{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI3OTM5NTE0", "number": 8090, "reviewThreads": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMDo1ODoxOFrOE9lYnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQxMzo1OToyOFrOFWr_EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMDExMTAzOnYy", "diffSide": "RIGHT", "path": ".travis.yml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMDo1ODoxOFrOH6WV9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMDo1ODoxOFrOH6WV9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDk0NTUyNg==", "bodyText": "rename to 'import' to be in-line with 'update'", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r530945526", "createdAt": "2020-11-26T10:58:18Z", "author": {"login": "pvannierop"}, "path": ".travis.yml", "diffHunk": "@@ -14,12 +14,14 @@ env:\n   matrix:\n   - MAVEN_VERSION=3.5.4 TEST=core\n   - MAVEN_VERSION=3.5.4 TEST=python-validator\n+  - MAVEN_VERSION=3.5.4 TEST=python-oncokb-importer", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32527dabdd6bd43a0696d551baed47d3cc92a3dd"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMDQ4NDM3OnYy", "diffSide": "RIGHT", "path": ".travis.yml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMjo0MjoxMVrOH6Z3yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMjo0MjoxMVrOH6Z3yQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAwMzMzNw==", "bodyText": "cd - can be removed here. There is no code following.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r531003337", "createdAt": "2020-11-26T12:42:11Z", "author": {"login": "pvannierop"}, "path": ".travis.yml", "diffHunk": "@@ -115,10 +127,22 @@ script:\n           sleep 30s\n       done\n       [ -z \"$healthy\" ] && { echo \"Error starting cBioPortal services.\"; exit 1; } || echo \"Successful deploy.\"\n+  fi\n+- |\n+  if [[ \"${TEST}\" == integration-test-load-study ]]\n+  then\n+    # load gene panels and study_es_0\n+    bash ../test/integration/test_load_study.sh\n \n-      # load gene panels and study_es_0\n-      bash ../test/integration/test_load_study.sh\n+    # back to main dir\n+    cd -", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32527dabdd6bd43a0696d551baed47d3cc92a3dd"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMDQ4NDY3OnYy", "diffSide": "RIGHT", "path": ".travis.yml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMjo0MjoxNlrOH6Z39w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMjo0MjoxNlrOH6Z39w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAwMzM4Mw==", "bodyText": "cd - can be removed here. There is no code following.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r531003383", "createdAt": "2020-11-26T12:42:16Z", "author": {"login": "pvannierop"}, "path": ".travis.yml", "diffHunk": "@@ -115,10 +127,22 @@ script:\n           sleep 30s\n       done\n       [ -z \"$healthy\" ] && { echo \"Error starting cBioPortal services.\"; exit 1; } || echo \"Successful deploy.\"\n+  fi\n+- |\n+  if [[ \"${TEST}\" == integration-test-load-study ]]\n+  then\n+    # load gene panels and study_es_0\n+    bash ../test/integration/test_load_study.sh\n \n-      # load gene panels and study_es_0\n-      bash ../test/integration/test_load_study.sh\n+    # back to main dir\n+    cd -\n+  fi\n+- |\n+  if [[ \"${TEST}\" == python-oncokb-update ]]\n+  then\n+    # update oncokb test\n+    bash ../test/integration/test_update_oncokb.sh\n \n-      # back to main dir\n-      cd -\n+    # back to main dir\n+    cd -", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32527dabdd6bd43a0696d551baed47d3cc92a3dd"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMDUzNDg4OnYy", "diffSide": "RIGHT", "path": "test/integration/test_update_oncokb.sh", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMjo1NjozN1rOH6aWCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMjo1NjozN1rOH6aWCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAxMTA4MQ==", "bodyText": "Add remark that this depends on the version of oncokb.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r531011081", "createdAt": "2020-11-26T12:56:37Z", "author": {"login": "pvannierop"}, "path": "test/integration/test_update_oncokb.sh", "diffHunk": "@@ -0,0 +1,23 @@\n+#!/bin/bash\n+\n+# exit when any of these fails\n+set -e\n+\n+run_in_service() {\n+    service=$1\n+    shift\n+    docker-compose -f docker-compose.yml -f ../test/integration/docker-compose-localbuild.yml \\\n+        run --rm \\\n+        \"$service\" bash -c \"$@\"\n+}\n+\n+# load study_es_0 using API validation\n+echo \"Testing update of OncoKB annotations...\"\n+run_in_service cbioportal 'metaImport.py -v -u http://cbioportal:8080 -o -s /cbioportal/core/src/test/scripts/test_data/study_oncokb_update/'\n+\n+# execute updateOncokb script\n+run_in_service cbioportal 'python3 /cbioportal/core/src/main/scripts/importer/updateOncokbAnnotations.py -s study_es_0 -p /cbioportal/portal.properties'\n+\n+# Check that mutation annotations have been updated\n+# 4 annotations should be changed to \"Putative_Driver\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32527dabdd6bd43a0696d551baed47d3cc92a3dd"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTI1NDMzOnYy", "diffSide": "RIGHT", "path": ".travis.yml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxOTowMDo0N1rOH_d9kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QwNzozNjo0OVrOIPh6QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMxMzIzMw==", "bodyText": "we've had some issues using Travis recently (it's very slow), would be better to use CircleCI or github actions in the future. Thanks for adding this test tho!", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r536313233", "createdAt": "2020-12-04T19:00:47Z", "author": {"login": "inodb"}, "path": ".travis.yml", "diffHunk": "@@ -14,12 +14,14 @@ env:\n   matrix:\n   - MAVEN_VERSION=3.5.4 TEST=core\n   - MAVEN_VERSION=3.5.4 TEST=python-validator\n+  - MAVEN_VERSION=3.5.4 TEST=python-oncokb-import\n+  - MAVEN_VERSION=3.5.4 TEST=python-oncokb-update\n   - MAVEN_VERSION=3.5.4 TEST=sanity-checks\n   - MAVEN_VERSION=3.5.4 TEST=end-to-end\n   - MAVEN_VERSION=3.5.4 TEST=integration-test-load-study\n install:\n - |\n-  if [[ \"${TEST}\" == core || \"${TEST}\" == end-to-end  || \"${TEST}\" == integration-test-load-study ]]\n+  if [[ \"${TEST}\" == core || \"${TEST}\" == end-to-end  || \"${TEST}\" == integration-test-load-study || \"${TEST}\" == python-oncokb-update  ]]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE1NTEzNg==", "bodyText": "Ok, thnx.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r553155136", "createdAt": "2021-01-07T07:36:49Z", "author": {"login": "pvannierop"}, "path": ".travis.yml", "diffHunk": "@@ -14,12 +14,14 @@ env:\n   matrix:\n   - MAVEN_VERSION=3.5.4 TEST=core\n   - MAVEN_VERSION=3.5.4 TEST=python-validator\n+  - MAVEN_VERSION=3.5.4 TEST=python-oncokb-import\n+  - MAVEN_VERSION=3.5.4 TEST=python-oncokb-update\n   - MAVEN_VERSION=3.5.4 TEST=sanity-checks\n   - MAVEN_VERSION=3.5.4 TEST=end-to-end\n   - MAVEN_VERSION=3.5.4 TEST=integration-test-load-study\n install:\n - |\n-  if [[ \"${TEST}\" == core || \"${TEST}\" == end-to-end  || \"${TEST}\" == integration-test-load-study ]]\n+  if [[ \"${TEST}\" == core || \"${TEST}\" == end-to-end  || \"${TEST}\" == integration-test-load-study || \"${TEST}\" == python-oncokb-update  ]]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMxMzIzMw=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTM5OTAwOnYy", "diffSide": "RIGHT", "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxOTozNjoxOVrOH_fP_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMDoxNTowM1rOIAfZmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMzNDMzMw==", "bodyText": "This method has been duplicated twice.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r536334333", "createdAt": "2020-12-04T19:36:19Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:\n+                continue\n+            feature['copyNameAlterationType'] = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(feature['alteration'])]\n+            for column_name, index in header_indexes.items():\n+                value = line_elements[index]\n+                if value != '':\n+                    feature[column_name] = value\n+                elif column_name != 'Entrez_Gene_Id':\n+                    print(Color.RED + \"Empty value encounterd in column '\" + column_name + \"' in row \" + str(\n+                        row_counter) + \". OncoKb annotations cannot be imported. Please fix and rerun.\" + Color.END,\n+                          file=sys.stderr)\n+                    print(\"!\" * 71, file=sys.stderr)\n+                    sys.exit(1)\n+\n+            # resolve gene symbols to Entrez Ids if needed\n+            if 'Entrez_Gene_Id' in feature and feature['Entrez_Gene_Id'] is not None and feature[\n+                'Entrez_Gene_Id'] != '':\n+                entrez_gene_ids = [feature['Entrez_Gene_Id']]\n+            else:\n+                entrez_gene_ids = portal_instance.hugo_entrez_map[feature['Hugo_Symbol']]\n+\n+            if len(entrez_gene_ids) > 1:\n+                logger.error(\"Multiple Entrez gene ids were found for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            elif len(entrez_gene_ids) == 0:\n+                logger.error(\"Could not find the Entrez gene id for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            else:\n+                feature['Entrez_Gene_Id'] = str(entrez_gene_ids[0])\n+                feature['id'] = \"_\".join([feature['Entrez_Gene_Id'], feature['copyNameAlterationType']])\n+\n+            features.append(feature)\n+    cna_file.close()\n+    print(\" DONE\")\n+    return features\n+\n+\n+def fetch_oncokb_annotations(features):\n+    \"\"\"Submit CNA events to OncoKB.org and return OncoKB annotations.\"\"\"\n+    id_to_annotation = {}\n+    payload_list = create_request_payload(features)\n+    annotations = libImportOncokb.fetch_oncokb_annotations(payload_list, \"https://public.api.oncokb.org/api/v1/annotate/copyNumberAlterations\")\n+    for annotation in annotations:\n+        id = annotation['query']['id']\n+        id_to_annotation[id] = annotation\n+    return id_to_annotation\n+\n+\n+def create_request_payload(features):\n+    \"\"\"Translate CNA events into JSON for message body.\"\"\"\n+    elements = {}\n+    for feature in features:\n+        elements[feature[\n+            'id']] = '{ \"copyNameAlterationType\":\"%s\", \"gene\":{\"entrezGeneId\":%s}, \"id\":\"%s\", \"tumorType\":null} ' \\\n+                     % (feature['copyNameAlterationType'], feature['Entrez_Gene_Id'], feature['id'])\n+    # normalize for alteration id since same alteration is represented in multiple samples\n+    return list(elements.values())\n+\n+\n+def update_cna_metafile(meta_cna_file_path, pd_file_name):\n+    \"\"\"Add reference to pd annotation file to CNA meta file.\"\"\"\n+    meta_file = open(meta_cna_file_path, \"r\")\n+    lines = meta_file.readlines()\n+    meta_file.close()\n+    meta_file_name = os.path.basename(meta_cna_file_path)\n+    dir = os.path.dirname(meta_cna_file_path)\n+    os.rename(meta_cna_file_path, os.path.join(dir, 'ONCOKB_IMPORT_BACKUP_' + meta_file_name))\n+    if lines[-1] == '\\n':\n+        lines = lines[:-1]\n+    meta_file = open(meta_cna_file_path, \"w\")\n+    for line in lines:\n+        meta_file.write(line)\n+    meta_file.write('pd_annotations_filename: ' + pd_file_name + '\\n')\n+    meta_file.close()\n+\n+\n+def write_annotations_to_file(features, pd_file_name):\n+    \"\"\"Write CNA pd annotations to data file.\"\"\"\n+    new_file = open(pd_file_name, \"w\")\n+    new_file.write(\"SAMPLE_ID\\tEntrez_Gene_Id\\tcbp_driver\\tcbp_driver_annotation\\tcbp_driver_tiers\\tcbp_driver_tiers_annotation\\n\")\n+    for feature in features:\n+        if 'oncogenic' in feature:\n+            line = \"\\t\".join(\n+                [feature['sample_id'], feature['Entrez_Gene_Id'], libImportOncokb.evaluate_driver_passenger(feature['oncogenic']),\n+                feature['oncogenic'], '', '']) + \"\\n\"\n+            new_file.write(line)\n+    new_file.close()\n+\n+\n+def check_required_columns(header_elements):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM4NTM2OA==", "bodyText": "Fixed", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r537385368", "createdAt": "2020-12-07T10:15:03Z", "author": {"login": "oplantalech"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:\n+                continue\n+            feature['copyNameAlterationType'] = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(feature['alteration'])]\n+            for column_name, index in header_indexes.items():\n+                value = line_elements[index]\n+                if value != '':\n+                    feature[column_name] = value\n+                elif column_name != 'Entrez_Gene_Id':\n+                    print(Color.RED + \"Empty value encounterd in column '\" + column_name + \"' in row \" + str(\n+                        row_counter) + \". OncoKb annotations cannot be imported. Please fix and rerun.\" + Color.END,\n+                          file=sys.stderr)\n+                    print(\"!\" * 71, file=sys.stderr)\n+                    sys.exit(1)\n+\n+            # resolve gene symbols to Entrez Ids if needed\n+            if 'Entrez_Gene_Id' in feature and feature['Entrez_Gene_Id'] is not None and feature[\n+                'Entrez_Gene_Id'] != '':\n+                entrez_gene_ids = [feature['Entrez_Gene_Id']]\n+            else:\n+                entrez_gene_ids = portal_instance.hugo_entrez_map[feature['Hugo_Symbol']]\n+\n+            if len(entrez_gene_ids) > 1:\n+                logger.error(\"Multiple Entrez gene ids were found for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            elif len(entrez_gene_ids) == 0:\n+                logger.error(\"Could not find the Entrez gene id for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            else:\n+                feature['Entrez_Gene_Id'] = str(entrez_gene_ids[0])\n+                feature['id'] = \"_\".join([feature['Entrez_Gene_Id'], feature['copyNameAlterationType']])\n+\n+            features.append(feature)\n+    cna_file.close()\n+    print(\" DONE\")\n+    return features\n+\n+\n+def fetch_oncokb_annotations(features):\n+    \"\"\"Submit CNA events to OncoKB.org and return OncoKB annotations.\"\"\"\n+    id_to_annotation = {}\n+    payload_list = create_request_payload(features)\n+    annotations = libImportOncokb.fetch_oncokb_annotations(payload_list, \"https://public.api.oncokb.org/api/v1/annotate/copyNumberAlterations\")\n+    for annotation in annotations:\n+        id = annotation['query']['id']\n+        id_to_annotation[id] = annotation\n+    return id_to_annotation\n+\n+\n+def create_request_payload(features):\n+    \"\"\"Translate CNA events into JSON for message body.\"\"\"\n+    elements = {}\n+    for feature in features:\n+        elements[feature[\n+            'id']] = '{ \"copyNameAlterationType\":\"%s\", \"gene\":{\"entrezGeneId\":%s}, \"id\":\"%s\", \"tumorType\":null} ' \\\n+                     % (feature['copyNameAlterationType'], feature['Entrez_Gene_Id'], feature['id'])\n+    # normalize for alteration id since same alteration is represented in multiple samples\n+    return list(elements.values())\n+\n+\n+def update_cna_metafile(meta_cna_file_path, pd_file_name):\n+    \"\"\"Add reference to pd annotation file to CNA meta file.\"\"\"\n+    meta_file = open(meta_cna_file_path, \"r\")\n+    lines = meta_file.readlines()\n+    meta_file.close()\n+    meta_file_name = os.path.basename(meta_cna_file_path)\n+    dir = os.path.dirname(meta_cna_file_path)\n+    os.rename(meta_cna_file_path, os.path.join(dir, 'ONCOKB_IMPORT_BACKUP_' + meta_file_name))\n+    if lines[-1] == '\\n':\n+        lines = lines[:-1]\n+    meta_file = open(meta_cna_file_path, \"w\")\n+    for line in lines:\n+        meta_file.write(line)\n+    meta_file.write('pd_annotations_filename: ' + pd_file_name + '\\n')\n+    meta_file.close()\n+\n+\n+def write_annotations_to_file(features, pd_file_name):\n+    \"\"\"Write CNA pd annotations to data file.\"\"\"\n+    new_file = open(pd_file_name, \"w\")\n+    new_file.write(\"SAMPLE_ID\\tEntrez_Gene_Id\\tcbp_driver\\tcbp_driver_annotation\\tcbp_driver_tiers\\tcbp_driver_tiers_annotation\\n\")\n+    for feature in features:\n+        if 'oncogenic' in feature:\n+            line = \"\\t\".join(\n+                [feature['sample_id'], feature['Entrez_Gene_Id'], libImportOncokb.evaluate_driver_passenger(feature['oncogenic']),\n+                feature['oncogenic'], '', '']) + \"\\n\"\n+            new_file.write(line)\n+    new_file.close()\n+\n+\n+def check_required_columns(header_elements):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMzNDMzMw=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 252}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTQwMzY0OnYy", "diffSide": "RIGHT", "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxOTozNzoyOFrOH_fShw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQxMzo1NDo1NlrOIX3hSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMzNDk4Mw==", "bodyText": "Do you want to put this into util method? It's duplicated.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r536334983", "createdAt": "2020-12-04T19:37:28Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:\n+                continue\n+            feature['copyNameAlterationType'] = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(feature['alteration'])]\n+            for column_name, index in header_indexes.items():\n+                value = line_elements[index]\n+                if value != '':\n+                    feature[column_name] = value\n+                elif column_name != 'Entrez_Gene_Id':\n+                    print(Color.RED + \"Empty value encounterd in column '\" + column_name + \"' in row \" + str(\n+                        row_counter) + \". OncoKb annotations cannot be imported. Please fix and rerun.\" + Color.END,\n+                          file=sys.stderr)\n+                    print(\"!\" * 71, file=sys.stderr)\n+                    sys.exit(1)\n+\n+            # resolve gene symbols to Entrez Ids if needed\n+            if 'Entrez_Gene_Id' in feature and feature['Entrez_Gene_Id'] is not None and feature[\n+                'Entrez_Gene_Id'] != '':\n+                entrez_gene_ids = [feature['Entrez_Gene_Id']]\n+            else:\n+                entrez_gene_ids = portal_instance.hugo_entrez_map[feature['Hugo_Symbol']]\n+\n+            if len(entrez_gene_ids) > 1:\n+                logger.error(\"Multiple Entrez gene ids were found for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            elif len(entrez_gene_ids) == 0:\n+                logger.error(\"Could not find the Entrez gene id for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            else:\n+                feature['Entrez_Gene_Id'] = str(entrez_gene_ids[0])\n+                feature['id'] = \"_\".join([feature['Entrez_Gene_Id'], feature['copyNameAlterationType']])\n+\n+            features.append(feature)\n+    cna_file.close()\n+    print(\" DONE\")\n+    return features\n+\n+\n+def fetch_oncokb_annotations(features):\n+    \"\"\"Submit CNA events to OncoKB.org and return OncoKB annotations.\"\"\"\n+    id_to_annotation = {}\n+    payload_list = create_request_payload(features)\n+    annotations = libImportOncokb.fetch_oncokb_annotations(payload_list, \"https://public.api.oncokb.org/api/v1/annotate/copyNumberAlterations\")\n+    for annotation in annotations:\n+        id = annotation['query']['id']\n+        id_to_annotation[id] = annotation\n+    return id_to_annotation\n+\n+\n+def create_request_payload(features):\n+    \"\"\"Translate CNA events into JSON for message body.\"\"\"\n+    elements = {}\n+    for feature in features:\n+        elements[feature[\n+            'id']] = '{ \"copyNameAlterationType\":\"%s\", \"gene\":{\"entrezGeneId\":%s}, \"id\":\"%s\", \"tumorType\":null} ' \\\n+                     % (feature['copyNameAlterationType'], feature['Entrez_Gene_Id'], feature['id'])\n+    # normalize for alteration id since same alteration is represented in multiple samples\n+    return list(elements.values())\n+\n+\n+def update_cna_metafile(meta_cna_file_path, pd_file_name):\n+    \"\"\"Add reference to pd annotation file to CNA meta file.\"\"\"\n+    meta_file = open(meta_cna_file_path, \"r\")\n+    lines = meta_file.readlines()\n+    meta_file.close()\n+    meta_file_name = os.path.basename(meta_cna_file_path)\n+    dir = os.path.dirname(meta_cna_file_path)\n+    os.rename(meta_cna_file_path, os.path.join(dir, 'ONCOKB_IMPORT_BACKUP_' + meta_file_name))\n+    if lines[-1] == '\\n':\n+        lines = lines[:-1]\n+    meta_file = open(meta_cna_file_path, \"w\")\n+    for line in lines:\n+        meta_file.write(line)\n+    meta_file.write('pd_annotations_filename: ' + pd_file_name + '\\n')\n+    meta_file.close()\n+\n+\n+def write_annotations_to_file(features, pd_file_name):\n+    \"\"\"Write CNA pd annotations to data file.\"\"\"\n+    new_file = open(pd_file_name, \"w\")\n+    new_file.write(\"SAMPLE_ID\\tEntrez_Gene_Id\\tcbp_driver\\tcbp_driver_annotation\\tcbp_driver_tiers\\tcbp_driver_tiers_annotation\\n\")\n+    for feature in features:\n+        if 'oncogenic' in feature:\n+            line = \"\\t\".join(\n+                [feature['sample_id'], feature['Entrez_Gene_Id'], libImportOncokb.evaluate_driver_passenger(feature['oncogenic']),\n+                feature['oncogenic'], '', '']) + \"\\n\"\n+            new_file.write(line)\n+    new_file.close()\n+\n+\n+def check_required_columns(header_elements):\n+    missing_columns = []\n+    for required_column in required_cna_columns:\n+        if not required_column in header_elements:\n+            missing_columns.append(required_column)\n+    if len(missing_columns) > 0:\n+        raise RuntimeError(\"One or more required columns for OncoKb import are missing from the discrete CNA file. \" \\\n+                           \"Missing column(s): [\" + \", \".join(missing_columns) + \"]\")\n+\n+\n+def interface():\n+    parser = argparse.ArgumentParser(description='cBioPortal OncoKB annotation importer')\n+    parser.add_argument('-u', '--url_server',\n+                        type=str,\n+                        default='http://localhost:8080',\n+                        help='URL to cBioPortal server. You can '\n+                             'set this if your URL is not '\n+                             'http://localhost:8080')\n+    parser.add_argument('-m', '--study_directory', type=str, required=True,\n+                        help='path to study directory.')\n+    parser = parser.parse_args()\n+    return parser\n+\n+\n+if __name__ == '__main__':\n+    try:\n+        parsed_args = interface()\n+        exit_status = main_import(parsed_args)\n+    finally:\n+        logging.shutdown()\n+        del logging._handlerList[:]  # workaround for harmless exceptions on exit\n+    print(('Import of OncoKB annotations for discrete CNA {status}.'.format(\n+        status={0: 'succeeded',\n+                1: 'failed',\n+                2: 'not performed as problems occurred',\n+                3: 'succeeded with warnings'}.get(exit_status, 'unknown'))), file=sys.stderr)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE1NzcxMw==", "bodyText": "Eh, where is it duplicated? You mean between the CNA and mutation importer files?", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r553157713", "createdAt": "2021-01-07T07:43:58Z", "author": {"login": "pvannierop"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:\n+                continue\n+            feature['copyNameAlterationType'] = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(feature['alteration'])]\n+            for column_name, index in header_indexes.items():\n+                value = line_elements[index]\n+                if value != '':\n+                    feature[column_name] = value\n+                elif column_name != 'Entrez_Gene_Id':\n+                    print(Color.RED + \"Empty value encounterd in column '\" + column_name + \"' in row \" + str(\n+                        row_counter) + \". OncoKb annotations cannot be imported. Please fix and rerun.\" + Color.END,\n+                          file=sys.stderr)\n+                    print(\"!\" * 71, file=sys.stderr)\n+                    sys.exit(1)\n+\n+            # resolve gene symbols to Entrez Ids if needed\n+            if 'Entrez_Gene_Id' in feature and feature['Entrez_Gene_Id'] is not None and feature[\n+                'Entrez_Gene_Id'] != '':\n+                entrez_gene_ids = [feature['Entrez_Gene_Id']]\n+            else:\n+                entrez_gene_ids = portal_instance.hugo_entrez_map[feature['Hugo_Symbol']]\n+\n+            if len(entrez_gene_ids) > 1:\n+                logger.error(\"Multiple Entrez gene ids were found for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            elif len(entrez_gene_ids) == 0:\n+                logger.error(\"Could not find the Entrez gene id for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            else:\n+                feature['Entrez_Gene_Id'] = str(entrez_gene_ids[0])\n+                feature['id'] = \"_\".join([feature['Entrez_Gene_Id'], feature['copyNameAlterationType']])\n+\n+            features.append(feature)\n+    cna_file.close()\n+    print(\" DONE\")\n+    return features\n+\n+\n+def fetch_oncokb_annotations(features):\n+    \"\"\"Submit CNA events to OncoKB.org and return OncoKB annotations.\"\"\"\n+    id_to_annotation = {}\n+    payload_list = create_request_payload(features)\n+    annotations = libImportOncokb.fetch_oncokb_annotations(payload_list, \"https://public.api.oncokb.org/api/v1/annotate/copyNumberAlterations\")\n+    for annotation in annotations:\n+        id = annotation['query']['id']\n+        id_to_annotation[id] = annotation\n+    return id_to_annotation\n+\n+\n+def create_request_payload(features):\n+    \"\"\"Translate CNA events into JSON for message body.\"\"\"\n+    elements = {}\n+    for feature in features:\n+        elements[feature[\n+            'id']] = '{ \"copyNameAlterationType\":\"%s\", \"gene\":{\"entrezGeneId\":%s}, \"id\":\"%s\", \"tumorType\":null} ' \\\n+                     % (feature['copyNameAlterationType'], feature['Entrez_Gene_Id'], feature['id'])\n+    # normalize for alteration id since same alteration is represented in multiple samples\n+    return list(elements.values())\n+\n+\n+def update_cna_metafile(meta_cna_file_path, pd_file_name):\n+    \"\"\"Add reference to pd annotation file to CNA meta file.\"\"\"\n+    meta_file = open(meta_cna_file_path, \"r\")\n+    lines = meta_file.readlines()\n+    meta_file.close()\n+    meta_file_name = os.path.basename(meta_cna_file_path)\n+    dir = os.path.dirname(meta_cna_file_path)\n+    os.rename(meta_cna_file_path, os.path.join(dir, 'ONCOKB_IMPORT_BACKUP_' + meta_file_name))\n+    if lines[-1] == '\\n':\n+        lines = lines[:-1]\n+    meta_file = open(meta_cna_file_path, \"w\")\n+    for line in lines:\n+        meta_file.write(line)\n+    meta_file.write('pd_annotations_filename: ' + pd_file_name + '\\n')\n+    meta_file.close()\n+\n+\n+def write_annotations_to_file(features, pd_file_name):\n+    \"\"\"Write CNA pd annotations to data file.\"\"\"\n+    new_file = open(pd_file_name, \"w\")\n+    new_file.write(\"SAMPLE_ID\\tEntrez_Gene_Id\\tcbp_driver\\tcbp_driver_annotation\\tcbp_driver_tiers\\tcbp_driver_tiers_annotation\\n\")\n+    for feature in features:\n+        if 'oncogenic' in feature:\n+            line = \"\\t\".join(\n+                [feature['sample_id'], feature['Entrez_Gene_Id'], libImportOncokb.evaluate_driver_passenger(feature['oncogenic']),\n+                feature['oncogenic'], '', '']) + \"\\n\"\n+            new_file.write(line)\n+    new_file.close()\n+\n+\n+def check_required_columns(header_elements):\n+    missing_columns = []\n+    for required_column in required_cna_columns:\n+        if not required_column in header_elements:\n+            missing_columns.append(required_column)\n+    if len(missing_columns) > 0:\n+        raise RuntimeError(\"One or more required columns for OncoKb import are missing from the discrete CNA file. \" \\\n+                           \"Missing column(s): [\" + \", \".join(missing_columns) + \"]\")\n+\n+\n+def interface():\n+    parser = argparse.ArgumentParser(description='cBioPortal OncoKB annotation importer')\n+    parser.add_argument('-u', '--url_server',\n+                        type=str,\n+                        default='http://localhost:8080',\n+                        help='URL to cBioPortal server. You can '\n+                             'set this if your URL is not '\n+                             'http://localhost:8080')\n+    parser.add_argument('-m', '--study_directory', type=str, required=True,\n+                        help='path to study directory.')\n+    parser = parser.parse_args()\n+    return parser\n+\n+\n+if __name__ == '__main__':\n+    try:\n+        parsed_args = interface()\n+        exit_status = main_import(parsed_args)\n+    finally:\n+        logging.shutdown()\n+        del logging._handlerList[:]  # workaround for harmless exceptions on exit\n+    print(('Import of OncoKB annotations for discrete CNA {status}.'.format(\n+        status={0: 'succeeded',\n+                1: 'failed',\n+                2: 'not performed as problems occurred',\n+                3: 'succeeded with warnings'}.get(exit_status, 'unknown'))), file=sys.stderr)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMzNDk4Mw=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDAyNzQ0OA==", "bodyText": "@pvannierop yeah, my main concern for this pr is the duplication between CNA and mutation files. But it could be too much trouble to share the logics between two. Let me know what you think.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r554027448", "createdAt": "2021-01-08T15:54:43Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:\n+                continue\n+            feature['copyNameAlterationType'] = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(feature['alteration'])]\n+            for column_name, index in header_indexes.items():\n+                value = line_elements[index]\n+                if value != '':\n+                    feature[column_name] = value\n+                elif column_name != 'Entrez_Gene_Id':\n+                    print(Color.RED + \"Empty value encounterd in column '\" + column_name + \"' in row \" + str(\n+                        row_counter) + \". OncoKb annotations cannot be imported. Please fix and rerun.\" + Color.END,\n+                          file=sys.stderr)\n+                    print(\"!\" * 71, file=sys.stderr)\n+                    sys.exit(1)\n+\n+            # resolve gene symbols to Entrez Ids if needed\n+            if 'Entrez_Gene_Id' in feature and feature['Entrez_Gene_Id'] is not None and feature[\n+                'Entrez_Gene_Id'] != '':\n+                entrez_gene_ids = [feature['Entrez_Gene_Id']]\n+            else:\n+                entrez_gene_ids = portal_instance.hugo_entrez_map[feature['Hugo_Symbol']]\n+\n+            if len(entrez_gene_ids) > 1:\n+                logger.error(\"Multiple Entrez gene ids were found for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            elif len(entrez_gene_ids) == 0:\n+                logger.error(\"Could not find the Entrez gene id for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            else:\n+                feature['Entrez_Gene_Id'] = str(entrez_gene_ids[0])\n+                feature['id'] = \"_\".join([feature['Entrez_Gene_Id'], feature['copyNameAlterationType']])\n+\n+            features.append(feature)\n+    cna_file.close()\n+    print(\" DONE\")\n+    return features\n+\n+\n+def fetch_oncokb_annotations(features):\n+    \"\"\"Submit CNA events to OncoKB.org and return OncoKB annotations.\"\"\"\n+    id_to_annotation = {}\n+    payload_list = create_request_payload(features)\n+    annotations = libImportOncokb.fetch_oncokb_annotations(payload_list, \"https://public.api.oncokb.org/api/v1/annotate/copyNumberAlterations\")\n+    for annotation in annotations:\n+        id = annotation['query']['id']\n+        id_to_annotation[id] = annotation\n+    return id_to_annotation\n+\n+\n+def create_request_payload(features):\n+    \"\"\"Translate CNA events into JSON for message body.\"\"\"\n+    elements = {}\n+    for feature in features:\n+        elements[feature[\n+            'id']] = '{ \"copyNameAlterationType\":\"%s\", \"gene\":{\"entrezGeneId\":%s}, \"id\":\"%s\", \"tumorType\":null} ' \\\n+                     % (feature['copyNameAlterationType'], feature['Entrez_Gene_Id'], feature['id'])\n+    # normalize for alteration id since same alteration is represented in multiple samples\n+    return list(elements.values())\n+\n+\n+def update_cna_metafile(meta_cna_file_path, pd_file_name):\n+    \"\"\"Add reference to pd annotation file to CNA meta file.\"\"\"\n+    meta_file = open(meta_cna_file_path, \"r\")\n+    lines = meta_file.readlines()\n+    meta_file.close()\n+    meta_file_name = os.path.basename(meta_cna_file_path)\n+    dir = os.path.dirname(meta_cna_file_path)\n+    os.rename(meta_cna_file_path, os.path.join(dir, 'ONCOKB_IMPORT_BACKUP_' + meta_file_name))\n+    if lines[-1] == '\\n':\n+        lines = lines[:-1]\n+    meta_file = open(meta_cna_file_path, \"w\")\n+    for line in lines:\n+        meta_file.write(line)\n+    meta_file.write('pd_annotations_filename: ' + pd_file_name + '\\n')\n+    meta_file.close()\n+\n+\n+def write_annotations_to_file(features, pd_file_name):\n+    \"\"\"Write CNA pd annotations to data file.\"\"\"\n+    new_file = open(pd_file_name, \"w\")\n+    new_file.write(\"SAMPLE_ID\\tEntrez_Gene_Id\\tcbp_driver\\tcbp_driver_annotation\\tcbp_driver_tiers\\tcbp_driver_tiers_annotation\\n\")\n+    for feature in features:\n+        if 'oncogenic' in feature:\n+            line = \"\\t\".join(\n+                [feature['sample_id'], feature['Entrez_Gene_Id'], libImportOncokb.evaluate_driver_passenger(feature['oncogenic']),\n+                feature['oncogenic'], '', '']) + \"\\n\"\n+            new_file.write(line)\n+    new_file.close()\n+\n+\n+def check_required_columns(header_elements):\n+    missing_columns = []\n+    for required_column in required_cna_columns:\n+        if not required_column in header_elements:\n+            missing_columns.append(required_column)\n+    if len(missing_columns) > 0:\n+        raise RuntimeError(\"One or more required columns for OncoKb import are missing from the discrete CNA file. \" \\\n+                           \"Missing column(s): [\" + \", \".join(missing_columns) + \"]\")\n+\n+\n+def interface():\n+    parser = argparse.ArgumentParser(description='cBioPortal OncoKB annotation importer')\n+    parser.add_argument('-u', '--url_server',\n+                        type=str,\n+                        default='http://localhost:8080',\n+                        help='URL to cBioPortal server. You can '\n+                             'set this if your URL is not '\n+                             'http://localhost:8080')\n+    parser.add_argument('-m', '--study_directory', type=str, required=True,\n+                        help='path to study directory.')\n+    parser = parser.parse_args()\n+    return parser\n+\n+\n+if __name__ == '__main__':\n+    try:\n+        parsed_args = interface()\n+        exit_status = main_import(parsed_args)\n+    finally:\n+        logging.shutdown()\n+        del logging._handlerList[:]  # workaround for harmless exceptions on exit\n+    print(('Import of OncoKB annotations for discrete CNA {status}.'.format(\n+        status={0: 'succeeded',\n+                1: 'failed',\n+                2: 'not performed as problems occurred',\n+                3: 'succeeded with warnings'}.get(exit_status, 'unknown'))), file=sys.stderr)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMzNDk4Mw=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMjQ5MQ==", "bodyText": "Well, i agree that every script has some boilerplate logic that it needs to check arguments, setup logging etc. But what is it that you propose exactly? Do you think it is better to merge the mutation and CNA import scripts into a single script so that the code redundancy is removed? I personally like the fact that the logic is in different files. I have moved the interface() method to the lib file so that both scripts share this code. Is that Ok with you?", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r554312491", "createdAt": "2021-01-09T08:58:28Z", "author": {"login": "pvannierop"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:\n+                continue\n+            feature['copyNameAlterationType'] = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(feature['alteration'])]\n+            for column_name, index in header_indexes.items():\n+                value = line_elements[index]\n+                if value != '':\n+                    feature[column_name] = value\n+                elif column_name != 'Entrez_Gene_Id':\n+                    print(Color.RED + \"Empty value encounterd in column '\" + column_name + \"' in row \" + str(\n+                        row_counter) + \". OncoKb annotations cannot be imported. Please fix and rerun.\" + Color.END,\n+                          file=sys.stderr)\n+                    print(\"!\" * 71, file=sys.stderr)\n+                    sys.exit(1)\n+\n+            # resolve gene symbols to Entrez Ids if needed\n+            if 'Entrez_Gene_Id' in feature and feature['Entrez_Gene_Id'] is not None and feature[\n+                'Entrez_Gene_Id'] != '':\n+                entrez_gene_ids = [feature['Entrez_Gene_Id']]\n+            else:\n+                entrez_gene_ids = portal_instance.hugo_entrez_map[feature['Hugo_Symbol']]\n+\n+            if len(entrez_gene_ids) > 1:\n+                logger.error(\"Multiple Entrez gene ids were found for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            elif len(entrez_gene_ids) == 0:\n+                logger.error(\"Could not find the Entrez gene id for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            else:\n+                feature['Entrez_Gene_Id'] = str(entrez_gene_ids[0])\n+                feature['id'] = \"_\".join([feature['Entrez_Gene_Id'], feature['copyNameAlterationType']])\n+\n+            features.append(feature)\n+    cna_file.close()\n+    print(\" DONE\")\n+    return features\n+\n+\n+def fetch_oncokb_annotations(features):\n+    \"\"\"Submit CNA events to OncoKB.org and return OncoKB annotations.\"\"\"\n+    id_to_annotation = {}\n+    payload_list = create_request_payload(features)\n+    annotations = libImportOncokb.fetch_oncokb_annotations(payload_list, \"https://public.api.oncokb.org/api/v1/annotate/copyNumberAlterations\")\n+    for annotation in annotations:\n+        id = annotation['query']['id']\n+        id_to_annotation[id] = annotation\n+    return id_to_annotation\n+\n+\n+def create_request_payload(features):\n+    \"\"\"Translate CNA events into JSON for message body.\"\"\"\n+    elements = {}\n+    for feature in features:\n+        elements[feature[\n+            'id']] = '{ \"copyNameAlterationType\":\"%s\", \"gene\":{\"entrezGeneId\":%s}, \"id\":\"%s\", \"tumorType\":null} ' \\\n+                     % (feature['copyNameAlterationType'], feature['Entrez_Gene_Id'], feature['id'])\n+    # normalize for alteration id since same alteration is represented in multiple samples\n+    return list(elements.values())\n+\n+\n+def update_cna_metafile(meta_cna_file_path, pd_file_name):\n+    \"\"\"Add reference to pd annotation file to CNA meta file.\"\"\"\n+    meta_file = open(meta_cna_file_path, \"r\")\n+    lines = meta_file.readlines()\n+    meta_file.close()\n+    meta_file_name = os.path.basename(meta_cna_file_path)\n+    dir = os.path.dirname(meta_cna_file_path)\n+    os.rename(meta_cna_file_path, os.path.join(dir, 'ONCOKB_IMPORT_BACKUP_' + meta_file_name))\n+    if lines[-1] == '\\n':\n+        lines = lines[:-1]\n+    meta_file = open(meta_cna_file_path, \"w\")\n+    for line in lines:\n+        meta_file.write(line)\n+    meta_file.write('pd_annotations_filename: ' + pd_file_name + '\\n')\n+    meta_file.close()\n+\n+\n+def write_annotations_to_file(features, pd_file_name):\n+    \"\"\"Write CNA pd annotations to data file.\"\"\"\n+    new_file = open(pd_file_name, \"w\")\n+    new_file.write(\"SAMPLE_ID\\tEntrez_Gene_Id\\tcbp_driver\\tcbp_driver_annotation\\tcbp_driver_tiers\\tcbp_driver_tiers_annotation\\n\")\n+    for feature in features:\n+        if 'oncogenic' in feature:\n+            line = \"\\t\".join(\n+                [feature['sample_id'], feature['Entrez_Gene_Id'], libImportOncokb.evaluate_driver_passenger(feature['oncogenic']),\n+                feature['oncogenic'], '', '']) + \"\\n\"\n+            new_file.write(line)\n+    new_file.close()\n+\n+\n+def check_required_columns(header_elements):\n+    missing_columns = []\n+    for required_column in required_cna_columns:\n+        if not required_column in header_elements:\n+            missing_columns.append(required_column)\n+    if len(missing_columns) > 0:\n+        raise RuntimeError(\"One or more required columns for OncoKb import are missing from the discrete CNA file. \" \\\n+                           \"Missing column(s): [\" + \", \".join(missing_columns) + \"]\")\n+\n+\n+def interface():\n+    parser = argparse.ArgumentParser(description='cBioPortal OncoKB annotation importer')\n+    parser.add_argument('-u', '--url_server',\n+                        type=str,\n+                        default='http://localhost:8080',\n+                        help='URL to cBioPortal server. You can '\n+                             'set this if your URL is not '\n+                             'http://localhost:8080')\n+    parser.add_argument('-m', '--study_directory', type=str, required=True,\n+                        help='path to study directory.')\n+    parser = parser.parse_args()\n+    return parser\n+\n+\n+if __name__ == '__main__':\n+    try:\n+        parsed_args = interface()\n+        exit_status = main_import(parsed_args)\n+    finally:\n+        logging.shutdown()\n+        del logging._handlerList[:]  # workaround for harmless exceptions on exit\n+    print(('Import of OncoKB annotations for discrete CNA {status}.'.format(\n+        status={0: 'succeeded',\n+                1: 'failed',\n+                2: 'not performed as problems occurred',\n+                3: 'succeeded with warnings'}.get(exit_status, 'unknown'))), file=sys.stderr)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMzNDk4Mw=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDMyNjI1Nw==", "bodyText": "My concern is not about the check arguments/setup logging but rather overall code duplications. But I think both you and Oleguer have updated this pr to fix that.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r560326257", "createdAt": "2021-01-19T16:49:49Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:\n+                continue\n+            feature['copyNameAlterationType'] = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(feature['alteration'])]\n+            for column_name, index in header_indexes.items():\n+                value = line_elements[index]\n+                if value != '':\n+                    feature[column_name] = value\n+                elif column_name != 'Entrez_Gene_Id':\n+                    print(Color.RED + \"Empty value encounterd in column '\" + column_name + \"' in row \" + str(\n+                        row_counter) + \". OncoKb annotations cannot be imported. Please fix and rerun.\" + Color.END,\n+                          file=sys.stderr)\n+                    print(\"!\" * 71, file=sys.stderr)\n+                    sys.exit(1)\n+\n+            # resolve gene symbols to Entrez Ids if needed\n+            if 'Entrez_Gene_Id' in feature and feature['Entrez_Gene_Id'] is not None and feature[\n+                'Entrez_Gene_Id'] != '':\n+                entrez_gene_ids = [feature['Entrez_Gene_Id']]\n+            else:\n+                entrez_gene_ids = portal_instance.hugo_entrez_map[feature['Hugo_Symbol']]\n+\n+            if len(entrez_gene_ids) > 1:\n+                logger.error(\"Multiple Entrez gene ids were found for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            elif len(entrez_gene_ids) == 0:\n+                logger.error(\"Could not find the Entrez gene id for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            else:\n+                feature['Entrez_Gene_Id'] = str(entrez_gene_ids[0])\n+                feature['id'] = \"_\".join([feature['Entrez_Gene_Id'], feature['copyNameAlterationType']])\n+\n+            features.append(feature)\n+    cna_file.close()\n+    print(\" DONE\")\n+    return features\n+\n+\n+def fetch_oncokb_annotations(features):\n+    \"\"\"Submit CNA events to OncoKB.org and return OncoKB annotations.\"\"\"\n+    id_to_annotation = {}\n+    payload_list = create_request_payload(features)\n+    annotations = libImportOncokb.fetch_oncokb_annotations(payload_list, \"https://public.api.oncokb.org/api/v1/annotate/copyNumberAlterations\")\n+    for annotation in annotations:\n+        id = annotation['query']['id']\n+        id_to_annotation[id] = annotation\n+    return id_to_annotation\n+\n+\n+def create_request_payload(features):\n+    \"\"\"Translate CNA events into JSON for message body.\"\"\"\n+    elements = {}\n+    for feature in features:\n+        elements[feature[\n+            'id']] = '{ \"copyNameAlterationType\":\"%s\", \"gene\":{\"entrezGeneId\":%s}, \"id\":\"%s\", \"tumorType\":null} ' \\\n+                     % (feature['copyNameAlterationType'], feature['Entrez_Gene_Id'], feature['id'])\n+    # normalize for alteration id since same alteration is represented in multiple samples\n+    return list(elements.values())\n+\n+\n+def update_cna_metafile(meta_cna_file_path, pd_file_name):\n+    \"\"\"Add reference to pd annotation file to CNA meta file.\"\"\"\n+    meta_file = open(meta_cna_file_path, \"r\")\n+    lines = meta_file.readlines()\n+    meta_file.close()\n+    meta_file_name = os.path.basename(meta_cna_file_path)\n+    dir = os.path.dirname(meta_cna_file_path)\n+    os.rename(meta_cna_file_path, os.path.join(dir, 'ONCOKB_IMPORT_BACKUP_' + meta_file_name))\n+    if lines[-1] == '\\n':\n+        lines = lines[:-1]\n+    meta_file = open(meta_cna_file_path, \"w\")\n+    for line in lines:\n+        meta_file.write(line)\n+    meta_file.write('pd_annotations_filename: ' + pd_file_name + '\\n')\n+    meta_file.close()\n+\n+\n+def write_annotations_to_file(features, pd_file_name):\n+    \"\"\"Write CNA pd annotations to data file.\"\"\"\n+    new_file = open(pd_file_name, \"w\")\n+    new_file.write(\"SAMPLE_ID\\tEntrez_Gene_Id\\tcbp_driver\\tcbp_driver_annotation\\tcbp_driver_tiers\\tcbp_driver_tiers_annotation\\n\")\n+    for feature in features:\n+        if 'oncogenic' in feature:\n+            line = \"\\t\".join(\n+                [feature['sample_id'], feature['Entrez_Gene_Id'], libImportOncokb.evaluate_driver_passenger(feature['oncogenic']),\n+                feature['oncogenic'], '', '']) + \"\\n\"\n+            new_file.write(line)\n+    new_file.close()\n+\n+\n+def check_required_columns(header_elements):\n+    missing_columns = []\n+    for required_column in required_cna_columns:\n+        if not required_column in header_elements:\n+            missing_columns.append(required_column)\n+    if len(missing_columns) > 0:\n+        raise RuntimeError(\"One or more required columns for OncoKb import are missing from the discrete CNA file. \" \\\n+                           \"Missing column(s): [\" + \", \".join(missing_columns) + \"]\")\n+\n+\n+def interface():\n+    parser = argparse.ArgumentParser(description='cBioPortal OncoKB annotation importer')\n+    parser.add_argument('-u', '--url_server',\n+                        type=str,\n+                        default='http://localhost:8080',\n+                        help='URL to cBioPortal server. You can '\n+                             'set this if your URL is not '\n+                             'http://localhost:8080')\n+    parser.add_argument('-m', '--study_directory', type=str, required=True,\n+                        help='path to study directory.')\n+    parser = parser.parse_args()\n+    return parser\n+\n+\n+if __name__ == '__main__':\n+    try:\n+        parsed_args = interface()\n+        exit_status = main_import(parsed_args)\n+    finally:\n+        logging.shutdown()\n+        del logging._handlerList[:]  # workaround for harmless exceptions on exit\n+    print(('Import of OncoKB annotations for discrete CNA {status}.'.format(\n+        status={0: 'succeeded',\n+                1: 'failed',\n+                2: 'not performed as problems occurred',\n+                3: 'succeeded with warnings'}.get(exit_status, 'unknown'))), file=sys.stderr)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMzNDk4Mw=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTg5NzgwMA==", "bodyText": "Ah yes, we have created a lib module that both scripts use.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r561897800", "createdAt": "2021-01-21T13:54:56Z", "author": {"login": "pvannierop"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:\n+                continue\n+            feature['copyNameAlterationType'] = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(feature['alteration'])]\n+            for column_name, index in header_indexes.items():\n+                value = line_elements[index]\n+                if value != '':\n+                    feature[column_name] = value\n+                elif column_name != 'Entrez_Gene_Id':\n+                    print(Color.RED + \"Empty value encounterd in column '\" + column_name + \"' in row \" + str(\n+                        row_counter) + \". OncoKb annotations cannot be imported. Please fix and rerun.\" + Color.END,\n+                          file=sys.stderr)\n+                    print(\"!\" * 71, file=sys.stderr)\n+                    sys.exit(1)\n+\n+            # resolve gene symbols to Entrez Ids if needed\n+            if 'Entrez_Gene_Id' in feature and feature['Entrez_Gene_Id'] is not None and feature[\n+                'Entrez_Gene_Id'] != '':\n+                entrez_gene_ids = [feature['Entrez_Gene_Id']]\n+            else:\n+                entrez_gene_ids = portal_instance.hugo_entrez_map[feature['Hugo_Symbol']]\n+\n+            if len(entrez_gene_ids) > 1:\n+                logger.error(\"Multiple Entrez gene ids were found for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            elif len(entrez_gene_ids) == 0:\n+                logger.error(\"Could not find the Entrez gene id for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            else:\n+                feature['Entrez_Gene_Id'] = str(entrez_gene_ids[0])\n+                feature['id'] = \"_\".join([feature['Entrez_Gene_Id'], feature['copyNameAlterationType']])\n+\n+            features.append(feature)\n+    cna_file.close()\n+    print(\" DONE\")\n+    return features\n+\n+\n+def fetch_oncokb_annotations(features):\n+    \"\"\"Submit CNA events to OncoKB.org and return OncoKB annotations.\"\"\"\n+    id_to_annotation = {}\n+    payload_list = create_request_payload(features)\n+    annotations = libImportOncokb.fetch_oncokb_annotations(payload_list, \"https://public.api.oncokb.org/api/v1/annotate/copyNumberAlterations\")\n+    for annotation in annotations:\n+        id = annotation['query']['id']\n+        id_to_annotation[id] = annotation\n+    return id_to_annotation\n+\n+\n+def create_request_payload(features):\n+    \"\"\"Translate CNA events into JSON for message body.\"\"\"\n+    elements = {}\n+    for feature in features:\n+        elements[feature[\n+            'id']] = '{ \"copyNameAlterationType\":\"%s\", \"gene\":{\"entrezGeneId\":%s}, \"id\":\"%s\", \"tumorType\":null} ' \\\n+                     % (feature['copyNameAlterationType'], feature['Entrez_Gene_Id'], feature['id'])\n+    # normalize for alteration id since same alteration is represented in multiple samples\n+    return list(elements.values())\n+\n+\n+def update_cna_metafile(meta_cna_file_path, pd_file_name):\n+    \"\"\"Add reference to pd annotation file to CNA meta file.\"\"\"\n+    meta_file = open(meta_cna_file_path, \"r\")\n+    lines = meta_file.readlines()\n+    meta_file.close()\n+    meta_file_name = os.path.basename(meta_cna_file_path)\n+    dir = os.path.dirname(meta_cna_file_path)\n+    os.rename(meta_cna_file_path, os.path.join(dir, 'ONCOKB_IMPORT_BACKUP_' + meta_file_name))\n+    if lines[-1] == '\\n':\n+        lines = lines[:-1]\n+    meta_file = open(meta_cna_file_path, \"w\")\n+    for line in lines:\n+        meta_file.write(line)\n+    meta_file.write('pd_annotations_filename: ' + pd_file_name + '\\n')\n+    meta_file.close()\n+\n+\n+def write_annotations_to_file(features, pd_file_name):\n+    \"\"\"Write CNA pd annotations to data file.\"\"\"\n+    new_file = open(pd_file_name, \"w\")\n+    new_file.write(\"SAMPLE_ID\\tEntrez_Gene_Id\\tcbp_driver\\tcbp_driver_annotation\\tcbp_driver_tiers\\tcbp_driver_tiers_annotation\\n\")\n+    for feature in features:\n+        if 'oncogenic' in feature:\n+            line = \"\\t\".join(\n+                [feature['sample_id'], feature['Entrez_Gene_Id'], libImportOncokb.evaluate_driver_passenger(feature['oncogenic']),\n+                feature['oncogenic'], '', '']) + \"\\n\"\n+            new_file.write(line)\n+    new_file.close()\n+\n+\n+def check_required_columns(header_elements):\n+    missing_columns = []\n+    for required_column in required_cna_columns:\n+        if not required_column in header_elements:\n+            missing_columns.append(required_column)\n+    if len(missing_columns) > 0:\n+        raise RuntimeError(\"One or more required columns for OncoKb import are missing from the discrete CNA file. \" \\\n+                           \"Missing column(s): [\" + \", \".join(missing_columns) + \"]\")\n+\n+\n+def interface():\n+    parser = argparse.ArgumentParser(description='cBioPortal OncoKB annotation importer')\n+    parser.add_argument('-u', '--url_server',\n+                        type=str,\n+                        default='http://localhost:8080',\n+                        help='URL to cBioPortal server. You can '\n+                             'set this if your URL is not '\n+                             'http://localhost:8080')\n+    parser.add_argument('-m', '--study_directory', type=str, required=True,\n+                        help='path to study directory.')\n+    parser = parser.parse_args()\n+    return parser\n+\n+\n+if __name__ == '__main__':\n+    try:\n+        parsed_args = interface()\n+        exit_status = main_import(parsed_args)\n+    finally:\n+        logging.shutdown()\n+        del logging._handlerList[:]  # workaround for harmless exceptions on exit\n+    print(('Import of OncoKB annotations for discrete CNA {status}.'.format(\n+        status={0: 'succeeded',\n+                1: 'failed',\n+                2: 'not performed as problems occurred',\n+                3: 'succeeded with warnings'}.get(exit_status, 'unknown'))), file=sys.stderr)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMzNDk4Mw=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 287}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTQxNDIzOnYy", "diffSide": "RIGHT", "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxOTo0MDoyMVrOH_fYtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QwNzo0NjoyNVrOIPiH1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMzNjU2NQ==", "bodyText": "Are we still doing the license declaration? I thought we had an effort to remove all of them. @n1zea144 @jjgao", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r536336565", "createdAt": "2020-12-04T19:40:21Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE1ODYxNQ==", "bodyText": "It seems that the license declarations are still in place in the scripts created by The Hyve (e.g. validateData.py). I propose to leave it in all scripts added in this PR.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r553158615", "createdAt": "2021-01-07T07:46:25Z", "author": {"login": "pvannierop"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMzNjU2NQ=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTQ0Njg3OnYy", "diffSide": "RIGHT", "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxOTo0OToyMFrOH_frtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QwNzo0ODoyMFrOIPiKuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM0MTQzMA==", "bodyText": "Should it call fetch_and_map_oncokb_annotations?", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r536341430", "createdAt": "2020-12-04T19:49:20Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:\n+                continue\n+            feature['copyNameAlterationType'] = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(feature['alteration'])]\n+            for column_name, index in header_indexes.items():\n+                value = line_elements[index]\n+                if value != '':\n+                    feature[column_name] = value\n+                elif column_name != 'Entrez_Gene_Id':\n+                    print(Color.RED + \"Empty value encounterd in column '\" + column_name + \"' in row \" + str(\n+                        row_counter) + \". OncoKb annotations cannot be imported. Please fix and rerun.\" + Color.END,\n+                          file=sys.stderr)\n+                    print(\"!\" * 71, file=sys.stderr)\n+                    sys.exit(1)\n+\n+            # resolve gene symbols to Entrez Ids if needed\n+            if 'Entrez_Gene_Id' in feature and feature['Entrez_Gene_Id'] is not None and feature[\n+                'Entrez_Gene_Id'] != '':\n+                entrez_gene_ids = [feature['Entrez_Gene_Id']]\n+            else:\n+                entrez_gene_ids = portal_instance.hugo_entrez_map[feature['Hugo_Symbol']]\n+\n+            if len(entrez_gene_ids) > 1:\n+                logger.error(\"Multiple Entrez gene ids were found for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            elif len(entrez_gene_ids) == 0:\n+                logger.error(\"Could not find the Entrez gene id for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            else:\n+                feature['Entrez_Gene_Id'] = str(entrez_gene_ids[0])\n+                feature['id'] = \"_\".join([feature['Entrez_Gene_Id'], feature['copyNameAlterationType']])\n+\n+            features.append(feature)\n+    cna_file.close()\n+    print(\" DONE\")\n+    return features\n+\n+\n+def fetch_oncokb_annotations(features):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE1OTM1Mw==", "bodyText": "Yes, I have updated the method name.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r553159353", "createdAt": "2021-01-07T07:48:20Z", "author": {"login": "pvannierop"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:\n+                continue\n+            feature['copyNameAlterationType'] = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(feature['alteration'])]\n+            for column_name, index in header_indexes.items():\n+                value = line_elements[index]\n+                if value != '':\n+                    feature[column_name] = value\n+                elif column_name != 'Entrez_Gene_Id':\n+                    print(Color.RED + \"Empty value encounterd in column '\" + column_name + \"' in row \" + str(\n+                        row_counter) + \". OncoKb annotations cannot be imported. Please fix and rerun.\" + Color.END,\n+                          file=sys.stderr)\n+                    print(\"!\" * 71, file=sys.stderr)\n+                    sys.exit(1)\n+\n+            # resolve gene symbols to Entrez Ids if needed\n+            if 'Entrez_Gene_Id' in feature and feature['Entrez_Gene_Id'] is not None and feature[\n+                'Entrez_Gene_Id'] != '':\n+                entrez_gene_ids = [feature['Entrez_Gene_Id']]\n+            else:\n+                entrez_gene_ids = portal_instance.hugo_entrez_map[feature['Hugo_Symbol']]\n+\n+            if len(entrez_gene_ids) > 1:\n+                logger.error(\"Multiple Entrez gene ids were found for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            elif len(entrez_gene_ids) == 0:\n+                logger.error(\"Could not find the Entrez gene id for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            else:\n+                feature['Entrez_Gene_Id'] = str(entrez_gene_ids[0])\n+                feature['id'] = \"_\".join([feature['Entrez_Gene_Id'], feature['copyNameAlterationType']])\n+\n+            features.append(feature)\n+    cna_file.close()\n+    print(\" DONE\")\n+    return features\n+\n+\n+def fetch_oncokb_annotations(features):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM0MTQzMA=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 200}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTQ1NDEyOnYy", "diffSide": "RIGHT", "path": "core/src/main/scripts/importer/importOncokbMutation.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxOTo1MToyNVrOH_fv8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QwNzo1NTo0MlrOIPiVYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM0MjUxNQ==", "bodyText": "Seems exactly the same to the one in importOncokbDiscreteCNA.py", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r536342515", "createdAt": "2020-12-04T19:51:25Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/importOncokbMutation.py", "diffHunk": "@@ -0,0 +1,293 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for MAF files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_mutation_columns = ['Hugo_Symbol', 'HGVSp_Short', 'Variant_Classification', 'Protein_position']\n+disallowed_mutation_columns = ['cbp_driver', 'cbp_driver_annotation', 'cbp_driver_tiers', 'cbp_driver_tiers_annotation']\n+portal_instance = None\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_file_mutation = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'MUTATION_EXTENDED'})\n+    mutation_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_file_mutation))\n+    check_required_columns(libImportOncokb.get_first_line(open_mutations_file(mutation_file_path)).rstrip('\\n').split('\\t'))\n+    check_disallowed_columns(libImportOncokb.get_first_line(open_mutations_file(mutation_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    row_number_to_feature = get_features(mutation_file_path)\n+    row_number_to_annotation = fetch_oncokb_annotations(row_number_to_feature)\n+    write_annotations_to_file(row_number_to_annotation, mutation_file_path)\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_mutations_file(file_name):\n+    \"\"\"Open MAF file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open MAF file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def check_disallowed_columns(header_elements):\n+    disallowed_columns = []\n+    for disallowed_column in disallowed_mutation_columns:\n+        if disallowed_column in header_elements:\n+            disallowed_columns.append(disallowed_column)\n+    if len(disallowed_columns) > 0:\n+        raise RuntimeError(\"One or more disallowed columns for OncoKb import are present in the MAF file. \" \\\n+                           \"Disallowed column(s): [\" + \", \".join(disallowed_columns) + \"]\")\n+\n+\n+def get_features(mutation_file_path):\n+    \"\"\"Extract Mutation events from MAF data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_mutations_file(mutation_file_path)).rstrip().split('\\t')\n+    header_indexes = {}\n+    for required_column in required_mutation_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    row_number_to_feature = {}\n+    row_counter = 0\n+    mutation_file = open_mutations_file(mutation_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in mutation_file:\n+        row_counter += 1\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip().split('\\t')\n+        feature = {}\n+        for column_name, index in header_indexes.items():\n+            value = line_elements[index]\n+            if value != '':\n+                if column_name == 'HGVSp_Short':\n+                    value = value.replace('p.', '')\n+                feature[column_name] = value\n+            elif column_name != 'Entrez_Gene_Id' and column_name != 'Protein_position':\n+                raise RuntimeError(\"Empty value encounterd in column '\" +\n+                                   column_name + \"' in row \" + str(row_counter) + \".\" \\\n+                                                                                  \"OncoKb annotations cannot be imported. Please fix and rerun.\")\n+\n+        # resolve gene symbols to Entrez Ids if needed\n+        if 'Entrez_Gene_Id' in feature and feature['Entrez_Gene_Id'] is not None and feature['Entrez_Gene_Id'] != '':\n+            entrez_gene_ids = [feature['Entrez_Gene_Id']]\n+        else:\n+            entrez_gene_ids = portal_instance.hugo_entrez_map[feature['Hugo_Symbol']]\n+\n+        if len(entrez_gene_ids) > 1:\n+            logger.error(\"Multiple Entrez gene ids were found for a gene.\" \\\n+                         \"OncoKb annotations will not be imported for this gene.\" \\\n+                         \"Please fix and rerun.\",\n+                         extra={'symbol': feature['Hugo_Symbol'], 'row': str(row_counter)})\n+            feature['Entrez_Gene_Id'] = None\n+        elif len(entrez_gene_ids) == 0:\n+            logger.error(\"Could not find the Entrez gene id for a gene.\" \\\n+                         \"OncoKb annotations will not be imported for this gene.\" \\\n+                         \"Please fix and rerun.\",\n+                         extra={'symbol': feature['Hugo_Symbol'], 'row': str(row_counter)})\n+            feature['Entrez_Gene_Id'] = None\n+        else:\n+            feature['Entrez_Gene_Id'] = str(entrez_gene_ids[0])\n+            feature['id'] = \"_\".join(\n+                [feature['Entrez_Gene_Id'], feature['HGVSp_Short'], feature['Variant_Classification']])\n+\n+        row_number_to_feature[row_counter] = feature\n+    mutation_file.close()\n+    print(\" DONE\")\n+    return row_number_to_feature\n+\n+\n+def fetch_oncokb_annotations(row_number_to_feature):\n+    \"\"\"Submit mutation events to OncoKB.org and return OncoKB annotations.\"\"\"\n+    id_to_rownumber = {}\n+    for row_number, feature in row_number_to_feature.items():\n+        id_to_rownumber[feature['id']] = row_number\n+    payload_list = create_request_payload(row_number_to_feature)\n+    annotations = libImportOncokb.fetch_oncokb_annotations(payload_list, \"https://public.api.oncokb.org/api/v1/annotate/mutations/byProteinChange\")\n+    row_number_to_annotation = {}\n+    id_to_annotation = {annotation['query']['id']: annotation for annotation in annotations}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE2MjA4Mw==", "bodyText": "They are different. The method for mutations creates a dict keyed by rownumber. The method for CNAs creates a dict keyed by an internal ID.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r553162083", "createdAt": "2021-01-07T07:55:42Z", "author": {"login": "pvannierop"}, "path": "core/src/main/scripts/importer/importOncokbMutation.py", "diffHunk": "@@ -0,0 +1,293 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for MAF files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_mutation_columns = ['Hugo_Symbol', 'HGVSp_Short', 'Variant_Classification', 'Protein_position']\n+disallowed_mutation_columns = ['cbp_driver', 'cbp_driver_annotation', 'cbp_driver_tiers', 'cbp_driver_tiers_annotation']\n+portal_instance = None\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_file_mutation = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'MUTATION_EXTENDED'})\n+    mutation_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_file_mutation))\n+    check_required_columns(libImportOncokb.get_first_line(open_mutations_file(mutation_file_path)).rstrip('\\n').split('\\t'))\n+    check_disallowed_columns(libImportOncokb.get_first_line(open_mutations_file(mutation_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    row_number_to_feature = get_features(mutation_file_path)\n+    row_number_to_annotation = fetch_oncokb_annotations(row_number_to_feature)\n+    write_annotations_to_file(row_number_to_annotation, mutation_file_path)\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_mutations_file(file_name):\n+    \"\"\"Open MAF file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open MAF file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def check_disallowed_columns(header_elements):\n+    disallowed_columns = []\n+    for disallowed_column in disallowed_mutation_columns:\n+        if disallowed_column in header_elements:\n+            disallowed_columns.append(disallowed_column)\n+    if len(disallowed_columns) > 0:\n+        raise RuntimeError(\"One or more disallowed columns for OncoKb import are present in the MAF file. \" \\\n+                           \"Disallowed column(s): [\" + \", \".join(disallowed_columns) + \"]\")\n+\n+\n+def get_features(mutation_file_path):\n+    \"\"\"Extract Mutation events from MAF data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_mutations_file(mutation_file_path)).rstrip().split('\\t')\n+    header_indexes = {}\n+    for required_column in required_mutation_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    row_number_to_feature = {}\n+    row_counter = 0\n+    mutation_file = open_mutations_file(mutation_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in mutation_file:\n+        row_counter += 1\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip().split('\\t')\n+        feature = {}\n+        for column_name, index in header_indexes.items():\n+            value = line_elements[index]\n+            if value != '':\n+                if column_name == 'HGVSp_Short':\n+                    value = value.replace('p.', '')\n+                feature[column_name] = value\n+            elif column_name != 'Entrez_Gene_Id' and column_name != 'Protein_position':\n+                raise RuntimeError(\"Empty value encounterd in column '\" +\n+                                   column_name + \"' in row \" + str(row_counter) + \".\" \\\n+                                                                                  \"OncoKb annotations cannot be imported. Please fix and rerun.\")\n+\n+        # resolve gene symbols to Entrez Ids if needed\n+        if 'Entrez_Gene_Id' in feature and feature['Entrez_Gene_Id'] is not None and feature['Entrez_Gene_Id'] != '':\n+            entrez_gene_ids = [feature['Entrez_Gene_Id']]\n+        else:\n+            entrez_gene_ids = portal_instance.hugo_entrez_map[feature['Hugo_Symbol']]\n+\n+        if len(entrez_gene_ids) > 1:\n+            logger.error(\"Multiple Entrez gene ids were found for a gene.\" \\\n+                         \"OncoKb annotations will not be imported for this gene.\" \\\n+                         \"Please fix and rerun.\",\n+                         extra={'symbol': feature['Hugo_Symbol'], 'row': str(row_counter)})\n+            feature['Entrez_Gene_Id'] = None\n+        elif len(entrez_gene_ids) == 0:\n+            logger.error(\"Could not find the Entrez gene id for a gene.\" \\\n+                         \"OncoKb annotations will not be imported for this gene.\" \\\n+                         \"Please fix and rerun.\",\n+                         extra={'symbol': feature['Hugo_Symbol'], 'row': str(row_counter)})\n+            feature['Entrez_Gene_Id'] = None\n+        else:\n+            feature['Entrez_Gene_Id'] = str(entrez_gene_ids[0])\n+            feature['id'] = \"_\".join(\n+                [feature['Entrez_Gene_Id'], feature['HGVSp_Short'], feature['Variant_Classification']])\n+\n+        row_number_to_feature[row_counter] = feature\n+    mutation_file.close()\n+    print(\" DONE\")\n+    return row_number_to_feature\n+\n+\n+def fetch_oncokb_annotations(row_number_to_feature):\n+    \"\"\"Submit mutation events to OncoKB.org and return OncoKB annotations.\"\"\"\n+    id_to_rownumber = {}\n+    for row_number, feature in row_number_to_feature.items():\n+        id_to_rownumber[feature['id']] = row_number\n+    payload_list = create_request_payload(row_number_to_feature)\n+    annotations = libImportOncokb.fetch_oncokb_annotations(payload_list, \"https://public.api.oncokb.org/api/v1/annotate/mutations/byProteinChange\")\n+    row_number_to_annotation = {}\n+    id_to_annotation = {annotation['query']['id']: annotation for annotation in annotations}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM0MjUxNQ=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 184}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTQ1ODA2OnYy", "diffSide": "RIGHT", "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxOTo1MjozMlrOH_fyQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMDoxNTo0NFrOIAfbdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM0MzEwNw==", "bodyText": "This could be a generic open_file util method", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r536343107", "createdAt": "2020-12-04T19:52:32Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM4NTg0Nw==", "bodyText": "Done", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r537385847", "createdAt": "2020-12-07T10:15:44Z", "author": {"login": "oplantalech"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM0MzEwNw=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTQ3MjQ4OnYy", "diffSide": "RIGHT", "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxOTo1NjozM1rOH_f6lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxMDowMToyM1rOIPmSsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM0NTIzOA==", "bodyText": "All the places using get_first_line seems following with a rstrip and split. Would it make sense just wrap the logic all together for a get_first_line_cells?", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r536345238", "createdAt": "2020-12-04T19:56:33Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIyNjkzMQ==", "bodyText": "I have created a convenience method that mitigates this somewhat (get_first_line_cells in libImportOncokb.py).", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r553226931", "createdAt": "2021-01-07T10:01:23Z", "author": {"login": "pvannierop"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM0NTIzOA=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTQ5MzI1OnYy", "diffSide": "RIGHT", "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMDowMjoyNVrOH_gGiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMDoxNjowMFrOIAfcEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM0ODI5OQ==", "bodyText": "Can we move the public.api.oncokb.org/api/v1 to a global constant so it can be shared?", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r536348299", "createdAt": "2020-12-04T20:02:25Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:\n+                continue\n+            feature['copyNameAlterationType'] = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(feature['alteration'])]\n+            for column_name, index in header_indexes.items():\n+                value = line_elements[index]\n+                if value != '':\n+                    feature[column_name] = value\n+                elif column_name != 'Entrez_Gene_Id':\n+                    print(Color.RED + \"Empty value encounterd in column '\" + column_name + \"' in row \" + str(\n+                        row_counter) + \". OncoKb annotations cannot be imported. Please fix and rerun.\" + Color.END,\n+                          file=sys.stderr)\n+                    print(\"!\" * 71, file=sys.stderr)\n+                    sys.exit(1)\n+\n+            # resolve gene symbols to Entrez Ids if needed\n+            if 'Entrez_Gene_Id' in feature and feature['Entrez_Gene_Id'] is not None and feature[\n+                'Entrez_Gene_Id'] != '':\n+                entrez_gene_ids = [feature['Entrez_Gene_Id']]\n+            else:\n+                entrez_gene_ids = portal_instance.hugo_entrez_map[feature['Hugo_Symbol']]\n+\n+            if len(entrez_gene_ids) > 1:\n+                logger.error(\"Multiple Entrez gene ids were found for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            elif len(entrez_gene_ids) == 0:\n+                logger.error(\"Could not find the Entrez gene id for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            else:\n+                feature['Entrez_Gene_Id'] = str(entrez_gene_ids[0])\n+                feature['id'] = \"_\".join([feature['Entrez_Gene_Id'], feature['copyNameAlterationType']])\n+\n+            features.append(feature)\n+    cna_file.close()\n+    print(\" DONE\")\n+    return features\n+\n+\n+def fetch_oncokb_annotations(features):\n+    \"\"\"Submit CNA events to OncoKB.org and return OncoKB annotations.\"\"\"\n+    id_to_annotation = {}\n+    payload_list = create_request_payload(features)\n+    annotations = libImportOncokb.fetch_oncokb_annotations(payload_list, \"https://public.api.oncokb.org/api/v1/annotate/copyNumberAlterations\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM4NjAwMw==", "bodyText": "Done", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r537386003", "createdAt": "2020-12-07T10:16:00Z", "author": {"login": "oplantalech"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:\n+                continue\n+            feature['copyNameAlterationType'] = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(feature['alteration'])]\n+            for column_name, index in header_indexes.items():\n+                value = line_elements[index]\n+                if value != '':\n+                    feature[column_name] = value\n+                elif column_name != 'Entrez_Gene_Id':\n+                    print(Color.RED + \"Empty value encounterd in column '\" + column_name + \"' in row \" + str(\n+                        row_counter) + \". OncoKb annotations cannot be imported. Please fix and rerun.\" + Color.END,\n+                          file=sys.stderr)\n+                    print(\"!\" * 71, file=sys.stderr)\n+                    sys.exit(1)\n+\n+            # resolve gene symbols to Entrez Ids if needed\n+            if 'Entrez_Gene_Id' in feature and feature['Entrez_Gene_Id'] is not None and feature[\n+                'Entrez_Gene_Id'] != '':\n+                entrez_gene_ids = [feature['Entrez_Gene_Id']]\n+            else:\n+                entrez_gene_ids = portal_instance.hugo_entrez_map[feature['Hugo_Symbol']]\n+\n+            if len(entrez_gene_ids) > 1:\n+                logger.error(\"Multiple Entrez gene ids were found for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            elif len(entrez_gene_ids) == 0:\n+                logger.error(\"Could not find the Entrez gene id for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            else:\n+                feature['Entrez_Gene_Id'] = str(entrez_gene_ids[0])\n+                feature['id'] = \"_\".join([feature['Entrez_Gene_Id'], feature['copyNameAlterationType']])\n+\n+            features.append(feature)\n+    cna_file.close()\n+    print(\" DONE\")\n+    return features\n+\n+\n+def fetch_oncokb_annotations(features):\n+    \"\"\"Submit CNA events to OncoKB.org and return OncoKB annotations.\"\"\"\n+    id_to_annotation = {}\n+    payload_list = create_request_payload(features)\n+    annotations = libImportOncokb.fetch_oncokb_annotations(payload_list, \"https://public.api.oncokb.org/api/v1/annotate/copyNumberAlterations\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM0ODI5OQ=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 204}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTUwMjczOnYy", "diffSide": "RIGHT", "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMDowNToxOVrOH_gMLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNTo1MzoxOFrOIQXDfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM0OTc0Mw==", "bodyText": "It seems strange to me you have all upper case, camel case, and lower case headers. Is this your intention?", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r536349743", "createdAt": "2020-12-04T20:05:19Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:\n+                continue\n+            feature['copyNameAlterationType'] = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(feature['alteration'])]\n+            for column_name, index in header_indexes.items():\n+                value = line_elements[index]\n+                if value != '':\n+                    feature[column_name] = value\n+                elif column_name != 'Entrez_Gene_Id':\n+                    print(Color.RED + \"Empty value encounterd in column '\" + column_name + \"' in row \" + str(\n+                        row_counter) + \". OncoKb annotations cannot be imported. Please fix and rerun.\" + Color.END,\n+                          file=sys.stderr)\n+                    print(\"!\" * 71, file=sys.stderr)\n+                    sys.exit(1)\n+\n+            # resolve gene symbols to Entrez Ids if needed\n+            if 'Entrez_Gene_Id' in feature and feature['Entrez_Gene_Id'] is not None and feature[\n+                'Entrez_Gene_Id'] != '':\n+                entrez_gene_ids = [feature['Entrez_Gene_Id']]\n+            else:\n+                entrez_gene_ids = portal_instance.hugo_entrez_map[feature['Hugo_Symbol']]\n+\n+            if len(entrez_gene_ids) > 1:\n+                logger.error(\"Multiple Entrez gene ids were found for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            elif len(entrez_gene_ids) == 0:\n+                logger.error(\"Could not find the Entrez gene id for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            else:\n+                feature['Entrez_Gene_Id'] = str(entrez_gene_ids[0])\n+                feature['id'] = \"_\".join([feature['Entrez_Gene_Id'], feature['copyNameAlterationType']])\n+\n+            features.append(feature)\n+    cna_file.close()\n+    print(\" DONE\")\n+    return features\n+\n+\n+def fetch_oncokb_annotations(features):\n+    \"\"\"Submit CNA events to OncoKB.org and return OncoKB annotations.\"\"\"\n+    id_to_annotation = {}\n+    payload_list = create_request_payload(features)\n+    annotations = libImportOncokb.fetch_oncokb_annotations(payload_list, \"https://public.api.oncokb.org/api/v1/annotate/copyNumberAlterations\")\n+    for annotation in annotations:\n+        id = annotation['query']['id']\n+        id_to_annotation[id] = annotation\n+    return id_to_annotation\n+\n+\n+def create_request_payload(features):\n+    \"\"\"Translate CNA events into JSON for message body.\"\"\"\n+    elements = {}\n+    for feature in features:\n+        elements[feature[\n+            'id']] = '{ \"copyNameAlterationType\":\"%s\", \"gene\":{\"entrezGeneId\":%s}, \"id\":\"%s\", \"tumorType\":null} ' \\\n+                     % (feature['copyNameAlterationType'], feature['Entrez_Gene_Id'], feature['id'])\n+    # normalize for alteration id since same alteration is represented in multiple samples\n+    return list(elements.values())\n+\n+\n+def update_cna_metafile(meta_cna_file_path, pd_file_name):\n+    \"\"\"Add reference to pd annotation file to CNA meta file.\"\"\"\n+    meta_file = open(meta_cna_file_path, \"r\")\n+    lines = meta_file.readlines()\n+    meta_file.close()\n+    meta_file_name = os.path.basename(meta_cna_file_path)\n+    dir = os.path.dirname(meta_cna_file_path)\n+    os.rename(meta_cna_file_path, os.path.join(dir, 'ONCOKB_IMPORT_BACKUP_' + meta_file_name))\n+    if lines[-1] == '\\n':\n+        lines = lines[:-1]\n+    meta_file = open(meta_cna_file_path, \"w\")\n+    for line in lines:\n+        meta_file.write(line)\n+    meta_file.write('pd_annotations_filename: ' + pd_file_name + '\\n')\n+    meta_file.close()\n+\n+\n+def write_annotations_to_file(features, pd_file_name):\n+    \"\"\"Write CNA pd annotations to data file.\"\"\"\n+    new_file = open(pd_file_name, \"w\")\n+    new_file.write(\"SAMPLE_ID\\tEntrez_Gene_Id\\tcbp_driver\\tcbp_driver_annotation\\tcbp_driver_tiers\\tcbp_driver_tiers_annotation\\n\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 242}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIyNzUzMQ==", "bodyText": "This is according to specification in FileFormats.md. I think that this discussion is out of scope for this PR.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r553227531", "createdAt": "2021-01-07T10:02:33Z", "author": {"login": "pvannierop"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:\n+                continue\n+            feature['copyNameAlterationType'] = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(feature['alteration'])]\n+            for column_name, index in header_indexes.items():\n+                value = line_elements[index]\n+                if value != '':\n+                    feature[column_name] = value\n+                elif column_name != 'Entrez_Gene_Id':\n+                    print(Color.RED + \"Empty value encounterd in column '\" + column_name + \"' in row \" + str(\n+                        row_counter) + \". OncoKb annotations cannot be imported. Please fix and rerun.\" + Color.END,\n+                          file=sys.stderr)\n+                    print(\"!\" * 71, file=sys.stderr)\n+                    sys.exit(1)\n+\n+            # resolve gene symbols to Entrez Ids if needed\n+            if 'Entrez_Gene_Id' in feature and feature['Entrez_Gene_Id'] is not None and feature[\n+                'Entrez_Gene_Id'] != '':\n+                entrez_gene_ids = [feature['Entrez_Gene_Id']]\n+            else:\n+                entrez_gene_ids = portal_instance.hugo_entrez_map[feature['Hugo_Symbol']]\n+\n+            if len(entrez_gene_ids) > 1:\n+                logger.error(\"Multiple Entrez gene ids were found for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            elif len(entrez_gene_ids) == 0:\n+                logger.error(\"Could not find the Entrez gene id for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            else:\n+                feature['Entrez_Gene_Id'] = str(entrez_gene_ids[0])\n+                feature['id'] = \"_\".join([feature['Entrez_Gene_Id'], feature['copyNameAlterationType']])\n+\n+            features.append(feature)\n+    cna_file.close()\n+    print(\" DONE\")\n+    return features\n+\n+\n+def fetch_oncokb_annotations(features):\n+    \"\"\"Submit CNA events to OncoKB.org and return OncoKB annotations.\"\"\"\n+    id_to_annotation = {}\n+    payload_list = create_request_payload(features)\n+    annotations = libImportOncokb.fetch_oncokb_annotations(payload_list, \"https://public.api.oncokb.org/api/v1/annotate/copyNumberAlterations\")\n+    for annotation in annotations:\n+        id = annotation['query']['id']\n+        id_to_annotation[id] = annotation\n+    return id_to_annotation\n+\n+\n+def create_request_payload(features):\n+    \"\"\"Translate CNA events into JSON for message body.\"\"\"\n+    elements = {}\n+    for feature in features:\n+        elements[feature[\n+            'id']] = '{ \"copyNameAlterationType\":\"%s\", \"gene\":{\"entrezGeneId\":%s}, \"id\":\"%s\", \"tumorType\":null} ' \\\n+                     % (feature['copyNameAlterationType'], feature['Entrez_Gene_Id'], feature['id'])\n+    # normalize for alteration id since same alteration is represented in multiple samples\n+    return list(elements.values())\n+\n+\n+def update_cna_metafile(meta_cna_file_path, pd_file_name):\n+    \"\"\"Add reference to pd annotation file to CNA meta file.\"\"\"\n+    meta_file = open(meta_cna_file_path, \"r\")\n+    lines = meta_file.readlines()\n+    meta_file.close()\n+    meta_file_name = os.path.basename(meta_cna_file_path)\n+    dir = os.path.dirname(meta_cna_file_path)\n+    os.rename(meta_cna_file_path, os.path.join(dir, 'ONCOKB_IMPORT_BACKUP_' + meta_file_name))\n+    if lines[-1] == '\\n':\n+        lines = lines[:-1]\n+    meta_file = open(meta_cna_file_path, \"w\")\n+    for line in lines:\n+        meta_file.write(line)\n+    meta_file.write('pd_annotations_filename: ' + pd_file_name + '\\n')\n+    meta_file.close()\n+\n+\n+def write_annotations_to_file(features, pd_file_name):\n+    \"\"\"Write CNA pd annotations to data file.\"\"\"\n+    new_file = open(pd_file_name, \"w\")\n+    new_file.write(\"SAMPLE_ID\\tEntrez_Gene_Id\\tcbp_driver\\tcbp_driver_annotation\\tcbp_driver_tiers\\tcbp_driver_tiers_annotation\\n\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM0OTc0Mw=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 242}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDAyNTg1NA==", "bodyText": "Ah nice! I don't even know that file exists. Thanks for the info!", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r554025854", "createdAt": "2021-01-08T15:53:18Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:\n+                continue\n+            feature['copyNameAlterationType'] = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(feature['alteration'])]\n+            for column_name, index in header_indexes.items():\n+                value = line_elements[index]\n+                if value != '':\n+                    feature[column_name] = value\n+                elif column_name != 'Entrez_Gene_Id':\n+                    print(Color.RED + \"Empty value encounterd in column '\" + column_name + \"' in row \" + str(\n+                        row_counter) + \". OncoKb annotations cannot be imported. Please fix and rerun.\" + Color.END,\n+                          file=sys.stderr)\n+                    print(\"!\" * 71, file=sys.stderr)\n+                    sys.exit(1)\n+\n+            # resolve gene symbols to Entrez Ids if needed\n+            if 'Entrez_Gene_Id' in feature and feature['Entrez_Gene_Id'] is not None and feature[\n+                'Entrez_Gene_Id'] != '':\n+                entrez_gene_ids = [feature['Entrez_Gene_Id']]\n+            else:\n+                entrez_gene_ids = portal_instance.hugo_entrez_map[feature['Hugo_Symbol']]\n+\n+            if len(entrez_gene_ids) > 1:\n+                logger.error(\"Multiple Entrez gene ids were found for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            elif len(entrez_gene_ids) == 0:\n+                logger.error(\"Could not find the Entrez gene id for a gene.\" \\\n+                             \"OncoKb annotations will not be imported for this gene.\" \\\n+                             \"Please fix and rerun.\",\n+                             extra={'symbol': feature['Hugo_Symbol']})\n+                feature['Entrez_Gene_Id'] = None\n+            else:\n+                feature['Entrez_Gene_Id'] = str(entrez_gene_ids[0])\n+                feature['id'] = \"_\".join([feature['Entrez_Gene_Id'], feature['copyNameAlterationType']])\n+\n+            features.append(feature)\n+    cna_file.close()\n+    print(\" DONE\")\n+    return features\n+\n+\n+def fetch_oncokb_annotations(features):\n+    \"\"\"Submit CNA events to OncoKB.org and return OncoKB annotations.\"\"\"\n+    id_to_annotation = {}\n+    payload_list = create_request_payload(features)\n+    annotations = libImportOncokb.fetch_oncokb_annotations(payload_list, \"https://public.api.oncokb.org/api/v1/annotate/copyNumberAlterations\")\n+    for annotation in annotations:\n+        id = annotation['query']['id']\n+        id_to_annotation[id] = annotation\n+    return id_to_annotation\n+\n+\n+def create_request_payload(features):\n+    \"\"\"Translate CNA events into JSON for message body.\"\"\"\n+    elements = {}\n+    for feature in features:\n+        elements[feature[\n+            'id']] = '{ \"copyNameAlterationType\":\"%s\", \"gene\":{\"entrezGeneId\":%s}, \"id\":\"%s\", \"tumorType\":null} ' \\\n+                     % (feature['copyNameAlterationType'], feature['Entrez_Gene_Id'], feature['id'])\n+    # normalize for alteration id since same alteration is represented in multiple samples\n+    return list(elements.values())\n+\n+\n+def update_cna_metafile(meta_cna_file_path, pd_file_name):\n+    \"\"\"Add reference to pd annotation file to CNA meta file.\"\"\"\n+    meta_file = open(meta_cna_file_path, \"r\")\n+    lines = meta_file.readlines()\n+    meta_file.close()\n+    meta_file_name = os.path.basename(meta_cna_file_path)\n+    dir = os.path.dirname(meta_cna_file_path)\n+    os.rename(meta_cna_file_path, os.path.join(dir, 'ONCOKB_IMPORT_BACKUP_' + meta_file_name))\n+    if lines[-1] == '\\n':\n+        lines = lines[:-1]\n+    meta_file = open(meta_cna_file_path, \"w\")\n+    for line in lines:\n+        meta_file.write(line)\n+    meta_file.write('pd_annotations_filename: ' + pd_file_name + '\\n')\n+    meta_file.close()\n+\n+\n+def write_annotations_to_file(features, pd_file_name):\n+    \"\"\"Write CNA pd annotations to data file.\"\"\"\n+    new_file = open(pd_file_name, \"w\")\n+    new_file.write(\"SAMPLE_ID\\tEntrez_Gene_Id\\tcbp_driver\\tcbp_driver_annotation\\tcbp_driver_tiers\\tcbp_driver_tiers_annotation\\n\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM0OTc0Mw=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 242}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTUwNzgzOnYy", "diffSide": "RIGHT", "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMDowNjozOFrOH_gPAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxMDowMjo1NlrOIPmVwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1MDQ2NA==", "bodyText": "Sorry about this silly question, is it by design having these three imports written after the logics above? Instead of putting all imports together?", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r536350464", "createdAt": "2020-12-04T20:06:38Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTExNTM3NQ==", "bodyText": "I guess the logic above is necessary because we are not installing the python package but running it as a script. The logic above enables the relative imports listed here", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r541115375", "createdAt": "2020-12-11T17:39:38Z", "author": {"login": "inodb"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1MDQ2NA=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIyNzcxMw==", "bodyText": "Indeed", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r553227713", "createdAt": "2021-01-07T10:02:56Z", "author": {"login": "pvannierop"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1MDQ2NA=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTUxNDM0OnYy", "diffSide": "RIGHT", "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMDowODo0M1rOH_gS0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxMDowNToxMVrOIPmaTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1MTQ0Mg==", "bodyText": "This logger initiation script is duplicated, is it possible to merge together?", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r536351442", "createdAt": "2020-12-04T20:08:43Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIyODg3OA==", "bodyText": "No, this is not possible. It is boiler-plate code for setting the environment. Sharing is difficult because we are not dealing with a class based architecture.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r553228878", "createdAt": "2021-01-07T10:05:11Z", "author": {"login": "pvannierop"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1MTQ0Mg=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTUyMDgyOnYy", "diffSide": "RIGHT", "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMDoxMDoyOFrOH_gWiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxMDowNTozNVrOIPmbKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1MjM5Mw==", "bodyText": "Is Entrez_Gene_Id required column?", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r536352393", "createdAt": "2020-12-04T20:10:28Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIyOTA5Nw==", "bodyText": "No it is not. It does not have to appear in the data file. At this point in the code the it has retrieved the 'Entrez_Gene_Id from the portal. The loop iterates over all required columns and the later retrieved Entrez gene id.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r553229097", "createdAt": "2021-01-07T10:05:35Z", "author": {"login": "pvannierop"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1MjM5Mw=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTUyMzA2OnYy", "diffSide": "RIGHT", "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMDoxMToxMVrOH_gX2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwOTowMDo0M1rOIQoj5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1MjcyOA==", "bodyText": "What does features mean here?", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r536352728", "createdAt": "2020-12-04T20:11:11Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIzMDM5MQ==", "bodyText": "For the CNA file a feature is a gene-sample-copy number alteration data point. Would you be moire comfortable with a more informative name? For instance, cna_events?", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r553230391", "createdAt": "2021-01-07T10:08:02Z", "author": {"login": "pvannierop"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1MjcyOA=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDAzOTIwMw==", "bodyText": "Yeah, that sounds better.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r554039203", "createdAt": "2021-01-08T16:10:44Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1MjcyOA=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMjY3Ng==", "bodyText": "Ok, updated.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r554312676", "createdAt": "2021-01-09T09:00:43Z", "author": {"login": "pvannierop"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1MjcyOA=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTUyNjQ2OnYy", "diffSide": "RIGHT", "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMDoxMTo1OVrOH_gZrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwOTowMTowMVrOIQokCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1MzE5Ng==", "bodyText": "Shouldn't you skip all values that not in cna_alteration_types.values()?", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r536353196", "createdAt": "2020-12-04T20:11:59Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzI4MjY1Mg==", "bodyText": "Yes, good catch!", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r553282652", "createdAt": "2021-01-07T11:54:06Z", "author": {"login": "pvannierop"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1MzE5Ng=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMjcxMg==", "bodyText": "Updated", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r554312712", "createdAt": "2021-01-09T09:01:01Z", "author": {"login": "pvannierop"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1MzE5Ng=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTUzMzA1OnYy", "diffSide": "RIGHT", "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMDoxMzo1OVrOH_gddg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNjoxMjozNlrOIQX7uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1NDE2Ng==", "bodyText": "I think that sometimes the cell can be empty by design. Not sure whether you want to stop executing the script.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r536354166", "createdAt": "2020-12-04T20:13:59Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:\n+                continue\n+            feature['copyNameAlterationType'] = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(feature['alteration'])]\n+            for column_name, index in header_indexes.items():\n+                value = line_elements[index]\n+                if value != '':\n+                    feature[column_name] = value\n+                elif column_name != 'Entrez_Gene_Id':", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzI1MDg5NA==", "bodyText": "Not accoding to FileFormats.md:\n\nFor each gene-sample combination, a copy number level is specified:\n\"-2\" is a deep loss, possibly a homozygous deletion\n\"-1\" is a single-copy loss (heterozygous deletion)\n\"0\" is diploid\n\"1\" indicates a low-level gain\n\"2\" is a high-level amplification.\n\nSo, the script stops when this happens.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r553250894", "createdAt": "2021-01-07T10:46:28Z", "author": {"login": "pvannierop"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:\n+                continue\n+            feature['copyNameAlterationType'] = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(feature['alteration'])]\n+            for column_name, index in header_indexes.items():\n+                value = line_elements[index]\n+                if value != '':\n+                    feature[column_name] = value\n+                elif column_name != 'Entrez_Gene_Id':", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1NDE2Ng=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDA0MDI1MQ==", "bodyText": "Good point. I saw some files without any value before, but probably not by design and should be fixed.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r554040251", "createdAt": "2021-01-08T16:12:36Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:\n+                continue\n+            feature['copyNameAlterationType'] = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(feature['alteration'])]\n+            for column_name, index in header_indexes.items():\n+                value = line_elements[index]\n+                if value != '':\n+                    feature[column_name] = value\n+                elif column_name != 'Entrez_Gene_Id':", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1NDE2Ng=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTUzNzMyOnYy", "diffSide": "RIGHT", "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMDoxNToxNlrOH_gf4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxMTo1NDozM1rOIPptAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1NDc4Ng==", "bodyText": "Do you want to move Hugo_Symbol to a constant to avoid the typo?", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r536354786", "createdAt": "2020-12-04T20:15:16Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:\n+                continue\n+            feature['copyNameAlterationType'] = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(feature['alteration'])]\n+            for column_name, index in header_indexes.items():\n+                value = line_elements[index]\n+                if value != '':\n+                    feature[column_name] = value\n+                elif column_name != 'Entrez_Gene_Id':\n+                    print(Color.RED + \"Empty value encounterd in column '\" + column_name + \"' in row \" + str(\n+                        row_counter) + \". OncoKb annotations cannot be imported. Please fix and rerun.\" + Color.END,\n+                          file=sys.stderr)\n+                    print(\"!\" * 71, file=sys.stderr)\n+                    sys.exit(1)\n+\n+            # resolve gene symbols to Entrez Ids if needed\n+            if 'Entrez_Gene_Id' in feature and feature['Entrez_Gene_Id'] is not None and feature[\n+                'Entrez_Gene_Id'] != '':\n+                entrez_gene_ids = [feature['Entrez_Gene_Id']]\n+            else:\n+                entrez_gene_ids = portal_instance.hugo_entrez_map[feature['Hugo_Symbol']]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1NTA4MA==", "bodyText": "Also Entrez_Gene_Id", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r536355080", "createdAt": "2020-12-04T20:15:54Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:\n+                continue\n+            feature['copyNameAlterationType'] = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(feature['alteration'])]\n+            for column_name, index in header_indexes.items():\n+                value = line_elements[index]\n+                if value != '':\n+                    feature[column_name] = value\n+                elif column_name != 'Entrez_Gene_Id':\n+                    print(Color.RED + \"Empty value encounterd in column '\" + column_name + \"' in row \" + str(\n+                        row_counter) + \". OncoKb annotations cannot be imported. Please fix and rerun.\" + Color.END,\n+                          file=sys.stderr)\n+                    print(\"!\" * 71, file=sys.stderr)\n+                    sys.exit(1)\n+\n+            # resolve gene symbols to Entrez Ids if needed\n+            if 'Entrez_Gene_Id' in feature and feature['Entrez_Gene_Id'] is not None and feature[\n+                'Entrez_Gene_Id'] != '':\n+                entrez_gene_ids = [feature['Entrez_Gene_Id']]\n+            else:\n+                entrez_gene_ids = portal_instance.hugo_entrez_map[feature['Hugo_Symbol']]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1NDc4Ng=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzI4MjgxOA==", "bodyText": "I made all string values into shared constants.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r553282818", "createdAt": "2021-01-07T11:54:33Z", "author": {"login": "pvannierop"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:\n+                continue\n+            feature['copyNameAlterationType'] = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(feature['alteration'])]\n+            for column_name, index in header_indexes.items():\n+                value = line_elements[index]\n+                if value != '':\n+                    feature[column_name] = value\n+                elif column_name != 'Entrez_Gene_Id':\n+                    print(Color.RED + \"Empty value encounterd in column '\" + column_name + \"' in row \" + str(\n+                        row_counter) + \". OncoKb annotations cannot be imported. Please fix and rerun.\" + Color.END,\n+                          file=sys.stderr)\n+                    print(\"!\" * 71, file=sys.stderr)\n+                    sys.exit(1)\n+\n+            # resolve gene symbols to Entrez Ids if needed\n+            if 'Entrez_Gene_Id' in feature and feature['Entrez_Gene_Id'] is not None and feature[\n+                'Entrez_Gene_Id'] != '':\n+                entrez_gene_ids = [feature['Entrez_Gene_Id']]\n+            else:\n+                entrez_gene_ids = portal_instance.hugo_entrez_map[feature['Hugo_Symbol']]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1NDc4Ng=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTU2OTA3OnYy", "diffSide": "RIGHT", "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMDoyNDoyN1rOH_gxww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxMjowNTowNVrOIPp_Cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1OTM2Mw==", "bodyText": "I noticed that in some of the one line string, you use three quotes even there is not need to escape the quote. Maybe that's the convention you like to use? Here would be a perfect place to use three quotes with multiple lines?", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r536359363", "createdAt": "2020-12-04T20:24:27Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:\n+                continue\n+            feature['copyNameAlterationType'] = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(feature['alteration'])]\n+            for column_name, index in header_indexes.items():\n+                value = line_elements[index]\n+                if value != '':\n+                    feature[column_name] = value\n+                elif column_name != 'Entrez_Gene_Id':\n+                    print(Color.RED + \"Empty value encounterd in column '\" + column_name + \"' in row \" + str(\n+                        row_counter) + \". OncoKb annotations cannot be imported. Please fix and rerun.\" + Color.END,\n+                          file=sys.stderr)\n+                    print(\"!\" * 71, file=sys.stderr)\n+                    sys.exit(1)\n+\n+            # resolve gene symbols to Entrez Ids if needed\n+            if 'Entrez_Gene_Id' in feature and feature['Entrez_Gene_Id'] is not None and feature[\n+                'Entrez_Gene_Id'] != '':\n+                entrez_gene_ids = [feature['Entrez_Gene_Id']]\n+            else:\n+                entrez_gene_ids = portal_instance.hugo_entrez_map[feature['Hugo_Symbol']]\n+\n+            if len(entrez_gene_ids) > 1:\n+                logger.error(\"Multiple Entrez gene ids were found for a gene.\" \\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzI4NzQzNQ==", "bodyText": "Ah I did not know that \"\"\" is used for multiline comments :) I have updated where possible.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r553287435", "createdAt": "2021-01-07T12:05:05Z", "author": {"login": "pvannierop"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:\n+                continue\n+            feature['copyNameAlterationType'] = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(feature['alteration'])]\n+            for column_name, index in header_indexes.items():\n+                value = line_elements[index]\n+                if value != '':\n+                    feature[column_name] = value\n+                elif column_name != 'Entrez_Gene_Id':\n+                    print(Color.RED + \"Empty value encounterd in column '\" + column_name + \"' in row \" + str(\n+                        row_counter) + \". OncoKb annotations cannot be imported. Please fix and rerun.\" + Color.END,\n+                          file=sys.stderr)\n+                    print(\"!\" * 71, file=sys.stderr)\n+                    sys.exit(1)\n+\n+            # resolve gene symbols to Entrez Ids if needed\n+            if 'Entrez_Gene_Id' in feature and feature['Entrez_Gene_Id'] is not None and feature[\n+                'Entrez_Gene_Id'] != '':\n+                entrez_gene_ids = [feature['Entrez_Gene_Id']]\n+            else:\n+                entrez_gene_ids = portal_instance.hugo_entrez_map[feature['Hugo_Symbol']]\n+\n+            if len(entrez_gene_ids) > 1:\n+                logger.error(\"Multiple Entrez gene ids were found for a gene.\" \\", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1OTM2Mw=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTU3NzQ1OnYy", "diffSide": "RIGHT", "path": "core/src/main/scripts/importer/importOncokbMutation.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMDoyNjo0MVrOH_g2Tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxMjowNToxNlrOIPp_cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2MDUyNg==", "bodyText": "It would be great to put this as a string constant.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r536360526", "createdAt": "2020-12-04T20:26:41Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/importOncokbMutation.py", "diffHunk": "@@ -0,0 +1,293 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for MAF files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_mutation_columns = ['Hugo_Symbol', 'HGVSp_Short', 'Variant_Classification', 'Protein_position']\n+disallowed_mutation_columns = ['cbp_driver', 'cbp_driver_annotation', 'cbp_driver_tiers', 'cbp_driver_tiers_annotation']\n+portal_instance = None\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_file_mutation = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'MUTATION_EXTENDED'})\n+    mutation_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_file_mutation))\n+    check_required_columns(libImportOncokb.get_first_line(open_mutations_file(mutation_file_path)).rstrip('\\n').split('\\t'))\n+    check_disallowed_columns(libImportOncokb.get_first_line(open_mutations_file(mutation_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    row_number_to_feature = get_features(mutation_file_path)\n+    row_number_to_annotation = fetch_oncokb_annotations(row_number_to_feature)\n+    write_annotations_to_file(row_number_to_annotation, mutation_file_path)\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_mutations_file(file_name):\n+    \"\"\"Open MAF file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open MAF file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def check_disallowed_columns(header_elements):\n+    disallowed_columns = []\n+    for disallowed_column in disallowed_mutation_columns:\n+        if disallowed_column in header_elements:\n+            disallowed_columns.append(disallowed_column)\n+    if len(disallowed_columns) > 0:\n+        raise RuntimeError(\"One or more disallowed columns for OncoKb import are present in the MAF file. \" \\\n+                           \"Disallowed column(s): [\" + \", \".join(disallowed_columns) + \"]\")\n+\n+\n+def get_features(mutation_file_path):\n+    \"\"\"Extract Mutation events from MAF data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_mutations_file(mutation_file_path)).rstrip().split('\\t')\n+    header_indexes = {}\n+    for required_column in required_mutation_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    row_number_to_feature = {}\n+    row_counter = 0\n+    mutation_file = open_mutations_file(mutation_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in mutation_file:\n+        row_counter += 1\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip().split('\\t')\n+        feature = {}\n+        for column_name, index in header_indexes.items():\n+            value = line_elements[index]\n+            if value != '':\n+                if column_name == 'HGVSp_Short':", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzI4NzUzOA==", "bodyText": "Done", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r553287538", "createdAt": "2021-01-07T12:05:16Z", "author": {"login": "pvannierop"}, "path": "core/src/main/scripts/importer/importOncokbMutation.py", "diffHunk": "@@ -0,0 +1,293 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for MAF files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_mutation_columns = ['Hugo_Symbol', 'HGVSp_Short', 'Variant_Classification', 'Protein_position']\n+disallowed_mutation_columns = ['cbp_driver', 'cbp_driver_annotation', 'cbp_driver_tiers', 'cbp_driver_tiers_annotation']\n+portal_instance = None\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_file_mutation = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'MUTATION_EXTENDED'})\n+    mutation_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_file_mutation))\n+    check_required_columns(libImportOncokb.get_first_line(open_mutations_file(mutation_file_path)).rstrip('\\n').split('\\t'))\n+    check_disallowed_columns(libImportOncokb.get_first_line(open_mutations_file(mutation_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    row_number_to_feature = get_features(mutation_file_path)\n+    row_number_to_annotation = fetch_oncokb_annotations(row_number_to_feature)\n+    write_annotations_to_file(row_number_to_annotation, mutation_file_path)\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_mutations_file(file_name):\n+    \"\"\"Open MAF file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open MAF file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def check_disallowed_columns(header_elements):\n+    disallowed_columns = []\n+    for disallowed_column in disallowed_mutation_columns:\n+        if disallowed_column in header_elements:\n+            disallowed_columns.append(disallowed_column)\n+    if len(disallowed_columns) > 0:\n+        raise RuntimeError(\"One or more disallowed columns for OncoKb import are present in the MAF file. \" \\\n+                           \"Disallowed column(s): [\" + \", \".join(disallowed_columns) + \"]\")\n+\n+\n+def get_features(mutation_file_path):\n+    \"\"\"Extract Mutation events from MAF data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_mutations_file(mutation_file_path)).rstrip().split('\\t')\n+    header_indexes = {}\n+    for required_column in required_mutation_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    row_number_to_feature = {}\n+    row_counter = 0\n+    mutation_file = open_mutations_file(mutation_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in mutation_file:\n+        row_counter += 1\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip().split('\\t')\n+        feature = {}\n+        for column_name, index in header_indexes.items():\n+            value = line_elements[index]\n+            if value != '':\n+                if column_name == 'HGVSp_Short':", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2MDUyNg=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTYwMTA0OnYy", "diffSide": "RIGHT", "path": "core/src/main/scripts/importer/libImportOncokb.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMDozNDowMlrOH_hD4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxMjowNTozMlrOIPp_1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NDAwMg==", "bodyText": "I didn't review this method considering it's coming from the portal.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r536364002", "createdAt": "2020-12-04T20:34:02Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/libImportOncokb.py", "diffHunk": "@@ -0,0 +1,236 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script.\n+\n+Run with the command line option --help for usage information.\n+\"\"\"\n+\n+import re\n+import os\n+import requests\n+import json\n+\n+from . import validateData\n+\n+\n+BATCH_SIZE = 200\n+\n+\n+def load_portal_genes(server_url):\n+    parsed_json = request_from_portal_api(server_url, \"genes\", logging.getLogger(__name__))\n+    return transform_symbol_entrez_map(parsed_json, 'hugoGeneSymbol')\n+\n+\n+# after: getProteinStart() in ExtendedMutationUtil.java\n+def get_protein_pos_start(protein_position, protein_change):\n+    start = -1\n+    if protein_position is not None:\n+        start_end = protein_position.split('/')[0].split('-')\n+        if len(start_end) > 0:\n+            start = start_end[0]\n+    if start == -1 and protein_change is not None:\n+        start_stop = annotate_protein_change(protein_change)\n+        start = str(start_stop['start'])\n+    return start\n+\n+\n+# after: getProteinPosEnd() in ExtendedMutationUtil.java\n+def get_protein_pos_end(protein_position, protein_change):\n+    stop = -1\n+    if protein_position is not None:\n+        start_end = protein_position.split('/')[0].split('-')\n+        if len(start_end) > 1:\n+            stop = start_end[1]\n+    if stop == -1 and protein_change is not None:\n+        start_stop = annotate_protein_change(protein_change)\n+        stop = str(start_stop['stop'])\n+    return stop\n+\n+\n+# after: annotateProteinChange() in ExtendedMutationUtil.java\n+def annotate_protein_change(protein_change):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzI4NzYzOQ==", "bodyText": "No, Its an exact copy.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r553287639", "createdAt": "2021-01-07T12:05:32Z", "author": {"login": "pvannierop"}, "path": "core/src/main/scripts/importer/libImportOncokb.py", "diffHunk": "@@ -0,0 +1,236 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script.\n+\n+Run with the command line option --help for usage information.\n+\"\"\"\n+\n+import re\n+import os\n+import requests\n+import json\n+\n+from . import validateData\n+\n+\n+BATCH_SIZE = 200\n+\n+\n+def load_portal_genes(server_url):\n+    parsed_json = request_from_portal_api(server_url, \"genes\", logging.getLogger(__name__))\n+    return transform_symbol_entrez_map(parsed_json, 'hugoGeneSymbol')\n+\n+\n+# after: getProteinStart() in ExtendedMutationUtil.java\n+def get_protein_pos_start(protein_position, protein_change):\n+    start = -1\n+    if protein_position is not None:\n+        start_end = protein_position.split('/')[0].split('-')\n+        if len(start_end) > 0:\n+            start = start_end[0]\n+    if start == -1 and protein_change is not None:\n+        start_stop = annotate_protein_change(protein_change)\n+        start = str(start_stop['start'])\n+    return start\n+\n+\n+# after: getProteinPosEnd() in ExtendedMutationUtil.java\n+def get_protein_pos_end(protein_position, protein_change):\n+    stop = -1\n+    if protein_position is not None:\n+        start_end = protein_position.split('/')[0].split('-')\n+        if len(start_end) > 1:\n+            stop = start_end[1]\n+    if stop == -1 and protein_change is not None:\n+        start_stop = annotate_protein_change(protein_change)\n+        stop = str(start_stop['stop'])\n+    return stop\n+\n+\n+# after: annotateProteinChange() in ExtendedMutationUtil.java\n+def annotate_protein_change(protein_change):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NDAwMg=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTYwMzMwOnYy", "diffSide": "RIGHT", "path": "core/src/main/scripts/importer/libImportOncokb.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMDozNDo0NFrOH_hFRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxMjowNjoxM1rOIPqBAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NDM1Ng==", "bodyText": "end?", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r536364356", "createdAt": "2020-12-04T20:34:44Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/libImportOncokb.py", "diffHunk": "@@ -0,0 +1,236 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script.\n+\n+Run with the command line option --help for usage information.\n+\"\"\"\n+\n+import re\n+import os\n+import requests\n+import json\n+\n+from . import validateData\n+\n+\n+BATCH_SIZE = 200\n+\n+\n+def load_portal_genes(server_url):\n+    parsed_json = request_from_portal_api(server_url, \"genes\", logging.getLogger(__name__))\n+    return transform_symbol_entrez_map(parsed_json, 'hugoGeneSymbol')\n+\n+\n+# after: getProteinStart() in ExtendedMutationUtil.java\n+def get_protein_pos_start(protein_position, protein_change):\n+    start = -1\n+    if protein_position is not None:\n+        start_end = protein_position.split('/')[0].split('-')\n+        if len(start_end) > 0:\n+            start = start_end[0]\n+    if start == -1 and protein_change is not None:\n+        start_stop = annotate_protein_change(protein_change)\n+        start = str(start_stop['start'])\n+    return start\n+\n+\n+# after: getProteinPosEnd() in ExtendedMutationUtil.java\n+def get_protein_pos_end(protein_position, protein_change):\n+    stop = -1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzI4NzkzOQ==", "bodyText": "Yes, updated.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r553287939", "createdAt": "2021-01-07T12:06:13Z", "author": {"login": "pvannierop"}, "path": "core/src/main/scripts/importer/libImportOncokb.py", "diffHunk": "@@ -0,0 +1,236 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script.\n+\n+Run with the command line option --help for usage information.\n+\"\"\"\n+\n+import re\n+import os\n+import requests\n+import json\n+\n+from . import validateData\n+\n+\n+BATCH_SIZE = 200\n+\n+\n+def load_portal_genes(server_url):\n+    parsed_json = request_from_portal_api(server_url, \"genes\", logging.getLogger(__name__))\n+    return transform_symbol_entrez_map(parsed_json, 'hugoGeneSymbol')\n+\n+\n+# after: getProteinStart() in ExtendedMutationUtil.java\n+def get_protein_pos_start(protein_position, protein_change):\n+    start = -1\n+    if protein_position is not None:\n+        start_end = protein_position.split('/')[0].split('-')\n+        if len(start_end) > 0:\n+            start = start_end[0]\n+    if start == -1 and protein_change is not None:\n+        start_stop = annotate_protein_change(protein_change)\n+        start = str(start_stop['start'])\n+    return start\n+\n+\n+# after: getProteinPosEnd() in ExtendedMutationUtil.java\n+def get_protein_pos_end(protein_position, protein_change):\n+    stop = -1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NDM1Ng=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTYwMzk3OnYy", "diffSide": "RIGHT", "path": "core/src/main/scripts/importer/libImportOncokb.py", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMDozNDo1OFrOH_hFqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNjowODowOFrOIQXx3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NDQ1Nw==", "bodyText": "What's your normal protein position? In the Maf file we are using, it's annotate_protein_change  a single digit for the missense mutation. The protein end is start_end[0]", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r536364457", "createdAt": "2020-12-04T20:34:58Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/libImportOncokb.py", "diffHunk": "@@ -0,0 +1,236 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script.\n+\n+Run with the command line option --help for usage information.\n+\"\"\"\n+\n+import re\n+import os\n+import requests\n+import json\n+\n+from . import validateData\n+\n+\n+BATCH_SIZE = 200\n+\n+\n+def load_portal_genes(server_url):\n+    parsed_json = request_from_portal_api(server_url, \"genes\", logging.getLogger(__name__))\n+    return transform_symbol_entrez_map(parsed_json, 'hugoGeneSymbol')\n+\n+\n+# after: getProteinStart() in ExtendedMutationUtil.java\n+def get_protein_pos_start(protein_position, protein_change):\n+    start = -1\n+    if protein_position is not None:\n+        start_end = protein_position.split('/')[0].split('-')\n+        if len(start_end) > 0:\n+            start = start_end[0]\n+    if start == -1 and protein_change is not None:\n+        start_stop = annotate_protein_change(protein_change)\n+        start = str(start_stop['start'])\n+    return start\n+\n+\n+# after: getProteinPosEnd() in ExtendedMutationUtil.java\n+def get_protein_pos_end(protein_position, protein_change):\n+    stop = -1\n+    if protein_position is not None:\n+        start_end = protein_position.split('/')[0].split('-')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzI5MDE4MA==", "bodyText": "I do not understand this comment. Can you clarify?", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r553290180", "createdAt": "2021-01-07T12:11:24Z", "author": {"login": "pvannierop"}, "path": "core/src/main/scripts/importer/libImportOncokb.py", "diffHunk": "@@ -0,0 +1,236 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script.\n+\n+Run with the command line option --help for usage information.\n+\"\"\"\n+\n+import re\n+import os\n+import requests\n+import json\n+\n+from . import validateData\n+\n+\n+BATCH_SIZE = 200\n+\n+\n+def load_portal_genes(server_url):\n+    parsed_json = request_from_portal_api(server_url, \"genes\", logging.getLogger(__name__))\n+    return transform_symbol_entrez_map(parsed_json, 'hugoGeneSymbol')\n+\n+\n+# after: getProteinStart() in ExtendedMutationUtil.java\n+def get_protein_pos_start(protein_position, protein_change):\n+    start = -1\n+    if protein_position is not None:\n+        start_end = protein_position.split('/')[0].split('-')\n+        if len(start_end) > 0:\n+            start = start_end[0]\n+    if start == -1 and protein_change is not None:\n+        start_stop = annotate_protein_change(protein_change)\n+        start = str(start_stop['start'])\n+    return start\n+\n+\n+# after: getProteinPosEnd() in ExtendedMutationUtil.java\n+def get_protein_pos_end(protein_position, protein_change):\n+    stop = -1\n+    if protein_position is not None:\n+        start_end = protein_position.split('/')[0].split('-')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NDQ1Nw=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDAzNzcyNw==", "bodyText": "Oh sorry, nvm. I just realize the line 70-72 solves my concern. My original thought is that in the maf file for missense mutation, we use just one number. For instance V600E, we use 600 as protein_position, rather 600-600. So based on the line 67, your end will always be -1 for missense mutation.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r554037727", "createdAt": "2021-01-08T16:08:08Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/libImportOncokb.py", "diffHunk": "@@ -0,0 +1,236 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script.\n+\n+Run with the command line option --help for usage information.\n+\"\"\"\n+\n+import re\n+import os\n+import requests\n+import json\n+\n+from . import validateData\n+\n+\n+BATCH_SIZE = 200\n+\n+\n+def load_portal_genes(server_url):\n+    parsed_json = request_from_portal_api(server_url, \"genes\", logging.getLogger(__name__))\n+    return transform_symbol_entrez_map(parsed_json, 'hugoGeneSymbol')\n+\n+\n+# after: getProteinStart() in ExtendedMutationUtil.java\n+def get_protein_pos_start(protein_position, protein_change):\n+    start = -1\n+    if protein_position is not None:\n+        start_end = protein_position.split('/')[0].split('-')\n+        if len(start_end) > 0:\n+            start = start_end[0]\n+    if start == -1 and protein_change is not None:\n+        start_stop = annotate_protein_change(protein_change)\n+        start = str(start_stop['start'])\n+    return start\n+\n+\n+# after: getProteinPosEnd() in ExtendedMutationUtil.java\n+def get_protein_pos_end(protein_position, protein_change):\n+    stop = -1\n+    if protein_position is not None:\n+        start_end = protein_position.split('/')[0].split('-')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NDQ1Nw=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTYwNjk5OnYy", "diffSide": "RIGHT", "path": "core/src/main/scripts/importer/libImportOncokb.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMDozNTo1N1rOH_hHZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMDoxNjo0MVrOIAfeAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NDkwMw==", "bodyText": "This is the api to curated gene list not cancer genes. Which one you like to use?", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r536364903", "createdAt": "2020-12-04T20:35:57Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/libImportOncokb.py", "diffHunk": "@@ -0,0 +1,236 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script.\n+\n+Run with the command line option --help for usage information.\n+\"\"\"\n+\n+import re\n+import os\n+import requests\n+import json\n+\n+from . import validateData\n+\n+\n+BATCH_SIZE = 200\n+\n+\n+def load_portal_genes(server_url):\n+    parsed_json = request_from_portal_api(server_url, \"genes\", logging.getLogger(__name__))\n+    return transform_symbol_entrez_map(parsed_json, 'hugoGeneSymbol')\n+\n+\n+# after: getProteinStart() in ExtendedMutationUtil.java\n+def get_protein_pos_start(protein_position, protein_change):\n+    start = -1\n+    if protein_position is not None:\n+        start_end = protein_position.split('/')[0].split('-')\n+        if len(start_end) > 0:\n+            start = start_end[0]\n+    if start == -1 and protein_change is not None:\n+        start_stop = annotate_protein_change(protein_change)\n+        start = str(start_stop['start'])\n+    return start\n+\n+\n+# after: getProteinPosEnd() in ExtendedMutationUtil.java\n+def get_protein_pos_end(protein_position, protein_change):\n+    stop = -1\n+    if protein_position is not None:\n+        start_end = protein_position.split('/')[0].split('-')\n+        if len(start_end) > 1:\n+            stop = start_end[1]\n+    if stop == -1 and protein_change is not None:\n+        start_stop = annotate_protein_change(protein_change)\n+        stop = str(start_stop['stop'])\n+    return stop\n+\n+\n+# after: annotateProteinChange() in ExtendedMutationUtil.java\n+def annotate_protein_change(protein_change):\n+    start = -1\n+    end = -1\n+    match = re.findall(r'^([A-Z\\*]+)([0-9]+)([A-Z\\*\\?]*)$', protein_change)\n+    if len(match) > 0:\n+        ref = match[0][0]\n+        var = match[0][2]\n+        refL = len(ref)\n+        start = int(match[0][1])\n+        if ref == var or ref == '*' or var == '*' or start == 1 or var == '?':\n+            end = start\n+        else:\n+            end = start + refL - 1\n+    else:\n+        match = re.findall(r'[A-Z]?([0-9]+)(_[A-Z]?([0-9]+))?(delins|ins)([A-Z]+)', protein_change)\n+        if len(match) > 0:\n+            start = int(match[0][0])\n+            if match[0][2] is not None:\n+                end = int(match[0][2])\n+            else:\n+                end = start\n+        else:\n+            match = re.findall(r'[A-Z]?([0-9]+)(_[A-Z]?([0-9]+))?(_)?splice', protein_change)\n+            if len(match) > 0:\n+                start = int(match[0][0])\n+                if match[0][2] is not None and match[0][2] != '':\n+                    end = int(match[0][2])\n+                else:\n+                    end = start\n+            else:\n+                match = re.findall(r'[A-Z]?([0-9]+)_[A-Z]?([0-9]+)(.+)', protein_change)\n+                if len(match) > 0:\n+                    start = int(match[0][0])\n+                    end = int(match[0][1])\n+                else:\n+                    match = re.findall(r'([A-Z\\*])([0-9]+)[A-Z]?fs.*', protein_change)\n+                    if len(match) > 0:\n+                        start = int(match[0][1])\n+                        end = start\n+                    else:\n+                        match = re.findall(r'([A-Z]+)?([0-9]+)((ins)|(del)|(dup))', protein_change)\n+                        if len(match) > 0:\n+                            start = int(match[0][1])\n+                            end = start\n+    return {\"start\": start, \"stop\": end}\n+\n+\n+def evaluate_driver_passenger(oncogenic):\n+    \"\"\"Translate the OncoKB 'oncogenic' value to Putative_Driver' or Putative_Passenger'\"\"\"\n+    custom_annotation = 'Putative_Passenger'\n+    if oncogenic.lower() in ['oncogenic', 'likely oncogenic', 'predicted oncogenic']:\n+        custom_annotation = 'Putative_Driver'\n+    return custom_annotation\n+\n+\n+def get_first_line(file_handle):\n+    \"\"\"Read the first line of a file ignoring comment lines.\"\"\"\n+    while True:\n+        first_line = file_handle.readline()\n+        if not first_line.startswith('#'):\n+            file_handle.close()\n+            return first_line\n+\n+\n+def find_meta_file_by_fields(study_dir, field_dict):\n+    \"\"\"In the study directory find the meta file that holds specified field values.\"\"\"\n+    filenames = os.listdir(study_dir)\n+    meta_files = [ file for file in filenames if file.startswith('meta_')]\n+    meta_files = [ study_dir + \"/\" + file for file in meta_files ]\n+    for meta_file in meta_files:\n+        fields = read_meta_file(meta_file)\n+        match_found = True\n+        for field_name, field_value in field_dict.items():\n+            if field_name not in fields or fields[field_name] != field_value:\n+                match_found = False\n+        if match_found:\n+            return os.path.join(study_dir, meta_file)\n+    return None\n+\n+\n+def find_data_file_from_meta_file(metafile_path):\n+    \"\"\"From specified meta file return the value of the 'data_filename' field.\"\"\"\n+    fields = read_meta_file(metafile_path)\n+    return fields['data_filename']\n+\n+\n+def read_meta_file(metafile_path):\n+    \"\"\"Read fields of specified meta into a dict.\"\"\"\n+    fields = {}\n+    with open(metafile_path) as metafile:\n+        for line in metafile:\n+            if line == '\\n':\n+                continue\n+            match = re.findall(r'\\s*(\\S+)\\s*:\\s*(\\S+)', line)[0]\n+            fields[match[0]] = match[1]\n+    return fields\n+\n+def get_oncokb_cancer_genes():\n+    \"\"\"Do a call to OncoKB to retrieve the Cancer Gene List. \"\"\"\n+    request_url = \"https://public.api.oncokb.org/api/v1/utils/allCuratedGenes\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM4NjQ5Nw==", "bodyText": "Thanks for the catch. Initially this was cancer genes but we changed it to curated genes without modifying the names.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r537386497", "createdAt": "2020-12-07T10:16:41Z", "author": {"login": "oplantalech"}, "path": "core/src/main/scripts/importer/libImportOncokb.py", "diffHunk": "@@ -0,0 +1,236 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script.\n+\n+Run with the command line option --help for usage information.\n+\"\"\"\n+\n+import re\n+import os\n+import requests\n+import json\n+\n+from . import validateData\n+\n+\n+BATCH_SIZE = 200\n+\n+\n+def load_portal_genes(server_url):\n+    parsed_json = request_from_portal_api(server_url, \"genes\", logging.getLogger(__name__))\n+    return transform_symbol_entrez_map(parsed_json, 'hugoGeneSymbol')\n+\n+\n+# after: getProteinStart() in ExtendedMutationUtil.java\n+def get_protein_pos_start(protein_position, protein_change):\n+    start = -1\n+    if protein_position is not None:\n+        start_end = protein_position.split('/')[0].split('-')\n+        if len(start_end) > 0:\n+            start = start_end[0]\n+    if start == -1 and protein_change is not None:\n+        start_stop = annotate_protein_change(protein_change)\n+        start = str(start_stop['start'])\n+    return start\n+\n+\n+# after: getProteinPosEnd() in ExtendedMutationUtil.java\n+def get_protein_pos_end(protein_position, protein_change):\n+    stop = -1\n+    if protein_position is not None:\n+        start_end = protein_position.split('/')[0].split('-')\n+        if len(start_end) > 1:\n+            stop = start_end[1]\n+    if stop == -1 and protein_change is not None:\n+        start_stop = annotate_protein_change(protein_change)\n+        stop = str(start_stop['stop'])\n+    return stop\n+\n+\n+# after: annotateProteinChange() in ExtendedMutationUtil.java\n+def annotate_protein_change(protein_change):\n+    start = -1\n+    end = -1\n+    match = re.findall(r'^([A-Z\\*]+)([0-9]+)([A-Z\\*\\?]*)$', protein_change)\n+    if len(match) > 0:\n+        ref = match[0][0]\n+        var = match[0][2]\n+        refL = len(ref)\n+        start = int(match[0][1])\n+        if ref == var or ref == '*' or var == '*' or start == 1 or var == '?':\n+            end = start\n+        else:\n+            end = start + refL - 1\n+    else:\n+        match = re.findall(r'[A-Z]?([0-9]+)(_[A-Z]?([0-9]+))?(delins|ins)([A-Z]+)', protein_change)\n+        if len(match) > 0:\n+            start = int(match[0][0])\n+            if match[0][2] is not None:\n+                end = int(match[0][2])\n+            else:\n+                end = start\n+        else:\n+            match = re.findall(r'[A-Z]?([0-9]+)(_[A-Z]?([0-9]+))?(_)?splice', protein_change)\n+            if len(match) > 0:\n+                start = int(match[0][0])\n+                if match[0][2] is not None and match[0][2] != '':\n+                    end = int(match[0][2])\n+                else:\n+                    end = start\n+            else:\n+                match = re.findall(r'[A-Z]?([0-9]+)_[A-Z]?([0-9]+)(.+)', protein_change)\n+                if len(match) > 0:\n+                    start = int(match[0][0])\n+                    end = int(match[0][1])\n+                else:\n+                    match = re.findall(r'([A-Z\\*])([0-9]+)[A-Z]?fs.*', protein_change)\n+                    if len(match) > 0:\n+                        start = int(match[0][1])\n+                        end = start\n+                    else:\n+                        match = re.findall(r'([A-Z]+)?([0-9]+)((ins)|(del)|(dup))', protein_change)\n+                        if len(match) > 0:\n+                            start = int(match[0][1])\n+                            end = start\n+    return {\"start\": start, \"stop\": end}\n+\n+\n+def evaluate_driver_passenger(oncogenic):\n+    \"\"\"Translate the OncoKB 'oncogenic' value to Putative_Driver' or Putative_Passenger'\"\"\"\n+    custom_annotation = 'Putative_Passenger'\n+    if oncogenic.lower() in ['oncogenic', 'likely oncogenic', 'predicted oncogenic']:\n+        custom_annotation = 'Putative_Driver'\n+    return custom_annotation\n+\n+\n+def get_first_line(file_handle):\n+    \"\"\"Read the first line of a file ignoring comment lines.\"\"\"\n+    while True:\n+        first_line = file_handle.readline()\n+        if not first_line.startswith('#'):\n+            file_handle.close()\n+            return first_line\n+\n+\n+def find_meta_file_by_fields(study_dir, field_dict):\n+    \"\"\"In the study directory find the meta file that holds specified field values.\"\"\"\n+    filenames = os.listdir(study_dir)\n+    meta_files = [ file for file in filenames if file.startswith('meta_')]\n+    meta_files = [ study_dir + \"/\" + file for file in meta_files ]\n+    for meta_file in meta_files:\n+        fields = read_meta_file(meta_file)\n+        match_found = True\n+        for field_name, field_value in field_dict.items():\n+            if field_name not in fields or fields[field_name] != field_value:\n+                match_found = False\n+        if match_found:\n+            return os.path.join(study_dir, meta_file)\n+    return None\n+\n+\n+def find_data_file_from_meta_file(metafile_path):\n+    \"\"\"From specified meta file return the value of the 'data_filename' field.\"\"\"\n+    fields = read_meta_file(metafile_path)\n+    return fields['data_filename']\n+\n+\n+def read_meta_file(metafile_path):\n+    \"\"\"Read fields of specified meta into a dict.\"\"\"\n+    fields = {}\n+    with open(metafile_path) as metafile:\n+        for line in metafile:\n+            if line == '\\n':\n+                continue\n+            match = re.findall(r'\\s*(\\S+)\\s*:\\s*(\\S+)', line)[0]\n+            fields[match[0]] = match[1]\n+    return fields\n+\n+def get_oncokb_cancer_genes():\n+    \"\"\"Do a call to OncoKB to retrieve the Cancer Gene List. \"\"\"\n+    request_url = \"https://public.api.oncokb.org/api/v1/utils/allCuratedGenes\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NDkwMw=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTYxMDcxOnYy", "diffSide": "RIGHT", "path": "core/src/main/scripts/importer/libImportOncokb.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMDozNzowMlrOH_hJdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMDoxODozN1rOIAfjJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NTQzMA==", "bodyText": "I don't see usage of sv. Are you adding later?", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r536365430", "createdAt": "2020-12-04T20:37:02Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/libImportOncokb.py", "diffHunk": "@@ -0,0 +1,236 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script.\n+\n+Run with the command line option --help for usage information.\n+\"\"\"\n+\n+import re\n+import os\n+import requests\n+import json\n+\n+from . import validateData\n+\n+\n+BATCH_SIZE = 200\n+\n+\n+def load_portal_genes(server_url):\n+    parsed_json = request_from_portal_api(server_url, \"genes\", logging.getLogger(__name__))\n+    return transform_symbol_entrez_map(parsed_json, 'hugoGeneSymbol')\n+\n+\n+# after: getProteinStart() in ExtendedMutationUtil.java\n+def get_protein_pos_start(protein_position, protein_change):\n+    start = -1\n+    if protein_position is not None:\n+        start_end = protein_position.split('/')[0].split('-')\n+        if len(start_end) > 0:\n+            start = start_end[0]\n+    if start == -1 and protein_change is not None:\n+        start_stop = annotate_protein_change(protein_change)\n+        start = str(start_stop['start'])\n+    return start\n+\n+\n+# after: getProteinPosEnd() in ExtendedMutationUtil.java\n+def get_protein_pos_end(protein_position, protein_change):\n+    stop = -1\n+    if protein_position is not None:\n+        start_end = protein_position.split('/')[0].split('-')\n+        if len(start_end) > 1:\n+            stop = start_end[1]\n+    if stop == -1 and protein_change is not None:\n+        start_stop = annotate_protein_change(protein_change)\n+        stop = str(start_stop['stop'])\n+    return stop\n+\n+\n+# after: annotateProteinChange() in ExtendedMutationUtil.java\n+def annotate_protein_change(protein_change):\n+    start = -1\n+    end = -1\n+    match = re.findall(r'^([A-Z\\*]+)([0-9]+)([A-Z\\*\\?]*)$', protein_change)\n+    if len(match) > 0:\n+        ref = match[0][0]\n+        var = match[0][2]\n+        refL = len(ref)\n+        start = int(match[0][1])\n+        if ref == var or ref == '*' or var == '*' or start == 1 or var == '?':\n+            end = start\n+        else:\n+            end = start + refL - 1\n+    else:\n+        match = re.findall(r'[A-Z]?([0-9]+)(_[A-Z]?([0-9]+))?(delins|ins)([A-Z]+)', protein_change)\n+        if len(match) > 0:\n+            start = int(match[0][0])\n+            if match[0][2] is not None:\n+                end = int(match[0][2])\n+            else:\n+                end = start\n+        else:\n+            match = re.findall(r'[A-Z]?([0-9]+)(_[A-Z]?([0-9]+))?(_)?splice', protein_change)\n+            if len(match) > 0:\n+                start = int(match[0][0])\n+                if match[0][2] is not None and match[0][2] != '':\n+                    end = int(match[0][2])\n+                else:\n+                    end = start\n+            else:\n+                match = re.findall(r'[A-Z]?([0-9]+)_[A-Z]?([0-9]+)(.+)', protein_change)\n+                if len(match) > 0:\n+                    start = int(match[0][0])\n+                    end = int(match[0][1])\n+                else:\n+                    match = re.findall(r'([A-Z\\*])([0-9]+)[A-Z]?fs.*', protein_change)\n+                    if len(match) > 0:\n+                        start = int(match[0][1])\n+                        end = start\n+                    else:\n+                        match = re.findall(r'([A-Z]+)?([0-9]+)((ins)|(del)|(dup))', protein_change)\n+                        if len(match) > 0:\n+                            start = int(match[0][1])\n+                            end = start\n+    return {\"start\": start, \"stop\": end}\n+\n+\n+def evaluate_driver_passenger(oncogenic):\n+    \"\"\"Translate the OncoKB 'oncogenic' value to Putative_Driver' or Putative_Passenger'\"\"\"\n+    custom_annotation = 'Putative_Passenger'\n+    if oncogenic.lower() in ['oncogenic', 'likely oncogenic', 'predicted oncogenic']:\n+        custom_annotation = 'Putative_Driver'\n+    return custom_annotation\n+\n+\n+def get_first_line(file_handle):\n+    \"\"\"Read the first line of a file ignoring comment lines.\"\"\"\n+    while True:\n+        first_line = file_handle.readline()\n+        if not first_line.startswith('#'):\n+            file_handle.close()\n+            return first_line\n+\n+\n+def find_meta_file_by_fields(study_dir, field_dict):\n+    \"\"\"In the study directory find the meta file that holds specified field values.\"\"\"\n+    filenames = os.listdir(study_dir)\n+    meta_files = [ file for file in filenames if file.startswith('meta_')]\n+    meta_files = [ study_dir + \"/\" + file for file in meta_files ]\n+    for meta_file in meta_files:\n+        fields = read_meta_file(meta_file)\n+        match_found = True\n+        for field_name, field_value in field_dict.items():\n+            if field_name not in fields or fields[field_name] != field_value:\n+                match_found = False\n+        if match_found:\n+            return os.path.join(study_dir, meta_file)\n+    return None\n+\n+\n+def find_data_file_from_meta_file(metafile_path):\n+    \"\"\"From specified meta file return the value of the 'data_filename' field.\"\"\"\n+    fields = read_meta_file(metafile_path)\n+    return fields['data_filename']\n+\n+\n+def read_meta_file(metafile_path):\n+    \"\"\"Read fields of specified meta into a dict.\"\"\"\n+    fields = {}\n+    with open(metafile_path) as metafile:\n+        for line in metafile:\n+            if line == '\\n':\n+                continue\n+            match = re.findall(r'\\s*(\\S+)\\s*:\\s*(\\S+)', line)[0]\n+            fields[match[0]] = match[1]\n+    return fields\n+\n+def get_oncokb_cancer_genes():\n+    \"\"\"Do a call to OncoKB to retrieve the Cancer Gene List. \"\"\"\n+    request_url = \"https://public.api.oncokb.org/api/v1/utils/allCuratedGenes\"\n+    request = requests.get(url=request_url)\n+\n+    if request.ok:\n+        return request.json()\n+    else:\n+        if request.status_code == 404:\n+            raise ConnectionError(\n+                \"An error occurred when trying to connect to OncoKB for retrieving of mutation annotations.\")\n+        else:\n+            request.raise_for_status()\n+\n+def get_annotated_oncokb_cancer_genes_by_entrezId():\n+    \"\"\" Get a list with the Entrez Gene IDs of the OncoKB Cancer Gene List, only the genes that have\n+        annotations. \"\"\"\n+    cancer_genes = get_oncokb_cancer_genes()\n+    entrez_ids = []\n+    for gene in cancer_genes:\n+        entrez_ids += [gene[\"entrezGeneId\"]]\n+    return entrez_ids\n+\n+def filter_payload(payload_list, sv):\n+    \"\"\" Remove the genes that are not an OncoKB Cancer Gene List from the payload. \"\"\"\n+    cancer_genes = get_annotated_oncokb_cancer_genes_by_entrezId()\n+    filtered_payload = []\n+    for element in payload_list:\n+        parsed_element = json.loads(element)\n+        if sv:\n+            if parsed_element[\"geneA\"][\"entrezGeneId\"] in cancer_genes and parsed_element[\"geneB\"][\"entrezGeneId\"] in cancer_genes:\n+                filtered_payload += [element]\n+        else:\n+            if parsed_element[\"gene\"][\"entrezGeneId\"] in cancer_genes:\n+                filtered_payload += [element]\n+    return filtered_payload\n+\n+def fetch_oncokb_annotations(payload_list, request_url, sv=False):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM4NzgxMw==", "bodyText": "We tried to implement Structural Variant functions (at least for the update script) as a \"preparation\" when we have SV finished. However, this needs to be finalized once the Structural Variants are fully working.", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r537387813", "createdAt": "2020-12-07T10:18:37Z", "author": {"login": "oplantalech"}, "path": "core/src/main/scripts/importer/libImportOncokb.py", "diffHunk": "@@ -0,0 +1,236 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script.\n+\n+Run with the command line option --help for usage information.\n+\"\"\"\n+\n+import re\n+import os\n+import requests\n+import json\n+\n+from . import validateData\n+\n+\n+BATCH_SIZE = 200\n+\n+\n+def load_portal_genes(server_url):\n+    parsed_json = request_from_portal_api(server_url, \"genes\", logging.getLogger(__name__))\n+    return transform_symbol_entrez_map(parsed_json, 'hugoGeneSymbol')\n+\n+\n+# after: getProteinStart() in ExtendedMutationUtil.java\n+def get_protein_pos_start(protein_position, protein_change):\n+    start = -1\n+    if protein_position is not None:\n+        start_end = protein_position.split('/')[0].split('-')\n+        if len(start_end) > 0:\n+            start = start_end[0]\n+    if start == -1 and protein_change is not None:\n+        start_stop = annotate_protein_change(protein_change)\n+        start = str(start_stop['start'])\n+    return start\n+\n+\n+# after: getProteinPosEnd() in ExtendedMutationUtil.java\n+def get_protein_pos_end(protein_position, protein_change):\n+    stop = -1\n+    if protein_position is not None:\n+        start_end = protein_position.split('/')[0].split('-')\n+        if len(start_end) > 1:\n+            stop = start_end[1]\n+    if stop == -1 and protein_change is not None:\n+        start_stop = annotate_protein_change(protein_change)\n+        stop = str(start_stop['stop'])\n+    return stop\n+\n+\n+# after: annotateProteinChange() in ExtendedMutationUtil.java\n+def annotate_protein_change(protein_change):\n+    start = -1\n+    end = -1\n+    match = re.findall(r'^([A-Z\\*]+)([0-9]+)([A-Z\\*\\?]*)$', protein_change)\n+    if len(match) > 0:\n+        ref = match[0][0]\n+        var = match[0][2]\n+        refL = len(ref)\n+        start = int(match[0][1])\n+        if ref == var or ref == '*' or var == '*' or start == 1 or var == '?':\n+            end = start\n+        else:\n+            end = start + refL - 1\n+    else:\n+        match = re.findall(r'[A-Z]?([0-9]+)(_[A-Z]?([0-9]+))?(delins|ins)([A-Z]+)', protein_change)\n+        if len(match) > 0:\n+            start = int(match[0][0])\n+            if match[0][2] is not None:\n+                end = int(match[0][2])\n+            else:\n+                end = start\n+        else:\n+            match = re.findall(r'[A-Z]?([0-9]+)(_[A-Z]?([0-9]+))?(_)?splice', protein_change)\n+            if len(match) > 0:\n+                start = int(match[0][0])\n+                if match[0][2] is not None and match[0][2] != '':\n+                    end = int(match[0][2])\n+                else:\n+                    end = start\n+            else:\n+                match = re.findall(r'[A-Z]?([0-9]+)_[A-Z]?([0-9]+)(.+)', protein_change)\n+                if len(match) > 0:\n+                    start = int(match[0][0])\n+                    end = int(match[0][1])\n+                else:\n+                    match = re.findall(r'([A-Z\\*])([0-9]+)[A-Z]?fs.*', protein_change)\n+                    if len(match) > 0:\n+                        start = int(match[0][1])\n+                        end = start\n+                    else:\n+                        match = re.findall(r'([A-Z]+)?([0-9]+)((ins)|(del)|(dup))', protein_change)\n+                        if len(match) > 0:\n+                            start = int(match[0][1])\n+                            end = start\n+    return {\"start\": start, \"stop\": end}\n+\n+\n+def evaluate_driver_passenger(oncogenic):\n+    \"\"\"Translate the OncoKB 'oncogenic' value to Putative_Driver' or Putative_Passenger'\"\"\"\n+    custom_annotation = 'Putative_Passenger'\n+    if oncogenic.lower() in ['oncogenic', 'likely oncogenic', 'predicted oncogenic']:\n+        custom_annotation = 'Putative_Driver'\n+    return custom_annotation\n+\n+\n+def get_first_line(file_handle):\n+    \"\"\"Read the first line of a file ignoring comment lines.\"\"\"\n+    while True:\n+        first_line = file_handle.readline()\n+        if not first_line.startswith('#'):\n+            file_handle.close()\n+            return first_line\n+\n+\n+def find_meta_file_by_fields(study_dir, field_dict):\n+    \"\"\"In the study directory find the meta file that holds specified field values.\"\"\"\n+    filenames = os.listdir(study_dir)\n+    meta_files = [ file for file in filenames if file.startswith('meta_')]\n+    meta_files = [ study_dir + \"/\" + file for file in meta_files ]\n+    for meta_file in meta_files:\n+        fields = read_meta_file(meta_file)\n+        match_found = True\n+        for field_name, field_value in field_dict.items():\n+            if field_name not in fields or fields[field_name] != field_value:\n+                match_found = False\n+        if match_found:\n+            return os.path.join(study_dir, meta_file)\n+    return None\n+\n+\n+def find_data_file_from_meta_file(metafile_path):\n+    \"\"\"From specified meta file return the value of the 'data_filename' field.\"\"\"\n+    fields = read_meta_file(metafile_path)\n+    return fields['data_filename']\n+\n+\n+def read_meta_file(metafile_path):\n+    \"\"\"Read fields of specified meta into a dict.\"\"\"\n+    fields = {}\n+    with open(metafile_path) as metafile:\n+        for line in metafile:\n+            if line == '\\n':\n+                continue\n+            match = re.findall(r'\\s*(\\S+)\\s*:\\s*(\\S+)', line)[0]\n+            fields[match[0]] = match[1]\n+    return fields\n+\n+def get_oncokb_cancer_genes():\n+    \"\"\"Do a call to OncoKB to retrieve the Cancer Gene List. \"\"\"\n+    request_url = \"https://public.api.oncokb.org/api/v1/utils/allCuratedGenes\"\n+    request = requests.get(url=request_url)\n+\n+    if request.ok:\n+        return request.json()\n+    else:\n+        if request.status_code == 404:\n+            raise ConnectionError(\n+                \"An error occurred when trying to connect to OncoKB for retrieving of mutation annotations.\")\n+        else:\n+            request.raise_for_status()\n+\n+def get_annotated_oncokb_cancer_genes_by_entrezId():\n+    \"\"\" Get a list with the Entrez Gene IDs of the OncoKB Cancer Gene List, only the genes that have\n+        annotations. \"\"\"\n+    cancer_genes = get_oncokb_cancer_genes()\n+    entrez_ids = []\n+    for gene in cancer_genes:\n+        entrez_ids += [gene[\"entrezGeneId\"]]\n+    return entrez_ids\n+\n+def filter_payload(payload_list, sv):\n+    \"\"\" Remove the genes that are not an OncoKB Cancer Gene List from the payload. \"\"\"\n+    cancer_genes = get_annotated_oncokb_cancer_genes_by_entrezId()\n+    filtered_payload = []\n+    for element in payload_list:\n+        parsed_element = json.loads(element)\n+        if sv:\n+            if parsed_element[\"geneA\"][\"entrezGeneId\"] in cancer_genes and parsed_element[\"geneB\"][\"entrezGeneId\"] in cancer_genes:\n+                filtered_payload += [element]\n+        else:\n+            if parsed_element[\"gene\"][\"entrezGeneId\"] in cancer_genes:\n+                filtered_payload += [element]\n+    return filtered_payload\n+\n+def fetch_oncokb_annotations(payload_list, request_url, sv=False):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NTQzMA=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTYxNTI5OnYy", "diffSide": "RIGHT", "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMDozODo0NVrOH_hMMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNjoxNDowMVrOIQX-7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NjEyOA==", "bodyText": "Can we do a quick standardize the language in the output? We mix use OncoKB and OncoKb through out different files. Let's stick to OncoKB. Thanks!", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r536366128", "createdAt": "2020-12-04T20:38:45Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:\n+                continue\n+            feature['copyNameAlterationType'] = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(feature['alteration'])]\n+            for column_name, index in header_indexes.items():\n+                value = line_elements[index]\n+                if value != '':\n+                    feature[column_name] = value\n+                elif column_name != 'Entrez_Gene_Id':\n+                    print(Color.RED + \"Empty value encounterd in column '\" + column_name + \"' in row \" + str(\n+                        row_counter) + \". OncoKb annotations cannot be imported. Please fix and rerun.\" + Color.END,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM4Nzk5MA==", "bodyText": "Fixed", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r537387990", "createdAt": "2020-12-07T10:18:54Z", "author": {"login": "oplantalech"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:\n+                continue\n+            feature['copyNameAlterationType'] = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(feature['alteration'])]\n+            for column_name, index in header_indexes.items():\n+                value = line_elements[index]\n+                if value != '':\n+                    feature[column_name] = value\n+                elif column_name != 'Entrez_Gene_Id':\n+                    print(Color.RED + \"Empty value encounterd in column '\" + column_name + \"' in row \" + str(\n+                        row_counter) + \". OncoKb annotations cannot be imported. Please fix and rerun.\" + Color.END,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NjEyOA=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDA0MTA2OQ==", "bodyText": "Thanks!", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r554041069", "createdAt": "2021-01-08T16:14:01Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/importOncokbDiscreteCNA.py", "diffHunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"OncoKB annotation import script for discrete CNA files.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+from os import path\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+required_cna_columns = ['Hugo_Symbol']\n+\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+\n+def main_import(args):\n+\n+    study_dir = args.study_directory\n+    server_url = args.url_server\n+\n+    # get a logger to emit messages\n+    logger = logging.getLogger(__name__)\n+    logger.setLevel(logging.INFO)\n+    exit_status_handler = validateData.MaxLevelTrackingHandler()\n+    logger.addHandler(exit_status_handler)\n+\n+    # set default message handler\n+    text_handler = logging.StreamHandler(sys.stdout)\n+    text_handler.setFormatter(\n+        cbioportal_common.LogfileStyleFormatter(study_dir))\n+    collapsing_text_handler = cbioportal_common.CollapsingLogMessageHandler(\n+        capacity=5e5,\n+        flushLevel=logging.CRITICAL,\n+        target=text_handler)\n+    collapsing_text_handler.setLevel(logging.INFO)\n+    logger.addHandler(collapsing_text_handler)\n+\n+    meta_cna_file_path = libImportOncokb.find_meta_file_by_fields(study_dir, {'genetic_alteration_type': 'COPY_NUMBER_ALTERATION', 'datatype': 'DISCRETE'})\n+    cna_file_path = os.path.join(study_dir, libImportOncokb.find_data_file_from_meta_file(meta_cna_file_path))\n+    pd_file_name = 'data_cna_pd_annotations.txt'\n+    pd_file_path = os.path.join(study_dir, pd_file_name)\n+    meta_dict = libImportOncokb.read_meta_file(meta_cna_file_path)\n+    if 'pd_annotations_filename' in meta_dict:\n+        raise RuntimeError(\n+            \"Custom driver annotations filename already specified in discrete CNA meta file. Please remove and rerun.\")\n+    if path.exists(pd_file_path):\n+        raise RuntimeError(\n+            \"Custom driver annotations file '\" + pd_file_path + \"' for discrete CNA already exists . Please remove and rerun.\")\n+    check_required_columns(libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t'))\n+\n+    global portal_instance\n+    if hasattr(args, 'portal_info_dir') and args.portal_info_dir is not None:\n+        portal_instance = validateData.load_portal_info(args.portal_info_dir, logger,\n+                                           offline=True)\n+    else:\n+        portal_instance = validateData.load_portal_info(server_url, logger)\n+\n+    features = get_features(cna_file_path)\n+    id_to_annotation = fetch_oncokb_annotations(features)\n+    for feature in features:\n+        if feature['id'] in id_to_annotation:\n+            feature['oncogenic'] = id_to_annotation[feature['id']]['oncogenic']\n+\n+    print(\"Updating study files ...\", end = '')\n+    write_annotations_to_file(features, pd_file_path)\n+    update_cna_metafile(meta_cna_file_path, pd_file_name)\n+    print(\" DONE\")\n+\n+    logger.info('Import complete')\n+\n+    return exit_status_handler.get_exit_status()\n+\n+\n+def open_cna_file(file_name):\n+    \"\"\"Open CNA file and handle exception when not found.\"\"\"\n+    try:\n+        file = open(file_name)\n+    except FileNotFoundError:\n+        raise FilenotFoundError(\"Could not open discrete CNA file at path '\" + file_name + \"'\")\n+    return file\n+\n+\n+def get_features(cna_file_path):\n+    \"\"\"Extract CNA events from CNA data file.\"\"\"\n+    header_elements = libImportOncokb.get_first_line(open_cna_file(cna_file_path)).rstrip('\\n').split('\\t')\n+    header_indexes = {}\n+    for required_column in required_cna_columns + ['Entrez_Gene_Id']:\n+        header_indexes[required_column] = header_elements.index(required_column)\n+    sample_ids = [i for j, i in enumerate(header_elements) if j not in header_indexes.values()]\n+    sample_indexes = {}\n+    for sample_id in sample_ids:\n+        sample_indexes[sample_id] = header_elements.index(sample_id)\n+\n+    features = []\n+    cna_file = open_cna_file(cna_file_path)\n+    print(\"Reading features from file ...\", end = '')\n+    for line in cna_file:\n+        if line == '\\n' or line.startswith('#') or line.startswith(header_elements[0]):\n+            continue  # skip comment and header line\n+        line_elements = line.rstrip('\\n').split('\\t')\n+        for sample_id in sample_ids:\n+            feature = {}\n+            feature['sample_id'] = sample_id\n+            feature['alteration'] = int(line_elements[sample_indexes[sample_id]])\n+            # cna value 0 (no CNA) is skipped\n+            if feature['alteration'] == 0:\n+                continue\n+            feature['copyNameAlterationType'] = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(feature['alteration'])]\n+            for column_name, index in header_indexes.items():\n+                value = line_elements[index]\n+                if value != '':\n+                    feature[column_name] = value\n+                elif column_name != 'Entrez_Gene_Id':\n+                    print(Color.RED + \"Empty value encounterd in column '\" + column_name + \"' in row \" + str(\n+                        row_counter) + \". OncoKb annotations cannot be imported. Please fix and rerun.\" + Color.END,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NjEyOA=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTY0NjMyOnYy", "diffSide": "RIGHT", "path": "core/src/main/scripts/importer/updateOncokbAnnotations.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMDo0Nzo0MlrOH_hdoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMDoxOToyMVrOIAflAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM3MDU5Mw==", "bodyText": "In the importOncokbMutation.py, you have similar logics. Are they different?", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r536370593", "createdAt": "2020-12-04T20:47:42Z", "author": {"login": "zhx828"}, "path": "core/src/main/scripts/importer/updateOncokbAnnotations.py", "diffHunk": "@@ -0,0 +1,379 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"Script to update OncoKB annotation for the provided study.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+import MySQLdb\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+ERROR_FILE = sys.stderr\n+DATABASE_HOST = 'db.host'\n+DATABASE_NAME = 'db.portal_db_name'\n+DATABASE_USER = 'db.user'\n+DATABASE_PW = 'db.password'\n+REQUIRED_PROPERTIES = [DATABASE_HOST, DATABASE_NAME, DATABASE_USER, DATABASE_PW]\n+REFERENCE_GENOME = {'hg19': 'GRCh37', 'hg38': 'GRCh38'}\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+class PortalProperties(object):\n+    \"\"\" Properties object class, just has fields for db conn \"\"\"\n+\n+    def __init__(self, database_host, database_name, database_user, database_pw):\n+        # default port:\n+        self.database_port = 3306\n+        # if there is a port added to the host name, split and use this one:\n+        if ':' in database_host:\n+            host_and_port = database_host.split(':')\n+            self.database_host = host_and_port[0]\n+            if self.database_host.strip() == 'localhost':\n+                print(\n+                    \"Invalid host config '\" + database_host + \"' in properties file. If you want to specify a port on local host use '127.0.0.1' instead of 'localhost'\",\n+                    file=ERROR_FILE)\n+                sys.exit(1)\n+            self.database_port = int(host_and_port[1])\n+        else:\n+            self.database_host = database_host\n+        self.database_name = database_name\n+        self.database_user = database_user\n+        self.database_pw = database_pw\n+\n+def get_portal_properties(properties_filename):\n+    \"\"\" Returns a properties object \"\"\"\n+    properties = {}\n+    with open(properties_filename, 'r') as properties_file:\n+        for line in properties_file:\n+            line = line.strip()\n+            # skip line if its blank or a comment\n+            if len(line) == 0 or line.startswith('#'):\n+                continue\n+            try:\n+                name, value = line.split('=', maxsplit=1)\n+            except ValueError:\n+                print(\n+                    'Skipping invalid entry in property file: %s' % (line),\n+                    file=ERROR_FILE)\n+                continue\n+            properties[name] = value.strip()\n+    missing_properties = []\n+    for required_property in REQUIRED_PROPERTIES:\n+        if required_property not in properties or len(properties[required_property]) == 0:\n+            missing_properties.append(required_property)\n+    if missing_properties:\n+        print(\n+            'Missing required properties : (%s)' % (', '.join(missing_properties)),\n+            file=ERROR_FILE)\n+        return None\n+    # return an instance of PortalProperties\n+    return PortalProperties(properties[DATABASE_HOST],\n+                            properties[DATABASE_NAME],\n+                            properties[DATABASE_USER],\n+                            properties[DATABASE_PW])\n+\n+def get_db_cursor(portal_properties):\n+    \"\"\" Establishes a MySQL connection \"\"\"\n+    try:\n+        connection = MySQLdb.connect(host=portal_properties.database_host,\n+            port = portal_properties.database_port,\n+            user = portal_properties.database_user,\n+            passwd = portal_properties.database_pw,\n+            db = portal_properties.database_name)\n+        connection.autocommit = False\n+    except MySQLdb.Error as exception:\n+        print(exception, file=ERROR_FILE)\n+        port_info = ''\n+        if portal_properties.database_host.strip() != 'localhost':\n+            # only add port info if host is != localhost (since with localhost apparently sockets are used and not the given port) TODO - perhaps this applies for all names vs ips?\n+            port_info = \" on port \" + str(portal_properties.database_port)\n+        message = (\n+            \"--> Error connecting to server \"\n+            + portal_properties.database_host\n+            + port_info)\n+        print(message, file=ERROR_FILE)\n+        raise ConnectionError(message) from exception\n+    if connection is not None:\n+        return connection, connection.cursor()\n+\n+def get_current_mutation_data(study_id, cursor):\n+    \"\"\" Get mutation data from the current study.\n+        Returns an array of dictionaries, with the following keys:\n+        id, geneticProfileId, entrezGeneId, alteration, and consequence\n+    \"\"\"\n+    mutations = []\n+    try:\n+        cursor.execute('SELECT genetic_profile.GENETIC_PROFILE_ID, mutation_event.ENTREZ_GENE_ID, PROTEIN_CHANGE as ALTERATION, ' +\n+        'MUTATION_TYPE as CONSEQUENCE, mutation.MUTATION_EVENT_ID, mutation.SAMPLE_ID FROM cbioportal.mutation_event ' +\n+        'inner join mutation on mutation.MUTATION_EVENT_ID = mutation_event.MUTATION_EVENT_ID ' +\n+        'inner join genetic_profile on genetic_profile.GENETIC_PROFILE_ID = mutation.GENETIC_PROFILE_ID ' +\n+        'inner join cancer_study on cancer_study.CANCER_STUDY_ID = genetic_profile.CANCER_STUDY_ID ' +\n+        'WHERE cancer_study.CANCER_STUDY_IDENTIFIER = \"'+study_id +'\"')\n+        for row in cursor.fetchall():\n+            mutations += [{ \"id\": \"_\".join([str(row[4]), str(row[0]), str(row[5])]), \"geneticProfileId\": row[0], \"entrezGeneId\": row[1],\n+                            \"alteration\": row[2], \"consequence\": row[3]}]\n+    except MySQLdb.Error as msg:\n+        print(msg, file=ERROR_FILE)\n+        return None\n+    return mutations\n+\n+def get_current_cna_data(study_id, cursor):\n+    \"\"\" Get cna data from the current study.\n+        Returns an array of dictionaries, with the following keys:\n+        id, geneticProfileId, entrezGeneId, and alteration\n+    \"\"\"\n+    cna = []\n+    try:\n+        cursor.execute('SELECT genetic_profile.GENETIC_PROFILE_ID, '+ 'cna_event.ENTREZ_GENE_ID, cna_event.ALTERATION, '+\n+        'sample_cna_event.CNA_EVENT_ID, sample_cna_event.SAMPLE_ID from cbioportal.cna_event ' +\n+        'inner join sample_cna_event on sample_cna_event.CNA_EVENT_ID = cna_event.CNA_EVENT_ID '+\n+        'inner join genetic_profile on genetic_profile.GENETIC_PROFILE_ID = sample_cna_event.GENETIC_PROFILE_ID '+\n+        'inner join cancer_study on cancer_study.CANCER_STUDY_ID = genetic_profile.CANCER_STUDY_ID '+\n+        'WHERE cancer_study.CANCER_STUDY_IDENTIFIER = \"'+study_id +'\"')\n+        for row in cursor.fetchall():\n+            alteration = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(row[2])]\n+            cna += [{\"id\": \"_\".join([str(row[3]), str(row[0]), str(row[4])]), \"geneticProfileId\": row[0], \"entrezGeneId\": row[1],\n+                    \"alteration\": alteration}]\n+    except MySQLdb.Error as msg:\n+        print(msg, file=ERROR_FILE)\n+        return None\n+    return cna\n+\n+def get_current_sv_data(study_id, cursor):\n+    \"\"\" Get structural variant data from the current study.\n+        Returns an array of dictionaries, with the following keys:\n+        id, geneticProfileId, entrezGeneIdA, entrezGeneIdB, and structuralVariantType\n+    \"\"\"\n+    sv = []\n+    try:\n+        cursor.execute('SELECT genetic_profile.GENETIC_PROFILE_ID, '+ 'structural_variant.SITE1_ENTREZ_GENE_ID, '+\n+        'structural_variant.SITE2_ENTREZ_GENE_ID, structural_variant.EVENT_INFO, ' +\n+        'structural_variant.INTERNAL_ID, structural_variant.SAMPLE_ID from cbioportal.structural_variant ' +\n+        'inner join genetic_profile on genetic_profile.GENETIC_PROFILE_ID = structural_variant.GENETIC_PROFILE_ID '+\n+        'inner join cancer_study on cancer_study.CANCER_STUDY_ID = genetic_profile.CANCER_STUDY_ID '+\n+        'WHERE cancer_study.CANCER_STUDY_IDENTIFIER = \"'+study_id +'\"')\n+        for row in cursor.fetchall():\n+            sv += [{\"id\": \"_\".join([str(row[4]), str(row[0]), str(row[5])]), \"geneticProfileId\": row[0], \"entrezGeneIdA\": row[1],\n+                    \"entrezGeneIdB\": row[2], \"structuralVariantType\": row[3]}]\n+    except MySQLdb.Error as msg:\n+        print(msg, file=ERROR_FILE)\n+        return None\n+    return sv\n+\n+def get_reference_genome(study_id, cursor):\n+    \"\"\" Get reference genome from the study \"\"\"\n+    ref_genome = []\n+    try:\n+        cursor.execute('SELECT reference_genome.NAME FROM reference_genome ' +\n+        'inner join cancer_study ON cancer_study.reference_genome_id = reference_genome.reference_genome_id ' +\n+        'WHERE cancer_study.CANCER_STUDY_IDENTIFIER = \"'+study_id +'\"')\n+        for row in cursor.fetchall():\n+            ref_genome += [row[0]]\n+        if len(ref_genome) == 1:\n+            return REFERENCE_GENOME[ref_genome[0]]\n+        else:\n+            raise ValueError(\"There is an error when retrieving the reference genome, as multiple values have been retrieved: \"+ref_genome)\n+    except MySQLdb.Error as msg:\n+        print(msg, file=ERROR_FILE)\n+\n+def fetch_oncokb_mutation_annotations(mutation_data, ref_genome):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM4ODI4OQ==", "bodyText": "The logic is similar, but the data is pre- and post-processed in the import methods before it uses the common code in libImportOncoKb", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r537388289", "createdAt": "2020-12-07T10:19:21Z", "author": {"login": "oplantalech"}, "path": "core/src/main/scripts/importer/updateOncokbAnnotations.py", "diffHunk": "@@ -0,0 +1,379 @@\n+#!/usr/bin/env python3\n+\n+#\n+# Copyright (c) 2020 The Hyve B.V.\n+# This code is licensed under the GNU Affero General Public License (AGPL),\n+# version 3, or (at your option) any later version.\n+#\n+\n+#\n+# This file is part of cBioPortal.\n+#\n+# cBioPortal is free software: you can redistribute it and/or modify\n+# it under the terms of the GNU Affero General Public License as\n+# published by the Free Software Foundation, either version 3 of the\n+# License.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU Affero General Public License for more details.\n+#\n+# You should have received a copy of the GNU Affero General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+#\n+\n+\"\"\"Script to update OncoKB annotation for the provided study.\n+\"\"\"\n+\n+import argparse\n+import importlib\n+import logging.handlers\n+import os\n+import requests\n+import sys\n+import MySQLdb\n+from pathlib import Path\n+\n+# configure relative imports if running as a script; see PEP 366\n+# it might passed as empty string by certain tooling to mark a top level module\n+if __name__ == \"__main__\" and (__package__ is None or __package__ == ''):\n+    # replace the script's location in the Python search path by the main\n+    # scripts/ folder, above it, so that the importer package folder is in\n+    # scope and *not* directly in sys.path; see PEP 395\n+    sys.path[0] = str(Path(sys.path[0]).resolve().parent)\n+    __package__ = 'importer'\n+    # explicitly import the package, which is needed on CPython 3.4 because it\n+    # doesn't include https://github.com/python/cpython/pull/2639\n+    importlib.import_module(__package__)\n+\n+from . import cbioportal_common\n+from . import libImportOncokb\n+from . import validateData\n+\n+ERROR_FILE = sys.stderr\n+DATABASE_HOST = 'db.host'\n+DATABASE_NAME = 'db.portal_db_name'\n+DATABASE_USER = 'db.user'\n+DATABASE_PW = 'db.password'\n+REQUIRED_PROPERTIES = [DATABASE_HOST, DATABASE_NAME, DATABASE_USER, DATABASE_PW]\n+REFERENCE_GENOME = {'hg19': 'GRCh37', 'hg38': 'GRCh38'}\n+\n+# from: cbioportal-frontend file CopyNumberUtils.ts\n+cna_alteration_types = {\n+    \"DELETION\": -2,\n+    \"LOSS\": -1,\n+    \"GAIN\": 1,\n+    \"AMPLIFICATION\": 2,\n+}\n+\n+class PortalProperties(object):\n+    \"\"\" Properties object class, just has fields for db conn \"\"\"\n+\n+    def __init__(self, database_host, database_name, database_user, database_pw):\n+        # default port:\n+        self.database_port = 3306\n+        # if there is a port added to the host name, split and use this one:\n+        if ':' in database_host:\n+            host_and_port = database_host.split(':')\n+            self.database_host = host_and_port[0]\n+            if self.database_host.strip() == 'localhost':\n+                print(\n+                    \"Invalid host config '\" + database_host + \"' in properties file. If you want to specify a port on local host use '127.0.0.1' instead of 'localhost'\",\n+                    file=ERROR_FILE)\n+                sys.exit(1)\n+            self.database_port = int(host_and_port[1])\n+        else:\n+            self.database_host = database_host\n+        self.database_name = database_name\n+        self.database_user = database_user\n+        self.database_pw = database_pw\n+\n+def get_portal_properties(properties_filename):\n+    \"\"\" Returns a properties object \"\"\"\n+    properties = {}\n+    with open(properties_filename, 'r') as properties_file:\n+        for line in properties_file:\n+            line = line.strip()\n+            # skip line if its blank or a comment\n+            if len(line) == 0 or line.startswith('#'):\n+                continue\n+            try:\n+                name, value = line.split('=', maxsplit=1)\n+            except ValueError:\n+                print(\n+                    'Skipping invalid entry in property file: %s' % (line),\n+                    file=ERROR_FILE)\n+                continue\n+            properties[name] = value.strip()\n+    missing_properties = []\n+    for required_property in REQUIRED_PROPERTIES:\n+        if required_property not in properties or len(properties[required_property]) == 0:\n+            missing_properties.append(required_property)\n+    if missing_properties:\n+        print(\n+            'Missing required properties : (%s)' % (', '.join(missing_properties)),\n+            file=ERROR_FILE)\n+        return None\n+    # return an instance of PortalProperties\n+    return PortalProperties(properties[DATABASE_HOST],\n+                            properties[DATABASE_NAME],\n+                            properties[DATABASE_USER],\n+                            properties[DATABASE_PW])\n+\n+def get_db_cursor(portal_properties):\n+    \"\"\" Establishes a MySQL connection \"\"\"\n+    try:\n+        connection = MySQLdb.connect(host=portal_properties.database_host,\n+            port = portal_properties.database_port,\n+            user = portal_properties.database_user,\n+            passwd = portal_properties.database_pw,\n+            db = portal_properties.database_name)\n+        connection.autocommit = False\n+    except MySQLdb.Error as exception:\n+        print(exception, file=ERROR_FILE)\n+        port_info = ''\n+        if portal_properties.database_host.strip() != 'localhost':\n+            # only add port info if host is != localhost (since with localhost apparently sockets are used and not the given port) TODO - perhaps this applies for all names vs ips?\n+            port_info = \" on port \" + str(portal_properties.database_port)\n+        message = (\n+            \"--> Error connecting to server \"\n+            + portal_properties.database_host\n+            + port_info)\n+        print(message, file=ERROR_FILE)\n+        raise ConnectionError(message) from exception\n+    if connection is not None:\n+        return connection, connection.cursor()\n+\n+def get_current_mutation_data(study_id, cursor):\n+    \"\"\" Get mutation data from the current study.\n+        Returns an array of dictionaries, with the following keys:\n+        id, geneticProfileId, entrezGeneId, alteration, and consequence\n+    \"\"\"\n+    mutations = []\n+    try:\n+        cursor.execute('SELECT genetic_profile.GENETIC_PROFILE_ID, mutation_event.ENTREZ_GENE_ID, PROTEIN_CHANGE as ALTERATION, ' +\n+        'MUTATION_TYPE as CONSEQUENCE, mutation.MUTATION_EVENT_ID, mutation.SAMPLE_ID FROM cbioportal.mutation_event ' +\n+        'inner join mutation on mutation.MUTATION_EVENT_ID = mutation_event.MUTATION_EVENT_ID ' +\n+        'inner join genetic_profile on genetic_profile.GENETIC_PROFILE_ID = mutation.GENETIC_PROFILE_ID ' +\n+        'inner join cancer_study on cancer_study.CANCER_STUDY_ID = genetic_profile.CANCER_STUDY_ID ' +\n+        'WHERE cancer_study.CANCER_STUDY_IDENTIFIER = \"'+study_id +'\"')\n+        for row in cursor.fetchall():\n+            mutations += [{ \"id\": \"_\".join([str(row[4]), str(row[0]), str(row[5])]), \"geneticProfileId\": row[0], \"entrezGeneId\": row[1],\n+                            \"alteration\": row[2], \"consequence\": row[3]}]\n+    except MySQLdb.Error as msg:\n+        print(msg, file=ERROR_FILE)\n+        return None\n+    return mutations\n+\n+def get_current_cna_data(study_id, cursor):\n+    \"\"\" Get cna data from the current study.\n+        Returns an array of dictionaries, with the following keys:\n+        id, geneticProfileId, entrezGeneId, and alteration\n+    \"\"\"\n+    cna = []\n+    try:\n+        cursor.execute('SELECT genetic_profile.GENETIC_PROFILE_ID, '+ 'cna_event.ENTREZ_GENE_ID, cna_event.ALTERATION, '+\n+        'sample_cna_event.CNA_EVENT_ID, sample_cna_event.SAMPLE_ID from cbioportal.cna_event ' +\n+        'inner join sample_cna_event on sample_cna_event.CNA_EVENT_ID = cna_event.CNA_EVENT_ID '+\n+        'inner join genetic_profile on genetic_profile.GENETIC_PROFILE_ID = sample_cna_event.GENETIC_PROFILE_ID '+\n+        'inner join cancer_study on cancer_study.CANCER_STUDY_ID = genetic_profile.CANCER_STUDY_ID '+\n+        'WHERE cancer_study.CANCER_STUDY_IDENTIFIER = \"'+study_id +'\"')\n+        for row in cursor.fetchall():\n+            alteration = list(cna_alteration_types.keys())[\n+                list(cna_alteration_types.values()).index(row[2])]\n+            cna += [{\"id\": \"_\".join([str(row[3]), str(row[0]), str(row[4])]), \"geneticProfileId\": row[0], \"entrezGeneId\": row[1],\n+                    \"alteration\": alteration}]\n+    except MySQLdb.Error as msg:\n+        print(msg, file=ERROR_FILE)\n+        return None\n+    return cna\n+\n+def get_current_sv_data(study_id, cursor):\n+    \"\"\" Get structural variant data from the current study.\n+        Returns an array of dictionaries, with the following keys:\n+        id, geneticProfileId, entrezGeneIdA, entrezGeneIdB, and structuralVariantType\n+    \"\"\"\n+    sv = []\n+    try:\n+        cursor.execute('SELECT genetic_profile.GENETIC_PROFILE_ID, '+ 'structural_variant.SITE1_ENTREZ_GENE_ID, '+\n+        'structural_variant.SITE2_ENTREZ_GENE_ID, structural_variant.EVENT_INFO, ' +\n+        'structural_variant.INTERNAL_ID, structural_variant.SAMPLE_ID from cbioportal.structural_variant ' +\n+        'inner join genetic_profile on genetic_profile.GENETIC_PROFILE_ID = structural_variant.GENETIC_PROFILE_ID '+\n+        'inner join cancer_study on cancer_study.CANCER_STUDY_ID = genetic_profile.CANCER_STUDY_ID '+\n+        'WHERE cancer_study.CANCER_STUDY_IDENTIFIER = \"'+study_id +'\"')\n+        for row in cursor.fetchall():\n+            sv += [{\"id\": \"_\".join([str(row[4]), str(row[0]), str(row[5])]), \"geneticProfileId\": row[0], \"entrezGeneIdA\": row[1],\n+                    \"entrezGeneIdB\": row[2], \"structuralVariantType\": row[3]}]\n+    except MySQLdb.Error as msg:\n+        print(msg, file=ERROR_FILE)\n+        return None\n+    return sv\n+\n+def get_reference_genome(study_id, cursor):\n+    \"\"\" Get reference genome from the study \"\"\"\n+    ref_genome = []\n+    try:\n+        cursor.execute('SELECT reference_genome.NAME FROM reference_genome ' +\n+        'inner join cancer_study ON cancer_study.reference_genome_id = reference_genome.reference_genome_id ' +\n+        'WHERE cancer_study.CANCER_STUDY_IDENTIFIER = \"'+study_id +'\"')\n+        for row in cursor.fetchall():\n+            ref_genome += [row[0]]\n+        if len(ref_genome) == 1:\n+            return REFERENCE_GENOME[ref_genome[0]]\n+        else:\n+            raise ValueError(\"There is an error when retrieving the reference genome, as multiple values have been retrieved: \"+ref_genome)\n+    except MySQLdb.Error as msg:\n+        print(msg, file=ERROR_FILE)\n+\n+def fetch_oncokb_mutation_annotations(mutation_data, ref_genome):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM3MDU5Mw=="}, "originalCommit": {"oid": "ae885e2226d87b0b340c29e26ce245fd063e5c40"}, "originalPosition": 229}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU5MzMzNjQ5OnYy", "diffSide": "RIGHT", "path": ".github/workflows/integration-test.yml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQxMzo1OToyOFrOIf07Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQxNDowNzozM1rOIf1S1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDI0Mzg2Mg==", "bodyText": "not sure exactly where the resulting war gets copied to the docker image?", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r570243862", "createdAt": "2021-02-04T13:59:28Z", "author": {"login": "inodb"}, "path": ".github/workflows/integration-test.yml", "diffHunk": "@@ -0,0 +1,76 @@\n+name: Integration tests\n+on: [push, pull_request]\n+jobs:\n+  build:\n+    name: Integration tests\n+    runs-on: ubuntu-latest\n+    env: \n+      PORTAL_SOURCE_DIR: /home/runner/work/cbioportal/cbioportal/cbioportal\n+      PORTAL_COMPOSE_DIR: /home/runner/work/cbioportal/cbioportal/cbioportal-docker-compose\n+      PORTAL_INFO_DIR: /home/runner/work/cbioportal/cbioportal/portalInfo\n+    steps:\n+      - name: 'Checkout cbioportal repo'\n+        uses: actions/checkout@v2\n+        with:\n+          path: ./cbioportal\n+      - name: 'Install python requirements'\n+        working-directory: ./cbioportal\n+        run: |\n+          sudo apt-get install python3-setuptools && \\\n+          pip3 install -U wheel && \\\n+          pip3 install -r ./requirements.txt\n+      - name: 'Set up JDK 11'\n+        uses: actions/setup-java@v1\n+        with:\n+          java-version: 11\n+      - name: 'Cache Maven packages'\n+        uses: actions/cache@v1\n+        with:\n+          path: ~/.m2\n+          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}\n+          restore-keys: ${{ runner.os }}-m2\n+      - name: 'Build cbioportal'\n+        working-directory: ./cbioportal\n+        run: |\n+          mvn -DskipTests clean install", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db3abd441eb40a4ccf9715540798afb494c2aae9"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDI0OTk0Mg==", "bodyText": "ah here: test/integration/docker-compose-localbuild.yml", "url": "https://github.com/cBioPortal/cbioportal/pull/8090#discussion_r570249942", "createdAt": "2021-02-04T14:07:33Z", "author": {"login": "inodb"}, "path": ".github/workflows/integration-test.yml", "diffHunk": "@@ -0,0 +1,76 @@\n+name: Integration tests\n+on: [push, pull_request]\n+jobs:\n+  build:\n+    name: Integration tests\n+    runs-on: ubuntu-latest\n+    env: \n+      PORTAL_SOURCE_DIR: /home/runner/work/cbioportal/cbioportal/cbioportal\n+      PORTAL_COMPOSE_DIR: /home/runner/work/cbioportal/cbioportal/cbioportal-docker-compose\n+      PORTAL_INFO_DIR: /home/runner/work/cbioportal/cbioportal/portalInfo\n+    steps:\n+      - name: 'Checkout cbioportal repo'\n+        uses: actions/checkout@v2\n+        with:\n+          path: ./cbioportal\n+      - name: 'Install python requirements'\n+        working-directory: ./cbioportal\n+        run: |\n+          sudo apt-get install python3-setuptools && \\\n+          pip3 install -U wheel && \\\n+          pip3 install -r ./requirements.txt\n+      - name: 'Set up JDK 11'\n+        uses: actions/setup-java@v1\n+        with:\n+          java-version: 11\n+      - name: 'Cache Maven packages'\n+        uses: actions/cache@v1\n+        with:\n+          path: ~/.m2\n+          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}\n+          restore-keys: ${{ runner.os }}-m2\n+      - name: 'Build cbioportal'\n+        working-directory: ./cbioportal\n+        run: |\n+          mvn -DskipTests clean install", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDI0Mzg2Mg=="}, "originalCommit": {"oid": "db3abd441eb40a4ccf9715540798afb494c2aae9"}, "originalPosition": 35}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3492, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}