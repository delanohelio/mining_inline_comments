{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyNjM2ODk1", "number": 3076, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNDozNzo1OFrOD6Fiuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNTowNDo0MlrOENrxBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjM0ODExOnYy", "diffSide": "RIGHT", "path": "zipkin-lens/src/components/DiscoverPage/DiscoverPage.tsx", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNDozNzo1OFrOGRuGkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNjo0NDo0NFrOGr_eSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIzNDMyMg==", "bodyText": "For new files I've been trying to alphabetize imports, can you try it?", "url": "https://github.com/openzipkin/zipkin/pull/3076#discussion_r421234322", "createdAt": "2020-05-07T04:37:58Z", "author": {"login": "anuraaga"}, "path": "zipkin-lens/src/components/DiscoverPage/DiscoverPage.tsx", "diffHunk": "@@ -0,0 +1,65 @@\n+/* eslint-disable no-shadow */\n+/*\n+ * Copyright 2015-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+import React from 'react';", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0be2d24f60b86da32318d200359c3096d2882e37"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc0MjA0MA==", "bodyText": "What did you use for alphabetizing?\nVSCode extension?", "url": "https://github.com/openzipkin/zipkin/pull/3076#discussion_r448742040", "createdAt": "2020-07-02T04:29:26Z", "author": {"login": "tacigar"}, "path": "zipkin-lens/src/components/DiscoverPage/DiscoverPage.tsx", "diffHunk": "@@ -0,0 +1,65 @@\n+/* eslint-disable no-shadow */\n+/*\n+ * Copyright 2015-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+import React from 'react';", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIzNDMyMg=="}, "originalCommit": {"oid": "0be2d24f60b86da32318d200359c3096d2882e37"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc0MjM3OQ==", "bodyText": "Manual :) Eventually we can extend the eslint to do it automatically though, in other projects it's been automatic for me.", "url": "https://github.com/openzipkin/zipkin/pull/3076#discussion_r448742379", "createdAt": "2020-07-02T04:30:49Z", "author": {"login": "anuraaga"}, "path": "zipkin-lens/src/components/DiscoverPage/DiscoverPage.tsx", "diffHunk": "@@ -0,0 +1,65 @@\n+/* eslint-disable no-shadow */\n+/*\n+ * Copyright 2015-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+import React from 'react';", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIzNDMyMg=="}, "originalCommit": {"oid": "0be2d24f60b86da32318d200359c3096d2882e37"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc4MTg5OQ==", "bodyText": "I got it!", "url": "https://github.com/openzipkin/zipkin/pull/3076#discussion_r448781899", "createdAt": "2020-07-02T06:44:44Z", "author": {"login": "tacigar"}, "path": "zipkin-lens/src/components/DiscoverPage/DiscoverPage.tsx", "diffHunk": "@@ -0,0 +1,65 @@\n+/* eslint-disable no-shadow */\n+/*\n+ * Copyright 2015-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+import React from 'react';", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIzNDMyMg=="}, "originalCommit": {"oid": "0be2d24f60b86da32318d200359c3096d2882e37"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjM2NzE0OnYy", "diffSide": "RIGHT", "path": "zipkin-lens/src/components/DiscoverPage/DiscoverPageContent.tsx", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNDo0OTowNFrOGRuRvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNDo0OTowNFrOGRuRvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIzNzE4Mw==", "bodyText": "Instead of passing in history, location you should be able to call useHistory, useLocation in this hook", "url": "https://github.com/openzipkin/zipkin/pull/3076#discussion_r421237183", "createdAt": "2020-05-07T04:49:04Z", "author": {"login": "anuraaga"}, "path": "zipkin-lens/src/components/DiscoverPage/DiscoverPageContent.tsx", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright 2015-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+/* eslint-disable no-shadow */\n+import React, { useEffect, useCallback, useState, useMemo } from 'react';\n+import { useDispatch, useSelector } from 'react-redux';\n+import { RouteComponentProps, withRouter } from 'react-router-dom';\n+import {\n+  Box,\n+  Button,\n+  TextField,\n+  CircularProgress,\n+  Paper,\n+} from '@material-ui/core';\n+import { History, Location } from 'history';\n+import moment from 'moment';\n+import { createStyles, makeStyles, Theme } from '@material-ui/core/styles';\n+import { faHistory, faSearch } from '@fortawesome/free-solid-svg-icons';\n+import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\n+\n+import Criterion from './Criterion';\n+import { Lookback, fixedLookbackMap } from './lookback';\n+import { clearTraces, loadTraces } from '../../actions/traces-action';\n+import SearchBar from './SearchBar';\n+import { RootState } from '../../store';\n+import ExplainBox from './ExplainBox';\n+import LookbackMenu from './LookbackMenu';\n+\n+const TracesTab = require('./TracesTab').default;\n+\n+const useStyles = makeStyles((theme: Theme) =>\n+  createStyles({\n+    limitInput: {\n+      fontSize: '1rem',\n+      height: 31,\n+      padding: `${theme.spacing(0.1)}px ${theme.spacing(1)}px`,\n+    },\n+    searchButton: {\n+      height: 60,\n+      minWidth: 60,\n+      color: theme.palette.common.white,\n+    },\n+    paper: {\n+      height: '100%',\n+    },\n+  }),\n+);\n+\n+interface Props extends RouteComponentProps {}\n+\n+// Export for testing\n+export const useQueryParams = (history: History, location: Location) => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0be2d24f60b86da32318d200359c3096d2882e37"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjQwMTE0OnYy", "diffSide": "RIGHT", "path": "zipkin-lens/src/components/DiscoverPage/DiscoverPageContent.tsx", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNTowODo0MFrOGRulrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNTowODo0MFrOGRulrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI0MjI4Nw==", "bodyText": "Think it's more conventional to use undefined instead of null. For example, in interface definitions there's shorthand for it\ninterface Foo {\n  bar: boolean?;\n}", "url": "https://github.com/openzipkin/zipkin/pull/3076#discussion_r421242287", "createdAt": "2020-05-07T05:08:40Z", "author": {"login": "anuraaga"}, "path": "zipkin-lens/src/components/DiscoverPage/DiscoverPageContent.tsx", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright 2015-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+/* eslint-disable no-shadow */\n+import React, { useEffect, useCallback, useState, useMemo } from 'react';\n+import { useDispatch, useSelector } from 'react-redux';\n+import { RouteComponentProps, withRouter } from 'react-router-dom';\n+import {\n+  Box,\n+  Button,\n+  TextField,\n+  CircularProgress,\n+  Paper,\n+} from '@material-ui/core';\n+import { History, Location } from 'history';\n+import moment from 'moment';\n+import { createStyles, makeStyles, Theme } from '@material-ui/core/styles';\n+import { faHistory, faSearch } from '@fortawesome/free-solid-svg-icons';\n+import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\n+\n+import Criterion from './Criterion';\n+import { Lookback, fixedLookbackMap } from './lookback';\n+import { clearTraces, loadTraces } from '../../actions/traces-action';\n+import SearchBar from './SearchBar';\n+import { RootState } from '../../store';\n+import ExplainBox from './ExplainBox';\n+import LookbackMenu from './LookbackMenu';\n+\n+const TracesTab = require('./TracesTab').default;\n+\n+const useStyles = makeStyles((theme: Theme) =>\n+  createStyles({\n+    limitInput: {\n+      fontSize: '1rem',\n+      height: 31,\n+      padding: `${theme.spacing(0.1)}px ${theme.spacing(1)}px`,\n+    },\n+    searchButton: {\n+      height: 60,\n+      minWidth: 60,\n+      color: theme.palette.common.white,\n+    },\n+    paper: {\n+      height: '100%',\n+    },\n+  }),\n+);\n+\n+interface Props extends RouteComponentProps {}\n+\n+// Export for testing\n+export const useQueryParams = (history: History, location: Location) => {\n+  const setQueryParams = useCallback(\n+    (criteria: Criterion[], lookback: Lookback, limit: number) => {\n+      const params = new URLSearchParams();\n+      criteria.forEach((criterion) => {\n+        params.set(criterion.key, criterion.value);\n+      });\n+      switch (lookback.type) {\n+        case 'fixed':\n+          params.set('lookback', lookback.value);\n+          params.set('endTs', lookback.endTime.valueOf().toString());\n+          break;\n+        case 'custom':\n+          params.set('lookback', 'custom');\n+          params.set('endTs', lookback.endTime.valueOf().toString());\n+          params.set('startTs', lookback.startTime.valueOf().toString());\n+          break;\n+        default:\n+      }\n+      params.set('limit', limit.toString());\n+      history.push({\n+        pathname: location.pathname,\n+        search: params.toString(),\n+      });\n+    },\n+    [history, location.pathname],\n+  );\n+\n+  const criteria = useMemo(() => {\n+    const ret: Criterion[] = [];\n+    const params = new URLSearchParams(location.search);\n+\n+    params.forEach((value, key) => {\n+      switch (key) {\n+        case 'lookback':\n+        case 'startTs':\n+        case 'endTs':\n+        case 'limit':\n+          break;\n+        default:\n+          ret.push({ key, value });\n+          break;\n+      }\n+    });\n+    return ret;\n+  }, [location.search]);\n+\n+  const lookback = useMemo<Lookback | null>(() => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0be2d24f60b86da32318d200359c3096d2882e37"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjQzMDE5OnYy", "diffSide": "RIGHT", "path": "zipkin-lens/src/components/DiscoverPage/DiscoverPageContent.tsx", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNToyNDozM1rOGRu2tQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMDoxMjo1NVrOGvx7Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI0NjY0NQ==", "bodyText": "I think we should also handle when the lookback is milliseconds, not short durations tring", "url": "https://github.com/openzipkin/zipkin/pull/3076#discussion_r421246645", "createdAt": "2020-05-07T05:24:33Z", "author": {"login": "anuraaga"}, "path": "zipkin-lens/src/components/DiscoverPage/DiscoverPageContent.tsx", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright 2015-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+/* eslint-disable no-shadow */\n+import React, { useEffect, useCallback, useState, useMemo } from 'react';\n+import { useDispatch, useSelector } from 'react-redux';\n+import { RouteComponentProps, withRouter } from 'react-router-dom';\n+import {\n+  Box,\n+  Button,\n+  TextField,\n+  CircularProgress,\n+  Paper,\n+} from '@material-ui/core';\n+import { History, Location } from 'history';\n+import moment from 'moment';\n+import { createStyles, makeStyles, Theme } from '@material-ui/core/styles';\n+import { faHistory, faSearch } from '@fortawesome/free-solid-svg-icons';\n+import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\n+\n+import Criterion from './Criterion';\n+import { Lookback, fixedLookbackMap } from './lookback';\n+import { clearTraces, loadTraces } from '../../actions/traces-action';\n+import SearchBar from './SearchBar';\n+import { RootState } from '../../store';\n+import ExplainBox from './ExplainBox';\n+import LookbackMenu from './LookbackMenu';\n+\n+const TracesTab = require('./TracesTab').default;\n+\n+const useStyles = makeStyles((theme: Theme) =>\n+  createStyles({\n+    limitInput: {\n+      fontSize: '1rem',\n+      height: 31,\n+      padding: `${theme.spacing(0.1)}px ${theme.spacing(1)}px`,\n+    },\n+    searchButton: {\n+      height: 60,\n+      minWidth: 60,\n+      color: theme.palette.common.white,\n+    },\n+    paper: {\n+      height: '100%',\n+    },\n+  }),\n+);\n+\n+interface Props extends RouteComponentProps {}\n+\n+// Export for testing\n+export const useQueryParams = (history: History, location: Location) => {\n+  const setQueryParams = useCallback(\n+    (criteria: Criterion[], lookback: Lookback, limit: number) => {\n+      const params = new URLSearchParams();\n+      criteria.forEach((criterion) => {\n+        params.set(criterion.key, criterion.value);\n+      });\n+      switch (lookback.type) {\n+        case 'fixed':\n+          params.set('lookback', lookback.value);\n+          params.set('endTs', lookback.endTime.valueOf().toString());\n+          break;\n+        case 'custom':\n+          params.set('lookback', 'custom');\n+          params.set('endTs', lookback.endTime.valueOf().toString());\n+          params.set('startTs', lookback.startTime.valueOf().toString());\n+          break;\n+        default:\n+      }\n+      params.set('limit', limit.toString());\n+      history.push({\n+        pathname: location.pathname,\n+        search: params.toString(),\n+      });\n+    },\n+    [history, location.pathname],\n+  );\n+\n+  const criteria = useMemo(() => {\n+    const ret: Criterion[] = [];\n+    const params = new URLSearchParams(location.search);\n+\n+    params.forEach((value, key) => {\n+      switch (key) {\n+        case 'lookback':\n+        case 'startTs':\n+        case 'endTs':\n+        case 'limit':\n+          break;\n+        default:\n+          ret.push({ key, value });\n+          break;\n+      }\n+    });\n+    return ret;\n+  }, [location.search]);\n+\n+  const lookback = useMemo<Lookback | null>(() => {\n+    const ps = new URLSearchParams(location.search);\n+    const lookback = ps.get('lookback');\n+    if (!lookback) {\n+      return null;\n+    }\n+    if (lookback === 'custom') {\n+      const startTs = ps.get('startTs');\n+      const endTs = ps.get('endTs');\n+      if (!endTs || !startTs) {\n+        return null;\n+      }\n+      const startTime = moment(parseInt(startTs, 10));\n+      const endTime = moment(parseInt(endTs, 10));\n+      return {\n+        type: 'custom',\n+        startTime,\n+        endTime,\n+      };\n+    }\n+    const endTs = ps.get('endTs');\n+    if (!endTs) {\n+      return null;\n+    }\n+    const data = fixedLookbackMap[lookback];\n+    if (!data) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0be2d24f60b86da32318d200359c3096d2882e37"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcyMTQzMg==", "bodyText": "Are we going to handle this one? I think lookback can be a millisecond value if the user specifies the environment variable for it.", "url": "https://github.com/openzipkin/zipkin/pull/3076#discussion_r452721432", "createdAt": "2020-07-10T09:07:45Z", "author": {"login": "anuraaga"}, "path": "zipkin-lens/src/components/DiscoverPage/DiscoverPageContent.tsx", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright 2015-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+/* eslint-disable no-shadow */\n+import React, { useEffect, useCallback, useState, useMemo } from 'react';\n+import { useDispatch, useSelector } from 'react-redux';\n+import { RouteComponentProps, withRouter } from 'react-router-dom';\n+import {\n+  Box,\n+  Button,\n+  TextField,\n+  CircularProgress,\n+  Paper,\n+} from '@material-ui/core';\n+import { History, Location } from 'history';\n+import moment from 'moment';\n+import { createStyles, makeStyles, Theme } from '@material-ui/core/styles';\n+import { faHistory, faSearch } from '@fortawesome/free-solid-svg-icons';\n+import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\n+\n+import Criterion from './Criterion';\n+import { Lookback, fixedLookbackMap } from './lookback';\n+import { clearTraces, loadTraces } from '../../actions/traces-action';\n+import SearchBar from './SearchBar';\n+import { RootState } from '../../store';\n+import ExplainBox from './ExplainBox';\n+import LookbackMenu from './LookbackMenu';\n+\n+const TracesTab = require('./TracesTab').default;\n+\n+const useStyles = makeStyles((theme: Theme) =>\n+  createStyles({\n+    limitInput: {\n+      fontSize: '1rem',\n+      height: 31,\n+      padding: `${theme.spacing(0.1)}px ${theme.spacing(1)}px`,\n+    },\n+    searchButton: {\n+      height: 60,\n+      minWidth: 60,\n+      color: theme.palette.common.white,\n+    },\n+    paper: {\n+      height: '100%',\n+    },\n+  }),\n+);\n+\n+interface Props extends RouteComponentProps {}\n+\n+// Export for testing\n+export const useQueryParams = (history: History, location: Location) => {\n+  const setQueryParams = useCallback(\n+    (criteria: Criterion[], lookback: Lookback, limit: number) => {\n+      const params = new URLSearchParams();\n+      criteria.forEach((criterion) => {\n+        params.set(criterion.key, criterion.value);\n+      });\n+      switch (lookback.type) {\n+        case 'fixed':\n+          params.set('lookback', lookback.value);\n+          params.set('endTs', lookback.endTime.valueOf().toString());\n+          break;\n+        case 'custom':\n+          params.set('lookback', 'custom');\n+          params.set('endTs', lookback.endTime.valueOf().toString());\n+          params.set('startTs', lookback.startTime.valueOf().toString());\n+          break;\n+        default:\n+      }\n+      params.set('limit', limit.toString());\n+      history.push({\n+        pathname: location.pathname,\n+        search: params.toString(),\n+      });\n+    },\n+    [history, location.pathname],\n+  );\n+\n+  const criteria = useMemo(() => {\n+    const ret: Criterion[] = [];\n+    const params = new URLSearchParams(location.search);\n+\n+    params.forEach((value, key) => {\n+      switch (key) {\n+        case 'lookback':\n+        case 'startTs':\n+        case 'endTs':\n+        case 'limit':\n+          break;\n+        default:\n+          ret.push({ key, value });\n+          break;\n+      }\n+    });\n+    return ret;\n+  }, [location.search]);\n+\n+  const lookback = useMemo<Lookback | null>(() => {\n+    const ps = new URLSearchParams(location.search);\n+    const lookback = ps.get('lookback');\n+    if (!lookback) {\n+      return null;\n+    }\n+    if (lookback === 'custom') {\n+      const startTs = ps.get('startTs');\n+      const endTs = ps.get('endTs');\n+      if (!endTs || !startTs) {\n+        return null;\n+      }\n+      const startTime = moment(parseInt(startTs, 10));\n+      const endTime = moment(parseInt(endTs, 10));\n+      return {\n+        type: 'custom',\n+        startTime,\n+        endTime,\n+      };\n+    }\n+    const endTs = ps.get('endTs');\n+    if (!endTs) {\n+      return null;\n+    }\n+    const data = fixedLookbackMap[lookback];\n+    if (!data) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI0NjY0NQ=="}, "originalCommit": {"oid": "0be2d24f60b86da32318d200359c3096d2882e37"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc1NDIwNw==", "bodyText": "Ah, I understand what you are saying!\nYou say we should allow users to specify lookback in milliseconds manually, right?\nI agree with you.\nWhat do you think of the following UI?\nUsers can specify millisecond manually.", "url": "https://github.com/openzipkin/zipkin/pull/3076#discussion_r452754207", "createdAt": "2020-07-10T10:12:55Z", "author": {"login": "tacigar"}, "path": "zipkin-lens/src/components/DiscoverPage/DiscoverPageContent.tsx", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright 2015-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+/* eslint-disable no-shadow */\n+import React, { useEffect, useCallback, useState, useMemo } from 'react';\n+import { useDispatch, useSelector } from 'react-redux';\n+import { RouteComponentProps, withRouter } from 'react-router-dom';\n+import {\n+  Box,\n+  Button,\n+  TextField,\n+  CircularProgress,\n+  Paper,\n+} from '@material-ui/core';\n+import { History, Location } from 'history';\n+import moment from 'moment';\n+import { createStyles, makeStyles, Theme } from '@material-ui/core/styles';\n+import { faHistory, faSearch } from '@fortawesome/free-solid-svg-icons';\n+import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\n+\n+import Criterion from './Criterion';\n+import { Lookback, fixedLookbackMap } from './lookback';\n+import { clearTraces, loadTraces } from '../../actions/traces-action';\n+import SearchBar from './SearchBar';\n+import { RootState } from '../../store';\n+import ExplainBox from './ExplainBox';\n+import LookbackMenu from './LookbackMenu';\n+\n+const TracesTab = require('./TracesTab').default;\n+\n+const useStyles = makeStyles((theme: Theme) =>\n+  createStyles({\n+    limitInput: {\n+      fontSize: '1rem',\n+      height: 31,\n+      padding: `${theme.spacing(0.1)}px ${theme.spacing(1)}px`,\n+    },\n+    searchButton: {\n+      height: 60,\n+      minWidth: 60,\n+      color: theme.palette.common.white,\n+    },\n+    paper: {\n+      height: '100%',\n+    },\n+  }),\n+);\n+\n+interface Props extends RouteComponentProps {}\n+\n+// Export for testing\n+export const useQueryParams = (history: History, location: Location) => {\n+  const setQueryParams = useCallback(\n+    (criteria: Criterion[], lookback: Lookback, limit: number) => {\n+      const params = new URLSearchParams();\n+      criteria.forEach((criterion) => {\n+        params.set(criterion.key, criterion.value);\n+      });\n+      switch (lookback.type) {\n+        case 'fixed':\n+          params.set('lookback', lookback.value);\n+          params.set('endTs', lookback.endTime.valueOf().toString());\n+          break;\n+        case 'custom':\n+          params.set('lookback', 'custom');\n+          params.set('endTs', lookback.endTime.valueOf().toString());\n+          params.set('startTs', lookback.startTime.valueOf().toString());\n+          break;\n+        default:\n+      }\n+      params.set('limit', limit.toString());\n+      history.push({\n+        pathname: location.pathname,\n+        search: params.toString(),\n+      });\n+    },\n+    [history, location.pathname],\n+  );\n+\n+  const criteria = useMemo(() => {\n+    const ret: Criterion[] = [];\n+    const params = new URLSearchParams(location.search);\n+\n+    params.forEach((value, key) => {\n+      switch (key) {\n+        case 'lookback':\n+        case 'startTs':\n+        case 'endTs':\n+        case 'limit':\n+          break;\n+        default:\n+          ret.push({ key, value });\n+          break;\n+      }\n+    });\n+    return ret;\n+  }, [location.search]);\n+\n+  const lookback = useMemo<Lookback | null>(() => {\n+    const ps = new URLSearchParams(location.search);\n+    const lookback = ps.get('lookback');\n+    if (!lookback) {\n+      return null;\n+    }\n+    if (lookback === 'custom') {\n+      const startTs = ps.get('startTs');\n+      const endTs = ps.get('endTs');\n+      if (!endTs || !startTs) {\n+        return null;\n+      }\n+      const startTime = moment(parseInt(startTs, 10));\n+      const endTime = moment(parseInt(endTs, 10));\n+      return {\n+        type: 'custom',\n+        startTime,\n+        endTime,\n+      };\n+    }\n+    const endTs = ps.get('endTs');\n+    if (!endTs) {\n+      return null;\n+    }\n+    const data = fixedLookbackMap[lookback];\n+    if (!data) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI0NjY0NQ=="}, "originalCommit": {"oid": "0be2d24f60b86da32318d200359c3096d2882e37"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMTYzMzA1OnYy", "diffSide": "RIGHT", "path": "zipkin-lens/src/components/DiscoverPage/DiscoverPageContent.test.jsx", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMzo0MDoyOVrOGvlSrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMzo0MDoyOVrOGvlSrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU0NzI0NQ==", "bodyText": "I know tagQuery doesn't match the old rest api annotationQuery, but chatted with @tacigar and I think these days almost never someone would put an \"annotation\" in there.\nanyone object to having the UI say tagQuery not annotationQuery? (the rest api is the same regardless as not important enough to change) @openzipkin/core", "url": "https://github.com/openzipkin/zipkin/pull/3076#discussion_r452547245", "createdAt": "2020-07-09T23:40:29Z", "author": {"login": "codefromthecrypt"}, "path": "zipkin-lens/src/components/DiscoverPage/DiscoverPageContent.test.jsx", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Copyright 2015-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/* eslint-disable react/prop-types */\n+\n+import { act, renderHook } from '@testing-library/react-hooks';\n+import { createMemoryHistory } from 'history';\n+import moment from 'moment';\n+import React from 'react';\n+import { Router } from 'react-router-dom';\n+\n+import DiscoverPageContent, {\n+  buildApiQuery,\n+  parseDuration,\n+  useQueryParams,\n+} from './DiscoverPageContent';\n+import render from '../../test/util/render-with-default-settings';\n+\n+describe('useQueryParams', () => {\n+  it('should extract criteria from query string', () => {\n+    const history = createMemoryHistory();\n+    const wrapper = ({ children }) => {\n+      return <Router history={history}>{children}</Router>;\n+    };\n+\n+    history.push({\n+      pathname: '/zipkin/',\n+      // serviceName: serviceA\n+      // spanName: spanB\n+      // remoteServiceName: remoteServiceNameC\n+      // minDuration: 10us\n+      // maxDuration: 100ms\n+      // annotationQuery:\n+      //   key1: value1\n+      //   key2\n+      //   key3: value3\n+      search:\n+        '?serviceName=serviceA&spanName=spanB&remoteServiceName=remoteServiceNameC&minDuration=10us&maxDuration=100ms&annotationQuery=key1%3Dvalue1+and+key2+and+key3%3Dvalue3&limit=10',\n+    });\n+\n+    const { result } = renderHook(() => useQueryParams(['key3']), { wrapper });\n+    expect(result.current.criteria).toEqual([\n+      { key: 'serviceName', value: 'serviceA' },\n+      { key: 'spanName', value: 'spanB' },\n+      { key: 'remoteServiceName', value: 'remoteServiceNameC' },\n+      { key: 'minDuration', value: '10us' },\n+      { key: 'maxDuration', value: '100ms' },\n+      // AnnotationQuery\n+      { key: 'key3', value: 'value3' },\n+      { key: 'tagQuery', value: 'key1=value1 and key2' },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d38094ad2bf5f14f94da8caed609c5c52ef6209f"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjc4NTExOnYy", "diffSide": "RIGHT", "path": "zipkin-lens/src/components/DiscoverPage/DiscoverPageContent.tsx", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOTowOTowOVrOGvv9wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOTowOTowOVrOGvv9wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcyMjExNA==", "bodyText": "What's an incorrect default lookback?", "url": "https://github.com/openzipkin/zipkin/pull/3076#discussion_r452722114", "createdAt": "2020-07-10T09:09:09Z", "author": {"login": "anuraaga"}, "path": "zipkin-lens/src/components/DiscoverPage/DiscoverPageContent.tsx", "diffHunk": "@@ -0,0 +1,463 @@\n+/*\n+ * Copyright 2015-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/* eslint-disable no-shadow */\n+\n+import { faHistory, faSearch } from '@fortawesome/free-solid-svg-icons';\n+import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\n+import {\n+  Box,\n+  Button,\n+  CircularProgress,\n+  Paper,\n+  TextField,\n+} from '@material-ui/core';\n+import moment from 'moment';\n+import React, { useCallback, useEffect, useMemo, useState } from 'react';\n+import { useDispatch, useSelector } from 'react-redux';\n+import { useHistory, useLocation } from 'react-router-dom';\n+import styled from 'styled-components';\n+\n+import Criterion, { newCriterion } from './Criterion';\n+import ExplainBox from './ExplainBox';\n+import LookbackMenu from './LookbackMenu';\n+import SearchBar from './SearchBar';\n+import { Lookback, fixedLookbackMap, millisecondsToValue } from './lookback';\n+import { useUiConfig } from '../UiConfig';\n+import { clearTraces, loadTraces } from '../../actions/traces-action';\n+import { RootState } from '../../store';\n+\n+const TracesTab = require('./TracesTab').default;\n+\n+const LookbackButton = styled(Button)`\n+  /* Align LookbackButton height with the TextField height. */\n+  padding-top: 7.5px;\n+  padding-bottom: 7.5px;\n+`;\n+\n+const SearchButton = styled(Button)`\n+  height: 60px;\n+  min-width: 60px;\n+  color: ${({ theme }) => theme.palette.common.white};\n+`;\n+\n+const TracesPaper = styled(Paper)`\n+  height: 100%;\n+`;\n+\n+interface DiscoverPageContentProps {\n+  autocompleteKeys: string[];\n+}\n+\n+// Export for testing\n+export const useQueryParams = (autocompleteKeys: string[]) => {\n+  const history = useHistory();\n+  const location = useLocation();\n+\n+  const setQueryParams = useCallback(\n+    (criteria: Criterion[], lookback: Lookback, limit: number) => {\n+      const params = new URLSearchParams();\n+      const annotationQuery: string[] = [];\n+      criteria.forEach((criterion) => {\n+        // If the key is 'tag' or a string included in autocompleteKeys,\n+        // the criterion will be included in annotationQuery.\n+        if (criterion.key === 'tagQuery') {\n+          annotationQuery.push(criterion.value);\n+        } else if (autocompleteKeys.includes(criterion.key)) {\n+          if (criterion.value) {\n+            annotationQuery.push(`${criterion.key}=${criterion.value}`);\n+          } else {\n+            annotationQuery.push(criterion.key);\n+          }\n+        } else {\n+          params.set(criterion.key, criterion.value);\n+        }\n+      });\n+      if (annotationQuery.length > 0) {\n+        params.set('annotationQuery', annotationQuery.join(' and '));\n+      }\n+      switch (lookback.type) {\n+        case 'fixed':\n+          params.set('lookback', lookback.value);\n+          params.set('endTs', lookback.endTime.valueOf().toString());\n+          break;\n+        case 'custom':\n+          params.set('lookback', 'custom');\n+          params.set('endTs', lookback.endTime.valueOf().toString());\n+          params.set('startTs', lookback.startTime.valueOf().toString());\n+          break;\n+        default:\n+      }\n+      params.set('limit', limit.toString());\n+      history.push({\n+        pathname: location.pathname,\n+        search: params.toString(),\n+      });\n+    },\n+    [autocompleteKeys, history, location.pathname],\n+  );\n+\n+  const criteria = useMemo(() => {\n+    const ret: Criterion[] = [];\n+    const params = new URLSearchParams(location.search);\n+\n+    params.forEach((value, key) => {\n+      switch (key) {\n+        case 'lookback':\n+        case 'startTs':\n+        case 'endTs':\n+        case 'limit':\n+          break;\n+        case 'annotationQuery': {\n+          // Split annotationQuery into keys of autocompleteKeys and the others.\n+          // If the autocompleteKeys is ['projectID', 'phase'] and the annotationQuery is\n+          // 'projectID=projectA and phase=BETA and http.path=/api/v1/users and http.method=GET',\n+          // criterion will be like the following.\n+          // [\n+          //   { key: 'tagQuery', value: 'http.path=/api/v1/users and http.method=GET' },\n+          //   { key: 'projectID', value: 'projectA' },\n+          //   { key: 'phase', value: 'BETA' },\n+          // ]\n+          const tagQuery: string[] = [];\n+          const exps = value.split(' and ');\n+          exps.forEach((exp) => {\n+            const strs = exp.split('=');\n+            if (strs.length === 0) {\n+              return;\n+            }\n+            const [key, value] = strs;\n+            if (autocompleteKeys.includes(key)) {\n+              ret.push(newCriterion(key, value || ''));\n+            } else {\n+              tagQuery.push(exp);\n+            }\n+          });\n+          ret.push(newCriterion('tagQuery', tagQuery.join(' and ')));\n+          break;\n+        }\n+        default:\n+          ret.push(newCriterion(key, value));\n+          break;\n+      }\n+    });\n+    return ret;\n+  }, [autocompleteKeys, location.search]);\n+\n+  const lookback = useMemo<Lookback | undefined>(() => {\n+    const ps = new URLSearchParams(location.search);\n+    const lookback = ps.get('lookback');\n+    if (!lookback) {\n+      return undefined;\n+    }\n+    if (lookback === 'custom') {\n+      const startTs = ps.get('startTs');\n+      const endTs = ps.get('endTs');\n+      if (!endTs || !startTs) {\n+        return undefined;\n+      }\n+      const startTime = moment(parseInt(startTs, 10));\n+      const endTime = moment(parseInt(endTs, 10));\n+      return {\n+        type: 'custom',\n+        startTime,\n+        endTime,\n+      };\n+    }\n+    const endTs = ps.get('endTs');\n+    if (!endTs) {\n+      return undefined;\n+    }\n+    const data = fixedLookbackMap[lookback];\n+    if (!data) {\n+      return undefined;\n+    }\n+    return {\n+      type: 'fixed',\n+      value: data.value,\n+      endTime: moment(parseInt(endTs, 10)),\n+    };\n+  }, [location.search]);\n+\n+  const limit = useMemo(() => {\n+    const ps = new URLSearchParams(location.search);\n+    const limit = ps.get('limit');\n+    if (!limit) {\n+      return undefined;\n+    }\n+    return parseInt(limit, 10);\n+  }, [location.search]);\n+\n+  return {\n+    setQueryParams,\n+    criteria,\n+    lookback,\n+    limit,\n+  };\n+};\n+\n+// Export for testing\n+export const parseDuration = (duration: string) => {\n+  const regex = /^(\\d+)(s|ms|us)?$/;\n+  const match = duration.match(regex);\n+\n+  if (!match || match.length < 2) {\n+    return undefined;\n+  }\n+  if (match.length === 2 || typeof match[2] === 'undefined') {\n+    return parseInt(match[1], 10);\n+  }\n+  switch (match[2]) {\n+    case 's':\n+      return parseInt(match[1], 10) * 1000 * 1000;\n+    case 'ms':\n+      return parseInt(match[1], 10) * 1000;\n+    case 'us':\n+      return parseInt(match[1], 10);\n+    default:\n+      return undefined;\n+  }\n+};\n+\n+// Export for testing\n+export const buildApiQuery = (\n+  criteria: Criterion[],\n+  lookback: Lookback,\n+  limit: number,\n+  autocompleteKeys: string[],\n+) => {\n+  const params: { [key: string]: string } = {};\n+  const annotationQuery: string[] = [];\n+  criteria.forEach((criterion) => {\n+    if (criterion.key === 'tagQuery') {\n+      annotationQuery.push(criterion.value);\n+    } else if (autocompleteKeys.includes(criterion.key)) {\n+      if (criterion.value) {\n+        annotationQuery.push(`${criterion.key}=${criterion.value}`);\n+      } else {\n+        annotationQuery.push(criterion.key);\n+      }\n+    } else if (\n+      criterion.key === 'minDuration' ||\n+      criterion.key === 'maxDuration'\n+    ) {\n+      const duration = parseDuration(criterion.value);\n+      if (duration) {\n+        params[criterion.key] = duration.toString();\n+      }\n+    } else {\n+      params[criterion.key] = criterion.value;\n+    }\n+  });\n+  if (annotationQuery.length > 0) {\n+    params.annotationQuery = annotationQuery.join(' and ');\n+  }\n+\n+  params.endTs = lookback.endTime.valueOf().toString();\n+  switch (lookback.type) {\n+    case 'custom': {\n+      const lb = lookback.endTime.valueOf() - lookback.startTime.valueOf();\n+      params.lookback = lb.toString();\n+      break;\n+    }\n+    case 'fixed': {\n+      params.lookback = fixedLookbackMap[lookback.value].duration\n+        .asMilliseconds()\n+        .toString();\n+      break;\n+    }\n+    default:\n+  }\n+\n+  params.limit = limit.toString();\n+  return params;\n+};\n+\n+const useFetchTraces = (\n+  autocompleteKeys: string[],\n+  criteria: Criterion[],\n+  lookback?: Lookback,\n+  limit?: number,\n+) => {\n+  const dispatch = useDispatch();\n+\n+  useEffect(() => {\n+    // For searching, lookback and limit are always required.\n+    // If it doesn't exist, clear traces.\n+    if (!lookback || !limit) {\n+      dispatch(clearTraces());\n+      return;\n+    }\n+\n+    const params = buildApiQuery(criteria, lookback, limit, autocompleteKeys);\n+    dispatch(loadTraces(params));\n+  }, [autocompleteKeys, criteria, dispatch, limit, lookback]);\n+};\n+\n+const DiscoverPageContent: React.FC<DiscoverPageContentProps> = ({\n+  autocompleteKeys,\n+}) => {\n+  const { setQueryParams, criteria, lookback, limit } = useQueryParams(\n+    autocompleteKeys,\n+  );\n+\n+  const [tempCriteria, setTempCriteria] = useState(criteria);\n+\n+  const { defaultLookback, queryLimit } = useUiConfig();\n+  const [tempLookback, setTempLookback] = useState<Lookback>(\n+    lookback || {\n+      type: 'fixed',\n+      // If defaultLookback in config.json is incorrect, use 15m as an initial value.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5bec2c1d1f5fcdaea0e8e883304a05db63a71ee"}, "originalPosition": 320}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjc5MzMzOnYy", "diffSide": "RIGHT", "path": "zipkin-lens/src/components/DiscoverPage/LookbackMenu.tsx", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOToxMTozNVrOGvwC0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOTo1NDo1MFrOGvxYlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcyMzQwOQ==", "bodyText": "Why is this important?", "url": "https://github.com/openzipkin/zipkin/pull/3076#discussion_r452723409", "createdAt": "2020-07-10T09:11:35Z", "author": {"login": "anuraaga"}, "path": "zipkin-lens/src/components/DiscoverPage/LookbackMenu.tsx", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright 2015-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import {\n+  Box,\n+  Button,\n+  Grid,\n+  List,\n+  ListItem,\n+  ListItemText,\n+  Paper,\n+  Theme,\n+  createStyles,\n+  makeStyles,\n+} from '@material-ui/core';\n+import { KeyboardDateTimePicker } from '@material-ui/pickers';\n+import { MaterialUiPickersDate } from '@material-ui/pickers/typings/date';\n+import moment, { Moment } from 'moment';\n+import React, { useCallback, useRef, useState } from 'react';\n+import { useEvent } from 'react-use';\n+\n+import { fixedLookbackMap, FixedLookbackValue, Lookback } from './lookback';\n+\n+const useStyles = makeStyles((theme: Theme) =>\n+  createStyles({\n+    root: {\n+      position: 'absolute',\n+      top: 35,\n+      left: 0,\n+      height: 300,\n+      width: 500,\n+      zIndex: theme.zIndex.modal,\n+    },\n+    containerGrid: {\n+      height: '100%',\n+    },\n+    fixedLookbackItemGrid: {\n+      height: '100%',\n+      overflowY: 'auto',\n+      borderRight: `1px solid ${theme.palette.divider}`,\n+    },\n+    list: {\n+      padding: 0,\n+    },\n+  }),\n+);\n+\n+interface LookbackMenuProps {\n+  close: () => void;\n+  onChange: (lookback: Lookback) => void;\n+  lookback: Lookback;\n+}\n+\n+const initialStartTime = (lookback: Lookback): Moment => {\n+  if (lookback.type === 'custom') {\n+    return lookback.startTime;\n+  }\n+  return moment().subtract(1, 'h');\n+};\n+\n+const initialEndTime = (lookback: Lookback): Moment => {\n+  if (lookback.type === 'custom') {\n+    return lookback.endTime;\n+  }\n+  return moment();\n+};\n+\n+const LookbackMenu: React.FC<LookbackMenuProps> = ({\n+  close,\n+  onChange,\n+  lookback,\n+}) => {\n+  const classes = useStyles();\n+\n+  // LookbackMenu is closed when click on the outside of the component.\n+  // This state is needed to prevent LookbackMenu component from closing\n+  // when the dialog of DateTimePicker is clicked.\n+  const [isOpeningDialog, setIsOpeningDialog] = useState(false);\n+\n+  const handleDialogOpen = useCallback(() => {\n+    setIsOpeningDialog(true);\n+  }, []);\n+\n+  const handleDialogClose = useCallback(() => {\n+    // Use setTimeout to change isOpeningDialog state after\n+    // handleOutsideClick callback function is executed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5bec2c1d1f5fcdaea0e8e883304a05db63a71ee"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc0NTM2Ng==", "bodyText": "If there is no setTimeout, LookbackMenu will also be closed when the DateTimePicker's dialog is clicked.\n\nI use setTimeout to achieve the following behavior", "url": "https://github.com/openzipkin/zipkin/pull/3076#discussion_r452745366", "createdAt": "2020-07-10T09:54:50Z", "author": {"login": "tacigar"}, "path": "zipkin-lens/src/components/DiscoverPage/LookbackMenu.tsx", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright 2015-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import {\n+  Box,\n+  Button,\n+  Grid,\n+  List,\n+  ListItem,\n+  ListItemText,\n+  Paper,\n+  Theme,\n+  createStyles,\n+  makeStyles,\n+} from '@material-ui/core';\n+import { KeyboardDateTimePicker } from '@material-ui/pickers';\n+import { MaterialUiPickersDate } from '@material-ui/pickers/typings/date';\n+import moment, { Moment } from 'moment';\n+import React, { useCallback, useRef, useState } from 'react';\n+import { useEvent } from 'react-use';\n+\n+import { fixedLookbackMap, FixedLookbackValue, Lookback } from './lookback';\n+\n+const useStyles = makeStyles((theme: Theme) =>\n+  createStyles({\n+    root: {\n+      position: 'absolute',\n+      top: 35,\n+      left: 0,\n+      height: 300,\n+      width: 500,\n+      zIndex: theme.zIndex.modal,\n+    },\n+    containerGrid: {\n+      height: '100%',\n+    },\n+    fixedLookbackItemGrid: {\n+      height: '100%',\n+      overflowY: 'auto',\n+      borderRight: `1px solid ${theme.palette.divider}`,\n+    },\n+    list: {\n+      padding: 0,\n+    },\n+  }),\n+);\n+\n+interface LookbackMenuProps {\n+  close: () => void;\n+  onChange: (lookback: Lookback) => void;\n+  lookback: Lookback;\n+}\n+\n+const initialStartTime = (lookback: Lookback): Moment => {\n+  if (lookback.type === 'custom') {\n+    return lookback.startTime;\n+  }\n+  return moment().subtract(1, 'h');\n+};\n+\n+const initialEndTime = (lookback: Lookback): Moment => {\n+  if (lookback.type === 'custom') {\n+    return lookback.endTime;\n+  }\n+  return moment();\n+};\n+\n+const LookbackMenu: React.FC<LookbackMenuProps> = ({\n+  close,\n+  onChange,\n+  lookback,\n+}) => {\n+  const classes = useStyles();\n+\n+  // LookbackMenu is closed when click on the outside of the component.\n+  // This state is needed to prevent LookbackMenu component from closing\n+  // when the dialog of DateTimePicker is clicked.\n+  const [isOpeningDialog, setIsOpeningDialog] = useState(false);\n+\n+  const handleDialogOpen = useCallback(() => {\n+    setIsOpeningDialog(true);\n+  }, []);\n+\n+  const handleDialogClose = useCallback(() => {\n+    // Use setTimeout to change isOpeningDialog state after\n+    // handleOutsideClick callback function is executed.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcyMzQwOQ=="}, "originalCommit": {"oid": "f5bec2c1d1f5fcdaea0e8e883304a05db63a71ee"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjc5NDQ3OnYy", "diffSide": "RIGHT", "path": "zipkin-lens/src/components/DiscoverPage/LookbackMenu.tsx", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOToxMTo1NVrOGvwDiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOToxMTo1NVrOGvwDiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcyMzU5Mw==", "bodyText": "Looks like you can combine the ifs", "url": "https://github.com/openzipkin/zipkin/pull/3076#discussion_r452723593", "createdAt": "2020-07-10T09:11:55Z", "author": {"login": "anuraaga"}, "path": "zipkin-lens/src/components/DiscoverPage/LookbackMenu.tsx", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright 2015-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import {\n+  Box,\n+  Button,\n+  Grid,\n+  List,\n+  ListItem,\n+  ListItemText,\n+  Paper,\n+  Theme,\n+  createStyles,\n+  makeStyles,\n+} from '@material-ui/core';\n+import { KeyboardDateTimePicker } from '@material-ui/pickers';\n+import { MaterialUiPickersDate } from '@material-ui/pickers/typings/date';\n+import moment, { Moment } from 'moment';\n+import React, { useCallback, useRef, useState } from 'react';\n+import { useEvent } from 'react-use';\n+\n+import { fixedLookbackMap, FixedLookbackValue, Lookback } from './lookback';\n+\n+const useStyles = makeStyles((theme: Theme) =>\n+  createStyles({\n+    root: {\n+      position: 'absolute',\n+      top: 35,\n+      left: 0,\n+      height: 300,\n+      width: 500,\n+      zIndex: theme.zIndex.modal,\n+    },\n+    containerGrid: {\n+      height: '100%',\n+    },\n+    fixedLookbackItemGrid: {\n+      height: '100%',\n+      overflowY: 'auto',\n+      borderRight: `1px solid ${theme.palette.divider}`,\n+    },\n+    list: {\n+      padding: 0,\n+    },\n+  }),\n+);\n+\n+interface LookbackMenuProps {\n+  close: () => void;\n+  onChange: (lookback: Lookback) => void;\n+  lookback: Lookback;\n+}\n+\n+const initialStartTime = (lookback: Lookback): Moment => {\n+  if (lookback.type === 'custom') {\n+    return lookback.startTime;\n+  }\n+  return moment().subtract(1, 'h');\n+};\n+\n+const initialEndTime = (lookback: Lookback): Moment => {\n+  if (lookback.type === 'custom') {\n+    return lookback.endTime;\n+  }\n+  return moment();\n+};\n+\n+const LookbackMenu: React.FC<LookbackMenuProps> = ({\n+  close,\n+  onChange,\n+  lookback,\n+}) => {\n+  const classes = useStyles();\n+\n+  // LookbackMenu is closed when click on the outside of the component.\n+  // This state is needed to prevent LookbackMenu component from closing\n+  // when the dialog of DateTimePicker is clicked.\n+  const [isOpeningDialog, setIsOpeningDialog] = useState(false);\n+\n+  const handleDialogOpen = useCallback(() => {\n+    setIsOpeningDialog(true);\n+  }, []);\n+\n+  const handleDialogClose = useCallback(() => {\n+    // Use setTimeout to change isOpeningDialog state after\n+    // handleOutsideClick callback function is executed.\n+    window.setTimeout(() => {\n+      setIsOpeningDialog(false);\n+    }, 0);\n+  }, []);\n+\n+  const el = useRef<HTMLDivElement>();\n+\n+  const handleOutsideClick = useCallback(\n+    (event: any) => {\n+      if (!isOpeningDialog) {\n+        if (!el.current) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5bec2c1d1f5fcdaea0e8e883304a05db63a71ee"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjc5OTMxOnYy", "diffSide": "RIGHT", "path": "zipkin-lens/src/components/DiscoverPage/SearchBar/CriterionBox.tsx", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOToxMzozMlrOGvwGjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOToxMzozMlrOGvwGjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcyNDM2Ng==", "bodyText": "Can we use a more descriptive name than ss? Not sure what ss stands for here", "url": "https://github.com/openzipkin/zipkin/pull/3076#discussion_r452724366", "createdAt": "2020-07-10T09:13:32Z", "author": {"login": "anuraaga"}, "path": "zipkin-lens/src/components/DiscoverPage/SearchBar/CriterionBox.tsx", "diffHunk": "@@ -0,0 +1,458 @@\n+/*\n+ * Copyright 2015-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/* eslint-disable no-shadow */\n+\n+import { faTimes } from '@fortawesome/free-solid-svg-icons';\n+import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\n+import { Box, ClickAwayListener } from '@material-ui/core';\n+import React, {\n+  useCallback,\n+  useEffect,\n+  useMemo,\n+  useRef,\n+  useState,\n+} from 'react';\n+import { useMount } from 'react-use';\n+import styled, { keyframes } from 'styled-components';\n+\n+import HowToUse from './HowToUse';\n+import SuggestionList from './SuggestionList';\n+import Criterion, { newCriterion } from '../Criterion';\n+\n+const fadeIn = keyframes`\n+  0% { opacity: 0 }\n+  30% { opacity: 0.1 }\n+  70% { opacity: 0.9 }\n+  100% { opacity: 1 }\n+`;\n+\n+const Root = styled(Box)`\n+  display: flex;\n+  height: 40px;\n+  border-radius: 3px;\n+  box-shadow: ${({ theme }) => theme.shadows[1]};\n+  overflow: hidden;\n+  margin-right: ${({ theme }) => theme.spacing(1)}px;\n+  font-size: 1.1rem;\n+  color: ${({ theme }) => theme.palette.common.white};\n+  cursor: pointer;\n+  & > *:hover {\n+    opacity: 0.9;\n+  }\n+  animation: 0.25s 0s both ${fadeIn};\n+`;\n+\n+const FocusedRoot = styled(Box)`\n+  margin-right: ${({ theme }) => theme.spacing(2)}px;\n+  position: relative;\n+  animation: 0.25s 0s both ${fadeIn};\n+  z-index: ${({ theme }) => theme.zIndex.modal};\n+`;\n+\n+const DeleteButton = styled.button`\n+  height: 100%;\n+  width: 30;\n+  color: ${({ theme }) => theme.palette.common.white};\n+  background-color: ${({ theme }) => theme.palette.primary.main};\n+  cursor: pointer;\n+  border: none;\n+  &:focus {\n+    outline: none;\n+  }\n+`;\n+\n+const Input = styled.input.attrs(() => ({\n+  'data-testid': 'criterion-input',\n+}))`\n+  width: 350px;\n+  height: 40px;\n+  padding: 10px;\n+  box-sizing: border-box;\n+  font-size: 1.1rem;\n+`;\n+\n+interface CriterionBoxProps {\n+  criteria: Criterion[];\n+  criterion: Criterion;\n+  serviceNames: string[];\n+  remoteServiceNames: string[];\n+  spanNames: string[];\n+  autocompleteKeys: string[];\n+  autocompleteValues: string[];\n+  isLoadingServiceNames: boolean;\n+  isLoadingRemoteServiceNames: boolean;\n+  isLoadingSpanNames: boolean;\n+  isLoadingAutocompleteValues: boolean;\n+  isFocused: boolean;\n+  onFocus: () => void;\n+  onBlur: () => void;\n+  onDecide: () => void;\n+  onChange: (criterion: Criterion) => void;\n+  onDelete: () => void;\n+  loadAutocompleteValues: (autocompleteKey: string) => void;\n+}\n+\n+const initialText = (criterion: Criterion) => {\n+  if (criterion.key) {\n+    if (criterion.value) {\n+      return `${criterion.key}=${criterion.value}`;\n+    }\n+    return `${criterion.key}=`;\n+  }\n+  return '';\n+};\n+\n+const CriterionBox: React.FC<CriterionBoxProps> = ({\n+  criteria,\n+  criterion,\n+  serviceNames,\n+  remoteServiceNames,\n+  spanNames,\n+  autocompleteKeys,\n+  autocompleteValues,\n+  isLoadingServiceNames,\n+  isLoadingRemoteServiceNames,\n+  isLoadingSpanNames,\n+  isLoadingAutocompleteValues,\n+  isFocused,\n+  onFocus,\n+  onBlur,\n+  onDecide,\n+  onChange,\n+  onDelete,\n+  loadAutocompleteValues,\n+}) => {\n+  const inputEl = useRef<HTMLInputElement>(null);\n+\n+  const [text, setText] = useState(initialText(criterion));\n+  const [fixedText, setFixedText] = useState(initialText(criterion));\n+\n+  useMount(() => {\n+    if (inputEl.current) {\n+      inputEl.current.focus();\n+    }\n+  });\n+\n+  const prevIsFocused = useRef(isFocused);\n+  useEffect(() => {\n+    if (prevIsFocused.current && !isFocused) {\n+      if (!fixedText) {\n+        onDelete();\n+        return;\n+      }\n+      let ss = fixedText.split('=');", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5bec2c1d1f5fcdaea0e8e883304a05db63a71ee"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjgyMDkzOnYy", "diffSide": "RIGHT", "path": "zipkin-lens/src/components/DiscoverPage/SearchBar/SearchBar.tsx", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOToyMDowOFrOGvwT5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOToyMDowOFrOGvwT5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcyNzc4MQ==", "bodyText": "As far as I can tell this callback pattern has bad performance since the functions all get initialized every render. Instead of using the index factory can't you do something like useCallback((criterion) => criteria.find(c => c.id == criterion.id)?", "url": "https://github.com/openzipkin/zipkin/pull/3076#discussion_r452727781", "createdAt": "2020-07-10T09:20:08Z", "author": {"login": "anuraaga"}, "path": "zipkin-lens/src/components/DiscoverPage/SearchBar/SearchBar.tsx", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright 2015-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import { faPlus } from '@fortawesome/free-solid-svg-icons';\n+import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\n+import {\n+  Box,\n+  Button,\n+  Theme,\n+  createStyles,\n+  makeStyles,\n+} from '@material-ui/core';\n+import React, { useCallback, useEffect, useRef, useState } from 'react';\n+import { connect } from 'react-redux';\n+import { ThunkDispatch } from 'redux-thunk';\n+\n+import Criterion, { newCriterion } from '../Criterion';\n+import CriterionBox from './CriterionBox';\n+import { fetchAutocompleteValues } from '../../../actions/autocomplete-values-action';\n+import { fetchRemoteServices } from '../../../actions/remote-services-action';\n+import { fetchServices } from '../../../actions/services-action';\n+import { fetchSpans } from '../../../actions/spans-action';\n+import RootState from '../../../types/RootState';\n+\n+const useStyles = makeStyles((theme: Theme) =>\n+  createStyles({\n+    addButton: {\n+      height: 40,\n+      width: 40,\n+      minWidth: 40,\n+      color: theme.palette.common.white,\n+    },\n+  }),\n+);\n+\n+type SearchBarProps = {\n+  searchTraces: () => void;\n+  criteria: Criterion[];\n+  onChange: (criteria: Criterion[]) => void;\n+  serviceNames: string[];\n+  isLoadingServiceNames: boolean;\n+  spanNames: string[];\n+  isLoadingSpanNames: boolean;\n+  remoteServiceNames: string[];\n+  isLoadingRemoteServiceNames: boolean;\n+  autocompleteKeys: string[];\n+  autocompleteValues: string[];\n+  isLoadingAutocompleteValues: boolean;\n+  loadServices: () => void;\n+  loadRemoteServices: (serviceName: string) => void;\n+  loadSpans: (serviceName: string) => void;\n+  loadAutocompleteValues: (autocompleteKey: string) => void;\n+};\n+\n+export const SearchBarImpl: React.FC<SearchBarProps> = ({\n+  searchTraces,\n+  criteria,\n+  onChange,\n+  serviceNames,\n+  isLoadingServiceNames,\n+  spanNames,\n+  isLoadingSpanNames,\n+  remoteServiceNames,\n+  isLoadingRemoteServiceNames,\n+  autocompleteKeys,\n+  autocompleteValues,\n+  isLoadingAutocompleteValues,\n+  loadServices,\n+  loadRemoteServices,\n+  loadSpans,\n+  loadAutocompleteValues,\n+}) => {\n+  const classes = useStyles();\n+\n+  // criterionIndex is the index of the criterion currently being edited.\n+  // If the value is -1, there is no criterion being edited.\n+  const [criterionIndex, setCriterionIndex] = useState(-1);\n+\n+  const handleCriterionFocus = (index: number) => () => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5bec2c1d1f5fcdaea0e8e883304a05db63a71ee"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNzg0MDA2OnYy", "diffSide": "RIGHT", "path": "zipkin-lens/src/components/DiscoverPage/DiscoverPageContent.test.jsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNTowNDo0MlrOGwbj9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNTowNDo0MlrOGwbj9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQzNjQwNQ==", "bodyText": "More specifically, we should have a test where this is set to an arbitrary milliseconds like 1234567", "url": "https://github.com/openzipkin/zipkin/pull/3076#discussion_r453436405", "createdAt": "2020-07-13T05:04:42Z", "author": {"login": "anuraaga"}, "path": "zipkin-lens/src/components/DiscoverPage/DiscoverPageContent.test.jsx", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Copyright 2015-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/* eslint-disable react/prop-types */\n+\n+import { act, renderHook } from '@testing-library/react-hooks';\n+import { createMemoryHistory } from 'history';\n+import moment from 'moment';\n+import React from 'react';\n+import { Router } from 'react-router-dom';\n+\n+import DiscoverPageContent, {\n+  buildApiQuery,\n+  parseDuration,\n+  useQueryParams,\n+} from './DiscoverPageContent';\n+import render from '../../test/util/render-with-default-settings';\n+\n+describe('useQueryParams', () => {\n+  it('should extract criteria from query string', () => {\n+    const history = createMemoryHistory();\n+    const wrapper = ({ children }) => {\n+      return <Router history={history}>{children}</Router>;\n+    };\n+\n+    history.push({\n+      pathname: '/zipkin/',\n+      // serviceName: serviceA\n+      // spanName: spanB\n+      // remoteServiceName: remoteServiceNameC\n+      // minDuration: 10us\n+      // maxDuration: 100ms\n+      // annotationQuery:\n+      //   key1: value1\n+      //   key2\n+      //   key3: value3\n+      search:\n+        '?serviceName=serviceA&spanName=spanB&remoteServiceName=remoteServiceNameC&minDuration=10us&maxDuration=100ms&annotationQuery=key1%3Dvalue1+and+key2+and+key3%3Dvalue3&limit=10',\n+    });\n+\n+    const { result } = renderHook(() => useQueryParams(['key3']), { wrapper });\n+\n+    const expected = [\n+      { key: 'serviceName', value: 'serviceA' },\n+      { key: 'spanName', value: 'spanB' },\n+      { key: 'remoteServiceName', value: 'remoteServiceNameC' },\n+      { key: 'minDuration', value: '10us' },\n+      { key: 'maxDuration', value: '100ms' },\n+      // AnnotationQuery\n+      { key: 'key3', value: 'value3' },\n+      { key: 'tagQuery', value: 'key1=value1 and key2' },\n+    ];\n+\n+    for (let i = 0; i < expected.length; i += 1) {\n+      expect(result.current.criteria[i].key).toBe(expected[i].key);\n+      expect(result.current.criteria[i].value).toBe(expected[i].value);\n+    }\n+  });\n+\n+  it('should extract custom lookback from query string', () => {\n+    const history = createMemoryHistory();\n+    const wrapper = ({ children }) => {\n+      return <Router history={history}>{children}</Router>;\n+    };\n+    history.push({\n+      pathname: '/zipkin/',\n+      search: '?lookback=custom&startTs=1588558961791&endTs=1588558961791',\n+    });\n+\n+    const { result } = renderHook(() => useQueryParams([]), { wrapper });\n+    expect(result.current.lookback.type).toBe('custom');\n+    expect(result.current.lookback.startTime.valueOf()).toBe(1588558961791);\n+    expect(result.current.lookback.endTime.valueOf()).toBe(1588558961791);\n+  });\n+\n+  it('should extract fixed lookback from query string', () => {\n+    const history = createMemoryHistory();\n+    const wrapper = ({ children }) => {\n+      return <Router history={history}>{children}</Router>;\n+    };\n+    history.push({\n+      pathname: '/zipkin/',\n+      search: '?lookback=2h&endTs=1588558961791',\n+    });\n+\n+    const { result } = renderHook(() => useQueryParams([]), { wrapper });\n+    expect(result.current.lookback.type).toBe('fixed');\n+    expect(result.current.lookback.value).toBe('2h');\n+    expect(result.current.lookback.endTime.valueOf()).toBe(1588558961791);\n+  });\n+\n+  it('should extract limit from query string', () => {\n+    const history = createMemoryHistory();\n+    const wrapper = ({ children }) => {\n+      return <Router history={history}>{children}</Router>;\n+    };\n+    history.push({\n+      pathname: '/zipkin/',\n+      search: '?limit=300',\n+    });\n+\n+    const { result } = renderHook(() => useQueryParams([]), { wrapper });\n+    expect(result.current.limit).toBe(300);\n+  });\n+\n+  it('should set query string using setQueryParams', () => {\n+    const history = createMemoryHistory();\n+    const wrapper = ({ children }) => {\n+      return <Router history={history}>{children}</Router>;\n+    };\n+    history.push({\n+      pathname: '/zipkin/',\n+      search: '?limit=300',\n+    });\n+\n+    const { result } = renderHook(() => useQueryParams(['key3']), { wrapper });\n+\n+    act(() => {\n+      result.current.setQueryParams(\n+        [\n+          { key: 'serviceName', value: 'serviceA' },\n+          { key: 'spanName', value: 'spanB' },\n+          { key: 'remoteServiceName', value: 'remoteServiceNameC' },\n+          // Durations will NOT converted to microsecond values.\n+          { key: 'minDuration', value: '10us' },\n+          { key: 'maxDuration', value: '100ms' },\n+          // AnnotationQuery\n+          { key: 'tagQuery', value: 'key1=value1 and key2' },\n+          { key: 'key3', value: 'value3' },\n+        ],\n+        {\n+          type: 'fixed',\n+          endTime: moment(1588558961791),\n+          value: '2h',\n+        },\n+        10,\n+      );\n+    });\n+    expect(history.location.search).toBe(\n+      '?serviceName=serviceA&spanName=spanB&remoteServiceName=remoteServiceNameC&minDuration=10us&maxDuration=100ms&annotationQuery=key1%3Dvalue1+and+key2+and+key3%3Dvalue3&lookback=2h&endTs=1588558961791&limit=10',\n+    );\n+  });\n+});\n+\n+it('parseDuration', () => {\n+  [\n+    { in: '35', out: 35 },\n+    { in: '35us', out: 35 },\n+    { in: '35ms', out: 35 * 1000 },\n+    { in: '35s', out: 35 * 1000 * 1000 },\n+  ].forEach((e) => {\n+    expect(parseDuration(e.in)).toBe(e.out);\n+  });\n+});\n+\n+describe('buildApiQuery', () => {\n+  it('should build API Query', () => {\n+    const params = buildApiQuery(\n+      [\n+        { key: 'serviceName', value: 'serviceA' },\n+        { key: 'spanName', value: 'spanB' },\n+        { key: 'remoteServiceName', value: 'remoteServiceNameC' },\n+        // Durations will converted to microsecond values.\n+        { key: 'minDuration', value: '10us' },\n+        { key: 'maxDuration', value: '100ms' },\n+        // AnnotationQuery\n+        { key: 'tagQuery', value: 'key1=value1 and key2' },\n+        { key: 'key3', value: 'value3' },\n+      ],\n+      {\n+        type: 'fixed',\n+        endTime: moment(1588558961791),\n+        value: '2h',\n+      },\n+      30,\n+      ['key3'],\n+    );\n+    expect(params.serviceName).toBe('serviceA');\n+    expect(params.spanName).toBe('spanB');\n+    expect(params.remoteServiceName).toBe('remoteServiceNameC');\n+    expect(params.minDuration).toBe('10');\n+    expect(params.maxDuration).toBe('100000');\n+    expect(params.annotationQuery).toBe('key1=value1 and key2 and key3=value3');\n+    expect(params.lookback).toBe('7200000');\n+    expect(params.endTs).toBe('1588558961791');\n+    expect(params.limit).toBe('30');\n+  });\n+});\n+\n+describe('<DiscoverPageContent />', () => {\n+  it('should initialize the lookback using config.json', () => {\n+    const { getAllByText } = render(<DiscoverPageContent />, {\n+      uiConfig: {\n+        defaultLookback: 60 * 1000 * 5, // 5m", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ea978787612dab7716b6d00d229c3f7c8af2c08"}, "originalPosition": 205}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1115, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}