{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY0MzY4OTIy", "number": 682, "title": "refactor(digitaltwin-device): separated digital twin client register \u2026", "bodyText": "\u2026API and renamed interface instance to component\n \nChecklist\n\n I have read the [contribution guidelines] (https://github.com/Azure/azure-iot-sdk-java/blob/master/.github/CONTRIBUTING.md).\n I added or modified the existing tests to cover the change (we do not allow our test coverage to go down).\nIf this is a modification that impacts the behavior of a public API\n\n I edited the corresponding document in the devdoc folder and added or modified requirements.\n\n\nI submitted this PR against the correct branch:\n\n This pull-request is submitted against the master branch.\n\n\n\nReference/Link to the issue solved with this PR (if any)\nDescription of the problem\n\nDescription of the solution", "createdAt": "2020-01-18T00:28:36Z", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682", "merged": true, "mergeCommit": {"oid": "4a6e9a2f97df04f290258b31f6fe1a9f9299a210"}, "closed": true, "closedAt": "2020-01-29T20:27:20Z", "author": {"login": "davilu"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb7Yeq8gFqTM0NDkwOTM3Mw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABb-7BzSAFqTM0OTgwMTg1Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTA5Mzcz", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#pullrequestreview-344909373", "createdAt": "2020-01-18T00:47:40Z", "commit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo0Nzo0MFrOFfIlRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo0Nzo0MFrOFfIlRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MDc4OQ==", "bodyText": "missing space between if and paren", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r368190789", "createdAt": "2020-01-18T00:47:40Z", "author": {"login": "drwill-ms"}, "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DeviceClientManager.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package com.microsoft.azure.sdk.iot.digitaltwin.device;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceClient;\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.experimental.Delegate;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+@Slf4j\n+public class DeviceClientManager implements IotHubConnectionStatusChangeCallback {\n+    private enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+\n+    private static final Object lock = new Object();\n+    private static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 10;\n+    private ConnectionStatus connectionStatus;\n+    private Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    private interface DeviceClientNonDelegatedFunction {\n+        void open();\n+        void closeNow();\n+        void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext);\n+    }\n+\n+    // The methods defined in the interface DeviceClientNonDelegatedFunction will be called on DeviceClientManager, and not on DeviceClient.\n+    @Delegate(excludes = DeviceClientNonDelegatedFunction.class)\n+    private final DeviceClient client;\n+\n+    DeviceClientManager(DeviceClient deviceClient) {\n+        this.connectionStatus = ConnectionStatus.DISCONNECTED;\n+        this.client = deviceClient;\n+        this.client.registerConnectionStatusChangeCallback(this, this);\n+    }\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+    }\n+\n+    public void open() throws Exception {\n+        synchronized (lock) {\n+            if(connectionStatus == ConnectionStatus.DISCONNECTED) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTA5NDQx", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#pullrequestreview-344909441", "createdAt": "2020-01-18T00:48:04Z", "commit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo0ODowNFrOFfIlhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo0ODowNFrOFfIlhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MDg1Mw==", "bodyText": "missing space between if and paren", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r368190853", "createdAt": "2020-01-18T00:48:04Z", "author": {"login": "drwill-ms"}, "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DeviceClientManager.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package com.microsoft.azure.sdk.iot.digitaltwin.device;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceClient;\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.experimental.Delegate;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+@Slf4j\n+public class DeviceClientManager implements IotHubConnectionStatusChangeCallback {\n+    private enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+\n+    private static final Object lock = new Object();\n+    private static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 10;\n+    private ConnectionStatus connectionStatus;\n+    private Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    private interface DeviceClientNonDelegatedFunction {\n+        void open();\n+        void closeNow();\n+        void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext);\n+    }\n+\n+    // The methods defined in the interface DeviceClientNonDelegatedFunction will be called on DeviceClientManager, and not on DeviceClient.\n+    @Delegate(excludes = DeviceClientNonDelegatedFunction.class)\n+    private final DeviceClient client;\n+\n+    DeviceClientManager(DeviceClient deviceClient) {\n+        this.connectionStatus = ConnectionStatus.DISCONNECTED;\n+        this.client = deviceClient;\n+        this.client.registerConnectionStatusChangeCallback(this, this);\n+    }\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+    }\n+\n+    public void open() throws Exception {\n+        synchronized (lock) {\n+            if(connectionStatus == ConnectionStatus.DISCONNECTED) {\n+                connectionStatus = ConnectionStatus.CONNECTING;\n+            } else {\n+                return;\n+            }\n+        }\n+        doConnect();\n+    }\n+\n+    private void doConnect() throws Exception {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTEwMDY5", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#pullrequestreview-344910069", "createdAt": "2020-01-18T00:52:04Z", "commit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo1MjowNFrOFfInvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo1MjowNFrOFfInvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MTQyMQ==", "bodyText": "missing space between if and paren", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r368191421", "createdAt": "2020-01-18T00:52:04Z", "author": {"login": "drwill-ms"}, "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DigitalTwinDeviceClient.java", "diffHunk": "@@ -109,166 +99,284 @@\n      * Callers MUST NOT directly access {@link DeviceClient} after.\n      *\n      * @param deviceClient An {@link DeviceClient} that has been already created and bound to a specific connection string (or transport, or DPS handle, or whatever mechanism is preferred).\n+     * @param deviceCapabilityModelId     Device Capability Model Id\n+     *\n      */\n-    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient) {\n-        this.deviceClient = deviceClient;\n-        this.registrationStatus = UNREGISTERED;\n-        this.digitalTwinInterfaceClients = new HashMap<>();\n+    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient, @NonNull String deviceCapabilityModelId) {\n+        this.deviceClientManager = new DeviceClientManager(deviceClient);\n+        this.deviceCapabilityModelId = deviceCapabilityModelId;\n+        this.components = new ConcurrentHashMap<>();\n         this.lock = new Object();\n     }\n \n     /**\n-     * Registers the specified {@link AbstractDigitalTwinInterfaceClient} with the DigitalTwin Service.\n-     * The call occurs asynchronously. While registration is in progress, {@link AbstractDigitalTwinInterfaceClient}'s that are being registered will not be able to report properties nor receive commands.\n-     * The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n-     * It must not be called multiple times.  If a given Digital Twin device needs to have its handles re-registered, it needs to create a new DigitalTwinDeviceClient instance.\n+     * Bind all digital twin components with Digital Twin device client.\n+     * @param digitalTwinComponents An list of {@link AbstractDigitalTwinComponent}s to register with the service.\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult bindComponents(@NonNull final List<? extends AbstractDigitalTwinComponent> digitalTwinComponents) {\n+        synchronized (lock) {\n+            if(!components.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "originalPosition": 133}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTEwMDk5", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#pullrequestreview-344910099", "createdAt": "2020-01-18T00:52:17Z", "commit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo1MjoxN1rOFfIn0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo1MjoxN1rOFfIn0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MTQ0MA==", "bodyText": "missing space between if and paren", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r368191440", "createdAt": "2020-01-18T00:52:17Z", "author": {"login": "drwill-ms"}, "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DigitalTwinDeviceClient.java", "diffHunk": "@@ -109,166 +99,284 @@\n      * Callers MUST NOT directly access {@link DeviceClient} after.\n      *\n      * @param deviceClient An {@link DeviceClient} that has been already created and bound to a specific connection string (or transport, or DPS handle, or whatever mechanism is preferred).\n+     * @param deviceCapabilityModelId     Device Capability Model Id\n+     *\n      */\n-    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient) {\n-        this.deviceClient = deviceClient;\n-        this.registrationStatus = UNREGISTERED;\n-        this.digitalTwinInterfaceClients = new HashMap<>();\n+    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient, @NonNull String deviceCapabilityModelId) {\n+        this.deviceClientManager = new DeviceClientManager(deviceClient);\n+        this.deviceCapabilityModelId = deviceCapabilityModelId;\n+        this.components = new ConcurrentHashMap<>();\n         this.lock = new Object();\n     }\n \n     /**\n-     * Registers the specified {@link AbstractDigitalTwinInterfaceClient} with the DigitalTwin Service.\n-     * The call occurs asynchronously. While registration is in progress, {@link AbstractDigitalTwinInterfaceClient}'s that are being registered will not be able to report properties nor receive commands.\n-     * The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n-     * It must not be called multiple times.  If a given Digital Twin device needs to have its handles re-registered, it needs to create a new DigitalTwinDeviceClient instance.\n+     * Bind all digital twin components with Digital Twin device client.\n+     * @param digitalTwinComponents An list of {@link AbstractDigitalTwinComponent}s to register with the service.\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult bindComponents(@NonNull final List<? extends AbstractDigitalTwinComponent> digitalTwinComponents) {\n+        synchronized (lock) {\n+            if(!components.isEmpty()) {\n+                return DIGITALTWIN_CLIENT_ERROR_COMPONENTS_ALREADY_BOUND;\n+            }\n+\n+            for (AbstractDigitalTwinComponent digitalTwinComponent : digitalTwinComponents) {\n+                digitalTwinComponent.setDigitalTwinDeviceClient(this);\n+                components.put(digitalTwinComponent.getDigitalTwinComponentName(), digitalTwinComponent);\n+            }\n+        }\n+        return DIGITALTWIN_CLIENT_OK;\n+    }\n+\n+    /**\n+     * Sends registration message message to DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n      *\n-     * @param deviceCapabilityModelId     Device Capability Model Id\n-     * @param digitalTwinInterfaceClients An list of {@link AbstractDigitalTwinInterfaceClient}s to register with the service.\n      * @return Result of this async function.\n      */\n-    public Single<DigitalTwinClientResult> registerInterfacesAsync(@NonNull final String deviceCapabilityModelId,\n-            @NonNull final List<? extends AbstractDigitalTwinInterfaceClient> digitalTwinInterfaceClients) {\n+    public Single<DigitalTwinClientResult> registerComponentsAsync() {\n         synchronized (lock) {\n-            if (registrationStatus == REGISTERING) {\n-                return Single.just(DIGITALTWIN_CLIENT_ERROR_REGISTRATION_PENDING);\n-            } else if (registrationStatus == REGISTERED) {\n-                return Single.just(DIGITALTWIN_CLIENT_ERROR_INTERFACE_ALREADY_REGISTERED);\n-            } else {\n-                registrationStatus = REGISTERING;\n+            if(components.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "originalPosition": 163}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTEwMjM1", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#pullrequestreview-344910235", "createdAt": "2020-01-18T00:53:13Z", "commit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo1MzoxM1rOFfIoOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo1MzoxM1rOFfIoOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MTU0NA==", "bodyText": "Is \"registration\" still a concept?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r368191544", "createdAt": "2020-01-18T00:53:13Z", "author": {"login": "drwill-ms"}, "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DigitalTwinDeviceClient.java", "diffHunk": "@@ -109,166 +99,284 @@\n      * Callers MUST NOT directly access {@link DeviceClient} after.\n      *\n      * @param deviceClient An {@link DeviceClient} that has been already created and bound to a specific connection string (or transport, or DPS handle, or whatever mechanism is preferred).\n+     * @param deviceCapabilityModelId     Device Capability Model Id\n+     *\n      */\n-    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient) {\n-        this.deviceClient = deviceClient;\n-        this.registrationStatus = UNREGISTERED;\n-        this.digitalTwinInterfaceClients = new HashMap<>();\n+    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient, @NonNull String deviceCapabilityModelId) {\n+        this.deviceClientManager = new DeviceClientManager(deviceClient);\n+        this.deviceCapabilityModelId = deviceCapabilityModelId;\n+        this.components = new ConcurrentHashMap<>();\n         this.lock = new Object();\n     }\n \n     /**\n-     * Registers the specified {@link AbstractDigitalTwinInterfaceClient} with the DigitalTwin Service.\n-     * The call occurs asynchronously. While registration is in progress, {@link AbstractDigitalTwinInterfaceClient}'s that are being registered will not be able to report properties nor receive commands.\n-     * The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n-     * It must not be called multiple times.  If a given Digital Twin device needs to have its handles re-registered, it needs to create a new DigitalTwinDeviceClient instance.\n+     * Bind all digital twin components with Digital Twin device client.\n+     * @param digitalTwinComponents An list of {@link AbstractDigitalTwinComponent}s to register with the service.\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult bindComponents(@NonNull final List<? extends AbstractDigitalTwinComponent> digitalTwinComponents) {\n+        synchronized (lock) {\n+            if(!components.isEmpty()) {\n+                return DIGITALTWIN_CLIENT_ERROR_COMPONENTS_ALREADY_BOUND;\n+            }\n+\n+            for (AbstractDigitalTwinComponent digitalTwinComponent : digitalTwinComponents) {\n+                digitalTwinComponent.setDigitalTwinDeviceClient(this);\n+                components.put(digitalTwinComponent.getDigitalTwinComponentName(), digitalTwinComponent);\n+            }\n+        }\n+        return DIGITALTWIN_CLIENT_OK;\n+    }\n+\n+    /**\n+     * Sends registration message message to DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n      *\n-     * @param deviceCapabilityModelId     Device Capability Model Id\n-     * @param digitalTwinInterfaceClients An list of {@link AbstractDigitalTwinInterfaceClient}s to register with the service.\n      * @return Result of this async function.\n      */\n-    public Single<DigitalTwinClientResult> registerInterfacesAsync(@NonNull final String deviceCapabilityModelId,\n-            @NonNull final List<? extends AbstractDigitalTwinInterfaceClient> digitalTwinInterfaceClients) {\n+    public Single<DigitalTwinClientResult> registerComponentsAsync() {\n         synchronized (lock) {\n-            if (registrationStatus == REGISTERING) {\n-                return Single.just(DIGITALTWIN_CLIENT_ERROR_REGISTRATION_PENDING);\n-            } else if (registrationStatus == REGISTERED) {\n-                return Single.just(DIGITALTWIN_CLIENT_ERROR_INTERFACE_ALREADY_REGISTERED);\n-            } else {\n-                registrationStatus = REGISTERING;\n+            if(components.isEmpty()) {\n+                return Single.just(DIGITALTWIN_CLIENT_ERROR_COMPONENTS_NOT_BOUND);\n             }\n         }\n-\n-        return connectAsync(deviceClient)\n+        return ensureConnectAsync()\n                 .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n                     @Override\n                     public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        return sendRegistrationMessageAsync(deviceCapabilityModelId, digitalTwinInterfaceClients);\n-                    }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n-                    @Override\n-                    public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return subscribeCommandAsync();\n-                        } else {\n-                            return Flowable.just(result);\n-                        }\n+                        return sendRegistrationMessageAsync(result);\n                     }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                }).singleOrError();\n+    }\n+\n+    /**\n+     * Sends registration message to DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n+     *\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult registerComponents() {\n+        return registerComponentsAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Subscribe commands with the DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.* @return Result of this sync function.\n+     *\n+     * @return Result of this async function.\n+     */\n+    public Single<DigitalTwinClientResult> subscribeForCommandsAsync() {\n+        return ensureConnectAsync()\n+                .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n                     @Override\n                     public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return subscribeTwinAsync();\n-                        } else {\n-                            return Flowable.just(result);\n-                        }\n+                        return subscribeCommandsAsync(result);\n                     }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                }).singleOrError();\n+    }\n+\n+    /**\n+     * Subscribe commands with the DigitalTwin Service.\n+     * The call will be blocked and will return the result once registration is processed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "originalPosition": 223}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTEwNTY2", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#pullrequestreview-344910566", "createdAt": "2020-01-18T00:55:37Z", "commit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo1NTozN1rOFfIpQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo1NTozN1rOFfIpQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MTgwOQ==", "bodyText": "what about content encoding and type?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r368191809", "createdAt": "2020-01-18T00:55:37Z", "author": {"login": "drwill-ms"}, "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DigitalTwinDeviceClient.java", "diffHunk": "@@ -109,166 +99,284 @@\n      * Callers MUST NOT directly access {@link DeviceClient} after.\n      *\n      * @param deviceClient An {@link DeviceClient} that has been already created and bound to a specific connection string (or transport, or DPS handle, or whatever mechanism is preferred).\n+     * @param deviceCapabilityModelId     Device Capability Model Id\n+     *\n      */\n-    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient) {\n-        this.deviceClient = deviceClient;\n-        this.registrationStatus = UNREGISTERED;\n-        this.digitalTwinInterfaceClients = new HashMap<>();\n+    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient, @NonNull String deviceCapabilityModelId) {\n+        this.deviceClientManager = new DeviceClientManager(deviceClient);\n+        this.deviceCapabilityModelId = deviceCapabilityModelId;\n+        this.components = new ConcurrentHashMap<>();\n         this.lock = new Object();\n     }\n \n     /**\n-     * Registers the specified {@link AbstractDigitalTwinInterfaceClient} with the DigitalTwin Service.\n-     * The call occurs asynchronously. While registration is in progress, {@link AbstractDigitalTwinInterfaceClient}'s that are being registered will not be able to report properties nor receive commands.\n-     * The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n-     * It must not be called multiple times.  If a given Digital Twin device needs to have its handles re-registered, it needs to create a new DigitalTwinDeviceClient instance.\n+     * Bind all digital twin components with Digital Twin device client.\n+     * @param digitalTwinComponents An list of {@link AbstractDigitalTwinComponent}s to register with the service.\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult bindComponents(@NonNull final List<? extends AbstractDigitalTwinComponent> digitalTwinComponents) {\n+        synchronized (lock) {\n+            if(!components.isEmpty()) {\n+                return DIGITALTWIN_CLIENT_ERROR_COMPONENTS_ALREADY_BOUND;\n+            }\n+\n+            for (AbstractDigitalTwinComponent digitalTwinComponent : digitalTwinComponents) {\n+                digitalTwinComponent.setDigitalTwinDeviceClient(this);\n+                components.put(digitalTwinComponent.getDigitalTwinComponentName(), digitalTwinComponent);\n+            }\n+        }\n+        return DIGITALTWIN_CLIENT_OK;\n+    }\n+\n+    /**\n+     * Sends registration message message to DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n      *\n-     * @param deviceCapabilityModelId     Device Capability Model Id\n-     * @param digitalTwinInterfaceClients An list of {@link AbstractDigitalTwinInterfaceClient}s to register with the service.\n      * @return Result of this async function.\n      */\n-    public Single<DigitalTwinClientResult> registerInterfacesAsync(@NonNull final String deviceCapabilityModelId,\n-            @NonNull final List<? extends AbstractDigitalTwinInterfaceClient> digitalTwinInterfaceClients) {\n+    public Single<DigitalTwinClientResult> registerComponentsAsync() {\n         synchronized (lock) {\n-            if (registrationStatus == REGISTERING) {\n-                return Single.just(DIGITALTWIN_CLIENT_ERROR_REGISTRATION_PENDING);\n-            } else if (registrationStatus == REGISTERED) {\n-                return Single.just(DIGITALTWIN_CLIENT_ERROR_INTERFACE_ALREADY_REGISTERED);\n-            } else {\n-                registrationStatus = REGISTERING;\n+            if(components.isEmpty()) {\n+                return Single.just(DIGITALTWIN_CLIENT_ERROR_COMPONENTS_NOT_BOUND);\n             }\n         }\n-\n-        return connectAsync(deviceClient)\n+        return ensureConnectAsync()\n                 .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n                     @Override\n                     public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        return sendRegistrationMessageAsync(deviceCapabilityModelId, digitalTwinInterfaceClients);\n-                    }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n-                    @Override\n-                    public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return subscribeCommandAsync();\n-                        } else {\n-                            return Flowable.just(result);\n-                        }\n+                        return sendRegistrationMessageAsync(result);\n                     }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                }).singleOrError();\n+    }\n+\n+    /**\n+     * Sends registration message to DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n+     *\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult registerComponents() {\n+        return registerComponentsAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Subscribe commands with the DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.* @return Result of this sync function.\n+     *\n+     * @return Result of this async function.\n+     */\n+    public Single<DigitalTwinClientResult> subscribeForCommandsAsync() {\n+        return ensureConnectAsync()\n+                .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n                     @Override\n                     public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return subscribeTwinAsync();\n-                        } else {\n-                            return Flowable.just(result);\n-                        }\n+                        return subscribeCommandsAsync(result);\n                     }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                }).singleOrError();\n+    }\n+\n+    /**\n+     * Subscribe commands with the DigitalTwin Service.\n+     * The call will be blocked and will return the result once registration is processed.\n+     *\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult subscribeForCommands() {\n+        return subscribeForCommandsAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Subscribe properties with the DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.* @return Result of this sync function.\n+     *\n+     * @return Result of this async function.\n+     */\n+    public Single<DigitalTwinClientResult> subscribeForPropertiesAsync() {\n+        return ensureConnectAsync()\n+                .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n                     @Override\n                     public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return reportSdkInformationAsync();\n-                        } else {\n-                            return Flowable.just(result);\n-                        }\n-                    }\n-                }).map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n-                    @Override\n-                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) throws Throwable {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return getTwinAsync();\n-                        } else {\n-                            return result;\n-                        }\n-                    }\n-                }).map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n-                    @Override\n-                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return notifyComponents(digitalTwinInterfaceClients);\n-                        } else {\n-                            return result;\n-                        }\n+                        return subscribePropertiesAsync(result);\n                     }\n-                }).map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n-                    @Override\n-                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) {\n-                        return onRegistrationResult(result);\n-                    }\n-                }).doOnError(new Consumer<Throwable>() {\n-                    @Override\n-                    public void accept(Throwable throwable) {\n-                        onRegistrationResult(DIGITALTWIN_CLIENT_ERROR);\n-                    }\n-                }).doOnCancel(new Action() {\n+                }).singleOrError();\n+    }\n+\n+    /**\n+     * Subscribe properties with the DigitalTwin Service.\n+     * The call will be blocked and will return the result once registration is processed.\n+     *\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult subscribeForProperties() {\n+        return subscribeForPropertiesAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Trigger properties sync up with the DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.* @return Result of this sync function.\n+     *\n+     * @return Result of this async function.\n+     */\n+    public Single<DigitalTwinClientResult> syncupPropertiesAsync() {\n+        return ensureConnectAsync()\n+                .map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n                     @Override\n-                    public void run() {\n-                        onRegistrationResult(DIGITALTWIN_CLIENT_ERROR);\n+                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) throws IOException {\n+                        // TODO Known gap, SDK API accepts no callback, there is no guarantee it's delivered\n+                        log.debug(\"Getting DeviceTwin...\");\n+                        deviceClientManager.getDeviceTwin();\n+                        return DIGITALTWIN_CLIENT_OK;\n                     }\n-                })\n-                .singleOrError();\n+                }).singleOrError();\n     }\n \n     /**\n-     * Registers the specified {@link AbstractDigitalTwinInterfaceClient} with the DigitalTwin Service.\n+     * Trigger properties sync up with the DigitalTwin Service.\n      * The call will be blocked and will return the result once registration is processed.\n-     * It must not be called multiple times. If a given Digital Twin device needs to have its handles re-registered, it needs to create a new DigitalTwinDeviceClient instance.\n      *\n-     * @param deviceCapabilityModelId     Device Capability Model Id\n-     * @param digitalTwinInterfaceClients An list of {@link AbstractDigitalTwinInterfaceClient}s to register with the service.\n      * @return Result of this sync function.\n      */\n-    public DigitalTwinClientResult registerInterfaces(@NonNull final String deviceCapabilityModelId,\n-            @NonNull final List<? extends AbstractDigitalTwinInterfaceClient> digitalTwinInterfaceClients) {\n-        return registerInterfacesAsync(deviceCapabilityModelId, digitalTwinInterfaceClients).blockingGet();\n+    public DigitalTwinClientResult syncupProperties() {\n+        return syncupPropertiesAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Application should call this function to notify all components they are now ready to use. All bound component function {@link AbstractDigitalTwinComponent#ready()} will be triggered.\n+     *\n+     * @return Failure if no component was bound, success otherwise.\n+     */\n+    public DigitalTwinClientResult ready() {\n+        synchronized (lock) {\n+            if(components.isEmpty()) {\n+                return DIGITALTWIN_CLIENT_ERROR_COMPONENTS_NOT_BOUND;\n+            }\n+\n+            for (AbstractDigitalTwinComponent component : components.values()) {\n+                component.ready();\n+            }\n+        }\n+        return DIGITALTWIN_CLIENT_OK;\n+    }\n+\n+    Flowable<DigitalTwinClientResult> sendTelemetryAsync(\n+            @NonNull final String digitalTwinComponentName,\n+            @NonNull final String telemetryName,\n+            @NonNull final String payload) {\n+        return ensureConnectAsync()\n+                .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                    @Override\n+                    public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n+                        return Flowable.create(new FlowableOnSubscribe<DigitalTwinClientResult>() {\n+                            @Override\n+                            public void subscribe(FlowableEmitter<DigitalTwinClientResult> emitter) throws Throwable {\n+                                log.debug(\"Sending TelemetryAsync...\");\n+                                SimpleEntry body = new SimpleEntry<>(telemetryName, new JsonRawValue(payload));\n+                                Message message = new Message(serialize(body));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "originalPosition": 362}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTEwNjkz", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#pullrequestreview-344910693", "createdAt": "2020-01-18T00:56:33Z", "commit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo1NjozM1rOFfIpug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo1NjozM1rOFfIpug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MTkzMA==", "bodyText": "grammar: succeeded", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r368191930", "createdAt": "2020-01-18T00:56:33Z", "author": {"login": "drwill-ms"}, "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DigitalTwinDeviceClient.java", "diffHunk": "@@ -109,166 +99,284 @@\n      * Callers MUST NOT directly access {@link DeviceClient} after.\n      *\n      * @param deviceClient An {@link DeviceClient} that has been already created and bound to a specific connection string (or transport, or DPS handle, or whatever mechanism is preferred).\n+     * @param deviceCapabilityModelId     Device Capability Model Id\n+     *\n      */\n-    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient) {\n-        this.deviceClient = deviceClient;\n-        this.registrationStatus = UNREGISTERED;\n-        this.digitalTwinInterfaceClients = new HashMap<>();\n+    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient, @NonNull String deviceCapabilityModelId) {\n+        this.deviceClientManager = new DeviceClientManager(deviceClient);\n+        this.deviceCapabilityModelId = deviceCapabilityModelId;\n+        this.components = new ConcurrentHashMap<>();\n         this.lock = new Object();\n     }\n \n     /**\n-     * Registers the specified {@link AbstractDigitalTwinInterfaceClient} with the DigitalTwin Service.\n-     * The call occurs asynchronously. While registration is in progress, {@link AbstractDigitalTwinInterfaceClient}'s that are being registered will not be able to report properties nor receive commands.\n-     * The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n-     * It must not be called multiple times.  If a given Digital Twin device needs to have its handles re-registered, it needs to create a new DigitalTwinDeviceClient instance.\n+     * Bind all digital twin components with Digital Twin device client.\n+     * @param digitalTwinComponents An list of {@link AbstractDigitalTwinComponent}s to register with the service.\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult bindComponents(@NonNull final List<? extends AbstractDigitalTwinComponent> digitalTwinComponents) {\n+        synchronized (lock) {\n+            if(!components.isEmpty()) {\n+                return DIGITALTWIN_CLIENT_ERROR_COMPONENTS_ALREADY_BOUND;\n+            }\n+\n+            for (AbstractDigitalTwinComponent digitalTwinComponent : digitalTwinComponents) {\n+                digitalTwinComponent.setDigitalTwinDeviceClient(this);\n+                components.put(digitalTwinComponent.getDigitalTwinComponentName(), digitalTwinComponent);\n+            }\n+        }\n+        return DIGITALTWIN_CLIENT_OK;\n+    }\n+\n+    /**\n+     * Sends registration message message to DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n      *\n-     * @param deviceCapabilityModelId     Device Capability Model Id\n-     * @param digitalTwinInterfaceClients An list of {@link AbstractDigitalTwinInterfaceClient}s to register with the service.\n      * @return Result of this async function.\n      */\n-    public Single<DigitalTwinClientResult> registerInterfacesAsync(@NonNull final String deviceCapabilityModelId,\n-            @NonNull final List<? extends AbstractDigitalTwinInterfaceClient> digitalTwinInterfaceClients) {\n+    public Single<DigitalTwinClientResult> registerComponentsAsync() {\n         synchronized (lock) {\n-            if (registrationStatus == REGISTERING) {\n-                return Single.just(DIGITALTWIN_CLIENT_ERROR_REGISTRATION_PENDING);\n-            } else if (registrationStatus == REGISTERED) {\n-                return Single.just(DIGITALTWIN_CLIENT_ERROR_INTERFACE_ALREADY_REGISTERED);\n-            } else {\n-                registrationStatus = REGISTERING;\n+            if(components.isEmpty()) {\n+                return Single.just(DIGITALTWIN_CLIENT_ERROR_COMPONENTS_NOT_BOUND);\n             }\n         }\n-\n-        return connectAsync(deviceClient)\n+        return ensureConnectAsync()\n                 .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n                     @Override\n                     public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        return sendRegistrationMessageAsync(deviceCapabilityModelId, digitalTwinInterfaceClients);\n-                    }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n-                    @Override\n-                    public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return subscribeCommandAsync();\n-                        } else {\n-                            return Flowable.just(result);\n-                        }\n+                        return sendRegistrationMessageAsync(result);\n                     }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                }).singleOrError();\n+    }\n+\n+    /**\n+     * Sends registration message to DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n+     *\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult registerComponents() {\n+        return registerComponentsAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Subscribe commands with the DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.* @return Result of this sync function.\n+     *\n+     * @return Result of this async function.\n+     */\n+    public Single<DigitalTwinClientResult> subscribeForCommandsAsync() {\n+        return ensureConnectAsync()\n+                .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n                     @Override\n                     public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return subscribeTwinAsync();\n-                        } else {\n-                            return Flowable.just(result);\n-                        }\n+                        return subscribeCommandsAsync(result);\n                     }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                }).singleOrError();\n+    }\n+\n+    /**\n+     * Subscribe commands with the DigitalTwin Service.\n+     * The call will be blocked and will return the result once registration is processed.\n+     *\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult subscribeForCommands() {\n+        return subscribeForCommandsAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Subscribe properties with the DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.* @return Result of this sync function.\n+     *\n+     * @return Result of this async function.\n+     */\n+    public Single<DigitalTwinClientResult> subscribeForPropertiesAsync() {\n+        return ensureConnectAsync()\n+                .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n                     @Override\n                     public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return reportSdkInformationAsync();\n-                        } else {\n-                            return Flowable.just(result);\n-                        }\n-                    }\n-                }).map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n-                    @Override\n-                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) throws Throwable {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return getTwinAsync();\n-                        } else {\n-                            return result;\n-                        }\n-                    }\n-                }).map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n-                    @Override\n-                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return notifyComponents(digitalTwinInterfaceClients);\n-                        } else {\n-                            return result;\n-                        }\n+                        return subscribePropertiesAsync(result);\n                     }\n-                }).map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n-                    @Override\n-                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) {\n-                        return onRegistrationResult(result);\n-                    }\n-                }).doOnError(new Consumer<Throwable>() {\n-                    @Override\n-                    public void accept(Throwable throwable) {\n-                        onRegistrationResult(DIGITALTWIN_CLIENT_ERROR);\n-                    }\n-                }).doOnCancel(new Action() {\n+                }).singleOrError();\n+    }\n+\n+    /**\n+     * Subscribe properties with the DigitalTwin Service.\n+     * The call will be blocked and will return the result once registration is processed.\n+     *\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult subscribeForProperties() {\n+        return subscribeForPropertiesAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Trigger properties sync up with the DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.* @return Result of this sync function.\n+     *\n+     * @return Result of this async function.\n+     */\n+    public Single<DigitalTwinClientResult> syncupPropertiesAsync() {\n+        return ensureConnectAsync()\n+                .map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n                     @Override\n-                    public void run() {\n-                        onRegistrationResult(DIGITALTWIN_CLIENT_ERROR);\n+                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) throws IOException {\n+                        // TODO Known gap, SDK API accepts no callback, there is no guarantee it's delivered\n+                        log.debug(\"Getting DeviceTwin...\");\n+                        deviceClientManager.getDeviceTwin();\n+                        return DIGITALTWIN_CLIENT_OK;\n                     }\n-                })\n-                .singleOrError();\n+                }).singleOrError();\n     }\n \n     /**\n-     * Registers the specified {@link AbstractDigitalTwinInterfaceClient} with the DigitalTwin Service.\n+     * Trigger properties sync up with the DigitalTwin Service.\n      * The call will be blocked and will return the result once registration is processed.\n-     * It must not be called multiple times. If a given Digital Twin device needs to have its handles re-registered, it needs to create a new DigitalTwinDeviceClient instance.\n      *\n-     * @param deviceCapabilityModelId     Device Capability Model Id\n-     * @param digitalTwinInterfaceClients An list of {@link AbstractDigitalTwinInterfaceClient}s to register with the service.\n      * @return Result of this sync function.\n      */\n-    public DigitalTwinClientResult registerInterfaces(@NonNull final String deviceCapabilityModelId,\n-            @NonNull final List<? extends AbstractDigitalTwinInterfaceClient> digitalTwinInterfaceClients) {\n-        return registerInterfacesAsync(deviceCapabilityModelId, digitalTwinInterfaceClients).blockingGet();\n+    public DigitalTwinClientResult syncupProperties() {\n+        return syncupPropertiesAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Application should call this function to notify all components they are now ready to use. All bound component function {@link AbstractDigitalTwinComponent#ready()} will be triggered.\n+     *\n+     * @return Failure if no component was bound, success otherwise.\n+     */\n+    public DigitalTwinClientResult ready() {\n+        synchronized (lock) {\n+            if(components.isEmpty()) {\n+                return DIGITALTWIN_CLIENT_ERROR_COMPONENTS_NOT_BOUND;\n+            }\n+\n+            for (AbstractDigitalTwinComponent component : components.values()) {\n+                component.ready();\n+            }\n+        }\n+        return DIGITALTWIN_CLIENT_OK;\n+    }\n+\n+    Flowable<DigitalTwinClientResult> sendTelemetryAsync(\n+            @NonNull final String digitalTwinComponentName,\n+            @NonNull final String telemetryName,\n+            @NonNull final String payload) {\n+        return ensureConnectAsync()\n+                .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                    @Override\n+                    public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n+                        return Flowable.create(new FlowableOnSubscribe<DigitalTwinClientResult>() {\n+                            @Override\n+                            public void subscribe(FlowableEmitter<DigitalTwinClientResult> emitter) throws Throwable {\n+                                log.debug(\"Sending TelemetryAsync...\");\n+                                SimpleEntry body = new SimpleEntry<>(telemetryName, new JsonRawValue(payload));\n+                                Message message = new Message(serialize(body));\n+                                message.setProperty(PROPERTY_DIGITAL_TWIN_COMPONENT, digitalTwinComponentName);\n+                                message.setProperty(PROPERTY_MESSAGE_SCHEMA, telemetryName);\n+                                IotHubEventCallback callback = createIotHubEventCallback(emitter);\n+                                deviceClientManager.sendEventAsync(message, callback, callback);\n+                                log.debug(\"SendTelemetryAsync succeed.\");\n+                            }\n+                        }, BUFFER);\n+                    }\n+                });\n+    }\n+\n+    Flowable<DigitalTwinClientResult> reportPropertiesAsync(\n+            @NonNull final String digitalTwinComponentName,\n+            @NonNull final List<DigitalTwinReportProperty> digitalTwinReportProperties) {\n+        return ensureConnectAsync()\n+                .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                    @Override\n+                    public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n+                        return Flowable.create(new FlowableOnSubscribe<DigitalTwinClientResult>() {\n+                            @Override\n+                            public void subscribe(FlowableEmitter<DigitalTwinClientResult> emitter) throws Throwable {\n+                                log.debug(\"Reporting PropertiesAsync...\");\n+                                // TODO Known gap, SDK API with ambiguous Object\n+                                Property property = serializeReportProperty(digitalTwinComponentName, digitalTwinReportProperties);\n+                                deviceClientManager.sendReportedProperties(singleton(property));\n+                                // TODO Known gap, SDK API accepts no callback, there is no guarantee it's delivered\n+                                log.debug(\"ReportPropertiesAsync succeed.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "originalPosition": 389}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTExNjkw", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#pullrequestreview-344911690", "createdAt": "2020-01-18T01:03:07Z", "commit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMTowMzowN1rOFfItFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMTowMzowN1rOFfItFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5Mjc5MA==", "bodyText": "grammar: threw", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r368192790", "createdAt": "2020-01-18T01:03:07Z", "author": {"login": "drwill-ms"}, "path": "digital-twin/device/src/test/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DigitalTwinDeviceClientTest.java", "diffHunk": "@@ -301,84 +314,56 @@ public Object answer(InvocationOnMock invocation) throws Exception {\n             log.debug(\"Send registration message throw exception\", e);\n         }\n \n+        verify(deviceClient).open();\n         verify(errorConsumer).accept(eq(exception));\n-        assertThat(testee.getRegistrationStatus()).isEqualTo(UNREGISTERED);\n-        verify(digitalTwinInterfaceClient1, never()).setDigitalTwinDeviceClient(any(DigitalTwinDeviceClient.class));\n-        verify(digitalTwinInterfaceClient2, never()).setDigitalTwinDeviceClient(any(DigitalTwinDeviceClient.class));\n-        verify(digitalTwinInterfaceClient1, never()).onRegistered();\n-        verify(digitalTwinInterfaceClient2, never()).onRegistered();\n-        verify(deviceClient, never()).subscribeToDeviceMethod(any(DeviceMethodCallback.class), any(), any(IotHubEventCallback.class), any());\n     }\n \n     @Test\n-    public void registerInterfacesAsyncCommandSubscriptionFailedTest() throws IOException {\n-        doAnswer(new Answer() {\n-            @Override\n-            public Object answer(InvocationOnMock invocation) {\n-                final IotHubEventCallback iotHubEventCallback = invocation.getArgumentAt(2, IotHubEventCallback.class);\n-                final Object context = invocation.getArgumentAt(3, Object.class);\n-                new Thread(new Runnable() {\n-                    @Override\n-                    public void run() {\n-                        try {\n-                            Thread.sleep(DELAY_IN_MS);\n-                        } catch (InterruptedException e) {\n-                            e.printStackTrace();\n-                        }\n-                        iotHubEventCallback.execute(ERROR, context);\n-                    }\n-                }).start();\n-                return null;\n-            }\n-        }).when(deviceClient)\n-          .subscribeToDeviceMethod(any(DeviceMethodCallback.class), any(), any(IotHubEventCallback.class), any());\n-        DigitalTwinClientResult digitalTwinClientResult = testee.registerInterfacesAsync(DIGITAL_TWIN_DCM_ID, digitalTwinInterfaceClients).blockingGet();\n-        assertThat(digitalTwinClientResult).isEqualTo(DIGITALTWIN_CLIENT_ERROR);\n-        assertThat(testee.getRegistrationStatus()).isEqualTo(UNREGISTERED);\n-        verify(digitalTwinInterfaceClient1, never()).setDigitalTwinDeviceClient(any(DigitalTwinDeviceClient.class));\n-        verify(digitalTwinInterfaceClient2, never()).setDigitalTwinDeviceClient(any(DigitalTwinDeviceClient.class));\n-        verify(digitalTwinInterfaceClient1, never()).onRegistered();\n-        verify(digitalTwinInterfaceClient2, never()).onRegistered();\n-        verify(deviceClient, never()).startDeviceTwin(any(IotHubEventCallback.class), any(), any(TwinPropertyCallBack.class), any());\n+    public void subscribeForCommandsAsyncTest() throws IOException {\n+        assertThat(testee.subscribeForCommandsAsync().blockingGet()).isEqualTo(DIGITALTWIN_CLIENT_OK);\n+        verify(deviceClient).open();\n+        verify(deviceClient).subscribeToDeviceMethod(any(DeviceMethodCallback.class), any(), any(IotHubEventCallback.class), any());\n     }\n \n     @Test\n-    public void registerInterfacesAsyncCommandSubscriptionThrowExceptionTest() throws Throwable {\n-        final Exception exception = new Exception(\"CommandSubscriptionThrowException\");\n+    public void subscribeForCommandsTest() throws IOException {\n+        assertThat(testee.subscribeForCommands()).isEqualTo(DIGITALTWIN_CLIENT_OK);\n+        verify(deviceClient).open();\n+        verify(deviceClient).subscribeToDeviceMethod(any(DeviceMethodCallback.class), any(), any(IotHubEventCallback.class), any());\n+    }\n+\n+    @Test\n+    public void subscribeForCommandsAsyncOpenThrowExceptionTest() throws Throwable {\n+        final Exception exception = new Exception(\"OpenThrowException\");\n         doAnswer(new Answer() {\n             @Override\n             public Object answer(InvocationOnMock invocation) throws Exception {\n                 throw exception;\n             }\n         }).when(deviceClient)\n-          .subscribeToDeviceMethod(any(DeviceMethodCallback.class), any(), any(IotHubEventCallback.class), any());\n+          .open();\n \n         try {\n-            DigitalTwinClientResult digitalTwinClientResult = testee.registerInterfacesAsync(DIGITAL_TWIN_DCM_ID, digitalTwinInterfaceClients)\n+            DigitalTwinClientResult digitalTwinClientResult = testee.subscribeForCommandsAsync()\n                                                                     .doOnError(errorConsumer)\n                                                                     .blockingGet();\n             log.debug(\"Unexpected result: {}\", digitalTwinClientResult);\n             fail(\"Should throw exception.\");\n         } catch (Throwable e) {\n-            log.debug(\"Subscribe command throw exception.\", e);\n+            log.debug(\"Open throw exception\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "originalPosition": 352}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTEyNTE3", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#pullrequestreview-344912517", "createdAt": "2020-01-18T01:09:14Z", "commit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMTowOToxNVrOFfIwEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMTowOToxNVrOFfIwEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MzU1Mg==", "bodyText": "interface instance => component\nelsewhere too", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r368193552", "createdAt": "2020-01-18T01:09:15Z", "author": {"login": "drwill-ms"}, "path": "digital-twin/service/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/service/DigitalTwinServiceAsyncClient.java", "diffHunk": "@@ -56,24 +56,24 @@\n      * @return The observable to the json string specifying the updated state  of the digital twin representation\n      * @throws IOException Throws IOException if the json deserialization fails\n      */\n-    Observable<String> updateDigitalTwinProperties(@NonNull String digitalTwinId, @NonNull final String interfaceInstanceName, @NonNull String propertyPatch) throws IOException;\n+    Observable<String> updateDigitalTwinProperties(@NonNull String digitalTwinId, @NonNull final String componentName, @NonNull String propertyPatch) throws IOException;\n \n     /**\n      * Invoke a digital twin command on the given interface instance that is implemented by the given digital twin", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTEyNjgx", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#pullrequestreview-344912681", "createdAt": "2020-01-18T01:10:31Z", "commit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4", "author": {"user": {"login": "davilu", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/4a5cba8c47b3e273156286d60c18fec8af5ccaa4", "committedDate": "2020-01-18T00:27:27Z", "message": "refactor(digitaltwin-device): separated digital twin client register API and renamed interface instance to component"}, "afterCommit": {"oid": "6a3302a240d89e6c136fe81283f28f5b69bf9cf8", "author": {"user": {"login": "davilu", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/6a3302a240d89e6c136fe81283f28f5b69bf9cf8", "committedDate": "2020-01-18T04:59:51Z", "message": "refactor(digitaltwin-device): separated digital twin client register API and renamed interface instance to component"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6a3302a240d89e6c136fe81283f28f5b69bf9cf8", "author": {"user": {"login": "davilu", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/6a3302a240d89e6c136fe81283f28f5b69bf9cf8", "committedDate": "2020-01-18T04:59:51Z", "message": "refactor(digitaltwin-device): separated digital twin client register API and renamed interface instance to component"}, "afterCommit": {"oid": "63ad99ade89472ad0669527ca4b32a99254e3dee", "author": {"user": {"login": "davilu", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/63ad99ade89472ad0669527ca4b32a99254e3dee", "committedDate": "2020-01-21T19:11:27Z", "message": "refactor(digitaltwin-device): separated digital twin client register API and renamed interface instance to component"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTI1Mzc4", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#pullrequestreview-346125378", "createdAt": "2020-01-21T19:15:29Z", "commit": {"oid": "63ad99ade89472ad0669527ca4b32a99254e3dee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxOToxNToyOVrOFgFsLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxOToxNToyOVrOFgFsLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE5MTk4MA==", "bodyText": "From my testing, we throw IOException on network loss. The TransportException is embedded under Exception.getCause(): https://github.com/Azure/azure-iot-sdk-java/pull/681/files#diff-d05304fffaae6bfdbe785b51eca97bfcR74", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r369191980", "createdAt": "2020-01-21T19:15:29Z", "author": {"login": "abhipsaMisra"}, "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DeviceClientManager.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package com.microsoft.azure.sdk.iot.digitaltwin.device;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceClient;\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.experimental.Delegate;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+@Slf4j\n+public class DeviceClientManager implements IotHubConnectionStatusChangeCallback {\n+    private enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+\n+    private static final Object lock = new Object();\n+    private static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 10;\n+    private ConnectionStatus connectionStatus;\n+    private Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    private interface DeviceClientNonDelegatedFunction {\n+        void open();\n+        void closeNow();\n+        void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext);\n+    }\n+\n+    // The methods defined in the interface DeviceClientNonDelegatedFunction will be called on DeviceClientManager, and not on DeviceClient.\n+    @Delegate(excludes = DeviceClientNonDelegatedFunction.class)\n+    private final DeviceClient client;\n+\n+    DeviceClientManager(DeviceClient deviceClient) {\n+        this.connectionStatus = ConnectionStatus.DISCONNECTED;\n+        this.client = deviceClient;\n+        this.client.registerConnectionStatusChangeCallback(this, this);\n+    }\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+    }\n+\n+    public void open() throws Exception {\n+        synchronized (lock) {\n+            if (connectionStatus == ConnectionStatus.DISCONNECTED) {\n+                connectionStatus = ConnectionStatus.CONNECTING;\n+            } else {\n+                return;\n+            }\n+        }\n+        doConnect();\n+    }\n+\n+    private void doConnect() throws Exception {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if (connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"[connect] - Opening the device client instance...\");\n+                        client.open();\n+                        connectionStatus = ConnectionStatus.CONNECTED;\n+                        break;\n+                    }\n+                    catch (Exception ex) {\n+                        log.error(\"[connect] - Exception thrown while opening DeviceClient instance: \", ex);\n+                        if (ex instanceof TransportException && ((TransportException) ex).isRetryable()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63ad99ade89472ad0669527ca4b32a99254e3dee"}, "originalPosition": 75}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTU5NDk0", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#pullrequestreview-346159494", "createdAt": "2020-01-21T20:11:03Z", "commit": {"oid": "63ad99ade89472ad0669527ca4b32a99254e3dee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMDoxMTowNFrOFgHUfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMDoxMTowNFrOFgHUfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIxODY4NQ==", "bodyText": "Isn't the behavior of eq() the same as same()?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r369218685", "createdAt": "2020-01-21T20:11:04Z", "author": {"login": "abhipsaMisra"}, "path": "digital-twin/device/src/test/java/com/microsoft/azure/sdk/iot/digitaltwin/device/SdkInformationComponentTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package com.microsoft.azure.sdk.iot.digitaltwin.device;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.powermock.core.classloader.annotations.PrepareForTest;\n+import org.powermock.modules.junit4.PowerMockRunner;\n+\n+import static com.microsoft.azure.sdk.iot.digitaltwin.device.DigitalTwinClientResult.DIGITALTWIN_CLIENT_OK;\n+import static com.microsoft.azure.sdk.iot.digitaltwin.device.SdkInformationComponent.SDK_INFORMATION_COMPONENT_NAME;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Matchers.same;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(PowerMockRunner.class)\n+@PrepareForTest({DigitalTwinDeviceClient.class})\n+public class SdkInformationComponentTest {\n+\n+    @Mock\n+    private DigitalTwinDeviceClient digitalTwinDeviceClient;\n+\n+    @Test\n+    public void singletonTest() {\n+        assertThat(SdkInformationComponent.getInstance()).isSameAs(SdkInformationComponent.getInstance());\n+        assertThat(SdkInformationComponent.getInstance().getSdkInformationProperties()).isNotEmpty();\n+    }\n+\n+    @Test\n+    public void readyTest() {\n+        SdkInformationComponent sdkInformationComponent = SdkInformationComponent.getInstance();\n+        when(digitalTwinDeviceClient.reportPropertiesAsync(eq(SDK_INFORMATION_COMPONENT_NAME), same(sdkInformationComponent.getSdkInformationProperties()))).thenReturn(Flowable.just(DIGITALTWIN_CLIENT_OK));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63ad99ade89472ad0669527ca4b32a99254e3dee"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTcwMzgx", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#pullrequestreview-346170381", "createdAt": "2020-01-21T20:30:14Z", "commit": {"oid": "63ad99ade89472ad0669527ca4b32a99254e3dee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMDozMDoxNFrOFgH0gQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMDozMDoxNFrOFgH0gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIyNjg4MQ==", "bodyText": "Should be retrieveComponentNameFromComponentId, but I can refactor these when I make the updates for the service client.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r369226881", "createdAt": "2020-01-21T20:30:14Z", "author": {"login": "abhipsaMisra"}, "path": "digital-twin/e2e-tests/digital-twin-e2e-tests-common/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/e2e/tests/DigitalTwinCommandE2ETests.java", "diffHunk": "@@ -54,17 +67,18 @@\n @RunWith(Parameterized.class)\n public class DigitalTwinCommandE2ETests {\n     private static final String IOT_HUB_CONNECTION_STRING = retrieveEnvironmentVariableValue(IOT_HUB_CONNECTION_STRING_ENV_VAR_NAME);\n-    private static final String TEST_INTERFACE_INSTANCE_NAME_1 = retrieveInterfaceNameFromInterfaceId(TestInterfaceInstance1.TEST_INTERFACE_ID);\n-    private static final String TEST_INTERFACE_INSTANCE_NAME_2 = retrieveInterfaceNameFromInterfaceId(TEST_INTERFACE_ID);\n+    private static final String TEST_COMPONENT_NAME_1 = retrieveComponentNameFromInterfaceId(TestComponent1.TEST_INTERFACE_ID);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63ad99ade89472ad0669527ca4b32a99254e3dee"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MjM4MjE1", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#pullrequestreview-346238215", "createdAt": "2020-01-21T22:32:10Z", "commit": {"oid": "63ad99ade89472ad0669527ca4b32a99254e3dee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMjozMjoxMFrOFgLBgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMjozMjoxMFrOFgLBgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI3OTM2MA==", "bodyText": "Our nightly run shows that this test passed, we should not ignore it.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r369279360", "createdAt": "2020-01-21T22:32:10Z", "author": {"login": "abhipsaMisra"}, "path": "digital-twin/e2e-tests/digital-twin-e2e-tests-common/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/e2e/tests/DigitalTwinServiceClientE2ETests.java", "diffHunk": "@@ -58,14 +59,19 @@ public void setUpTest() throws IotHubException, IOException, URISyntaxException\n     }\n \n     @Test\n+    // TODO\n+    @Ignore(\"404 response from server\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63ad99ade89472ad0669527ca4b32a99254e3dee"}, "originalPosition": 32}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa1a58401dec455272890d281e7527b569a9998b", "author": {"user": {"login": "davilu", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/fa1a58401dec455272890d281e7527b569a9998b", "committedDate": "2020-01-22T20:46:10Z", "message": "refactor(digitaltwin-device): separated digital twin client register API and renamed interface instance to component"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "63ad99ade89472ad0669527ca4b32a99254e3dee", "author": {"user": {"login": "davilu", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/63ad99ade89472ad0669527ca4b32a99254e3dee", "committedDate": "2020-01-21T19:11:27Z", "message": "refactor(digitaltwin-device): separated digital twin client register API and renamed interface instance to component"}, "afterCommit": {"oid": "fa1a58401dec455272890d281e7527b569a9998b", "author": {"user": {"login": "davilu", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/fa1a58401dec455272890d281e7527b569a9998b", "committedDate": "2020-01-22T20:46:10Z", "message": "refactor(digitaltwin-device): separated digital twin client register API and renamed interface instance to component"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a2ad25bf0ba9e28cca3ae66e629e2d0260512315", "author": {"user": {"login": "davilu", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/a2ad25bf0ba9e28cca3ae66e629e2d0260512315", "committedDate": "2020-01-28T02:43:04Z", "message": "e2e:added nagtive tests for command and twin for digital twin without subscription"}, "afterCommit": {"oid": "cffa8395ca285e0124e952e0f2a82e751dc1d400", "author": {"user": {"login": "davilu", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/cffa8395ca285e0124e952e0f2a82e751dc1d400", "committedDate": "2020-01-28T18:24:36Z", "message": "e2e:added nagtive tests for command and twin for digital twin without subscription"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTIzMTkz", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#pullrequestreview-346123193", "createdAt": "2020-01-21T19:12:00Z", "commit": {"oid": "6a3302a240d89e6c136fe81283f28f5b69bf9cf8"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMDo0NDo1M1rOFiz3EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMDo0NDo1M1rOFiz3EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA0NTU4NQ==", "bodyText": "logging update to \"... component is not bound\"?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r372045585", "createdAt": "2020-01-28T20:44:53Z", "author": {"login": "drwill-ms"}, "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/AbstractDigitalTwinComponent.java", "diffHunk": "@@ -105,14 +104,14 @@ protected final DigitalTwinClientResult sendTelemetry(@NonNull final String tele\n      * @return Result of this async function.\n      */\n     protected final Single<DigitalTwinClientResult> reportPropertiesAsync(@NonNull final List<DigitalTwinReportProperty> digitalTwinReportProperties) {\n-        log.debug(\"Reporting PropertiesAsync from interface instance={}\", digitalTwinInterfaceInstanceName);\n+        log.debug(\"Reporting PropertiesAsync from component={}\", digitalTwinComponentName);\n         if (digitalTwinDeviceClient == null) {\n-            log.debug(\"Report PropertiesAsync from interface instance={} failed: interface instance is not registered.\", digitalTwinInterfaceInstanceName);\n-            return Single.just(DIGITALTWIN_CLIENT_ERROR_INTERFACE_NOT_REGISTERED);\n+            log.debug(\"Report PropertiesAsync from component={} failed: component is not registered.\", digitalTwinComponentName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cffa8395ca285e0124e952e0f2a82e751dc1d400"}, "originalPosition": 81}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c18d290694f7c92db86de2bc781b07fa6433615f", "author": {"user": {"login": "davilu", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/c18d290694f7c92db86de2bc781b07fa6433615f", "committedDate": "2020-01-28T22:09:21Z", "message": "e2e:added nagtive tests for command and twin for digital twin without subscription"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cffa8395ca285e0124e952e0f2a82e751dc1d400", "author": {"user": {"login": "davilu", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/cffa8395ca285e0124e952e0f2a82e751dc1d400", "committedDate": "2020-01-28T18:24:36Z", "message": "e2e:added nagtive tests for command and twin for digital twin without subscription"}, "afterCommit": {"oid": "c18d290694f7c92db86de2bc781b07fa6433615f", "author": {"user": {"login": "davilu", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/c18d290694f7c92db86de2bc781b07fa6433615f", "committedDate": "2020-01-28T22:09:21Z", "message": "e2e:added nagtive tests for command and twin for digital twin without subscription"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "821c11af42dea6c42b1296744071e01b6dc26803", "author": {"user": {"login": "davilu", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/821c11af42dea6c42b1296744071e01b6dc26803", "committedDate": "2020-01-29T00:43:31Z", "message": "Merge branch 'preview' into dt-register-change"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5ODAxODUz", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#pullrequestreview-349801853", "createdAt": "2020-01-29T00:44:36Z", "commit": {"oid": "cffa8395ca285e0124e952e0f2a82e751dc1d400"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1803, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}