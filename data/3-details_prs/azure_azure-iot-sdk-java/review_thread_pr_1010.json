{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI5ODk3NDUx", "number": 1010, "reviewThreads": {"totalCount": 34, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMDo1ODo1OFrOE-57LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxOTozODo1MFrOFAbmdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Mzk2MjA0OnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMDo1ODo1OFrOH8T7fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMTowMzozNVrOH8UBww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAwMzEzMg==", "bodyText": "We did this silly thing in the DeviceClient to work around the fact that we can't throw TransportException's directly in methods like deviceClient.open() becuase the open API existed before the TransportException did. To get around it, we just nested the meaningful exception into an IOException. I don't want to do the same thing for the multiplexing client though, so this code un-nests the exception when possible.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533003132", "createdAt": "2020-12-01T00:58:58Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "diffHunk": "@@ -164,14 +164,36 @@ void open() throws IOException\n         }\n     }\n \n-    void registerMultiplexedDeviceClient(List<DeviceClientConfig> configs) throws InterruptedException\n+    // Functionally the same as \"open()\", but without wrapping any thrown TransportException into an IOException\n+    void multiplexingClientOpen() throws TransportException\n     {\n-        this.transport.registerMultiplexedDeviceClient(configs);\n+        try\n+        {\n+            open();\n+        }\n+        catch (IOException e)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f20a64b429a70d7ef91767b4d8d22512cabe931"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAwNDczOQ==", "bodyText": "Add that as a code comment, then please", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533004739", "createdAt": "2020-12-01T01:03:35Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "diffHunk": "@@ -164,14 +164,36 @@ void open() throws IOException\n         }\n     }\n \n-    void registerMultiplexedDeviceClient(List<DeviceClientConfig> configs) throws InterruptedException\n+    // Functionally the same as \"open()\", but without wrapping any thrown TransportException into an IOException\n+    void multiplexingClientOpen() throws TransportException\n     {\n-        this.transport.registerMultiplexedDeviceClient(configs);\n+        try\n+        {\n+            open();\n+        }\n+        catch (IOException e)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAwMzEzMg=="}, "originalCommit": {"oid": "6f20a64b429a70d7ef91767b4d8d22512cabe931"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Mzk2NjcyOnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/exceptions/MultiplexingClientDeviceRegistrationFailedException.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMTowMDo0M1rOH8T-EA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxOToyNToyMVrOH88UQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAwMzc5Mg==", "bodyText": "I should maybe rename this to MultiplexingClientDeviceRegistrationAuthenticationFailedException to be more specific, since it is only ever thrown when a device's authentication fails", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533003792", "createdAt": "2020-12-01T01:00:43Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/exceptions/MultiplexingClientDeviceRegistrationFailedException.java", "diffHunk": "@@ -0,0 +1,85 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.microsoft.azure.sdk.iot.device.exceptions;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Exception that is thrown when one or more devices fail to register to an active multiplexed connection.\n+ */\n+public class MultiplexingClientDeviceRegistrationFailedException extends MultiplexingClientException\n+{\n+    private Map<String, Exception> registrationExceptions = new HashMap<>();\n+\n+    /**\n+     * Construct a new MultiplexingClientDeviceRegistrationFailedException with no nested exception and no error message.\n+     */\n+    public MultiplexingClientDeviceRegistrationFailedException()\n+    {\n+        super();\n+    }\n+\n+    /**\n+     * Construct a new MultiplexingClientDeviceRegistrationFailedException with no nested exception but with an error message.\n+     * @param message The top level message for this exception.\n+     */\n+    public MultiplexingClientDeviceRegistrationFailedException(String message)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f20a64b429a70d7ef91767b4d8d22512cabe931"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2NDgzMg==", "bodyText": "I think that is a good change. you probably don't even need the word failed in there as Exception kind of gives that away", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533664832", "createdAt": "2020-12-01T19:25:21Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/exceptions/MultiplexingClientDeviceRegistrationFailedException.java", "diffHunk": "@@ -0,0 +1,85 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.microsoft.azure.sdk.iot.device.exceptions;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Exception that is thrown when one or more devices fail to register to an active multiplexed connection.\n+ */\n+public class MultiplexingClientDeviceRegistrationFailedException extends MultiplexingClientException\n+{\n+    private Map<String, Exception> registrationExceptions = new HashMap<>();\n+\n+    /**\n+     * Construct a new MultiplexingClientDeviceRegistrationFailedException with no nested exception and no error message.\n+     */\n+    public MultiplexingClientDeviceRegistrationFailedException()\n+    {\n+        super();\n+    }\n+\n+    /**\n+     * Construct a new MultiplexingClientDeviceRegistrationFailedException with no nested exception but with an error message.\n+     * @param message The top level message for this exception.\n+     */\n+    public MultiplexingClientDeviceRegistrationFailedException(String message)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAwMzc5Mg=="}, "originalCommit": {"oid": "6f20a64b429a70d7ef91767b4d8d22512cabe931"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Mzk3Mjc5OnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMTowMzoxMlrOH8UBYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxODozMjoxMVrOH86XGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAwNDY0MQ==", "bodyText": "Would feel more natural to me if the verb were first: openMultiplexingClient. Thoughts?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533004641", "createdAt": "2020-12-01T01:03:12Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "diffHunk": "@@ -164,14 +164,36 @@ void open() throws IOException\n         }\n     }\n \n-    void registerMultiplexedDeviceClient(List<DeviceClientConfig> configs) throws InterruptedException\n+    // Functionally the same as \"open()\", but without wrapping any thrown TransportException into an IOException\n+    void multiplexingClientOpen() throws TransportException", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f20a64b429a70d7ef91767b4d8d22512cabe931"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYzMjAwNw==", "bodyText": "This doesn't open the multiplexing client though. It is the open method used exclusively by the multiplexing client", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533632007", "createdAt": "2020-12-01T18:30:48Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "diffHunk": "@@ -164,14 +164,36 @@ void open() throws IOException\n         }\n     }\n \n-    void registerMultiplexedDeviceClient(List<DeviceClientConfig> configs) throws InterruptedException\n+    // Functionally the same as \"open()\", but without wrapping any thrown TransportException into an IOException\n+    void multiplexingClientOpen() throws TransportException", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAwNDY0MQ=="}, "originalCommit": {"oid": "6f20a64b429a70d7ef91767b4d8d22512cabe931"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYzMjUxMQ==", "bodyText": "I'll rename this to something like \"openWithoutWrappingException\" instead, so that this isn't necessarily limited to multiplexing clients though", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533632511", "createdAt": "2020-12-01T18:31:43Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "diffHunk": "@@ -164,14 +164,36 @@ void open() throws IOException\n         }\n     }\n \n-    void registerMultiplexedDeviceClient(List<DeviceClientConfig> configs) throws InterruptedException\n+    // Functionally the same as \"open()\", but without wrapping any thrown TransportException into an IOException\n+    void multiplexingClientOpen() throws TransportException", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAwNDY0MQ=="}, "originalCommit": {"oid": "6f20a64b429a70d7ef91767b4d8d22512cabe931"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYzMjczNg==", "bodyText": "I don't know how someone would know that.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533632736", "createdAt": "2020-12-01T18:32:04Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "diffHunk": "@@ -164,14 +164,36 @@ void open() throws IOException\n         }\n     }\n \n-    void registerMultiplexedDeviceClient(List<DeviceClientConfig> configs) throws InterruptedException\n+    // Functionally the same as \"open()\", but without wrapping any thrown TransportException into an IOException\n+    void multiplexingClientOpen() throws TransportException", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAwNDY0MQ=="}, "originalCommit": {"oid": "6f20a64b429a70d7ef91767b4d8d22512cabe931"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYzMjc5Mg==", "bodyText": "And I'll do the same for the similar close method", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533632792", "createdAt": "2020-12-01T18:32:11Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "diffHunk": "@@ -164,14 +164,36 @@ void open() throws IOException\n         }\n     }\n \n-    void registerMultiplexedDeviceClient(List<DeviceClientConfig> configs) throws InterruptedException\n+    // Functionally the same as \"open()\", but without wrapping any thrown TransportException into an IOException\n+    void multiplexingClientOpen() throws TransportException", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAwNDY0MQ=="}, "originalCommit": {"oid": "6f20a64b429a70d7ef91767b4d8d22512cabe931"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Mzk3NDUxOnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMTowMzo1NlrOH8UCWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMTowMzo1NlrOH8UCWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAwNDg4OQ==", "bodyText": "Same: closeMultiplexingClient", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533004889", "createdAt": "2020-12-01T01:03:56Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "diffHunk": "@@ -251,18 +273,25 @@ public void close() throws IOException\n         }\n     }\n \n-    /**\n-     * Completes all current outstanding requests and closes the IoT Hub client.\n-     * Must be called to terminate the background thread that is sending data to\n-     * IoT Hub. After {@code close()} is called, the IoT Hub client is no longer\n-     *  usable. If the client is already closed, the function shall do nothing.\n-     *\n-     * @throws IOException if the connection to an IoT Hub cannot be closed.\n-     */\n-    public void multiplexClose() throws IOException\n+    // Functionally the same as \"close()\", but without wrapping any thrown TransportException into an IOException\n+    public void multiplexClose() throws TransportException", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f20a64b429a70d7ef91767b4d8d22512cabe931"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Mzk3NTQzOnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMTowNDoyMlrOH8UC3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMTowNDoyMlrOH8UC3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAwNTAyMA==", "bodyText": "Naming consistency: multiplexing", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533005020", "createdAt": "2020-12-01T01:04:22Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -119,6 +124,8 @@ else if (receivePeriod == 0) //default builder value for this option, signals th\n         this.deviceIO = new DeviceIO(hostName, protocol, sslContext, proxySettings, sendPeriod, receivePeriod);\n     }\n \n+    private static final String OPEN_ERROR_MESSAGE = \"Failed to open the multiplexed connection\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f20a64b429a70d7ef91767b4d8d22512cabe931"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Mzk4MjkxOnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubTransport.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMTowNzo0NFrOH8UHOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMTowNzo0NFrOH8UHOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAwNjEzOA==", "bodyText": "puncuation?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533006138", "createdAt": "2020-12-01T01:07:44Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubTransport.java", "diffHunk": "@@ -719,19 +731,47 @@ public void registerMultiplexedDeviceClient(List<DeviceClientConfig> configs) th\n         }\n \n         // If the multiplexed connection is active, block until all the registered devices have been connected.\n+        long timeoutTime = System.currentTimeMillis() + timeoutMilliseconds;\n+        MultiplexingClientDeviceRegistrationFailedException registrationException = null;\n         if (this.connectionStatus != IotHubConnectionStatus.DISCONNECTED)\n         {\n             for (DeviceClientConfig newlyRegisteredConfig : configs)\n             {\n-                while (deviceConnectionStates.get(newlyRegisteredConfig.getDeviceId()) != IotHubConnectionStatus.CONNECTED)\n+                String deviceId = newlyRegisteredConfig.getDeviceId();\n+                boolean deviceIsNotConnected = deviceConnectionStates.get(deviceId) != IotHubConnectionStatus.CONNECTED;\n+                Exception deviceRegistrationException = multiplexingDeviceRegistrationFailures.remove(deviceId);\n+                while (deviceIsNotConnected && deviceRegistrationException == null)\n                 {\n                     Thread.sleep(100);\n+\n+                    deviceIsNotConnected = deviceConnectionStates.get(deviceId) != IotHubConnectionStatus.CONNECTED;\n+                    deviceRegistrationException = multiplexingDeviceRegistrationFailures.remove(deviceId);\n+                    boolean operationHasTimedOut = System.currentTimeMillis() >= timeoutTime;\n+                    if (operationHasTimedOut)\n+                    {\n+                        throw new MultiplexingClientDeviceRegistrationFailedException(\"Timed out waiting for all device registrations to finish\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f20a64b429a70d7ef91767b4d8d22512cabe931"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Mzk4NzI0OnYy", "diffSide": "RIGHT", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexingSample.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMTowOTo0NFrOH8UJ1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMTowOTo0NFrOH8UJ1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAwNjgwNA==", "bodyText": "inconsistent brace usage", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533006804", "createdAt": "2020-12-01T01:09:44Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexingSample.java", "diffHunk": "@@ -102,16 +115,57 @@ public static void main(String[] args)\n \n         System.out.println(\"Opening multiplexed connection\");\n         // All previously registered device clients will be opened alongside this multiplexing client\n-        multiplexClientManager.open();\n+        try\n+        {\n+            multiplexClientManager.open();\n+        }\n+        catch (MultiplexingClientException | IOException e)\n+        {\n+            System.out.println(\"Unexpected exception thrown while opening multiplexed connection, closing client...\");\n+            e.printStackTrace();\n+            multiplexingClient.close();\n+            System.exit(-1);\n+        }\n         System.out.println(\"Multiplexed connection opened successfully\");\n \n         // Note that all the clients are registered at once. This method will asynchronously start the registration\n         // process for each device client, and then it will block until all registrations are complete before returning.\n         // If instead each client was registered separately through multiplexingClient.registerDeviceClient(), it would\n         // take a longer time since it would block on each registration completing, rather than block on all registrations completing\n         System.out.println(\"Registering \" + multiplexedDeviceCount + \" clients to the multiplexing client...\");\n-        multiplexClientManager.registerDeviceClients(multiplexedDeviceClients.values());\n-\n+        try\n+        {\n+            multiplexClientManager.registerDeviceClients(multiplexedDeviceClients.values());\n+        }\n+        catch (MultiplexingClientDeviceRegistrationFailedException e)\n+        {\n+            // When registering device clients to an active multiplexed connection, one to all of the devices may fail\n+            // to register if they have out-of-date or otherwise incorrect connection strings, for instance. The thrown exception\n+            // here contains a map of deviceId -> registration failure so that you can tell which devices failed to register,\n+            // and why each device failed to register.\n+            System.out.println(\"Encountered an exception while registering devices to the active multiplexed connection: \" + e.getMessage());\n+            Map<String, Exception> registrationExceptions = e.getRegistrationExceptions();\n+            for (String deviceId : registrationExceptions.keySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f20a64b429a70d7ef91767b4d8d22512cabe931"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Nzc3MTc1OnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNzo0NjoyNlrOH84m-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNzo0NjoyNlrOH84m-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYwNDA4OA==", "bodyText": "it seems like we don't need the else since the if statement throws.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533604088", "createdAt": "2020-12-01T17:46:26Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "diffHunk": "@@ -164,14 +164,36 @@ void open() throws IOException\n         }\n     }\n \n-    void registerMultiplexedDeviceClient(List<DeviceClientConfig> configs) throws InterruptedException\n+    // Functionally the same as \"open()\", but without wrapping any thrown TransportException into an IOException\n+    void multiplexingClientOpen() throws TransportException\n     {\n-        this.transport.registerMultiplexedDeviceClient(configs);\n+        try\n+        {\n+            open();\n+        }\n+        catch (IOException e)\n+        {\n+            Throwable cause = e.getCause();\n+            if (cause != null && cause instanceof TransportException)\n+            {\n+                throw (TransportException) cause;\n+            }\n+            else", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "275c8a0aae20744ddbbdeb28fbfaeb43ea078b36"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Nzc3NzI1OnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNzo0NzozN1rOH84qPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNzo0NzozN1rOH84qPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYwNDkyNg==", "bodyText": "same here, no else required", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533604926", "createdAt": "2020-12-01T17:47:37Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "diffHunk": "@@ -251,18 +273,25 @@ public void close() throws IOException\n         }\n     }\n \n-    /**\n-     * Completes all current outstanding requests and closes the IoT Hub client.\n-     * Must be called to terminate the background thread that is sending data to\n-     * IoT Hub. After {@code close()} is called, the IoT Hub client is no longer\n-     *  usable. If the client is already closed, the function shall do nothing.\n-     *\n-     * @throws IOException if the connection to an IoT Hub cannot be closed.\n-     */\n-    public void multiplexClose() throws IOException\n+    // Functionally the same as \"close()\", but without wrapping any thrown TransportException into an IOException\n+    public void multiplexClose() throws TransportException\n     {\n-        // Codes_SRS_DEVICE_IO_12_009: [THe function shall call close().]\n-        close();\n+        try\n+        {\n+            close();\n+        }\n+        catch (IOException e)\n+        {\n+            if (e.getCause() != null && e.getCause() instanceof TransportException)\n+            {\n+                throw (TransportException) e.getCause();\n+            }\n+            else", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "275c8a0aae20744ddbbdeb28fbfaeb43ea078b36"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Nzc5OTc2OnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNzo1MzowOVrOH844Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNzo1MzowOVrOH844Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYwODUwMg==", "bodyText": ":D you don't need the else", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533608502", "createdAt": "2020-12-01T17:53:09Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -127,14 +134,44 @@ else if (receivePeriod == 0) //default builder value for this option, signals th\n      * <p>\n      * If this client is already open, then this method will do nothing.\n      * <p>\n-     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientException If any IO or authentication errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or many of the registered devices failed to authenticate.\n+     * Any devices not found in the map of registration exceptions provided by this exception have registered successfully.\n+     * Even when this is thrown, the AMQPS/AMQPS_WS connection is still open, and other clients may be registered to it.\n      */\n-    public void open() throws IOException\n+    public void open() throws MultiplexingClientException\n     {\n         synchronized (this.operationLock)\n         {\n             log.info(\"Opening multiplexing client\");\n-            this.deviceIO.open();\n+            try\n+            {\n+                this.deviceIO.multiplexingClientOpen();\n+            }\n+            catch (TransportException e)\n+            {\n+                // AMQP layer will throw a TransportException with a nested MultiplexingClientException in some cases. In these\n+                // cases, the wrapping of the MultiplexingClientException is strictly to avoid adding more thrown exception types, and\n+                // no extra context is added into the TransportException layer. Because of that, this layer will strip out the TransportException\n+                // if the TransportException's cause was a MultiplexingClientException.\n+                Throwable cause = e.getCause();\n+                if (cause != null && cause instanceof MultiplexingClientDeviceRegistrationFailedException)\n+                {\n+                    MultiplexingClientDeviceRegistrationFailedException newException =\n+                            new MultiplexingClientDeviceRegistrationFailedException(OPEN_ERROR_MESSAGE, cause);\n+\n+                    // Bring the exceptions map from the cause to the root level exception, so that users don't have to use\n+                    // fields from inner exceptions.\n+                    newException.setRegistrationExceptionsMap(((MultiplexingClientDeviceRegistrationFailedException) cause).getRegistrationExceptions());\n+\n+                    throw newException;\n+                }\n+                else", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "275c8a0aae20744ddbbdeb28fbfaeb43ea078b36"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NzgwNzk1OnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNzo1NToxNlrOH849ZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNzo1NToxNlrOH849ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYwOTgyOA==", "bodyText": "what's the reason behind changing the exception that is thrown here? I am a bit confused", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533609828", "createdAt": "2020-12-01T17:55:16Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -146,19 +183,27 @@ public void open() throws IOException\n      * <p>\n      * Once closed, this client can be re-opened. It will preserve all previously registered device clients.\n      * <p>\n-     * @throws IOException If any exception occurs while closing the connection.\n+     * @throws MultiplexingClientException If any IO errors occur when fulfilling this request.\n      */\n-    public void close() throws IOException\n+    public void close() throws MultiplexingClientException\n     {\n         synchronized (this.operationLock)\n         {\n             log.info(\"Closing multiplexing client\");\n-            for (DeviceClient deviceClient : this.multiplexedDeviceClients.values())\n+\n+            try\n             {\n-                deviceClient.closeFileUpload();\n-            }\n+                for (DeviceClient deviceClient : this.multiplexedDeviceClients.values())\n+                {\n+                    deviceClient.closeFileUpload();\n+                }\n \n-            this.deviceIO.multiplexClose();\n+                this.deviceIO.multiplexClose();\n+            }\n+            catch (TransportException | IOException e)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "275c8a0aae20744ddbbdeb28fbfaeb43ea078b36"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NzgxNTAxOnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNzo1Njo1NlrOH85BtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMjozMjoxNFrOH9Cfag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYxMDkzMg==", "bodyText": "this is why unsigned data types come in handy :D", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533610932", "createdAt": "2020-12-01T17:56:56Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -238,11 +330,62 @@ public void registerDeviceClient(DeviceClient deviceClient) throws InterruptedEx\n      * <p>\n      * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n      * will never be thrown if the multiplexing client is not open yet.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or more devices failed to register. Details for each failure can be found\n+     * in this exception. Any devices not found in the map of registration exceptions provided by this exception have registered successfully.\n+     * @throws com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException If this operation takes longer than the default timeout allows.\n+     * @throws MultiplexingClientException If any other Exception is thrown, it will be nested into this exception.\n      * @param deviceClients The device clients to associate with this multiplexing client.\n      */\n-    public void registerDeviceClients(Iterable<DeviceClient> deviceClients) throws InterruptedException {\n+    public void registerDeviceClients(Iterable<DeviceClient> deviceClients) throws InterruptedException, MultiplexingClientException\n+    {\n+        this.registerDeviceClients(deviceClients, DEFAULT_REGISTRATION_TIMEOUT_MILLISECONDS);\n+    }\n+\n+    /**\n+     * Register device clients to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection.\n+     * <p>\n+     * Up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS} devices can be registered on a multiplexed AMQPS connection,\n+     * and up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS} devices can be registered on a multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then these device clients will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then these device clients will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will asynchronously add each device client to the\n+     * multiplexed connection, and then will block until all registrations have been completed.\n+     * <p>\n+     * Any proxy settings set to the provided device clients will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device clients must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * Each registered device client may have its own retry policy and its own SAS token expiry time, separate from every other registered device client.\n+     * <p>\n+     * The registered device clients must use symmetric key based authentication.\n+     * <p>\n+     * The registered device clients must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If any of these device clients are already registered to this multiplexing client, then then this method will\n+     * not do anything to that particular device client. All other provided device clients will still be registered though.\n+     * <p>\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n+     * will never be thrown if the multiplexing client is not open yet.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or more devices failed to register. Details for each failure can be found\n+     * in this exception. Any devices not found in the map of registration exceptions provided by this exception have registered successfully.\n+     * @throws com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException If this operation takes longer than the provided timeout allows.\n+     * @throws MultiplexingClientException If any other Exception is thrown, it will be nested into this exception.\n+     * @param deviceClients The device clients to associate with this multiplexing client.\n+     * @param timeoutMilliseconds How long (in milliseconds) to let this operation wait for all registrations to complete. If this threshold is passed, a {@link com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException} is thrown.\n+     */\n+    public void registerDeviceClients(Iterable<DeviceClient> deviceClients, long timeoutMilliseconds) throws InterruptedException, MultiplexingClientException\n+    {\n         Objects.requireNonNull(deviceClients);\n \n+        if (timeoutMilliseconds <= 0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "275c8a0aae20744ddbbdeb28fbfaeb43ea078b36"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc2NTk5NA==", "bodyText": "Java 7 and below don't support unsigned ints/longs unfortunately. I love the idea, though!", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533765994", "createdAt": "2020-12-01T22:32:14Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -238,11 +330,62 @@ public void registerDeviceClient(DeviceClient deviceClient) throws InterruptedEx\n      * <p>\n      * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n      * will never be thrown if the multiplexing client is not open yet.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or more devices failed to register. Details for each failure can be found\n+     * in this exception. Any devices not found in the map of registration exceptions provided by this exception have registered successfully.\n+     * @throws com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException If this operation takes longer than the default timeout allows.\n+     * @throws MultiplexingClientException If any other Exception is thrown, it will be nested into this exception.\n      * @param deviceClients The device clients to associate with this multiplexing client.\n      */\n-    public void registerDeviceClients(Iterable<DeviceClient> deviceClients) throws InterruptedException {\n+    public void registerDeviceClients(Iterable<DeviceClient> deviceClients) throws InterruptedException, MultiplexingClientException\n+    {\n+        this.registerDeviceClients(deviceClients, DEFAULT_REGISTRATION_TIMEOUT_MILLISECONDS);\n+    }\n+\n+    /**\n+     * Register device clients to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection.\n+     * <p>\n+     * Up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS} devices can be registered on a multiplexed AMQPS connection,\n+     * and up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS} devices can be registered on a multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then these device clients will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then these device clients will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will asynchronously add each device client to the\n+     * multiplexed connection, and then will block until all registrations have been completed.\n+     * <p>\n+     * Any proxy settings set to the provided device clients will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device clients must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * Each registered device client may have its own retry policy and its own SAS token expiry time, separate from every other registered device client.\n+     * <p>\n+     * The registered device clients must use symmetric key based authentication.\n+     * <p>\n+     * The registered device clients must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If any of these device clients are already registered to this multiplexing client, then then this method will\n+     * not do anything to that particular device client. All other provided device clients will still be registered though.\n+     * <p>\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n+     * will never be thrown if the multiplexing client is not open yet.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or more devices failed to register. Details for each failure can be found\n+     * in this exception. Any devices not found in the map of registration exceptions provided by this exception have registered successfully.\n+     * @throws com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException If this operation takes longer than the provided timeout allows.\n+     * @throws MultiplexingClientException If any other Exception is thrown, it will be nested into this exception.\n+     * @param deviceClients The device clients to associate with this multiplexing client.\n+     * @param timeoutMilliseconds How long (in milliseconds) to let this operation wait for all registrations to complete. If this threshold is passed, a {@link com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException} is thrown.\n+     */\n+    public void registerDeviceClients(Iterable<DeviceClient> deviceClients, long timeoutMilliseconds) throws InterruptedException, MultiplexingClientException\n+    {\n         Objects.requireNonNull(deviceClients);\n \n+        if (timeoutMilliseconds <= 0)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYxMDkzMg=="}, "originalCommit": {"oid": "275c8a0aae20744ddbbdeb28fbfaeb43ea078b36"}, "originalPosition": 228}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NzgyNTc4OnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNzo1OTozM1rOH85IXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNzo1OTozM1rOH85IXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYxMjYzNw==", "bodyText": "Thank you for adding all the javadocs ! awesome !", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533612637", "createdAt": "2020-12-01T17:59:33Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -1,5 +1,8 @@\n package com.microsoft.azure.sdk.iot.device;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "275c8a0aae20744ddbbdeb28fbfaeb43ea078b36"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NzkzODQwOnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxODoyODozMlrOH86OTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxODo1NjoxN1rOH87RBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYzMDU0MA==", "bodyText": "MultiplexingClientDeviceRegistrationFailedException seems a bit long. I think we don't need the word fail in there.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533630540", "createdAt": "2020-12-01T18:28:32Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -127,14 +134,44 @@ else if (receivePeriod == 0) //default builder value for this option, signals th\n      * <p>\n      * If this client is already open, then this method will do nothing.\n      * <p>\n-     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientException If any IO or authentication errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or many of the registered devices failed to authenticate.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "275c8a0aae20744ddbbdeb28fbfaeb43ea078b36"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY0NzYyMQ==", "bodyText": "that doesn't really make it any shorter, but still ...", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533647621", "createdAt": "2020-12-01T18:56:17Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -127,14 +134,44 @@ else if (receivePeriod == 0) //default builder value for this option, signals th\n      * <p>\n      * If this client is already open, then this method will do nothing.\n      * <p>\n-     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientException If any IO or authentication errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or many of the registered devices failed to authenticate.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYzMDU0MA=="}, "originalCommit": {"oid": "275c8a0aae20744ddbbdeb28fbfaeb43ea078b36"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0ODA4OTY2OnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxOTowNzoxNlrOH87rjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMjozMzoxOVrOH9ChWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NDQxNQ==", "bodyText": "could there be any other reason for the device registration to fail? is it only authentication failures that would cause a MultiplexingClientDeviceRegistrationFailedException to be thrwon?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533654415", "createdAt": "2020-12-01T19:07:16Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -127,14 +133,44 @@ else if (receivePeriod == 0) //default builder value for this option, signals th\n      * <p>\n      * If this client is already open, then this method will do nothing.\n      * <p>\n-     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientException If any IO or authentication errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or many of the registered devices failed to authenticate.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6229cb9392395b94c7a04c1282d2d3ccf186619a"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc2NjQ5MQ==", "bodyText": "I think I will rename this particular exception to MultiplexingClientDeviceRegistrationAuthenticationException and if there are other cases when the SDK needs to throw, I can add a new Exception type to cover them. Right now, this exception is only thrown in authentication failure cases.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533766491", "createdAt": "2020-12-01T22:33:19Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -127,14 +133,44 @@ else if (receivePeriod == 0) //default builder value for this option, signals th\n      * <p>\n      * If this client is already open, then this method will do nothing.\n      * <p>\n-     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientException If any IO or authentication errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or many of the registered devices failed to authenticate.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NDQxNQ=="}, "originalCommit": {"oid": "6229cb9392395b94c7a04c1282d2d3ccf186619a"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0ODEwNTA4OnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxOToxMTo1MVrOH871Xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzozMzo1NFrOH9ELHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NjkyNw==", "bodyText": "correct me if I am wrong, but TransportException is not in the MultiplexingClientException hierarchy\nFrom what I can tell, MultiplexingClientException extends Exception and MultiplexingClientDeviceRegistrationFailedException extends MultiplexingClientException so line 157 would not be true ever ! no?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533656927", "createdAt": "2020-12-01T19:11:51Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -127,14 +133,44 @@ else if (receivePeriod == 0) //default builder value for this option, signals th\n      * <p>\n      * If this client is already open, then this method will do nothing.\n      * <p>\n-     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientException If any IO or authentication errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or many of the registered devices failed to authenticate.\n+     * Any devices not found in the map of registration exceptions provided by this exception have registered successfully.\n+     * Even when this is thrown, the AMQPS/AMQPS_WS connection is still open, and other clients may be registered to it.\n      */\n-    public void open() throws IOException\n+    public void open() throws MultiplexingClientException\n     {\n         synchronized (this.operationLock)\n         {\n             log.info(\"Opening multiplexing client\");\n-            this.deviceIO.open();\n+            try\n+            {\n+                this.deviceIO.openWithoutWrappingException();\n+            }\n+            catch (TransportException e)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6229cb9392395b94c7a04c1282d2d3ccf186619a"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc2NzY5Mg==", "bodyText": "Line 157 is checking the nested exception of this caught exception. I did add one special case where the lower layer throws a TransportException with a nested MultiplexingClientDeviceRegistrationAuthenticationException so that we could handle this code path. In particular, it is when you call open after registering your devices.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533767692", "createdAt": "2020-12-01T22:35:39Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -127,14 +133,44 @@ else if (receivePeriod == 0) //default builder value for this option, signals th\n      * <p>\n      * If this client is already open, then this method will do nothing.\n      * <p>\n-     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientException If any IO or authentication errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or many of the registered devices failed to authenticate.\n+     * Any devices not found in the map of registration exceptions provided by this exception have registered successfully.\n+     * Even when this is thrown, the AMQPS/AMQPS_WS connection is still open, and other clients may be registered to it.\n      */\n-    public void open() throws IOException\n+    public void open() throws MultiplexingClientException\n     {\n         synchronized (this.operationLock)\n         {\n             log.info(\"Opening multiplexing client\");\n-            this.deviceIO.open();\n+            try\n+            {\n+                this.deviceIO.openWithoutWrappingException();\n+            }\n+            catch (TransportException e)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NjkyNw=="}, "originalCommit": {"oid": "6229cb9392395b94c7a04c1282d2d3ccf186619a"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5MzU2NQ==", "bodyText": "ah, I totallly missed the fact that you are checking the inner exception", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533793565", "createdAt": "2020-12-01T23:33:54Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -127,14 +133,44 @@ else if (receivePeriod == 0) //default builder value for this option, signals th\n      * <p>\n      * If this client is already open, then this method will do nothing.\n      * <p>\n-     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientException If any IO or authentication errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or many of the registered devices failed to authenticate.\n+     * Any devices not found in the map of registration exceptions provided by this exception have registered successfully.\n+     * Even when this is thrown, the AMQPS/AMQPS_WS connection is still open, and other clients may be registered to it.\n      */\n-    public void open() throws IOException\n+    public void open() throws MultiplexingClientException\n     {\n         synchronized (this.operationLock)\n         {\n             log.info(\"Opening multiplexing client\");\n-            this.deviceIO.open();\n+            try\n+            {\n+                this.deviceIO.openWithoutWrappingException();\n+            }\n+            catch (TransportException e)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NjkyNw=="}, "originalCommit": {"oid": "6229cb9392395b94c7a04c1282d2d3ccf186619a"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0ODExMjQyOnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxOToxNDowOFrOH876Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxOToxNDowOFrOH876Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1ODE3NQ==", "bodyText": "nit: repeatedly calling this method for individual device registrations", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533658175", "createdAt": "2020-12-01T19:14:08Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -200,13 +244,100 @@ public void close() throws IOException\n      * <p>\n      * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n      * will never be thrown if the multiplexing client is not open yet.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or more devices failed to register. Details for each failure can be found\n+     * in this exception.\n+     * @throws com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException If this operation takes longer than the default timeout allows.\n+     * @throws MultiplexingClientException If any other Exception is thrown, it will be nested into this exception.\n      * @param deviceClient The device client to associate with this multiplexing client.\n      */\n-    public void registerDeviceClient(DeviceClient deviceClient) throws InterruptedException {\n+    public void registerDeviceClient(DeviceClient deviceClient) throws InterruptedException, MultiplexingClientException {\n+        this.registerDeviceClient(deviceClient, DEFAULT_REGISTRATION_TIMEOUT_MILLISECONDS);\n+    }\n+\n+    /**\n+     * Register a device client to this multiplexing client. This method may be called before or after opening the\n+     * multiplexed connection.\n+     * <p>\n+     * Users should use {@link #registerDeviceClients(Iterable)} for registering multiple devices as it has some\n+     * performance improvements over repeatedly calling this method. This method blocks on each registration, whereas", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6229cb9392395b94c7a04c1282d2d3ccf186619a"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0ODEyMTM1OnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxOToxNjozOFrOH87_0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMjozODo1NFrOH9CsPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1OTYwMA==", "bodyText": "Q - both of these exception types point towards authentication related errors, what is the difference in the scenarios where they are thrown?\nMultiplexingClientException = while initial open vs MultiplexingClientDeviceRegistrationFailedException = registered but subsequently keys expired?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533659600", "createdAt": "2020-12-01T19:16:38Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -127,14 +134,44 @@ else if (receivePeriod == 0) //default builder value for this option, signals th\n      * <p>\n      * If this client is already open, then this method will do nothing.\n      * <p>\n-     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientException If any IO or authentication errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or many of the registered devices failed to authenticate.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "275c8a0aae20744ddbbdeb28fbfaeb43ea078b36"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc2OTI3Nw==", "bodyText": "MultiplexingClientException is the super type of MultiplexingClientDeviceRegistrationFailedException here. Normally I'd only call out that the method throws the super type, since that is all that Javadocs require, but it felt useful to call out MultiplexingClientDeviceRegistrationFailedException in particular as it can be handled differently from MultiplexingClientException. The more specific exception has a map of deviceId->registration exception that users can read when reacting to such exceptions.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533769277", "createdAt": "2020-12-01T22:38:54Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -127,14 +134,44 @@ else if (receivePeriod == 0) //default builder value for this option, signals th\n      * <p>\n      * If this client is already open, then this method will do nothing.\n      * <p>\n-     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientException If any IO or authentication errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or many of the registered devices failed to authenticate.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1OTYwMA=="}, "originalCommit": {"oid": "275c8a0aae20744ddbbdeb28fbfaeb43ea078b36"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0ODEyNTkyOnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxOToxNzo1M1rOH88CyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMjozOTowOFrOH9Csug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2MDM2MA==", "bodyText": "does com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException need to be fully qualified?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533660360", "createdAt": "2020-12-01T19:17:53Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -200,13 +244,100 @@ public void close() throws IOException\n      * <p>\n      * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n      * will never be thrown if the multiplexing client is not open yet.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or more devices failed to register. Details for each failure can be found\n+     * in this exception.\n+     * @throws com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException If this operation takes longer than the default timeout allows.\n+     * @throws MultiplexingClientException If any other Exception is thrown, it will be nested into this exception.\n      * @param deviceClient The device client to associate with this multiplexing client.\n      */\n-    public void registerDeviceClient(DeviceClient deviceClient) throws InterruptedException {\n+    public void registerDeviceClient(DeviceClient deviceClient) throws InterruptedException, MultiplexingClientException {\n+        this.registerDeviceClient(deviceClient, DEFAULT_REGISTRATION_TIMEOUT_MILLISECONDS);\n+    }\n+\n+    /**\n+     * Register a device client to this multiplexing client. This method may be called before or after opening the\n+     * multiplexed connection.\n+     * <p>\n+     * Users should use {@link #registerDeviceClients(Iterable)} for registering multiple devices as it has some\n+     * performance improvements over repeatedly calling this method. This method blocks on each registration, whereas\n+     * {@link #registerDeviceClients(Iterable)} blocks on all of the registrations after starting them all asynchronously.\n+     * <p>\n+     * Up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS} devices can be registered on a multiplexed AMQPS connection,\n+     * and up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS} devices can be registered on a multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will add this device client to the\n+     * multiplexed connection, and then will block until the registration has been completed.\n+     * <p>\n+     * Any proxy settings set to the provided device clients will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * Each registered device client may have its own retry policy and its own SAS token expiry time, separate from every other registered device client.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If the provided device client is already registered to this multiplexing client, then then this method will do nothing.\n+     * <p>\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n+     * will never be thrown if the multiplexing client is not open yet.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or more devices failed to register. Details for each failure can be found\n+     * in this exception.\n+     * @throws com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException If this operation takes longer than the provided timeout allows.\n+     * @throws MultiplexingClientException If any other Exception is thrown, it will be nested into this exception.\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     * @param timeoutMilliseconds How long (in milliseconds) to let this operation wait for all registrations to complete. If this threshold is passed, a {@link com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException} is thrown.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient, long timeoutMilliseconds) throws InterruptedException, MultiplexingClientException {\n         Objects.requireNonNull(deviceClient);\n         List<DeviceClient> clientList = new ArrayList<>();\n         clientList.add(deviceClient);\n-        registerDeviceClients(clientList);\n+        registerDeviceClients(clientList, timeoutMilliseconds);\n+    }\n+\n+    /**\n+     * Register device clients to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection.\n+     * <p>\n+     * Up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS} devices can be registered on a multiplexed AMQPS connection,\n+     * and up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS} devices can be registered on a multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then these device clients will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then these device clients will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will asynchronously add each device client to the\n+     * multiplexed connection, and then will block until all registrations have been completed.\n+     * <p>\n+     * Any proxy settings set to the provided device clients will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device clients must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * Each registered device client may have its own retry policy and its own SAS token expiry time, separate from every other registered device client.\n+     * <p>\n+     * The registered device clients must use symmetric key based authentication.\n+     * <p>\n+     * The registered device clients must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If any of these device clients are already registered to this multiplexing client, then then this method will\n+     * not do anything to that particular device client. All other provided device clients will still be registered though.\n+     * <p>\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n+     * will never be thrown if the multiplexing client is not open yet.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or more devices failed to register. Details for each failure can be found\n+     * in this exception. Any devices not found in the map of registration exceptions provided by this exception have registered successfully.\n+     * @throws com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException If this operation takes longer than the default timeout allows.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6229cb9392395b94c7a04c1282d2d3ccf186619a"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc2OTQwMg==", "bodyText": "Strangely, yes. I can't figure out why though", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533769402", "createdAt": "2020-12-01T22:39:08Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -200,13 +244,100 @@ public void close() throws IOException\n      * <p>\n      * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n      * will never be thrown if the multiplexing client is not open yet.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or more devices failed to register. Details for each failure can be found\n+     * in this exception.\n+     * @throws com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException If this operation takes longer than the default timeout allows.\n+     * @throws MultiplexingClientException If any other Exception is thrown, it will be nested into this exception.\n      * @param deviceClient The device client to associate with this multiplexing client.\n      */\n-    public void registerDeviceClient(DeviceClient deviceClient) throws InterruptedException {\n+    public void registerDeviceClient(DeviceClient deviceClient) throws InterruptedException, MultiplexingClientException {\n+        this.registerDeviceClient(deviceClient, DEFAULT_REGISTRATION_TIMEOUT_MILLISECONDS);\n+    }\n+\n+    /**\n+     * Register a device client to this multiplexing client. This method may be called before or after opening the\n+     * multiplexed connection.\n+     * <p>\n+     * Users should use {@link #registerDeviceClients(Iterable)} for registering multiple devices as it has some\n+     * performance improvements over repeatedly calling this method. This method blocks on each registration, whereas\n+     * {@link #registerDeviceClients(Iterable)} blocks on all of the registrations after starting them all asynchronously.\n+     * <p>\n+     * Up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS} devices can be registered on a multiplexed AMQPS connection,\n+     * and up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS} devices can be registered on a multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will add this device client to the\n+     * multiplexed connection, and then will block until the registration has been completed.\n+     * <p>\n+     * Any proxy settings set to the provided device clients will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * Each registered device client may have its own retry policy and its own SAS token expiry time, separate from every other registered device client.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If the provided device client is already registered to this multiplexing client, then then this method will do nothing.\n+     * <p>\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n+     * will never be thrown if the multiplexing client is not open yet.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or more devices failed to register. Details for each failure can be found\n+     * in this exception.\n+     * @throws com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException If this operation takes longer than the provided timeout allows.\n+     * @throws MultiplexingClientException If any other Exception is thrown, it will be nested into this exception.\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     * @param timeoutMilliseconds How long (in milliseconds) to let this operation wait for all registrations to complete. If this threshold is passed, a {@link com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException} is thrown.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient, long timeoutMilliseconds) throws InterruptedException, MultiplexingClientException {\n         Objects.requireNonNull(deviceClient);\n         List<DeviceClient> clientList = new ArrayList<>();\n         clientList.add(deviceClient);\n-        registerDeviceClients(clientList);\n+        registerDeviceClients(clientList, timeoutMilliseconds);\n+    }\n+\n+    /**\n+     * Register device clients to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection.\n+     * <p>\n+     * Up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS} devices can be registered on a multiplexed AMQPS connection,\n+     * and up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS} devices can be registered on a multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then these device clients will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then these device clients will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will asynchronously add each device client to the\n+     * multiplexed connection, and then will block until all registrations have been completed.\n+     * <p>\n+     * Any proxy settings set to the provided device clients will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device clients must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * Each registered device client may have its own retry policy and its own SAS token expiry time, separate from every other registered device client.\n+     * <p>\n+     * The registered device clients must use symmetric key based authentication.\n+     * <p>\n+     * The registered device clients must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If any of these device clients are already registered to this multiplexing client, then then this method will\n+     * not do anything to that particular device client. All other provided device clients will still be registered though.\n+     * <p>\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n+     * will never be thrown if the multiplexing client is not open yet.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or more devices failed to register. Details for each failure can be found\n+     * in this exception. Any devices not found in the map of registration exceptions provided by this exception have registered successfully.\n+     * @throws com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException If this operation takes longer than the default timeout allows.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2MDM2MA=="}, "originalCommit": {"oid": "6229cb9392395b94c7a04c1282d2d3ccf186619a"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0ODEzMTc0OnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxOToxOTozMVrOH88Gfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMTo0MTo0OVrOH-1tZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2MTMxMA==", "bodyText": "less or equal? can it be 0?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533661310", "createdAt": "2020-12-01T19:19:31Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -238,11 +369,22 @@ public void registerDeviceClient(DeviceClient deviceClient) throws InterruptedEx\n      * <p>\n      * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n      * will never be thrown if the multiplexing client is not open yet.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or more devices failed to register. Details for each failure can be found\n+     * in this exception. Any devices not found in the map of registration exceptions provided by this exception have registered successfully.\n+     * @throws com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException If this operation takes longer than the provided timeout allows.\n+     * @throws MultiplexingClientException If any other Exception is thrown, it will be nested into this exception.\n      * @param deviceClients The device clients to associate with this multiplexing client.\n+     * @param timeoutMilliseconds How long (in milliseconds) to let this operation wait for all registrations to complete. If this threshold is passed, a {@link com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException} is thrown.\n      */\n-    public void registerDeviceClients(Iterable<DeviceClient> deviceClients) throws InterruptedException {\n+    public void registerDeviceClients(Iterable<DeviceClient> deviceClients, long timeoutMilliseconds) throws InterruptedException, MultiplexingClientException\n+    {\n         Objects.requireNonNull(deviceClients);\n \n+        if (timeoutMilliseconds <= 0)\n+        {\n+            throw new IllegalArgumentException(\"Cannot set a device registration timeout of less than 0 milliseconds\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6229cb9392395b94c7a04c1282d2d3ccf186619a"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc3MDEyMw==", "bodyText": "If we allowed 0, it would immediately throw a timeout exception, which doesn't seem useful. Using HTTP libraries as a model, setting a timeout to 0 usually means \"infinite timeout\" but I don't see a good use case for that when you can just set a really long timeout already.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533770123", "createdAt": "2020-12-01T22:40:30Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -238,11 +369,22 @@ public void registerDeviceClient(DeviceClient deviceClient) throws InterruptedEx\n      * <p>\n      * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n      * will never be thrown if the multiplexing client is not open yet.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or more devices failed to register. Details for each failure can be found\n+     * in this exception. Any devices not found in the map of registration exceptions provided by this exception have registered successfully.\n+     * @throws com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException If this operation takes longer than the provided timeout allows.\n+     * @throws MultiplexingClientException If any other Exception is thrown, it will be nested into this exception.\n      * @param deviceClients The device clients to associate with this multiplexing client.\n+     * @param timeoutMilliseconds How long (in milliseconds) to let this operation wait for all registrations to complete. If this threshold is passed, a {@link com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException} is thrown.\n      */\n-    public void registerDeviceClients(Iterable<DeviceClient> deviceClients) throws InterruptedException {\n+    public void registerDeviceClients(Iterable<DeviceClient> deviceClients, long timeoutMilliseconds) throws InterruptedException, MultiplexingClientException\n+    {\n         Objects.requireNonNull(deviceClients);\n \n+        if (timeoutMilliseconds <= 0)\n+        {\n+            throw new IllegalArgumentException(\"Cannot set a device registration timeout of less than 0 milliseconds\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2MTMxMA=="}, "originalCommit": {"oid": "6229cb9392395b94c7a04c1282d2d3ccf186619a"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgwNTc2NQ==", "bodyText": "I mean it's a technicality issue, the sentence mentions it cannot be less than 0, the user can argue \"it's not, it's 0\" ... so maybe\nCannot set a device registration timeout of 0 milliseconds or less", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533805765", "createdAt": "2020-12-02T00:06:59Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -238,11 +369,22 @@ public void registerDeviceClient(DeviceClient deviceClient) throws InterruptedEx\n      * <p>\n      * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n      * will never be thrown if the multiplexing client is not open yet.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or more devices failed to register. Details for each failure can be found\n+     * in this exception. Any devices not found in the map of registration exceptions provided by this exception have registered successfully.\n+     * @throws com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException If this operation takes longer than the provided timeout allows.\n+     * @throws MultiplexingClientException If any other Exception is thrown, it will be nested into this exception.\n      * @param deviceClients The device clients to associate with this multiplexing client.\n+     * @param timeoutMilliseconds How long (in milliseconds) to let this operation wait for all registrations to complete. If this threshold is passed, a {@link com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException} is thrown.\n      */\n-    public void registerDeviceClients(Iterable<DeviceClient> deviceClients) throws InterruptedException {\n+    public void registerDeviceClients(Iterable<DeviceClient> deviceClients, long timeoutMilliseconds) throws InterruptedException, MultiplexingClientException\n+    {\n         Objects.requireNonNull(deviceClients);\n \n+        if (timeoutMilliseconds <= 0)\n+        {\n+            throw new IllegalArgumentException(\"Cannot set a device registration timeout of less than 0 milliseconds\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2MTMxMA=="}, "originalCommit": {"oid": "6229cb9392395b94c7a04c1282d2d3ccf186619a"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY1MzczMw==", "bodyText": "Oh, good catch, I misunderstood what you were getting at", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r535653733", "createdAt": "2020-12-03T21:41:49Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -238,11 +369,22 @@ public void registerDeviceClient(DeviceClient deviceClient) throws InterruptedEx\n      * <p>\n      * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n      * will never be thrown if the multiplexing client is not open yet.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or more devices failed to register. Details for each failure can be found\n+     * in this exception. Any devices not found in the map of registration exceptions provided by this exception have registered successfully.\n+     * @throws com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException If this operation takes longer than the provided timeout allows.\n+     * @throws MultiplexingClientException If any other Exception is thrown, it will be nested into this exception.\n      * @param deviceClients The device clients to associate with this multiplexing client.\n+     * @param timeoutMilliseconds How long (in milliseconds) to let this operation wait for all registrations to complete. If this threshold is passed, a {@link com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException} is thrown.\n      */\n-    public void registerDeviceClients(Iterable<DeviceClient> deviceClients) throws InterruptedException {\n+    public void registerDeviceClients(Iterable<DeviceClient> deviceClients, long timeoutMilliseconds) throws InterruptedException, MultiplexingClientException\n+    {\n         Objects.requireNonNull(deviceClients);\n \n+        if (timeoutMilliseconds <= 0)\n+        {\n+            throw new IllegalArgumentException(\"Cannot set a device registration timeout of less than 0 milliseconds\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2MTMxMA=="}, "originalCommit": {"oid": "6229cb9392395b94c7a04c1282d2d3ccf186619a"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0ODE0Njc0OnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxOToyMzowN1rOH88PSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxOToyMzowN1rOH88PSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2MzU2Mg==", "bodyText": "nit: maybe add the word multiple at the beginning ...\nUnregister one or many device clients ...", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533663562", "createdAt": "2020-12-01T19:23:07Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -339,13 +481,69 @@ public void registerDeviceClients(Iterable<DeviceClient> deviceClients) throws I\n      * be used in non-multiplexing scenarios or used by the deprecated {@link TransportClient}.\n      * <p>\n      * @param deviceClient The device client to unregister from this multiplexing client.\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the unregistration to succeed.\n+     * @throws com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException If the unregistration takes longer than the default timeout allows.\n+     * @throws MultiplexingClientException If any other Exception is thrown, it will be nested into this exception.\n      */\n-    public void unregisterDeviceClient(DeviceClient deviceClient) throws InterruptedException\n+    public void unregisterDeviceClient(DeviceClient deviceClient) throws InterruptedException, MultiplexingClientException\n+    {\n+        this.unregisterDeviceClient(deviceClient, DEFAULT_UNREGISTRATION_TIMEOUT_MILLISECONDS);\n+    }\n+\n+    /**\n+     * Unregister a device client from this multiplexing client. This method may be called before or after opening the\n+     * multiplexed connection.\n+     * <p>\n+     * Users should use {@link #unregisterDeviceClients(Iterable)} for unregistering multiple devices as it has some\n+     * performance improvements over repeatedly calling this method. This method blocks on each unregistration, whereas\n+     * {@link #registerDeviceClients(Iterable)} blocks on all of the unregistrations after starting them all asynchronously.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will close the AMQP device session associated with\n+     * this device, but it will not close any other registered device sessions or the multiplexing client itself.\n+     * <p>\n+     * If the multiplexed connection is already open, and this call would unregister the last device client,\n+     * the multiplexed connection will remain open. The multiplexed connection can only be closed by calling\n+     * {@link #close()}\n+     * <p>\n+     * Once a device client is unregistered, it may be re-registered to this or any other multiplexing client. It cannot\n+     * be used in non-multiplexing scenarios or used by the deprecated {@link TransportClient}.\n+     * <p>\n+     * @param deviceClient The device client to unregister from this multiplexing client.\n+     * @param timeoutMilliseconds How long (in milliseconds) to let this operation wait for all unregistrations to complete. If this threshold is passed, a {@link com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException} is thrown.\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the unregistration to succeed.\n+     * @throws com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException If the unregistration takes longer than the provided timeout allows.\n+     * @throws MultiplexingClientException If any other Exception is thrown, it will be nested into this exception.\n+     */\n+    public void unregisterDeviceClient(DeviceClient deviceClient, long timeoutMilliseconds) throws InterruptedException, MultiplexingClientException\n     {\n         Objects.requireNonNull(deviceClient);\n         List<DeviceClient> clientList = new ArrayList<>();\n         clientList.add(deviceClient);\n-        unregisterDeviceClients(clientList);\n+        unregisterDeviceClients(clientList, timeoutMilliseconds);\n+    }\n+\n+    /**\n+     * Unregister device clients from this multiplexing client. This method may be called before or after opening the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6229cb9392395b94c7a04c1282d2d3ccf186619a"}, "originalPosition": 285}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0ODE1MjQxOnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/TransportClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxOToyNDo0MFrOH88S0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxOToyMDo1MlrOH-tNQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2NDQ2Nw==", "bodyText": "can you elaborate why you change the exception type here? I am sure you have documented it somewhere in this PR but I am having a hard time following :D", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533664467", "createdAt": "2020-12-01T19:24:40Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/TransportClient.java", "diffHunk": "@@ -110,12 +114,16 @@ public void open() throws IllegalStateException, IOException\n \n             try\n             {\n-                this.deviceIO.registerMultiplexedDeviceClient(configList);\n+                this.deviceIO.registerMultiplexedDeviceClient(configList, DEFAULT_REGISTRATION_TIMEOUT_MILLISECONDS);\n             }\n             catch (InterruptedException e)\n             {\n                 throw new IOException(\"Interrupted while registering device clients to the multiplexed connection\", e);\n             }\n+            catch (MultiplexingClientException e)\n+            {\n+                throw new IOException(\"Failed to register one or more device clients to the multiplexed connection\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6229cb9392395b94c7a04c1282d2d3ccf186619a"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUxNDQzNA==", "bodyText": "probably because of the method signature \"public void open() throws IllegalStateException, IOException\"", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r535514434", "createdAt": "2020-12-03T19:20:52Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/TransportClient.java", "diffHunk": "@@ -110,12 +114,16 @@ public void open() throws IllegalStateException, IOException\n \n             try\n             {\n-                this.deviceIO.registerMultiplexedDeviceClient(configList);\n+                this.deviceIO.registerMultiplexedDeviceClient(configList, DEFAULT_REGISTRATION_TIMEOUT_MILLISECONDS);\n             }\n             catch (InterruptedException e)\n             {\n                 throw new IOException(\"Interrupted while registering device clients to the multiplexed connection\", e);\n             }\n+            catch (MultiplexingClientException e)\n+            {\n+                throw new IOException(\"Failed to register one or more device clients to the multiplexed connection\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2NDQ2Nw=="}, "originalCommit": {"oid": "6229cb9392395b94c7a04c1282d2d3ccf186619a"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0ODE1OTk5OnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/exceptions/MultiplexingClientDeviceRegistrationFailedException.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxOToyNjo0MlrOH88XeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMjo0MzowMFrOH9C0Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2NTY1Nw==", "bodyText": "does this need to be public? who would be able to set it ? I mean whoever it is, should probably use addRegistrationException", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533665657", "createdAt": "2020-12-01T19:26:42Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/exceptions/MultiplexingClientDeviceRegistrationFailedException.java", "diffHunk": "@@ -0,0 +1,85 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.microsoft.azure.sdk.iot.device.exceptions;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Exception that is thrown when one or more devices fail to register to an active multiplexed connection.\n+ */\n+public class MultiplexingClientDeviceRegistrationFailedException extends MultiplexingClientException\n+{\n+    private Map<String, Exception> registrationExceptions = new HashMap<>();\n+\n+    /**\n+     * Construct a new MultiplexingClientDeviceRegistrationFailedException with no nested exception and no error message.\n+     */\n+    public MultiplexingClientDeviceRegistrationFailedException()\n+    {\n+        super();\n+    }\n+\n+    /**\n+     * Construct a new MultiplexingClientDeviceRegistrationFailedException with no nested exception but with an error message.\n+     * @param message The top level message for this exception.\n+     */\n+    public MultiplexingClientDeviceRegistrationFailedException(String message)\n+    {\n+        super(message);\n+    }\n+\n+    /**\n+     * Construct a new MultiplexingClientDeviceRegistrationFailedException with a nested exception and an error message.\n+     * @param message The top level message for this exception.\n+     * @param cause The nested exception.\n+     */\n+    public MultiplexingClientDeviceRegistrationFailedException(String message, Throwable cause)\n+    {\n+        super(message, cause);\n+    }\n+\n+    /**\n+     * Construct a new MultiplexingClientDeviceRegistrationFailedException with a nested exception but no error message.\n+     * @param cause The nested exception.\n+     */\n+    public MultiplexingClientDeviceRegistrationFailedException(Throwable cause)\n+    {\n+        super(cause);\n+    }\n+\n+    /**\n+     * Associate a new registration exception to a device.\n+     * @param deviceId The device that failed to register to an active multiplexed connection.\n+     * @param registrationException The exception that explains why the device failed to register to an active multiplexed connection.\n+     */\n+    public void addRegistrationException(String deviceId, Exception registrationException)\n+    {\n+        Objects.requireNonNull(registrationException, \"registrationException cannot be null\");\n+        if (deviceId == null || deviceId.isEmpty())\n+        {\n+            throw new IllegalArgumentException(\"DeviceId cannot be null or empty\");\n+        }\n+\n+        registrationExceptions.put(deviceId, registrationException);\n+    }\n+\n+    /**\n+     * Get the exception for each device that failed to register.\n+     * @return A map containing the deviceId's that failed to register mapped to the exception that explains why they failed to register.\n+     */\n+    public Map<String, Exception> getRegistrationExceptions() {\n+        return registrationExceptions;\n+    }\n+\n+    /**\n+     * Sets the full registrations exception map. This will overwrite any previously saved mappings.\n+     * @param registrationExceptions the new full registrations exception map.\n+     */\n+    public void setRegistrationExceptionsMap(Map<String, Exception> registrationExceptions)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6229cb9392395b94c7a04c1282d2d3ccf186619a"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc3MTI3MA==", "bodyText": "It is only public because this function is called from the multiplexing client, which sits in a different package from these exceptions. I don't expect customers to call it, but I can't make it private without moving these new exceptions to the base package.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533771270", "createdAt": "2020-12-01T22:43:00Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/exceptions/MultiplexingClientDeviceRegistrationFailedException.java", "diffHunk": "@@ -0,0 +1,85 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.microsoft.azure.sdk.iot.device.exceptions;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Exception that is thrown when one or more devices fail to register to an active multiplexed connection.\n+ */\n+public class MultiplexingClientDeviceRegistrationFailedException extends MultiplexingClientException\n+{\n+    private Map<String, Exception> registrationExceptions = new HashMap<>();\n+\n+    /**\n+     * Construct a new MultiplexingClientDeviceRegistrationFailedException with no nested exception and no error message.\n+     */\n+    public MultiplexingClientDeviceRegistrationFailedException()\n+    {\n+        super();\n+    }\n+\n+    /**\n+     * Construct a new MultiplexingClientDeviceRegistrationFailedException with no nested exception but with an error message.\n+     * @param message The top level message for this exception.\n+     */\n+    public MultiplexingClientDeviceRegistrationFailedException(String message)\n+    {\n+        super(message);\n+    }\n+\n+    /**\n+     * Construct a new MultiplexingClientDeviceRegistrationFailedException with a nested exception and an error message.\n+     * @param message The top level message for this exception.\n+     * @param cause The nested exception.\n+     */\n+    public MultiplexingClientDeviceRegistrationFailedException(String message, Throwable cause)\n+    {\n+        super(message, cause);\n+    }\n+\n+    /**\n+     * Construct a new MultiplexingClientDeviceRegistrationFailedException with a nested exception but no error message.\n+     * @param cause The nested exception.\n+     */\n+    public MultiplexingClientDeviceRegistrationFailedException(Throwable cause)\n+    {\n+        super(cause);\n+    }\n+\n+    /**\n+     * Associate a new registration exception to a device.\n+     * @param deviceId The device that failed to register to an active multiplexed connection.\n+     * @param registrationException The exception that explains why the device failed to register to an active multiplexed connection.\n+     */\n+    public void addRegistrationException(String deviceId, Exception registrationException)\n+    {\n+        Objects.requireNonNull(registrationException, \"registrationException cannot be null\");\n+        if (deviceId == null || deviceId.isEmpty())\n+        {\n+            throw new IllegalArgumentException(\"DeviceId cannot be null or empty\");\n+        }\n+\n+        registrationExceptions.put(deviceId, registrationException);\n+    }\n+\n+    /**\n+     * Get the exception for each device that failed to register.\n+     * @return A map containing the deviceId's that failed to register mapped to the exception that explains why they failed to register.\n+     */\n+    public Map<String, Exception> getRegistrationExceptions() {\n+        return registrationExceptions;\n+    }\n+\n+    /**\n+     * Sets the full registrations exception map. This will overwrite any previously saved mappings.\n+     * @param registrationExceptions the new full registrations exception map.\n+     */\n+    public void setRegistrationExceptionsMap(Map<String, Exception> registrationExceptions)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2NTY1Nw=="}, "originalCommit": {"oid": "6229cb9392395b94c7a04c1282d2d3ccf186619a"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0ODE3MDA3OnYy", "diffSide": "RIGHT", "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexingSample.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxOToyOToyMlrOH88dmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxOToyOToyMlrOH88dmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2NzIyNw==", "bodyText": "Consider delegating this logic to the MultiplexClientManager.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533667227", "createdAt": "2020-12-01T19:29:22Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexingSample.java", "diffHunk": "@@ -102,19 +115,60 @@ public static void main(String[] args)\n \n         System.out.println(\"Opening multiplexed connection\");\n         // All previously registered device clients will be opened alongside this multiplexing client\n-        multiplexClientManager.open();\n+        try\n+        {\n+            multiplexClientManager.open();\n+        }\n+        catch (MultiplexingClientException | IOException e)\n+        {\n+            System.out.println(\"Unexpected exception thrown while opening multiplexed connection, closing client...\");\n+            e.printStackTrace();\n+            multiplexingClient.close();\n+            System.exit(-1);\n+        }\n         System.out.println(\"Multiplexed connection opened successfully\");\n \n         // Note that all the clients are registered at once. This method will asynchronously start the registration\n         // process for each device client, and then it will block until all registrations are complete before returning.\n         // If instead each client was registered separately through multiplexingClient.registerDeviceClient(), it would\n         // take a longer time since it would block on each registration completing, rather than block on all registrations completing\n         System.out.println(\"Registering \" + multiplexedDeviceCount + \" clients to the multiplexing client...\");\n-        multiplexClientManager.registerDeviceClients(multiplexedDeviceClients.values());\n-\n+        try\n+        {\n+            multiplexClientManager.registerDeviceClients(multiplexedDeviceClients.values());\n+        }\n+        catch (MultiplexingClientDeviceRegistrationFailedException e)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6229cb9392395b94c7a04c1282d2d3ccf186619a"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0ODE5MDk4OnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxOTozNDo1MVrOH88qOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMjo0NDoyMlrOH9C2lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY3MDQ1OA==", "bodyText": "MultiplexingClientDeviceRegistrationFailedException doesn't seem to be an instance of TransportException, it looks like it was inherited from Exception directly. Missed, maybe?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533670458", "createdAt": "2020-12-01T19:34:51Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -127,14 +134,44 @@ else if (receivePeriod == 0) //default builder value for this option, signals th\n      * <p>\n      * If this client is already open, then this method will do nothing.\n      * <p>\n-     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientException If any IO or authentication errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or many of the registered devices failed to authenticate.\n+     * Any devices not found in the map of registration exceptions provided by this exception have registered successfully.\n+     * Even when this is thrown, the AMQPS/AMQPS_WS connection is still open, and other clients may be registered to it.\n      */\n-    public void open() throws IOException\n+    public void open() throws MultiplexingClientException\n     {\n         synchronized (this.operationLock)\n         {\n             log.info(\"Opening multiplexing client\");\n-            this.deviceIO.open();\n+            try\n+            {\n+                this.deviceIO.multiplexingClientOpen();\n+            }\n+            catch (TransportException e)\n+            {\n+                // AMQP layer will throw a TransportException with a nested MultiplexingClientException in some cases. In these\n+                // cases, the wrapping of the MultiplexingClientException is strictly to avoid adding more thrown exception types, and\n+                // no extra context is added into the TransportException layer. Because of that, this layer will strip out the TransportException\n+                // if the TransportException's cause was a MultiplexingClientException.\n+                Throwable cause = e.getCause();\n+                if (cause != null && cause instanceof MultiplexingClientDeviceRegistrationFailedException)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "275c8a0aae20744ddbbdeb28fbfaeb43ea078b36"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc3MTkyNQ==", "bodyText": "This case is checking the cause of the thrown exception, not the thrown exception itself. I added one special case in the AMQP layer to throw a TransportException with a nested MultiplexingClientDeviceRegistrationFailedException so that the AMQP layer had a convenient way to report which, if any, devices failed to register.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533771925", "createdAt": "2020-12-01T22:44:22Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -127,14 +134,44 @@ else if (receivePeriod == 0) //default builder value for this option, signals th\n      * <p>\n      * If this client is already open, then this method will do nothing.\n      * <p>\n-     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientException If any IO or authentication errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or many of the registered devices failed to authenticate.\n+     * Any devices not found in the map of registration exceptions provided by this exception have registered successfully.\n+     * Even when this is thrown, the AMQPS/AMQPS_WS connection is still open, and other clients may be registered to it.\n      */\n-    public void open() throws IOException\n+    public void open() throws MultiplexingClientException\n     {\n         synchronized (this.operationLock)\n         {\n             log.info(\"Opening multiplexing client\");\n-            this.deviceIO.open();\n+            try\n+            {\n+                this.deviceIO.multiplexingClientOpen();\n+            }\n+            catch (TransportException e)\n+            {\n+                // AMQP layer will throw a TransportException with a nested MultiplexingClientException in some cases. In these\n+                // cases, the wrapping of the MultiplexingClientException is strictly to avoid adding more thrown exception types, and\n+                // no extra context is added into the TransportException layer. Because of that, this layer will strip out the TransportException\n+                // if the TransportException's cause was a MultiplexingClientException.\n+                Throwable cause = e.getCause();\n+                if (cause != null && cause instanceof MultiplexingClientDeviceRegistrationFailedException)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY3MDQ1OA=="}, "originalCommit": {"oid": "275c8a0aae20744ddbbdeb28fbfaeb43ea078b36"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0ODE5NTI3OnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxOTozNTo1NVrOH88syg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzowNDozNlrOH9Db4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY3MTExNA==", "bodyText": "we are creating a new MultiplexingClientDeviceRegistrationFailedException with an existing MultiplexingClientDeviceRegistrationFailedException? I don't think I get what is happening here, could you explain this bit?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533671114", "createdAt": "2020-12-01T19:35:55Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -127,14 +134,44 @@ else if (receivePeriod == 0) //default builder value for this option, signals th\n      * <p>\n      * If this client is already open, then this method will do nothing.\n      * <p>\n-     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientException If any IO or authentication errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or many of the registered devices failed to authenticate.\n+     * Any devices not found in the map of registration exceptions provided by this exception have registered successfully.\n+     * Even when this is thrown, the AMQPS/AMQPS_WS connection is still open, and other clients may be registered to it.\n      */\n-    public void open() throws IOException\n+    public void open() throws MultiplexingClientException\n     {\n         synchronized (this.operationLock)\n         {\n             log.info(\"Opening multiplexing client\");\n-            this.deviceIO.open();\n+            try\n+            {\n+                this.deviceIO.multiplexingClientOpen();\n+            }\n+            catch (TransportException e)\n+            {\n+                // AMQP layer will throw a TransportException with a nested MultiplexingClientException in some cases. In these\n+                // cases, the wrapping of the MultiplexingClientException is strictly to avoid adding more thrown exception types, and\n+                // no extra context is added into the TransportException layer. Because of that, this layer will strip out the TransportException\n+                // if the TransportException's cause was a MultiplexingClientException.\n+                Throwable cause = e.getCause();\n+                if (cause != null && cause instanceof MultiplexingClientDeviceRegistrationFailedException)\n+                {\n+                    MultiplexingClientDeviceRegistrationFailedException newException =\n+                            new MultiplexingClientDeviceRegistrationFailedException(OPEN_ERROR_MESSAGE, cause);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "275c8a0aae20744ddbbdeb28fbfaeb43ea078b36"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4MTEzNQ==", "bodyText": "I'm going to rework this a little bit. Instead of this design, I'll have a class that extends TransportException but that has the same information as MultiplexingClientDeviceRegistrationFailedException in it. That way this new exception can be caught at this layer instead of catching a cause here.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533781135", "createdAt": "2020-12-01T23:03:51Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -127,14 +134,44 @@ else if (receivePeriod == 0) //default builder value for this option, signals th\n      * <p>\n      * If this client is already open, then this method will do nothing.\n      * <p>\n-     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientException If any IO or authentication errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or many of the registered devices failed to authenticate.\n+     * Any devices not found in the map of registration exceptions provided by this exception have registered successfully.\n+     * Even when this is thrown, the AMQPS/AMQPS_WS connection is still open, and other clients may be registered to it.\n      */\n-    public void open() throws IOException\n+    public void open() throws MultiplexingClientException\n     {\n         synchronized (this.operationLock)\n         {\n             log.info(\"Opening multiplexing client\");\n-            this.deviceIO.open();\n+            try\n+            {\n+                this.deviceIO.multiplexingClientOpen();\n+            }\n+            catch (TransportException e)\n+            {\n+                // AMQP layer will throw a TransportException with a nested MultiplexingClientException in some cases. In these\n+                // cases, the wrapping of the MultiplexingClientException is strictly to avoid adding more thrown exception types, and\n+                // no extra context is added into the TransportException layer. Because of that, this layer will strip out the TransportException\n+                // if the TransportException's cause was a MultiplexingClientException.\n+                Throwable cause = e.getCause();\n+                if (cause != null && cause instanceof MultiplexingClientDeviceRegistrationFailedException)\n+                {\n+                    MultiplexingClientDeviceRegistrationFailedException newException =\n+                            new MultiplexingClientDeviceRegistrationFailedException(OPEN_ERROR_MESSAGE, cause);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY3MTExNA=="}, "originalCommit": {"oid": "275c8a0aae20744ddbbdeb28fbfaeb43ea078b36"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4MTQ3NQ==", "bodyText": "The important thing that I'm striving for here is that the top level exception should contain that map of deviceId -> registration failure exception rather than just having it in a nested exception.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r533781475", "createdAt": "2020-12-01T23:04:36Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -127,14 +134,44 @@ else if (receivePeriod == 0) //default builder value for this option, signals th\n      * <p>\n      * If this client is already open, then this method will do nothing.\n      * <p>\n-     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientException If any IO or authentication errors occur while opening the multiplexed connection.\n+     * @throws MultiplexingClientDeviceRegistrationFailedException If one or many of the registered devices failed to authenticate.\n+     * Any devices not found in the map of registration exceptions provided by this exception have registered successfully.\n+     * Even when this is thrown, the AMQPS/AMQPS_WS connection is still open, and other clients may be registered to it.\n      */\n-    public void open() throws IOException\n+    public void open() throws MultiplexingClientException\n     {\n         synchronized (this.operationLock)\n         {\n             log.info(\"Opening multiplexing client\");\n-            this.deviceIO.open();\n+            try\n+            {\n+                this.deviceIO.multiplexingClientOpen();\n+            }\n+            catch (TransportException e)\n+            {\n+                // AMQP layer will throw a TransportException with a nested MultiplexingClientException in some cases. In these\n+                // cases, the wrapping of the MultiplexingClientException is strictly to avoid adding more thrown exception types, and\n+                // no extra context is added into the TransportException layer. Because of that, this layer will strip out the TransportException\n+                // if the TransportException's cause was a MultiplexingClientException.\n+                Throwable cause = e.getCause();\n+                if (cause != null && cause instanceof MultiplexingClientDeviceRegistrationFailedException)\n+                {\n+                    MultiplexingClientDeviceRegistrationFailedException newException =\n+                            new MultiplexingClientDeviceRegistrationFailedException(OPEN_ERROR_MESSAGE, cause);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY3MTExNA=="}, "originalCommit": {"oid": "275c8a0aae20744ddbbdeb28fbfaeb43ea078b36"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1OTc2OTQ2OnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxOTowMDozNFrOH-saOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMToxNDo0OFrOH-0FxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUwMTM3MQ==", "bodyText": "Q - if we get an IOException here, should we extract the transport exception from the IOException and throw that within the new MultiplexingClientException?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r535501371", "createdAt": "2020-12-03T19:00:34Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -146,19 +178,27 @@ public void open() throws IOException\n      * <p>\n      * Once closed, this client can be re-opened. It will preserve all previously registered device clients.\n      * <p>\n-     * @throws IOException If any exception occurs while closing the connection.\n+     * @throws MultiplexingClientException If any IO errors occur when fulfilling this request.\n      */\n-    public void close() throws IOException\n+    public void close() throws MultiplexingClientException\n     {\n         synchronized (this.operationLock)\n         {\n             log.info(\"Closing multiplexing client\");\n-            for (DeviceClient deviceClient : this.multiplexedDeviceClients.values())\n+\n+            try\n             {\n-                deviceClient.closeFileUpload();\n-            }\n+                for (DeviceClient deviceClient : this.multiplexedDeviceClients.values())\n+                {\n+                    deviceClient.closeFileUpload();\n+                }\n \n-            this.deviceIO.multiplexClose();\n+                this.deviceIO.closeWithoutWrappingException();\n+            }\n+            catch (TransportException | IOException e)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49723c98408c691f66d95c83eb37ac4627cf6e04"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUwMTcyOA==", "bodyText": "To avoid the actual exception info being 2 levels lower", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r535501728", "createdAt": "2020-12-03T19:01:09Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -146,19 +178,27 @@ public void open() throws IOException\n      * <p>\n      * Once closed, this client can be re-opened. It will preserve all previously registered device clients.\n      * <p>\n-     * @throws IOException If any exception occurs while closing the connection.\n+     * @throws MultiplexingClientException If any IO errors occur when fulfilling this request.\n      */\n-    public void close() throws IOException\n+    public void close() throws MultiplexingClientException\n     {\n         synchronized (this.operationLock)\n         {\n             log.info(\"Closing multiplexing client\");\n-            for (DeviceClient deviceClient : this.multiplexedDeviceClients.values())\n+\n+            try\n             {\n-                deviceClient.closeFileUpload();\n-            }\n+                for (DeviceClient deviceClient : this.multiplexedDeviceClients.values())\n+                {\n+                    deviceClient.closeFileUpload();\n+                }\n \n-            this.deviceIO.multiplexClose();\n+                this.deviceIO.closeWithoutWrappingException();\n+            }\n+            catch (TransportException | IOException e)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUwMTM3MQ=="}, "originalCommit": {"oid": "49723c98408c691f66d95c83eb37ac4627cf6e04"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTYyNzIwNA==", "bodyText": "The IOException caught here is only thrown from the closing of the FileUpload code. That code doesn't have nested TransportExceptions, so it should be fine to not try to un-nest this particular exception", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r535627204", "createdAt": "2020-12-03T21:14:48Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -146,19 +178,27 @@ public void open() throws IOException\n      * <p>\n      * Once closed, this client can be re-opened. It will preserve all previously registered device clients.\n      * <p>\n-     * @throws IOException If any exception occurs while closing the connection.\n+     * @throws MultiplexingClientException If any IO errors occur when fulfilling this request.\n      */\n-    public void close() throws IOException\n+    public void close() throws MultiplexingClientException\n     {\n         synchronized (this.operationLock)\n         {\n             log.info(\"Closing multiplexing client\");\n-            for (DeviceClient deviceClient : this.multiplexedDeviceClients.values())\n+\n+            try\n             {\n-                deviceClient.closeFileUpload();\n-            }\n+                for (DeviceClient deviceClient : this.multiplexedDeviceClients.values())\n+                {\n+                    deviceClient.closeFileUpload();\n+                }\n \n-            this.deviceIO.multiplexClose();\n+                this.deviceIO.closeWithoutWrappingException();\n+            }\n+            catch (TransportException | IOException e)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUwMTM3MQ=="}, "originalCommit": {"oid": "49723c98408c691f66d95c83eb37ac4627cf6e04"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1OTc4MjQ5OnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxOTowMzo1OFrOH-siOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMToxNToyNlrOH-0IOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUwMzQxNg==", "bodyText": "Q - \"A device client will not be unregistered automatically if it encounters a non-retryable exception\" - is this statement applicable only during the registration call, or during device operation as well?\ni.e. -> encounter a non-retryable exception during registration vs during sending telemetry.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r535503416", "createdAt": "2020-12-03T19:03:58Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -173,9 +213,61 @@ public void close() throws IOException\n      * multiplexed connection.\n      * <p>\n      * Users should use {@link #registerDeviceClients(Iterable)} for registering multiple devices as it has some\n-     * performance improvements over repeatedly calling this method. This method blocks on each registration, whereas\n+     * performance improvements over repeatedly calling this method for individual device registrations. This method blocks on each registration, whereas\n+     * {@link #registerDeviceClients(Iterable)} blocks on all of the registrations after starting them all asynchronously.\n+     * <p>\n+     * A device client can be unregistered using {@link #unregisterDeviceClient(DeviceClient)}, {@link #unregisterDeviceClient(DeviceClient, long)},\n+     * {@link #unregisterDeviceClients(Iterable)}, or {@link #unregisterDeviceClients(Iterable, long)}. A device client will not be unregistered\n+     * automatically if it encounters a non-retryable exception, so users are responsible for unregistering a device client", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49723c98408c691f66d95c83eb37ac4627cf6e04"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTYyNzgzMg==", "bodyText": "It is applicable at all times. The only time when a device becomes unregistered is when the user calls multiplexingClient.unregister()", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r535627832", "createdAt": "2020-12-03T21:15:26Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -173,9 +213,61 @@ public void close() throws IOException\n      * multiplexed connection.\n      * <p>\n      * Users should use {@link #registerDeviceClients(Iterable)} for registering multiple devices as it has some\n-     * performance improvements over repeatedly calling this method. This method blocks on each registration, whereas\n+     * performance improvements over repeatedly calling this method for individual device registrations. This method blocks on each registration, whereas\n+     * {@link #registerDeviceClients(Iterable)} blocks on all of the registrations after starting them all asynchronously.\n+     * <p>\n+     * A device client can be unregistered using {@link #unregisterDeviceClient(DeviceClient)}, {@link #unregisterDeviceClient(DeviceClient, long)},\n+     * {@link #unregisterDeviceClients(Iterable)}, or {@link #unregisterDeviceClients(Iterable, long)}. A device client will not be unregistered\n+     * automatically if it encounters a non-retryable exception, so users are responsible for unregistering a device client", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUwMzQxNg=="}, "originalCommit": {"oid": "49723c98408c691f66d95c83eb37ac4627cf6e04"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1OTc4NTI5OnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxOTowNDo0NVrOH-sj7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxOTowNDo0NVrOH-sj7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUwMzg1NA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r535503854", "createdAt": "2020-12-03T19:04:45Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -173,9 +213,61 @@ public void close() throws IOException\n      * multiplexed connection.\n      * <p>\n      * Users should use {@link #registerDeviceClients(Iterable)} for registering multiple devices as it has some\n-     * performance improvements over repeatedly calling this method. This method blocks on each registration, whereas\n+     * performance improvements over repeatedly calling this method for individual device registrations. This method blocks on each registration, whereas\n+     * {@link #registerDeviceClients(Iterable)} blocks on all of the registrations after starting them all asynchronously.\n+     * <p>\n+     * A device client can be unregistered using {@link #unregisterDeviceClient(DeviceClient)}, {@link #unregisterDeviceClient(DeviceClient, long)},\n+     * {@link #unregisterDeviceClients(Iterable)}, or {@link #unregisterDeviceClients(Iterable, long)}. A device client will not be unregistered\n+     * automatically if it encounters a non-retryable exception, so users are responsible for unregistering a device client\n+     * when they no longer want it in this multiplexing client.\n+     * <p>\n+     * Up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS} devices can be registered on a multiplexed AMQPS connection,\n+     * and up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS} devices can be registered on a multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49723c98408c691f66d95c83eb37ac4627cf6e04"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1OTc5MzQ2OnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxOTowNjo1NVrOH-so5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMTo0MTo1NlrOH-1t2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUwNTEyNQ==", "bodyText": "q - \"and then will block until the registration has been completed\" -> should this say \"and then will block until the device client has been opened\" instead?\nalso, adding an already opened device client to an opened mux connection will simply add it to the hashmap (or whichever collection is used) and will return immediately, correct?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r535505125", "createdAt": "2020-12-03T19:06:55Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -173,9 +213,61 @@ public void close() throws IOException\n      * multiplexed connection.\n      * <p>\n      * Users should use {@link #registerDeviceClients(Iterable)} for registering multiple devices as it has some\n-     * performance improvements over repeatedly calling this method. This method blocks on each registration, whereas\n+     * performance improvements over repeatedly calling this method for individual device registrations. This method blocks on each registration, whereas\n+     * {@link #registerDeviceClients(Iterable)} blocks on all of the registrations after starting them all asynchronously.\n+     * <p>\n+     * A device client can be unregistered using {@link #unregisterDeviceClient(DeviceClient)}, {@link #unregisterDeviceClient(DeviceClient, long)},\n+     * {@link #unregisterDeviceClients(Iterable)}, or {@link #unregisterDeviceClients(Iterable, long)}. A device client will not be unregistered\n+     * automatically if it encounters a non-retryable exception, so users are responsible for unregistering a device client\n+     * when they no longer want it in this multiplexing client.\n+     * <p>\n+     * Up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS} devices can be registered on a multiplexed AMQPS connection,\n+     * and up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS} devices can be registered on a multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will add this device client to the\n+     * multiplexed connection, and then will block until the registration has been completed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49723c98408c691f66d95c83eb37ac4627cf6e04"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTYzMDA2Mw==", "bodyText": "You can't register a device client that has already been opened, whether it was opened on a different multiplexing client, or just opened as a non-multiplexing client connection.\n\nshould this say \"and then will block until the device client has been opened\"\n\nI'm deliberately trying to use the phrase \"register\" rather than \"open\" in this context since the API itself is called \"registerDeviceClient\"", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r535630063", "createdAt": "2020-12-03T21:17:42Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -173,9 +213,61 @@ public void close() throws IOException\n      * multiplexed connection.\n      * <p>\n      * Users should use {@link #registerDeviceClients(Iterable)} for registering multiple devices as it has some\n-     * performance improvements over repeatedly calling this method. This method blocks on each registration, whereas\n+     * performance improvements over repeatedly calling this method for individual device registrations. This method blocks on each registration, whereas\n+     * {@link #registerDeviceClients(Iterable)} blocks on all of the registrations after starting them all asynchronously.\n+     * <p>\n+     * A device client can be unregistered using {@link #unregisterDeviceClient(DeviceClient)}, {@link #unregisterDeviceClient(DeviceClient, long)},\n+     * {@link #unregisterDeviceClients(Iterable)}, or {@link #unregisterDeviceClients(Iterable, long)}. A device client will not be unregistered\n+     * automatically if it encounters a non-retryable exception, so users are responsible for unregistering a device client\n+     * when they no longer want it in this multiplexing client.\n+     * <p>\n+     * Up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS} devices can be registered on a multiplexed AMQPS connection,\n+     * and up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS} devices can be registered on a multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will add this device client to the\n+     * multiplexed connection, and then will block until the registration has been completed.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUwNTEyNQ=="}, "originalCommit": {"oid": "49723c98408c691f66d95c83eb37ac4627cf6e04"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY1Mzg0OA==", "bodyText": "You can't register a device client that has already been opened, whether it was opened on a different multiplexing client, or just opened as a non-multiplexing client connection.\n\nIs this documented?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r535653848", "createdAt": "2020-12-03T21:41:56Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -173,9 +213,61 @@ public void close() throws IOException\n      * multiplexed connection.\n      * <p>\n      * Users should use {@link #registerDeviceClients(Iterable)} for registering multiple devices as it has some\n-     * performance improvements over repeatedly calling this method. This method blocks on each registration, whereas\n+     * performance improvements over repeatedly calling this method for individual device registrations. This method blocks on each registration, whereas\n+     * {@link #registerDeviceClients(Iterable)} blocks on all of the registrations after starting them all asynchronously.\n+     * <p>\n+     * A device client can be unregistered using {@link #unregisterDeviceClient(DeviceClient)}, {@link #unregisterDeviceClient(DeviceClient, long)},\n+     * {@link #unregisterDeviceClients(Iterable)}, or {@link #unregisterDeviceClients(Iterable, long)}. A device client will not be unregistered\n+     * automatically if it encounters a non-retryable exception, so users are responsible for unregistering a device client\n+     * when they no longer want it in this multiplexing client.\n+     * <p>\n+     * Up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS} devices can be registered on a multiplexed AMQPS connection,\n+     * and up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS} devices can be registered on a multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will add this device client to the\n+     * multiplexed connection, and then will block until the registration has been completed.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUwNTEyNQ=="}, "originalCommit": {"oid": "49723c98408c691f66d95c83eb37ac4627cf6e04"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1OTgyMzAxOnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxOToxNDowMlrOH-s6jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMToyMDoyNlrOH-0bdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUwOTY0Nw==", "bodyText": "Q - unregister will do a graceful close of the transport layer, right? So \"register -> open -> send telemetry -> unregister -> register -> send telemetry\" should be fine?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r535509647", "createdAt": "2020-12-03T19:14:02Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -339,17 +497,49 @@ public void registerDeviceClients(Iterable<DeviceClient> deviceClients) throws I\n      * be used in non-multiplexing scenarios or used by the deprecated {@link TransportClient}.\n      * <p>\n      * @param deviceClient The device client to unregister from this multiplexing client.\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the unregistration to succeed.\n+     * @throws com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException If the unregistration takes longer than the default timeout allows.\n+     * @throws MultiplexingClientException If any other Exception is thrown, it will be nested into this exception.\n      */\n-    public void unregisterDeviceClient(DeviceClient deviceClient) throws InterruptedException\n+    public void unregisterDeviceClient(DeviceClient deviceClient) throws InterruptedException, MultiplexingClientException\n+    {\n+        this.unregisterDeviceClient(deviceClient, DEFAULT_UNREGISTRATION_TIMEOUT_MILLISECONDS);\n+    }\n+\n+    /**\n+     * Unregister a device client from this multiplexing client. This method may be called before or after opening the\n+     * multiplexed connection.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49723c98408c691f66d95c83eb37ac4627cf6e04"}, "originalPosition": 299}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUxMDcwMA==", "bodyText": "On that note, what happens if I call deviceClient.close() but don't unregister the client from the mux connection. Will it just hang around in the connection blocking one position? If I call deviceClient.open() after that, will it be usable again?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r535510700", "createdAt": "2020-12-03T19:15:40Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -339,17 +497,49 @@ public void registerDeviceClients(Iterable<DeviceClient> deviceClients) throws I\n      * be used in non-multiplexing scenarios or used by the deprecated {@link TransportClient}.\n      * <p>\n      * @param deviceClient The device client to unregister from this multiplexing client.\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the unregistration to succeed.\n+     * @throws com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException If the unregistration takes longer than the default timeout allows.\n+     * @throws MultiplexingClientException If any other Exception is thrown, it will be nested into this exception.\n      */\n-    public void unregisterDeviceClient(DeviceClient deviceClient) throws InterruptedException\n+    public void unregisterDeviceClient(DeviceClient deviceClient) throws InterruptedException, MultiplexingClientException\n+    {\n+        this.unregisterDeviceClient(deviceClient, DEFAULT_UNREGISTRATION_TIMEOUT_MILLISECONDS);\n+    }\n+\n+    /**\n+     * Unregister a device client from this multiplexing client. This method may be called before or after opening the\n+     * multiplexed connection.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUwOTY0Nw=="}, "originalCommit": {"oid": "49723c98408c691f66d95c83eb37ac4627cf6e04"}, "originalPosition": 299}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUxMjk5Ng==", "bodyText": "I see this note below: \"It cannot be used in non-multiplexing scenarios\", so will deviceclient.close() throw an exception?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r535512996", "createdAt": "2020-12-03T19:19:24Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -339,17 +497,49 @@ public void registerDeviceClients(Iterable<DeviceClient> deviceClients) throws I\n      * be used in non-multiplexing scenarios or used by the deprecated {@link TransportClient}.\n      * <p>\n      * @param deviceClient The device client to unregister from this multiplexing client.\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the unregistration to succeed.\n+     * @throws com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException If the unregistration takes longer than the default timeout allows.\n+     * @throws MultiplexingClientException If any other Exception is thrown, it will be nested into this exception.\n      */\n-    public void unregisterDeviceClient(DeviceClient deviceClient) throws InterruptedException\n+    public void unregisterDeviceClient(DeviceClient deviceClient) throws InterruptedException, MultiplexingClientException\n+    {\n+        this.unregisterDeviceClient(deviceClient, DEFAULT_UNREGISTRATION_TIMEOUT_MILLISECONDS);\n+    }\n+\n+    /**\n+     * Unregister a device client from this multiplexing client. This method may be called before or after opening the\n+     * multiplexed connection.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUwOTY0Nw=="}, "originalCommit": {"oid": "49723c98408c691f66d95c83eb37ac4627cf6e04"}, "originalPosition": 299}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTYzMTE4OA==", "bodyText": "Q - unregister will do a graceful close of the transport layer, right? So \"register -> open -> send telemetry -> unregister -> register -> send telemetry\" should be fine?\n\nUnregister doesn't close the multiplexing connection, it simply removes the device session associated with that device client. So that flow you outlined will work, yes", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r535631188", "createdAt": "2020-12-03T21:18:52Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -339,17 +497,49 @@ public void registerDeviceClients(Iterable<DeviceClient> deviceClients) throws I\n      * be used in non-multiplexing scenarios or used by the deprecated {@link TransportClient}.\n      * <p>\n      * @param deviceClient The device client to unregister from this multiplexing client.\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the unregistration to succeed.\n+     * @throws com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException If the unregistration takes longer than the default timeout allows.\n+     * @throws MultiplexingClientException If any other Exception is thrown, it will be nested into this exception.\n      */\n-    public void unregisterDeviceClient(DeviceClient deviceClient) throws InterruptedException\n+    public void unregisterDeviceClient(DeviceClient deviceClient) throws InterruptedException, MultiplexingClientException\n+    {\n+        this.unregisterDeviceClient(deviceClient, DEFAULT_UNREGISTRATION_TIMEOUT_MILLISECONDS);\n+    }\n+\n+    /**\n+     * Unregister a device client from this multiplexing client. This method may be called before or after opening the\n+     * multiplexed connection.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUwOTY0Nw=="}, "originalCommit": {"oid": "49723c98408c691f66d95c83eb37ac4627cf6e04"}, "originalPosition": 299}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTYzMjc1Nw==", "bodyText": "On that note, what happens if I call deviceClient.close() but don't unregister the client from the mux connection. Will it just hang around in the connection blocking one position? If I call deviceClient.open() after that, will it be usable again?\n\nI have a special UnsupportedOperationException to prevent users from calling open/close on the device client itself when the client is multiplexed. The only way to open and close a multiplexed client is by registering it/unregistering it\n\nI see this note below: \"It cannot be used in non-multiplexing scenarios\", so will deviceclient.close() throw an exception?\n\nYep. That way users can't mix up if their client is multiplexed or not", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r535632757", "createdAt": "2020-12-03T21:20:26Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -339,17 +497,49 @@ public void registerDeviceClients(Iterable<DeviceClient> deviceClients) throws I\n      * be used in non-multiplexing scenarios or used by the deprecated {@link TransportClient}.\n      * <p>\n      * @param deviceClient The device client to unregister from this multiplexing client.\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the unregistration to succeed.\n+     * @throws com.microsoft.azure.sdk.iot.device.exceptions.MultiplexingClientDeviceRegistrationTimeoutException If the unregistration takes longer than the default timeout allows.\n+     * @throws MultiplexingClientException If any other Exception is thrown, it will be nested into this exception.\n      */\n-    public void unregisterDeviceClient(DeviceClient deviceClient) throws InterruptedException\n+    public void unregisterDeviceClient(DeviceClient deviceClient) throws InterruptedException, MultiplexingClientException\n+    {\n+        this.unregisterDeviceClient(deviceClient, DEFAULT_UNREGISTRATION_TIMEOUT_MILLISECONDS);\n+    }\n+\n+    /**\n+     * Unregister a device client from this multiplexing client. This method may be called before or after opening the\n+     * multiplexed connection.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUwOTY0Nw=="}, "originalCommit": {"oid": "49723c98408c691f66d95c83eb37ac4627cf6e04"}, "originalPosition": 299}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1OTg3MjgxOnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/exceptions/MultiplexingClientDeviceRegistrationTimeoutException.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxOToyMzo0NVrOH-tX0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMToyNDo0OVrOH-0tzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUxNzEzNw==", "bodyText": "q - how detailed is this message/ throwable? does it give any info about which device actually timed out (while opening/ closing)?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r535517137", "createdAt": "2020-12-03T19:23:45Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/exceptions/MultiplexingClientDeviceRegistrationTimeoutException.java", "diffHunk": "@@ -0,0 +1,46 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.microsoft.azure.sdk.iot.device.exceptions;\n+\n+/**\n+ * Exception that is thrown when a multiplexed device client registration or unregistration times out.\n+ */\n+public class MultiplexingClientDeviceRegistrationTimeoutException extends MultiplexingClientException\n+{\n+    /**\n+     * Construct a new MultiplexingClientDeviceRegistrationTimeoutException with no nested exception and no error message.\n+     */\n+    public MultiplexingClientDeviceRegistrationTimeoutException()\n+    {\n+        super();\n+    }\n+\n+    /**\n+     * Construct a new MultiplexingClientDeviceRegistrationTimeoutException with no nested exception but with an error message.\n+     * @param message The top level message for this exception.\n+     */\n+    public MultiplexingClientDeviceRegistrationTimeoutException(String message)\n+    {\n+        super(message);\n+    }\n+\n+    /**\n+     * Construct a new MultiplexingClientDeviceRegistrationTimeoutException with a nested exception and an error message.\n+     * @param message The top level message for this exception.\n+     * @param cause The nested exception.\n+     */\n+    public MultiplexingClientDeviceRegistrationTimeoutException(String message, Throwable cause)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49723c98408c691f66d95c83eb37ac4627cf6e04"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTYzNzQ1Mg==", "bodyText": "The message will be a hardcoded \"Timed out waiting for all device unregistrations to finish.\" and there will not be a nested throwable, at least for now. The only reason I provide overloaded constructors that take throwables is because that is standard for exceptions.\n\ndoes it give any info about which device actually timed out\n\nNo, because this timeout is for all of the device registrations, not per device registration. If a user calls the singular multiplexingClient.registerDeviceClient(), then they will know which client timed out. For the bulk APIs, though, I expect users will just call the API again with the same set of device clients to be registered. The multiplexing client allows for you to \"re-register\" a client or a set of clients without throwing, after all.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r535637452", "createdAt": "2020-12-03T21:24:49Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/exceptions/MultiplexingClientDeviceRegistrationTimeoutException.java", "diffHunk": "@@ -0,0 +1,46 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.microsoft.azure.sdk.iot.device.exceptions;\n+\n+/**\n+ * Exception that is thrown when a multiplexed device client registration or unregistration times out.\n+ */\n+public class MultiplexingClientDeviceRegistrationTimeoutException extends MultiplexingClientException\n+{\n+    /**\n+     * Construct a new MultiplexingClientDeviceRegistrationTimeoutException with no nested exception and no error message.\n+     */\n+    public MultiplexingClientDeviceRegistrationTimeoutException()\n+    {\n+        super();\n+    }\n+\n+    /**\n+     * Construct a new MultiplexingClientDeviceRegistrationTimeoutException with no nested exception but with an error message.\n+     * @param message The top level message for this exception.\n+     */\n+    public MultiplexingClientDeviceRegistrationTimeoutException(String message)\n+    {\n+        super(message);\n+    }\n+\n+    /**\n+     * Construct a new MultiplexingClientDeviceRegistrationTimeoutException with a nested exception and an error message.\n+     * @param message The top level message for this exception.\n+     * @param cause The nested exception.\n+     */\n+    public MultiplexingClientDeviceRegistrationTimeoutException(String message, Throwable cause)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUxNzEzNw=="}, "originalCommit": {"oid": "49723c98408c691f66d95c83eb37ac4627cf6e04"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1OTk1MjczOnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubListener.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxOTozNjo1OFrOH-uGTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxOTozNjo1OFrOH-uGTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUyOTAzNg==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r535529036", "createdAt": "2020-12-03T19:36:58Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubListener.java", "diffHunk": "@@ -56,4 +56,13 @@\n      * @param deviceId the Id of the device that the session belongs to\n      */\n     void onMultiplexedDeviceSessionLost(Throwable e, String connectionId, String deviceId);\n+\n+    /**\n+     * Callback to be fired when the multiplexed connection fails to register a device session.\n+     * @param connectionId the Id of the connection, used to identify which of possible many reconnection attempts", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49723c98408c691f66d95c83eb37ac4627cf6e04"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1OTk2NTMyOnYy", "diffSide": "RIGHT", "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubTransport.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxOTozODo1MFrOH-uNIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMToyNTozN1rOH-0w0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUzMDc4Nw==", "bodyText": "Q - \"connectionId.equals(this.iotHubTransportConnection.getConnectionId())\" is this to avoid the scenario where by the time this callback was fired the client had already initiated a new reconnection attempt?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r535530787", "createdAt": "2020-12-03T19:38:50Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubTransport.java", "diffHunk": "@@ -337,6 +339,15 @@ public void onMultiplexedDeviceSessionLost(Throwable e, String connectionId, Str\n         }\n     }\n \n+    @Override\n+    public void onMultiplexedDeviceSessionRegistrationFailed(String connectionId, String deviceId, Exception e)\n+    {\n+        if (connectionId != null && connectionId.equals(this.iotHubTransportConnection.getConnectionId()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49723c98408c691f66d95c83eb37ac4627cf6e04"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTYzODIyNg==", "bodyText": "Yeah, the IotHubTransport layer may spawn a new AmqpsIotHubConnection instance during retry logic. This connectionId prevents us from logging/retrying errors from old connections that we've moved on from", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/1010#discussion_r535638226", "createdAt": "2020-12-03T21:25:37Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubTransport.java", "diffHunk": "@@ -337,6 +339,15 @@ public void onMultiplexedDeviceSessionLost(Throwable e, String connectionId, Str\n         }\n     }\n \n+    @Override\n+    public void onMultiplexedDeviceSessionRegistrationFailed(String connectionId, String deviceId, Exception e)\n+    {\n+        if (connectionId != null && connectionId.equals(this.iotHubTransportConnection.getConnectionId()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUzMDc4Nw=="}, "originalCommit": {"oid": "49723c98408c691f66d95c83eb37ac4627cf6e04"}, "originalPosition": 16}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2642, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}