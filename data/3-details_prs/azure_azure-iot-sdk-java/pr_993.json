{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIxODE5NzM5", "number": 993, "title": "Multiplexing samples: Device Client Manager and Multiplexing client manager", "bodyText": "With this change, DeviceClientManager objects will be wrapped around device clients to manage the reconnection logic.\nDeviceClientManager and MultiplexingClientManager both extend ClientManagerBase that hold the core reconnection logic.\nAll API calls to the DeviceClientManager and MultiplexingClientManager will be delegated to the client they are wrapping.", "createdAt": "2020-11-16T17:33:19Z", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993", "merged": true, "mergeCommit": {"oid": "c1b7d9684bc0d1108952ff7922a3a46e8dd0c56c"}, "closed": true, "closedAt": "2020-11-30T22:49:30Z", "author": {"login": "azabbasi"}, "timelineItems": {"totalCount": 49, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABddIcefgH2gAyNTIxODE5NzM5OmI5ZWU2N2Y4NmJhNWNmYzM2Y2M4ZjliNDI3Y2U4YjRlOWYwMDlmOTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdhslaAgH2gAyNTIxODE5NzM5OjY3NzRkOGU0OGI4MGI1YTA0ODVkMDk5Nzk2OTQ4NTk2OThjNmFmOTI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b9ee67f86ba5cfc36cc8f9b427ce8b4e9f009f98", "author": {"user": {"login": "azabbasi", "name": "Azad Abbasi"}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/b9ee67f86ba5cfc36cc8f9b427ce8b4e9f009f98", "committedDate": "2020-11-16T17:31:23Z", "message": "Reconnection logic added."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxNTUxMTc5", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-531551179", "createdAt": "2020-11-16T17:34:32Z", "commit": {"oid": "b9ee67f86ba5cfc36cc8f9b427ce8b4e9f009f98"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxNzozNDozM1rOH0J4Zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxNzozNDozM1rOH0J4Zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ0OTg5NQ==", "bodyText": "@timtay-microsoft  , you rightfully mentioned that we shouldn't be using this implementation and there is an out of the box Pair class in java.\nI found javafx.util.Pair implementation ... is that the one you had in mind?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r524449895", "createdAt": "2020-11-16T17:34:33Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9ee67f86ba5cfc36cc8f9b427ce8b4e9f009f98"}, "originalPosition": 3}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4e28a655339273efc8aac13c28a8c7b0c42ec65", "author": {"user": {"login": "azabbasi", "name": "Azad Abbasi"}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/c4e28a655339273efc8aac13c28a8c7b0c42ec65", "committedDate": "2020-11-17T17:24:51Z", "message": "Merge branch 'preview' into azabbasi/multiplexingSamples"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NzExNDY5", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-535711469", "createdAt": "2020-11-20T19:17:22Z", "commit": {"oid": "c4e28a655339273efc8aac13c28a8c7b0c42ec65"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxOToxNzoyM1rOH3drcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxOToxNzoyM1rOH3drcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkxOTk4Ng==", "bodyText": "Don't hardcode \"10\" into this message. Use the value from the variable below, in case we ever change its value", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r527919986", "createdAt": "2020-11-20T19:17:23Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+\n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"Opening the device client instance \" + getClientId() + \" ...\");\n+                        openClient();\n+                        connectionStatus = ConnectionStatus.CONNECTED;\n+                        break;\n+                    }\n+                    catch (Exception ex) {\n+                        if (ex.getCause() instanceof TransportException && ((TransportException) ex.getCause()).isRetryable()) {\n+                            log.warn(\"Transport exception thrown while opening DeviceClient instance \" + getClientId() + \", retrying: \", ex);\n+                        } else {\n+                            log.error(\"Non-retryable exception thrown while opening DeviceClient instance \" + getClientId() + \": \", ex);\n+                            connectionStatus = ConnectionStatus.DISCONNECTED;\n+                            throw ex;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            try {\n+                log.debug(\"Sleeping for 10 secs before attempting another open()\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4e28a655339273efc8aac13c28a8c7b0c42ec65"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NzEyMDYy", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-535712062", "createdAt": "2020-11-20T19:18:20Z", "commit": {"oid": "c4e28a655339273efc8aac13c28a8c7b0c42ec65"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxOToxODoyMVrOH3dtNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxOToxODoyMVrOH3dtNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkyMDQzOQ==", "bodyText": "Since we are using log.debug everywhere else, can you switch these from System.out to log.info or log.debug?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r527920439", "createdAt": "2020-11-20T19:18:21Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+\n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"Opening the device client instance \" + getClientId() + \" ...\");\n+                        openClient();\n+                        connectionStatus = ConnectionStatus.CONNECTED;\n+                        break;\n+                    }\n+                    catch (Exception ex) {\n+                        if (ex.getCause() instanceof TransportException && ((TransportException) ex.getCause()).isRetryable()) {\n+                            log.warn(\"Transport exception thrown while opening DeviceClient instance \" + getClientId() + \", retrying: \", ex);\n+                        } else {\n+                            log.error(\"Non-retryable exception thrown while opening DeviceClient instance \" + getClientId() + \": \", ex);\n+                            connectionStatus = ConnectionStatus.DISCONNECTED;\n+                            throw ex;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            try {\n+                log.debug(\"Sleeping for 10 secs before attempting another open()\");\n+                Thread.sleep(SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS * 1000);\n+            }\n+            catch (InterruptedException ex) {\n+                throw new RuntimeException(\"Interrupted while waiting between attempting to open the client: \", ex);\n+            }\n+        }\n+    }\n+\n+    public void closeNow() {\n+        synchronized (lock) {\n+            try {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException e) {\n+                log.error(\"Exception thrown while closing client instance \" + getClientId() + \" : \", e);\n+            } finally {\n+                connectionStatus = ConnectionStatus.DISCONNECTED;\n+            }\n+        }\n+    }\n+\n+    public void open() throws IOException {\n+        synchronized (lock) {\n+            if(connectionStatus == ConnectionStatus.DISCONNECTED) {\n+                connectionStatus = ConnectionStatus.CONNECTING;\n+            } else {\n+                return;\n+            }\n+        }\n+        doConnect();\n+    }\n+\n+    @Override\n+    public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext) {\n+        Pair<IotHubConnectionStatusChangeCallback, Object> suppliedCallbackPair = this.suppliedConnectionStatusChangeCallback;\n+        if (throwable == null)\n+        {\n+            System.out.println(\"CONNECTION STATUS UPDATE FOR CLIENT: \" + getClientId() + \" - \" + status + \", \" + statusChangeReason);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4e28a655339273efc8aac13c28a8c7b0c42ec65"}, "originalPosition": 109}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NzEzMTg5", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-535713189", "createdAt": "2020-11-20T19:19:58Z", "commit": {"oid": "c4e28a655339273efc8aac13c28a8c7b0c42ec65"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxOToxOTo1OVrOH3dwzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxOToxOTo1OVrOH3dwzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkyMTM1OA==", "bodyText": "Add a header here if only to clarify that the multiplexClientId is user-defined, and isn't some Id like deviceId where they get it from the portal.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r527921358", "createdAt": "2020-11-20T19:19:59Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexClientManager.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.MultiplexingClient;\n+import lombok.experimental.Delegate;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+/**\n+ * This class is in charge of handling reconnection logic and registering callbacks for connection status changes.\n+ * It will delegate all other calls other than `Open`, `Close` and registerConnectionStatusChangeCallbaack to the inner client (MultiplexingClient)\n+ */\n+@Slf4j\n+public class MultiplexClientManager extends ClientManagerBase {\n+\n+    // Define method calls that will not be delegated to the inner client.\n+    private interface DeviceClientNonDelegatedFunction {\n+        void open();\n+        void close();\n+        void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext);\n+    }\n+\n+    // The methods defined in the interface DeviceClientNonDelegatedFunction will be called on MultiplexingClientManager, and not on MultiplexingClient.\n+    @Delegate(excludes = DeviceClientNonDelegatedFunction.class)\n+    private final MultiplexingClient client;\n+    private final String multiplexClientId;\n+\n+    MultiplexClientManager(MultiplexingClient multiplexingClient, String multiplexClientId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4e28a655339273efc8aac13c28a8c7b0c42ec65"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NzE1MDEy", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-535715012", "createdAt": "2020-11-20T19:22:53Z", "commit": {"oid": "c4e28a655339273efc8aac13c28a8c7b0c42ec65"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2", "author": {"user": {"login": "azabbasi", "name": "Azad Abbasi"}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2", "committedDate": "2020-11-23T17:47:58Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NzMwNTEz", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-536730513", "createdAt": "2020-11-23T18:14:47Z", "commit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxODoxNDo0N1rOH4ZuYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxODoxNDo0N1rOH4ZuYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkwMzc3Ng==", "bodyText": "I'd suggest swapping this condition to handle the positive case first", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528903776", "createdAt": "2020-11-23T18:14:47Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NzMwNzU4", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-536730758", "createdAt": "2020-11-23T18:15:06Z", "commit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxODoxNTowN1rOH4ZvNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxODoxNTowN1rOH4ZvNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkwMzk4OQ==", "bodyText": "space after if", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528903989", "createdAt": "2020-11-23T18:15:07Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NzMxNzk2", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-536731796", "createdAt": "2020-11-23T18:16:33Z", "commit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxODoxNjozM1rOH4ZyZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxODoxNjozM1rOH4ZyZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkwNDgwNQ==", "bodyText": "Is openClient() synchronous, such that after it completes we can be sure we're connected?\nShouldn't we wait for a callback that says we're connected to change this internally tracked state to connected?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528904805", "createdAt": "2020-11-23T18:16:33Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"Opening the device client instance \" + getClientId() + \" ...\");\n+                        openClient();\n+                        connectionStatus = ConnectionStatus.CONNECTED;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NzQ4OTI2", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-536748926", "createdAt": "2020-11-23T18:40:47Z", "commit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxODo0MDo0N1rOH4anBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxODo0MDo0N1rOH4anBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkxODI3Nw==", "bodyText": "Suggest changing this to != connecting, and return, so the remaining code doesn't have to be tabbed in 1 more", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528918277", "createdAt": "2020-11-23T18:40:47Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NzQ5NTc4", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-536749578", "createdAt": "2020-11-23T18:41:44Z", "commit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxODo0MTo0NVrOH4apFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxODo0MTo0NVrOH4apFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkxODgwNw==", "bodyText": "Why is locking not necessary here when changing this state but is elsewhere?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528918807", "createdAt": "2020-11-23T18:41:45Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"Opening the device client instance \" + getClientId() + \" ...\");\n+                        openClient();\n+                        connectionStatus = ConnectionStatus.CONNECTED;\n+                        break;\n+                    }\n+                    catch (Exception ex) {\n+                        if (ex.getCause() instanceof TransportException && ((TransportException) ex.getCause()).isRetryable()) {\n+                            log.warn(\"Transport exception thrown while opening DeviceClient instance \" + getClientId() + \", retrying: \", ex);\n+                        } else {\n+                            log.error(\"Non-retryable exception thrown while opening DeviceClient instance \" + getClientId() + \": \", ex);\n+                            connectionStatus = ConnectionStatus.DISCONNECTED;\n+                            throw ex;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            try {\n+                log.debug(\"Sleeping for \" + SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS + \" secs before attempting another open()\");\n+                Thread.sleep(SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS * 1000);\n+            }\n+            catch (InterruptedException ex) {\n+                throw new RuntimeException(\"Interrupted while waiting between attempting to open the client: \", ex);\n+            }\n+        }\n+    }\n+\n+    public void closeNow() {\n+        synchronized (lock) {\n+            try {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException e) {\n+                log.error(\"Exception thrown while closing client instance \" + getClientId() + \" : \", e);\n+            } finally {\n+                connectionStatus = ConnectionStatus.DISCONNECTED;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "originalPosition": 88}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NzUyNzAz", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-536752703", "createdAt": "2020-11-23T18:46:16Z", "commit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxODo0NjoxNlrOH4ayvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxODo0NjoxNlrOH4ayvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyMTI3Ng==", "bodyText": "very inconsistent brace usage in this file", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528921276", "createdAt": "2020-11-23T18:46:16Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"Opening the device client instance \" + getClientId() + \" ...\");\n+                        openClient();\n+                        connectionStatus = ConnectionStatus.CONNECTED;\n+                        break;\n+                    }\n+                    catch (Exception ex) {\n+                        if (ex.getCause() instanceof TransportException && ((TransportException) ex.getCause()).isRetryable()) {\n+                            log.warn(\"Transport exception thrown while opening DeviceClient instance \" + getClientId() + \", retrying: \", ex);\n+                        } else {\n+                            log.error(\"Non-retryable exception thrown while opening DeviceClient instance \" + getClientId() + \": \", ex);\n+                            connectionStatus = ConnectionStatus.DISCONNECTED;\n+                            throw ex;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            try {\n+                log.debug(\"Sleeping for \" + SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS + \" secs before attempting another open()\");\n+                Thread.sleep(SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS * 1000);\n+            }\n+            catch (InterruptedException ex) {\n+                throw new RuntimeException(\"Interrupted while waiting between attempting to open the client: \", ex);\n+            }\n+        }\n+    }\n+\n+    public void closeNow() {\n+        synchronized (lock) {\n+            try {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException e) {\n+                log.error(\"Exception thrown while closing client instance \" + getClientId() + \" : \", e);\n+            } finally {\n+                connectionStatus = ConnectionStatus.DISCONNECTED;\n+            }\n+        }\n+    }\n+\n+    public void open() throws IOException {\n+        synchronized (lock) {\n+            if(connectionStatus == ConnectionStatus.DISCONNECTED) {\n+                connectionStatus = ConnectionStatus.CONNECTING;\n+            } else {\n+                return;\n+            }\n+        }\n+        doConnect();\n+    }\n+\n+    @Override\n+    public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext) {\n+        Pair<IotHubConnectionStatusChangeCallback, Object> suppliedCallbackPair = this.suppliedConnectionStatusChangeCallback;\n+        if (throwable == null)\n+        {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "originalPosition": 108}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NzU4NDY5", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-536758469", "createdAt": "2020-11-23T18:54:48Z", "commit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxODo1NDo0OFrOH4bFWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxODo1NDo0OFrOH4bFWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyNjA0MA==", "bodyText": "lastKnownConnectionStatus?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528926040", "createdAt": "2020-11-23T18:54:48Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NzYwMzYy", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-536760362", "createdAt": "2020-11-23T18:57:25Z", "commit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxODo1NzoyNlrOH4bLSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxODo1NzoyNlrOH4bLSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyNzU2Mw==", "bodyText": "It doesn't handle that state. It detects that state, right?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528927563", "createdAt": "2020-11-23T18:57:26Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"Opening the device client instance \" + getClientId() + \" ...\");\n+                        openClient();\n+                        connectionStatus = ConnectionStatus.CONNECTED;\n+                        break;\n+                    }\n+                    catch (Exception ex) {\n+                        if (ex.getCause() instanceof TransportException && ((TransportException) ex.getCause()).isRetryable()) {\n+                            log.warn(\"Transport exception thrown while opening DeviceClient instance \" + getClientId() + \", retrying: \", ex);\n+                        } else {\n+                            log.error(\"Non-retryable exception thrown while opening DeviceClient instance \" + getClientId() + \": \", ex);\n+                            connectionStatus = ConnectionStatus.DISCONNECTED;\n+                            throw ex;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            try {\n+                log.debug(\"Sleeping for \" + SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS + \" secs before attempting another open()\");\n+                Thread.sleep(SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS * 1000);\n+            }\n+            catch (InterruptedException ex) {\n+                throw new RuntimeException(\"Interrupted while waiting between attempting to open the client: \", ex);\n+            }\n+        }\n+    }\n+\n+    public void closeNow() {\n+        synchronized (lock) {\n+            try {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException e) {\n+                log.error(\"Exception thrown while closing client instance \" + getClientId() + \" : \", e);\n+            } finally {\n+                connectionStatus = ConnectionStatus.DISCONNECTED;\n+            }\n+        }\n+    }\n+\n+    public void open() throws IOException {\n+        synchronized (lock) {\n+            if(connectionStatus == ConnectionStatus.DISCONNECTED) {\n+                connectionStatus = ConnectionStatus.CONNECTING;\n+            } else {\n+                return;\n+            }\n+        }\n+        doConnect();\n+    }\n+\n+    @Override\n+    public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext) {\n+        Pair<IotHubConnectionStatusChangeCallback, Object> suppliedCallbackPair = this.suppliedConnectionStatusChangeCallback;\n+        if (throwable == null)\n+        {\n+            log.info(\"CONNECTION STATUS UPDATE FOR CLIENT: \" + getClientId() + \" - \" + status + \", \" + statusChangeReason);\n+        }\n+        else\n+        {\n+            log.info(\"CONNECTION STATUS UPDATE FOR CLIENT: \" + getClientId() + \" - \" + status + \", \" + statusChangeReason + \", \" + throwable.getMessage());\n+            throwable.printStackTrace();\n+        }\n+\n+        if (shouldDeviceReconnect(status, statusChangeReason, throwable)) {\n+            if (suppliedCallbackPair != null) {\n+                suppliedCallbackPair.getKey().execute(DISCONNECTED_RETRYING, NO_NETWORK, throwable, suppliedCallbackPair.getValue());\n+            }\n+\n+            handleRecoverableDisconnection();\n+        } else if (suppliedCallbackPair != null) {\n+            suppliedCallbackPair.getKey().execute(status, statusChangeReason, throwable, suppliedCallbackPair.getValue());\n+        }\n+    }\n+\n+    // This handles the state where the DeviceClient reports that OperationTimeout has expired, and stops retrying; even though the applied RetryPolicy is still valid.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "originalPosition": 128}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NzYwODM4", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-536760838", "createdAt": "2020-11-23T18:58:05Z", "commit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxODo1ODowNlrOH4bMwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxODo1ODowNlrOH4bMwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyNzkzOA==", "bodyText": "Given this is a sample and that the task is complex, it is going to need way more code comments.\nI'd like to see high level approach, and then for each method how it fits into the larger picture.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528927938", "createdAt": "2020-11-23T18:58:06Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NzYxMzY0", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-536761364", "createdAt": "2020-11-23T18:58:50Z", "commit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxODo1ODo1MFrOH4bOWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxODo1ODo1MFrOH4bOWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyODM0Nw==", "bodyText": "Does Java share this antipattern with C#? That is, throw ex; vs throw;?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528928347", "createdAt": "2020-11-23T18:58:50Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"Opening the device client instance \" + getClientId() + \" ...\");\n+                        openClient();\n+                        connectionStatus = ConnectionStatus.CONNECTED;\n+                        break;\n+                    }\n+                    catch (Exception ex) {\n+                        if (ex.getCause() instanceof TransportException && ((TransportException) ex.getCause()).isRetryable()) {\n+                            log.warn(\"Transport exception thrown while opening DeviceClient instance \" + getClientId() + \", retrying: \", ex);\n+                        } else {\n+                            log.error(\"Non-retryable exception thrown while opening DeviceClient instance \" + getClientId() + \": \", ex);\n+                            connectionStatus = ConnectionStatus.DISCONNECTED;\n+                            throw ex;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "originalPosition": 63}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NzYyNTE0", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-536762514", "createdAt": "2020-11-23T19:00:34Z", "commit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOTowMDozNVrOH4bR-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOTowMDozNVrOH4bR-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyOTI3Mg==", "bodyText": "Again, I think this would read easier if it was formatted as:\nsynchronized (lock) {\n    if (connectionStatus != ConnectionStatus.DISCONNECTED) {\n        return;\n    }\n\n    connectionStatus = ConnectionStatus.CONNECTING;\n}\n\ndoConnect();", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528929272", "createdAt": "2020-11-23T19:00:35Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"Opening the device client instance \" + getClientId() + \" ...\");\n+                        openClient();\n+                        connectionStatus = ConnectionStatus.CONNECTED;\n+                        break;\n+                    }\n+                    catch (Exception ex) {\n+                        if (ex.getCause() instanceof TransportException && ((TransportException) ex.getCause()).isRetryable()) {\n+                            log.warn(\"Transport exception thrown while opening DeviceClient instance \" + getClientId() + \", retrying: \", ex);\n+                        } else {\n+                            log.error(\"Non-retryable exception thrown while opening DeviceClient instance \" + getClientId() + \": \", ex);\n+                            connectionStatus = ConnectionStatus.DISCONNECTED;\n+                            throw ex;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            try {\n+                log.debug(\"Sleeping for \" + SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS + \" secs before attempting another open()\");\n+                Thread.sleep(SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS * 1000);\n+            }\n+            catch (InterruptedException ex) {\n+                throw new RuntimeException(\"Interrupted while waiting between attempting to open the client: \", ex);\n+            }\n+        }\n+    }\n+\n+    public void closeNow() {\n+        synchronized (lock) {\n+            try {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException e) {\n+                log.error(\"Exception thrown while closing client instance \" + getClientId() + \" : \", e);\n+            } finally {\n+                connectionStatus = ConnectionStatus.DISCONNECTED;\n+            }\n+        }\n+    }\n+\n+    public void open() throws IOException {\n+        synchronized (lock) {\n+            if(connectionStatus == ConnectionStatus.DISCONNECTED) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "originalPosition": 95}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NzcyMDk1", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-536772095", "createdAt": "2020-11-23T19:15:07Z", "commit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOToxNTowN1rOH4bxgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOToxNTowN1rOH4bxgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkzNzM0NA==", "bodyText": "callback is 1 word", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528937344", "createdAt": "2020-11-23T19:15:07Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2Nzc0MTky", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-536774192", "createdAt": "2020-11-23T19:18:14Z", "commit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOToxODoxNVrOH4b4cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOToxODoxNVrOH4b4cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkzOTEyMA==", "bodyText": "Perhaps this belongs on the client wrapper classes we have?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528939120", "createdAt": "2020-11-23T19:18:15Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexingSample.java", "diffHunk": "@@ -193,22 +122,34 @@ public static void main(String[] args)\n         String deviceIdToUnregister = deviceIds.get(0);\n \n         System.out.println(\"Unregistering device \" + deviceIdToUnregister + \" from multiplexed connection...\");\n-        multiplexingClient.unregisterDeviceClient(multiplexedDeviceClients.get(deviceIdToUnregister));\n+        multiplexClientManager.unregisterDeviceClient(multiplexedDeviceClients.get(deviceIdToUnregister));\n         System.out.println(\"Successfully unregistered device \" + deviceIdToUnregister + \" from an active multiplexed connection.\");\n \n         // This code demonstrates how to add a device to an active multiplexed connection without shutting down\n         // the whole multiplexed connection or any of the other devices.\n         System.out.println(\"Re-registering device \" + deviceIdToUnregister + \" to an active multiplexed connection...\");\n-        multiplexingClient.registerDeviceClient(multiplexedDeviceClients.get(deviceIdToUnregister));\n+        multiplexClientManager.registerDeviceClient(multiplexedDeviceClients.get(deviceIdToUnregister));\n         System.out.println(\"Successfully registered \" + deviceIdToUnregister + \" to an active multiplexed connection\");\n \n         // Before closing a multiplexing client, you do not need to unregister all of the registered clients.\n         // If they are not unregistered, then you can re-open the multiplexing client later and it will still\n         // have all of your registered devices\n-\n         System.out.println(\"Closing entire multiplexed connection...\");\n         // This call will close all multiplexed device client instances as well\n-        multiplexingClient.close();\n+        multiplexClientManager.closeClient();\n         System.out.println(\"Successfully closed the multiplexed connection\");\n+\n+        System.out.println(\"Shutting down...\");\n+    }\n+\n+    private static int acknowledgedSentMessages = 0;\n+    private static class TelemetryAcknowledgedEventCallback implements IotHubEventCallback", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "originalPosition": 205}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2Nzc1MzA1", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-536775305", "createdAt": "2020-11-23T19:20:00Z", "commit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOToyMDowMFrOH4b8MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOToyMDowMFrOH4b8MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0MDA4MA==", "bodyText": "Where is this used?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528940080", "createdAt": "2020-11-23T19:20:00Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexClientManager.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.MultiplexingClient;\n+import lombok.experimental.Delegate;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+/**\n+ * This class is in charge of handling reconnection logic and registering callbacks for connection status changes.\n+ * It will delegate all other calls other than `Open`, `Close` and registerConnectionStatusChangeCallbaack to the inner client (MultiplexingClient)\n+ */\n+@Slf4j\n+public class MultiplexClientManager extends ClientManagerBase {\n+\n+    // Define method calls that will not be delegated to the inner client.\n+    private interface DeviceClientNonDelegatedFunction {\n+        void open();\n+        void close();\n+        void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext);\n+    }\n+\n+    // The methods defined in the interface DeviceClientNonDelegatedFunction will be called on MultiplexingClientManager, and not on MultiplexingClient.\n+    @Delegate(excludes = DeviceClientNonDelegatedFunction.class)\n+    private final MultiplexingClient client;\n+    private final String multiplexClientId;\n+\n+    /**\n+     * Creates an instance of the MultiplexClientManager\n+     *\n+     * @param multiplexingClient the multiplexing client\n+     * @param multiplexClientId user defined Id for the multiplexing client.\n+     */\n+    MultiplexClientManager(MultiplexingClient multiplexingClient, String multiplexClientId) {\n+        this.connectionStatus = ConnectionStatus.DISCONNECTED;\n+        this.client = multiplexingClient;\n+        this.multiplexClientId = multiplexClientId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2Nzc2Njgw", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-536776680", "createdAt": "2020-11-23T19:22:04Z", "commit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOToyMjowNFrOH4cAdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOToyMjowNFrOH4cAdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0MTE3Mw==", "bodyText": "Why wouldn't this be set to DISCONNECTED?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528941173", "createdAt": "2020-11-23T19:22:04Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"Opening the device client instance \" + getClientId() + \" ...\");\n+                        openClient();\n+                        connectionStatus = ConnectionStatus.CONNECTED;\n+                        break;\n+                    }\n+                    catch (Exception ex) {\n+                        if (ex.getCause() instanceof TransportException && ((TransportException) ex.getCause()).isRetryable()) {\n+                            log.warn(\"Transport exception thrown while opening DeviceClient instance \" + getClientId() + \", retrying: \", ex);\n+                        } else {\n+                            log.error(\"Non-retryable exception thrown while opening DeviceClient instance \" + getClientId() + \": \", ex);\n+                            connectionStatus = ConnectionStatus.DISCONNECTED;\n+                            throw ex;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            try {\n+                log.debug(\"Sleeping for \" + SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS + \" secs before attempting another open()\");\n+                Thread.sleep(SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS * 1000);\n+            }\n+            catch (InterruptedException ex) {\n+                throw new RuntimeException(\"Interrupted while waiting between attempting to open the client: \", ex);\n+            }\n+        }\n+    }\n+\n+    public void closeNow() {\n+        synchronized (lock) {\n+            try {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException e) {\n+                log.error(\"Exception thrown while closing client instance \" + getClientId() + \" : \", e);\n+            } finally {\n+                connectionStatus = ConnectionStatus.DISCONNECTED;\n+            }\n+        }\n+    }\n+\n+    public void open() throws IOException {\n+        synchronized (lock) {\n+            if(connectionStatus == ConnectionStatus.DISCONNECTED) {\n+                connectionStatus = ConnectionStatus.CONNECTING;\n+            } else {\n+                return;\n+            }\n+        }\n+        doConnect();\n+    }\n+\n+    @Override\n+    public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext) {\n+        Pair<IotHubConnectionStatusChangeCallback, Object> suppliedCallbackPair = this.suppliedConnectionStatusChangeCallback;\n+        if (throwable == null)\n+        {\n+            log.info(\"CONNECTION STATUS UPDATE FOR CLIENT: \" + getClientId() + \" - \" + status + \", \" + statusChangeReason);\n+        }\n+        else\n+        {\n+            log.info(\"CONNECTION STATUS UPDATE FOR CLIENT: \" + getClientId() + \" - \" + status + \", \" + statusChangeReason + \", \" + throwable.getMessage());\n+            throwable.printStackTrace();\n+        }\n+\n+        if (shouldDeviceReconnect(status, statusChangeReason, throwable)) {\n+            if (suppliedCallbackPair != null) {\n+                suppliedCallbackPair.getKey().execute(DISCONNECTED_RETRYING, NO_NETWORK, throwable, suppliedCallbackPair.getValue());\n+            }\n+\n+            handleRecoverableDisconnection();\n+        } else if (suppliedCallbackPair != null) {\n+            suppliedCallbackPair.getKey().execute(status, statusChangeReason, throwable, suppliedCallbackPair.getValue());\n+        }\n+    }\n+\n+    // This handles the state where the DeviceClient reports that OperationTimeout has expired, and stops retrying; even though the applied RetryPolicy is still valid.\n+    protected boolean shouldDeviceReconnect(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable) {\n+        return (status == DISCONNECTED && statusChangeReason == RETRY_EXPIRED && throwable instanceof DeviceOperationTimeoutException);\n+    }\n+\n+    public void handleRecoverableDisconnection() {\n+        synchronized (lock) {\n+            if (connectionStatus == ConnectionStatus.CONNECTED) {\n+                new Thread(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        log.debug(\"Attempting reconnect for client: \" + getClientId() + \" ...\");\n+                        synchronized (lock) {\n+                            if (connectionStatus == ConnectionStatus.CONNECTED) {\n+                                try {\n+                                    closeClient();\n+                                } catch (Exception e) {\n+                                    log.warn(\"Client \" + getClientId() + \" closeNow failed.\", e);\n+                                } finally {\n+                                    connectionStatus = ConnectionStatus.CONNECTING;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "originalPosition": 147}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2Nzc3NzYw", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-536777760", "createdAt": "2020-11-23T19:23:42Z", "commit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOToyMzo0MlrOH4cDkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOToyMzo0MlrOH4cDkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0MTk3MQ==", "bodyText": "Any reason not to use the same exception variable name throughout? We have ex and e in some places.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528941971", "createdAt": "2020-11-23T19:23:42Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"Opening the device client instance \" + getClientId() + \" ...\");\n+                        openClient();\n+                        connectionStatus = ConnectionStatus.CONNECTED;\n+                        break;\n+                    }\n+                    catch (Exception ex) {\n+                        if (ex.getCause() instanceof TransportException && ((TransportException) ex.getCause()).isRetryable()) {\n+                            log.warn(\"Transport exception thrown while opening DeviceClient instance \" + getClientId() + \", retrying: \", ex);\n+                        } else {\n+                            log.error(\"Non-retryable exception thrown while opening DeviceClient instance \" + getClientId() + \": \", ex);\n+                            connectionStatus = ConnectionStatus.DISCONNECTED;\n+                            throw ex;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            try {\n+                log.debug(\"Sleeping for \" + SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS + \" secs before attempting another open()\");\n+                Thread.sleep(SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS * 1000);\n+            }\n+            catch (InterruptedException ex) {\n+                throw new RuntimeException(\"Interrupted while waiting between attempting to open the client: \", ex);\n+            }\n+        }\n+    }\n+\n+    public void closeNow() {\n+        synchronized (lock) {\n+            try {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2Nzc4ODcw", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-536778870", "createdAt": "2020-11-23T19:25:17Z", "commit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOToyNToxOFrOH4cHiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOToyNToxOFrOH4cHiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0Mjk4NQ==", "bodyText": "The class comment says this is the base class for device and multiplexing manager clients, but this comment mentions the device client.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528942985", "createdAt": "2020-11-23T19:25:18Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"Opening the device client instance \" + getClientId() + \" ...\");\n+                        openClient();\n+                        connectionStatus = ConnectionStatus.CONNECTED;\n+                        break;\n+                    }\n+                    catch (Exception ex) {\n+                        if (ex.getCause() instanceof TransportException && ((TransportException) ex.getCause()).isRetryable()) {\n+                            log.warn(\"Transport exception thrown while opening DeviceClient instance \" + getClientId() + \", retrying: \", ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NzgwNjU2", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-536780656", "createdAt": "2020-11-23T19:27:52Z", "commit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOToyNzo1MlrOH4cNWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOToyNzo1MlrOH4cNWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0NDQ3NQ==", "bodyText": "How might/should the multiplexing connection status callback calls (where the status is disconnected_retrying) affect the device client manager statuses? They may still think they are connected, but they aren't. Or are they getting the callback too, and if so, what action are they taking?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528944475", "createdAt": "2020-11-23T19:27:52Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexClientManager.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.MultiplexingClient;\n+import lombok.experimental.Delegate;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+/**\n+ * This class is in charge of handling reconnection logic and registering callbacks for connection status changes.\n+ * It will delegate all other calls other than `Open`, `Close` and registerConnectionStatusChangeCallbaack to the inner client (MultiplexingClient)\n+ */\n+@Slf4j\n+public class MultiplexClientManager extends ClientManagerBase {\n+\n+    // Define method calls that will not be delegated to the inner client.\n+    private interface DeviceClientNonDelegatedFunction {\n+        void open();\n+        void close();\n+        void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext);\n+    }\n+\n+    // The methods defined in the interface DeviceClientNonDelegatedFunction will be called on MultiplexingClientManager, and not on MultiplexingClient.\n+    @Delegate(excludes = DeviceClientNonDelegatedFunction.class)\n+    private final MultiplexingClient client;\n+    private final String multiplexClientId;\n+\n+    /**\n+     * Creates an instance of the MultiplexClientManager\n+     *\n+     * @param multiplexingClient the multiplexing client\n+     * @param multiplexClientId user defined Id for the multiplexing client.\n+     */\n+    MultiplexClientManager(MultiplexingClient multiplexingClient, String multiplexClientId) {\n+        this.connectionStatus = ConnectionStatus.DISCONNECTED;\n+        this.client = multiplexingClient;\n+        this.multiplexClientId = multiplexClientId;\n+        this.client.registerConnectionStatusChangeCallback(this, this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NzgyMzI5", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-536782329", "createdAt": "2020-11-23T19:30:09Z", "commit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOTozMDoxMFrOH4cSrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOTozMDoxMFrOH4cSrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0NTgzNw==", "bodyText": "What's the difference between getClientId() and suppliedCallbackPair.getValue()? Are they both the device Id?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528945837", "createdAt": "2020-11-23T19:30:10Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change call back exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback {\n+\n+    protected enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+    \n+    protected static final Object lock = new Object();\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+    protected ConnectionStatus connectionStatus;\n+    protected Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        if (callback != null) {\n+            this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+        } else {\n+            this.suppliedConnectionStatusChangeCallback = null;\n+        }\n+    }\n+\n+    public void doConnect() throws IOException {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"Opening the device client instance \" + getClientId() + \" ...\");\n+                        openClient();\n+                        connectionStatus = ConnectionStatus.CONNECTED;\n+                        break;\n+                    }\n+                    catch (Exception ex) {\n+                        if (ex.getCause() instanceof TransportException && ((TransportException) ex.getCause()).isRetryable()) {\n+                            log.warn(\"Transport exception thrown while opening DeviceClient instance \" + getClientId() + \", retrying: \", ex);\n+                        } else {\n+                            log.error(\"Non-retryable exception thrown while opening DeviceClient instance \" + getClientId() + \": \", ex);\n+                            connectionStatus = ConnectionStatus.DISCONNECTED;\n+                            throw ex;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            try {\n+                log.debug(\"Sleeping for \" + SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS + \" secs before attempting another open()\");\n+                Thread.sleep(SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS * 1000);\n+            }\n+            catch (InterruptedException ex) {\n+                throw new RuntimeException(\"Interrupted while waiting between attempting to open the client: \", ex);\n+            }\n+        }\n+    }\n+\n+    public void closeNow() {\n+        synchronized (lock) {\n+            try {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException e) {\n+                log.error(\"Exception thrown while closing client instance \" + getClientId() + \" : \", e);\n+            } finally {\n+                connectionStatus = ConnectionStatus.DISCONNECTED;\n+            }\n+        }\n+    }\n+\n+    public void open() throws IOException {\n+        synchronized (lock) {\n+            if(connectionStatus == ConnectionStatus.DISCONNECTED) {\n+                connectionStatus = ConnectionStatus.CONNECTING;\n+            } else {\n+                return;\n+            }\n+        }\n+        doConnect();\n+    }\n+\n+    @Override\n+    public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext) {\n+        Pair<IotHubConnectionStatusChangeCallback, Object> suppliedCallbackPair = this.suppliedConnectionStatusChangeCallback;\n+        if (throwable == null)\n+        {\n+            log.info(\"CONNECTION STATUS UPDATE FOR CLIENT: \" + getClientId() + \" - \" + status + \", \" + statusChangeReason);\n+        }\n+        else\n+        {\n+            log.info(\"CONNECTION STATUS UPDATE FOR CLIENT: \" + getClientId() + \" - \" + status + \", \" + statusChangeReason + \", \" + throwable.getMessage());\n+            throwable.printStackTrace();\n+        }\n+\n+        if (shouldDeviceReconnect(status, statusChangeReason, throwable)) {\n+            if (suppliedCallbackPair != null) {\n+                suppliedCallbackPair.getKey().execute(DISCONNECTED_RETRYING, NO_NETWORK, throwable, suppliedCallbackPair.getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "originalPosition": 119}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NzgyOTUy", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-536782952", "createdAt": "2020-11-23T19:30:59Z", "commit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOTozMDo1OVrOH4cUhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOTozMDo1OVrOH4cUhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0NjMxMQ==", "bodyText": "2 spaces after return => 1", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528946311", "createdAt": "2020-11-23T19:30:59Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexClientManager.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.MultiplexingClient;\n+import lombok.experimental.Delegate;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+/**\n+ * This class is in charge of handling reconnection logic and registering callbacks for connection status changes.\n+ * It will delegate all other calls other than `Open`, `Close` and registerConnectionStatusChangeCallbaack to the inner client (MultiplexingClient)\n+ */\n+@Slf4j\n+public class MultiplexClientManager extends ClientManagerBase {\n+\n+    // Define method calls that will not be delegated to the inner client.\n+    private interface DeviceClientNonDelegatedFunction {\n+        void open();\n+        void close();\n+        void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext);\n+    }\n+\n+    // The methods defined in the interface DeviceClientNonDelegatedFunction will be called on MultiplexingClientManager, and not on MultiplexingClient.\n+    @Delegate(excludes = DeviceClientNonDelegatedFunction.class)\n+    private final MultiplexingClient client;\n+    private final String multiplexClientId;\n+\n+    /**\n+     * Creates an instance of the MultiplexClientManager\n+     *\n+     * @param multiplexingClient the multiplexing client\n+     * @param multiplexClientId user defined Id for the multiplexing client.\n+     */\n+    MultiplexClientManager(MultiplexingClient multiplexingClient, String multiplexClientId) {\n+        this.connectionStatus = ConnectionStatus.DISCONNECTED;\n+        this.client = multiplexingClient;\n+        this.multiplexClientId = multiplexClientId;\n+        this.client.registerConnectionStatusChangeCallback(this, this);\n+    }\n+\n+    @Override\n+    public void openClient() throws IOException {\n+        this.client.open();\n+    }\n+\n+    @Override\n+    public void closeClient() throws IOException {\n+        this.client.close();\n+    }\n+\n+    @Override\n+    public String getClientId() {\n+        return  multiplexClientId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NzgzMDkz", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-536783093", "createdAt": "2020-11-23T19:31:10Z", "commit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOTozMToxMFrOH4cU9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOTozMToxMFrOH4cU9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0NjQyMA==", "bodyText": "space before brace", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r528946420", "createdAt": "2020-11-23T19:31:10Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexClientManager.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.MultiplexingClient;\n+import lombok.experimental.Delegate;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+/**\n+ * This class is in charge of handling reconnection logic and registering callbacks for connection status changes.\n+ * It will delegate all other calls other than `Open`, `Close` and registerConnectionStatusChangeCallbaack to the inner client (MultiplexingClient)\n+ */\n+@Slf4j\n+public class MultiplexClientManager extends ClientManagerBase {\n+\n+    // Define method calls that will not be delegated to the inner client.\n+    private interface DeviceClientNonDelegatedFunction {\n+        void open();\n+        void close();\n+        void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext);\n+    }\n+\n+    // The methods defined in the interface DeviceClientNonDelegatedFunction will be called on MultiplexingClientManager, and not on MultiplexingClient.\n+    @Delegate(excludes = DeviceClientNonDelegatedFunction.class)\n+    private final MultiplexingClient client;\n+    private final String multiplexClientId;\n+\n+    /**\n+     * Creates an instance of the MultiplexClientManager\n+     *\n+     * @param multiplexingClient the multiplexing client\n+     * @param multiplexClientId user defined Id for the multiplexing client.\n+     */\n+    MultiplexClientManager(MultiplexingClient multiplexingClient, String multiplexClientId) {\n+        this.connectionStatus = ConnectionStatus.DISCONNECTED;\n+        this.client = multiplexingClient;\n+        this.multiplexClientId = multiplexClientId;\n+        this.client.registerConnectionStatusChangeCallback(this, this);\n+    }\n+\n+    @Override\n+    public void openClient() throws IOException {\n+        this.client.open();\n+    }\n+\n+    @Override\n+    public void closeClient() throws IOException {\n+        this.client.close();\n+    }\n+\n+    @Override\n+    public String getClientId() {\n+        return  multiplexClientId;\n+    }\n+\n+    public MultiplexingClient getMultiplexClient(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a663e2514bd6a97e9fcd9d2f4fa9ff8f584b9a2"}, "originalPosition": 57}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d1da1b587953ee4680a3cf18989495decaf5e73", "author": {"user": {"login": "azabbasi", "name": "Azad Abbasi"}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/3d1da1b587953ee4680a3cf18989495decaf5e73", "committedDate": "2020-11-24T19:39:25Z", "message": "Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17a7c2866b18ba138223cc74483571bccf480aaf", "author": {"user": {"login": "azabbasi", "name": "Azad Abbasi"}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/17a7c2866b18ba138223cc74483571bccf480aaf", "committedDate": "2020-11-24T19:47:02Z", "message": "formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7620bdff266881584f521a4ae707ea50af018180", "author": {"user": {"login": "azabbasi", "name": "Azad Abbasi"}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/7620bdff266881584f521a4ae707ea50af018180", "committedDate": "2020-11-24T19:51:23Z", "message": "Update ClientManagerBase.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5826833250201d6a8cc339cde06d6e90fdc23201", "author": {"user": {"login": "azabbasi", "name": "Azad Abbasi"}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/5826833250201d6a8cc339cde06d6e90fdc23201", "committedDate": "2020-11-24T21:27:15Z", "message": "Update ClientManagerBase.java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMTU4NjQy", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-541158642", "createdAt": "2020-11-30T17:59:51Z", "commit": {"oid": "5826833250201d6a8cc339cde06d6e90fdc23201"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNzo1OTo1MVrOH8HDPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNzo1OTo1MVrOH8HDPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5MjEyNw==", "bodyText": "In .NET we'd make this abstract to ensure the inheriting class implemented it. Does Java have an analog?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532792127", "createdAt": "2020-11-30T17:59:51Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change callback exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback, ConnectionStatusTracker\n+{\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+\n+    // Initialize the connection status as DISCONNECTED\n+    protected ConnectionStatus lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+\n+    // Tracks connection status of the dependency connection (multiplexing client connection status for example in this case for DeviceClientManager)\n+    protected ConnectionStatusTracker dependencyConnectionStatusTracker;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    // Since the client manager is in charge of handling the connection status callback, this method is a no-op\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5826833250201d6a8cc339cde06d6e90fdc23201"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMTU5MDkz", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-541159093", "createdAt": "2020-11-30T18:00:24Z", "commit": {"oid": "5826833250201d6a8cc339cde06d6e90fdc23201"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODowMDoyNFrOH8HEvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODowMDoyNFrOH8HEvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5MjUxMA==", "bodyText": "Why closeNow() instead of just close()?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532792510", "createdAt": "2020-11-30T18:00:24Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change callback exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback, ConnectionStatusTracker\n+{\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+\n+    // Initialize the connection status as DISCONNECTED\n+    protected ConnectionStatus lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+\n+    // Tracks connection status of the dependency connection (multiplexing client connection status for example in this case for DeviceClientManager)\n+    protected ConnectionStatusTracker dependencyConnectionStatusTracker;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    // Since the client manager is in charge of handling the connection status callback, this method is a no-op\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext)\n+    {\n+        return;\n+    }\n+\n+    public void closeNow()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5826833250201d6a8cc339cde06d6e90fdc23201"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMTU5NTc3", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-541159577", "createdAt": "2020-11-30T18:00:59Z", "commit": {"oid": "5826833250201d6a8cc339cde06d6e90fdc23201"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODowMDo1OVrOH8HGeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODowMDo1OVrOH8HGeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5Mjk1Mg==", "bodyText": "As previous block returns, else is not necessary", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532792952", "createdAt": "2020-11-30T18:00:59Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change callback exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback, ConnectionStatusTracker\n+{\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+\n+    // Initialize the connection status as DISCONNECTED\n+    protected ConnectionStatus lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+\n+    // Tracks connection status of the dependency connection (multiplexing client connection status for example in this case for DeviceClientManager)\n+    protected ConnectionStatusTracker dependencyConnectionStatusTracker;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    // Since the client manager is in charge of handling the connection status callback, this method is a no-op\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext)\n+    {\n+        return;\n+    }\n+\n+    public void closeNow()\n+    {\n+        synchronized (lastKnownConnectionStatus)\n+        {\n+            try\n+            {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException ex)\n+            {\n+                log.error(\"Exception thrown while closing client instance \" + getClientId() + \" : \", ex);\n+            }\n+            finally\n+            {\n+                // Once the connection is closed, set the Status to DISCONNECTED\n+                lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+            }\n+        }\n+    }\n+\n+    // When client manager is being opened it first makes sure the client is in a DISCONNECTED state\n+    // If the client is in CONNECTING or CONNECTED state, Open will be no-op.\n+    public void open() throws IOException\n+    {\n+        synchronized (lastKnownConnectionStatus)\n+        {\n+            // Do not attempt to CONNECT if the connection status is not DISCONNECTED. This ensure that only one process is going to attempt to connect\n+            if (lastKnownConnectionStatus != ConnectionStatus.DISCONNECTED)\n+            {\n+                return;\n+            }\n+            else", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5826833250201d6a8cc339cde06d6e90fdc23201"}, "originalPosition": 72}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMTU5Nzk2", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-541159796", "createdAt": "2020-11-30T18:01:16Z", "commit": {"oid": "5826833250201d6a8cc339cde06d6e90fdc23201"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODowMToxNlrOH8HHEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODowMToxNlrOH8HHEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5MzEwNg==", "bodyText": "Same, why not just connect()?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532793106", "createdAt": "2020-11-30T18:01:16Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change callback exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback, ConnectionStatusTracker\n+{\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+\n+    // Initialize the connection status as DISCONNECTED\n+    protected ConnectionStatus lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+\n+    // Tracks connection status of the dependency connection (multiplexing client connection status for example in this case for DeviceClientManager)\n+    protected ConnectionStatusTracker dependencyConnectionStatusTracker;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    // Since the client manager is in charge of handling the connection status callback, this method is a no-op\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext)\n+    {\n+        return;\n+    }\n+\n+    public void closeNow()\n+    {\n+        synchronized (lastKnownConnectionStatus)\n+        {\n+            try\n+            {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException ex)\n+            {\n+                log.error(\"Exception thrown while closing client instance \" + getClientId() + \" : \", ex);\n+            }\n+            finally\n+            {\n+                // Once the connection is closed, set the Status to DISCONNECTED\n+                lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+            }\n+        }\n+    }\n+\n+    // When client manager is being opened it first makes sure the client is in a DISCONNECTED state\n+    // If the client is in CONNECTING or CONNECTED state, Open will be no-op.\n+    public void open() throws IOException\n+    {\n+        synchronized (lastKnownConnectionStatus)\n+        {\n+            // Do not attempt to CONNECT if the connection status is not DISCONNECTED. This ensure that only one process is going to attempt to connect\n+            if (lastKnownConnectionStatus != ConnectionStatus.DISCONNECTED)\n+            {\n+                return;\n+            }\n+            else\n+            {\n+                // Set the connection status to CONNECTING\n+                lastKnownConnectionStatus = ConnectionStatus.CONNECTING;\n+            }\n+        }\n+\n+        establishConnection();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5826833250201d6a8cc339cde06d6e90fdc23201"}, "originalPosition": 79}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMTYwNDkw", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-541160490", "createdAt": "2020-11-30T18:02:09Z", "commit": {"oid": "5826833250201d6a8cc339cde06d6e90fdc23201"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODowMjowOVrOH8HJHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODowMjowOVrOH8HJHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5MzYzMQ==", "bodyText": "Let's avoid the verb execute. It doesn't pass PoliCheck.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532793631", "createdAt": "2020-11-30T18:02:09Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change callback exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback, ConnectionStatusTracker\n+{\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+\n+    // Initialize the connection status as DISCONNECTED\n+    protected ConnectionStatus lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+\n+    // Tracks connection status of the dependency connection (multiplexing client connection status for example in this case for DeviceClientManager)\n+    protected ConnectionStatusTracker dependencyConnectionStatusTracker;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    // Since the client manager is in charge of handling the connection status callback, this method is a no-op\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext)\n+    {\n+        return;\n+    }\n+\n+    public void closeNow()\n+    {\n+        synchronized (lastKnownConnectionStatus)\n+        {\n+            try\n+            {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException ex)\n+            {\n+                log.error(\"Exception thrown while closing client instance \" + getClientId() + \" : \", ex);\n+            }\n+            finally\n+            {\n+                // Once the connection is closed, set the Status to DISCONNECTED\n+                lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+            }\n+        }\n+    }\n+\n+    // When client manager is being opened it first makes sure the client is in a DISCONNECTED state\n+    // If the client is in CONNECTING or CONNECTED state, Open will be no-op.\n+    public void open() throws IOException\n+    {\n+        synchronized (lastKnownConnectionStatus)\n+        {\n+            // Do not attempt to CONNECT if the connection status is not DISCONNECTED. This ensure that only one process is going to attempt to connect\n+            if (lastKnownConnectionStatus != ConnectionStatus.DISCONNECTED)\n+            {\n+                return;\n+            }\n+            else\n+            {\n+                // Set the connection status to CONNECTING\n+                lastKnownConnectionStatus = ConnectionStatus.CONNECTING;\n+            }\n+        }\n+\n+        establishConnection();\n+    }\n+\n+    @Override\n+    public ConnectionStatus getConnectionStatus(){\n+        return this.lastKnownConnectionStatus;\n+    }\n+\n+    @Override\n+    public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5826833250201d6a8cc339cde06d6e90fdc23201"}, "originalPosition": 88}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMTYxODAz", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-541161803", "createdAt": "2020-11-30T18:03:49Z", "commit": {"oid": "5826833250201d6a8cc339cde06d6e90fdc23201"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODowMzo0OVrOH8HM7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODowMzo0OVrOH8HM7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5NDYwNw==", "bodyText": "For readability, consider putting each condition on a newline:\nreturn status == DISCONNECTED\n    && statusChangeReason == RETRY_EXPIRED\n    && throwable instanceof DeviceOperationTimeoutException;", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532794607", "createdAt": "2020-11-30T18:03:49Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change callback exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback, ConnectionStatusTracker\n+{\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+\n+    // Initialize the connection status as DISCONNECTED\n+    protected ConnectionStatus lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+\n+    // Tracks connection status of the dependency connection (multiplexing client connection status for example in this case for DeviceClientManager)\n+    protected ConnectionStatusTracker dependencyConnectionStatusTracker;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    // Since the client manager is in charge of handling the connection status callback, this method is a no-op\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext)\n+    {\n+        return;\n+    }\n+\n+    public void closeNow()\n+    {\n+        synchronized (lastKnownConnectionStatus)\n+        {\n+            try\n+            {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException ex)\n+            {\n+                log.error(\"Exception thrown while closing client instance \" + getClientId() + \" : \", ex);\n+            }\n+            finally\n+            {\n+                // Once the connection is closed, set the Status to DISCONNECTED\n+                lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+            }\n+        }\n+    }\n+\n+    // When client manager is being opened it first makes sure the client is in a DISCONNECTED state\n+    // If the client is in CONNECTING or CONNECTED state, Open will be no-op.\n+    public void open() throws IOException\n+    {\n+        synchronized (lastKnownConnectionStatus)\n+        {\n+            // Do not attempt to CONNECT if the connection status is not DISCONNECTED. This ensure that only one process is going to attempt to connect\n+            if (lastKnownConnectionStatus != ConnectionStatus.DISCONNECTED)\n+            {\n+                return;\n+            }\n+            else\n+            {\n+                // Set the connection status to CONNECTING\n+                lastKnownConnectionStatus = ConnectionStatus.CONNECTING;\n+            }\n+        }\n+\n+        establishConnection();\n+    }\n+\n+    @Override\n+    public ConnectionStatus getConnectionStatus(){\n+        return this.lastKnownConnectionStatus;\n+    }\n+\n+    @Override\n+    public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext)\n+    {\n+        if (throwable == null)\n+        {\n+            log.info(\"CONNECTION STATUS UPDATE FOR CLIENT: \" + getClientId() + \" - \" + status + \", \" + statusChangeReason);\n+        }\n+        else\n+        {\n+            log.info(\"CONNECTION STATUS UPDATE FOR CLIENT: \" + getClientId() + \" - \" + status + \", \" + statusChangeReason + \", \" + throwable.getMessage());\n+            throwable.printStackTrace();\n+        }\n+\n+        if (shouldDeviceReconnect(status, statusChangeReason, throwable))\n+        {\n+            handleRecoverableDisconnection();\n+        }\n+    }\n+\n+    // This detects the state where the DeviceClient reports that OperationTimeout has expired, and stops retrying; even though the applied RetryPolicy is still valid.\n+    // The logic to identify whether or not the connection should be established lives in this method.\n+    // The client will automatically retry to establish the connection if the error is retryable\n+    protected boolean shouldDeviceReconnect(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable)\n+    {\n+        return (status == DISCONNECTED && statusChangeReason == RETRY_EXPIRED && throwable instanceof DeviceOperationTimeoutException);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5826833250201d6a8cc339cde06d6e90fdc23201"}, "originalPosition": 111}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMTYyOTcz", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-541162973", "createdAt": "2020-11-30T18:05:23Z", "commit": {"oid": "5826833250201d6a8cc339cde06d6e90fdc23201"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODowNToyM1rOH8HQnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODowNToyM1rOH8HQnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5NTU0OA==", "bodyText": "Same idea as above, splitting conditions on multiple lines; it will also reduce line length here which is getting a bit long", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532795548", "createdAt": "2020-11-30T18:05:23Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change callback exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback, ConnectionStatusTracker\n+{\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+\n+    // Initialize the connection status as DISCONNECTED\n+    protected ConnectionStatus lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+\n+    // Tracks connection status of the dependency connection (multiplexing client connection status for example in this case for DeviceClientManager)\n+    protected ConnectionStatusTracker dependencyConnectionStatusTracker;\n+\n+    public abstract void openClient() throws IOException;\n+    public abstract void closeClient() throws IOException;\n+    public abstract String getClientId();\n+\n+    // Since the client manager is in charge of handling the connection status callback, this method is a no-op\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext)\n+    {\n+        return;\n+    }\n+\n+    public void closeNow()\n+    {\n+        synchronized (lastKnownConnectionStatus)\n+        {\n+            try\n+            {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException ex)\n+            {\n+                log.error(\"Exception thrown while closing client instance \" + getClientId() + \" : \", ex);\n+            }\n+            finally\n+            {\n+                // Once the connection is closed, set the Status to DISCONNECTED\n+                lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+            }\n+        }\n+    }\n+\n+    // When client manager is being opened it first makes sure the client is in a DISCONNECTED state\n+    // If the client is in CONNECTING or CONNECTED state, Open will be no-op.\n+    public void open() throws IOException\n+    {\n+        synchronized (lastKnownConnectionStatus)\n+        {\n+            // Do not attempt to CONNECT if the connection status is not DISCONNECTED. This ensure that only one process is going to attempt to connect\n+            if (lastKnownConnectionStatus != ConnectionStatus.DISCONNECTED)\n+            {\n+                return;\n+            }\n+            else\n+            {\n+                // Set the connection status to CONNECTING\n+                lastKnownConnectionStatus = ConnectionStatus.CONNECTING;\n+            }\n+        }\n+\n+        establishConnection();\n+    }\n+\n+    @Override\n+    public ConnectionStatus getConnectionStatus(){\n+        return this.lastKnownConnectionStatus;\n+    }\n+\n+    @Override\n+    public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext)\n+    {\n+        if (throwable == null)\n+        {\n+            log.info(\"CONNECTION STATUS UPDATE FOR CLIENT: \" + getClientId() + \" - \" + status + \", \" + statusChangeReason);\n+        }\n+        else\n+        {\n+            log.info(\"CONNECTION STATUS UPDATE FOR CLIENT: \" + getClientId() + \" - \" + status + \", \" + statusChangeReason + \", \" + throwable.getMessage());\n+            throwable.printStackTrace();\n+        }\n+\n+        if (shouldDeviceReconnect(status, statusChangeReason, throwable))\n+        {\n+            handleRecoverableDisconnection();\n+        }\n+    }\n+\n+    // This detects the state where the DeviceClient reports that OperationTimeout has expired, and stops retrying; even though the applied RetryPolicy is still valid.\n+    // The logic to identify whether or not the connection should be established lives in this method.\n+    // The client will automatically retry to establish the connection if the error is retryable\n+    protected boolean shouldDeviceReconnect(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable)\n+    {\n+        return (status == DISCONNECTED && statusChangeReason == RETRY_EXPIRED && throwable instanceof DeviceOperationTimeoutException);\n+    }\n+\n+    // We only expect the connection status to be CONNECTED by the time we enter this state.\n+    public void handleRecoverableDisconnection() {\n+        // If the lastKnownConnectionStatus is not in a CONNECTED state it can mean two things:\n+        // 1: the status is CONNECTING, in which case there is nothing to be done at this time.\n+        // 2: the status is DISCONNECTED, in which case connection cannot be re-established.\n+        if (lastKnownConnectionStatus == ConnectionStatus.CONNECTED)\n+        {\n+            new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    log.debug(\"Attempting reconnect for client: \" + getClientId() + \" ...\");\n+                    synchronized (lastKnownConnectionStatus)\n+                    {\n+                        if (lastKnownConnectionStatus == ConnectionStatus.CONNECTED)\n+                        {\n+                            try\n+                            {\n+                                closeClient();\n+                            }\n+                            catch (Exception ex)\n+                            {\n+                                log.warn(\"Client \" + getClientId() + \" closeNow failed.\", ex);\n+                            }\n+                            finally\n+                            {\n+                                lastKnownConnectionStatus = ConnectionStatus.CONNECTING;\n+                            }\n+                        }\n+                        else\n+                        {\n+                            log.debug(\"Client `\" + getClientId() + \"` is currently connecting; skipping...\");\n+                            return;\n+                        }\n+                    }\n+\n+                    // The client is now closed and the connection status is CONNECTING. Connection can be established now.\n+                    try\n+                    {\n+                        establishConnection();\n+                    }\n+                    catch (IOException ex)\n+                    {\n+                        log.error(\"Exception thrown while opening client instance: \" + getClientId(), ex);\n+                    }\n+                }\n+            }).start();\n+        }\n+    }\n+\n+    public void establishConnection() throws IOException\n+    {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        // Lock the lastKnownConnectionStus so no other process will be able to change it while the client manager is attempting to open the connection.\n+        synchronized (lastKnownConnectionStatus)\n+        {\n+            while (lastKnownConnectionStatus == ConnectionStatus.CONNECTING)\n+            {\n+                // If the client has dependencies to another client (in this case it could be the multiplexing client) we have to wait to make sure the\n+                // dependent connection is established first.\n+                if (dependencyConnectionStatusTracker != null && dependencyConnectionStatusTracker.getConnectionStatus() == ConnectionStatus.CONNECTING)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5826833250201d6a8cc339cde06d6e90fdc23201"}, "originalPosition": 173}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMTY2NTY2", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-541166566", "createdAt": "2020-11-30T18:10:11Z", "commit": {"oid": "5826833250201d6a8cc339cde06d6e90fdc23201"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODoxMDoxMVrOH8Hb5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODoxMDoxMVrOH8Hb5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5ODQzNg==", "bodyText": "comment", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532798436", "createdAt": "2020-11-30T18:10:11Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ConnectionStatusTracker.java", "diffHunk": "@@ -0,0 +1,6 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+public interface ConnectionStatusTracker", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5826833250201d6a8cc339cde06d6e90fdc23201"}, "originalPosition": 3}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMTY2Nzg2", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-541166786", "createdAt": "2020-11-30T18:10:29Z", "commit": {"oid": "5826833250201d6a8cc339cde06d6e90fdc23201"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODoxMDoyOVrOH8Hcqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODoxMDoyOVrOH8Hcqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5ODYzNA==", "bodyText": "baack", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532798634", "createdAt": "2020-11-30T18:10:29Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/DeviceClientManager.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceClient;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import lombok.experimental.Delegate;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+/**\n+ * This class is in charge of handling reconnection logic and registering callbacks for connection status changes.\n+ * It will delegate all other calls other than `Open`, `Close` and registerConnectionStatusChangeCallbaack to the inner client (DeviceClient)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5826833250201d6a8cc339cde06d6e90fdc23201"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMTY3MzI3", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-541167327", "createdAt": "2020-11-30T18:11:09Z", "commit": {"oid": "5826833250201d6a8cc339cde06d6e90fdc23201"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODoxMToxMFrOH8HeNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODoxMToxMFrOH8HeNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5OTAyOA==", "bodyText": "I don't know if markdown works for Java doc comments, but you have the first two methods enclosed in backticks, but not the third. We should decorate them consistently.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532799028", "createdAt": "2020-11-30T18:11:10Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/DeviceClientManager.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceClient;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import lombok.experimental.Delegate;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+/**\n+ * This class is in charge of handling reconnection logic and registering callbacks for connection status changes.\n+ * It will delegate all other calls other than `Open`, `Close` and registerConnectionStatusChangeCallbaack to the inner client (DeviceClient)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5826833250201d6a8cc339cde06d6e90fdc23201"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMTg5NjIy", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-541189622", "createdAt": "2020-11-30T18:41:03Z", "commit": {"oid": "5826833250201d6a8cc339cde06d6e90fdc23201"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODo0MTowM1rOH8IkHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODo0MTowM1rOH8IkHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxNjkyNg==", "bodyText": "Lots of \"clients\" to distinguish. Perhaps call this sdkClient?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532816926", "createdAt": "2020-11-30T18:41:03Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexClientManager.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.MultiplexingClient;\n+import lombok.experimental.Delegate;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+/**\n+ * This class is in charge of handling reconnection logic and registering callbacks for connection status changes.\n+ * It will delegate all other calls other than `Open`, `Close` and registerConnectionStatusChangeCallbaack to the inner client (MultiplexingClient)\n+ */\n+@Slf4j\n+public class MultiplexClientManager extends ClientManagerBase\n+{\n+    // Define method calls that will not be delegated to the inner client.\n+    private interface DeviceClientNonDelegatedFunction\n+    {\n+        void open();\n+        void close();\n+        void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext);\n+    }\n+\n+    // The methods defined in the interface DeviceClientNonDelegatedFunction will be called on MultiplexingClientManager, and not on MultiplexingClient.\n+    @Delegate(excludes = DeviceClientNonDelegatedFunction.class)\n+    private final MultiplexingClient client;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5826833250201d6a8cc339cde06d6e90fdc23201"}, "originalPosition": 27}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "723391617e06cb9c19e63ddaef216120cbbeefd0", "author": {"user": {"login": "azabbasi", "name": "Azad Abbasi"}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/723391617e06cb9c19e63ddaef216120cbbeefd0", "committedDate": "2020-11-30T20:37:57Z", "message": "Address more CR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c221e7863877392c91caacefcef1159ad6c5e8c", "author": {"user": {"login": "azabbasi", "name": "Azad Abbasi"}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/4c221e7863877392c91caacefcef1159ad6c5e8c", "committedDate": "2020-11-30T20:42:34Z", "message": "more comment fixes."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMjk0NTcz", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-541294573", "createdAt": "2020-11-30T21:06:42Z", "commit": {"oid": "4c221e7863877392c91caacefcef1159ad6c5e8c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQyMTowNjo0MlrOH8N2UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQyMTowNjo0MlrOH8N2UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkwMzUwNQ==", "bodyText": "Why is this indented twice?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#discussion_r532903505", "createdAt": "2020-11-30T21:06:42Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/ClientManagerBase.java", "diffHunk": "@@ -0,0 +1,255 @@\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+\n+/**\n+ * This is the base class for DeviceClientManager and MultiplexingClientManager\n+ * The shared logic for reconnection and handling status change callback exists here.\n+ */\n+@Slf4j\n+public abstract class ClientManagerBase implements IotHubConnectionStatusChangeCallback, ConnectionStatusTracker\n+{\n+    protected static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 2;\n+\n+    /**\n+     * Initialize the connection status as DISCONNECTED\n+     */\n+    protected ConnectionStatus lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+\n+    // Tracks connection status of the dependency connection (multiplexing client connection status for example in this case for DeviceClientManager)\n+    protected ConnectionStatusTracker dependencyConnectionStatusTracker;\n+\n+    /**\n+     * All classes that extend ClientManagerBase should implement how their inner client can be opened.\n+     */\n+    protected abstract void openClient() throws IOException;\n+\n+    /**\n+     * All classes that extend ClientManagerBase should implement how their inner client can be closed.\n+     */\n+    protected abstract void closeClient() throws IOException;\n+\n+    /**\n+     * All classes that extend ClientManagerBase should implement how their inner client can be identified for logging purposes.\n+     */\n+    public abstract String getClientId();\n+\n+    /**\n+     * Since the client manager is in charge of handling the connection status callback, this method is a no-op.\n+     * This method is not an abstract method since in this sample there is no need for the user to register a connection status callback\n+     * @param callback The callback function.\n+     * @param callbackContext The callback context\n+     */\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext)\n+    {\n+        return;\n+    }\n+\n+    public void close()\n+    {\n+        closeNow();\n+    }\n+\n+    public void closeNow()\n+    {\n+        synchronized (lastKnownConnectionStatus)\n+        {\n+            try\n+            {\n+                log.debug(\"Closing the client instance \" + getClientId() + \" ...\");\n+                closeClient();\n+            }\n+            catch (IOException ex)\n+            {\n+                log.error(\"Exception thrown while closing client instance \" + getClientId() + \" : \", ex);\n+            }\n+            finally\n+            {\n+                // Once the connection is closed, set the Status to DISCONNECTED\n+                lastKnownConnectionStatus = ConnectionStatus.DISCONNECTED;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * When client manager is being opened it first makes sure the client is in a DISCONNECTED state\n+     * If the client is in CONNECTING or CONNECTED state, Open will be no-op.\n+     * @throws IOException\n+     */\n+    public void open() throws IOException\n+    {\n+        synchronized (lastKnownConnectionStatus)\n+        {\n+            // Do not attempt to CONNECT if the connection status is not DISCONNECTED. This ensure that only one process is going to attempt to connect\n+            if (lastKnownConnectionStatus != ConnectionStatus.DISCONNECTED)\n+            {\n+                return;\n+            }\n+\n+            // Set the connection status to CONNECTING\n+            lastKnownConnectionStatus = ConnectionStatus.CONNECTING;\n+        }\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public ConnectionStatus getConnectionStatus(){\n+        return this.lastKnownConnectionStatus;\n+    }\n+\n+    @Override\n+    public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext)\n+    {\n+        if (throwable == null)\n+        {\n+            log.info(\"CONNECTION STATUS UPDATE FOR CLIENT: \" + getClientId() + \" - \" + status + \", \" + statusChangeReason);\n+        }\n+        else\n+        {\n+            log.info(\"CONNECTION STATUS UPDATE FOR CLIENT: \" + getClientId() + \" - \" + status + \", \" + statusChangeReason + \", \" + throwable.getMessage());\n+            throwable.printStackTrace();\n+        }\n+\n+        if (shouldClientReconnect(status, statusChangeReason, throwable))\n+        {\n+            handleRecoverableDisconnection();\n+        }\n+    }\n+\n+    /**\n+     * This detects the state where the DeviceClient reports that OperationTimeout has expired, and sto\n+     * The logic to identify whether or not the connection should be established lives in this method.\n+     * The client will automatically retry to establish the connection if the error is retryable\n+     */\n+    protected boolean shouldClientReconnect(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable)\n+    {\n+        return status == DISCONNECTED\n+                && statusChangeReason == RETRY_EXPIRED", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c221e7863877392c91caacefcef1159ad6c5e8c"}, "originalPosition": 138}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMjk1Nzc1", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/993#pullrequestreview-541295775", "createdAt": "2020-11-30T21:08:36Z", "commit": {"oid": "4c221e7863877392c91caacefcef1159ad6c5e8c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6774d8e48b80b5a0485d09979694859698c6af92", "author": {"user": {"login": "azabbasi", "name": "Azad Abbasi"}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/6774d8e48b80b5a0485d09979694859698c6af92", "committedDate": "2020-11-30T21:53:25Z", "message": "Update ClientManagerBase.java"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1617, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}