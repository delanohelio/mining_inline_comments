{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0OTg5NzI5", "number": 840, "title": "feat(sample): Add plug and play Thermostat sample (no-component)", "bodyText": "Interface implemented: https://github.com/Azure/opendigitaltwins-dtdl/blob/master/DTDL/v2/samples/Thermostat.json", "createdAt": "2020-07-06T20:38:09Z", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/840", "merged": true, "mergeCommit": {"oid": "60d9a311d9713cc2848aff2a0baeefd2e1afcd11"}, "closed": true, "closedAt": "2020-07-06T23:40:53Z", "author": {"login": "abhipsaMisra"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcyXZNjgH2gAyNDQ0OTg5NzI5OmM5MzY3MWFlNDJkNjE0MTBkYjFiMzlhYTFhNzU2MTdkZjhiZjBiODc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcyY-tpgFqTQ0MzQ0NjM2Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c93671ae42d61410db1b39aa1a75617df8bf0b87", "author": {"user": {"login": "abhipsaMisra", "name": "Abhipsa Misra"}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/c93671ae42d61410db1b39aa1a75617df8bf0b87", "committedDate": "2020-07-06T20:37:39Z", "message": "feat(sample): Add plug and play Thermostat sample (no-component)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMzkzNzgx", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/840#pullrequestreview-443393781", "createdAt": "2020-07-06T20:42:34Z", "commit": {"oid": "c93671ae42d61410db1b39aa1a75617df8bf0b87"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMDo0MjozNFrOGtmcGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMDo0MjozNFrOGtmcGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ2ODg5MQ==", "bodyText": "SneakyThrows will not ignore, wrap or modify the actual checked exception thrown, but will instead prevent the compiler from complaining that the exception is not handled (either by declaring throws n the method signature, or by wrapping it in a try-catch block and rethrowing a RuntimeException.\nFrom lombok documentation: https://projectlombok.org/features/SneakyThrows\nwhatever exception propagates out of your run() method, checked or not, it will be passed to the Thread's unhandled exception handler. Catching a checked exception and wrapping it in some sort of RuntimeException is only obscuring the real cause of the issue.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/840#discussion_r450468891", "createdAt": "2020-07-06T20:42:34Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-samples/pnp-device-sample/Thermostat/src/main/java/samples/com/microsoft/azure/sdk/iot/Thermostat.java", "diffHunk": "@@ -0,0 +1,317 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonObject;\n+import com.google.gson.annotations.SerializedName;\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.AllArgsConstructor;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.*;\n+\n+@Slf4j\n+public class Thermostat {\n+\n+    public enum StatusCode {\n+        COMPLETED (200),\n+        IN_PROGRESS (202),\n+        NOT_FOUND (404);\n+\n+        private final int value;\n+        StatusCode(int value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    private static final String deviceConnectionString = System.getenv(\"IOTHUB_DEVICE_CONNECTION_STRING\");\n+    private static final String MODEL_ID = \"dtmi:com:example:Thermostat;1\";\n+\n+    // Plug and play features are available over either MQTT or MQTT_WS.\n+    private static final IotHubClientProtocol protocol = IotHubClientProtocol.MQTT;\n+\n+    private static final Random random = new Random();\n+    private static final Map<Date, Double> temperatureReadings = new HashMap<>();\n+\n+    private static DeviceClient deviceClient;\n+    private static double temperature = 0.0d;\n+    private static double maxTemperature = 0.0d;\n+    private static boolean temperatureReset = true;\n+\n+    public static void main(String[] args) throws URISyntaxException, IOException {\n+\n+        // This sample follows the following workflow:\n+        // -> Initialize device client instance.\n+        // -> Set handler to receive \"targetTemperature\" updates, and send the received update over reported property.\n+        // -> Set handler to receive \"getMaxMinReport\" command, and send the generated report as command response.\n+        // -> Periodically send \"temperature\" over telemetry.\n+        // -> Send \"maxTempSinceLastReboot\" over property update, when a new max temperature is set.\n+\n+        log.debug(\"Initialize the device client.\");\n+        initializeDeviceClient();\n+\n+        log.debug(\"Start twin and set handler to receive \\\"targetTemperature\\\" updates.\");\n+        deviceClient.startDeviceTwin(new TwinIotHubEventCallback(), null, new TargetTemperatureUpdateCallback(), null);\n+        Map<Property, Pair<TwinPropertyCallBack, Object>> desiredPropertyUpdateCallback =\n+                Collections.singletonMap(\n+                        new Property(\"targetTemperature\", null),\n+                        new Pair<TwinPropertyCallBack, Object>(new TargetTemperatureUpdateCallback(), null));\n+        deviceClient.subscribeToTwinDesiredProperties(desiredPropertyUpdateCallback);\n+\n+        log.debug(\"Set handler to receive \\\"getMaxMinReport\\\" command.\");\n+        String methodName = \"getMaxMinReport\";\n+        deviceClient.subscribeToDeviceMethod(new GetMaxMinReportMethodCallback(), methodName, new MethodIotHubEventCallback(), methodName);\n+\n+        new Thread(new Runnable() {\n+            @SneakyThrows(InterruptedException.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c93671ae42d61410db1b39aa1a75617df8bf0b87"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMzk0MzEx", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/840#pullrequestreview-443394311", "createdAt": "2020-07-06T20:43:29Z", "commit": {"oid": "c93671ae42d61410db1b39aa1a75617df8bf0b87"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMDo0MzoyOVrOGtmdxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMDo0MzoyOVrOGtmdxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ2OTMxNw==", "bodyText": "This is only to ensure only a single decimal place is stored, for the double.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/840#discussion_r450469317", "createdAt": "2020-07-06T20:43:29Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-samples/pnp-device-sample/Thermostat/src/main/java/samples/com/microsoft/azure/sdk/iot/Thermostat.java", "diffHunk": "@@ -0,0 +1,317 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonObject;\n+import com.google.gson.annotations.SerializedName;\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.AllArgsConstructor;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.*;\n+\n+@Slf4j\n+public class Thermostat {\n+\n+    public enum StatusCode {\n+        COMPLETED (200),\n+        IN_PROGRESS (202),\n+        NOT_FOUND (404);\n+\n+        private final int value;\n+        StatusCode(int value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    private static final String deviceConnectionString = System.getenv(\"IOTHUB_DEVICE_CONNECTION_STRING\");\n+    private static final String MODEL_ID = \"dtmi:com:example:Thermostat;1\";\n+\n+    // Plug and play features are available over either MQTT or MQTT_WS.\n+    private static final IotHubClientProtocol protocol = IotHubClientProtocol.MQTT;\n+\n+    private static final Random random = new Random();\n+    private static final Map<Date, Double> temperatureReadings = new HashMap<>();\n+\n+    private static DeviceClient deviceClient;\n+    private static double temperature = 0.0d;\n+    private static double maxTemperature = 0.0d;\n+    private static boolean temperatureReset = true;\n+\n+    public static void main(String[] args) throws URISyntaxException, IOException {\n+\n+        // This sample follows the following workflow:\n+        // -> Initialize device client instance.\n+        // -> Set handler to receive \"targetTemperature\" updates, and send the received update over reported property.\n+        // -> Set handler to receive \"getMaxMinReport\" command, and send the generated report as command response.\n+        // -> Periodically send \"temperature\" over telemetry.\n+        // -> Send \"maxTempSinceLastReboot\" over property update, when a new max temperature is set.\n+\n+        log.debug(\"Initialize the device client.\");\n+        initializeDeviceClient();\n+\n+        log.debug(\"Start twin and set handler to receive \\\"targetTemperature\\\" updates.\");\n+        deviceClient.startDeviceTwin(new TwinIotHubEventCallback(), null, new TargetTemperatureUpdateCallback(), null);\n+        Map<Property, Pair<TwinPropertyCallBack, Object>> desiredPropertyUpdateCallback =\n+                Collections.singletonMap(\n+                        new Property(\"targetTemperature\", null),\n+                        new Pair<TwinPropertyCallBack, Object>(new TargetTemperatureUpdateCallback(), null));\n+        deviceClient.subscribeToTwinDesiredProperties(desiredPropertyUpdateCallback);\n+\n+        log.debug(\"Set handler to receive \\\"getMaxMinReport\\\" command.\");\n+        String methodName = \"getMaxMinReport\";\n+        deviceClient.subscribeToDeviceMethod(new GetMaxMinReportMethodCallback(), methodName, new MethodIotHubEventCallback(), methodName);\n+\n+        new Thread(new Runnable() {\n+            @SneakyThrows(InterruptedException.class)\n+            @Override\n+            public void run() {\n+                while (true) {\n+                    if (temperatureReset) {\n+                        // Generate a random value between 5.0\u00b0C and 45.0\u00b0C for the current temperature reading.\n+                        temperature = BigDecimal.valueOf(random.nextDouble() * 40 + 5).setScale(1, RoundingMode.HALF_UP).doubleValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c93671ae42d61410db1b39aa1a75617df8bf0b87"}, "originalPosition": 86}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMzk0NjI3", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/840#pullrequestreview-443394627", "createdAt": "2020-07-06T20:44:00Z", "commit": {"oid": "c93671ae42d61410db1b39aa1a75617df8bf0b87"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMDo0NDowMFrOGtmesA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMDo0NDowMFrOGtmesA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ2OTU1Mg==", "bodyText": "This call is required explicitly for java SDK", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/840#discussion_r450469552", "createdAt": "2020-07-06T20:44:00Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-samples/pnp-device-sample/Thermostat/src/main/java/samples/com/microsoft/azure/sdk/iot/Thermostat.java", "diffHunk": "@@ -0,0 +1,317 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonObject;\n+import com.google.gson.annotations.SerializedName;\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.AllArgsConstructor;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.*;\n+\n+@Slf4j\n+public class Thermostat {\n+\n+    public enum StatusCode {\n+        COMPLETED (200),\n+        IN_PROGRESS (202),\n+        NOT_FOUND (404);\n+\n+        private final int value;\n+        StatusCode(int value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    private static final String deviceConnectionString = System.getenv(\"IOTHUB_DEVICE_CONNECTION_STRING\");\n+    private static final String MODEL_ID = \"dtmi:com:example:Thermostat;1\";\n+\n+    // Plug and play features are available over either MQTT or MQTT_WS.\n+    private static final IotHubClientProtocol protocol = IotHubClientProtocol.MQTT;\n+\n+    private static final Random random = new Random();\n+    private static final Map<Date, Double> temperatureReadings = new HashMap<>();\n+\n+    private static DeviceClient deviceClient;\n+    private static double temperature = 0.0d;\n+    private static double maxTemperature = 0.0d;\n+    private static boolean temperatureReset = true;\n+\n+    public static void main(String[] args) throws URISyntaxException, IOException {\n+\n+        // This sample follows the following workflow:\n+        // -> Initialize device client instance.\n+        // -> Set handler to receive \"targetTemperature\" updates, and send the received update over reported property.\n+        // -> Set handler to receive \"getMaxMinReport\" command, and send the generated report as command response.\n+        // -> Periodically send \"temperature\" over telemetry.\n+        // -> Send \"maxTempSinceLastReboot\" over property update, when a new max temperature is set.\n+\n+        log.debug(\"Initialize the device client.\");\n+        initializeDeviceClient();\n+\n+        log.debug(\"Start twin and set handler to receive \\\"targetTemperature\\\" updates.\");\n+        deviceClient.startDeviceTwin(new TwinIotHubEventCallback(), null, new TargetTemperatureUpdateCallback(), null);\n+        Map<Property, Pair<TwinPropertyCallBack, Object>> desiredPropertyUpdateCallback =\n+                Collections.singletonMap(\n+                        new Property(\"targetTemperature\", null),\n+                        new Pair<TwinPropertyCallBack, Object>(new TargetTemperatureUpdateCallback(), null));\n+        deviceClient.subscribeToTwinDesiredProperties(desiredPropertyUpdateCallback);\n+\n+        log.debug(\"Set handler to receive \\\"getMaxMinReport\\\" command.\");\n+        String methodName = \"getMaxMinReport\";\n+        deviceClient.subscribeToDeviceMethod(new GetMaxMinReportMethodCallback(), methodName, new MethodIotHubEventCallback(), methodName);\n+\n+        new Thread(new Runnable() {\n+            @SneakyThrows(InterruptedException.class)\n+            @Override\n+            public void run() {\n+                while (true) {\n+                    if (temperatureReset) {\n+                        // Generate a random value between 5.0\u00b0C and 45.0\u00b0C for the current temperature reading.\n+                        temperature = BigDecimal.valueOf(random.nextDouble() * 40 + 5).setScale(1, RoundingMode.HALF_UP).doubleValue();\n+                        temperatureReset = false;\n+                    }\n+\n+                    try {\n+                        sendTemperatureReading();\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(\"IOException when sending reported property update: \", e);\n+                    }\n+\n+                    Thread.sleep(5 * 1000);\n+                }\n+            }\n+        }).start();\n+    }\n+\n+    /**\n+     * Initialize the device client instance over Mqtt protocol, setting the ModelId into ClientOptions.\n+     * This method also sets a connection status change callback, that will get triggered any time the device's connection status changes.\n+     */\n+    private static void initializeDeviceClient() throws URISyntaxException, IOException {\n+        ClientOptions options = new ClientOptions();\n+        options.setModelId(MODEL_ID);\n+        deviceClient = new DeviceClient(deviceConnectionString, protocol, options);\n+\n+        deviceClient.registerConnectionStatusChangeCallback(new IotHubConnectionStatusChangeCallback() {\n+            @Override\n+            public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext) {\n+                log.debug(\"Connection status change registered: status={}, reason={}\", status, statusChangeReason);\n+\n+                if (throwable != null) {\n+                    log.debug(\"The connection status change was caused by the following Throwable: {}\", throwable.getMessage());\n+                    throwable.printStackTrace();\n+                }\n+            }\n+        }, deviceClient);\n+\n+        deviceClient.open();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c93671ae42d61410db1b39aa1a75617df8bf0b87"}, "originalPosition": 123}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMzk1MTM4", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/840#pullrequestreview-443395138", "createdAt": "2020-07-06T20:44:50Z", "commit": {"oid": "c93671ae42d61410db1b39aa1a75617df8bf0b87"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMDo0NDo1MFrOGtmgPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMDo0NDo1MFrOGtmgPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ2OTk1MA==", "bodyText": "data type to store the embedded property update object.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/840#discussion_r450469950", "createdAt": "2020-07-06T20:44:50Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-samples/pnp-device-sample/Thermostat/src/main/java/samples/com/microsoft/azure/sdk/iot/Thermostat.java", "diffHunk": "@@ -0,0 +1,317 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonObject;\n+import com.google.gson.annotations.SerializedName;\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.AllArgsConstructor;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.*;\n+\n+@Slf4j\n+public class Thermostat {\n+\n+    public enum StatusCode {\n+        COMPLETED (200),\n+        IN_PROGRESS (202),\n+        NOT_FOUND (404);\n+\n+        private final int value;\n+        StatusCode(int value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    private static final String deviceConnectionString = System.getenv(\"IOTHUB_DEVICE_CONNECTION_STRING\");\n+    private static final String MODEL_ID = \"dtmi:com:example:Thermostat;1\";\n+\n+    // Plug and play features are available over either MQTT or MQTT_WS.\n+    private static final IotHubClientProtocol protocol = IotHubClientProtocol.MQTT;\n+\n+    private static final Random random = new Random();\n+    private static final Map<Date, Double> temperatureReadings = new HashMap<>();\n+\n+    private static DeviceClient deviceClient;\n+    private static double temperature = 0.0d;\n+    private static double maxTemperature = 0.0d;\n+    private static boolean temperatureReset = true;\n+\n+    public static void main(String[] args) throws URISyntaxException, IOException {\n+\n+        // This sample follows the following workflow:\n+        // -> Initialize device client instance.\n+        // -> Set handler to receive \"targetTemperature\" updates, and send the received update over reported property.\n+        // -> Set handler to receive \"getMaxMinReport\" command, and send the generated report as command response.\n+        // -> Periodically send \"temperature\" over telemetry.\n+        // -> Send \"maxTempSinceLastReboot\" over property update, when a new max temperature is set.\n+\n+        log.debug(\"Initialize the device client.\");\n+        initializeDeviceClient();\n+\n+        log.debug(\"Start twin and set handler to receive \\\"targetTemperature\\\" updates.\");\n+        deviceClient.startDeviceTwin(new TwinIotHubEventCallback(), null, new TargetTemperatureUpdateCallback(), null);\n+        Map<Property, Pair<TwinPropertyCallBack, Object>> desiredPropertyUpdateCallback =\n+                Collections.singletonMap(\n+                        new Property(\"targetTemperature\", null),\n+                        new Pair<TwinPropertyCallBack, Object>(new TargetTemperatureUpdateCallback(), null));\n+        deviceClient.subscribeToTwinDesiredProperties(desiredPropertyUpdateCallback);\n+\n+        log.debug(\"Set handler to receive \\\"getMaxMinReport\\\" command.\");\n+        String methodName = \"getMaxMinReport\";\n+        deviceClient.subscribeToDeviceMethod(new GetMaxMinReportMethodCallback(), methodName, new MethodIotHubEventCallback(), methodName);\n+\n+        new Thread(new Runnable() {\n+            @SneakyThrows(InterruptedException.class)\n+            @Override\n+            public void run() {\n+                while (true) {\n+                    if (temperatureReset) {\n+                        // Generate a random value between 5.0\u00b0C and 45.0\u00b0C for the current temperature reading.\n+                        temperature = BigDecimal.valueOf(random.nextDouble() * 40 + 5).setScale(1, RoundingMode.HALF_UP).doubleValue();\n+                        temperatureReset = false;\n+                    }\n+\n+                    try {\n+                        sendTemperatureReading();\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(\"IOException when sending reported property update: \", e);\n+                    }\n+\n+                    Thread.sleep(5 * 1000);\n+                }\n+            }\n+        }).start();\n+    }\n+\n+    /**\n+     * Initialize the device client instance over Mqtt protocol, setting the ModelId into ClientOptions.\n+     * This method also sets a connection status change callback, that will get triggered any time the device's connection status changes.\n+     */\n+    private static void initializeDeviceClient() throws URISyntaxException, IOException {\n+        ClientOptions options = new ClientOptions();\n+        options.setModelId(MODEL_ID);\n+        deviceClient = new DeviceClient(deviceConnectionString, protocol, options);\n+\n+        deviceClient.registerConnectionStatusChangeCallback(new IotHubConnectionStatusChangeCallback() {\n+            @Override\n+            public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext) {\n+                log.debug(\"Connection status change registered: status={}, reason={}\", status, statusChangeReason);\n+\n+                if (throwable != null) {\n+                    log.debug(\"The connection status change was caused by the following Throwable: {}\", throwable.getMessage());\n+                    throwable.printStackTrace();\n+                }\n+            }\n+        }, deviceClient);\n+\n+        deviceClient.open();\n+    }\n+\n+    /**\n+     * The desired property update callback, which receives the target temperature as a desired property update,\n+     * and updates the current temperature value over telemetry and reported property update.\n+     */\n+    private static class TargetTemperatureUpdateCallback implements TwinPropertyCallBack {\n+\n+        String propertyName = \"targetTemperature\";\n+\n+        @SneakyThrows(InterruptedException.class)\n+        @Override\n+        public void TwinPropertyCallBack(Property property, Object context) {\n+            if (property.getKey().equalsIgnoreCase(propertyName)) {\n+                double targetTemperature = ((Number)property.getValue()).doubleValue();\n+                log.debug(\"Property: Received - {\\\"{}\\\": {}\u00b0C}.\", propertyName, targetTemperature);\n+\n+                EmbeddedPropertyUpdate pendingUpdate = new EmbeddedPropertyUpdate(targetTemperature, StatusCode.IN_PROGRESS.value, property.getVersion(), null);\n+                Property reportedPropertyPending = new Property(propertyName, pendingUpdate);\n+                try {\n+                    deviceClient.sendReportedProperties(Collections.singleton(reportedPropertyPending));\n+                } catch (IOException e) {\n+                    throw new RuntimeException(\"IOException when sending reported property update: \", e);\n+                }\n+                log.debug(\"Property: Update - {\\\"{}\\\": {}\u00b0C} is {}\", propertyName, targetTemperature, StatusCode.IN_PROGRESS);\n+\n+                // Update temperature in 2 steps\n+                double step = (targetTemperature - temperature) / 2;\n+                for (int i = 1; i <=2; i++) {\n+                    temperature = BigDecimal.valueOf(temperature + step).setScale(1, RoundingMode.HALF_UP).doubleValue();\n+                    Thread.sleep(5 * 1000);\n+                }\n+\n+                EmbeddedPropertyUpdate completedUpdate = new EmbeddedPropertyUpdate(temperature, StatusCode.COMPLETED.value, property.getVersion(), \"Successfully updated target temperature\");\n+                Property reportedPropertyCompleted = new Property(propertyName, completedUpdate);\n+                try {\n+                    deviceClient.sendReportedProperties(Collections.singleton(reportedPropertyCompleted));\n+                } catch (IOException e) {\n+                    throw new RuntimeException(\"IOException when sending reported property update: \", e);\n+                }\n+                log.debug(\"Property: Update - {\\\"{}\\\": {}\u00b0C} is {}\", propertyName, temperature, StatusCode.COMPLETED);\n+            } else {\n+                log.debug(\"Property: Received an unrecognized property update from service.\");\n+            }\n+        }\n+    }\n+\n+    @AllArgsConstructor\n+    private static class EmbeddedPropertyUpdate {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c93671ae42d61410db1b39aa1a75617df8bf0b87"}, "originalPosition": 172}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMzk1NTg1", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/840#pullrequestreview-443395585", "createdAt": "2020-07-06T20:45:36Z", "commit": {"oid": "c93671ae42d61410db1b39aa1a75617df8bf0b87"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMDo0NTozN1rOGtmhww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMDo0NTozN1rOGtmhww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ3MDMzOQ==", "bodyText": "@timtay-microsoft Is there an easier/ better way to do this parsing in java?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/840#discussion_r450470339", "createdAt": "2020-07-06T20:45:37Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-samples/pnp-device-sample/Thermostat/src/main/java/samples/com/microsoft/azure/sdk/iot/Thermostat.java", "diffHunk": "@@ -0,0 +1,317 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonObject;\n+import com.google.gson.annotations.SerializedName;\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.AllArgsConstructor;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.*;\n+\n+@Slf4j\n+public class Thermostat {\n+\n+    public enum StatusCode {\n+        COMPLETED (200),\n+        IN_PROGRESS (202),\n+        NOT_FOUND (404);\n+\n+        private final int value;\n+        StatusCode(int value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    private static final String deviceConnectionString = System.getenv(\"IOTHUB_DEVICE_CONNECTION_STRING\");\n+    private static final String MODEL_ID = \"dtmi:com:example:Thermostat;1\";\n+\n+    // Plug and play features are available over either MQTT or MQTT_WS.\n+    private static final IotHubClientProtocol protocol = IotHubClientProtocol.MQTT;\n+\n+    private static final Random random = new Random();\n+    private static final Map<Date, Double> temperatureReadings = new HashMap<>();\n+\n+    private static DeviceClient deviceClient;\n+    private static double temperature = 0.0d;\n+    private static double maxTemperature = 0.0d;\n+    private static boolean temperatureReset = true;\n+\n+    public static void main(String[] args) throws URISyntaxException, IOException {\n+\n+        // This sample follows the following workflow:\n+        // -> Initialize device client instance.\n+        // -> Set handler to receive \"targetTemperature\" updates, and send the received update over reported property.\n+        // -> Set handler to receive \"getMaxMinReport\" command, and send the generated report as command response.\n+        // -> Periodically send \"temperature\" over telemetry.\n+        // -> Send \"maxTempSinceLastReboot\" over property update, when a new max temperature is set.\n+\n+        log.debug(\"Initialize the device client.\");\n+        initializeDeviceClient();\n+\n+        log.debug(\"Start twin and set handler to receive \\\"targetTemperature\\\" updates.\");\n+        deviceClient.startDeviceTwin(new TwinIotHubEventCallback(), null, new TargetTemperatureUpdateCallback(), null);\n+        Map<Property, Pair<TwinPropertyCallBack, Object>> desiredPropertyUpdateCallback =\n+                Collections.singletonMap(\n+                        new Property(\"targetTemperature\", null),\n+                        new Pair<TwinPropertyCallBack, Object>(new TargetTemperatureUpdateCallback(), null));\n+        deviceClient.subscribeToTwinDesiredProperties(desiredPropertyUpdateCallback);\n+\n+        log.debug(\"Set handler to receive \\\"getMaxMinReport\\\" command.\");\n+        String methodName = \"getMaxMinReport\";\n+        deviceClient.subscribeToDeviceMethod(new GetMaxMinReportMethodCallback(), methodName, new MethodIotHubEventCallback(), methodName);\n+\n+        new Thread(new Runnable() {\n+            @SneakyThrows(InterruptedException.class)\n+            @Override\n+            public void run() {\n+                while (true) {\n+                    if (temperatureReset) {\n+                        // Generate a random value between 5.0\u00b0C and 45.0\u00b0C for the current temperature reading.\n+                        temperature = BigDecimal.valueOf(random.nextDouble() * 40 + 5).setScale(1, RoundingMode.HALF_UP).doubleValue();\n+                        temperatureReset = false;\n+                    }\n+\n+                    try {\n+                        sendTemperatureReading();\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(\"IOException when sending reported property update: \", e);\n+                    }\n+\n+                    Thread.sleep(5 * 1000);\n+                }\n+            }\n+        }).start();\n+    }\n+\n+    /**\n+     * Initialize the device client instance over Mqtt protocol, setting the ModelId into ClientOptions.\n+     * This method also sets a connection status change callback, that will get triggered any time the device's connection status changes.\n+     */\n+    private static void initializeDeviceClient() throws URISyntaxException, IOException {\n+        ClientOptions options = new ClientOptions();\n+        options.setModelId(MODEL_ID);\n+        deviceClient = new DeviceClient(deviceConnectionString, protocol, options);\n+\n+        deviceClient.registerConnectionStatusChangeCallback(new IotHubConnectionStatusChangeCallback() {\n+            @Override\n+            public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext) {\n+                log.debug(\"Connection status change registered: status={}, reason={}\", status, statusChangeReason);\n+\n+                if (throwable != null) {\n+                    log.debug(\"The connection status change was caused by the following Throwable: {}\", throwable.getMessage());\n+                    throwable.printStackTrace();\n+                }\n+            }\n+        }, deviceClient);\n+\n+        deviceClient.open();\n+    }\n+\n+    /**\n+     * The desired property update callback, which receives the target temperature as a desired property update,\n+     * and updates the current temperature value over telemetry and reported property update.\n+     */\n+    private static class TargetTemperatureUpdateCallback implements TwinPropertyCallBack {\n+\n+        String propertyName = \"targetTemperature\";\n+\n+        @SneakyThrows(InterruptedException.class)\n+        @Override\n+        public void TwinPropertyCallBack(Property property, Object context) {\n+            if (property.getKey().equalsIgnoreCase(propertyName)) {\n+                double targetTemperature = ((Number)property.getValue()).doubleValue();\n+                log.debug(\"Property: Received - {\\\"{}\\\": {}\u00b0C}.\", propertyName, targetTemperature);\n+\n+                EmbeddedPropertyUpdate pendingUpdate = new EmbeddedPropertyUpdate(targetTemperature, StatusCode.IN_PROGRESS.value, property.getVersion(), null);\n+                Property reportedPropertyPending = new Property(propertyName, pendingUpdate);\n+                try {\n+                    deviceClient.sendReportedProperties(Collections.singleton(reportedPropertyPending));\n+                } catch (IOException e) {\n+                    throw new RuntimeException(\"IOException when sending reported property update: \", e);\n+                }\n+                log.debug(\"Property: Update - {\\\"{}\\\": {}\u00b0C} is {}\", propertyName, targetTemperature, StatusCode.IN_PROGRESS);\n+\n+                // Update temperature in 2 steps\n+                double step = (targetTemperature - temperature) / 2;\n+                for (int i = 1; i <=2; i++) {\n+                    temperature = BigDecimal.valueOf(temperature + step).setScale(1, RoundingMode.HALF_UP).doubleValue();\n+                    Thread.sleep(5 * 1000);\n+                }\n+\n+                EmbeddedPropertyUpdate completedUpdate = new EmbeddedPropertyUpdate(temperature, StatusCode.COMPLETED.value, property.getVersion(), \"Successfully updated target temperature\");\n+                Property reportedPropertyCompleted = new Property(propertyName, completedUpdate);\n+                try {\n+                    deviceClient.sendReportedProperties(Collections.singleton(reportedPropertyCompleted));\n+                } catch (IOException e) {\n+                    throw new RuntimeException(\"IOException when sending reported property update: \", e);\n+                }\n+                log.debug(\"Property: Update - {\\\"{}\\\": {}\u00b0C} is {}\", propertyName, temperature, StatusCode.COMPLETED);\n+            } else {\n+                log.debug(\"Property: Received an unrecognized property update from service.\");\n+            }\n+        }\n+    }\n+\n+    @AllArgsConstructor\n+    private static class EmbeddedPropertyUpdate {\n+        @NonNull\n+        @SerializedName(\"value\")\n+        public Object value;\n+        @NonNull\n+        @SerializedName(\"ac\")\n+        public Integer ackCode;\n+        @NonNull\n+        @SerializedName(\"av\")\n+        public Integer ackVersion;\n+        @SerializedName(\"ad\")\n+        public String ackDescription;\n+    }\n+\n+    /**\n+     * The callback to handle \"getMaxMinReport\" command.\n+     * This method will returns the max, min and average temperature from the specified time to the current time.\n+     */\n+    private static class GetMaxMinReportMethodCallback implements DeviceMethodCallback {\n+        String commandName = \"getMaxMinReport\";\n+        String formatPattern = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\";\n+\n+        @SneakyThrows(ParseException.class)\n+        @Override\n+        public DeviceMethodData call(String methodName, Object methodData, Object context) {\n+            if (methodName.equalsIgnoreCase(commandName)) {\n+\n+                String jsonRequest = new String((byte[]) methodData, StandardCharsets.UTF_8);\n+                JsonObject jsonObject = new Gson().fromJson(jsonRequest, JsonObject.class);\n+                String sinceString = jsonObject.get(\"commandRequest\").getAsJsonObject().get(\"value\").getAsString();\n+\n+                DateFormat format = new SimpleDateFormat(formatPattern);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c93671ae42d61410db1b39aa1a75617df8bf0b87"}, "originalPosition": 203}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMzk2MDM4", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/840#pullrequestreview-443396038", "createdAt": "2020-07-06T20:46:18Z", "commit": {"oid": "c93671ae42d61410db1b39aa1a75617df8bf0b87"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMDo0NjoxOFrOGtmjIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMDo0NjoxOFrOGtmjIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ3MDY5MA==", "bodyText": "I wish we supported Java 8+, we could then use Streams. In the absence of that, we are stuck with implementing this logic manually.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/840#discussion_r450470690", "createdAt": "2020-07-06T20:46:18Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-samples/pnp-device-sample/Thermostat/src/main/java/samples/com/microsoft/azure/sdk/iot/Thermostat.java", "diffHunk": "@@ -0,0 +1,317 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonObject;\n+import com.google.gson.annotations.SerializedName;\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.AllArgsConstructor;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.*;\n+\n+@Slf4j\n+public class Thermostat {\n+\n+    public enum StatusCode {\n+        COMPLETED (200),\n+        IN_PROGRESS (202),\n+        NOT_FOUND (404);\n+\n+        private final int value;\n+        StatusCode(int value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    private static final String deviceConnectionString = System.getenv(\"IOTHUB_DEVICE_CONNECTION_STRING\");\n+    private static final String MODEL_ID = \"dtmi:com:example:Thermostat;1\";\n+\n+    // Plug and play features are available over either MQTT or MQTT_WS.\n+    private static final IotHubClientProtocol protocol = IotHubClientProtocol.MQTT;\n+\n+    private static final Random random = new Random();\n+    private static final Map<Date, Double> temperatureReadings = new HashMap<>();\n+\n+    private static DeviceClient deviceClient;\n+    private static double temperature = 0.0d;\n+    private static double maxTemperature = 0.0d;\n+    private static boolean temperatureReset = true;\n+\n+    public static void main(String[] args) throws URISyntaxException, IOException {\n+\n+        // This sample follows the following workflow:\n+        // -> Initialize device client instance.\n+        // -> Set handler to receive \"targetTemperature\" updates, and send the received update over reported property.\n+        // -> Set handler to receive \"getMaxMinReport\" command, and send the generated report as command response.\n+        // -> Periodically send \"temperature\" over telemetry.\n+        // -> Send \"maxTempSinceLastReboot\" over property update, when a new max temperature is set.\n+\n+        log.debug(\"Initialize the device client.\");\n+        initializeDeviceClient();\n+\n+        log.debug(\"Start twin and set handler to receive \\\"targetTemperature\\\" updates.\");\n+        deviceClient.startDeviceTwin(new TwinIotHubEventCallback(), null, new TargetTemperatureUpdateCallback(), null);\n+        Map<Property, Pair<TwinPropertyCallBack, Object>> desiredPropertyUpdateCallback =\n+                Collections.singletonMap(\n+                        new Property(\"targetTemperature\", null),\n+                        new Pair<TwinPropertyCallBack, Object>(new TargetTemperatureUpdateCallback(), null));\n+        deviceClient.subscribeToTwinDesiredProperties(desiredPropertyUpdateCallback);\n+\n+        log.debug(\"Set handler to receive \\\"getMaxMinReport\\\" command.\");\n+        String methodName = \"getMaxMinReport\";\n+        deviceClient.subscribeToDeviceMethod(new GetMaxMinReportMethodCallback(), methodName, new MethodIotHubEventCallback(), methodName);\n+\n+        new Thread(new Runnable() {\n+            @SneakyThrows(InterruptedException.class)\n+            @Override\n+            public void run() {\n+                while (true) {\n+                    if (temperatureReset) {\n+                        // Generate a random value between 5.0\u00b0C and 45.0\u00b0C for the current temperature reading.\n+                        temperature = BigDecimal.valueOf(random.nextDouble() * 40 + 5).setScale(1, RoundingMode.HALF_UP).doubleValue();\n+                        temperatureReset = false;\n+                    }\n+\n+                    try {\n+                        sendTemperatureReading();\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(\"IOException when sending reported property update: \", e);\n+                    }\n+\n+                    Thread.sleep(5 * 1000);\n+                }\n+            }\n+        }).start();\n+    }\n+\n+    /**\n+     * Initialize the device client instance over Mqtt protocol, setting the ModelId into ClientOptions.\n+     * This method also sets a connection status change callback, that will get triggered any time the device's connection status changes.\n+     */\n+    private static void initializeDeviceClient() throws URISyntaxException, IOException {\n+        ClientOptions options = new ClientOptions();\n+        options.setModelId(MODEL_ID);\n+        deviceClient = new DeviceClient(deviceConnectionString, protocol, options);\n+\n+        deviceClient.registerConnectionStatusChangeCallback(new IotHubConnectionStatusChangeCallback() {\n+            @Override\n+            public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext) {\n+                log.debug(\"Connection status change registered: status={}, reason={}\", status, statusChangeReason);\n+\n+                if (throwable != null) {\n+                    log.debug(\"The connection status change was caused by the following Throwable: {}\", throwable.getMessage());\n+                    throwable.printStackTrace();\n+                }\n+            }\n+        }, deviceClient);\n+\n+        deviceClient.open();\n+    }\n+\n+    /**\n+     * The desired property update callback, which receives the target temperature as a desired property update,\n+     * and updates the current temperature value over telemetry and reported property update.\n+     */\n+    private static class TargetTemperatureUpdateCallback implements TwinPropertyCallBack {\n+\n+        String propertyName = \"targetTemperature\";\n+\n+        @SneakyThrows(InterruptedException.class)\n+        @Override\n+        public void TwinPropertyCallBack(Property property, Object context) {\n+            if (property.getKey().equalsIgnoreCase(propertyName)) {\n+                double targetTemperature = ((Number)property.getValue()).doubleValue();\n+                log.debug(\"Property: Received - {\\\"{}\\\": {}\u00b0C}.\", propertyName, targetTemperature);\n+\n+                EmbeddedPropertyUpdate pendingUpdate = new EmbeddedPropertyUpdate(targetTemperature, StatusCode.IN_PROGRESS.value, property.getVersion(), null);\n+                Property reportedPropertyPending = new Property(propertyName, pendingUpdate);\n+                try {\n+                    deviceClient.sendReportedProperties(Collections.singleton(reportedPropertyPending));\n+                } catch (IOException e) {\n+                    throw new RuntimeException(\"IOException when sending reported property update: \", e);\n+                }\n+                log.debug(\"Property: Update - {\\\"{}\\\": {}\u00b0C} is {}\", propertyName, targetTemperature, StatusCode.IN_PROGRESS);\n+\n+                // Update temperature in 2 steps\n+                double step = (targetTemperature - temperature) / 2;\n+                for (int i = 1; i <=2; i++) {\n+                    temperature = BigDecimal.valueOf(temperature + step).setScale(1, RoundingMode.HALF_UP).doubleValue();\n+                    Thread.sleep(5 * 1000);\n+                }\n+\n+                EmbeddedPropertyUpdate completedUpdate = new EmbeddedPropertyUpdate(temperature, StatusCode.COMPLETED.value, property.getVersion(), \"Successfully updated target temperature\");\n+                Property reportedPropertyCompleted = new Property(propertyName, completedUpdate);\n+                try {\n+                    deviceClient.sendReportedProperties(Collections.singleton(reportedPropertyCompleted));\n+                } catch (IOException e) {\n+                    throw new RuntimeException(\"IOException when sending reported property update: \", e);\n+                }\n+                log.debug(\"Property: Update - {\\\"{}\\\": {}\u00b0C} is {}\", propertyName, temperature, StatusCode.COMPLETED);\n+            } else {\n+                log.debug(\"Property: Received an unrecognized property update from service.\");\n+            }\n+        }\n+    }\n+\n+    @AllArgsConstructor\n+    private static class EmbeddedPropertyUpdate {\n+        @NonNull\n+        @SerializedName(\"value\")\n+        public Object value;\n+        @NonNull\n+        @SerializedName(\"ac\")\n+        public Integer ackCode;\n+        @NonNull\n+        @SerializedName(\"av\")\n+        public Integer ackVersion;\n+        @SerializedName(\"ad\")\n+        public String ackDescription;\n+    }\n+\n+    /**\n+     * The callback to handle \"getMaxMinReport\" command.\n+     * This method will returns the max, min and average temperature from the specified time to the current time.\n+     */\n+    private static class GetMaxMinReportMethodCallback implements DeviceMethodCallback {\n+        String commandName = \"getMaxMinReport\";\n+        String formatPattern = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\";\n+\n+        @SneakyThrows(ParseException.class)\n+        @Override\n+        public DeviceMethodData call(String methodName, Object methodData, Object context) {\n+            if (methodName.equalsIgnoreCase(commandName)) {\n+\n+                String jsonRequest = new String((byte[]) methodData, StandardCharsets.UTF_8);\n+                JsonObject jsonObject = new Gson().fromJson(jsonRequest, JsonObject.class);\n+                String sinceString = jsonObject.get(\"commandRequest\").getAsJsonObject().get(\"value\").getAsString();\n+\n+                DateFormat format = new SimpleDateFormat(formatPattern);\n+                Date since = format.parse(sinceString);\n+                log.debug(\"Command: Received - Generating min, max, avg temperature report since {}.\", since);\n+\n+                double runningTotal = 0;\n+                Map<Date, Double> filteredReadings = new HashMap<>();\n+                for (Map.Entry<Date, Double> entry : temperatureReadings.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c93671ae42d61410db1b39aa1a75617df8bf0b87"}, "originalPosition": 209}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a7713e7e90765068af7291568aa8696ceaaed13", "author": {"user": {"login": "abhipsaMisra", "name": "Abhipsa Misra"}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/1a7713e7e90765068af7291568aa8696ceaaed13", "committedDate": "2020-07-06T21:00:32Z", "message": "fix formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ae49478a89835766e8bcdba991c9d7bbef8d78a", "author": {"user": {"login": "abhipsaMisra", "name": "Abhipsa Misra"}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/8ae49478a89835766e8bcdba991c9d7bbef8d78a", "committedDate": "2020-07-06T22:12:13Z", "message": "add comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNDQzODQ2", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/840#pullrequestreview-443443846", "createdAt": "2020-07-06T22:22:02Z", "commit": {"oid": "8ae49478a89835766e8bcdba991c9d7bbef8d78a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMjoyMjowMlrOGto8Lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMjoyMjowMlrOGto8Lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUwOTg3MA==", "bodyText": "Thanks for including the logging config! Looks good", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/840#discussion_r450509870", "createdAt": "2020-07-06T22:22:02Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-samples/pnp-device-sample/TemperatureController/src/main/resources/log4j.properties", "diffHunk": "@@ -0,0 +1,11 @@\n+# Root logger option\n+log4j.rootLogger=ERROR, stdout\n+\n+# Direct log messages to stdout\n+log4j.appender.stdout=org.apache.log4j.ConsoleAppender\n+log4j.appender.stdout.Target=System.out\n+log4j.appender.stdout.layout=org.apache.log4j.PatternLayout\n+log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss.SSS} %-5p %c{1}:%L - %m%n\n+\n+log4j.logger.com.microsoft.azure.sdk.iot.device = DEBUG\n+log4j.logger.samples.com.microsoft.azure.sdk.iot = DEBUG", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ae49478a89835766e8bcdba991c9d7bbef8d78a"}, "originalPosition": 11}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNDQ2MzY3", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/840#pullrequestreview-443446367", "createdAt": "2020-07-06T22:28:31Z", "commit": {"oid": "8ae49478a89835766e8bcdba991c9d7bbef8d78a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1722, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}