{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk0MzQ0ODQ1", "number": 939, "title": "feat(iot-dev): Add multiplexing client that supports device registration/unregistration during open connection", "bodyText": "TransportClient was our multiplexing client, but there was no way to add the ability to add/remove devices from an active connection without breaking the APIs in that class, so this deprecates the transport client in favor of a new MultiplexingClient.\nSignificant changes had to made to the IotHubTransport layer so that each multiplexed client could have its own connection state and so that each multiplexed client could have its own focused retry logic. Instead of closing the entire multiplexed connection every time a session drops, the transport layer can re-open individual device sessions", "createdAt": "2020-09-28T19:08:34Z", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939", "merged": true, "mergeCommit": {"oid": "fe377ac01d143e3bfa2f00d0433ffcc1f3831f6d"}, "closed": true, "closedAt": "2020-11-15T20:51:24Z", "author": {"login": "timtay-microsoft"}, "timelineItems": {"totalCount": 80, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdNYeKVgBqjM4MTYwNTg5ODI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdcQN1_gH2gAyNDk0MzQ0ODQ1OmMzNWY4NzM2YmRmY2FjNzRlMTNmM2M4YjQ2ZTRlZDVkYTQ5YWQ2Nzc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b3af1714e725851384ae1224870173c8e327a2b9", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/b3af1714e725851384ae1224870173c8e327a2b9", "committedDate": "2020-09-28T19:07:25Z", "message": "feat(iot-dev): Add multiplexing client that supports device registration/unregistration during open connection\n\nTransportClient was our multiplexing client, but there was no way to add the ability to add/remove devices from an active connection without breaking the APIs in that class, so this deprecates the transport client in favor of a new MultiplexingClient.\n\nSignificant changes had to made to the IotHubTransport layer so that each multiplexed client could have its own connection state and so that each multiplexed client could have its own focused retry logic. Instead of closing the entire multiplexed connection every time a session drops, the transport layer can re-open individual device sessions"}, "afterCommit": {"oid": "37cf09f06e4d70e77218a44de91cab8a6d7cae67", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/37cf09f06e4d70e77218a44de91cab8a6d7cae67", "committedDate": "2020-09-28T19:08:49Z", "message": "feat(iot-dev): Add multiplexing client that supports device registration/unregistration during open connection\n\nTransportClient was our multiplexing client, but there was no way to add the ability to add/remove devices from an active connection without breaking the APIs in that class, so this deprecates the transport client in favor of a new MultiplexingClient.\n\nSignificant changes had to made to the IotHubTransport layer so that each multiplexed client could have its own connection state and so that each multiplexed client could have its own focused retry logic. Instead of closing the entire multiplexed connection every time a session drops, the transport layer can re-open individual device sessions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMTgyNzA2", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-520182706", "createdAt": "2020-10-30T00:05:07Z", "commit": {"oid": "a0104b7933f8b17190eac935c591375f74af08e9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMDowNTowN1rOHqy2uA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMDowNTowN1rOHqy2uA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzNTQ0OA==", "bodyText": "Might as well make this string a constant instead of repeating it.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r514635448", "createdAt": "2020-10-30T00:05:07Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceClient.java", "diffHunk": "@@ -376,6 +376,11 @@ private void commonConstructorVerifications() throws UnsupportedOperationExcepti\n      */\n     public void open() throws IOException\n     {\n+        if (this.ioTHubConnectionType == IoTHubConnectionType.USE_MULTIPLEXING_CLIENT)\n+        {\n+            throw new UnsupportedOperationException(\"Cannot open a multiplexed client through this method. Must use multiplexingClient.registerDeviceClient(deviceClient)\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0104b7933f8b17190eac935c591375f74af08e9"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMTgzOTA5", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-520183909", "createdAt": "2020-10-30T00:06:01Z", "commit": {"oid": "a0104b7933f8b17190eac935c591375f74af08e9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMDowNjowMVrOHqy3vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMDowNjowMVrOHqy3vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzNTcxMQ==", "bodyText": "\"; abandoning it.\"", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r514635711", "createdAt": "2020-10-30T00:06:01Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceTwin/DeviceTwin.java", "diffHunk": "@@ -69,7 +69,7 @@ public IotHubMessageResult execute(Message message, Object callbackContext)\n                 IotHubStatusCode iotHubStatus = IotHubStatusCode.ERROR;\n                 if (message.getMessageType() != MessageType.DEVICE_TWIN)\n                 {\n-                    System.out.print(\"Unexpected message type received\");\n+                    log.warn(\"Unexpected message type received, abandoning it\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0104b7933f8b17190eac935c591375f74af08e9"}, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a0104b7933f8b17190eac935c591375f74af08e9", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/a0104b7933f8b17190eac935c591375f74af08e9", "committedDate": "2020-09-29T22:36:51Z", "message": "Update ThrottleResistantTestRule.java"}, "afterCommit": {"oid": "90c993b2808ae6ef6e3ae2b120a270c14539c8a2", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/90c993b2808ae6ef6e3ae2b120a270c14539c8a2", "committedDate": "2020-11-02T16:55:17Z", "message": "fixup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMDgzODk2", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522083896", "createdAt": "2020-11-02T22:43:41Z", "commit": {"oid": "6a88d33ab305b43dd56726bf57c89f98493fef30"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMjo0Mzo0MVrOHsYluA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMjo0Mzo0MVrOHsYluA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwMjI2NA==", "bodyText": "So we're marking this constructor as deprecated so users can use the MultiplexingClient instead. But isn't this true only for customers who want to use multiplexed connections? Wouldn't this still be useful to customers who don't want to use multiplexed connections?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516302264", "createdAt": "2020-11-02T22:43:41Z", "author": {"login": "barustum"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceClient.java", "diffHunk": "@@ -128,18 +129,19 @@\n      * RFC 3986 or if the provided {@code connString} is for an x509 authenticated device\n      * @throws URISyntaxException if the hostname in the connection string is not a valid URI\n      * @throws UnsupportedOperationException if the connection string belongs to a module rather than a device\n+     * @deprecated {@link MultiplexingClient} should be used instead of {@link TransportClient} for creating all multiplexed connections.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a88d33ab305b43dd56726bf57c89f98493fef30"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMDg0NTcy", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522084572", "createdAt": "2020-11-02T22:45:11Z", "commit": {"oid": "6a88d33ab305b43dd56726bf57c89f98493fef30"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMjo0NToxMVrOHsYpIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMjo0NToxMVrOHsYpIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwMzEzOA==", "bodyText": "add space after the double slash", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516303138", "createdAt": "2020-11-02T22:45:11Z", "author": {"login": "barustum"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceClient.java", "diffHunk": "@@ -668,6 +685,12 @@ public void subscribeToDeviceMethod(DeviceMethodCallback deviceMethodCallback, O\n         this.subscribeToMethodsInternal(deviceMethodCallback, deviceMethodCallbackContext, deviceMethodStatusCallback, deviceMethodStatusCallbackContext);\n     }\n \n+    //Used by multiplexing clients to signal to this client what kind of multiplexing client is using this device client", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a88d33ab305b43dd56726bf57c89f98493fef30"}, "originalPosition": 81}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMDkzNjQy", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522093642", "createdAt": "2020-11-02T23:04:21Z", "commit": {"oid": "3b3efe19125b1e9dc3ee1e0ca5a08bd070d837eb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMzowNDoyMVrOHsZTtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMzowNDoyMVrOHsZTtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMxNDAzNg==", "bodyText": "There really wasn't a good reason to have a list of configs or the protocol at this level. I've delegated that responsibility down to the transport connection since that layer actually needs the protocol value and configs", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516314036", "createdAt": "2020-11-02T23:04:21Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "diffHunk": "@@ -75,16 +77,13 @@\n     private long receivePeriodInMilliseconds;\n \n     private IotHubTransport transport;\n-    private DeviceClientConfig config;\n     private IotHubSendTask sendTask = null;\n     private IotHubReceiveTask receiveTask = null;\n-    private IotHubClientProtocol protocol = null;\n \n     private ScheduledExecutorService receiveTaskScheduler;\n     private ScheduledExecutorService sendTaskScheduler;\n     private IotHubConnectionStatus state;\n \n-    private List<DeviceClientConfig> deviceClientConfigs = new LinkedList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b3efe19125b1e9dc3ee1e0ca5a08bd070d837eb"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMDk0MDIz", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522094023", "createdAt": "2020-11-02T23:05:10Z", "commit": {"oid": "3b3efe19125b1e9dc3ee1e0ca5a08bd070d837eb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMzowNToxMFrOHsZVmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMzowNToxMFrOHsZVmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMxNDUyMQ==", "bodyText": "Totally unrelated to this PR, but thought I'd fix this since I saw it. Never use System.out.println from our library", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516314521", "createdAt": "2020-11-02T23:05:10Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceTwin/DeviceTwin.java", "diffHunk": "@@ -69,7 +69,7 @@ public IotHubMessageResult execute(Message message, Object callbackContext)\n                 IotHubStatusCode iotHubStatus = IotHubStatusCode.ERROR;\n                 if (message.getMessageType() != MessageType.DEVICE_TWIN)\n                 {\n-                    System.out.print(\"Unexpected message type received\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b3efe19125b1e9dc3ee1e0ca5a08bd070d837eb"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMDk4MDQ1", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522098045", "createdAt": "2020-11-02T23:14:07Z", "commit": {"oid": "3b3efe19125b1e9dc3ee1e0ca5a08bd070d837eb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMzoxNDowN1rOHsZscA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMzoxNDowN1rOHsZscA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMyMDM2OA==", "bodyText": "It never made sense that we defined the possibility of multiplexing in this interface considering only AMQP supports it, so I've removed it", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516320368", "createdAt": "2020-11-02T23:14:07Z", "author": {"login": "timtay-microsoft"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubTransportConnection.java", "diffHunk": "@@ -24,11 +24,9 @@\n {\n     /**\n      * Opens the transport connection object\n-     * @param deviceClientConfigs The list of configs to use. If more than 1 configs are in this list, multiplexing\n-     *                            will be used\n      * @throws TransportException If any exceptions are encountered while opening the connection\n      */\n-    void open(Queue<DeviceClientConfig> deviceClientConfigs) throws TransportException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b3efe19125b1e9dc3ee1e0ca5a08bd070d837eb"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMTAxNDg1", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522101485", "createdAt": "2020-11-02T23:22:11Z", "commit": {"oid": "3b3efe19125b1e9dc3ee1e0ca5a08bd070d837eb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMzoyMjoxMVrOHsaETQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMzoyMjoxMVrOHsaETQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMyNjQ3Nw==", "bodyText": "For the uninitiated, we use Fortify to scan for security vulnerabilities and other code smells. This file contains the false positives that Fortify complains about, but have manually been verified to be fine.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516326477", "createdAt": "2020-11-02T23:22:11Z", "author": {"login": "timtay-microsoft"}, "path": "vsts/fortify/filter.txt", "diffHunk": "@@ -189,4 +189,5 @@ E10238AE08E9048E3D0C0590CA43AC01\n EB88D40BFA36002BFBBC2D26501D5111\n 02BEB7B8FC297FE5C8110708272DA2B4\n 11F880EB6AEABBFF8CC1B0BC6A3FB21D\n-C5C6C2943C1AC9DF47725F75B2163020\n\\ No newline at end of file\n+C5C6C2943C1AC9DF47725F75B2163020\n+D9A3DBA80AB3999F4F8C1F1AA9E44B7B", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b3efe19125b1e9dc3ee1e0ca5a08bd070d837eb"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMTY0Mjgz", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522164283", "createdAt": "2020-11-03T03:00:30Z", "commit": {"oid": "ff1c610164699199f630b1379b8407d3dc6e44bb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMzowMDozMFrOHse0uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMzowMDozMFrOHse0uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwNDQwOQ==", "bodyText": "We should confirm with Avneet that 1000 devices is sufficient for the customers' requirements.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516404409", "createdAt": "2020-11-03T03:00:30Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        if (deviceClientList.size() < 1)\n+        {\n+            throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+        }\n+\n+        log.info(\"Opening multiplexing client\");\n+        this.deviceIO.open();\n+        log.info(\"Successfully opened multiplexing client\");\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        log.info(\"Closing multiplexing client\");\n+        for (DeviceClient deviceClient : this.deviceClientList)\n+        {\n+            deviceClient.closeFileUpload();\n+        }\n+\n+        if (this.deviceIO != null)\n+        {\n+            this.deviceIO.multiplexClose();\n+        }\n+\n+        log.info(\"Successfully closed multiplexing client\");\n+    }\n+\n+    /**\n+     * Add a device to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * Up to 1000 devices can be registered on a multiplexed AMQPS connection, and up to 500 devices can be registered on a\n+     * multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this is an asynchronous operation. You can track the state of your\n+     * device session using the {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     * That callback will execute once your device session has successfully been added to the existing multiplexed connection and\n+     * is ready to send telemetry.\n+     * <p>\n+     * Any proxy settings set to the provided device client will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client instance must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * The registered device client may have its own retry policy and its own SAS token expiry time, separate from every other multiplexed device.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If this device client is already registered, then this method will throw a {@link IllegalStateException}\n+     * <p>\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient)\n+    {\n+        Objects.requireNonNull(deviceClient);\n+\n+        for (DeviceClient currentClient : deviceClientList)\n+        {\n+            if (currentClient.getConfig().getDeviceId().equals(deviceClient.getConfig().getDeviceId()))\n+            {\n+                throw new IllegalStateException(\"Cannot register device client because a device client for that device identity has already been registered\");\n+            }\n+        }\n+\n+        if (deviceClient.getConfig().getAuthenticationType() != DeviceClientConfig.AuthType.SAS_TOKEN)\n+        {\n+            throw new UnsupportedOperationException(\"Can only register a device client if it uses SAS token based authentication\");\n+        }\n+\n+        if (deviceClient.getConfig().getProtocol() != this.protocol)\n+        {\n+            throw new UnsupportedOperationException(\"Cannot register a device client that uses a different transport protocol than this multiplexing client uses\");\n+        }\n+\n+        if (this.protocol == IotHubClientProtocol.AMQPS && this.deviceClientList.size() > 1000)\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed connections over AMQPS only support up to 1000 devices\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff1c610164699199f630b1379b8407d3dc6e44bb"}, "originalPosition": 171}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMTY0NTE5", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522164519", "createdAt": "2020-11-03T03:01:29Z", "commit": {"oid": "ff1c610164699199f630b1379b8407d3dc6e44bb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMzowMToyOVrOHse1jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMzowMToyOVrOHse1jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwNDYyMw==", "bodyText": "I'd also like us to confirm this restriction with Avneet.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516404623", "createdAt": "2020-11-03T03:01:29Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        if (deviceClientList.size() < 1)\n+        {\n+            throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+        }\n+\n+        log.info(\"Opening multiplexing client\");\n+        this.deviceIO.open();\n+        log.info(\"Successfully opened multiplexing client\");\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        log.info(\"Closing multiplexing client\");\n+        for (DeviceClient deviceClient : this.deviceClientList)\n+        {\n+            deviceClient.closeFileUpload();\n+        }\n+\n+        if (this.deviceIO != null)\n+        {\n+            this.deviceIO.multiplexClose();\n+        }\n+\n+        log.info(\"Successfully closed multiplexing client\");\n+    }\n+\n+    /**\n+     * Add a device to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * Up to 1000 devices can be registered on a multiplexed AMQPS connection, and up to 500 devices can be registered on a\n+     * multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this is an asynchronous operation. You can track the state of your\n+     * device session using the {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     * That callback will execute once your device session has successfully been added to the existing multiplexed connection and\n+     * is ready to send telemetry.\n+     * <p>\n+     * Any proxy settings set to the provided device client will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client instance must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * The registered device client may have its own retry policy and its own SAS token expiry time, separate from every other multiplexed device.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If this device client is already registered, then this method will throw a {@link IllegalStateException}\n+     * <p>\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient)\n+    {\n+        Objects.requireNonNull(deviceClient);\n+\n+        for (DeviceClient currentClient : deviceClientList)\n+        {\n+            if (currentClient.getConfig().getDeviceId().equals(deviceClient.getConfig().getDeviceId()))\n+            {\n+                throw new IllegalStateException(\"Cannot register device client because a device client for that device identity has already been registered\");\n+            }\n+        }\n+\n+        if (deviceClient.getConfig().getAuthenticationType() != DeviceClientConfig.AuthType.SAS_TOKEN)\n+        {\n+            throw new UnsupportedOperationException(\"Can only register a device client if it uses SAS token based authentication\");\n+        }\n+\n+        if (deviceClient.getConfig().getProtocol() != this.protocol)\n+        {\n+            throw new UnsupportedOperationException(\"Cannot register a device client that uses a different transport protocol than this multiplexing client uses\");\n+        }\n+\n+        if (this.protocol == IotHubClientProtocol.AMQPS && this.deviceClientList.size() > 1000)\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed connections over AMQPS only support up to 1000 devices\");\n+        }\n+\n+        // Typically client side validation is duplicate work, but IoT Hub doesn't give a good error message when closing the\n+        // AMQPS_WS connection so this is the only way that users will know about this limit\n+        if (this.protocol == IotHubClientProtocol.AMQPS_WS && this.deviceClientList.size() > 500)\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed connections over AMQPS_WS only support up to 500 devices\");\n+        }\n+\n+        if (this.deviceClientList.size() > 1 && !this.deviceClientList.get(0).getConfig().getIotHubHostname().equals(deviceClient.getConfig().getIotHubHostname()))\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed device clients must connect to the same host name\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff1c610164699199f630b1379b8407d3dc6e44bb"}, "originalPosition": 183}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMTY0NjEy", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522164612", "createdAt": "2020-11-03T03:01:53Z", "commit": {"oid": "ff1c610164699199f630b1379b8407d3dc6e44bb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMzowMTo1M1rOHse19g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMzowMTo1M1rOHse19g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwNDcyNg==", "bodyText": "This doesn't look threadsafe. Shouldn't it be?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516404726", "createdAt": "2020-11-03T03:01:53Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        if (deviceClientList.size() < 1)\n+        {\n+            throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+        }\n+\n+        log.info(\"Opening multiplexing client\");\n+        this.deviceIO.open();\n+        log.info(\"Successfully opened multiplexing client\");\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        log.info(\"Closing multiplexing client\");\n+        for (DeviceClient deviceClient : this.deviceClientList)\n+        {\n+            deviceClient.closeFileUpload();\n+        }\n+\n+        if (this.deviceIO != null)\n+        {\n+            this.deviceIO.multiplexClose();\n+        }\n+\n+        log.info(\"Successfully closed multiplexing client\");\n+    }\n+\n+    /**\n+     * Add a device to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * Up to 1000 devices can be registered on a multiplexed AMQPS connection, and up to 500 devices can be registered on a\n+     * multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this is an asynchronous operation. You can track the state of your\n+     * device session using the {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     * That callback will execute once your device session has successfully been added to the existing multiplexed connection and\n+     * is ready to send telemetry.\n+     * <p>\n+     * Any proxy settings set to the provided device client will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client instance must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * The registered device client may have its own retry policy and its own SAS token expiry time, separate from every other multiplexed device.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If this device client is already registered, then this method will throw a {@link IllegalStateException}\n+     * <p>\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient)\n+    {\n+        Objects.requireNonNull(deviceClient);\n+\n+        for (DeviceClient currentClient : deviceClientList)\n+        {\n+            if (currentClient.getConfig().getDeviceId().equals(deviceClient.getConfig().getDeviceId()))\n+            {\n+                throw new IllegalStateException(\"Cannot register device client because a device client for that device identity has already been registered\");\n+            }\n+        }\n+\n+        if (deviceClient.getConfig().getAuthenticationType() != DeviceClientConfig.AuthType.SAS_TOKEN)\n+        {\n+            throw new UnsupportedOperationException(\"Can only register a device client if it uses SAS token based authentication\");\n+        }\n+\n+        if (deviceClient.getConfig().getProtocol() != this.protocol)\n+        {\n+            throw new UnsupportedOperationException(\"Cannot register a device client that uses a different transport protocol than this multiplexing client uses\");\n+        }\n+\n+        if (this.protocol == IotHubClientProtocol.AMQPS && this.deviceClientList.size() > 1000)\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed connections over AMQPS only support up to 1000 devices\");\n+        }\n+\n+        // Typically client side validation is duplicate work, but IoT Hub doesn't give a good error message when closing the\n+        // AMQPS_WS connection so this is the only way that users will know about this limit\n+        if (this.protocol == IotHubClientProtocol.AMQPS_WS && this.deviceClientList.size() > 500)\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed connections over AMQPS_WS only support up to 500 devices\");\n+        }\n+\n+        if (this.deviceClientList.size() > 1 && !this.deviceClientList.get(0).getConfig().getIotHubHostname().equals(deviceClient.getConfig().getIotHubHostname()))\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed device clients must connect to the same host name\");\n+        }\n+\n+        // The first device to be registered will cause this client to build the IO layer with its configuration\n+        if (this.deviceIO == null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff1c610164699199f630b1379b8407d3dc6e44bb"}, "originalPosition": 187}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMTY0ODY4", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522164868", "createdAt": "2020-11-03T03:03:00Z", "commit": {"oid": "ff1c610164699199f630b1379b8407d3dc6e44bb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMzowMzowMFrOHse21Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMzowMzowMFrOHse21Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwNDk0OQ==", "bodyText": "This is an interesting case. Why do we have this restriction, and what options might we have for fixing that?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516404949", "createdAt": "2020-11-03T03:03:00Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        if (deviceClientList.size() < 1)\n+        {\n+            throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+        }\n+\n+        log.info(\"Opening multiplexing client\");\n+        this.deviceIO.open();\n+        log.info(\"Successfully opened multiplexing client\");\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        log.info(\"Closing multiplexing client\");\n+        for (DeviceClient deviceClient : this.deviceClientList)\n+        {\n+            deviceClient.closeFileUpload();\n+        }\n+\n+        if (this.deviceIO != null)\n+        {\n+            this.deviceIO.multiplexClose();\n+        }\n+\n+        log.info(\"Successfully closed multiplexing client\");\n+    }\n+\n+    /**\n+     * Add a device to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * Up to 1000 devices can be registered on a multiplexed AMQPS connection, and up to 500 devices can be registered on a\n+     * multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this is an asynchronous operation. You can track the state of your\n+     * device session using the {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     * That callback will execute once your device session has successfully been added to the existing multiplexed connection and\n+     * is ready to send telemetry.\n+     * <p>\n+     * Any proxy settings set to the provided device client will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client instance must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * The registered device client may have its own retry policy and its own SAS token expiry time, separate from every other multiplexed device.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If this device client is already registered, then this method will throw a {@link IllegalStateException}\n+     * <p>\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient)\n+    {\n+        Objects.requireNonNull(deviceClient);\n+\n+        for (DeviceClient currentClient : deviceClientList)\n+        {\n+            if (currentClient.getConfig().getDeviceId().equals(deviceClient.getConfig().getDeviceId()))\n+            {\n+                throw new IllegalStateException(\"Cannot register device client because a device client for that device identity has already been registered\");\n+            }\n+        }\n+\n+        if (deviceClient.getConfig().getAuthenticationType() != DeviceClientConfig.AuthType.SAS_TOKEN)\n+        {\n+            throw new UnsupportedOperationException(\"Can only register a device client if it uses SAS token based authentication\");\n+        }\n+\n+        if (deviceClient.getConfig().getProtocol() != this.protocol)\n+        {\n+            throw new UnsupportedOperationException(\"Cannot register a device client that uses a different transport protocol than this multiplexing client uses\");\n+        }\n+\n+        if (this.protocol == IotHubClientProtocol.AMQPS && this.deviceClientList.size() > 1000)\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed connections over AMQPS only support up to 1000 devices\");\n+        }\n+\n+        // Typically client side validation is duplicate work, but IoT Hub doesn't give a good error message when closing the\n+        // AMQPS_WS connection so this is the only way that users will know about this limit\n+        if (this.protocol == IotHubClientProtocol.AMQPS_WS && this.deviceClientList.size() > 500)\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed connections over AMQPS_WS only support up to 500 devices\");\n+        }\n+\n+        if (this.deviceClientList.size() > 1 && !this.deviceClientList.get(0).getConfig().getIotHubHostname().equals(deviceClient.getConfig().getIotHubHostname()))\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed device clients must connect to the same host name\");\n+        }\n+\n+        // The first device to be registered will cause this client to build the IO layer with its configuration\n+        if (this.deviceIO == null)\n+        {\n+            log.debug(\"Creating DeviceIO layer for multiplexing client since this is the first registered device\");\n+            this.deviceIO = new DeviceIO(deviceClient.getConfig(), SEND_PERIOD_MILLIS, RECEIVE_PERIOD_MILLIS);\n+        }\n+\n+        deviceClient.setDeviceIO(this.deviceIO);\n+        deviceClient.getConfig().setProxy(this.proxySettings);\n+        deviceClient.setConnectionType(IoTHubConnectionType.USE_MULTIPLEXING_CLIENT);\n+        this.deviceClientList.add(deviceClient);\n+\n+        // if the device IO hasn't been created yet, then this client will be registered once it is created.\n+        log.info(\"Registering device {} to multiplexing client\", deviceClient.getConfig().getDeviceId());\n+        this.deviceIO.registerMultiplexedDeviceClient(deviceClient.getConfig());\n+    }\n+\n+    /**\n+     * Remove a device client from this multiplexing client. This method may be called before or after opening the\n+     * multiplexed connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will close the AMQP device session associated with\n+     * this device, but it will not close any other registered device sessions or the multiplexing client itself.\n+     * <p>\n+     * If the multiplexed connection is already open, then this is an asynchronous operation and you can track the state of your\n+     * device session using the {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     * <p>\n+     * If the multiplexed connection is already open, then at least one device client must be registered at any given time.\n+     * Because of this, this method will throw an {@link IllegalStateException} if it attempts to remove the last device client.\n+     * <p>\n+     * @param deviceClient The device client to unregister from this multiplexing client.\n+     */\n+    public void unregisterDeviceClient(DeviceClient deviceClient)\n+    {\n+        Objects.requireNonNull(deviceClient);\n+\n+        if (deviceClientList.size() <= 1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff1c610164699199f630b1379b8407d3dc6e44bb"}, "originalPosition": 222}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMTY0OTg5", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522164989", "createdAt": "2020-11-03T03:03:30Z", "commit": {"oid": "ff1c610164699199f630b1379b8407d3dc6e44bb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMzowMzozMFrOHse3QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMzowMzozMFrOHse3QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwNTA1Nw==", "bodyText": "As long as we're fixing this, I don't see why it would be capitalized. It isn't a proper noun, right?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516405057", "createdAt": "2020-11-03T03:03:30Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubListener.java", "diffHunk": "@@ -11,7 +11,7 @@\n \n /**\n  * Callback interface for communicating connection and message status updates from individual protocol clients\n- * (mqtt, https, amqps) to the Tranpsort layer that handles queueing of messages and connecting/reconnecting/disconnecting\n+ * (mqtt, https, amqps) to the Transport layer that handles queueing of messages and connecting/reconnecting/disconnecting", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff1c610164699199f630b1379b8407d3dc6e44bb"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMTY1MTY0", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522165164", "createdAt": "2020-11-03T03:04:13Z", "commit": {"oid": "ff1c610164699199f630b1379b8407d3dc6e44bb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMzowNDoxNFrOHse39Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMzowNDoxNFrOHse39Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwNTIzNw==", "bodyText": "Maybe this is just me, but I cringe at the word \"statuses\". I much prefer \"states\". Thoughts?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516405237", "createdAt": "2020-11-03T03:04:14Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubTransport.java", "diffHunk": "@@ -30,47 +30,54 @@\n public class IotHubTransport implements IotHubListener\n {\n     private static final int MAX_MESSAGES_TO_SEND_PER_THREAD = 10;\n+\n+    // For tracking the state of this layer in particular. If multiplexing, this value may be CONNECTED while a\n+    // device specific state is DISCONNECTED_RETRYING. If this state is DISCONNECTED_RETRYING, then the multiplexed\n+    // connection will be completely torn down and re-opened.\n     private volatile IotHubConnectionStatus connectionStatus;\n+\n+    // for multiplexing. A particular device can be disconnected retrying while the tcp connection is fine and the other\n+    // device sessions are open.\n+    private Map<String, IotHubConnectionStatus> deviceConnectionStatuses = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff1c610164699199f630b1379b8407d3dc6e44bb"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNzI3MDM1", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522727035", "createdAt": "2020-11-03T17:31:01Z", "commit": {"oid": "82af88904d85ecdbe000a03a5125ee584bab7f85"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzozMTowMVrOHs5XhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzo0MDoxNVrOHs5tFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzOTMwMQ==", "bodyText": "nit: I would change and construct this string by using the class and method names so we won't have any refactoring issues.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516839301", "createdAt": "2020-11-03T17:31:01Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceClient.java", "diffHunk": "@@ -376,6 +378,11 @@ private void commonConstructorVerifications() throws UnsupportedOperationExcepti\n      */\n     public void open() throws IOException\n     {\n+        if (this.ioTHubConnectionType == IoTHubConnectionType.USE_MULTIPLEXING_CLIENT)\n+        {\n+            throw new UnsupportedOperationException(\"Cannot open a multiplexed client through this method. Must use multiplexingClient.registerDeviceClient(deviceClient)\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82af88904d85ecdbe000a03a5125ee584bab7f85"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0MDgxNQ==", "bodyText": "this check seems useful, why remove it?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516840815", "createdAt": "2020-11-03T17:33:31Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "diffHunk": "@@ -101,16 +100,8 @@\n      */\n     DeviceIO(DeviceClientConfig config, long sendPeriodInMilliseconds, long receivePeriodInMilliseconds)\n     {\n-        /* Codes_SRS_DEVICE_IO_21_002: [If the `config` is null, the constructor shall throw an IllegalArgumentException.] */\n-        if(config == null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82af88904d85ecdbe000a03a5125ee584bab7f85"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0MTE1Mg==", "bodyText": "unless it happens in the public method that calls this one ...", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516841152", "createdAt": "2020-11-03T17:34:09Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "diffHunk": "@@ -101,16 +100,8 @@\n      */\n     DeviceIO(DeviceClientConfig config, long sendPeriodInMilliseconds, long receivePeriodInMilliseconds)\n     {\n-        /* Codes_SRS_DEVICE_IO_21_002: [If the `config` is null, the constructor shall throw an IllegalArgumentException.] */\n-        if(config == null)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0MDgxNQ=="}, "originalCommit": {"oid": "82af88904d85ecdbe000a03a5125ee584bab7f85"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0MjkxMg==", "bodyText": "does DISCONNECTED status means all the tasks schedulers are shut down?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516842912", "createdAt": "2020-11-03T17:37:09Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "diffHunk": "@@ -218,6 +215,11 @@ public void close() throws IOException\n     {\n         synchronized (this.stateLock)\n         {\n+            if (state == IotHubConnectionStatus.DISCONNECTED)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82af88904d85ecdbe000a03a5125ee584bab7f85"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0NDgyMA==", "bodyText": "double negative method name. We can just call it verifyRegisteredIfMultiplexing", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516844820", "createdAt": "2020-11-03T17:40:15Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/InternalClient.java", "diffHunk": "@@ -180,6 +183,8 @@ public void closeNow() throws IOException\n      */\n     public void sendEventAsync(Message message, IotHubEventCallback callback, Object callbackContext)\n     {\n+        verifyNotUnregisteredIfMultiplexing();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82af88904d85ecdbe000a03a5125ee584bab7f85"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNzM2MzI2", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522736326", "createdAt": "2020-11-03T17:42:43Z", "commit": {"oid": "82af88904d85ecdbe000a03a5125ee584bab7f85"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzo0Mjo0M1rOHs5yoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzo1MDoxNFrOHs6EvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0NjI0MA==", "bodyText": "can this.deviceIO be null? then shouldn't this method throw?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516846240", "createdAt": "2020-11-03T17:42:43Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/InternalClient.java", "diffHunk": "@@ -354,8 +369,13 @@ public void sendReportedProperties(Set<Property> reportedProperties, int version\n      */\n     public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) throws IllegalArgumentException\n     {\n-        //Codes_SRS_INTERNALCLIENT_34_069: [This function shall register the provided callback and context with its device IO instance.]\n-        this.deviceIO.registerConnectionStatusChangeCallback(callback, callbackContext);\n+        this.connectionStatusChangeCallback = callback;\n+        this.connectionStatusChangeCallbackContext = callbackContext;\n+\n+        if (this.deviceIO != null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82af88904d85ecdbe000a03a5125ee584bab7f85"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0NjY4Mw==", "bodyText": "nit: break this line into multiple lines for readability", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516846683", "createdAt": "2020-11-03T17:43:33Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/InternalClient.java", "diffHunk": "@@ -745,7 +773,15 @@ DeviceIO getDeviceIO()\n      */\n     void setDeviceIO(DeviceIO deviceIO)\n     {\n+        // deviceIO may be set to null in the case when a device client was multiplexing and was unregistered\n         this.deviceIO = deviceIO;\n+\n+        // Since connection status callbacks can be registered before associating a device client with a multiplexing client, the callback and its\n+        // context also need to be registered when the device IO is set.\n+        if (this.deviceIO != null && this.connectionStatusChangeCallback != null)\n+        {\n+            this.deviceIO.registerConnectionStatusChangeCallback(this.connectionStatusChangeCallback, this.connectionStatusChangeCallbackContext, this.getConfig().getDeviceId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82af88904d85ecdbe000a03a5125ee584bab7f85"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0ODk4NQ==", "bodyText": "good catch, we can probably check to see if it's null at the beginning and throw there. before we check for anything else.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516848985", "createdAt": "2020-11-03T17:47:10Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/InternalClient.java", "diffHunk": "@@ -948,13 +984,15 @@ void setOption_SetAmqpOpenDeviceSessionsTimeout(Object value)\n      */\n     public void setProxySettings(ProxySettings proxySettings)\n     {\n+        verifyNotUnregisteredIfMultiplexing();\n+\n         if (this.deviceIO.isOpen())\n         {\n             throw new IllegalStateException(\"Cannot set proxy after connection was already opened\");\n         }\n \n         IotHubClientProtocol protocol = this.deviceIO.getProtocol();\n-        if (protocol != HTTPS && protocol != AMQPS_WS && protocol != MQTT_WS)\n+        if (protocol != HTTPS && protocol != AMQPS_WS && protocol != MQTT_WS && proxySettings != null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82af88904d85ecdbe000a03a5125ee584bab7f85"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0OTgzNQ==", "bodyText": "is this the only indication of the client using multiplexing? no boolean indicator anywhere? it would probably be useful to have.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516849835", "createdAt": "2020-11-03T17:48:39Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/InternalClient.java", "diffHunk": "@@ -980,4 +1018,13 @@ private void commonConstructorVerification(IotHubConnectionString connectionStri\n             throw new UnsupportedOperationException(\"Communication with edgehub only supported by MQTT/MQTT_WS and AMQPS/AMQPS_WS\");\n         }\n     }\n+\n+    private void verifyNotUnregisteredIfMultiplexing()\n+    {\n+        // deviceIO is only ever null when a client was registered to a multiplexing client, became unregistered, and hasn't be re-registered yet.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82af88904d85ecdbe000a03a5125ee584bab7f85"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1MDMwOA==", "bodyText": "I see that it can be null if it's using multiplexing ... ignore my previous commnet.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516850308", "createdAt": "2020-11-03T17:49:24Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/InternalClient.java", "diffHunk": "@@ -354,8 +369,13 @@ public void sendReportedProperties(Set<Property> reportedProperties, int version\n      */\n     public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) throws IllegalArgumentException\n     {\n-        //Codes_SRS_INTERNALCLIENT_34_069: [This function shall register the provided callback and context with its device IO instance.]\n-        this.deviceIO.registerConnectionStatusChangeCallback(callback, callbackContext);\n+        this.connectionStatusChangeCallback = callback;\n+        this.connectionStatusChangeCallbackContext = callbackContext;\n+\n+        if (this.deviceIO != null)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0NjI0MA=="}, "originalCommit": {"oid": "82af88904d85ecdbe000a03a5125ee584bab7f85"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1MDg3Nw==", "bodyText": "if we had a boolean flag that we would set if multiplexing was registered, we could just check that  ... just a thought", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516850877", "createdAt": "2020-11-03T17:50:14Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/InternalClient.java", "diffHunk": "@@ -354,8 +369,13 @@ public void sendReportedProperties(Set<Property> reportedProperties, int version\n      */\n     public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) throws IllegalArgumentException\n     {\n-        //Codes_SRS_INTERNALCLIENT_34_069: [This function shall register the provided callback and context with its device IO instance.]\n-        this.deviceIO.registerConnectionStatusChangeCallback(callback, callbackContext);\n+        this.connectionStatusChangeCallback = callback;\n+        this.connectionStatusChangeCallbackContext = callbackContext;\n+\n+        if (this.deviceIO != null)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0NjI0MA=="}, "originalCommit": {"oid": "82af88904d85ecdbe000a03a5125ee584bab7f85"}, "originalPosition": 73}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNzQ2MDc4", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522746078", "createdAt": "2020-11-03T17:55:19Z", "commit": {"oid": "82af88904d85ecdbe000a03a5125ee584bab7f85"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzo1NToxOVrOHs6Q7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxODoyNToyM1rOHs7T2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1Mzk5Nw==", "bodyText": "can you elaborate why we don't have to close every device client as well?\nlike this:\ndeviceClient.close()", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516853997", "createdAt": "2020-11-03T17:55:19Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        if (deviceClientList.size() < 1)\n+        {\n+            throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+        }\n+\n+        log.info(\"Opening multiplexing client\");\n+        this.deviceIO.open();\n+        log.info(\"Successfully opened multiplexing client\");\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        log.info(\"Closing multiplexing client\");\n+        for (DeviceClient deviceClient : this.deviceClientList)\n+        {\n+            deviceClient.closeFileUpload();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82af88904d85ecdbe000a03a5125ee584bab7f85"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1NDU5Nw==", "bodyText": "is this limitation documented somewhere that we can link this paragraph to?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516854597", "createdAt": "2020-11-03T17:56:14Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        if (deviceClientList.size() < 1)\n+        {\n+            throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+        }\n+\n+        log.info(\"Opening multiplexing client\");\n+        this.deviceIO.open();\n+        log.info(\"Successfully opened multiplexing client\");\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        log.info(\"Closing multiplexing client\");\n+        for (DeviceClient deviceClient : this.deviceClientList)\n+        {\n+            deviceClient.closeFileUpload();\n+        }\n+\n+        if (this.deviceIO != null)\n+        {\n+            this.deviceIO.multiplexClose();\n+        }\n+\n+        log.info(\"Successfully closed multiplexing client\");\n+    }\n+\n+    /**\n+     * Add a device to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * Up to 1000 devices can be registered on a multiplexed AMQPS connection, and up to 500 devices can be registered on a", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82af88904d85ecdbe000a03a5125ee584bab7f85"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1NjE3Mw==", "bodyText": "do we check to see if we are overwriting any proxy setting on individual devices? just as warning maybe? it's an unlikely event but might be useful to warn the user about", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516856173", "createdAt": "2020-11-03T17:58:50Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        if (deviceClientList.size() < 1)\n+        {\n+            throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+        }\n+\n+        log.info(\"Opening multiplexing client\");\n+        this.deviceIO.open();\n+        log.info(\"Successfully opened multiplexing client\");\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        log.info(\"Closing multiplexing client\");\n+        for (DeviceClient deviceClient : this.deviceClientList)\n+        {\n+            deviceClient.closeFileUpload();\n+        }\n+\n+        if (this.deviceIO != null)\n+        {\n+            this.deviceIO.multiplexClose();\n+        }\n+\n+        log.info(\"Successfully closed multiplexing client\");\n+    }\n+\n+    /**\n+     * Add a device to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * Up to 1000 devices can be registered on a multiplexed AMQPS connection, and up to 500 devices can be registered on a\n+     * multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this is an asynchronous operation. You can track the state of your\n+     * device session using the {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     * That callback will execute once your device session has successfully been added to the existing multiplexed connection and\n+     * is ready to send telemetry.\n+     * <p>\n+     * Any proxy settings set to the provided device client will be overwritten by the proxy settings of this multiplexing client.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82af88904d85ecdbe000a03a5125ee584bab7f85"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1NjkxMA==", "bodyText": "should we throw in this case? can't we just be resilient to this?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516856910", "createdAt": "2020-11-03T18:00:03Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        if (deviceClientList.size() < 1)\n+        {\n+            throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+        }\n+\n+        log.info(\"Opening multiplexing client\");\n+        this.deviceIO.open();\n+        log.info(\"Successfully opened multiplexing client\");\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        log.info(\"Closing multiplexing client\");\n+        for (DeviceClient deviceClient : this.deviceClientList)\n+        {\n+            deviceClient.closeFileUpload();\n+        }\n+\n+        if (this.deviceIO != null)\n+        {\n+            this.deviceIO.multiplexClose();\n+        }\n+\n+        log.info(\"Successfully closed multiplexing client\");\n+    }\n+\n+    /**\n+     * Add a device to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * Up to 1000 devices can be registered on a multiplexed AMQPS connection, and up to 500 devices can be registered on a\n+     * multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this is an asynchronous operation. You can track the state of your\n+     * device session using the {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     * That callback will execute once your device session has successfully been added to the existing multiplexed connection and\n+     * is ready to send telemetry.\n+     * <p>\n+     * Any proxy settings set to the provided device client will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client instance must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * The registered device client may have its own retry policy and its own SAS token expiry time, separate from every other multiplexed device.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If this device client is already registered, then this method will throw a {@link IllegalStateException}\n+     * <p>\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient)\n+    {\n+        Objects.requireNonNull(deviceClient);\n+\n+        for (DeviceClient currentClient : deviceClientList)\n+        {\n+            if (currentClient.getConfig().getDeviceId().equals(deviceClient.getConfig().getDeviceId()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82af88904d85ecdbe000a03a5125ee584bab7f85"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1ODQzOA==", "bodyText": "is this check case insensitive?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516858438", "createdAt": "2020-11-03T18:02:44Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        if (deviceClientList.size() < 1)\n+        {\n+            throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+        }\n+\n+        log.info(\"Opening multiplexing client\");\n+        this.deviceIO.open();\n+        log.info(\"Successfully opened multiplexing client\");\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        log.info(\"Closing multiplexing client\");\n+        for (DeviceClient deviceClient : this.deviceClientList)\n+        {\n+            deviceClient.closeFileUpload();\n+        }\n+\n+        if (this.deviceIO != null)\n+        {\n+            this.deviceIO.multiplexClose();\n+        }\n+\n+        log.info(\"Successfully closed multiplexing client\");\n+    }\n+\n+    /**\n+     * Add a device to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * Up to 1000 devices can be registered on a multiplexed AMQPS connection, and up to 500 devices can be registered on a\n+     * multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this is an asynchronous operation. You can track the state of your\n+     * device session using the {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     * That callback will execute once your device session has successfully been added to the existing multiplexed connection and\n+     * is ready to send telemetry.\n+     * <p>\n+     * Any proxy settings set to the provided device client will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client instance must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * The registered device client may have its own retry policy and its own SAS token expiry time, separate from every other multiplexed device.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If this device client is already registered, then this method will throw a {@link IllegalStateException}\n+     * <p>\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient)\n+    {\n+        Objects.requireNonNull(deviceClient);\n+\n+        for (DeviceClient currentClient : deviceClientList)\n+        {\n+            if (currentClient.getConfig().getDeviceId().equals(deviceClient.getConfig().getDeviceId()))\n+            {\n+                throw new IllegalStateException(\"Cannot register device client because a device client for that device identity has already been registered\");\n+            }\n+        }\n+\n+        if (deviceClient.getConfig().getAuthenticationType() != DeviceClientConfig.AuthType.SAS_TOKEN)\n+        {\n+            throw new UnsupportedOperationException(\"Can only register a device client if it uses SAS token based authentication\");\n+        }\n+\n+        if (deviceClient.getConfig().getProtocol() != this.protocol)\n+        {\n+            throw new UnsupportedOperationException(\"Cannot register a device client that uses a different transport protocol than this multiplexing client uses\");\n+        }\n+\n+        if (this.protocol == IotHubClientProtocol.AMQPS && this.deviceClientList.size() > 1000)\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed connections over AMQPS only support up to 1000 devices\");\n+        }\n+\n+        // Typically client side validation is duplicate work, but IoT Hub doesn't give a good error message when closing the\n+        // AMQPS_WS connection so this is the only way that users will know about this limit\n+        if (this.protocol == IotHubClientProtocol.AMQPS_WS && this.deviceClientList.size() > 500)\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed connections over AMQPS_WS only support up to 500 devices\");\n+        }\n+\n+        if (this.deviceClientList.size() > 1 && !this.deviceClientList.get(0).getConfig().getIotHubHostname().equals(deviceClient.getConfig().getIotHubHostname()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82af88904d85ecdbe000a03a5125ee584bab7f85"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1OTE0NQ==", "bodyText": "I think 186 - 200 should be in a synchronized block", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516859145", "createdAt": "2020-11-03T18:04:02Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        if (deviceClientList.size() < 1)\n+        {\n+            throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+        }\n+\n+        log.info(\"Opening multiplexing client\");\n+        this.deviceIO.open();\n+        log.info(\"Successfully opened multiplexing client\");\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        log.info(\"Closing multiplexing client\");\n+        for (DeviceClient deviceClient : this.deviceClientList)\n+        {\n+            deviceClient.closeFileUpload();\n+        }\n+\n+        if (this.deviceIO != null)\n+        {\n+            this.deviceIO.multiplexClose();\n+        }\n+\n+        log.info(\"Successfully closed multiplexing client\");\n+    }\n+\n+    /**\n+     * Add a device to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * Up to 1000 devices can be registered on a multiplexed AMQPS connection, and up to 500 devices can be registered on a\n+     * multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this is an asynchronous operation. You can track the state of your\n+     * device session using the {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     * That callback will execute once your device session has successfully been added to the existing multiplexed connection and\n+     * is ready to send telemetry.\n+     * <p>\n+     * Any proxy settings set to the provided device client will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client instance must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * The registered device client may have its own retry policy and its own SAS token expiry time, separate from every other multiplexed device.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If this device client is already registered, then this method will throw a {@link IllegalStateException}\n+     * <p>\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient)\n+    {\n+        Objects.requireNonNull(deviceClient);\n+\n+        for (DeviceClient currentClient : deviceClientList)\n+        {\n+            if (currentClient.getConfig().getDeviceId().equals(deviceClient.getConfig().getDeviceId()))\n+            {\n+                throw new IllegalStateException(\"Cannot register device client because a device client for that device identity has already been registered\");\n+            }\n+        }\n+\n+        if (deviceClient.getConfig().getAuthenticationType() != DeviceClientConfig.AuthType.SAS_TOKEN)\n+        {\n+            throw new UnsupportedOperationException(\"Can only register a device client if it uses SAS token based authentication\");\n+        }\n+\n+        if (deviceClient.getConfig().getProtocol() != this.protocol)\n+        {\n+            throw new UnsupportedOperationException(\"Cannot register a device client that uses a different transport protocol than this multiplexing client uses\");\n+        }\n+\n+        if (this.protocol == IotHubClientProtocol.AMQPS && this.deviceClientList.size() > 1000)\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed connections over AMQPS only support up to 1000 devices\");\n+        }\n+\n+        // Typically client side validation is duplicate work, but IoT Hub doesn't give a good error message when closing the\n+        // AMQPS_WS connection so this is the only way that users will know about this limit\n+        if (this.protocol == IotHubClientProtocol.AMQPS_WS && this.deviceClientList.size() > 500)\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed connections over AMQPS_WS only support up to 500 devices\");\n+        }\n+\n+        if (this.deviceClientList.size() > 1 && !this.deviceClientList.get(0).getConfig().getIotHubHostname().equals(deviceClient.getConfig().getIotHubHostname()))\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed device clients must connect to the same host name\");\n+        }\n+\n+        // The first device to be registered will cause this client to build the IO layer with its configuration\n+        if (this.deviceIO == null)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwNDcyNg=="}, "originalCommit": {"oid": "ff1c610164699199f630b1379b8407d3dc6e44bb"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg3MTEzMQ==", "bodyText": "It is interesting. I think this needs to be more clear, maybe we should first look for the device in the devicelist and throw if we can't find it.\nthen if it's there and it's the last one, while maintaining thread safety, close the deviceIO and allow the multiplex client to not have any devices.\njust as you would when you first initialize it. just a thought ... curious what else we can do here.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516871131", "createdAt": "2020-11-03T18:25:23Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        if (deviceClientList.size() < 1)\n+        {\n+            throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+        }\n+\n+        log.info(\"Opening multiplexing client\");\n+        this.deviceIO.open();\n+        log.info(\"Successfully opened multiplexing client\");\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        log.info(\"Closing multiplexing client\");\n+        for (DeviceClient deviceClient : this.deviceClientList)\n+        {\n+            deviceClient.closeFileUpload();\n+        }\n+\n+        if (this.deviceIO != null)\n+        {\n+            this.deviceIO.multiplexClose();\n+        }\n+\n+        log.info(\"Successfully closed multiplexing client\");\n+    }\n+\n+    /**\n+     * Add a device to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * Up to 1000 devices can be registered on a multiplexed AMQPS connection, and up to 500 devices can be registered on a\n+     * multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this is an asynchronous operation. You can track the state of your\n+     * device session using the {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     * That callback will execute once your device session has successfully been added to the existing multiplexed connection and\n+     * is ready to send telemetry.\n+     * <p>\n+     * Any proxy settings set to the provided device client will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client instance must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * The registered device client may have its own retry policy and its own SAS token expiry time, separate from every other multiplexed device.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If this device client is already registered, then this method will throw a {@link IllegalStateException}\n+     * <p>\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient)\n+    {\n+        Objects.requireNonNull(deviceClient);\n+\n+        for (DeviceClient currentClient : deviceClientList)\n+        {\n+            if (currentClient.getConfig().getDeviceId().equals(deviceClient.getConfig().getDeviceId()))\n+            {\n+                throw new IllegalStateException(\"Cannot register device client because a device client for that device identity has already been registered\");\n+            }\n+        }\n+\n+        if (deviceClient.getConfig().getAuthenticationType() != DeviceClientConfig.AuthType.SAS_TOKEN)\n+        {\n+            throw new UnsupportedOperationException(\"Can only register a device client if it uses SAS token based authentication\");\n+        }\n+\n+        if (deviceClient.getConfig().getProtocol() != this.protocol)\n+        {\n+            throw new UnsupportedOperationException(\"Cannot register a device client that uses a different transport protocol than this multiplexing client uses\");\n+        }\n+\n+        if (this.protocol == IotHubClientProtocol.AMQPS && this.deviceClientList.size() > 1000)\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed connections over AMQPS only support up to 1000 devices\");\n+        }\n+\n+        // Typically client side validation is duplicate work, but IoT Hub doesn't give a good error message when closing the\n+        // AMQPS_WS connection so this is the only way that users will know about this limit\n+        if (this.protocol == IotHubClientProtocol.AMQPS_WS && this.deviceClientList.size() > 500)\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed connections over AMQPS_WS only support up to 500 devices\");\n+        }\n+\n+        if (this.deviceClientList.size() > 1 && !this.deviceClientList.get(0).getConfig().getIotHubHostname().equals(deviceClient.getConfig().getIotHubHostname()))\n+        {\n+            throw new UnsupportedOperationException(\"Multiplexed device clients must connect to the same host name\");\n+        }\n+\n+        // The first device to be registered will cause this client to build the IO layer with its configuration\n+        if (this.deviceIO == null)\n+        {\n+            log.debug(\"Creating DeviceIO layer for multiplexing client since this is the first registered device\");\n+            this.deviceIO = new DeviceIO(deviceClient.getConfig(), SEND_PERIOD_MILLIS, RECEIVE_PERIOD_MILLIS);\n+        }\n+\n+        deviceClient.setDeviceIO(this.deviceIO);\n+        deviceClient.getConfig().setProxy(this.proxySettings);\n+        deviceClient.setConnectionType(IoTHubConnectionType.USE_MULTIPLEXING_CLIENT);\n+        this.deviceClientList.add(deviceClient);\n+\n+        // if the device IO hasn't been created yet, then this client will be registered once it is created.\n+        log.info(\"Registering device {} to multiplexing client\", deviceClient.getConfig().getDeviceId());\n+        this.deviceIO.registerMultiplexedDeviceClient(deviceClient.getConfig());\n+    }\n+\n+    /**\n+     * Remove a device client from this multiplexing client. This method may be called before or after opening the\n+     * multiplexed connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will close the AMQP device session associated with\n+     * this device, but it will not close any other registered device sessions or the multiplexing client itself.\n+     * <p>\n+     * If the multiplexed connection is already open, then this is an asynchronous operation and you can track the state of your\n+     * device session using the {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     * <p>\n+     * If the multiplexed connection is already open, then at least one device client must be registered at any given time.\n+     * Because of this, this method will throw an {@link IllegalStateException} if it attempts to remove the last device client.\n+     * <p>\n+     * @param deviceClient The device client to unregister from this multiplexing client.\n+     */\n+    public void unregisterDeviceClient(DeviceClient deviceClient)\n+    {\n+        Objects.requireNonNull(deviceClient);\n+\n+        if (deviceClientList.size() <= 1)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwNDk0OQ=="}, "originalCommit": {"oid": "ff1c610164699199f630b1379b8407d3dc6e44bb"}, "originalPosition": 222}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "48088c160fc067ba6b38b977f9466816e24a0404", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/48088c160fc067ba6b38b977f9466816e24a0404", "committedDate": "2020-11-03T18:04:49Z", "message": "feedbac"}, "afterCommit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/b7af2b477c526150c91e5853fcb3ddd8b39fe760", "committedDate": "2020-11-03T18:59:04Z", "message": "feat(iot-dev): Add multiplexing client that supports device registration/unregistration during open connection\n\nTransportClient was our multiplexing client, but there was no way to add the ability to add/remove devices from an active connection without breaking the APIs in that class, so this deprecates the transport client in favor of a new MultiplexingClient.\n\nSignificant changes had to made to the IotHubTransport layer so that each multiplexed client could have its own connection state and so that each multiplexed client could have its own focused retry logic. Instead of closing the entire multiplexed connection every time a session drops, the transport layer can re-open individual device sessions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNzkzOTEw", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522793910", "createdAt": "2020-11-03T19:02:11Z", "commit": {"oid": "48088c160fc067ba6b38b977f9466816e24a0404"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTowMzoyNFrOHs8kLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTowNToyNFrOHs8pFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5MTY5Mw==", "bodyText": "This can have multiplex in the name of the call back to avoid confusion ... maybe onDeviceMultiplexSessionEstablished\nsame for the method below.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516891693", "createdAt": "2020-11-03T19:03:24Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubListener.java", "diffHunk": "@@ -43,4 +43,16 @@\n      * @param connectionId the id of the connection this update is relevant to\n      */\n     void onConnectionEstablished(String connectionId);\n+\n+    /**\n+     * Callback to be fired when the multiplexed connection establishes a new device session.\n+     * @param deviceId the Id of the device that the session belongs to\n+     */\n+    void onDeviceSessionEstablished(String connectionId, String deviceId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5MjQwMg==", "bodyText": "space between + s", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516892402", "createdAt": "2020-11-03T19:04:28Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/ReconnectionNotifier.java", "diffHunk": "@@ -21,7 +22,21 @@ public static void notifyDisconnectAsync(final Throwable connectionLossCause, fi\n                         listener.onConnectionLost(connectionLossCause,connectionId);\n                     }\n                 },\n-                THREAD_NAME+\":\"+connectionId\n+                CONNECTION_RECONNECTION_THREAD_NAME+\":\"+connectionId", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5Mjk0OQ==", "bodyText": "same on line 39", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516892949", "createdAt": "2020-11-03T19:05:24Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/ReconnectionNotifier.java", "diffHunk": "@@ -21,7 +22,21 @@ public static void notifyDisconnectAsync(final Throwable connectionLossCause, fi\n                         listener.onConnectionLost(connectionLossCause,connectionId);\n                     }\n                 },\n-                THREAD_NAME+\":\"+connectionId\n+                CONNECTION_RECONNECTION_THREAD_NAME+\":\"+connectionId", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5MjQwMg=="}, "originalCommit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODA5OTAw", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522809900", "createdAt": "2020-11-03T19:25:29Z", "commit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOToyNToyOVrOHs9Tdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOToyNToyOVrOHs9Tdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwMzc5OQ==", "bodyText": "Seems this might take a long time. No way to parallelize?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516903799", "createdAt": "2020-11-03T19:25:29Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,252 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        synchronized (this.lock)\n+        {\n+            if (deviceClientList.size() < 1)\n+            {\n+                throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+            }\n+\n+            log.info(\"Opening multiplexing client\");\n+            this.deviceIO.open();\n+            log.info(\"Successfully opened multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        synchronized (this.lock)\n+        {\n+            log.info(\"Closing multiplexing client\");\n+            for (DeviceClient deviceClient : this.deviceClientList)\n+            {\n+                deviceClient.closeFileUpload();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "originalPosition": 112}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODExNjY0", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522811664", "createdAt": "2020-11-03T19:27:59Z", "commit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOToyNzo1OVrOHs9Y1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOToyNzo1OVrOHs9Y1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNTE3NA==", "bodyText": "Reads a bit funny. I feel not having a subject on the sentence makes it sound weird too. Thoughts?\nA device client cannot be registered to a multiplexing client that specifies a different transport protocol.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516905174", "createdAt": "2020-11-03T19:27:59Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,252 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        synchronized (this.lock)\n+        {\n+            if (deviceClientList.size() < 1)\n+            {\n+                throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+            }\n+\n+            log.info(\"Opening multiplexing client\");\n+            this.deviceIO.open();\n+            log.info(\"Successfully opened multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        synchronized (this.lock)\n+        {\n+            log.info(\"Closing multiplexing client\");\n+            for (DeviceClient deviceClient : this.deviceClientList)\n+            {\n+                deviceClient.closeFileUpload();\n+            }\n+\n+            if (this.deviceIO != null)\n+            {\n+                this.deviceIO.multiplexClose();\n+            }\n+\n+            // Note that this method does not close each of the registered device client instances. This is intentional\n+            // as the calls to deviceClient.close() do nothing besides close the deviceIO layer, which is already closed\n+            // by the above code.\n+\n+            log.info(\"Successfully closed multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Add a device to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * Up to 1000 devices can be registered on a multiplexed AMQPS connection, and up to 500 devices can be registered on a\n+     * multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this is an asynchronous operation. You can track the state of your\n+     * device session using the {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     * That callback will execute once your device session has successfully been added to the existing multiplexed connection and\n+     * is ready to send telemetry.\n+     * <p>\n+     * Any proxy settings set to the provided device client will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client instance must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * The registered device client may have its own retry policy and its own SAS token expiry time, separate from every other multiplexed device.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If this device client is already registered, then this method will throw a {@link IllegalStateException}\n+     * <p>\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient)\n+    {\n+        Objects.requireNonNull(deviceClient);\n+\n+        synchronized (this.lock)\n+        {\n+            for (DeviceClient currentClient : deviceClientList)\n+            {\n+                if (currentClient.getConfig().getDeviceId().equalsIgnoreCase(deviceClient.getConfig().getDeviceId()))\n+                {\n+                    throw new IllegalStateException(\"Cannot register device client because a device client for that device identity has already been registered\");\n+                }\n+            }\n+\n+            if (deviceClient.getConfig().getAuthenticationType() != DeviceClientConfig.AuthType.SAS_TOKEN)\n+            {\n+                throw new UnsupportedOperationException(\"Can only register a device client if it uses SAS token based authentication\");\n+            }\n+\n+            if (deviceClient.getConfig().getProtocol() != this.protocol)\n+            {\n+                throw new UnsupportedOperationException(\"Cannot register a device client that uses a different transport protocol than this multiplexing client uses\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "originalPosition": 179}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODEzMDIz", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522813023", "createdAt": "2020-11-03T19:29:55Z", "commit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOToyOTo1NlrOHs9dTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOToyOTo1NlrOHs9dTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNjMxOQ==", "bodyText": "same for these guys, if this is only applicable to multiplexed sessions, it would be nice to have that in the name.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516906319", "createdAt": "2020-11-03T19:29:56Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/amqps/AmqpsSessionStateCallback.java", "diffHunk": "@@ -52,7 +52,25 @@\n      * closed unexpectedly.\n      *\n      * @param errorCondition the condition of the session that caused the close if the session closed remotely, or the condition\n-     *                       of the link that closed unexpectedly\n+     *                       of the link that closed unexpectedly.\n+     * @param deviceId the device that the session belonged to.\n      */\n-    void onSessionClosedUnexpectedly(ErrorCondition errorCondition);\n+    void onSessionClosedUnexpectedly(ErrorCondition errorCondition, String deviceId);\n+\n+    /**\n+     * Executed if a session closes, but it was expected. Likely due to user calling close on the connection, or\n+     * unregistering a device from an active multiplexed connection\n+     *\n+     * @param deviceId the device whose connection closed.\n+     */\n+    void onSessionClosedAsExpected(String deviceId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODEzMTg0", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522813184", "createdAt": "2020-11-03T19:30:07Z", "commit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTozMDowOFrOHs9d2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTozMDowOFrOHs9d2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNjQ1Nw==", "bodyText": "How about we make this 1000 a constant, and refer to it in the error message too?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516906457", "createdAt": "2020-11-03T19:30:08Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,252 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        synchronized (this.lock)\n+        {\n+            if (deviceClientList.size() < 1)\n+            {\n+                throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+            }\n+\n+            log.info(\"Opening multiplexing client\");\n+            this.deviceIO.open();\n+            log.info(\"Successfully opened multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        synchronized (this.lock)\n+        {\n+            log.info(\"Closing multiplexing client\");\n+            for (DeviceClient deviceClient : this.deviceClientList)\n+            {\n+                deviceClient.closeFileUpload();\n+            }\n+\n+            if (this.deviceIO != null)\n+            {\n+                this.deviceIO.multiplexClose();\n+            }\n+\n+            // Note that this method does not close each of the registered device client instances. This is intentional\n+            // as the calls to deviceClient.close() do nothing besides close the deviceIO layer, which is already closed\n+            // by the above code.\n+\n+            log.info(\"Successfully closed multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Add a device to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * Up to 1000 devices can be registered on a multiplexed AMQPS connection, and up to 500 devices can be registered on a\n+     * multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this is an asynchronous operation. You can track the state of your\n+     * device session using the {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     * That callback will execute once your device session has successfully been added to the existing multiplexed connection and\n+     * is ready to send telemetry.\n+     * <p>\n+     * Any proxy settings set to the provided device client will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client instance must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * The registered device client may have its own retry policy and its own SAS token expiry time, separate from every other multiplexed device.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If this device client is already registered, then this method will throw a {@link IllegalStateException}\n+     * <p>\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient)\n+    {\n+        Objects.requireNonNull(deviceClient);\n+\n+        synchronized (this.lock)\n+        {\n+            for (DeviceClient currentClient : deviceClientList)\n+            {\n+                if (currentClient.getConfig().getDeviceId().equalsIgnoreCase(deviceClient.getConfig().getDeviceId()))\n+                {\n+                    throw new IllegalStateException(\"Cannot register device client because a device client for that device identity has already been registered\");\n+                }\n+            }\n+\n+            if (deviceClient.getConfig().getAuthenticationType() != DeviceClientConfig.AuthType.SAS_TOKEN)\n+            {\n+                throw new UnsupportedOperationException(\"Can only register a device client if it uses SAS token based authentication\");\n+            }\n+\n+            if (deviceClient.getConfig().getProtocol() != this.protocol)\n+            {\n+                throw new UnsupportedOperationException(\"Cannot register a device client that uses a different transport protocol than this multiplexing client uses\");\n+            }\n+\n+            if (this.protocol == IotHubClientProtocol.AMQPS && this.deviceClientList.size() > 1000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "originalPosition": 182}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODEzOTMy", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522813932", "createdAt": "2020-11-03T19:31:16Z", "commit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTozMToxNlrOHs9gQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTozMToxNlrOHs9gQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNzA3Mg==", "bodyText": ":D why did we have a queue if it wasn't allowed to be larger than 1 !!! strange ...", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516907072", "createdAt": "2020-11-03T19:31:16Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/mqtt/MqttIotHubConnection.java", "diffHunk": "@@ -101,14 +101,9 @@ public MqttIotHubConnection(DeviceClientConfig config) throws IllegalArgumentExc\n      *\n      * @throws TransportException if a connection could not to be established.\n      */\n-    public void open(Queue<DeviceClientConfig> deviceClientConfigs) throws TransportException", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODE2MTgx", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522816181", "createdAt": "2020-11-03T19:34:32Z", "commit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTozNDozMlrOHs9nNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTozNDozMlrOHs9nNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwODg1NQ==", "bodyText": "plural", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516908855", "createdAt": "2020-11-03T19:34:32Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubTransport.java", "diffHunk": "@@ -820,21 +901,80 @@ private void handleDisconnection(TransportException transportException)\n         reconnect(transportException);\n     }\n \n+    // should only be called when multiplexing an only a particular device went offline\n+    private void reconnectDeviceSession(TransportException transportException, String deviceId)\n+    {\n+        long reconnectionStartTimeMillis = System.currentTimeMillis();\n+        int reconnectionAttempt = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "originalPosition": 366}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODE2ODI4", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522816828", "createdAt": "2020-11-03T19:35:33Z", "commit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTozNTozM1rOHs9pWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTozNTozM1rOHs9pWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwOTQwMA==", "bodyText": "Poor grammar. Maybe this?\n\"Attempting device session reconnect: attempt {}\"", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516909400", "createdAt": "2020-11-03T19:35:33Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubTransport.java", "diffHunk": "@@ -820,21 +901,80 @@ private void handleDisconnection(TransportException transportException)\n         reconnect(transportException);\n     }\n \n+    // should only be called when multiplexing an only a particular device went offline\n+    private void reconnectDeviceSession(TransportException transportException, String deviceId)\n+    {\n+        long reconnectionStartTimeMillis = System.currentTimeMillis();\n+        int reconnectionAttempt = 0;\n+        boolean hasReconnectOperationTimedOut = this.hasOperationTimedOut(reconnectionStartTimeMillis, deviceId);\n+        RetryDecision retryDecision = null;\n+\n+        while (this.deviceConnectionStates.get(deviceId) == IotHubConnectionStatus.DISCONNECTED_RETRYING\n+                && !hasReconnectOperationTimedOut)\n+        {\n+            this.log.trace(\"Attempting device session reconnect attempt {}\", reconnectionAttempt);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "originalPosition": 373}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODE3NDc3", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522817477", "createdAt": "2020-11-03T19:36:29Z", "commit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTozNjozMFrOHs9rQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTozNjozMFrOHs9rQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwOTg5MA==", "bodyText": "I mentioned it elsewhere, but don't see the comment anymore. Bracing here seems to follow .NET style guidelines, not Java.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516909890", "createdAt": "2020-11-03T19:36:30Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubTransport.java", "diffHunk": "@@ -820,21 +901,80 @@ private void handleDisconnection(TransportException transportException)\n         reconnect(transportException);\n     }\n \n+    // should only be called when multiplexing an only a particular device went offline\n+    private void reconnectDeviceSession(TransportException transportException, String deviceId)\n+    {\n+        long reconnectionStartTimeMillis = System.currentTimeMillis();\n+        int reconnectionAttempt = 0;\n+        boolean hasReconnectOperationTimedOut = this.hasOperationTimedOut(reconnectionStartTimeMillis, deviceId);\n+        RetryDecision retryDecision = null;\n+\n+        while (this.deviceConnectionStates.get(deviceId) == IotHubConnectionStatus.DISCONNECTED_RETRYING\n+                && !hasReconnectOperationTimedOut)\n+        {\n+            this.log.trace(\"Attempting device session reconnect attempt {}\", reconnectionAttempt);\n+            reconnectionAttempt++;\n+\n+            RetryPolicy retryPolicy = this.getConfig(deviceId).getRetryPolicy();\n+            retryDecision = retryPolicy.getRetryDecision(reconnectionAttempt, transportException);\n+            if (!retryDecision.shouldRetry())\n+            {\n+                break;\n+            }\n+\n+            // This call triggers some async amqp logic, so all this function can do is wait for a bit and check the connection\n+            // status for this device before retrying.\n+            singleDeviceReconnectAttemptAsync(deviceId);\n+\n+            this.log.trace(\"Sleeping between device reconnect attempts for device {}\", deviceId);\n+            IotHubTransport.sleepUninterruptibly(retryDecision.getDuration(), MILLISECONDS);\n+\n+            hasReconnectOperationTimedOut = this.hasOperationTimedOut(reconnectionStartTimeMillis);\n+        }\n+\n+        // reconnection may have failed, so check last retry decision, check for timeout, and check if last exception\n+        // was terminal\n+        try\n+        {\n+            if (retryDecision != null && !retryDecision.shouldRetry())\n+            {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "originalPosition": 398}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODE4Mzkz", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522818393", "createdAt": "2020-11-03T19:37:50Z", "commit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTozNzo1MVrOHs9uDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTozNzo1MVrOHs9uDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMDYwNA==", "bodyText": "This might also be slow for 1000 devices. Thoughts on parallelizing?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516910604", "createdAt": "2020-11-03T19:37:51Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubTransport.java", "diffHunk": "@@ -1142,23 +1297,48 @@ private void updateStatus(IotHubConnectionStatus newConnectionStatus, IotHubConn\n             //invoke connection status callbacks\n             this.log.debug(\"Invoking connection status callbacks with new status details\");\n             invokeConnectionStateCallback(newConnectionStatus, reason);\n-            invokeConnectionStatusChangeCallback(newConnectionStatus, reason, throwable);\n+\n+            if (deviceClientConfigs.size() < 2 || newConnectionStatus != IotHubConnectionStatus.CONNECTED)\n+            {\n+                // When multiplexing, a different method will notify each device-specific callback when that device is online,\n+                // but in cases when the tcp connection is lost and everything is disconnected retrying or disconnected, this is where the\n+                // callback should be fired\n+                invokeConnectionStatusChangeCallback(newConnectionStatus, reason, throwable);\n+\n+                for (DeviceClientConfig config : deviceClientConfigs)\n+                {\n+                    deviceConnectionStates.put(config.getDeviceId(), newConnectionStatus);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "originalPosition": 584}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODE4OTI4", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522818928", "createdAt": "2020-11-03T19:38:38Z", "commit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTozODozOFrOHs9vpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTozODozOFrOHs9vpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMTAxNA==", "bodyText": "Do we not want to log each device's connection status?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516911014", "createdAt": "2020-11-03T19:38:38Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubTransport.java", "diffHunk": "@@ -1142,23 +1297,48 @@ private void updateStatus(IotHubConnectionStatus newConnectionStatus, IotHubConn\n             //invoke connection status callbacks\n             this.log.debug(\"Invoking connection status callbacks with new status details\");\n             invokeConnectionStateCallback(newConnectionStatus, reason);\n-            invokeConnectionStatusChangeCallback(newConnectionStatus, reason, throwable);\n+\n+            if (deviceClientConfigs.size() < 2 || newConnectionStatus != IotHubConnectionStatus.CONNECTED)\n+            {\n+                // When multiplexing, a different method will notify each device-specific callback when that device is online,\n+                // but in cases when the tcp connection is lost and everything is disconnected retrying or disconnected, this is where the\n+                // callback should be fired\n+                invokeConnectionStatusChangeCallback(newConnectionStatus, reason, throwable);\n+\n+                for (DeviceClientConfig config : deviceClientConfigs)\n+                {\n+                    deviceConnectionStates.put(config.getDeviceId(), newConnectionStatus);\n+                }\n+            }\n+\n             this.deviceIOConnectionStatusChangeCallback.execute(newConnectionStatus, reason, throwable, null);\n+        }\n+    }\n \n-            if (newConnectionStatus == IotHubConnectionStatus.CONNECTED)\n+    private void updateStatus(IotHubConnectionStatus newConnectionStatus, IotHubConnectionStatusChangeReason reason, Throwable throwable, String deviceId)\n+    {\n+        if (this.deviceConnectionStates.containsKey(deviceId) && this.deviceConnectionStates.get(deviceId) != newConnectionStatus)\n+        {\n+            if (throwable == null)\n+            {\n+                this.log.debug(\"Updating device {} status to new status {} with reason {}\", deviceId, newConnectionStatus, reason);\n+            }\n+            else\n             {\n-                //Codes_SRS_IOTHUBTRANSPORT_28_007: [This function shall reset currentReconnectionAttempt and reconnectionAttemptStartTimeMillis if connection status is changed to CONNECTED.]\n-                this.currentReconnectionAttempt = 0;\n-                this.reconnectionAttemptStartTimeMillis = 0;\n+                this.log.warn(\"Updating device {} status to new status {} with reason {}\", deviceId, newConnectionStatus, reason, throwable);\n+            }\n+\n+            synchronized (this.multiplexingDeviceStateLock)\n+            {\n+                this.deviceConnectionStates.put(deviceId, newConnectionStatus);\n+\n+                this.log.debug(\"Invoking connection status callbacks with new status details\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "originalPosition": 613}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODE5Nzc1", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522819775", "createdAt": "2020-11-03T19:39:55Z", "commit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTozOTo1NVrOHs9yaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTozOTo1NVrOHs9yaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMTcyMw==", "bodyText": "Connection reconnection? Seems a bit redundant.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516911723", "createdAt": "2020-11-03T19:39:55Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/ReconnectionNotifier.java", "diffHunk": "@@ -7,7 +7,8 @@\n \n public final class ReconnectionNotifier\n {\n-    private final static String THREAD_NAME=\"azure-iot-sdk-ReconnectionTask\";\n+    private final static String CONNECTION_RECONNECTION_THREAD_NAME=\"azure-iot-sdk-ConnectionReconnectionTask\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODIwOTQ4", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522820948", "createdAt": "2020-11-03T19:41:38Z", "commit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTo0MTozOFrOHs92Aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTo0MTozOFrOHs92Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMjY0Mw==", "bodyText": "plural should be \"Latches\"", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516912643", "createdAt": "2020-11-03T19:41:38Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/amqps/AmqpsIotHubConnection.java", "diffHunk": "@@ -220,7 +269,7 @@ public void onReactorFinal(Event event)\n     {\n         log.trace(\"Amqps reactor finalized\");\n         releaseLatch(authenticationSessionOpenedLatch);\n-        releaseLatch(deviceSessionsOpenedLatch);\n+        releaseDeviceSessionLatchs();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "originalPosition": 181}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODIyOTQ1", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522822945", "createdAt": "2020-11-03T19:44:46Z", "commit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTo0NDo0N1rOHs984A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTo0NDo0N1rOHs984A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxNDQwMA==", "bodyText": "What is CBS besides a TV network?\nIn .NET we'd case this as Cbs. All caps for Java?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516914400", "createdAt": "2020-11-03T19:44:47Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/amqps/AmqpsIotHubConnection.java", "diffHunk": "@@ -505,17 +584,48 @@ public void onAuthenticationFailed(TransportException transportException)\n     {\n         this.savedException = transportException;\n         releaseLatch(authenticationSessionOpenedLatch);\n-        releaseLatch(deviceSessionsOpenedLatch);\n+        releaseDeviceSessionLatchs();\n+    }\n+\n+    @Override\n+    public void onSessionClosedUnexpectedly(ErrorCondition errorCondition, String deviceId)\n+    {\n+        TransportException savedException = AmqpsExceptionTranslator.convertFromAmqpException(errorCondition);\n+\n+        if (this.deviceClientConfigs.size() > 1)\n+        {\n+            // When multiplexing, don't kill the connection just because a session dropped.\n+            log.error(\"Amqp session closed unexpectedly. notifying the transport layer to start reconnection logic...\", this.savedException);\n+            scheduleDeviceSessionReconnection(savedException, deviceId);\n+        }\n+        else\n+        {\n+            // When not multiplexing, reconnection logic will just spin up the whole connection again.\n+            this.savedException = savedException;\n+            log.error(\"Amqp session closed unexpectedly. Closing this connection...\", this.savedException);\n+            this.connection.close();\n+        }\n     }\n \n     @Override\n-    public void onSessionClosedUnexpectedly(ErrorCondition errorCondition)\n+    public void onCBSSessionClosedUnexpectedly(ErrorCondition errorCondition)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "originalPosition": 414}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODIzNjcx", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522823671", "createdAt": "2020-11-03T19:45:52Z", "commit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTo0NTo1MlrOHs9_IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTo0NTo1MlrOHs9_IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxNDk3Ng==", "bodyText": "Grammar, semi-colon instead of comma.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516914976", "createdAt": "2020-11-03T19:45:52Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/amqps/AmqpsIotHubConnection.java", "diffHunk": "@@ -651,20 +779,110 @@ private void addDeviceSession(DeviceClientConfig deviceClientConfig, boolean aft\n         if (amqpsSessionHandler == null)\n         {\n             amqpsSessionHandler = new AmqpsSessionHandler(deviceClientConfig, this);\n-            this.sessionHandlerList.add(amqpsSessionHandler);\n+            this.sessionHandlers.add(amqpsSessionHandler);\n         }\n \n-        if (afterOpen)\n+        return amqpsSessionHandler;\n+    }\n+\n+    // This function is called periodically from the onTimerTask reactor callback so that any newly registered device sessions\n+    // can be opened on a reactor thread instead of from one of our threads.\n+    private void checkForNewlyRegisteredMultiplexedClientsToStart()\n+    {\n+        DeviceClientConfig configToRegister = this.multiplexingClientsToRegister.poll();\n+        while (configToRegister != null)\n         {\n+            AmqpsSessionHandler amqpsSessionHandler = createSessionHandler(configToRegister);\n+\n+            log.trace(\"Adding device session for device {} to an active connection\", configToRegister.getDeviceId());\n             amqpsSessionHandler.setSession(this.connection.session());\n+            AmqpsSasTokenRenewalHandler amqpsSasTokenRenewalHandler = new AmqpsSasTokenRenewalHandler(amqpsCbsSessionHandler, amqpsSessionHandler);\n+            sasTokenRenewalHandlers.add(amqpsSasTokenRenewalHandler);\n+            try\n+            {\n+                amqpsSasTokenRenewalHandler.sendAuthenticationMessage(this.reactor);\n+            }\n+            catch (TransportException e)\n+            {\n+                log.warn(\"Failed to send authentication message for device {}, will try again.\", amqpsSasTokenRenewalHandler.amqpsSessionHandler.getDeviceId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "originalPosition": 533}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODI2NTcy", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522826572", "createdAt": "2020-11-03T19:50:24Z", "commit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTo1MDoyNVrOHs-Iaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTo1MDoyNVrOHs-Iaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxNzM1NQ==", "bodyText": "Any comment here to indicate the transport client is being deprecated?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516917355", "createdAt": "2020-11-03T19:50:25Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/amqps/IoTHubConnectionType.java", "diffHunk": "@@ -7,5 +7,6 @@\n {\n     UNKNOWN,\n     SINGLE_CLIENT,\n-    USE_TRANSPORTCLIENT\n+    USE_TRANSPORTCLIENT,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7af2b477c526150c91e5853fcb3ddd8b39fe760"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODMxNDU1", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522831455", "createdAt": "2020-11-03T19:57:26Z", "commit": {"oid": "5db894c5cc5bd857420858e32d544b3312eaf92d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTo1NzoyN1rOHs-YOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTo1NzoyN1rOHs-YOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkyMTQwMg==", "bodyText": "We don't have a way to distinguish exceptions except by the message?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r516921402", "createdAt": "2020-11-03T19:57:27Z", "author": {"login": "drwill-ms"}, "path": "iot-e2e-tests/common/src/test/java/tests/integration/com/microsoft/azure/sdk/iot/helpers/rules/ThrottleResistantTestRule.java", "diffHunk": "@@ -49,6 +50,19 @@ public void evaluate() throws Throwable {\n                     log.warn(\"Thottling detected in test {}, waiting for {} milliseconds and then re-running the test\", description.getMethodName(), THROTTLING_RETRY_DELAY_MILLISECONDS, e);\n                     Thread.sleep(THROTTLING_RETRY_DELAY_MILLISECONDS);\n                 }\n+                catch (Exception e)\n+                {\n+                    if (e.getMessage().toLowerCase().contains(CONNECTION_REFUSED))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5db894c5cc5bd857420858e32d544b3312eaf92d"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyOTUyNzg3", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522952787", "createdAt": "2020-11-03T23:43:27Z", "commit": {"oid": "cbb5b54eb5573f67b173b33575f240c7d0387fa9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMzo0MzoyOFrOHtEYFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMzo0MzoyOFrOHtEYFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAxOTY2OQ==", "bodyText": "Is this not already covered by the previous import?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r517019669", "createdAt": "2020-11-03T23:43:28Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexingSample.java", "diffHunk": "@@ -0,0 +1,169 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbb5b54eb5573f67b173b33575f240c7d0387fa9"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyOTUyOTQ2", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522952946", "createdAt": "2020-11-03T23:44:00Z", "commit": {"oid": "cbb5b54eb5573f67b173b33575f240c7d0387fa9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMzo0NDowMFrOHtEYkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMzo0NDowMFrOHtEYkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAxOTc5NA==", "bodyText": "So anyone can change this, not just this class?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r517019794", "createdAt": "2020-11-03T23:44:00Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexingSample.java", "diffHunk": "@@ -0,0 +1,169 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+/**\n+ * Sample that demonstrates creating a multiplexed connection to IoT Hub using AMQPS / AMQPS_WS. It also demonstrates\n+ * removing and adding device clients from the multiplexed connection while it is open.\n+ */\n+public class MultiplexingSample\n+{\n+    // Every multiplexed device will maintain its own connection status callback. Because of that, you can monitor\n+    // if a particular device session goes offline unexpectedly. This connection status callback is also how you\n+    // confirm when a device client is connected after registering it to an active multiplexed connection since the .registerDeviceClient(...)\n+    // call behaves asynchronously when the multiplexing client is already open. Similarly, this callback is used to track\n+    // when a device client is closed when unregistering it from an active connection.\n+    public static class MultiplexedDeviceConnectionStatusChangeTracker implements IotHubConnectionStatusChangeCallback\n+    {\n+        public boolean isOpen = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbb5b54eb5573f67b173b33575f240c7d0387fa9"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyOTUzMjY3", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522953267", "createdAt": "2020-11-03T23:44:58Z", "commit": {"oid": "cbb5b54eb5573f67b173b33575f240c7d0387fa9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMzo0NDo1OFrOHtEZzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMzo0NDo1OFrOHtEZzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAyMDExMA==", "bodyText": "Can we give this a more specific name? TelemetryAckCallback?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r517020110", "createdAt": "2020-11-03T23:44:58Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexingSample.java", "diffHunk": "@@ -0,0 +1,169 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+/**\n+ * Sample that demonstrates creating a multiplexed connection to IoT Hub using AMQPS / AMQPS_WS. It also demonstrates\n+ * removing and adding device clients from the multiplexed connection while it is open.\n+ */\n+public class MultiplexingSample\n+{\n+    // Every multiplexed device will maintain its own connection status callback. Because of that, you can monitor\n+    // if a particular device session goes offline unexpectedly. This connection status callback is also how you\n+    // confirm when a device client is connected after registering it to an active multiplexed connection since the .registerDeviceClient(...)\n+    // call behaves asynchronously when the multiplexing client is already open. Similarly, this callback is used to track\n+    // when a device client is closed when unregistering it from an active connection.\n+    public static class MultiplexedDeviceConnectionStatusChangeTracker implements IotHubConnectionStatusChangeCallback\n+    {\n+        public boolean isOpen = false;\n+        public boolean isDisconnectedRetrying = false;\n+\n+        @Override\n+        public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext)\n+        {\n+            String deviceId = (String) callbackContext;\n+\n+            if (throwable == null)\n+            {\n+                System.out.println(\"CONNECTION STATUS UPDATE FOR DEVICE \" + deviceId + \" - \" + status + \", \" + statusChangeReason);\n+            }\n+            else\n+            {\n+                System.out.println(\"CONNECTION STATUS UPDATE FOR DEVICE \" + deviceId + \" - \" + status + \", \" + statusChangeReason + \", \" + throwable.getMessage());\n+            }\n+\n+            if (status == IotHubConnectionStatus.CONNECTED)\n+            {\n+                isOpen = true;\n+                isDisconnectedRetrying = false;\n+            }\n+            else if (status == IotHubConnectionStatus.DISCONNECTED)\n+            {\n+                isOpen = false;\n+                isDisconnectedRetrying = false;\n+            }\n+            else if (status == IotHubConnectionStatus.DISCONNECTED_RETRYING)\n+            {\n+                isDisconnectedRetrying = true;\n+                isOpen = false;\n+            }\n+        }\n+    }\n+\n+    public static int acknowledgedSentMessages = 0;\n+    protected static class EventCallback implements IotHubEventCallback", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbb5b54eb5573f67b173b33575f240c7d0387fa9"}, "originalPosition": 61}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyOTU0MDcx", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522954071", "createdAt": "2020-11-03T23:47:10Z", "commit": {"oid": "cbb5b54eb5573f67b173b33575f240c7d0387fa9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMzo0NzoxMFrOHtEcfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMzo0NzoxMFrOHtEcfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAyMDc5Nw==", "bodyText": "As discussed, I think this would work better as a HashMap of <string deviceId, DeviceClient deviceClient> and illustrate sending telemetry as devices (and other operations) by looking up a device client by the device Id.\nTo iterate, you'd have a list of your registered devices, use that to look up your HashMap, and perform the action on the DeviceClient.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r517020797", "createdAt": "2020-11-03T23:47:10Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexingSample.java", "diffHunk": "@@ -0,0 +1,169 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+/**\n+ * Sample that demonstrates creating a multiplexed connection to IoT Hub using AMQPS / AMQPS_WS. It also demonstrates\n+ * removing and adding device clients from the multiplexed connection while it is open.\n+ */\n+public class MultiplexingSample\n+{\n+    // Every multiplexed device will maintain its own connection status callback. Because of that, you can monitor\n+    // if a particular device session goes offline unexpectedly. This connection status callback is also how you\n+    // confirm when a device client is connected after registering it to an active multiplexed connection since the .registerDeviceClient(...)\n+    // call behaves asynchronously when the multiplexing client is already open. Similarly, this callback is used to track\n+    // when a device client is closed when unregistering it from an active connection.\n+    public static class MultiplexedDeviceConnectionStatusChangeTracker implements IotHubConnectionStatusChangeCallback\n+    {\n+        public boolean isOpen = false;\n+        public boolean isDisconnectedRetrying = false;\n+\n+        @Override\n+        public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext)\n+        {\n+            String deviceId = (String) callbackContext;\n+\n+            if (throwable == null)\n+            {\n+                System.out.println(\"CONNECTION STATUS UPDATE FOR DEVICE \" + deviceId + \" - \" + status + \", \" + statusChangeReason);\n+            }\n+            else\n+            {\n+                System.out.println(\"CONNECTION STATUS UPDATE FOR DEVICE \" + deviceId + \" - \" + status + \", \" + statusChangeReason + \", \" + throwable.getMessage());\n+            }\n+\n+            if (status == IotHubConnectionStatus.CONNECTED)\n+            {\n+                isOpen = true;\n+                isDisconnectedRetrying = false;\n+            }\n+            else if (status == IotHubConnectionStatus.DISCONNECTED)\n+            {\n+                isOpen = false;\n+                isDisconnectedRetrying = false;\n+            }\n+            else if (status == IotHubConnectionStatus.DISCONNECTED_RETRYING)\n+            {\n+                isDisconnectedRetrying = true;\n+                isOpen = false;\n+            }\n+        }\n+    }\n+\n+    public static int acknowledgedSentMessages = 0;\n+    protected static class EventCallback implements IotHubEventCallback\n+    {\n+        public void execute(IotHubStatusCode status, Object context)\n+        {\n+            String messageId = (String) context;\n+            System.out.println(\"IoT Hub responded to message \"+ messageId  + \" with status \" + status.name());\n+            acknowledgedSentMessages++;\n+        }\n+    }\n+\n+    private static final int MULTIPLEXED_DEVICE_CLIENT_COUNT = 3;\n+\n+    /**\n+     * Multiplex devices an IoT Hub using AMQPS / AMQPS_WS\n+     *\n+     * @param args\n+     * args[0] = IoT Hub connection string - Device Client 1\n+     * args[1] = IoT Hub connection string - Device Client 2\n+     * args[2] = IoT Hub connection string - Device Client 3\n+     */\n+    public static void main(String[] args)\n+            throws IOException, URISyntaxException, InterruptedException {\n+        System.out.println(\"Starting...\");\n+        System.out.println(\"Beginning setup.\");\n+\n+        if (args.length != 4)\n+        {\n+            System.out.format(\n+                    \"Expected 3 arguments but received: %d.\\n\"\n+                            + \"The program should be called with the following args: \\n\"\n+                            + \"1. [Device 1 connection string] - String containing Hostname, Device Id & Device Key in one of the following formats: HostName=<iothub_host_name>;DeviceId=<device_id>;SharedAccessKey=<device_key>\\n\"\n+                            + \"2. [Device 2 connection string] - String containing Hostname, Device Id & Device Key in one of the following formats: HostName=<iothub_host_name>;DeviceId=<device_id>;SharedAccessKey=<device_key>\\n\"\n+                            + \"3. [Device 3 connection string] - String containing Hostname, Device Id & Device Key in one of the following formats: HostName=<iothub_host_name>;DeviceId=<device_id>;SharedAccessKey=<device_key>\\n\"\n+                            + \"4. [Protocol]                   - amqps | amqps_ws\\n\",\n+                    args.length);\n+            return;\n+        }\n+\n+        String connString1 = args[0];\n+        String connString2 = args[1];\n+        String connString3 = args[2];\n+        IotHubClientProtocol protocol = IotHubClientProtocol.AMQPS;\n+        if (args[3].equalsIgnoreCase(\"amqps_ws\"))\n+        {\n+            protocol = IotHubClientProtocol.AMQPS_WS;\n+        }\n+\n+        MultiplexingClient multiplexingClient = new MultiplexingClient(protocol);\n+        DeviceClient[] multiplexedDeviceClients = new DeviceClient[MULTIPLEXED_DEVICE_CLIENT_COUNT];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbb5b54eb5573f67b173b33575f240c7d0387fa9"}, "originalPosition": 109}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyOTU0MzIz", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522954323", "createdAt": "2020-11-03T23:47:53Z", "commit": {"oid": "cbb5b54eb5573f67b173b33575f240c7d0387fa9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMzo0Nzo1M1rOHtEdTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMzo0Nzo1M1rOHtEdTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAyMTAwNg==", "bodyText": "Probably should print the number of messages acked, and how many more you are waiting for.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r517021006", "createdAt": "2020-11-03T23:47:53Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexingSample.java", "diffHunk": "@@ -0,0 +1,169 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+/**\n+ * Sample that demonstrates creating a multiplexed connection to IoT Hub using AMQPS / AMQPS_WS. It also demonstrates\n+ * removing and adding device clients from the multiplexed connection while it is open.\n+ */\n+public class MultiplexingSample\n+{\n+    // Every multiplexed device will maintain its own connection status callback. Because of that, you can monitor\n+    // if a particular device session goes offline unexpectedly. This connection status callback is also how you\n+    // confirm when a device client is connected after registering it to an active multiplexed connection since the .registerDeviceClient(...)\n+    // call behaves asynchronously when the multiplexing client is already open. Similarly, this callback is used to track\n+    // when a device client is closed when unregistering it from an active connection.\n+    public static class MultiplexedDeviceConnectionStatusChangeTracker implements IotHubConnectionStatusChangeCallback\n+    {\n+        public boolean isOpen = false;\n+        public boolean isDisconnectedRetrying = false;\n+\n+        @Override\n+        public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext)\n+        {\n+            String deviceId = (String) callbackContext;\n+\n+            if (throwable == null)\n+            {\n+                System.out.println(\"CONNECTION STATUS UPDATE FOR DEVICE \" + deviceId + \" - \" + status + \", \" + statusChangeReason);\n+            }\n+            else\n+            {\n+                System.out.println(\"CONNECTION STATUS UPDATE FOR DEVICE \" + deviceId + \" - \" + status + \", \" + statusChangeReason + \", \" + throwable.getMessage());\n+            }\n+\n+            if (status == IotHubConnectionStatus.CONNECTED)\n+            {\n+                isOpen = true;\n+                isDisconnectedRetrying = false;\n+            }\n+            else if (status == IotHubConnectionStatus.DISCONNECTED)\n+            {\n+                isOpen = false;\n+                isDisconnectedRetrying = false;\n+            }\n+            else if (status == IotHubConnectionStatus.DISCONNECTED_RETRYING)\n+            {\n+                isDisconnectedRetrying = true;\n+                isOpen = false;\n+            }\n+        }\n+    }\n+\n+    public static int acknowledgedSentMessages = 0;\n+    protected static class EventCallback implements IotHubEventCallback\n+    {\n+        public void execute(IotHubStatusCode status, Object context)\n+        {\n+            String messageId = (String) context;\n+            System.out.println(\"IoT Hub responded to message \"+ messageId  + \" with status \" + status.name());\n+            acknowledgedSentMessages++;\n+        }\n+    }\n+\n+    private static final int MULTIPLEXED_DEVICE_CLIENT_COUNT = 3;\n+\n+    /**\n+     * Multiplex devices an IoT Hub using AMQPS / AMQPS_WS\n+     *\n+     * @param args\n+     * args[0] = IoT Hub connection string - Device Client 1\n+     * args[1] = IoT Hub connection string - Device Client 2\n+     * args[2] = IoT Hub connection string - Device Client 3\n+     */\n+    public static void main(String[] args)\n+            throws IOException, URISyntaxException, InterruptedException {\n+        System.out.println(\"Starting...\");\n+        System.out.println(\"Beginning setup.\");\n+\n+        if (args.length != 4)\n+        {\n+            System.out.format(\n+                    \"Expected 3 arguments but received: %d.\\n\"\n+                            + \"The program should be called with the following args: \\n\"\n+                            + \"1. [Device 1 connection string] - String containing Hostname, Device Id & Device Key in one of the following formats: HostName=<iothub_host_name>;DeviceId=<device_id>;SharedAccessKey=<device_key>\\n\"\n+                            + \"2. [Device 2 connection string] - String containing Hostname, Device Id & Device Key in one of the following formats: HostName=<iothub_host_name>;DeviceId=<device_id>;SharedAccessKey=<device_key>\\n\"\n+                            + \"3. [Device 3 connection string] - String containing Hostname, Device Id & Device Key in one of the following formats: HostName=<iothub_host_name>;DeviceId=<device_id>;SharedAccessKey=<device_key>\\n\"\n+                            + \"4. [Protocol]                   - amqps | amqps_ws\\n\",\n+                    args.length);\n+            return;\n+        }\n+\n+        String connString1 = args[0];\n+        String connString2 = args[1];\n+        String connString3 = args[2];\n+        IotHubClientProtocol protocol = IotHubClientProtocol.AMQPS;\n+        if (args[3].equalsIgnoreCase(\"amqps_ws\"))\n+        {\n+            protocol = IotHubClientProtocol.AMQPS_WS;\n+        }\n+\n+        MultiplexingClient multiplexingClient = new MultiplexingClient(protocol);\n+        DeviceClient[] multiplexedDeviceClients = new DeviceClient[MULTIPLEXED_DEVICE_CLIENT_COUNT];\n+        MultiplexedDeviceConnectionStatusChangeTracker[] connectionStatusTrackers = new MultiplexedDeviceConnectionStatusChangeTracker[MULTIPLEXED_DEVICE_CLIENT_COUNT];\n+\n+        for (int i = 0; i < MULTIPLEXED_DEVICE_CLIENT_COUNT; i++)\n+        {\n+            multiplexedDeviceClients[i] = new DeviceClient(args[i], protocol);\n+            String deviceId = multiplexedDeviceClients[i].getConfig().getDeviceId();\n+            connectionStatusTrackers[i] = new MultiplexedDeviceConnectionStatusChangeTracker();\n+            multiplexedDeviceClients[i].registerConnectionStatusChangeCallback(connectionStatusTrackers[i], deviceId);\n+            multiplexingClient.registerDeviceClient(multiplexedDeviceClients[i]);\n+        }\n+\n+        System.out.println(\"Opening multiplexed connection\");\n+        // All previously registered device clients will be opened alongside this multiplexing client\n+        multiplexingClient.open();\n+        System.out.println(\"Multiplexed connection opened successfully\");\n+\n+        for (int i = 0; i < MULTIPLEXED_DEVICE_CLIENT_COUNT; i++)\n+        {\n+            Message message = new Message(\"some payload\");\n+            multiplexedDeviceClients[i].sendEventAsync(message, new EventCallback(), message.getMessageId());\n+        }\n+\n+        System.out.println(\"Waiting while messages get sent asynchronously...\");\n+        while (acknowledgedSentMessages < MULTIPLEXED_DEVICE_CLIENT_COUNT)\n+        {\n+            Thread.sleep(200);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbb5b54eb5573f67b173b33575f240c7d0387fa9"}, "originalPosition": 135}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyOTU0NTQ4", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522954548", "createdAt": "2020-11-03T23:48:28Z", "commit": {"oid": "cbb5b54eb5573f67b173b33575f240c7d0387fa9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMzo0ODoyOVrOHtEeCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMzo0ODoyOVrOHtEeCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAyMTE5Mg==", "bodyText": "Consider adding big comment blocks to announce what the next code block demonstrates.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r517021192", "createdAt": "2020-11-03T23:48:29Z", "author": {"login": "drwill-ms"}, "path": "device/iot-device-samples/multiplexing-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/MultiplexingSample.java", "diffHunk": "@@ -0,0 +1,169 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+package samples.com.microsoft.azure.sdk.iot;\n+\n+import com.microsoft.azure.sdk.iot.device.*;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+/**\n+ * Sample that demonstrates creating a multiplexed connection to IoT Hub using AMQPS / AMQPS_WS. It also demonstrates\n+ * removing and adding device clients from the multiplexed connection while it is open.\n+ */\n+public class MultiplexingSample\n+{\n+    // Every multiplexed device will maintain its own connection status callback. Because of that, you can monitor\n+    // if a particular device session goes offline unexpectedly. This connection status callback is also how you\n+    // confirm when a device client is connected after registering it to an active multiplexed connection since the .registerDeviceClient(...)\n+    // call behaves asynchronously when the multiplexing client is already open. Similarly, this callback is used to track\n+    // when a device client is closed when unregistering it from an active connection.\n+    public static class MultiplexedDeviceConnectionStatusChangeTracker implements IotHubConnectionStatusChangeCallback\n+    {\n+        public boolean isOpen = false;\n+        public boolean isDisconnectedRetrying = false;\n+\n+        @Override\n+        public void execute(IotHubConnectionStatus status, IotHubConnectionStatusChangeReason statusChangeReason, Throwable throwable, Object callbackContext)\n+        {\n+            String deviceId = (String) callbackContext;\n+\n+            if (throwable == null)\n+            {\n+                System.out.println(\"CONNECTION STATUS UPDATE FOR DEVICE \" + deviceId + \" - \" + status + \", \" + statusChangeReason);\n+            }\n+            else\n+            {\n+                System.out.println(\"CONNECTION STATUS UPDATE FOR DEVICE \" + deviceId + \" - \" + status + \", \" + statusChangeReason + \", \" + throwable.getMessage());\n+            }\n+\n+            if (status == IotHubConnectionStatus.CONNECTED)\n+            {\n+                isOpen = true;\n+                isDisconnectedRetrying = false;\n+            }\n+            else if (status == IotHubConnectionStatus.DISCONNECTED)\n+            {\n+                isOpen = false;\n+                isDisconnectedRetrying = false;\n+            }\n+            else if (status == IotHubConnectionStatus.DISCONNECTED_RETRYING)\n+            {\n+                isDisconnectedRetrying = true;\n+                isOpen = false;\n+            }\n+        }\n+    }\n+\n+    public static int acknowledgedSentMessages = 0;\n+    protected static class EventCallback implements IotHubEventCallback\n+    {\n+        public void execute(IotHubStatusCode status, Object context)\n+        {\n+            String messageId = (String) context;\n+            System.out.println(\"IoT Hub responded to message \"+ messageId  + \" with status \" + status.name());\n+            acknowledgedSentMessages++;\n+        }\n+    }\n+\n+    private static final int MULTIPLEXED_DEVICE_CLIENT_COUNT = 3;\n+\n+    /**\n+     * Multiplex devices an IoT Hub using AMQPS / AMQPS_WS\n+     *\n+     * @param args\n+     * args[0] = IoT Hub connection string - Device Client 1\n+     * args[1] = IoT Hub connection string - Device Client 2\n+     * args[2] = IoT Hub connection string - Device Client 3\n+     */\n+    public static void main(String[] args)\n+            throws IOException, URISyntaxException, InterruptedException {\n+        System.out.println(\"Starting...\");\n+        System.out.println(\"Beginning setup.\");\n+\n+        if (args.length != 4)\n+        {\n+            System.out.format(\n+                    \"Expected 3 arguments but received: %d.\\n\"\n+                            + \"The program should be called with the following args: \\n\"\n+                            + \"1. [Device 1 connection string] - String containing Hostname, Device Id & Device Key in one of the following formats: HostName=<iothub_host_name>;DeviceId=<device_id>;SharedAccessKey=<device_key>\\n\"\n+                            + \"2. [Device 2 connection string] - String containing Hostname, Device Id & Device Key in one of the following formats: HostName=<iothub_host_name>;DeviceId=<device_id>;SharedAccessKey=<device_key>\\n\"\n+                            + \"3. [Device 3 connection string] - String containing Hostname, Device Id & Device Key in one of the following formats: HostName=<iothub_host_name>;DeviceId=<device_id>;SharedAccessKey=<device_key>\\n\"\n+                            + \"4. [Protocol]                   - amqps | amqps_ws\\n\",\n+                    args.length);\n+            return;\n+        }\n+\n+        String connString1 = args[0];\n+        String connString2 = args[1];\n+        String connString3 = args[2];\n+        IotHubClientProtocol protocol = IotHubClientProtocol.AMQPS;\n+        if (args[3].equalsIgnoreCase(\"amqps_ws\"))\n+        {\n+            protocol = IotHubClientProtocol.AMQPS_WS;\n+        }\n+\n+        MultiplexingClient multiplexingClient = new MultiplexingClient(protocol);\n+        DeviceClient[] multiplexedDeviceClients = new DeviceClient[MULTIPLEXED_DEVICE_CLIENT_COUNT];\n+        MultiplexedDeviceConnectionStatusChangeTracker[] connectionStatusTrackers = new MultiplexedDeviceConnectionStatusChangeTracker[MULTIPLEXED_DEVICE_CLIENT_COUNT];\n+\n+        for (int i = 0; i < MULTIPLEXED_DEVICE_CLIENT_COUNT; i++)\n+        {\n+            multiplexedDeviceClients[i] = new DeviceClient(args[i], protocol);\n+            String deviceId = multiplexedDeviceClients[i].getConfig().getDeviceId();\n+            connectionStatusTrackers[i] = new MultiplexedDeviceConnectionStatusChangeTracker();\n+            multiplexedDeviceClients[i].registerConnectionStatusChangeCallback(connectionStatusTrackers[i], deviceId);\n+            multiplexingClient.registerDeviceClient(multiplexedDeviceClients[i]);\n+        }\n+\n+        System.out.println(\"Opening multiplexed connection\");\n+        // All previously registered device clients will be opened alongside this multiplexing client\n+        multiplexingClient.open();\n+        System.out.println(\"Multiplexed connection opened successfully\");\n+\n+        for (int i = 0; i < MULTIPLEXED_DEVICE_CLIENT_COUNT; i++)\n+        {\n+            Message message = new Message(\"some payload\");\n+            multiplexedDeviceClients[i].sendEventAsync(message, new EventCallback(), message.getMessageId());\n+        }\n+\n+        System.out.println(\"Waiting while messages get sent asynchronously...\");\n+        while (acknowledgedSentMessages < MULTIPLEXED_DEVICE_CLIENT_COUNT)\n+        {\n+            Thread.sleep(200);\n+        }\n+\n+        int deviceIndexToUnregister = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbb5b54eb5573f67b173b33575f240c7d0387fa9"}, "originalPosition": 138}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyOTU1MTc2", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522955176", "createdAt": "2020-11-03T23:50:20Z", "commit": {"oid": "5e463891692c12152a7a402badc1070b64c27f95"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMzo1MDoyMFrOHtEgQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMzo1MDoyMFrOHtEgQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAyMTc2Mg==", "bodyText": "what if the deviceIO already exists on this device? (it has already been opened independently from the multiplex connection)\nwhat I mean is that the pre-existing device IO needs to be disposed. we also need tests for that :D", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r517021762", "createdAt": "2020-11-03T23:50:20Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+    private final Object lock = new Object();\n+\n+    private static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS = 1000;\n+    private static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS = 500;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        synchronized (this.lock)\n+        {\n+            if (deviceClientList.size() < 1)\n+            {\n+                throw new UnsupportedOperationException(\"Must register at least one device client before opening a multiplexed connection\");\n+            }\n+\n+            log.info(\"Opening multiplexing client\");\n+            this.deviceIO.open();\n+            log.info(\"Successfully opened multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        synchronized (this.lock)\n+        {\n+            log.info(\"Closing multiplexing client\");\n+            for (DeviceClient deviceClient : this.deviceClientList)\n+            {\n+                deviceClient.closeFileUpload();\n+            }\n+\n+            if (this.deviceIO != null)\n+            {\n+                this.deviceIO.multiplexClose();\n+            }\n+\n+            // Note that this method does not close each of the registered device client instances. This is intentional\n+            // as the calls to deviceClient.close() do nothing besides close the deviceIO layer, which is already closed\n+            // by the above code.\n+\n+            log.info(\"Successfully closed multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Add a device to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * Up to 1000 devices can be registered on a multiplexed AMQPS connection, and up to 500 devices can be registered on a\n+     * multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this is an asynchronous operation. You can track the state of your\n+     * device session using the {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     * That callback will execute once your device session has successfully been added to the existing multiplexed connection and\n+     * is ready to send telemetry.\n+     * <p>\n+     * Any proxy settings set to the provided device client will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client instance must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * The registered device client may have its own retry policy and its own SAS token expiry time, separate from every other multiplexed device.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If this device client is already registered, then this method will throw a {@link IllegalStateException}\n+     * <p>\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient)\n+    {\n+        Objects.requireNonNull(deviceClient);\n+\n+        synchronized (this.lock)\n+        {\n+            for (DeviceClient currentClient : deviceClientList)\n+            {\n+                String currentDeviceId = currentClient.getConfig().getDeviceId();\n+                if (currentDeviceId.equalsIgnoreCase(deviceClient.getConfig().getDeviceId()))\n+                {\n+                    log.warn(\"Device {} won't be registered to the multiplexed connection because it is already registered.\", currentDeviceId);\n+                    return;\n+                }\n+            }\n+\n+            if (deviceClient.getConfig().getAuthenticationType() != DeviceClientConfig.AuthType.SAS_TOKEN)\n+            {\n+                throw new UnsupportedOperationException(\"Can only register a device client if it uses SAS token based authentication\");\n+            }\n+\n+            if (deviceClient.getConfig().getProtocol() != this.protocol)\n+            {\n+                throw new UnsupportedOperationException(\"A device client cannot be registered to a multiplexing client that specifies a different transport protocol.\");\n+            }\n+\n+            if (this.protocol == IotHubClientProtocol.AMQPS && this.deviceClientList.size() > MAX_MULTIPLEX_DEVICE_COUNT_AMQPS)\n+            {\n+                throw new UnsupportedOperationException(String.format(\"Multiplexed connections over AMQPS only support up to %d devices\", MAX_MULTIPLEX_DEVICE_COUNT_AMQPS));\n+            }\n+\n+            // Typically client side validation is duplicate work, but IoT Hub doesn't give a good error message when closing the\n+            // AMQPS_WS connection so this is the only way that users will know about this limit\n+            if (this.protocol == IotHubClientProtocol.AMQPS_WS && this.deviceClientList.size() > MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS)\n+            {\n+                throw new UnsupportedOperationException(String.format(\"Multiplexed connections over AMQPS_WS only support up to %d devices\", MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS));\n+            }\n+\n+            if (this.deviceClientList.size() > 1 && !this.deviceClientList.get(0).getConfig().getIotHubHostname().equalsIgnoreCase(deviceClient.getConfig().getIotHubHostname()))\n+            {\n+                throw new UnsupportedOperationException(\"Multiplexed device clients must connect to the same host name\");\n+            }\n+\n+            // The first device to be registered will cause this client to build the IO layer with its configuration\n+            if (this.deviceIO == null)\n+            {\n+                log.debug(\"Creating DeviceIO layer for multiplexing client since this is the first registered device\");\n+                this.deviceIO = new DeviceIO(deviceClient.getConfig(), SEND_PERIOD_MILLIS, RECEIVE_PERIOD_MILLIS);\n+            }\n+\n+            deviceClient.setDeviceIO(this.deviceIO);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e463891692c12152a7a402badc1070b64c27f95"}, "originalPosition": 211}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyOTYwNDQ0", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-522960444", "createdAt": "2020-11-04T00:05:28Z", "commit": {"oid": "cbb5b54eb5573f67b173b33575f240c7d0387fa9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwMDowNToyOFrOHtExwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwMDowNToyOFrOHtExwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAyNjI0MA==", "bodyText": "how do we prevent users from setting a different proxy setting after they are registered to the multiplexing client? there is a public API on the internal client that allows setting a proxySetting", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r517026240", "createdAt": "2020-11-04T00:05:28Z", "author": {"login": "azabbasi"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static long SEND_PERIOD_MILLIS = 10L;\n+    public static long RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private DeviceIO deviceIO;\n+    private ArrayList<DeviceClient> deviceClientList;\n+    private IotHubClientProtocol protocol;\n+    private ProxySettings proxySettings;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS = 1000;\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS_WS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS = 500;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol)\n+    {\n+        this(protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param proxySettings The proxy settings that this client will use.\n+     */\n+    public MultiplexingClient(IotHubClientProtocol protocol, ProxySettings proxySettings)\n+    {\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.protocol = protocol;\n+        this.proxySettings = proxySettings;\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. At least one device client must be registered prior to calling this.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        synchronized (this.lock)\n+        {\n+            if (deviceClientList.size() < 1)\n+            {\n+                throw new IllegalStateException(\"Must register at least one device client before opening a multiplexed connection\");\n+            }\n+\n+            log.info(\"Opening multiplexing client\");\n+            this.deviceIO.open();\n+            log.info(\"Successfully opened multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve the previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        synchronized (this.lock)\n+        {\n+            log.info(\"Closing multiplexing client\");\n+            for (DeviceClient deviceClient : this.deviceClientList)\n+            {\n+                deviceClient.closeFileUpload();\n+            }\n+\n+            if (this.deviceIO != null)\n+            {\n+                this.deviceIO.multiplexClose();\n+            }\n+\n+            // Note that this method does not close each of the registered device client instances. This is intentional\n+            // as the calls to deviceClient.close() do nothing besides close the deviceIO layer, which is already closed\n+            // by the above code.\n+\n+            log.info(\"Successfully closed multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Add a device to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection, but will behave differently depending on when it was called.\n+     * <p>\n+     * Up to 1000 devices can be registered on a multiplexed AMQPS connection, and up to 500 devices can be registered on a\n+     * multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this is an asynchronous operation. You can track the state of your\n+     * device session using the {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     * That callback will execute once your device session has successfully been added to the existing multiplexed connection and\n+     * is ready to send telemetry.\n+     * <p>\n+     * Any proxy settings set to the provided device client will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client instance must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * The registered device client may have its own retry policy and its own SAS token expiry time, separate from every other multiplexed device.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If this device client is already registered, then this method will throw a {@link IllegalStateException}\n+     * <p>\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient)\n+    {\n+        Objects.requireNonNull(deviceClient);\n+\n+        synchronized (this.lock)\n+        {\n+            for (DeviceClient currentClient : deviceClientList)\n+            {\n+                String currentDeviceId = currentClient.getConfig().getDeviceId();\n+                if (currentDeviceId.equalsIgnoreCase(deviceClient.getConfig().getDeviceId()))\n+                {\n+                    log.warn(\"Device {} won't be registered to the multiplexed connection because it is already registered.\", currentDeviceId);\n+                    return;\n+                }\n+            }\n+\n+            if (deviceClient.getConfig().getAuthenticationType() != DeviceClientConfig.AuthType.SAS_TOKEN)\n+            {\n+                throw new UnsupportedOperationException(\"Can only register to multiplex a device client that uses SAS token based authentication\");\n+            }\n+\n+            if (deviceClient.getConfig().getProtocol() != this.protocol)\n+            {\n+                throw new UnsupportedOperationException(\"A device client cannot be registered to a multiplexing client that specifies a different transport protocol.\");\n+            }\n+\n+            if (this.protocol == IotHubClientProtocol.AMQPS && this.deviceClientList.size() > MAX_MULTIPLEX_DEVICE_COUNT_AMQPS)\n+            {\n+                throw new UnsupportedOperationException(String.format(\"Multiplexed connections over AMQPS only support up to %d devices\", MAX_MULTIPLEX_DEVICE_COUNT_AMQPS));\n+            }\n+\n+            // Typically client side validation is duplicate work, but IoT Hub doesn't give a good error message when closing the\n+            // AMQPS_WS connection so this is the only way that users will know about this limit\n+            if (this.protocol == IotHubClientProtocol.AMQPS_WS && this.deviceClientList.size() > MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS)\n+            {\n+                throw new UnsupportedOperationException(String.format(\"Multiplexed connections over AMQPS_WS only support up to %d devices\", MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS));\n+            }\n+\n+            if (this.deviceClientList.size() > 1 && !this.deviceClientList.get(0).getConfig().getIotHubHostname().equalsIgnoreCase(deviceClient.getConfig().getIotHubHostname()))\n+            {\n+                throw new UnsupportedOperationException(\"A device client cannot be registered to a multiplexing client that specifies a different host name.\");\n+            }\n+\n+            // The first device to be registered will cause this client to build the IO layer with its configuration\n+            if (this.deviceIO == null)\n+            {\n+                log.debug(\"Creating DeviceIO layer for multiplexing client since this is the first registered device\");\n+                this.deviceIO = new DeviceIO(deviceClient.getConfig(), SEND_PERIOD_MILLIS, RECEIVE_PERIOD_MILLIS);\n+            }\n+\n+            deviceClient.setDeviceIO(this.deviceIO);\n+            deviceClient.getConfig().setProxy(this.proxySettings);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbb5b54eb5573f67b173b33575f240c7d0387fa9"}, "originalPosition": 219}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e5d6df38a3915be5f7a4263f55ec82dda8698aa8", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/e5d6df38a3915be5f7a4263f55ec82dda8698aa8", "committedDate": "2020-11-04T22:40:27Z", "message": "Add more tests"}, "afterCommit": {"oid": "0a90624dbd6bf9f1abbf79bef0783ac6fb4f46e0", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/0a90624dbd6bf9f1abbf79bef0783ac6fb4f46e0", "committedDate": "2020-11-04T22:43:43Z", "message": "temporarily add blocking flag to register call"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0a90624dbd6bf9f1abbf79bef0783ac6fb4f46e0", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/0a90624dbd6bf9f1abbf79bef0783ac6fb4f46e0", "committedDate": "2020-11-04T22:43:43Z", "message": "temporarily add blocking flag to register call"}, "afterCommit": {"oid": "cde9f0d864965504ae327bf4a8cae258a24c8c61", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/cde9f0d864965504ae327bf4a8cae258a24c8c61", "committedDate": "2020-11-05T01:15:47Z", "message": "feat(iot-dev): Add multiplexing client that supports device registration/unregistration during open connection\n\nTransportClient was our multiplexing client, but there was no way to add the ability to add/remove devices from an active connection without breaking the APIs in that class, so this deprecates the transport client in favor of a new MultiplexingClient.\n\nSignificant changes had to made to the IotHubTransport layer so that each multiplexed client could have its own connection state and so that each multiplexed client could have its own focused retry logic. Instead of closing the entire multiplexed connection every time a session drops, the transport layer can re-open individual device sessions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1ca986714466353e66f006c600ce0c9c813571d3", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/1ca986714466353e66f006c600ce0c9c813571d3", "committedDate": "2020-11-07T00:33:49Z", "message": "fixup"}, "afterCommit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/15ca17d7923d36f54663fbd8722769c315c45156", "committedDate": "2020-11-07T00:34:41Z", "message": "feat(iot-dev): Add multiplexing client that supports device registration/unregistration during open connection\n\nTransportClient was our multiplexing client, but there was no way to add the ability to add/remove devices from an active connection without breaking the APIs in that class, so this deprecates the transport client in favor of a new MultiplexingClient.\n\nSignificant changes had to made to the IotHubTransport layer so that each multiplexed client could have its own connection state and so that each multiplexed client could have its own focused retry logic. Instead of closing the entire multiplexed connection every time a session drops, the transport layer can re-open individual device sessions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NDkyNTIy", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-527492522", "createdAt": "2020-11-10T18:35:15Z", "commit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NjUyNjc1", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-527652675", "createdAt": "2020-11-10T22:16:45Z", "commit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjoxNjo0NlrOHwxxiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjoxNjo0NlrOHwxxiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkwOTE5NQ==", "bodyText": "nit: this message could be in a const string, similar to MULTIPLEXING_CLOSE_ERROR_MESSAGE.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520909195", "createdAt": "2020-11-10T22:16:46Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceClient.java", "diffHunk": "@@ -376,6 +378,11 @@ private void commonConstructorVerifications() throws UnsupportedOperationExcepti\n      */\n     public void open() throws IOException\n     {\n+        if (this.ioTHubConnectionType == IoTHubConnectionType.USE_MULTIPLEXING_CLIENT)\n+        {\n+            throw new UnsupportedOperationException(\"Cannot open a multiplexed client through this method. Must use multiplexingClient.registerDeviceClients(deviceClient)\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NjU0MzIy", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-527654322", "createdAt": "2020-11-10T22:19:34Z", "commit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjoxOTozNFrOHwx2uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjoxOTozNFrOHwx2uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxMDUyMw==", "bodyText": "I am not really clear what this means; is this set only by a multiplexing client, to indicate to this device client's DeviceIO layer (or someone else) that it is a multiplexed client?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520910523", "createdAt": "2020-11-10T22:19:34Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceClient.java", "diffHunk": "@@ -668,6 +685,12 @@ public void subscribeToDeviceMethod(DeviceMethodCallback deviceMethodCallback, O\n         this.subscribeToMethodsInternal(deviceMethodCallback, deviceMethodCallbackContext, deviceMethodStatusCallback, deviceMethodStatusCallbackContext);\n     }\n \n+    // Used by multiplexing clients to signal to this client what kind of multiplexing client is using this device client", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "originalPosition": 81}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NjU2NTI0", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-527656524", "createdAt": "2020-11-10T22:23:23Z", "commit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjoyMzoyM1rOHwx9hA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjoyMzoyM1rOHwx9hA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxMjI2MA==", "bodyText": "q - for a non-multiplexed device, what is the difference between an auth session timeout and a device session timeout?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520912260", "createdAt": "2020-11-10T22:23:23Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceClientConfig.java", "diffHunk": "@@ -31,7 +31,10 @@\n     private static final int DEFAULT_HTTPS_READ_TIMEOUT_MILLIS = 240000;\n     private static final int DEFAULT_HTTPS_CONNECT_TIMEOUT_MILLIS = 0; //no connect timeout\n \n-    private static final int DEFAULT_AMQP_OPEN_AUTHENTICATION_SESSION_TIMEOUT_IN_SECONDS = 20;\n+    // authentication session timeout is public because a multiplexed connection needs this default if no devices\n+    // were registered prior to opening the connection. No device sessions would be opened in that case though, so\n+    // the default device session timeout can stay private.\n+    public static final int DEFAULT_AMQP_OPEN_AUTHENTICATION_SESSION_TIMEOUT_IN_SECONDS = 20;\n     private static final int DEFAULT_AMQP_OPEN_DEVICE_SESSIONS_TIMEOUT_IN_SECONDS = 60;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NjU4NDU5", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-527658459", "createdAt": "2020-11-10T22:26:40Z", "commit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjoyNjo0MVrOHwyD0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjoyNjo0MVrOHwyD0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxMzg3NQ==", "bodyText": "question on a slightly unrelated-to-multiplexing note - I recently found that if the .NET sdk is initially disconnected right after initialization, it reports a \"Disconnected\" state, even though it is actively retrying at this point. Does java behave as expected?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520913875", "createdAt": "2020-11-10T22:26:41Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "diffHunk": "@@ -136,6 +130,21 @@\n         this.state = IotHubConnectionStatus.DISCONNECTED;\n     }\n \n+    DeviceIO(String hostName, IotHubClientProtocol protocol, SSLContext sslContext, ProxySettings proxySettings, long sendPeriodInMilliseconds, long receivePeriodInMilliseconds)\n+    {\n+        this.sendPeriodInMilliseconds = sendPeriodInMilliseconds;\n+        this.receivePeriodInMilliseconds = receivePeriodInMilliseconds;\n+\n+        this.state = IotHubConnectionStatus.DISCONNECTED;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "originalPosition": 79}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NjU4OTM3", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-527658937", "createdAt": "2020-11-10T22:27:32Z", "commit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjoyNzozMlrOHwyFTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjoyNzozMlrOHwyFTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNDI1NA==", "bodyText": "this line and the two below it are repeated in this block - rebase issue?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520914254", "createdAt": "2020-11-10T22:27:32Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "diffHunk": "@@ -136,6 +130,21 @@\n         this.state = IotHubConnectionStatus.DISCONNECTED;\n     }\n \n+    DeviceIO(String hostName, IotHubClientProtocol protocol, SSLContext sslContext, ProxySettings proxySettings, long sendPeriodInMilliseconds, long receivePeriodInMilliseconds)\n+    {\n+        this.sendPeriodInMilliseconds = sendPeriodInMilliseconds;\n+        this.receivePeriodInMilliseconds = receivePeriodInMilliseconds;\n+\n+        this.state = IotHubConnectionStatus.DISCONNECTED;\n+\n+        this.transport = new IotHubTransport(hostName, protocol, sslContext, proxySettings, this);\n+\n+        this.sendPeriodInMilliseconds = sendPeriodInMilliseconds;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NzA3MjQ4", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-527707248", "createdAt": "2020-11-11T00:09:33Z", "commit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMDowOTozM1rOHw0hFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMDowOTozM1rOHw0hFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1NDEzMw==", "bodyText": "Q - is this called only for multiplexed devices?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520954133", "createdAt": "2020-11-11T00:09:33Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/InternalClient.java", "diffHunk": "@@ -745,7 +773,18 @@ DeviceIO getDeviceIO()\n      */\n     void setDeviceIO(DeviceIO deviceIO)\n     {\n+        // deviceIO may be set to null in the case when a device client was multiplexing and was unregistered\n         this.deviceIO = deviceIO;\n+\n+        // Since connection status callbacks can be registered before associating a device client with a multiplexing client, the callback and its\n+        // context also need to be registered when the device IO is set.\n+        if (this.deviceIO != null && this.connectionStatusChangeCallback != null)\n+        {\n+            this.deviceIO.registerConnectionStatusChangeCallback(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "originalPosition": 143}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NzA4NzQ5", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-527708749", "createdAt": "2020-11-11T00:13:31Z", "commit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMDoxMzozMVrOHw0mMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMDoxMzozMVrOHw0mMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1NTQ0MQ==", "bodyText": "In which scenario would a user set one with a deviceId and without, or do both of them behave the same way? I see that this is publicly exposed under DeviceIO, but I don't think users access this directly, correct?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520955441", "createdAt": "2020-11-11T00:13:31Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "diffHunk": "@@ -432,10 +446,15 @@ public void registerConnectionStateCallback(IotHubConnectionStateCallback callba\n         this.transport.registerConnectionStateCallback(callback, callbackContext);\n     }\n \n-    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback statusChangeCallback, Object callbackContext)\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback statusChangeCallback, Object callbackContext, String deviceId)\n     {\n         //Codes_SRS_DEVICE_IO_34_020: [This function shall register the callback with the transport.]\n-        this.transport.registerConnectionStatusChangeCallback(statusChangeCallback, callbackContext);\n+        this.transport.registerConnectionStatusChangeCallback(statusChangeCallback, callbackContext, deviceId);\n+    }\n+\n+    public void registerMultiplexingConnectionStateCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "originalPosition": 165}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NzE3Mjc1", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-527717275", "createdAt": "2020-11-11T00:23:07Z", "commit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMDoyMzowN1rOHw0ywA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMDoyMzowN1rOHw0ywA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1ODY1Ng==", "bodyText": "q - would deviceIO ever be null? Would it be null if I were to call multiplexedClient.close() twice, in succession?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520958656", "createdAt": "2020-11-11T00:23:07Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,456 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.RetryPolicy;\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static final long DEFAULT_SEND_PERIOD_MILLIS = 10L;\n+    public static final long DEFAULT_RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private final DeviceIO deviceIO;\n+    private final ArrayList<DeviceClient> deviceClientList;\n+    private final String hostName;\n+    private final IotHubClientProtocol protocol;\n+\n+    // This lock is used to keep open/close/register/unregister operations atomic to prevent race conditions\n+    private final Object operationLock = new Object();\n+\n+    // Optional settings from MultiplexingClientOptions\n+    private SSLContext sslContext;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS = 1000;\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS_WS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS = 500;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(String hostName, IotHubClientProtocol protocol)\n+    {\n+        this(hostName, protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param options The optional parameters to configure this client to use.\n+     */\n+    public MultiplexingClient(String hostName, IotHubClientProtocol protocol, MultiplexingClientOptions options)\n+    {\n+        Objects.requireNonNull(hostName);\n+        Objects.requireNonNull(protocol);\n+\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.hostName = hostName;\n+        this.protocol = protocol;\n+        this.proxySettings = options != null ? options.getProxySettings() : null;\n+        long sendPeriod = options != null ? options.getSendPeriod() : DEFAULT_SEND_PERIOD_MILLIS;\n+        long receivePeriod = options != null ? options.getReceivePeriod() : DEFAULT_RECEIVE_PERIOD_MILLIS;\n+\n+        if (sendPeriod < 0)\n+        {\n+            throw new IllegalArgumentException(\"send period can not be negative\");\n+        }\n+        else if (sendPeriod == 0) //default builder value for this option, signals that user didn't set a value\n+        {\n+            sendPeriod = DEFAULT_SEND_PERIOD_MILLIS;\n+        }\n+\n+        if (receivePeriod < 0)\n+        {\n+            throw new IllegalArgumentException(\"receive period can not be negative\");\n+        }\n+        else if (receivePeriod == 0) //default builder value for this option, signals that user didn't set a value\n+        {\n+            receivePeriod = DEFAULT_RECEIVE_PERIOD_MILLIS;\n+        }\n+\n+        this.sslContext = options != null ? options.getSslContext() : null;\n+        this.deviceIO = new DeviceIO(hostName, protocol, sslContext, proxySettings, sendPeriod, receivePeriod);\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. This may be done before or after registering any number of device clients.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            log.info(\"Opening multiplexing client\");\n+            this.deviceIO.open();\n+            log.info(\"Successfully opened multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve all previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            log.info(\"Closing multiplexing client\");\n+            for (DeviceClient deviceClient : this.deviceClientList)\n+            {\n+                deviceClient.closeFileUpload();\n+            }\n+\n+            if (this.deviceIO != null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "originalPosition": 156}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NzE4NDk5", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-527718499", "createdAt": "2020-11-11T00:23:54Z", "commit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMDoyMzo1NFrOHw0zrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMDoyMzo1NFrOHw0zrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1ODg5NA==", "bodyText": "q - does deviceIO.close() close the transport layer? (the amqp connection)", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520958894", "createdAt": "2020-11-11T00:23:54Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,456 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.RetryPolicy;\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static final long DEFAULT_SEND_PERIOD_MILLIS = 10L;\n+    public static final long DEFAULT_RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private final DeviceIO deviceIO;\n+    private final ArrayList<DeviceClient> deviceClientList;\n+    private final String hostName;\n+    private final IotHubClientProtocol protocol;\n+\n+    // This lock is used to keep open/close/register/unregister operations atomic to prevent race conditions\n+    private final Object operationLock = new Object();\n+\n+    // Optional settings from MultiplexingClientOptions\n+    private SSLContext sslContext;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS = 1000;\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS_WS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS = 500;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(String hostName, IotHubClientProtocol protocol)\n+    {\n+        this(hostName, protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param options The optional parameters to configure this client to use.\n+     */\n+    public MultiplexingClient(String hostName, IotHubClientProtocol protocol, MultiplexingClientOptions options)\n+    {\n+        Objects.requireNonNull(hostName);\n+        Objects.requireNonNull(protocol);\n+\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.hostName = hostName;\n+        this.protocol = protocol;\n+        this.proxySettings = options != null ? options.getProxySettings() : null;\n+        long sendPeriod = options != null ? options.getSendPeriod() : DEFAULT_SEND_PERIOD_MILLIS;\n+        long receivePeriod = options != null ? options.getReceivePeriod() : DEFAULT_RECEIVE_PERIOD_MILLIS;\n+\n+        if (sendPeriod < 0)\n+        {\n+            throw new IllegalArgumentException(\"send period can not be negative\");\n+        }\n+        else if (sendPeriod == 0) //default builder value for this option, signals that user didn't set a value\n+        {\n+            sendPeriod = DEFAULT_SEND_PERIOD_MILLIS;\n+        }\n+\n+        if (receivePeriod < 0)\n+        {\n+            throw new IllegalArgumentException(\"receive period can not be negative\");\n+        }\n+        else if (receivePeriod == 0) //default builder value for this option, signals that user didn't set a value\n+        {\n+            receivePeriod = DEFAULT_RECEIVE_PERIOD_MILLIS;\n+        }\n+\n+        this.sslContext = options != null ? options.getSslContext() : null;\n+        this.deviceIO = new DeviceIO(hostName, protocol, sslContext, proxySettings, sendPeriod, receivePeriod);\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. This may be done before or after registering any number of device clients.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            log.info(\"Opening multiplexing client\");\n+            this.deviceIO.open();\n+            log.info(\"Successfully opened multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve all previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            log.info(\"Closing multiplexing client\");\n+            for (DeviceClient deviceClient : this.deviceClientList)\n+            {\n+                deviceClient.closeFileUpload();\n+            }\n+\n+            if (this.deviceIO != null)\n+            {\n+                this.deviceIO.multiplexClose();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "originalPosition": 158}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NzMwODI4", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-527730828", "createdAt": "2020-11-11T00:31:42Z", "commit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMDozMTo0MlrOHw09zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMDozMTo0MlrOHw09zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2MTQ4NQ==", "bodyText": "I remember reading above that each device client can have its own retry policy. Would the device client level retry policy (if provided) override the multiplexing client level retry policy?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520961485", "createdAt": "2020-11-11T00:31:42Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,456 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.RetryPolicy;\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static final long DEFAULT_SEND_PERIOD_MILLIS = 10L;\n+    public static final long DEFAULT_RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private final DeviceIO deviceIO;\n+    private final ArrayList<DeviceClient> deviceClientList;\n+    private final String hostName;\n+    private final IotHubClientProtocol protocol;\n+\n+    // This lock is used to keep open/close/register/unregister operations atomic to prevent race conditions\n+    private final Object operationLock = new Object();\n+\n+    // Optional settings from MultiplexingClientOptions\n+    private SSLContext sslContext;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS = 1000;\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS_WS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS = 500;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(String hostName, IotHubClientProtocol protocol)\n+    {\n+        this(hostName, protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param options The optional parameters to configure this client to use.\n+     */\n+    public MultiplexingClient(String hostName, IotHubClientProtocol protocol, MultiplexingClientOptions options)\n+    {\n+        Objects.requireNonNull(hostName);\n+        Objects.requireNonNull(protocol);\n+\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.hostName = hostName;\n+        this.protocol = protocol;\n+        this.proxySettings = options != null ? options.getProxySettings() : null;\n+        long sendPeriod = options != null ? options.getSendPeriod() : DEFAULT_SEND_PERIOD_MILLIS;\n+        long receivePeriod = options != null ? options.getReceivePeriod() : DEFAULT_RECEIVE_PERIOD_MILLIS;\n+\n+        if (sendPeriod < 0)\n+        {\n+            throw new IllegalArgumentException(\"send period can not be negative\");\n+        }\n+        else if (sendPeriod == 0) //default builder value for this option, signals that user didn't set a value\n+        {\n+            sendPeriod = DEFAULT_SEND_PERIOD_MILLIS;\n+        }\n+\n+        if (receivePeriod < 0)\n+        {\n+            throw new IllegalArgumentException(\"receive period can not be negative\");\n+        }\n+        else if (receivePeriod == 0) //default builder value for this option, signals that user didn't set a value\n+        {\n+            receivePeriod = DEFAULT_RECEIVE_PERIOD_MILLIS;\n+        }\n+\n+        this.sslContext = options != null ? options.getSslContext() : null;\n+        this.deviceIO = new DeviceIO(hostName, protocol, sslContext, proxySettings, sendPeriod, receivePeriod);\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. This may be done before or after registering any number of device clients.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            log.info(\"Opening multiplexing client\");\n+            this.deviceIO.open();\n+            log.info(\"Successfully opened multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve all previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            log.info(\"Closing multiplexing client\");\n+            for (DeviceClient deviceClient : this.deviceClientList)\n+            {\n+                deviceClient.closeFileUpload();\n+            }\n+\n+            if (this.deviceIO != null)\n+            {\n+                this.deviceIO.multiplexClose();\n+            }\n+\n+            // Note that this method does not close each of the registered device client instances. This is intentional\n+            // as the calls to deviceClient.close() do nothing besides close the deviceIO layer, which is already closed\n+            // by the above code.\n+\n+            log.info(\"Successfully closed multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Register a device client to this multiplexing client. This method may be called before or after opening the\n+     * multiplexed connection.\n+     * <p>\n+     * Users should use {@link #registerDeviceClients(Iterable)} for registering multiple devices as it has some\n+     * performance improvements over repeatedly calling this method. This method blocks on each registration, whereas\n+     * {@link #registerDeviceClients(Iterable)} blocks on all of the registrations after starting them all asynchronously.\n+     * <p>\n+     * Up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS} devices can be registered on a multiplexed AMQPS connection,\n+     * and up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS} devices can be registered on a multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will add this device client to the\n+     * multiplexed connection, and then will block until the registration has been completed.\n+     * <p>\n+     * Any proxy settings set to the provided device clients will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * Each registered device client may have its own retry policy and its own SAS token expiry time, separate from every other registered device client.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If the provided device client is already registered to this multiplexing client, then then this method will do nothing.\n+     * <p>\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n+     * will never be thrown if the multiplexing client is not open yet.\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient) throws InterruptedException {\n+        Objects.requireNonNull(deviceClient);\n+        List<DeviceClient> clientList = new ArrayList<>();\n+        clientList.add(deviceClient);\n+        registerDeviceClients(clientList);\n+    }\n+\n+    /**\n+     * Register device clients to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection.\n+     * <p>\n+     * Up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS} devices can be registered on a multiplexed AMQPS connection,\n+     * and up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS} devices can be registered on a multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then these device clients will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then these device clients will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will asynchronously add each device client to the\n+     * multiplexed connection, and then will block until all registrations have been completed.\n+     * <p>\n+     * Any proxy settings set to the provided device clients will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device clients must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * Each registered device client may have its own retry policy and its own SAS token expiry time, separate from every other registered device client.\n+     * <p>\n+     * The registered device clients must use symmetric key based authentication.\n+     * <p>\n+     * The registered device clients must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If any of these device clients are already registered to this multiplexing client, then then this method will\n+     * not do anything to that particular device client. All other provided device clients will still be registered though.\n+     * <p>\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n+     * will never be thrown if the multiplexing client is not open yet.\n+     * @param deviceClients The device clients to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClients(Iterable<DeviceClient> deviceClients) throws InterruptedException {\n+        Objects.requireNonNull(deviceClients);\n+\n+        synchronized (this.operationLock)\n+        {\n+            List<DeviceClientConfig> deviceClientConfigsToRegister = new ArrayList<>();\n+            for (DeviceClient deviceClientToRegister : deviceClients)\n+            {\n+                DeviceClientConfig configToAdd = deviceClientToRegister.getConfig();\n+\n+                // Overwrite the sslContext of the new client to match the multiplexing client\n+                // settings if it was set. If it wasn't set, defer to the default client to set this ssl context\n+                if (this.sslContext != null)\n+                {\n+                    configToAdd.getAuthenticationProvider().setSSLContext(this.sslContext);\n+                }\n+\n+                // Overwrite the proxy settings of the new client to match the multiplexing client settings\n+                configToAdd.setProxy(this.proxySettings);\n+\n+                boolean deviceAlreadyRegistered = false;\n+                for (DeviceClient currentClient : deviceClientList)\n+                {\n+                    String currentDeviceId = currentClient.getConfig().getDeviceId();\n+                    if (currentDeviceId.equalsIgnoreCase(configToAdd.getDeviceId()))\n+                    {\n+                        deviceAlreadyRegistered = true;\n+                        break;\n+                    }\n+                }\n+\n+                if (deviceAlreadyRegistered)\n+                {\n+                    log.debug(\"Device {} wasn't registered to the multiplexed connection because it is already registered.\", configToAdd.getDeviceId());\n+                    continue;\n+                }\n+\n+                if (configToAdd.getAuthenticationType() != DeviceClientConfig.AuthType.SAS_TOKEN)\n+                {\n+                    throw new UnsupportedOperationException(\"Can only register to multiplex a device client that uses SAS token based authentication\");\n+                }\n+\n+                if (configToAdd.getProtocol() != this.protocol)\n+                {\n+                    throw new UnsupportedOperationException(\"A device client cannot be registered to a multiplexing client that specifies a different transport protocol.\");\n+                }\n+\n+                if (this.protocol == IotHubClientProtocol.AMQPS && this.deviceClientList.size() > MAX_MULTIPLEX_DEVICE_COUNT_AMQPS)\n+                {\n+                    throw new UnsupportedOperationException(String.format(\"Multiplexed connections over AMQPS only support up to %d devices\", MAX_MULTIPLEX_DEVICE_COUNT_AMQPS));\n+                }\n+\n+                // Typically client side validation is duplicate work, but IoT Hub doesn't give a good error message when closing the\n+                // AMQPS_WS connection so this is the only way that users will know about this limit\n+                if (this.protocol == IotHubClientProtocol.AMQPS_WS && this.deviceClientList.size() > MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS)\n+                {\n+                    throw new UnsupportedOperationException(String.format(\"Multiplexed connections over AMQPS_WS only support up to %d devices\", MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS));\n+                }\n+\n+                if (!this.hostName.equalsIgnoreCase(configToAdd.getIotHubHostname()))\n+                {\n+                    throw new UnsupportedOperationException(\"A device client cannot be registered to a multiplexing client that specifies a different host name.\");\n+                }\n+\n+                if (deviceClientToRegister.getDeviceIO() != null && deviceClientToRegister.getDeviceIO().isOpen())\n+                {\n+                    throw new IllegalStateException(\"Cannot register a device client to a multiplexed connection when it the device client was already opened.\");\n+                }\n+\n+                deviceClientToRegister.setAsMultiplexed();\n+                deviceClientToRegister.setDeviceIO(this.deviceIO);\n+                deviceClientToRegister.setConnectionType(IoTHubConnectionType.USE_MULTIPLEXING_CLIENT);\n+                this.deviceClientList.add(deviceClientToRegister);\n+                deviceClientConfigsToRegister.add(configToAdd);\n+            }\n+\n+            // if the device IO hasn't been created yet, then this client will be registered once it is created.\n+            for (DeviceClientConfig configBeingRegistered : deviceClientConfigsToRegister)\n+            {\n+                log.info(\"Registering device {} to multiplexing client\", configBeingRegistered.getDeviceId());\n+            }\n+            this.deviceIO.registerMultiplexedDeviceClient(deviceClientConfigsToRegister);\n+        }\n+    }\n+\n+    /**\n+     * Unregister a device client from this multiplexing client. This method may be called before or after opening the\n+     * multiplexed connection.\n+     * <p>\n+     * Users should use {@link #unregisterDeviceClients(Iterable)} for unregistering multiple devices as it has some\n+     * performance improvements over repeatedly calling this method. This method blocks on each unregistration, whereas\n+     * {@link #registerDeviceClients(Iterable)} blocks on all of the unregistrations after starting them all asynchronously.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will close the AMQP device session associated with\n+     * this device, but it will not close any other registered device sessions or the multiplexing client itself.\n+     * <p>\n+     * If the multiplexed connection is already open, and this call would unregister the last device client,\n+     * the multiplexed connection will remain open. The multiplexed connection can only be closed by calling\n+     * {@link #close()}\n+     * <p>\n+     * Once a device client is unregistered, it may be re-registered to this or any other multiplexing client. It cannot\n+     * be used in non-multiplexing scenarios or used by the deprecated {@link TransportClient}.\n+     * <p>\n+     * @param deviceClient The device client to unregister from this multiplexing client.\n+     */\n+    public void unregisterDeviceClient(DeviceClient deviceClient) throws InterruptedException\n+    {\n+        Objects.requireNonNull(deviceClient);\n+        List<DeviceClient> clientList = new ArrayList<>();\n+        clientList.add(deviceClient);\n+        unregisterDeviceClients(clientList);\n+    }\n+\n+    /**\n+     * Unregister device clients from this multiplexing client. This method may be called before or after opening the\n+     * multiplexed connection.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will close the AMQP device session associated with\n+     * this device, but it will not close any other registered device sessions or the multiplexing client itself.\n+     * <p>\n+     * If the multiplexed connection is already open, and this call would unregister the last device clients,\n+     * the multiplexed connection will remain open. The multiplexed connection can only be closed by calling\n+     * {@link #close()}\n+     * <p>\n+     * Once a device client is unregistered, it may be re-registered to this or any other multiplexing client. It cannot\n+     * be used in non-multiplexing scenarios or used by the deprecated {@link TransportClient}.\n+     * <p>\n+     * @param deviceClients The device clients to unregister from this multiplexing client.\n+     */\n+    public void unregisterDeviceClients(Iterable<DeviceClient> deviceClients) throws InterruptedException\n+    {\n+        Objects.requireNonNull(deviceClients);\n+\n+        synchronized (this.operationLock)\n+        {\n+            List<DeviceClientConfig> deviceClientConfigsToRegister = new ArrayList<>();\n+            for (DeviceClient deviceClientToUnregister : deviceClients)\n+            {\n+                DeviceClientConfig configToUnregister = deviceClientToUnregister.getConfig();\n+                deviceClientConfigsToRegister.add(configToUnregister);\n+                log.info(\"Unregistering device {} from multiplexing client\", deviceClientToUnregister.getConfig().getDeviceId());\n+                this.deviceClientList.remove(deviceClientToUnregister);\n+                deviceClientToUnregister.setDeviceIO(null);\n+            }\n+\n+            this.deviceIO.unregisterMultiplexedDeviceClient(deviceClientConfigsToRegister);\n+        }\n+    }\n+\n+    /**\n+     * Registers a callback to be executed when the connection status of the multiplexed connection as a whole changes.\n+     * The callback will be fired with a status and a reason why the multiplexed connection's status changed. When the\n+     * callback is fired, the provided context will be provided alongside the status and reason.\n+     *\n+     * <p>Note that this callback will not be fired for device specific connection status changes. In order to be notified\n+     * when a particular device's connection status changes, you will need to register a connection status change callback\n+     * on that device client instance using {@link DeviceClient#registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback, Object)}.\n+     *\n+     * <p>Note that the thread used to deliver this callback should not be used to call open()/closeNow() on the client\n+     * that this callback belongs to. All open()/closeNow() operations should be done on a separate thread</p>\n+     *\n+     * @param callback The callback to be fired when the connection status of the multiplexed connection changes.\n+     *                 Can be null to unset this listener as long as the provided callbackContext is also null.\n+     * @param callbackContext a context to be passed to the callback. Can be {@code null}.\n+     */\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext)\n+    {\n+        this.deviceIO.registerMultiplexingConnectionStateCallback(callback, callbackContext);\n+    }\n+\n+    /**\n+     * Returns if a device client for the provided device Id is already registered to this multiplexing client.\n+     * @param deviceId The Id of the device client to look for.\n+     * @return True if a device client is already registered with this Id. False otherwise.\n+     */\n+    public boolean isDeviceRegistered(String deviceId)\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            for (DeviceClient client : this.deviceClientList)\n+            {\n+                if (client.getConfig().getDeviceId().equalsIgnoreCase(deviceId))\n+                {\n+                    return true;\n+                }\n+            }\n+\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Get the number of currently registered devices on this multiplexing client.\n+     * @return The number of currently registered devices on this multiplexing client.\n+     */\n+    public int getRegisteredDeviceCount()\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            // O(1) operation since ArrayList saves this value as an integer rather than iterating over each element.\n+            // So there is no need to be more clever about this.\n+            return this.deviceClientList.size();\n+        }\n+    }\n+\n+    /**\n+     * Sets the given retry policy for the multiplexing client level connection management.\n+     * <a href=\"https://github.com/Azure/azure-iot-sdk-java/blob/master/device/iot-device-client/devdoc/requirement_docs/com/microsoft/azure/iothub/retryPolicy.md\">\n+     *     See more details about the default retry policy and about using custom retry policies here</a>\n+     * @param retryPolicy The policy that the multiplexing client will use when reconnecting.\n+     */\n+    public void setRetryPolicy(RetryPolicy retryPolicy)\n+    {\n+        this.deviceIO.setMultiplexingRetryPolicy(retryPolicy);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "originalPosition": 454}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NzczNjE3", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-527773617", "createdAt": "2020-11-11T01:13:32Z", "commit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMToxMzozMlrOHw2VzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMToxMzozMlrOHw2VzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk4NDAxMw==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520984013", "createdAt": "2020-11-11T01:13:32Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,456 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.RetryPolicy;\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static final long DEFAULT_SEND_PERIOD_MILLIS = 10L;\n+    public static final long DEFAULT_RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private final DeviceIO deviceIO;\n+    private final ArrayList<DeviceClient> deviceClientList;\n+    private final String hostName;\n+    private final IotHubClientProtocol protocol;\n+\n+    // This lock is used to keep open/close/register/unregister operations atomic to prevent race conditions\n+    private final Object operationLock = new Object();\n+\n+    // Optional settings from MultiplexingClientOptions\n+    private SSLContext sslContext;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS = 1000;\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS_WS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS = 500;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(String hostName, IotHubClientProtocol protocol)\n+    {\n+        this(hostName, protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param options The optional parameters to configure this client to use.\n+     */\n+    public MultiplexingClient(String hostName, IotHubClientProtocol protocol, MultiplexingClientOptions options)\n+    {\n+        Objects.requireNonNull(hostName);\n+        Objects.requireNonNull(protocol);\n+\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.hostName = hostName;\n+        this.protocol = protocol;\n+        this.proxySettings = options != null ? options.getProxySettings() : null;\n+        long sendPeriod = options != null ? options.getSendPeriod() : DEFAULT_SEND_PERIOD_MILLIS;\n+        long receivePeriod = options != null ? options.getReceivePeriod() : DEFAULT_RECEIVE_PERIOD_MILLIS;\n+\n+        if (sendPeriod < 0)\n+        {\n+            throw new IllegalArgumentException(\"send period can not be negative\");\n+        }\n+        else if (sendPeriod == 0) //default builder value for this option, signals that user didn't set a value\n+        {\n+            sendPeriod = DEFAULT_SEND_PERIOD_MILLIS;\n+        }\n+\n+        if (receivePeriod < 0)\n+        {\n+            throw new IllegalArgumentException(\"receive period can not be negative\");\n+        }\n+        else if (receivePeriod == 0) //default builder value for this option, signals that user didn't set a value\n+        {\n+            receivePeriod = DEFAULT_RECEIVE_PERIOD_MILLIS;\n+        }\n+\n+        this.sslContext = options != null ? options.getSslContext() : null;\n+        this.deviceIO = new DeviceIO(hostName, protocol, sslContext, proxySettings, sendPeriod, receivePeriod);\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. This may be done before or after registering any number of device clients.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            log.info(\"Opening multiplexing client\");\n+            this.deviceIO.open();\n+            log.info(\"Successfully opened multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve all previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            log.info(\"Closing multiplexing client\");\n+            for (DeviceClient deviceClient : this.deviceClientList)\n+            {\n+                deviceClient.closeFileUpload();\n+            }\n+\n+            if (this.deviceIO != null)\n+            {\n+                this.deviceIO.multiplexClose();\n+            }\n+\n+            // Note that this method does not close each of the registered device client instances. This is intentional\n+            // as the calls to deviceClient.close() do nothing besides close the deviceIO layer, which is already closed\n+            // by the above code.\n+\n+            log.info(\"Successfully closed multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Register a device client to this multiplexing client. This method may be called before or after opening the\n+     * multiplexed connection.\n+     * <p>\n+     * Users should use {@link #registerDeviceClients(Iterable)} for registering multiple devices as it has some\n+     * performance improvements over repeatedly calling this method. This method blocks on each registration, whereas\n+     * {@link #registerDeviceClients(Iterable)} blocks on all of the registrations after starting them all asynchronously.\n+     * <p>\n+     * Up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS} devices can be registered on a multiplexed AMQPS connection,\n+     * and up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS} devices can be registered on a multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will add this device client to the\n+     * multiplexed connection, and then will block until the registration has been completed.\n+     * <p>\n+     * Any proxy settings set to the provided device clients will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * Each registered device client may have its own retry policy and its own SAS token expiry time, separate from every other registered device client.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If the provided device client is already registered to this multiplexing client, then then this method will do nothing.\n+     * <p>\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n+     * will never be thrown if the multiplexing client is not open yet.\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient) throws InterruptedException {\n+        Objects.requireNonNull(deviceClient);\n+        List<DeviceClient> clientList = new ArrayList<>();\n+        clientList.add(deviceClient);\n+        registerDeviceClients(clientList);\n+    }\n+\n+    /**\n+     * Register device clients to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection.\n+     * <p>\n+     * Up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS} devices can be registered on a multiplexed AMQPS connection,\n+     * and up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS} devices can be registered on a multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then these device clients will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then these device clients will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will asynchronously add each device client to the\n+     * multiplexed connection, and then will block until all registrations have been completed.\n+     * <p>\n+     * Any proxy settings set to the provided device clients will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device clients must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * Each registered device client may have its own retry policy and its own SAS token expiry time, separate from every other registered device client.\n+     * <p>\n+     * The registered device clients must use symmetric key based authentication.\n+     * <p>\n+     * The registered device clients must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If any of these device clients are already registered to this multiplexing client, then then this method will\n+     * not do anything to that particular device client. All other provided device clients will still be registered though.\n+     * <p>\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n+     * will never be thrown if the multiplexing client is not open yet.\n+     * @param deviceClients The device clients to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClients(Iterable<DeviceClient> deviceClients) throws InterruptedException {\n+        Objects.requireNonNull(deviceClients);\n+\n+        synchronized (this.operationLock)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "originalPosition": 244}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3Nzc2MDgw", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-527776080", "createdAt": "2020-11-11T01:20:19Z", "commit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMToyMDoyMFrOHw2n-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMToyMDoyMFrOHw2n-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk4ODY2Nw==", "bodyText": "if we perform the registration operation again for a device that is already registered, will there be an issue? I am thinking abut how heavy this for loop will be, for ~1000 devices, and if making registration idempotent is an option.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520988667", "createdAt": "2020-11-11T01:20:20Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,456 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.RetryPolicy;\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static final long DEFAULT_SEND_PERIOD_MILLIS = 10L;\n+    public static final long DEFAULT_RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private final DeviceIO deviceIO;\n+    private final ArrayList<DeviceClient> deviceClientList;\n+    private final String hostName;\n+    private final IotHubClientProtocol protocol;\n+\n+    // This lock is used to keep open/close/register/unregister operations atomic to prevent race conditions\n+    private final Object operationLock = new Object();\n+\n+    // Optional settings from MultiplexingClientOptions\n+    private SSLContext sslContext;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS = 1000;\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS_WS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS = 500;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(String hostName, IotHubClientProtocol protocol)\n+    {\n+        this(hostName, protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param options The optional parameters to configure this client to use.\n+     */\n+    public MultiplexingClient(String hostName, IotHubClientProtocol protocol, MultiplexingClientOptions options)\n+    {\n+        Objects.requireNonNull(hostName);\n+        Objects.requireNonNull(protocol);\n+\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.hostName = hostName;\n+        this.protocol = protocol;\n+        this.proxySettings = options != null ? options.getProxySettings() : null;\n+        long sendPeriod = options != null ? options.getSendPeriod() : DEFAULT_SEND_PERIOD_MILLIS;\n+        long receivePeriod = options != null ? options.getReceivePeriod() : DEFAULT_RECEIVE_PERIOD_MILLIS;\n+\n+        if (sendPeriod < 0)\n+        {\n+            throw new IllegalArgumentException(\"send period can not be negative\");\n+        }\n+        else if (sendPeriod == 0) //default builder value for this option, signals that user didn't set a value\n+        {\n+            sendPeriod = DEFAULT_SEND_PERIOD_MILLIS;\n+        }\n+\n+        if (receivePeriod < 0)\n+        {\n+            throw new IllegalArgumentException(\"receive period can not be negative\");\n+        }\n+        else if (receivePeriod == 0) //default builder value for this option, signals that user didn't set a value\n+        {\n+            receivePeriod = DEFAULT_RECEIVE_PERIOD_MILLIS;\n+        }\n+\n+        this.sslContext = options != null ? options.getSslContext() : null;\n+        this.deviceIO = new DeviceIO(hostName, protocol, sslContext, proxySettings, sendPeriod, receivePeriod);\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. This may be done before or after registering any number of device clients.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            log.info(\"Opening multiplexing client\");\n+            this.deviceIO.open();\n+            log.info(\"Successfully opened multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve all previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            log.info(\"Closing multiplexing client\");\n+            for (DeviceClient deviceClient : this.deviceClientList)\n+            {\n+                deviceClient.closeFileUpload();\n+            }\n+\n+            if (this.deviceIO != null)\n+            {\n+                this.deviceIO.multiplexClose();\n+            }\n+\n+            // Note that this method does not close each of the registered device client instances. This is intentional\n+            // as the calls to deviceClient.close() do nothing besides close the deviceIO layer, which is already closed\n+            // by the above code.\n+\n+            log.info(\"Successfully closed multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Register a device client to this multiplexing client. This method may be called before or after opening the\n+     * multiplexed connection.\n+     * <p>\n+     * Users should use {@link #registerDeviceClients(Iterable)} for registering multiple devices as it has some\n+     * performance improvements over repeatedly calling this method. This method blocks on each registration, whereas\n+     * {@link #registerDeviceClients(Iterable)} blocks on all of the registrations after starting them all asynchronously.\n+     * <p>\n+     * Up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS} devices can be registered on a multiplexed AMQPS connection,\n+     * and up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS} devices can be registered on a multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will add this device client to the\n+     * multiplexed connection, and then will block until the registration has been completed.\n+     * <p>\n+     * Any proxy settings set to the provided device clients will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * Each registered device client may have its own retry policy and its own SAS token expiry time, separate from every other registered device client.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If the provided device client is already registered to this multiplexing client, then then this method will do nothing.\n+     * <p>\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n+     * will never be thrown if the multiplexing client is not open yet.\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient) throws InterruptedException {\n+        Objects.requireNonNull(deviceClient);\n+        List<DeviceClient> clientList = new ArrayList<>();\n+        clientList.add(deviceClient);\n+        registerDeviceClients(clientList);\n+    }\n+\n+    /**\n+     * Register device clients to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection.\n+     * <p>\n+     * Up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS} devices can be registered on a multiplexed AMQPS connection,\n+     * and up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS} devices can be registered on a multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then these device clients will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then these device clients will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will asynchronously add each device client to the\n+     * multiplexed connection, and then will block until all registrations have been completed.\n+     * <p>\n+     * Any proxy settings set to the provided device clients will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device clients must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * Each registered device client may have its own retry policy and its own SAS token expiry time, separate from every other registered device client.\n+     * <p>\n+     * The registered device clients must use symmetric key based authentication.\n+     * <p>\n+     * The registered device clients must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If any of these device clients are already registered to this multiplexing client, then then this method will\n+     * not do anything to that particular device client. All other provided device clients will still be registered though.\n+     * <p>\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n+     * will never be thrown if the multiplexing client is not open yet.\n+     * @param deviceClients The device clients to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClients(Iterable<DeviceClient> deviceClients) throws InterruptedException {\n+        Objects.requireNonNull(deviceClients);\n+\n+        synchronized (this.operationLock)\n+        {\n+            List<DeviceClientConfig> deviceClientConfigsToRegister = new ArrayList<>();\n+            for (DeviceClient deviceClientToRegister : deviceClients)\n+            {\n+                DeviceClientConfig configToAdd = deviceClientToRegister.getConfig();\n+\n+                // Overwrite the sslContext of the new client to match the multiplexing client\n+                // settings if it was set. If it wasn't set, defer to the default client to set this ssl context\n+                if (this.sslContext != null)\n+                {\n+                    configToAdd.getAuthenticationProvider().setSSLContext(this.sslContext);\n+                }\n+\n+                // Overwrite the proxy settings of the new client to match the multiplexing client settings\n+                configToAdd.setProxy(this.proxySettings);\n+\n+                boolean deviceAlreadyRegistered = false;\n+                for (DeviceClient currentClient : deviceClientList)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "originalPosition": 262}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3Nzc3ODMy", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-527777832", "createdAt": "2020-11-11T01:25:22Z", "commit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMToyNToyMlrOHw22JA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMToyNToyMlrOHw22JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk5MjI5Mg==", "bodyText": "I am a bit confused about how deviceIO works. This is what I thought, but now I think I might be misunderstanding it:\n\ndeviceIO is the \"interface\" for transforming device client operations to the transport layer\nthis.deviceIO is the deviceIO associated with the multiplexing client, which is then getting assigned to the device client instance.\nIn that case, how do we differentiate between the deviceIO for device1 vs device2?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520992292", "createdAt": "2020-11-11T01:25:22Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/MultiplexingClient.java", "diffHunk": "@@ -0,0 +1,456 @@\n+package com.microsoft.azure.sdk.iot.device;\n+\n+import com.microsoft.azure.sdk.iot.device.transport.RetryPolicy;\n+import com.microsoft.azure.sdk.iot.device.transport.amqps.IoTHubConnectionType;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A client for creating multiplexed connections to IoT Hub. A multiplexed connection allows for multiple device clients\n+ * to communicate to the service through a single AMQPS connection.\n+ * <p>\n+ * A given AMQPS connection requires a TLS connection, so multiplexing may be worthwhile if you want to limit the number\n+ * of TLS connections needed to connect multiple device clients to IoT Hub.\n+ * <p>\n+ * A given multiplexing client also has a fixed amount of worker threads regardless of how many device clients are\n+ * being multiplexed. Comparatively, every non-multiplexed device client instance has its own set of worker\n+ * threads. Multiplexing may be worthwhile if you want fewer worker threads.\n+ * <p>\n+ * Only AMQPS and AMQPS_WS support multiplexing, and only symmetric key authenticated devices can be multiplexed.\n+ * <p>\n+ * {@link ModuleClient} instances cannot be multiplexed.\n+ */\n+@Slf4j\n+public class MultiplexingClient\n+{\n+    public static final long DEFAULT_SEND_PERIOD_MILLIS = 10L;\n+    public static final long DEFAULT_RECEIVE_PERIOD_MILLIS = 10L;\n+\n+    private final DeviceIO deviceIO;\n+    private final ArrayList<DeviceClient> deviceClientList;\n+    private final String hostName;\n+    private final IotHubClientProtocol protocol;\n+\n+    // This lock is used to keep open/close/register/unregister operations atomic to prevent race conditions\n+    private final Object operationLock = new Object();\n+\n+    // Optional settings from MultiplexingClientOptions\n+    private SSLContext sslContext;\n+    private ProxySettings proxySettings;\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS = 1000;\n+\n+    /**\n+     * The maximum number of devices that can be multiplexed together on a single multiplexed AMQPS_WS connection\n+     */\n+    public static final int MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS = 500;\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be either\n+     *                 {@link IotHubClientProtocol#AMQPS} or {@link IotHubClientProtocol#AMQPS_WS}.\n+     */\n+    public MultiplexingClient(String hostName, IotHubClientProtocol protocol)\n+    {\n+        this(hostName, protocol, null);\n+    }\n+\n+    /**\n+     * Instantiate a new MultiplexingClient that will establish a multiplexed connection through a proxy.\n+     *\n+     * @param protocol The transport protocol that this client will build the multiplexed connection on. Must be\n+     * {@link IotHubClientProtocol#AMQPS_WS} since using {@link IotHubClientProtocol#AMQPS} does not support proxies.\n+     * @param options The optional parameters to configure this client to use.\n+     */\n+    public MultiplexingClient(String hostName, IotHubClientProtocol protocol, MultiplexingClientOptions options)\n+    {\n+        Objects.requireNonNull(hostName);\n+        Objects.requireNonNull(protocol);\n+\n+        switch (protocol)\n+        {\n+            case AMQPS:\n+            case AMQPS_WS:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Multiplexing is only supported for AMQPS and AMQPS_WS\");\n+        }\n+\n+        this.deviceClientList = new ArrayList<>();\n+        this.hostName = hostName;\n+        this.protocol = protocol;\n+        this.proxySettings = options != null ? options.getProxySettings() : null;\n+        long sendPeriod = options != null ? options.getSendPeriod() : DEFAULT_SEND_PERIOD_MILLIS;\n+        long receivePeriod = options != null ? options.getReceivePeriod() : DEFAULT_RECEIVE_PERIOD_MILLIS;\n+\n+        if (sendPeriod < 0)\n+        {\n+            throw new IllegalArgumentException(\"send period can not be negative\");\n+        }\n+        else if (sendPeriod == 0) //default builder value for this option, signals that user didn't set a value\n+        {\n+            sendPeriod = DEFAULT_SEND_PERIOD_MILLIS;\n+        }\n+\n+        if (receivePeriod < 0)\n+        {\n+            throw new IllegalArgumentException(\"receive period can not be negative\");\n+        }\n+        else if (receivePeriod == 0) //default builder value for this option, signals that user didn't set a value\n+        {\n+            receivePeriod = DEFAULT_RECEIVE_PERIOD_MILLIS;\n+        }\n+\n+        this.sslContext = options != null ? options.getSslContext() : null;\n+        this.deviceIO = new DeviceIO(hostName, protocol, sslContext, proxySettings, sendPeriod, receivePeriod);\n+    }\n+\n+    /**\n+     * Opens this multiplexing client. This may be done before or after registering any number of device clients.\n+     * <p>\n+     * This call behaves synchronously, so if it returns without throwing, then all registered device clients were\n+     * successfully opened.\n+     * <p>\n+     * If this client is already open, then this method will do nothing.\n+     * <p>\n+     * @throws IOException If any IO errors occur while opening the multiplexed connection.\n+     */\n+    public void open() throws IOException\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            log.info(\"Opening multiplexing client\");\n+            this.deviceIO.open();\n+            log.info(\"Successfully opened multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Close this multiplexing client. This will close all active device sessions as well as the AMQP connection.\n+     * <p>\n+     * If this client is already closed, then this method will do nothing.\n+     * <p>\n+     * Once closed, this client can be re-opened. It will preserve all previously registered device clients.\n+     * <p>\n+     * @throws IOException If any exception occurs while closing the connection.\n+     */\n+    public void close() throws IOException\n+    {\n+        synchronized (this.operationLock)\n+        {\n+            log.info(\"Closing multiplexing client\");\n+            for (DeviceClient deviceClient : this.deviceClientList)\n+            {\n+                deviceClient.closeFileUpload();\n+            }\n+\n+            if (this.deviceIO != null)\n+            {\n+                this.deviceIO.multiplexClose();\n+            }\n+\n+            // Note that this method does not close each of the registered device client instances. This is intentional\n+            // as the calls to deviceClient.close() do nothing besides close the deviceIO layer, which is already closed\n+            // by the above code.\n+\n+            log.info(\"Successfully closed multiplexing client\");\n+        }\n+    }\n+\n+    /**\n+     * Register a device client to this multiplexing client. This method may be called before or after opening the\n+     * multiplexed connection.\n+     * <p>\n+     * Users should use {@link #registerDeviceClients(Iterable)} for registering multiple devices as it has some\n+     * performance improvements over repeatedly calling this method. This method blocks on each registration, whereas\n+     * {@link #registerDeviceClients(Iterable)} blocks on all of the registrations after starting them all asynchronously.\n+     * <p>\n+     * Up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS} devices can be registered on a multiplexed AMQPS connection,\n+     * and up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS} devices can be registered on a multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then this device client will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then this device client will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will add this device client to the\n+     * multiplexed connection, and then will block until the registration has been completed.\n+     * <p>\n+     * Any proxy settings set to the provided device clients will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device client must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * Each registered device client may have its own retry policy and its own SAS token expiry time, separate from every other registered device client.\n+     * <p>\n+     * The registered device client must use symmetric key based authentication.\n+     * <p>\n+     * The registered device client must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If the provided device client is already registered to this multiplexing client, then then this method will do nothing.\n+     * <p>\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n+     * will never be thrown if the multiplexing client is not open yet.\n+     * @param deviceClient The device client to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClient(DeviceClient deviceClient) throws InterruptedException {\n+        Objects.requireNonNull(deviceClient);\n+        List<DeviceClient> clientList = new ArrayList<>();\n+        clientList.add(deviceClient);\n+        registerDeviceClients(clientList);\n+    }\n+\n+    /**\n+     * Register device clients to this multiplexing client. This method may be called before or after opening the multiplexed\n+     * connection.\n+     * <p>\n+     * Up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS} devices can be registered on a multiplexed AMQPS connection,\n+     * and up to {@link #MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS} devices can be registered on a multiplexed AMQPS_WS connection.\n+     * <p>\n+     * If the multiplexing client is already open, then these device clients will automatically\n+     * be opened, too. If the multiplexing client is not open yet, then these device clients will not be opened until\n+     * {@link MultiplexingClient#open()} is called.\n+     * <p>\n+     * If the multiplexed connection is already open, then this call will asynchronously add each device client to the\n+     * multiplexed connection, and then will block until all registrations have been completed.\n+     * <p>\n+     * Any proxy settings set to the provided device clients will be overwritten by the proxy settings of this multiplexing client.\n+     * <p>\n+     * The registered device clients must use the same transport protocol (AMQPS or AMQPS_WS) that this multiplexing client uses.\n+     * <p>\n+     * Each registered device client may have its own retry policy and its own SAS token expiry time, separate from every other registered device client.\n+     * <p>\n+     * The registered device clients must use symmetric key based authentication.\n+     * <p>\n+     * The registered device clients must belong to the same IoT Hub as all previously registered device clients.\n+     * <p>\n+     * If any of these device clients are already registered to this multiplexing client, then then this method will\n+     * not do anything to that particular device client. All other provided device clients will still be registered though.\n+     * <p>\n+     * @throws InterruptedException If the thread gets interrupted while waiting for the registration to succeed. This\n+     * will never be thrown if the multiplexing client is not open yet.\n+     * @param deviceClients The device clients to associate with this multiplexing client.\n+     */\n+    public void registerDeviceClients(Iterable<DeviceClient> deviceClients) throws InterruptedException {\n+        Objects.requireNonNull(deviceClients);\n+\n+        synchronized (this.operationLock)\n+        {\n+            List<DeviceClientConfig> deviceClientConfigsToRegister = new ArrayList<>();\n+            for (DeviceClient deviceClientToRegister : deviceClients)\n+            {\n+                DeviceClientConfig configToAdd = deviceClientToRegister.getConfig();\n+\n+                // Overwrite the sslContext of the new client to match the multiplexing client\n+                // settings if it was set. If it wasn't set, defer to the default client to set this ssl context\n+                if (this.sslContext != null)\n+                {\n+                    configToAdd.getAuthenticationProvider().setSSLContext(this.sslContext);\n+                }\n+\n+                // Overwrite the proxy settings of the new client to match the multiplexing client settings\n+                configToAdd.setProxy(this.proxySettings);\n+\n+                boolean deviceAlreadyRegistered = false;\n+                for (DeviceClient currentClient : deviceClientList)\n+                {\n+                    String currentDeviceId = currentClient.getConfig().getDeviceId();\n+                    if (currentDeviceId.equalsIgnoreCase(configToAdd.getDeviceId()))\n+                    {\n+                        deviceAlreadyRegistered = true;\n+                        break;\n+                    }\n+                }\n+\n+                if (deviceAlreadyRegistered)\n+                {\n+                    log.debug(\"Device {} wasn't registered to the multiplexed connection because it is already registered.\", configToAdd.getDeviceId());\n+                    continue;\n+                }\n+\n+                if (configToAdd.getAuthenticationType() != DeviceClientConfig.AuthType.SAS_TOKEN)\n+                {\n+                    throw new UnsupportedOperationException(\"Can only register to multiplex a device client that uses SAS token based authentication\");\n+                }\n+\n+                if (configToAdd.getProtocol() != this.protocol)\n+                {\n+                    throw new UnsupportedOperationException(\"A device client cannot be registered to a multiplexing client that specifies a different transport protocol.\");\n+                }\n+\n+                if (this.protocol == IotHubClientProtocol.AMQPS && this.deviceClientList.size() > MAX_MULTIPLEX_DEVICE_COUNT_AMQPS)\n+                {\n+                    throw new UnsupportedOperationException(String.format(\"Multiplexed connections over AMQPS only support up to %d devices\", MAX_MULTIPLEX_DEVICE_COUNT_AMQPS));\n+                }\n+\n+                // Typically client side validation is duplicate work, but IoT Hub doesn't give a good error message when closing the\n+                // AMQPS_WS connection so this is the only way that users will know about this limit\n+                if (this.protocol == IotHubClientProtocol.AMQPS_WS && this.deviceClientList.size() > MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS)\n+                {\n+                    throw new UnsupportedOperationException(String.format(\"Multiplexed connections over AMQPS_WS only support up to %d devices\", MAX_MULTIPLEX_DEVICE_COUNT_AMQPS_WS));\n+                }\n+\n+                if (!this.hostName.equalsIgnoreCase(configToAdd.getIotHubHostname()))\n+                {\n+                    throw new UnsupportedOperationException(\"A device client cannot be registered to a multiplexing client that specifies a different host name.\");\n+                }\n+\n+                if (deviceClientToRegister.getDeviceIO() != null && deviceClientToRegister.getDeviceIO().isOpen())\n+                {\n+                    throw new IllegalStateException(\"Cannot register a device client to a multiplexed connection when it the device client was already opened.\");\n+                }\n+\n+                deviceClientToRegister.setAsMultiplexed();\n+                deviceClientToRegister.setDeviceIO(this.deviceIO);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "originalPosition": 311}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NzgxMDU3", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-527781057", "createdAt": "2020-11-11T01:34:21Z", "commit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMTozNDoyMVrOHw3PJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMTozNDoyMVrOHw3PJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk5ODY5NA==", "bodyText": "it is safe to assume that network or service related disconnection would always be accompanied by by a throwable, correct?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r520998694", "createdAt": "2020-11-11T01:34:21Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubTransport.java", "diffHunk": "@@ -267,64 +291,91 @@ public void onConnectionEstablished(String connectionId)\n     {\n         if (connectionId.equals(this.iotHubTransportConnection.getConnectionId()))\n         {\n-            log.info(\"The connection to the IoT Hub has been established\");\n+            log.debug(\"The connection to the IoT Hub has been established\");\n \n-            //Codes_SRS_IOTHUBTRANSPORT_34_014: [If the provided connectionId is associated with the current connection, This function shall invoke updateStatus with status CONNECTED, change\n-            // reason CONNECTION_OK and a null throwable.]\n             this.updateStatus(IotHubConnectionStatus.CONNECTED, IotHubConnectionStatusChangeReason.CONNECTION_OK, null);\n         }\n     }\n \n+    @Override\n+    public void onMultiplexedDeviceSessionEstablished(String connectionId, String deviceId)\n+    {\n+        if (connectionId.equals(this.iotHubTransportConnection.getConnectionId()))\n+        {\n+            log.debug(\"The device session in the multiplexed connection to the IoT Hub has been established for device {}\", deviceId);\n+            this.updateStatus(IotHubConnectionStatus.CONNECTED, IotHubConnectionStatusChangeReason.CONNECTION_OK, null, deviceId);\n+        }\n+    }\n+\n+    @Override\n+    public void onMultiplexedDeviceSessionLost(Throwable e, String connectionId, String deviceId)\n+    {\n+        if (connectionId.equals(this.iotHubTransportConnection.getConnectionId()))\n+        {\n+            log.debug(\"The device session in the multiplexed connection to the IoT Hub has been lost for device {}\", deviceId);\n+            if (e == null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "originalPosition": 174}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3Nzg3ODk1", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-527787895", "createdAt": "2020-11-11T01:54:16Z", "commit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMTo1NDoxNlrOHw4FCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMTo1NDoxNlrOHw4FCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxMjQ5MA==", "bodyText": "Is the call to Open() thread safe?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521012490", "createdAt": "2020-11-11T01:54:16Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubTransport.java", "diffHunk": "@@ -267,64 +291,91 @@ public void onConnectionEstablished(String connectionId)\n     {\n         if (connectionId.equals(this.iotHubTransportConnection.getConnectionId()))\n         {\n-            log.info(\"The connection to the IoT Hub has been established\");\n+            log.debug(\"The connection to the IoT Hub has been established\");\n \n-            //Codes_SRS_IOTHUBTRANSPORT_34_014: [If the provided connectionId is associated with the current connection, This function shall invoke updateStatus with status CONNECTED, change\n-            // reason CONNECTION_OK and a null throwable.]\n             this.updateStatus(IotHubConnectionStatus.CONNECTED, IotHubConnectionStatusChangeReason.CONNECTION_OK, null);\n         }\n     }\n \n+    @Override\n+    public void onMultiplexedDeviceSessionEstablished(String connectionId, String deviceId)\n+    {\n+        if (connectionId.equals(this.iotHubTransportConnection.getConnectionId()))\n+        {\n+            log.debug(\"The device session in the multiplexed connection to the IoT Hub has been established for device {}\", deviceId);\n+            this.updateStatus(IotHubConnectionStatus.CONNECTED, IotHubConnectionStatusChangeReason.CONNECTION_OK, null, deviceId);\n+        }\n+    }\n+\n+    @Override\n+    public void onMultiplexedDeviceSessionLost(Throwable e, String connectionId, String deviceId)\n+    {\n+        if (connectionId.equals(this.iotHubTransportConnection.getConnectionId()))\n+        {\n+            log.debug(\"The device session in the multiplexed connection to the IoT Hub has been lost for device {}\", deviceId);\n+            if (e == null)\n+            {\n+                this.updateStatus(IotHubConnectionStatus.DISCONNECTED, IotHubConnectionStatusChangeReason.CLIENT_CLOSE, null, deviceId);\n+            }\n+            else\n+            {\n+                this.updateStatus(IotHubConnectionStatus.DISCONNECTED_RETRYING, exceptionToStatusChangeReason(e), e, deviceId);\n+\n+                if (e instanceof TransportException)\n+                {\n+                    this.reconnectDeviceSession((TransportException) e, deviceId);\n+                }\n+                else\n+                {\n+                    this.reconnectDeviceSession(new TransportException(e), deviceId);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setMultiplexingRetryPolicy(RetryPolicy retryPolicy)\n+    {\n+        this.multiplexingRetryPolicy = retryPolicy;\n+    }\n+\n     /**\n      * Establishes a communication channel with an IoT Hub. If a channel is\n      * already open, the function shall do nothing.\n      *\n      * If reconnection is occurring when this is called, this function shall block and wait for the reconnection\n      * to finish before trying to open the connection\n      *\n-     * @param deviceClientConfigs the configs for the devices to open\n-     *\n      * @throws DeviceClientException if a communication channel cannot be\n      * established.\n      */\n-    public void open(Collection<DeviceClientConfig> deviceClientConfigs) throws DeviceClientException\n+    public void open() throws DeviceClientException\n     {\n-        if ((deviceClientConfigs == null) || deviceClientConfigs.isEmpty())\n-        {\n-            //Codes_SRS_IOTHUBTRANSPORT_34_015: [If the provided list of configs is null or empty, this function shall\n-            // throw an IllegalArgumentException.]\n-            throw new IllegalArgumentException(\"deviceClientConfigs cannot be null or empty\");\n-        }\n-\n         if (this.connectionStatus == IotHubConnectionStatus.CONNECTED)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "originalPosition": 221}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3Nzg4MjIx", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-527788221", "createdAt": "2020-11-11T01:55:07Z", "commit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMTo1NTowN1rOHw4HrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMTo1NTowN1rOHw4HrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxMzE2NQ==", "bodyText": "q - is sas token renewal handled in some other layer?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521013165", "createdAt": "2020-11-11T01:55:07Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubTransport.java", "diffHunk": "@@ -267,64 +291,91 @@ public void onConnectionEstablished(String connectionId)\n     {\n         if (connectionId.equals(this.iotHubTransportConnection.getConnectionId()))\n         {\n-            log.info(\"The connection to the IoT Hub has been established\");\n+            log.debug(\"The connection to the IoT Hub has been established\");\n \n-            //Codes_SRS_IOTHUBTRANSPORT_34_014: [If the provided connectionId is associated with the current connection, This function shall invoke updateStatus with status CONNECTED, change\n-            // reason CONNECTION_OK and a null throwable.]\n             this.updateStatus(IotHubConnectionStatus.CONNECTED, IotHubConnectionStatusChangeReason.CONNECTION_OK, null);\n         }\n     }\n \n+    @Override\n+    public void onMultiplexedDeviceSessionEstablished(String connectionId, String deviceId)\n+    {\n+        if (connectionId.equals(this.iotHubTransportConnection.getConnectionId()))\n+        {\n+            log.debug(\"The device session in the multiplexed connection to the IoT Hub has been established for device {}\", deviceId);\n+            this.updateStatus(IotHubConnectionStatus.CONNECTED, IotHubConnectionStatusChangeReason.CONNECTION_OK, null, deviceId);\n+        }\n+    }\n+\n+    @Override\n+    public void onMultiplexedDeviceSessionLost(Throwable e, String connectionId, String deviceId)\n+    {\n+        if (connectionId.equals(this.iotHubTransportConnection.getConnectionId()))\n+        {\n+            log.debug(\"The device session in the multiplexed connection to the IoT Hub has been lost for device {}\", deviceId);\n+            if (e == null)\n+            {\n+                this.updateStatus(IotHubConnectionStatus.DISCONNECTED, IotHubConnectionStatusChangeReason.CLIENT_CLOSE, null, deviceId);\n+            }\n+            else\n+            {\n+                this.updateStatus(IotHubConnectionStatus.DISCONNECTED_RETRYING, exceptionToStatusChangeReason(e), e, deviceId);\n+\n+                if (e instanceof TransportException)\n+                {\n+                    this.reconnectDeviceSession((TransportException) e, deviceId);\n+                }\n+                else\n+                {\n+                    this.reconnectDeviceSession(new TransportException(e), deviceId);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setMultiplexingRetryPolicy(RetryPolicy retryPolicy)\n+    {\n+        this.multiplexingRetryPolicy = retryPolicy;\n+    }\n+\n     /**\n      * Establishes a communication channel with an IoT Hub. If a channel is\n      * already open, the function shall do nothing.\n      *\n      * If reconnection is occurring when this is called, this function shall block and wait for the reconnection\n      * to finish before trying to open the connection\n      *\n-     * @param deviceClientConfigs the configs for the devices to open\n-     *\n      * @throws DeviceClientException if a communication channel cannot be\n      * established.\n      */\n-    public void open(Collection<DeviceClientConfig> deviceClientConfigs) throws DeviceClientException\n+    public void open() throws DeviceClientException\n     {\n-        if ((deviceClientConfigs == null) || deviceClientConfigs.isEmpty())\n-        {\n-            //Codes_SRS_IOTHUBTRANSPORT_34_015: [If the provided list of configs is null or empty, this function shall\n-            // throw an IllegalArgumentException.]\n-            throw new IllegalArgumentException(\"deviceClientConfigs cannot be null or empty\");\n-        }\n-\n         if (this.connectionStatus == IotHubConnectionStatus.CONNECTED)\n         {\n-            //Codes_SRS_IOTHUBTRANSPORT_34_017: [If the connection status of this object is CONNECTED, this function\n-            // shall do nothing.]\n             return;\n         }\n \n         if (this.connectionStatus == IotHubConnectionStatus.DISCONNECTED_RETRYING)\n         {\n-            //Codes_SRS_IOTHUBTRANSPORT_34_016: [If the connection status of this object is DISCONNECTED_RETRYING, this\n-            // function shall throw a TransportException.]\n             throw new TransportException(\"Open cannot be called while transport is reconnecting\");\n         }\n \n-        if (this.isSasTokenExpired())\n+        // The default config is only null when someone creates a multiplexing client and opens it before\n+        // registering any devices to it. No need to check for SAS token expiry if no devices are registered yet.\n+        if (this.getDefaultConfig() != null)\n         {\n-            //Codes_SRS_IOTHUBTRANSPORT_34_018: [If the saved SAS token has expired, this function shall throw a\n-            // SecurityException.]\n-            throw new SecurityException(\"Your sas token has expired\");\n+            if (this.isSasTokenExpired())\n+            {\n+                throw new SecurityException(\"Your sas token has expired\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "originalPosition": 245}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3Nzg5MzM3", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-527789337", "createdAt": "2020-11-11T01:58:06Z", "commit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMTo1ODowNlrOHw4P1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMTo1ODowNlrOHw4P1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxNTI1Mg==", "bodyText": "q - would the user ever create an instance of IotHubTransport directly? The reason I ask is, we already have these checks in the higher layers, so I was wondering if this check was even required.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r521015252", "createdAt": "2020-11-11T01:58:06Z", "author": {"login": "abhipsaMisra"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/transport/IotHubTransport.java", "diffHunk": "@@ -606,17 +657,112 @@ public void registerConnectionStateCallback(IotHubConnectionStateCallback callba\n      * @param callback the callback to be called. Can be null if callbackContext is not null\n      * @param callbackContext a context to be passed to the callback. Can be {@code null}.\n      */\n-    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext)\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext, String deviceId)\n     {\n         if (callbackContext != null && callback == null)\n         {\n             //Codes_SRS_IOTHUBTRANSPORT_34_051: [If the provided callback is null but the context is not, this function shall throw an IllegalArgumentException.]\n             throw new IllegalArgumentException(\"Callback cannot be null if callback context is null\");\n         }\n \n-        //Codes_SRS_IOTHUBTRANSPORT_34_052: [This function shall save the provided callback and context.]\n-        this.connectionStatusChangeCallback = callback;\n-        this.connectionStatusChangeCallbackContext = callbackContext;\n+        if (callback == null)\n+        {\n+            this.connectionStatusChangeCallbacks.remove(deviceId);\n+            this.connectionStatusChangeCallbackContexts.remove(deviceId);\n+        }\n+        else\n+        {\n+            this.connectionStatusChangeCallbacks.put(deviceId, callback);\n+\n+            if (callbackContext != null)\n+            {\n+                // ConcurrentHashMaps don't support null values. If user provides null context,\n+                // then calls to connectionStatusChangeCallbackContexts.get(...) will return null which lets this layer still work as expected.\n+                this.connectionStatusChangeCallbackContexts.put(deviceId, callbackContext);\n+            }\n+\n+        }\n+    }\n+\n+    public void registerMultiplexingConnectionStateCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext)\n+    {\n+        if (callback == null && callbackContext != null)\n+        {\n+            throw new IllegalArgumentException(\"Cannot have a null callback and a non-null context associated with it\");\n+        }\n+\n+        this.multiplexingStateCallback = callback;\n+        this.multiplexingStateCallbackContext = callbackContext;\n+    }\n+\n+    public void registerMultiplexedDeviceClient(List<DeviceClientConfig> configs) throws InterruptedException {\n+        if (getProtocol() != IotHubClientProtocol.AMQPS && getProtocol() != IotHubClientProtocol.AMQPS_WS)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156"}, "originalPosition": 335}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "15ca17d7923d36f54663fbd8722769c315c45156", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/15ca17d7923d36f54663fbd8722769c315c45156", "committedDate": "2020-11-07T00:34:41Z", "message": "feat(iot-dev): Add multiplexing client that supports device registration/unregistration during open connection\n\nTransportClient was our multiplexing client, but there was no way to add the ability to add/remove devices from an active connection without breaking the APIs in that class, so this deprecates the transport client in favor of a new MultiplexingClient.\n\nSignificant changes had to made to the IotHubTransport layer so that each multiplexed client could have its own connection state and so that each multiplexed client could have its own focused retry logic. Instead of closing the entire multiplexed connection every time a session drops, the transport layer can re-open individual device sessions"}, "afterCommit": {"oid": "78ed2325fe5fa867328803b0b83b09e6c4225bf6", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/78ed2325fe5fa867328803b0b83b09e6c4225bf6", "committedDate": "2020-11-11T23:46:32Z", "message": "feat(iot-dev): Add multiplexing client that supports device registration/unregistration during open connection\n\nTransportClient was our multiplexing client, but there was no way to add the ability to add/remove devices from an active connection without breaking the APIs in that class, so this deprecates the transport client in favor of a new MultiplexingClient.\n\nSignificant changes had to made to the IotHubTransport layer so that each multiplexed client could have its own connection state and so that each multiplexed client could have its own focused retry logic. Instead of closing the entire multiplexed connection every time a session drops, the transport layer can re-open individual device sessions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24ea744c50a21731079b72690abb981c43fb9f6c", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/24ea744c50a21731079b72690abb981c43fb9f6c", "committedDate": "2020-11-12T00:21:20Z", "message": "feat(iot-dev): Add multiplexing client that supports device registration/unregistration during open connection\n\nTransportClient was our multiplexing client, but there was no way to add the ability to add/remove devices from an active connection without breaking the APIs in that class, so this deprecates the transport client in favor of a new MultiplexingClient.\n\nSignificant changes had to made to the IotHubTransport layer so that each multiplexed client could have its own connection state and so that each multiplexed client could have its own focused retry logic. Instead of closing the entire multiplexed connection every time a session drops, the transport layer can re-open individual device sessions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "78ed2325fe5fa867328803b0b83b09e6c4225bf6", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/78ed2325fe5fa867328803b0b83b09e6c4225bf6", "committedDate": "2020-11-11T23:46:32Z", "message": "feat(iot-dev): Add multiplexing client that supports device registration/unregistration during open connection\n\nTransportClient was our multiplexing client, but there was no way to add the ability to add/remove devices from an active connection without breaking the APIs in that class, so this deprecates the transport client in favor of a new MultiplexingClient.\n\nSignificant changes had to made to the IotHubTransport layer so that each multiplexed client could have its own connection state and so that each multiplexed client could have its own focused retry logic. Instead of closing the entire multiplexed connection every time a session drops, the transport layer can re-open individual device sessions"}, "afterCommit": {"oid": "24ea744c50a21731079b72690abb981c43fb9f6c", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/24ea744c50a21731079b72690abb981c43fb9f6c", "committedDate": "2020-11-12T00:21:20Z", "message": "feat(iot-dev): Add multiplexing client that supports device registration/unregistration during open connection\n\nTransportClient was our multiplexing client, but there was no way to add the ability to add/remove devices from an active connection without breaking the APIs in that class, so this deprecates the transport client in favor of a new MultiplexingClient.\n\nSignificant changes had to made to the IotHubTransport layer so that each multiplexed client could have its own connection state and so that each multiplexed client could have its own focused retry logic. Instead of closing the entire multiplexed connection every time a session drops, the transport layer can re-open individual device sessions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d2fc9fd05e6baee250d1a07d33ad33283cb3479e", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/d2fc9fd05e6baee250d1a07d33ad33283cb3479e", "committedDate": "2020-11-12T19:46:21Z", "message": "Merge branch 'timtay/multiplex' of https://github.com/Azure/azure-iot-sdk-java into timtay/multiplex"}, "afterCommit": {"oid": "d8b84f1a3e351158d192f93c169f04c404a136f2", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/d8b84f1a3e351158d192f93c169f04c404a136f2", "committedDate": "2020-11-12T18:58:53Z", "message": "fixup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b83f1727617198d1b8d0912d320be69258acdcbf", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/b83f1727617198d1b8d0912d320be69258acdcbf", "committedDate": "2020-11-12T19:58:28Z", "message": "try different emulator"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aa500feea5bcbae4f3795396e4297b17ba9a455a", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/aa500feea5bcbae4f3795396e4297b17ba9a455a", "committedDate": "2020-11-12T19:48:47Z", "message": "try different emulator"}, "afterCommit": {"oid": "b83f1727617198d1b8d0912d320be69258acdcbf", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/b83f1727617198d1b8d0912d320be69258acdcbf", "committedDate": "2020-11-12T19:58:28Z", "message": "try different emulator"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5NTE1MDM0", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#pullrequestreview-529515034", "createdAt": "2020-11-12T21:34:29Z", "commit": {"oid": "b83f1727617198d1b8d0912d320be69258acdcbf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMTozNDoyOVrOHyPOFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMTozNDoyOVrOHyPOFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ0MDIxMw==", "bodyText": "For my understanding - What is the difference between status callback and mux status callback?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/939#discussion_r522440213", "createdAt": "2020-11-12T21:34:29Z", "author": {"login": "vinagesh"}, "path": "device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java", "diffHunk": "@@ -428,14 +435,17 @@ public boolean isEmpty()\n      */\n     public void registerConnectionStateCallback(IotHubConnectionStateCallback callback, Object callbackContext)\n     {\n-        /* Codes_SRS_DEVICE_IO_99_001: [The registerConnectionStateCallback shall register the callback with the transport.]*/\n         this.transport.registerConnectionStateCallback(callback, callbackContext);\n     }\n \n-    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback statusChangeCallback, Object callbackContext)\n+    void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback statusChangeCallback, Object callbackContext, String deviceId)\n+    {\n+        this.transport.registerConnectionStatusChangeCallback(statusChangeCallback, callbackContext, deviceId);\n+    }\n+\n+    void registerMultiplexingConnectionStateCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext)\n     {\n-        //Codes_SRS_DEVICE_IO_34_020: [This function shall register the callback with the transport.]\n-        this.transport.registerConnectionStatusChangeCallback(statusChangeCallback, callbackContext);\n+        this.transport.registerMultiplexingConnectionStateCallback(callback, callbackContext);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b83f1727617198d1b8d0912d320be69258acdcbf"}, "originalPosition": 173}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f3a38ad86495683ecd3aac611a6eae3b327b4d9", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/1f3a38ad86495683ecd3aac611a6eae3b327b4d9", "committedDate": "2020-11-12T22:25:26Z", "message": "Revert \"try different emulator\"\n\nThis reverts commit b83f1727617198d1b8d0912d320be69258acdcbf."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0b7b474114a725cd77c9aab95972dbb70418245", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/d0b7b474114a725cd77c9aab95972dbb70418245", "committedDate": "2020-11-12T22:26:23Z", "message": "ignore"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3f1dd27c19dc4f3cbd003fc0d7fb71c6b7b54b6", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/a3f1dd27c19dc4f3cbd003fc0d7fb71c6b7b54b6", "committedDate": "2020-11-12T23:32:47Z", "message": "fixup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e93ec71f1bf73294131e41cffbd483174f64324", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/8e93ec71f1bf73294131e41cffbd483174f64324", "committedDate": "2020-11-13T00:31:02Z", "message": "fixup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4957b2c903ca6f431f7bef2fee41bd4cc49f1f1", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/d4957b2c903ca6f431f7bef2fee41bd4cc49f1f1", "committedDate": "2020-11-13T19:57:07Z", "message": "fixup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "348d726f94e960190e3795b4044c2cfccd1fec5d", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/348d726f94e960190e3795b4044c2cfccd1fec5d", "committedDate": "2020-11-13T20:27:58Z", "message": "fixup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c35f8736bdfcac74e13f3c8b46e4ed5da49ad677", "author": {"user": {"login": "timtay-microsoft", "name": null}}, "url": "https://github.com/Azure/azure-iot-sdk-java/commit/c35f8736bdfcac74e13f3c8b46e4ed5da49ad677", "committedDate": "2020-11-14T00:00:43Z", "message": "fixup"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1572, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}