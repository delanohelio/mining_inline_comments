{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY0MzY4OTIy", "number": 682, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo0Nzo0MFrODY-Llw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMDo0NDo1M1rODbXXsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTExMTkxOnYy", "diffSide": "RIGHT", "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DeviceClientManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo0Nzo0MFrOFfIlRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo0Nzo0MFrOFfIlRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MDc4OQ==", "bodyText": "missing space between if and paren", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r368190789", "createdAt": "2020-01-18T00:47:40Z", "author": {"login": "drwill-ms"}, "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DeviceClientManager.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package com.microsoft.azure.sdk.iot.digitaltwin.device;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceClient;\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.experimental.Delegate;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+@Slf4j\n+public class DeviceClientManager implements IotHubConnectionStatusChangeCallback {\n+    private enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+\n+    private static final Object lock = new Object();\n+    private static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 10;\n+    private ConnectionStatus connectionStatus;\n+    private Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    private interface DeviceClientNonDelegatedFunction {\n+        void open();\n+        void closeNow();\n+        void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext);\n+    }\n+\n+    // The methods defined in the interface DeviceClientNonDelegatedFunction will be called on DeviceClientManager, and not on DeviceClient.\n+    @Delegate(excludes = DeviceClientNonDelegatedFunction.class)\n+    private final DeviceClient client;\n+\n+    DeviceClientManager(DeviceClient deviceClient) {\n+        this.connectionStatus = ConnectionStatus.DISCONNECTED;\n+        this.client = deviceClient;\n+        this.client.registerConnectionStatusChangeCallback(this, this);\n+    }\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+    }\n+\n+    public void open() throws Exception {\n+        synchronized (lock) {\n+            if(connectionStatus == ConnectionStatus.DISCONNECTED) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTExMjMxOnYy", "diffSide": "RIGHT", "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DeviceClientManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo0ODowNFrOFfIlhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo0ODowNFrOFfIlhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MDg1Mw==", "bodyText": "missing space between if and paren", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r368190853", "createdAt": "2020-01-18T00:48:04Z", "author": {"login": "drwill-ms"}, "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DeviceClientManager.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package com.microsoft.azure.sdk.iot.digitaltwin.device;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceClient;\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.experimental.Delegate;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+@Slf4j\n+public class DeviceClientManager implements IotHubConnectionStatusChangeCallback {\n+    private enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+\n+    private static final Object lock = new Object();\n+    private static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 10;\n+    private ConnectionStatus connectionStatus;\n+    private Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    private interface DeviceClientNonDelegatedFunction {\n+        void open();\n+        void closeNow();\n+        void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext);\n+    }\n+\n+    // The methods defined in the interface DeviceClientNonDelegatedFunction will be called on DeviceClientManager, and not on DeviceClient.\n+    @Delegate(excludes = DeviceClientNonDelegatedFunction.class)\n+    private final DeviceClient client;\n+\n+    DeviceClientManager(DeviceClient deviceClient) {\n+        this.connectionStatus = ConnectionStatus.DISCONNECTED;\n+        this.client = deviceClient;\n+        this.client.registerConnectionStatusChangeCallback(this, this);\n+    }\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+    }\n+\n+    public void open() throws Exception {\n+        synchronized (lock) {\n+            if(connectionStatus == ConnectionStatus.DISCONNECTED) {\n+                connectionStatus = ConnectionStatus.CONNECTING;\n+            } else {\n+                return;\n+            }\n+        }\n+        doConnect();\n+    }\n+\n+    private void doConnect() throws Exception {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if(connectionStatus == ConnectionStatus.CONNECTING) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTExNjAyOnYy", "diffSide": "RIGHT", "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DigitalTwinDeviceClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo1MjowNFrOFfInvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo1MjowNFrOFfInvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MTQyMQ==", "bodyText": "missing space between if and paren", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r368191421", "createdAt": "2020-01-18T00:52:04Z", "author": {"login": "drwill-ms"}, "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DigitalTwinDeviceClient.java", "diffHunk": "@@ -109,166 +99,284 @@\n      * Callers MUST NOT directly access {@link DeviceClient} after.\n      *\n      * @param deviceClient An {@link DeviceClient} that has been already created and bound to a specific connection string (or transport, or DPS handle, or whatever mechanism is preferred).\n+     * @param deviceCapabilityModelId     Device Capability Model Id\n+     *\n      */\n-    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient) {\n-        this.deviceClient = deviceClient;\n-        this.registrationStatus = UNREGISTERED;\n-        this.digitalTwinInterfaceClients = new HashMap<>();\n+    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient, @NonNull String deviceCapabilityModelId) {\n+        this.deviceClientManager = new DeviceClientManager(deviceClient);\n+        this.deviceCapabilityModelId = deviceCapabilityModelId;\n+        this.components = new ConcurrentHashMap<>();\n         this.lock = new Object();\n     }\n \n     /**\n-     * Registers the specified {@link AbstractDigitalTwinInterfaceClient} with the DigitalTwin Service.\n-     * The call occurs asynchronously. While registration is in progress, {@link AbstractDigitalTwinInterfaceClient}'s that are being registered will not be able to report properties nor receive commands.\n-     * The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n-     * It must not be called multiple times.  If a given Digital Twin device needs to have its handles re-registered, it needs to create a new DigitalTwinDeviceClient instance.\n+     * Bind all digital twin components with Digital Twin device client.\n+     * @param digitalTwinComponents An list of {@link AbstractDigitalTwinComponent}s to register with the service.\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult bindComponents(@NonNull final List<? extends AbstractDigitalTwinComponent> digitalTwinComponents) {\n+        synchronized (lock) {\n+            if(!components.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTExNjE0OnYy", "diffSide": "RIGHT", "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DigitalTwinDeviceClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo1MjoxN1rOFfIn0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo1MjoxN1rOFfIn0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MTQ0MA==", "bodyText": "missing space between if and paren", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r368191440", "createdAt": "2020-01-18T00:52:17Z", "author": {"login": "drwill-ms"}, "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DigitalTwinDeviceClient.java", "diffHunk": "@@ -109,166 +99,284 @@\n      * Callers MUST NOT directly access {@link DeviceClient} after.\n      *\n      * @param deviceClient An {@link DeviceClient} that has been already created and bound to a specific connection string (or transport, or DPS handle, or whatever mechanism is preferred).\n+     * @param deviceCapabilityModelId     Device Capability Model Id\n+     *\n      */\n-    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient) {\n-        this.deviceClient = deviceClient;\n-        this.registrationStatus = UNREGISTERED;\n-        this.digitalTwinInterfaceClients = new HashMap<>();\n+    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient, @NonNull String deviceCapabilityModelId) {\n+        this.deviceClientManager = new DeviceClientManager(deviceClient);\n+        this.deviceCapabilityModelId = deviceCapabilityModelId;\n+        this.components = new ConcurrentHashMap<>();\n         this.lock = new Object();\n     }\n \n     /**\n-     * Registers the specified {@link AbstractDigitalTwinInterfaceClient} with the DigitalTwin Service.\n-     * The call occurs asynchronously. While registration is in progress, {@link AbstractDigitalTwinInterfaceClient}'s that are being registered will not be able to report properties nor receive commands.\n-     * The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n-     * It must not be called multiple times.  If a given Digital Twin device needs to have its handles re-registered, it needs to create a new DigitalTwinDeviceClient instance.\n+     * Bind all digital twin components with Digital Twin device client.\n+     * @param digitalTwinComponents An list of {@link AbstractDigitalTwinComponent}s to register with the service.\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult bindComponents(@NonNull final List<? extends AbstractDigitalTwinComponent> digitalTwinComponents) {\n+        synchronized (lock) {\n+            if(!components.isEmpty()) {\n+                return DIGITALTWIN_CLIENT_ERROR_COMPONENTS_ALREADY_BOUND;\n+            }\n+\n+            for (AbstractDigitalTwinComponent digitalTwinComponent : digitalTwinComponents) {\n+                digitalTwinComponent.setDigitalTwinDeviceClient(this);\n+                components.put(digitalTwinComponent.getDigitalTwinComponentName(), digitalTwinComponent);\n+            }\n+        }\n+        return DIGITALTWIN_CLIENT_OK;\n+    }\n+\n+    /**\n+     * Sends registration message message to DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n      *\n-     * @param deviceCapabilityModelId     Device Capability Model Id\n-     * @param digitalTwinInterfaceClients An list of {@link AbstractDigitalTwinInterfaceClient}s to register with the service.\n      * @return Result of this async function.\n      */\n-    public Single<DigitalTwinClientResult> registerInterfacesAsync(@NonNull final String deviceCapabilityModelId,\n-            @NonNull final List<? extends AbstractDigitalTwinInterfaceClient> digitalTwinInterfaceClients) {\n+    public Single<DigitalTwinClientResult> registerComponentsAsync() {\n         synchronized (lock) {\n-            if (registrationStatus == REGISTERING) {\n-                return Single.just(DIGITALTWIN_CLIENT_ERROR_REGISTRATION_PENDING);\n-            } else if (registrationStatus == REGISTERED) {\n-                return Single.just(DIGITALTWIN_CLIENT_ERROR_INTERFACE_ALREADY_REGISTERED);\n-            } else {\n-                registrationStatus = REGISTERING;\n+            if(components.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "originalPosition": 163}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTExNjc5OnYy", "diffSide": "RIGHT", "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DigitalTwinDeviceClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo1MzoxM1rOFfIoOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNzoyNToxMlrOFgCbAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MTU0NA==", "bodyText": "Is \"registration\" still a concept?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r368191544", "createdAt": "2020-01-18T00:53:13Z", "author": {"login": "drwill-ms"}, "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DigitalTwinDeviceClient.java", "diffHunk": "@@ -109,166 +99,284 @@\n      * Callers MUST NOT directly access {@link DeviceClient} after.\n      *\n      * @param deviceClient An {@link DeviceClient} that has been already created and bound to a specific connection string (or transport, or DPS handle, or whatever mechanism is preferred).\n+     * @param deviceCapabilityModelId     Device Capability Model Id\n+     *\n      */\n-    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient) {\n-        this.deviceClient = deviceClient;\n-        this.registrationStatus = UNREGISTERED;\n-        this.digitalTwinInterfaceClients = new HashMap<>();\n+    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient, @NonNull String deviceCapabilityModelId) {\n+        this.deviceClientManager = new DeviceClientManager(deviceClient);\n+        this.deviceCapabilityModelId = deviceCapabilityModelId;\n+        this.components = new ConcurrentHashMap<>();\n         this.lock = new Object();\n     }\n \n     /**\n-     * Registers the specified {@link AbstractDigitalTwinInterfaceClient} with the DigitalTwin Service.\n-     * The call occurs asynchronously. While registration is in progress, {@link AbstractDigitalTwinInterfaceClient}'s that are being registered will not be able to report properties nor receive commands.\n-     * The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n-     * It must not be called multiple times.  If a given Digital Twin device needs to have its handles re-registered, it needs to create a new DigitalTwinDeviceClient instance.\n+     * Bind all digital twin components with Digital Twin device client.\n+     * @param digitalTwinComponents An list of {@link AbstractDigitalTwinComponent}s to register with the service.\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult bindComponents(@NonNull final List<? extends AbstractDigitalTwinComponent> digitalTwinComponents) {\n+        synchronized (lock) {\n+            if(!components.isEmpty()) {\n+                return DIGITALTWIN_CLIENT_ERROR_COMPONENTS_ALREADY_BOUND;\n+            }\n+\n+            for (AbstractDigitalTwinComponent digitalTwinComponent : digitalTwinComponents) {\n+                digitalTwinComponent.setDigitalTwinDeviceClient(this);\n+                components.put(digitalTwinComponent.getDigitalTwinComponentName(), digitalTwinComponent);\n+            }\n+        }\n+        return DIGITALTWIN_CLIENT_OK;\n+    }\n+\n+    /**\n+     * Sends registration message message to DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n      *\n-     * @param deviceCapabilityModelId     Device Capability Model Id\n-     * @param digitalTwinInterfaceClients An list of {@link AbstractDigitalTwinInterfaceClient}s to register with the service.\n      * @return Result of this async function.\n      */\n-    public Single<DigitalTwinClientResult> registerInterfacesAsync(@NonNull final String deviceCapabilityModelId,\n-            @NonNull final List<? extends AbstractDigitalTwinInterfaceClient> digitalTwinInterfaceClients) {\n+    public Single<DigitalTwinClientResult> registerComponentsAsync() {\n         synchronized (lock) {\n-            if (registrationStatus == REGISTERING) {\n-                return Single.just(DIGITALTWIN_CLIENT_ERROR_REGISTRATION_PENDING);\n-            } else if (registrationStatus == REGISTERED) {\n-                return Single.just(DIGITALTWIN_CLIENT_ERROR_INTERFACE_ALREADY_REGISTERED);\n-            } else {\n-                registrationStatus = REGISTERING;\n+            if(components.isEmpty()) {\n+                return Single.just(DIGITALTWIN_CLIENT_ERROR_COMPONENTS_NOT_BOUND);\n             }\n         }\n-\n-        return connectAsync(deviceClient)\n+        return ensureConnectAsync()\n                 .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n                     @Override\n                     public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        return sendRegistrationMessageAsync(deviceCapabilityModelId, digitalTwinInterfaceClients);\n-                    }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n-                    @Override\n-                    public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return subscribeCommandAsync();\n-                        } else {\n-                            return Flowable.just(result);\n-                        }\n+                        return sendRegistrationMessageAsync(result);\n                     }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                }).singleOrError();\n+    }\n+\n+    /**\n+     * Sends registration message to DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n+     *\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult registerComponents() {\n+        return registerComponentsAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Subscribe commands with the DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.* @return Result of this sync function.\n+     *\n+     * @return Result of this async function.\n+     */\n+    public Single<DigitalTwinClientResult> subscribeForCommandsAsync() {\n+        return ensureConnectAsync()\n+                .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n                     @Override\n                     public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return subscribeTwinAsync();\n-                        } else {\n-                            return Flowable.just(result);\n-                        }\n+                        return subscribeCommandsAsync(result);\n                     }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                }).singleOrError();\n+    }\n+\n+    /**\n+     * Subscribe commands with the DigitalTwin Service.\n+     * The call will be blocked and will return the result once registration is processed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEzODQzNQ==", "bodyText": "renamed.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r369138435", "createdAt": "2020-01-21T17:25:12Z", "author": {"login": "davilu"}, "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DigitalTwinDeviceClient.java", "diffHunk": "@@ -109,166 +99,284 @@\n      * Callers MUST NOT directly access {@link DeviceClient} after.\n      *\n      * @param deviceClient An {@link DeviceClient} that has been already created and bound to a specific connection string (or transport, or DPS handle, or whatever mechanism is preferred).\n+     * @param deviceCapabilityModelId     Device Capability Model Id\n+     *\n      */\n-    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient) {\n-        this.deviceClient = deviceClient;\n-        this.registrationStatus = UNREGISTERED;\n-        this.digitalTwinInterfaceClients = new HashMap<>();\n+    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient, @NonNull String deviceCapabilityModelId) {\n+        this.deviceClientManager = new DeviceClientManager(deviceClient);\n+        this.deviceCapabilityModelId = deviceCapabilityModelId;\n+        this.components = new ConcurrentHashMap<>();\n         this.lock = new Object();\n     }\n \n     /**\n-     * Registers the specified {@link AbstractDigitalTwinInterfaceClient} with the DigitalTwin Service.\n-     * The call occurs asynchronously. While registration is in progress, {@link AbstractDigitalTwinInterfaceClient}'s that are being registered will not be able to report properties nor receive commands.\n-     * The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n-     * It must not be called multiple times.  If a given Digital Twin device needs to have its handles re-registered, it needs to create a new DigitalTwinDeviceClient instance.\n+     * Bind all digital twin components with Digital Twin device client.\n+     * @param digitalTwinComponents An list of {@link AbstractDigitalTwinComponent}s to register with the service.\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult bindComponents(@NonNull final List<? extends AbstractDigitalTwinComponent> digitalTwinComponents) {\n+        synchronized (lock) {\n+            if(!components.isEmpty()) {\n+                return DIGITALTWIN_CLIENT_ERROR_COMPONENTS_ALREADY_BOUND;\n+            }\n+\n+            for (AbstractDigitalTwinComponent digitalTwinComponent : digitalTwinComponents) {\n+                digitalTwinComponent.setDigitalTwinDeviceClient(this);\n+                components.put(digitalTwinComponent.getDigitalTwinComponentName(), digitalTwinComponent);\n+            }\n+        }\n+        return DIGITALTWIN_CLIENT_OK;\n+    }\n+\n+    /**\n+     * Sends registration message message to DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n      *\n-     * @param deviceCapabilityModelId     Device Capability Model Id\n-     * @param digitalTwinInterfaceClients An list of {@link AbstractDigitalTwinInterfaceClient}s to register with the service.\n      * @return Result of this async function.\n      */\n-    public Single<DigitalTwinClientResult> registerInterfacesAsync(@NonNull final String deviceCapabilityModelId,\n-            @NonNull final List<? extends AbstractDigitalTwinInterfaceClient> digitalTwinInterfaceClients) {\n+    public Single<DigitalTwinClientResult> registerComponentsAsync() {\n         synchronized (lock) {\n-            if (registrationStatus == REGISTERING) {\n-                return Single.just(DIGITALTWIN_CLIENT_ERROR_REGISTRATION_PENDING);\n-            } else if (registrationStatus == REGISTERED) {\n-                return Single.just(DIGITALTWIN_CLIENT_ERROR_INTERFACE_ALREADY_REGISTERED);\n-            } else {\n-                registrationStatus = REGISTERING;\n+            if(components.isEmpty()) {\n+                return Single.just(DIGITALTWIN_CLIENT_ERROR_COMPONENTS_NOT_BOUND);\n             }\n         }\n-\n-        return connectAsync(deviceClient)\n+        return ensureConnectAsync()\n                 .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n                     @Override\n                     public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        return sendRegistrationMessageAsync(deviceCapabilityModelId, digitalTwinInterfaceClients);\n-                    }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n-                    @Override\n-                    public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return subscribeCommandAsync();\n-                        } else {\n-                            return Flowable.just(result);\n-                        }\n+                        return sendRegistrationMessageAsync(result);\n                     }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                }).singleOrError();\n+    }\n+\n+    /**\n+     * Sends registration message to DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n+     *\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult registerComponents() {\n+        return registerComponentsAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Subscribe commands with the DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.* @return Result of this sync function.\n+     *\n+     * @return Result of this async function.\n+     */\n+    public Single<DigitalTwinClientResult> subscribeForCommandsAsync() {\n+        return ensureConnectAsync()\n+                .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n                     @Override\n                     public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return subscribeTwinAsync();\n-                        } else {\n-                            return Flowable.just(result);\n-                        }\n+                        return subscribeCommandsAsync(result);\n                     }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                }).singleOrError();\n+    }\n+\n+    /**\n+     * Subscribe commands with the DigitalTwin Service.\n+     * The call will be blocked and will return the result once registration is processed.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MTU0NA=="}, "originalCommit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "originalPosition": 223}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTExODYwOnYy", "diffSide": "RIGHT", "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DigitalTwinDeviceClient.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo1NTozN1rOFfIpQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxOToxMjozMlrOFgFmug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MTgwOQ==", "bodyText": "what about content encoding and type?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r368191809", "createdAt": "2020-01-18T00:55:37Z", "author": {"login": "drwill-ms"}, "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DigitalTwinDeviceClient.java", "diffHunk": "@@ -109,166 +99,284 @@\n      * Callers MUST NOT directly access {@link DeviceClient} after.\n      *\n      * @param deviceClient An {@link DeviceClient} that has been already created and bound to a specific connection string (or transport, or DPS handle, or whatever mechanism is preferred).\n+     * @param deviceCapabilityModelId     Device Capability Model Id\n+     *\n      */\n-    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient) {\n-        this.deviceClient = deviceClient;\n-        this.registrationStatus = UNREGISTERED;\n-        this.digitalTwinInterfaceClients = new HashMap<>();\n+    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient, @NonNull String deviceCapabilityModelId) {\n+        this.deviceClientManager = new DeviceClientManager(deviceClient);\n+        this.deviceCapabilityModelId = deviceCapabilityModelId;\n+        this.components = new ConcurrentHashMap<>();\n         this.lock = new Object();\n     }\n \n     /**\n-     * Registers the specified {@link AbstractDigitalTwinInterfaceClient} with the DigitalTwin Service.\n-     * The call occurs asynchronously. While registration is in progress, {@link AbstractDigitalTwinInterfaceClient}'s that are being registered will not be able to report properties nor receive commands.\n-     * The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n-     * It must not be called multiple times.  If a given Digital Twin device needs to have its handles re-registered, it needs to create a new DigitalTwinDeviceClient instance.\n+     * Bind all digital twin components with Digital Twin device client.\n+     * @param digitalTwinComponents An list of {@link AbstractDigitalTwinComponent}s to register with the service.\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult bindComponents(@NonNull final List<? extends AbstractDigitalTwinComponent> digitalTwinComponents) {\n+        synchronized (lock) {\n+            if(!components.isEmpty()) {\n+                return DIGITALTWIN_CLIENT_ERROR_COMPONENTS_ALREADY_BOUND;\n+            }\n+\n+            for (AbstractDigitalTwinComponent digitalTwinComponent : digitalTwinComponents) {\n+                digitalTwinComponent.setDigitalTwinDeviceClient(this);\n+                components.put(digitalTwinComponent.getDigitalTwinComponentName(), digitalTwinComponent);\n+            }\n+        }\n+        return DIGITALTWIN_CLIENT_OK;\n+    }\n+\n+    /**\n+     * Sends registration message message to DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n      *\n-     * @param deviceCapabilityModelId     Device Capability Model Id\n-     * @param digitalTwinInterfaceClients An list of {@link AbstractDigitalTwinInterfaceClient}s to register with the service.\n      * @return Result of this async function.\n      */\n-    public Single<DigitalTwinClientResult> registerInterfacesAsync(@NonNull final String deviceCapabilityModelId,\n-            @NonNull final List<? extends AbstractDigitalTwinInterfaceClient> digitalTwinInterfaceClients) {\n+    public Single<DigitalTwinClientResult> registerComponentsAsync() {\n         synchronized (lock) {\n-            if (registrationStatus == REGISTERING) {\n-                return Single.just(DIGITALTWIN_CLIENT_ERROR_REGISTRATION_PENDING);\n-            } else if (registrationStatus == REGISTERED) {\n-                return Single.just(DIGITALTWIN_CLIENT_ERROR_INTERFACE_ALREADY_REGISTERED);\n-            } else {\n-                registrationStatus = REGISTERING;\n+            if(components.isEmpty()) {\n+                return Single.just(DIGITALTWIN_CLIENT_ERROR_COMPONENTS_NOT_BOUND);\n             }\n         }\n-\n-        return connectAsync(deviceClient)\n+        return ensureConnectAsync()\n                 .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n                     @Override\n                     public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        return sendRegistrationMessageAsync(deviceCapabilityModelId, digitalTwinInterfaceClients);\n-                    }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n-                    @Override\n-                    public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return subscribeCommandAsync();\n-                        } else {\n-                            return Flowable.just(result);\n-                        }\n+                        return sendRegistrationMessageAsync(result);\n                     }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                }).singleOrError();\n+    }\n+\n+    /**\n+     * Sends registration message to DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n+     *\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult registerComponents() {\n+        return registerComponentsAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Subscribe commands with the DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.* @return Result of this sync function.\n+     *\n+     * @return Result of this async function.\n+     */\n+    public Single<DigitalTwinClientResult> subscribeForCommandsAsync() {\n+        return ensureConnectAsync()\n+                .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n                     @Override\n                     public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return subscribeTwinAsync();\n-                        } else {\n-                            return Flowable.just(result);\n-                        }\n+                        return subscribeCommandsAsync(result);\n                     }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                }).singleOrError();\n+    }\n+\n+    /**\n+     * Subscribe commands with the DigitalTwin Service.\n+     * The call will be blocked and will return the result once registration is processed.\n+     *\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult subscribeForCommands() {\n+        return subscribeForCommandsAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Subscribe properties with the DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.* @return Result of this sync function.\n+     *\n+     * @return Result of this async function.\n+     */\n+    public Single<DigitalTwinClientResult> subscribeForPropertiesAsync() {\n+        return ensureConnectAsync()\n+                .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n                     @Override\n                     public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return reportSdkInformationAsync();\n-                        } else {\n-                            return Flowable.just(result);\n-                        }\n-                    }\n-                }).map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n-                    @Override\n-                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) throws Throwable {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return getTwinAsync();\n-                        } else {\n-                            return result;\n-                        }\n-                    }\n-                }).map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n-                    @Override\n-                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return notifyComponents(digitalTwinInterfaceClients);\n-                        } else {\n-                            return result;\n-                        }\n+                        return subscribePropertiesAsync(result);\n                     }\n-                }).map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n-                    @Override\n-                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) {\n-                        return onRegistrationResult(result);\n-                    }\n-                }).doOnError(new Consumer<Throwable>() {\n-                    @Override\n-                    public void accept(Throwable throwable) {\n-                        onRegistrationResult(DIGITALTWIN_CLIENT_ERROR);\n-                    }\n-                }).doOnCancel(new Action() {\n+                }).singleOrError();\n+    }\n+\n+    /**\n+     * Subscribe properties with the DigitalTwin Service.\n+     * The call will be blocked and will return the result once registration is processed.\n+     *\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult subscribeForProperties() {\n+        return subscribeForPropertiesAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Trigger properties sync up with the DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.* @return Result of this sync function.\n+     *\n+     * @return Result of this async function.\n+     */\n+    public Single<DigitalTwinClientResult> syncupPropertiesAsync() {\n+        return ensureConnectAsync()\n+                .map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n                     @Override\n-                    public void run() {\n-                        onRegistrationResult(DIGITALTWIN_CLIENT_ERROR);\n+                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) throws IOException {\n+                        // TODO Known gap, SDK API accepts no callback, there is no guarantee it's delivered\n+                        log.debug(\"Getting DeviceTwin...\");\n+                        deviceClientManager.getDeviceTwin();\n+                        return DIGITALTWIN_CLIENT_OK;\n                     }\n-                })\n-                .singleOrError();\n+                }).singleOrError();\n     }\n \n     /**\n-     * Registers the specified {@link AbstractDigitalTwinInterfaceClient} with the DigitalTwin Service.\n+     * Trigger properties sync up with the DigitalTwin Service.\n      * The call will be blocked and will return the result once registration is processed.\n-     * It must not be called multiple times. If a given Digital Twin device needs to have its handles re-registered, it needs to create a new DigitalTwinDeviceClient instance.\n      *\n-     * @param deviceCapabilityModelId     Device Capability Model Id\n-     * @param digitalTwinInterfaceClients An list of {@link AbstractDigitalTwinInterfaceClient}s to register with the service.\n      * @return Result of this sync function.\n      */\n-    public DigitalTwinClientResult registerInterfaces(@NonNull final String deviceCapabilityModelId,\n-            @NonNull final List<? extends AbstractDigitalTwinInterfaceClient> digitalTwinInterfaceClients) {\n-        return registerInterfacesAsync(deviceCapabilityModelId, digitalTwinInterfaceClients).blockingGet();\n+    public DigitalTwinClientResult syncupProperties() {\n+        return syncupPropertiesAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Application should call this function to notify all components they are now ready to use. All bound component function {@link AbstractDigitalTwinComponent#ready()} will be triggered.\n+     *\n+     * @return Failure if no component was bound, success otherwise.\n+     */\n+    public DigitalTwinClientResult ready() {\n+        synchronized (lock) {\n+            if(components.isEmpty()) {\n+                return DIGITALTWIN_CLIENT_ERROR_COMPONENTS_NOT_BOUND;\n+            }\n+\n+            for (AbstractDigitalTwinComponent component : components.values()) {\n+                component.ready();\n+            }\n+        }\n+        return DIGITALTWIN_CLIENT_OK;\n+    }\n+\n+    Flowable<DigitalTwinClientResult> sendTelemetryAsync(\n+            @NonNull final String digitalTwinComponentName,\n+            @NonNull final String telemetryName,\n+            @NonNull final String payload) {\n+        return ensureConnectAsync()\n+                .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                    @Override\n+                    public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n+                        return Flowable.create(new FlowableOnSubscribe<DigitalTwinClientResult>() {\n+                            @Override\n+                            public void subscribe(FlowableEmitter<DigitalTwinClientResult> emitter) throws Throwable {\n+                                log.debug(\"Sending TelemetryAsync...\");\n+                                SimpleEntry body = new SimpleEntry<>(telemetryName, new JsonRawValue(payload));\n+                                Message message = new Message(serialize(body));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNjI4NA==", "bodyText": "Default charset for JAVA is UTF-8. If we'd like to add default charset or content type, it should be handled in device SDK rather than digital twin SDK.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r368206284", "createdAt": "2020-01-18T04:52:05Z", "author": {"login": "davilu"}, "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DigitalTwinDeviceClient.java", "diffHunk": "@@ -109,166 +99,284 @@\n      * Callers MUST NOT directly access {@link DeviceClient} after.\n      *\n      * @param deviceClient An {@link DeviceClient} that has been already created and bound to a specific connection string (or transport, or DPS handle, or whatever mechanism is preferred).\n+     * @param deviceCapabilityModelId     Device Capability Model Id\n+     *\n      */\n-    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient) {\n-        this.deviceClient = deviceClient;\n-        this.registrationStatus = UNREGISTERED;\n-        this.digitalTwinInterfaceClients = new HashMap<>();\n+    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient, @NonNull String deviceCapabilityModelId) {\n+        this.deviceClientManager = new DeviceClientManager(deviceClient);\n+        this.deviceCapabilityModelId = deviceCapabilityModelId;\n+        this.components = new ConcurrentHashMap<>();\n         this.lock = new Object();\n     }\n \n     /**\n-     * Registers the specified {@link AbstractDigitalTwinInterfaceClient} with the DigitalTwin Service.\n-     * The call occurs asynchronously. While registration is in progress, {@link AbstractDigitalTwinInterfaceClient}'s that are being registered will not be able to report properties nor receive commands.\n-     * The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n-     * It must not be called multiple times.  If a given Digital Twin device needs to have its handles re-registered, it needs to create a new DigitalTwinDeviceClient instance.\n+     * Bind all digital twin components with Digital Twin device client.\n+     * @param digitalTwinComponents An list of {@link AbstractDigitalTwinComponent}s to register with the service.\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult bindComponents(@NonNull final List<? extends AbstractDigitalTwinComponent> digitalTwinComponents) {\n+        synchronized (lock) {\n+            if(!components.isEmpty()) {\n+                return DIGITALTWIN_CLIENT_ERROR_COMPONENTS_ALREADY_BOUND;\n+            }\n+\n+            for (AbstractDigitalTwinComponent digitalTwinComponent : digitalTwinComponents) {\n+                digitalTwinComponent.setDigitalTwinDeviceClient(this);\n+                components.put(digitalTwinComponent.getDigitalTwinComponentName(), digitalTwinComponent);\n+            }\n+        }\n+        return DIGITALTWIN_CLIENT_OK;\n+    }\n+\n+    /**\n+     * Sends registration message message to DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n      *\n-     * @param deviceCapabilityModelId     Device Capability Model Id\n-     * @param digitalTwinInterfaceClients An list of {@link AbstractDigitalTwinInterfaceClient}s to register with the service.\n      * @return Result of this async function.\n      */\n-    public Single<DigitalTwinClientResult> registerInterfacesAsync(@NonNull final String deviceCapabilityModelId,\n-            @NonNull final List<? extends AbstractDigitalTwinInterfaceClient> digitalTwinInterfaceClients) {\n+    public Single<DigitalTwinClientResult> registerComponentsAsync() {\n         synchronized (lock) {\n-            if (registrationStatus == REGISTERING) {\n-                return Single.just(DIGITALTWIN_CLIENT_ERROR_REGISTRATION_PENDING);\n-            } else if (registrationStatus == REGISTERED) {\n-                return Single.just(DIGITALTWIN_CLIENT_ERROR_INTERFACE_ALREADY_REGISTERED);\n-            } else {\n-                registrationStatus = REGISTERING;\n+            if(components.isEmpty()) {\n+                return Single.just(DIGITALTWIN_CLIENT_ERROR_COMPONENTS_NOT_BOUND);\n             }\n         }\n-\n-        return connectAsync(deviceClient)\n+        return ensureConnectAsync()\n                 .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n                     @Override\n                     public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        return sendRegistrationMessageAsync(deviceCapabilityModelId, digitalTwinInterfaceClients);\n-                    }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n-                    @Override\n-                    public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return subscribeCommandAsync();\n-                        } else {\n-                            return Flowable.just(result);\n-                        }\n+                        return sendRegistrationMessageAsync(result);\n                     }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                }).singleOrError();\n+    }\n+\n+    /**\n+     * Sends registration message to DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n+     *\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult registerComponents() {\n+        return registerComponentsAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Subscribe commands with the DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.* @return Result of this sync function.\n+     *\n+     * @return Result of this async function.\n+     */\n+    public Single<DigitalTwinClientResult> subscribeForCommandsAsync() {\n+        return ensureConnectAsync()\n+                .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n                     @Override\n                     public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return subscribeTwinAsync();\n-                        } else {\n-                            return Flowable.just(result);\n-                        }\n+                        return subscribeCommandsAsync(result);\n                     }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                }).singleOrError();\n+    }\n+\n+    /**\n+     * Subscribe commands with the DigitalTwin Service.\n+     * The call will be blocked and will return the result once registration is processed.\n+     *\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult subscribeForCommands() {\n+        return subscribeForCommandsAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Subscribe properties with the DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.* @return Result of this sync function.\n+     *\n+     * @return Result of this async function.\n+     */\n+    public Single<DigitalTwinClientResult> subscribeForPropertiesAsync() {\n+        return ensureConnectAsync()\n+                .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n                     @Override\n                     public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return reportSdkInformationAsync();\n-                        } else {\n-                            return Flowable.just(result);\n-                        }\n-                    }\n-                }).map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n-                    @Override\n-                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) throws Throwable {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return getTwinAsync();\n-                        } else {\n-                            return result;\n-                        }\n-                    }\n-                }).map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n-                    @Override\n-                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return notifyComponents(digitalTwinInterfaceClients);\n-                        } else {\n-                            return result;\n-                        }\n+                        return subscribePropertiesAsync(result);\n                     }\n-                }).map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n-                    @Override\n-                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) {\n-                        return onRegistrationResult(result);\n-                    }\n-                }).doOnError(new Consumer<Throwable>() {\n-                    @Override\n-                    public void accept(Throwable throwable) {\n-                        onRegistrationResult(DIGITALTWIN_CLIENT_ERROR);\n-                    }\n-                }).doOnCancel(new Action() {\n+                }).singleOrError();\n+    }\n+\n+    /**\n+     * Subscribe properties with the DigitalTwin Service.\n+     * The call will be blocked and will return the result once registration is processed.\n+     *\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult subscribeForProperties() {\n+        return subscribeForPropertiesAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Trigger properties sync up with the DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.* @return Result of this sync function.\n+     *\n+     * @return Result of this async function.\n+     */\n+    public Single<DigitalTwinClientResult> syncupPropertiesAsync() {\n+        return ensureConnectAsync()\n+                .map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n                     @Override\n-                    public void run() {\n-                        onRegistrationResult(DIGITALTWIN_CLIENT_ERROR);\n+                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) throws IOException {\n+                        // TODO Known gap, SDK API accepts no callback, there is no guarantee it's delivered\n+                        log.debug(\"Getting DeviceTwin...\");\n+                        deviceClientManager.getDeviceTwin();\n+                        return DIGITALTWIN_CLIENT_OK;\n                     }\n-                })\n-                .singleOrError();\n+                }).singleOrError();\n     }\n \n     /**\n-     * Registers the specified {@link AbstractDigitalTwinInterfaceClient} with the DigitalTwin Service.\n+     * Trigger properties sync up with the DigitalTwin Service.\n      * The call will be blocked and will return the result once registration is processed.\n-     * It must not be called multiple times. If a given Digital Twin device needs to have its handles re-registered, it needs to create a new DigitalTwinDeviceClient instance.\n      *\n-     * @param deviceCapabilityModelId     Device Capability Model Id\n-     * @param digitalTwinInterfaceClients An list of {@link AbstractDigitalTwinInterfaceClient}s to register with the service.\n      * @return Result of this sync function.\n      */\n-    public DigitalTwinClientResult registerInterfaces(@NonNull final String deviceCapabilityModelId,\n-            @NonNull final List<? extends AbstractDigitalTwinInterfaceClient> digitalTwinInterfaceClients) {\n-        return registerInterfacesAsync(deviceCapabilityModelId, digitalTwinInterfaceClients).blockingGet();\n+    public DigitalTwinClientResult syncupProperties() {\n+        return syncupPropertiesAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Application should call this function to notify all components they are now ready to use. All bound component function {@link AbstractDigitalTwinComponent#ready()} will be triggered.\n+     *\n+     * @return Failure if no component was bound, success otherwise.\n+     */\n+    public DigitalTwinClientResult ready() {\n+        synchronized (lock) {\n+            if(components.isEmpty()) {\n+                return DIGITALTWIN_CLIENT_ERROR_COMPONENTS_NOT_BOUND;\n+            }\n+\n+            for (AbstractDigitalTwinComponent component : components.values()) {\n+                component.ready();\n+            }\n+        }\n+        return DIGITALTWIN_CLIENT_OK;\n+    }\n+\n+    Flowable<DigitalTwinClientResult> sendTelemetryAsync(\n+            @NonNull final String digitalTwinComponentName,\n+            @NonNull final String telemetryName,\n+            @NonNull final String payload) {\n+        return ensureConnectAsync()\n+                .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                    @Override\n+                    public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n+                        return Flowable.create(new FlowableOnSubscribe<DigitalTwinClientResult>() {\n+                            @Override\n+                            public void subscribe(FlowableEmitter<DigitalTwinClientResult> emitter) throws Throwable {\n+                                log.debug(\"Sending TelemetryAsync...\");\n+                                SimpleEntry body = new SimpleEntry<>(telemetryName, new JsonRawValue(payload));\n+                                Message message = new Message(serialize(body));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MTgwOQ=="}, "originalCommit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI1MDUxMw==", "bodyText": "I don't know about defaults. In C# and C, the sender is supposed to specify both properties. If one doesn't, then the messages cannot be processed by the hub's rules engine. That means routing is broken.\nThis has nothing to do with a language's default character set, and telling the hub how to interpret the message, as sent.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r368250513", "createdAt": "2020-01-18T21:51:27Z", "author": {"login": "drwill-ms"}, "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DigitalTwinDeviceClient.java", "diffHunk": "@@ -109,166 +99,284 @@\n      * Callers MUST NOT directly access {@link DeviceClient} after.\n      *\n      * @param deviceClient An {@link DeviceClient} that has been already created and bound to a specific connection string (or transport, or DPS handle, or whatever mechanism is preferred).\n+     * @param deviceCapabilityModelId     Device Capability Model Id\n+     *\n      */\n-    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient) {\n-        this.deviceClient = deviceClient;\n-        this.registrationStatus = UNREGISTERED;\n-        this.digitalTwinInterfaceClients = new HashMap<>();\n+    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient, @NonNull String deviceCapabilityModelId) {\n+        this.deviceClientManager = new DeviceClientManager(deviceClient);\n+        this.deviceCapabilityModelId = deviceCapabilityModelId;\n+        this.components = new ConcurrentHashMap<>();\n         this.lock = new Object();\n     }\n \n     /**\n-     * Registers the specified {@link AbstractDigitalTwinInterfaceClient} with the DigitalTwin Service.\n-     * The call occurs asynchronously. While registration is in progress, {@link AbstractDigitalTwinInterfaceClient}'s that are being registered will not be able to report properties nor receive commands.\n-     * The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n-     * It must not be called multiple times.  If a given Digital Twin device needs to have its handles re-registered, it needs to create a new DigitalTwinDeviceClient instance.\n+     * Bind all digital twin components with Digital Twin device client.\n+     * @param digitalTwinComponents An list of {@link AbstractDigitalTwinComponent}s to register with the service.\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult bindComponents(@NonNull final List<? extends AbstractDigitalTwinComponent> digitalTwinComponents) {\n+        synchronized (lock) {\n+            if(!components.isEmpty()) {\n+                return DIGITALTWIN_CLIENT_ERROR_COMPONENTS_ALREADY_BOUND;\n+            }\n+\n+            for (AbstractDigitalTwinComponent digitalTwinComponent : digitalTwinComponents) {\n+                digitalTwinComponent.setDigitalTwinDeviceClient(this);\n+                components.put(digitalTwinComponent.getDigitalTwinComponentName(), digitalTwinComponent);\n+            }\n+        }\n+        return DIGITALTWIN_CLIENT_OK;\n+    }\n+\n+    /**\n+     * Sends registration message message to DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n      *\n-     * @param deviceCapabilityModelId     Device Capability Model Id\n-     * @param digitalTwinInterfaceClients An list of {@link AbstractDigitalTwinInterfaceClient}s to register with the service.\n      * @return Result of this async function.\n      */\n-    public Single<DigitalTwinClientResult> registerInterfacesAsync(@NonNull final String deviceCapabilityModelId,\n-            @NonNull final List<? extends AbstractDigitalTwinInterfaceClient> digitalTwinInterfaceClients) {\n+    public Single<DigitalTwinClientResult> registerComponentsAsync() {\n         synchronized (lock) {\n-            if (registrationStatus == REGISTERING) {\n-                return Single.just(DIGITALTWIN_CLIENT_ERROR_REGISTRATION_PENDING);\n-            } else if (registrationStatus == REGISTERED) {\n-                return Single.just(DIGITALTWIN_CLIENT_ERROR_INTERFACE_ALREADY_REGISTERED);\n-            } else {\n-                registrationStatus = REGISTERING;\n+            if(components.isEmpty()) {\n+                return Single.just(DIGITALTWIN_CLIENT_ERROR_COMPONENTS_NOT_BOUND);\n             }\n         }\n-\n-        return connectAsync(deviceClient)\n+        return ensureConnectAsync()\n                 .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n                     @Override\n                     public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        return sendRegistrationMessageAsync(deviceCapabilityModelId, digitalTwinInterfaceClients);\n-                    }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n-                    @Override\n-                    public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return subscribeCommandAsync();\n-                        } else {\n-                            return Flowable.just(result);\n-                        }\n+                        return sendRegistrationMessageAsync(result);\n                     }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                }).singleOrError();\n+    }\n+\n+    /**\n+     * Sends registration message to DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n+     *\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult registerComponents() {\n+        return registerComponentsAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Subscribe commands with the DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.* @return Result of this sync function.\n+     *\n+     * @return Result of this async function.\n+     */\n+    public Single<DigitalTwinClientResult> subscribeForCommandsAsync() {\n+        return ensureConnectAsync()\n+                .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n                     @Override\n                     public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return subscribeTwinAsync();\n-                        } else {\n-                            return Flowable.just(result);\n-                        }\n+                        return subscribeCommandsAsync(result);\n                     }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                }).singleOrError();\n+    }\n+\n+    /**\n+     * Subscribe commands with the DigitalTwin Service.\n+     * The call will be blocked and will return the result once registration is processed.\n+     *\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult subscribeForCommands() {\n+        return subscribeForCommandsAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Subscribe properties with the DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.* @return Result of this sync function.\n+     *\n+     * @return Result of this async function.\n+     */\n+    public Single<DigitalTwinClientResult> subscribeForPropertiesAsync() {\n+        return ensureConnectAsync()\n+                .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n                     @Override\n                     public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return reportSdkInformationAsync();\n-                        } else {\n-                            return Flowable.just(result);\n-                        }\n-                    }\n-                }).map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n-                    @Override\n-                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) throws Throwable {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return getTwinAsync();\n-                        } else {\n-                            return result;\n-                        }\n-                    }\n-                }).map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n-                    @Override\n-                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return notifyComponents(digitalTwinInterfaceClients);\n-                        } else {\n-                            return result;\n-                        }\n+                        return subscribePropertiesAsync(result);\n                     }\n-                }).map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n-                    @Override\n-                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) {\n-                        return onRegistrationResult(result);\n-                    }\n-                }).doOnError(new Consumer<Throwable>() {\n-                    @Override\n-                    public void accept(Throwable throwable) {\n-                        onRegistrationResult(DIGITALTWIN_CLIENT_ERROR);\n-                    }\n-                }).doOnCancel(new Action() {\n+                }).singleOrError();\n+    }\n+\n+    /**\n+     * Subscribe properties with the DigitalTwin Service.\n+     * The call will be blocked and will return the result once registration is processed.\n+     *\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult subscribeForProperties() {\n+        return subscribeForPropertiesAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Trigger properties sync up with the DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.* @return Result of this sync function.\n+     *\n+     * @return Result of this async function.\n+     */\n+    public Single<DigitalTwinClientResult> syncupPropertiesAsync() {\n+        return ensureConnectAsync()\n+                .map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n                     @Override\n-                    public void run() {\n-                        onRegistrationResult(DIGITALTWIN_CLIENT_ERROR);\n+                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) throws IOException {\n+                        // TODO Known gap, SDK API accepts no callback, there is no guarantee it's delivered\n+                        log.debug(\"Getting DeviceTwin...\");\n+                        deviceClientManager.getDeviceTwin();\n+                        return DIGITALTWIN_CLIENT_OK;\n                     }\n-                })\n-                .singleOrError();\n+                }).singleOrError();\n     }\n \n     /**\n-     * Registers the specified {@link AbstractDigitalTwinInterfaceClient} with the DigitalTwin Service.\n+     * Trigger properties sync up with the DigitalTwin Service.\n      * The call will be blocked and will return the result once registration is processed.\n-     * It must not be called multiple times. If a given Digital Twin device needs to have its handles re-registered, it needs to create a new DigitalTwinDeviceClient instance.\n      *\n-     * @param deviceCapabilityModelId     Device Capability Model Id\n-     * @param digitalTwinInterfaceClients An list of {@link AbstractDigitalTwinInterfaceClient}s to register with the service.\n      * @return Result of this sync function.\n      */\n-    public DigitalTwinClientResult registerInterfaces(@NonNull final String deviceCapabilityModelId,\n-            @NonNull final List<? extends AbstractDigitalTwinInterfaceClient> digitalTwinInterfaceClients) {\n-        return registerInterfacesAsync(deviceCapabilityModelId, digitalTwinInterfaceClients).blockingGet();\n+    public DigitalTwinClientResult syncupProperties() {\n+        return syncupPropertiesAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Application should call this function to notify all components they are now ready to use. All bound component function {@link AbstractDigitalTwinComponent#ready()} will be triggered.\n+     *\n+     * @return Failure if no component was bound, success otherwise.\n+     */\n+    public DigitalTwinClientResult ready() {\n+        synchronized (lock) {\n+            if(components.isEmpty()) {\n+                return DIGITALTWIN_CLIENT_ERROR_COMPONENTS_NOT_BOUND;\n+            }\n+\n+            for (AbstractDigitalTwinComponent component : components.values()) {\n+                component.ready();\n+            }\n+        }\n+        return DIGITALTWIN_CLIENT_OK;\n+    }\n+\n+    Flowable<DigitalTwinClientResult> sendTelemetryAsync(\n+            @NonNull final String digitalTwinComponentName,\n+            @NonNull final String telemetryName,\n+            @NonNull final String payload) {\n+        return ensureConnectAsync()\n+                .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                    @Override\n+                    public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n+                        return Flowable.create(new FlowableOnSubscribe<DigitalTwinClientResult>() {\n+                            @Override\n+                            public void subscribe(FlowableEmitter<DigitalTwinClientResult> emitter) throws Throwable {\n+                                log.debug(\"Sending TelemetryAsync...\");\n+                                SimpleEntry body = new SimpleEntry<>(telemetryName, new JsonRawValue(payload));\n+                                Message message = new Message(serialize(body));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MTgwOQ=="}, "originalCommit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE5MDU4Ng==", "bodyText": "done.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r369190586", "createdAt": "2020-01-21T19:12:32Z", "author": {"login": "davilu"}, "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DigitalTwinDeviceClient.java", "diffHunk": "@@ -109,166 +99,284 @@\n      * Callers MUST NOT directly access {@link DeviceClient} after.\n      *\n      * @param deviceClient An {@link DeviceClient} that has been already created and bound to a specific connection string (or transport, or DPS handle, or whatever mechanism is preferred).\n+     * @param deviceCapabilityModelId     Device Capability Model Id\n+     *\n      */\n-    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient) {\n-        this.deviceClient = deviceClient;\n-        this.registrationStatus = UNREGISTERED;\n-        this.digitalTwinInterfaceClients = new HashMap<>();\n+    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient, @NonNull String deviceCapabilityModelId) {\n+        this.deviceClientManager = new DeviceClientManager(deviceClient);\n+        this.deviceCapabilityModelId = deviceCapabilityModelId;\n+        this.components = new ConcurrentHashMap<>();\n         this.lock = new Object();\n     }\n \n     /**\n-     * Registers the specified {@link AbstractDigitalTwinInterfaceClient} with the DigitalTwin Service.\n-     * The call occurs asynchronously. While registration is in progress, {@link AbstractDigitalTwinInterfaceClient}'s that are being registered will not be able to report properties nor receive commands.\n-     * The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n-     * It must not be called multiple times.  If a given Digital Twin device needs to have its handles re-registered, it needs to create a new DigitalTwinDeviceClient instance.\n+     * Bind all digital twin components with Digital Twin device client.\n+     * @param digitalTwinComponents An list of {@link AbstractDigitalTwinComponent}s to register with the service.\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult bindComponents(@NonNull final List<? extends AbstractDigitalTwinComponent> digitalTwinComponents) {\n+        synchronized (lock) {\n+            if(!components.isEmpty()) {\n+                return DIGITALTWIN_CLIENT_ERROR_COMPONENTS_ALREADY_BOUND;\n+            }\n+\n+            for (AbstractDigitalTwinComponent digitalTwinComponent : digitalTwinComponents) {\n+                digitalTwinComponent.setDigitalTwinDeviceClient(this);\n+                components.put(digitalTwinComponent.getDigitalTwinComponentName(), digitalTwinComponent);\n+            }\n+        }\n+        return DIGITALTWIN_CLIENT_OK;\n+    }\n+\n+    /**\n+     * Sends registration message message to DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n      *\n-     * @param deviceCapabilityModelId     Device Capability Model Id\n-     * @param digitalTwinInterfaceClients An list of {@link AbstractDigitalTwinInterfaceClient}s to register with the service.\n      * @return Result of this async function.\n      */\n-    public Single<DigitalTwinClientResult> registerInterfacesAsync(@NonNull final String deviceCapabilityModelId,\n-            @NonNull final List<? extends AbstractDigitalTwinInterfaceClient> digitalTwinInterfaceClients) {\n+    public Single<DigitalTwinClientResult> registerComponentsAsync() {\n         synchronized (lock) {\n-            if (registrationStatus == REGISTERING) {\n-                return Single.just(DIGITALTWIN_CLIENT_ERROR_REGISTRATION_PENDING);\n-            } else if (registrationStatus == REGISTERED) {\n-                return Single.just(DIGITALTWIN_CLIENT_ERROR_INTERFACE_ALREADY_REGISTERED);\n-            } else {\n-                registrationStatus = REGISTERING;\n+            if(components.isEmpty()) {\n+                return Single.just(DIGITALTWIN_CLIENT_ERROR_COMPONENTS_NOT_BOUND);\n             }\n         }\n-\n-        return connectAsync(deviceClient)\n+        return ensureConnectAsync()\n                 .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n                     @Override\n                     public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        return sendRegistrationMessageAsync(deviceCapabilityModelId, digitalTwinInterfaceClients);\n-                    }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n-                    @Override\n-                    public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return subscribeCommandAsync();\n-                        } else {\n-                            return Flowable.just(result);\n-                        }\n+                        return sendRegistrationMessageAsync(result);\n                     }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                }).singleOrError();\n+    }\n+\n+    /**\n+     * Sends registration message to DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n+     *\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult registerComponents() {\n+        return registerComponentsAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Subscribe commands with the DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.* @return Result of this sync function.\n+     *\n+     * @return Result of this async function.\n+     */\n+    public Single<DigitalTwinClientResult> subscribeForCommandsAsync() {\n+        return ensureConnectAsync()\n+                .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n                     @Override\n                     public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return subscribeTwinAsync();\n-                        } else {\n-                            return Flowable.just(result);\n-                        }\n+                        return subscribeCommandsAsync(result);\n                     }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                }).singleOrError();\n+    }\n+\n+    /**\n+     * Subscribe commands with the DigitalTwin Service.\n+     * The call will be blocked and will return the result once registration is processed.\n+     *\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult subscribeForCommands() {\n+        return subscribeForCommandsAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Subscribe properties with the DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.* @return Result of this sync function.\n+     *\n+     * @return Result of this async function.\n+     */\n+    public Single<DigitalTwinClientResult> subscribeForPropertiesAsync() {\n+        return ensureConnectAsync()\n+                .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n                     @Override\n                     public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return reportSdkInformationAsync();\n-                        } else {\n-                            return Flowable.just(result);\n-                        }\n-                    }\n-                }).map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n-                    @Override\n-                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) throws Throwable {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return getTwinAsync();\n-                        } else {\n-                            return result;\n-                        }\n-                    }\n-                }).map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n-                    @Override\n-                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return notifyComponents(digitalTwinInterfaceClients);\n-                        } else {\n-                            return result;\n-                        }\n+                        return subscribePropertiesAsync(result);\n                     }\n-                }).map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n-                    @Override\n-                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) {\n-                        return onRegistrationResult(result);\n-                    }\n-                }).doOnError(new Consumer<Throwable>() {\n-                    @Override\n-                    public void accept(Throwable throwable) {\n-                        onRegistrationResult(DIGITALTWIN_CLIENT_ERROR);\n-                    }\n-                }).doOnCancel(new Action() {\n+                }).singleOrError();\n+    }\n+\n+    /**\n+     * Subscribe properties with the DigitalTwin Service.\n+     * The call will be blocked and will return the result once registration is processed.\n+     *\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult subscribeForProperties() {\n+        return subscribeForPropertiesAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Trigger properties sync up with the DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.* @return Result of this sync function.\n+     *\n+     * @return Result of this async function.\n+     */\n+    public Single<DigitalTwinClientResult> syncupPropertiesAsync() {\n+        return ensureConnectAsync()\n+                .map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n                     @Override\n-                    public void run() {\n-                        onRegistrationResult(DIGITALTWIN_CLIENT_ERROR);\n+                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) throws IOException {\n+                        // TODO Known gap, SDK API accepts no callback, there is no guarantee it's delivered\n+                        log.debug(\"Getting DeviceTwin...\");\n+                        deviceClientManager.getDeviceTwin();\n+                        return DIGITALTWIN_CLIENT_OK;\n                     }\n-                })\n-                .singleOrError();\n+                }).singleOrError();\n     }\n \n     /**\n-     * Registers the specified {@link AbstractDigitalTwinInterfaceClient} with the DigitalTwin Service.\n+     * Trigger properties sync up with the DigitalTwin Service.\n      * The call will be blocked and will return the result once registration is processed.\n-     * It must not be called multiple times. If a given Digital Twin device needs to have its handles re-registered, it needs to create a new DigitalTwinDeviceClient instance.\n      *\n-     * @param deviceCapabilityModelId     Device Capability Model Id\n-     * @param digitalTwinInterfaceClients An list of {@link AbstractDigitalTwinInterfaceClient}s to register with the service.\n      * @return Result of this sync function.\n      */\n-    public DigitalTwinClientResult registerInterfaces(@NonNull final String deviceCapabilityModelId,\n-            @NonNull final List<? extends AbstractDigitalTwinInterfaceClient> digitalTwinInterfaceClients) {\n-        return registerInterfacesAsync(deviceCapabilityModelId, digitalTwinInterfaceClients).blockingGet();\n+    public DigitalTwinClientResult syncupProperties() {\n+        return syncupPropertiesAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Application should call this function to notify all components they are now ready to use. All bound component function {@link AbstractDigitalTwinComponent#ready()} will be triggered.\n+     *\n+     * @return Failure if no component was bound, success otherwise.\n+     */\n+    public DigitalTwinClientResult ready() {\n+        synchronized (lock) {\n+            if(components.isEmpty()) {\n+                return DIGITALTWIN_CLIENT_ERROR_COMPONENTS_NOT_BOUND;\n+            }\n+\n+            for (AbstractDigitalTwinComponent component : components.values()) {\n+                component.ready();\n+            }\n+        }\n+        return DIGITALTWIN_CLIENT_OK;\n+    }\n+\n+    Flowable<DigitalTwinClientResult> sendTelemetryAsync(\n+            @NonNull final String digitalTwinComponentName,\n+            @NonNull final String telemetryName,\n+            @NonNull final String payload) {\n+        return ensureConnectAsync()\n+                .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                    @Override\n+                    public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n+                        return Flowable.create(new FlowableOnSubscribe<DigitalTwinClientResult>() {\n+                            @Override\n+                            public void subscribe(FlowableEmitter<DigitalTwinClientResult> emitter) throws Throwable {\n+                                log.debug(\"Sending TelemetryAsync...\");\n+                                SimpleEntry body = new SimpleEntry<>(telemetryName, new JsonRawValue(payload));\n+                                Message message = new Message(serialize(body));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MTgwOQ=="}, "originalCommit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "originalPosition": 362}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTExOTQ0OnYy", "diffSide": "RIGHT", "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DigitalTwinDeviceClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo1NjozM1rOFfIpug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMDo1NjozM1rOFfIpug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MTkzMA==", "bodyText": "grammar: succeeded", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r368191930", "createdAt": "2020-01-18T00:56:33Z", "author": {"login": "drwill-ms"}, "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DigitalTwinDeviceClient.java", "diffHunk": "@@ -109,166 +99,284 @@\n      * Callers MUST NOT directly access {@link DeviceClient} after.\n      *\n      * @param deviceClient An {@link DeviceClient} that has been already created and bound to a specific connection string (or transport, or DPS handle, or whatever mechanism is preferred).\n+     * @param deviceCapabilityModelId     Device Capability Model Id\n+     *\n      */\n-    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient) {\n-        this.deviceClient = deviceClient;\n-        this.registrationStatus = UNREGISTERED;\n-        this.digitalTwinInterfaceClients = new HashMap<>();\n+    public DigitalTwinDeviceClient(@NonNull DeviceClient deviceClient, @NonNull String deviceCapabilityModelId) {\n+        this.deviceClientManager = new DeviceClientManager(deviceClient);\n+        this.deviceCapabilityModelId = deviceCapabilityModelId;\n+        this.components = new ConcurrentHashMap<>();\n         this.lock = new Object();\n     }\n \n     /**\n-     * Registers the specified {@link AbstractDigitalTwinInterfaceClient} with the DigitalTwin Service.\n-     * The call occurs asynchronously. While registration is in progress, {@link AbstractDigitalTwinInterfaceClient}'s that are being registered will not be able to report properties nor receive commands.\n-     * The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n-     * It must not be called multiple times.  If a given Digital Twin device needs to have its handles re-registered, it needs to create a new DigitalTwinDeviceClient instance.\n+     * Bind all digital twin components with Digital Twin device client.\n+     * @param digitalTwinComponents An list of {@link AbstractDigitalTwinComponent}s to register with the service.\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult bindComponents(@NonNull final List<? extends AbstractDigitalTwinComponent> digitalTwinComponents) {\n+        synchronized (lock) {\n+            if(!components.isEmpty()) {\n+                return DIGITALTWIN_CLIENT_ERROR_COMPONENTS_ALREADY_BOUND;\n+            }\n+\n+            for (AbstractDigitalTwinComponent digitalTwinComponent : digitalTwinComponents) {\n+                digitalTwinComponent.setDigitalTwinDeviceClient(this);\n+                components.put(digitalTwinComponent.getDigitalTwinComponentName(), digitalTwinComponent);\n+            }\n+        }\n+        return DIGITALTWIN_CLIENT_OK;\n+    }\n+\n+    /**\n+     * Sends registration message message to DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n      *\n-     * @param deviceCapabilityModelId     Device Capability Model Id\n-     * @param digitalTwinInterfaceClients An list of {@link AbstractDigitalTwinInterfaceClient}s to register with the service.\n      * @return Result of this async function.\n      */\n-    public Single<DigitalTwinClientResult> registerInterfacesAsync(@NonNull final String deviceCapabilityModelId,\n-            @NonNull final List<? extends AbstractDigitalTwinInterfaceClient> digitalTwinInterfaceClients) {\n+    public Single<DigitalTwinClientResult> registerComponentsAsync() {\n         synchronized (lock) {\n-            if (registrationStatus == REGISTERING) {\n-                return Single.just(DIGITALTWIN_CLIENT_ERROR_REGISTRATION_PENDING);\n-            } else if (registrationStatus == REGISTERED) {\n-                return Single.just(DIGITALTWIN_CLIENT_ERROR_INTERFACE_ALREADY_REGISTERED);\n-            } else {\n-                registrationStatus = REGISTERING;\n+            if(components.isEmpty()) {\n+                return Single.just(DIGITALTWIN_CLIENT_ERROR_COMPONENTS_NOT_BOUND);\n             }\n         }\n-\n-        return connectAsync(deviceClient)\n+        return ensureConnectAsync()\n                 .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n                     @Override\n                     public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        return sendRegistrationMessageAsync(deviceCapabilityModelId, digitalTwinInterfaceClients);\n-                    }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n-                    @Override\n-                    public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return subscribeCommandAsync();\n-                        } else {\n-                            return Flowable.just(result);\n-                        }\n+                        return sendRegistrationMessageAsync(result);\n                     }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                }).singleOrError();\n+    }\n+\n+    /**\n+     * Sends registration message to DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.\n+     *\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult registerComponents() {\n+        return registerComponentsAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Subscribe commands with the DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.* @return Result of this sync function.\n+     *\n+     * @return Result of this async function.\n+     */\n+    public Single<DigitalTwinClientResult> subscribeForCommandsAsync() {\n+        return ensureConnectAsync()\n+                .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n                     @Override\n                     public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return subscribeTwinAsync();\n-                        } else {\n-                            return Flowable.just(result);\n-                        }\n+                        return subscribeCommandsAsync(result);\n                     }\n-                }).flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                }).singleOrError();\n+    }\n+\n+    /**\n+     * Subscribe commands with the DigitalTwin Service.\n+     * The call will be blocked and will return the result once registration is processed.\n+     *\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult subscribeForCommands() {\n+        return subscribeForCommandsAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Subscribe properties with the DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.* @return Result of this sync function.\n+     *\n+     * @return Result of this async function.\n+     */\n+    public Single<DigitalTwinClientResult> subscribeForPropertiesAsync() {\n+        return ensureConnectAsync()\n+                .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n                     @Override\n                     public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return reportSdkInformationAsync();\n-                        } else {\n-                            return Flowable.just(result);\n-                        }\n-                    }\n-                }).map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n-                    @Override\n-                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) throws Throwable {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return getTwinAsync();\n-                        } else {\n-                            return result;\n-                        }\n-                    }\n-                }).map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n-                    @Override\n-                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) {\n-                        if (result == DIGITALTWIN_CLIENT_OK) {\n-                            return notifyComponents(digitalTwinInterfaceClients);\n-                        } else {\n-                            return result;\n-                        }\n+                        return subscribePropertiesAsync(result);\n                     }\n-                }).map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n-                    @Override\n-                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) {\n-                        return onRegistrationResult(result);\n-                    }\n-                }).doOnError(new Consumer<Throwable>() {\n-                    @Override\n-                    public void accept(Throwable throwable) {\n-                        onRegistrationResult(DIGITALTWIN_CLIENT_ERROR);\n-                    }\n-                }).doOnCancel(new Action() {\n+                }).singleOrError();\n+    }\n+\n+    /**\n+     * Subscribe properties with the DigitalTwin Service.\n+     * The call will be blocked and will return the result once registration is processed.\n+     *\n+     * @return Result of this sync function.\n+     */\n+    public DigitalTwinClientResult subscribeForProperties() {\n+        return subscribeForPropertiesAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Trigger properties sync up with the DigitalTwin Service.\n+     * The call occurs asynchronously. The call returns immediately. The application can either subscribe to handle the result or block to get the result.* @return Result of this sync function.\n+     *\n+     * @return Result of this async function.\n+     */\n+    public Single<DigitalTwinClientResult> syncupPropertiesAsync() {\n+        return ensureConnectAsync()\n+                .map(new Function<DigitalTwinClientResult, DigitalTwinClientResult>() {\n                     @Override\n-                    public void run() {\n-                        onRegistrationResult(DIGITALTWIN_CLIENT_ERROR);\n+                    public DigitalTwinClientResult apply(DigitalTwinClientResult result) throws IOException {\n+                        // TODO Known gap, SDK API accepts no callback, there is no guarantee it's delivered\n+                        log.debug(\"Getting DeviceTwin...\");\n+                        deviceClientManager.getDeviceTwin();\n+                        return DIGITALTWIN_CLIENT_OK;\n                     }\n-                })\n-                .singleOrError();\n+                }).singleOrError();\n     }\n \n     /**\n-     * Registers the specified {@link AbstractDigitalTwinInterfaceClient} with the DigitalTwin Service.\n+     * Trigger properties sync up with the DigitalTwin Service.\n      * The call will be blocked and will return the result once registration is processed.\n-     * It must not be called multiple times. If a given Digital Twin device needs to have its handles re-registered, it needs to create a new DigitalTwinDeviceClient instance.\n      *\n-     * @param deviceCapabilityModelId     Device Capability Model Id\n-     * @param digitalTwinInterfaceClients An list of {@link AbstractDigitalTwinInterfaceClient}s to register with the service.\n      * @return Result of this sync function.\n      */\n-    public DigitalTwinClientResult registerInterfaces(@NonNull final String deviceCapabilityModelId,\n-            @NonNull final List<? extends AbstractDigitalTwinInterfaceClient> digitalTwinInterfaceClients) {\n-        return registerInterfacesAsync(deviceCapabilityModelId, digitalTwinInterfaceClients).blockingGet();\n+    public DigitalTwinClientResult syncupProperties() {\n+        return syncupPropertiesAsync().blockingGet();\n+    }\n+\n+    /**\n+     * Application should call this function to notify all components they are now ready to use. All bound component function {@link AbstractDigitalTwinComponent#ready()} will be triggered.\n+     *\n+     * @return Failure if no component was bound, success otherwise.\n+     */\n+    public DigitalTwinClientResult ready() {\n+        synchronized (lock) {\n+            if(components.isEmpty()) {\n+                return DIGITALTWIN_CLIENT_ERROR_COMPONENTS_NOT_BOUND;\n+            }\n+\n+            for (AbstractDigitalTwinComponent component : components.values()) {\n+                component.ready();\n+            }\n+        }\n+        return DIGITALTWIN_CLIENT_OK;\n+    }\n+\n+    Flowable<DigitalTwinClientResult> sendTelemetryAsync(\n+            @NonNull final String digitalTwinComponentName,\n+            @NonNull final String telemetryName,\n+            @NonNull final String payload) {\n+        return ensureConnectAsync()\n+                .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                    @Override\n+                    public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n+                        return Flowable.create(new FlowableOnSubscribe<DigitalTwinClientResult>() {\n+                            @Override\n+                            public void subscribe(FlowableEmitter<DigitalTwinClientResult> emitter) throws Throwable {\n+                                log.debug(\"Sending TelemetryAsync...\");\n+                                SimpleEntry body = new SimpleEntry<>(telemetryName, new JsonRawValue(payload));\n+                                Message message = new Message(serialize(body));\n+                                message.setProperty(PROPERTY_DIGITAL_TWIN_COMPONENT, digitalTwinComponentName);\n+                                message.setProperty(PROPERTY_MESSAGE_SCHEMA, telemetryName);\n+                                IotHubEventCallback callback = createIotHubEventCallback(emitter);\n+                                deviceClientManager.sendEventAsync(message, callback, callback);\n+                                log.debug(\"SendTelemetryAsync succeed.\");\n+                            }\n+                        }, BUFFER);\n+                    }\n+                });\n+    }\n+\n+    Flowable<DigitalTwinClientResult> reportPropertiesAsync(\n+            @NonNull final String digitalTwinComponentName,\n+            @NonNull final List<DigitalTwinReportProperty> digitalTwinReportProperties) {\n+        return ensureConnectAsync()\n+                .flatMap(new Function<DigitalTwinClientResult, Flowable<DigitalTwinClientResult>>() {\n+                    @Override\n+                    public Flowable<DigitalTwinClientResult> apply(DigitalTwinClientResult result) {\n+                        return Flowable.create(new FlowableOnSubscribe<DigitalTwinClientResult>() {\n+                            @Override\n+                            public void subscribe(FlowableEmitter<DigitalTwinClientResult> emitter) throws Throwable {\n+                                log.debug(\"Reporting PropertiesAsync...\");\n+                                // TODO Known gap, SDK API with ambiguous Object\n+                                Property property = serializeReportProperty(digitalTwinComponentName, digitalTwinReportProperties);\n+                                deviceClientManager.sendReportedProperties(singleton(property));\n+                                // TODO Known gap, SDK API accepts no callback, there is no guarantee it's delivered\n+                                log.debug(\"ReportPropertiesAsync succeed.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "originalPosition": 389}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTEyNTA1OnYy", "diffSide": "RIGHT", "path": "digital-twin/device/src/test/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DigitalTwinDeviceClientTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMTowMzowN1rOFfItFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMTowMzowN1rOFfItFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5Mjc5MA==", "bodyText": "grammar: threw", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r368192790", "createdAt": "2020-01-18T01:03:07Z", "author": {"login": "drwill-ms"}, "path": "digital-twin/device/src/test/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DigitalTwinDeviceClientTest.java", "diffHunk": "@@ -301,84 +314,56 @@ public Object answer(InvocationOnMock invocation) throws Exception {\n             log.debug(\"Send registration message throw exception\", e);\n         }\n \n+        verify(deviceClient).open();\n         verify(errorConsumer).accept(eq(exception));\n-        assertThat(testee.getRegistrationStatus()).isEqualTo(UNREGISTERED);\n-        verify(digitalTwinInterfaceClient1, never()).setDigitalTwinDeviceClient(any(DigitalTwinDeviceClient.class));\n-        verify(digitalTwinInterfaceClient2, never()).setDigitalTwinDeviceClient(any(DigitalTwinDeviceClient.class));\n-        verify(digitalTwinInterfaceClient1, never()).onRegistered();\n-        verify(digitalTwinInterfaceClient2, never()).onRegistered();\n-        verify(deviceClient, never()).subscribeToDeviceMethod(any(DeviceMethodCallback.class), any(), any(IotHubEventCallback.class), any());\n     }\n \n     @Test\n-    public void registerInterfacesAsyncCommandSubscriptionFailedTest() throws IOException {\n-        doAnswer(new Answer() {\n-            @Override\n-            public Object answer(InvocationOnMock invocation) {\n-                final IotHubEventCallback iotHubEventCallback = invocation.getArgumentAt(2, IotHubEventCallback.class);\n-                final Object context = invocation.getArgumentAt(3, Object.class);\n-                new Thread(new Runnable() {\n-                    @Override\n-                    public void run() {\n-                        try {\n-                            Thread.sleep(DELAY_IN_MS);\n-                        } catch (InterruptedException e) {\n-                            e.printStackTrace();\n-                        }\n-                        iotHubEventCallback.execute(ERROR, context);\n-                    }\n-                }).start();\n-                return null;\n-            }\n-        }).when(deviceClient)\n-          .subscribeToDeviceMethod(any(DeviceMethodCallback.class), any(), any(IotHubEventCallback.class), any());\n-        DigitalTwinClientResult digitalTwinClientResult = testee.registerInterfacesAsync(DIGITAL_TWIN_DCM_ID, digitalTwinInterfaceClients).blockingGet();\n-        assertThat(digitalTwinClientResult).isEqualTo(DIGITALTWIN_CLIENT_ERROR);\n-        assertThat(testee.getRegistrationStatus()).isEqualTo(UNREGISTERED);\n-        verify(digitalTwinInterfaceClient1, never()).setDigitalTwinDeviceClient(any(DigitalTwinDeviceClient.class));\n-        verify(digitalTwinInterfaceClient2, never()).setDigitalTwinDeviceClient(any(DigitalTwinDeviceClient.class));\n-        verify(digitalTwinInterfaceClient1, never()).onRegistered();\n-        verify(digitalTwinInterfaceClient2, never()).onRegistered();\n-        verify(deviceClient, never()).startDeviceTwin(any(IotHubEventCallback.class), any(), any(TwinPropertyCallBack.class), any());\n+    public void subscribeForCommandsAsyncTest() throws IOException {\n+        assertThat(testee.subscribeForCommandsAsync().blockingGet()).isEqualTo(DIGITALTWIN_CLIENT_OK);\n+        verify(deviceClient).open();\n+        verify(deviceClient).subscribeToDeviceMethod(any(DeviceMethodCallback.class), any(), any(IotHubEventCallback.class), any());\n     }\n \n     @Test\n-    public void registerInterfacesAsyncCommandSubscriptionThrowExceptionTest() throws Throwable {\n-        final Exception exception = new Exception(\"CommandSubscriptionThrowException\");\n+    public void subscribeForCommandsTest() throws IOException {\n+        assertThat(testee.subscribeForCommands()).isEqualTo(DIGITALTWIN_CLIENT_OK);\n+        verify(deviceClient).open();\n+        verify(deviceClient).subscribeToDeviceMethod(any(DeviceMethodCallback.class), any(), any(IotHubEventCallback.class), any());\n+    }\n+\n+    @Test\n+    public void subscribeForCommandsAsyncOpenThrowExceptionTest() throws Throwable {\n+        final Exception exception = new Exception(\"OpenThrowException\");\n         doAnswer(new Answer() {\n             @Override\n             public Object answer(InvocationOnMock invocation) throws Exception {\n                 throw exception;\n             }\n         }).when(deviceClient)\n-          .subscribeToDeviceMethod(any(DeviceMethodCallback.class), any(), any(IotHubEventCallback.class), any());\n+          .open();\n \n         try {\n-            DigitalTwinClientResult digitalTwinClientResult = testee.registerInterfacesAsync(DIGITAL_TWIN_DCM_ID, digitalTwinInterfaceClients)\n+            DigitalTwinClientResult digitalTwinClientResult = testee.subscribeForCommandsAsync()\n                                                                     .doOnError(errorConsumer)\n                                                                     .blockingGet();\n             log.debug(\"Unexpected result: {}\", digitalTwinClientResult);\n             fail(\"Should throw exception.\");\n         } catch (Throwable e) {\n-            log.debug(\"Subscribe command throw exception.\", e);\n+            log.debug(\"Open throw exception\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "originalPosition": 352}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTEzMDU0OnYy", "diffSide": "RIGHT", "path": "digital-twin/service/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/service/DigitalTwinServiceAsyncClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwMTowOToxNVrOFfIwEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwNDo1ODo0NFrOFfJi7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MzU1Mg==", "bodyText": "interface instance => component\nelsewhere too", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r368193552", "createdAt": "2020-01-18T01:09:15Z", "author": {"login": "drwill-ms"}, "path": "digital-twin/service/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/service/DigitalTwinServiceAsyncClient.java", "diffHunk": "@@ -56,24 +56,24 @@\n      * @return The observable to the json string specifying the updated state  of the digital twin representation\n      * @throws IOException Throws IOException if the json deserialization fails\n      */\n-    Observable<String> updateDigitalTwinProperties(@NonNull String digitalTwinId, @NonNull final String interfaceInstanceName, @NonNull String propertyPatch) throws IOException;\n+    Observable<String> updateDigitalTwinProperties(@NonNull String digitalTwinId, @NonNull final String componentName, @NonNull String propertyPatch) throws IOException;\n \n     /**\n      * Invoke a digital twin command on the given interface instance that is implemented by the given digital twin", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNjU3Mw==", "bodyText": "@abhipsaMisra  is going to carry on to fix naming for service client. There are more in generated code and payload might be changed as well in future. Service side is not ready yet.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r368206573", "createdAt": "2020-01-18T04:58:44Z", "author": {"login": "davilu"}, "path": "digital-twin/service/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/service/DigitalTwinServiceAsyncClient.java", "diffHunk": "@@ -56,24 +56,24 @@\n      * @return The observable to the json string specifying the updated state  of the digital twin representation\n      * @throws IOException Throws IOException if the json deserialization fails\n      */\n-    Observable<String> updateDigitalTwinProperties(@NonNull String digitalTwinId, @NonNull final String interfaceInstanceName, @NonNull String propertyPatch) throws IOException;\n+    Observable<String> updateDigitalTwinProperties(@NonNull String digitalTwinId, @NonNull final String componentName, @NonNull String propertyPatch) throws IOException;\n \n     /**\n      * Invoke a digital twin command on the given interface instance that is implemented by the given digital twin", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MzU1Mg=="}, "originalCommit": {"oid": "4a5cba8c47b3e273156286d60c18fec8af5ccaa4"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MTc2ODU0OnYy", "diffSide": "RIGHT", "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DeviceClientManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxOToxNToyOVrOFgFsLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxOTozNTowNVrOFgodAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE5MTk4MA==", "bodyText": "From my testing, we throw IOException on network loss. The TransportException is embedded under Exception.getCause(): https://github.com/Azure/azure-iot-sdk-java/pull/681/files#diff-d05304fffaae6bfdbe785b51eca97bfcR74", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r369191980", "createdAt": "2020-01-21T19:15:29Z", "author": {"login": "abhipsaMisra"}, "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DeviceClientManager.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package com.microsoft.azure.sdk.iot.digitaltwin.device;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceClient;\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.experimental.Delegate;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+@Slf4j\n+public class DeviceClientManager implements IotHubConnectionStatusChangeCallback {\n+    private enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+\n+    private static final Object lock = new Object();\n+    private static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 10;\n+    private ConnectionStatus connectionStatus;\n+    private Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    private interface DeviceClientNonDelegatedFunction {\n+        void open();\n+        void closeNow();\n+        void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext);\n+    }\n+\n+    // The methods defined in the interface DeviceClientNonDelegatedFunction will be called on DeviceClientManager, and not on DeviceClient.\n+    @Delegate(excludes = DeviceClientNonDelegatedFunction.class)\n+    private final DeviceClient client;\n+\n+    DeviceClientManager(DeviceClient deviceClient) {\n+        this.connectionStatus = ConnectionStatus.DISCONNECTED;\n+        this.client = deviceClient;\n+        this.client.registerConnectionStatusChangeCallback(this, this);\n+    }\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+    }\n+\n+    public void open() throws Exception {\n+        synchronized (lock) {\n+            if (connectionStatus == ConnectionStatus.DISCONNECTED) {\n+                connectionStatus = ConnectionStatus.CONNECTING;\n+            } else {\n+                return;\n+            }\n+        }\n+        doConnect();\n+    }\n+\n+    private void doConnect() throws Exception {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if (connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"[connect] - Opening the device client instance...\");\n+                        client.open();\n+                        connectionStatus = ConnectionStatus.CONNECTED;\n+                        break;\n+                    }\n+                    catch (Exception ex) {\n+                        log.error(\"[connect] - Exception thrown while opening DeviceClient instance: \", ex);\n+                        if (ex instanceof TransportException && ((TransportException) ex).isRetryable()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63ad99ade89472ad0669527ca4b32a99254e3dee"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIxMzEyNw==", "bodyText": "https://github.com/Azure/azure-iot-sdk-java/blob/master/device/iot-device-client/src/main/java/com/microsoft/azure/sdk/iot/device/DeviceIO.java#L162", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r369213127", "createdAt": "2020-01-21T19:58:53Z", "author": {"login": "abhipsaMisra"}, "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DeviceClientManager.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package com.microsoft.azure.sdk.iot.digitaltwin.device;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceClient;\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.experimental.Delegate;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+@Slf4j\n+public class DeviceClientManager implements IotHubConnectionStatusChangeCallback {\n+    private enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+\n+    private static final Object lock = new Object();\n+    private static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 10;\n+    private ConnectionStatus connectionStatus;\n+    private Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    private interface DeviceClientNonDelegatedFunction {\n+        void open();\n+        void closeNow();\n+        void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext);\n+    }\n+\n+    // The methods defined in the interface DeviceClientNonDelegatedFunction will be called on DeviceClientManager, and not on DeviceClient.\n+    @Delegate(excludes = DeviceClientNonDelegatedFunction.class)\n+    private final DeviceClient client;\n+\n+    DeviceClientManager(DeviceClient deviceClient) {\n+        this.connectionStatus = ConnectionStatus.DISCONNECTED;\n+        this.client = deviceClient;\n+        this.client.registerConnectionStatusChangeCallback(this, this);\n+    }\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+    }\n+\n+    public void open() throws Exception {\n+        synchronized (lock) {\n+            if (connectionStatus == ConnectionStatus.DISCONNECTED) {\n+                connectionStatus = ConnectionStatus.CONNECTING;\n+            } else {\n+                return;\n+            }\n+        }\n+        doConnect();\n+    }\n+\n+    private void doConnect() throws Exception {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if (connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"[connect] - Opening the device client instance...\");\n+                        client.open();\n+                        connectionStatus = ConnectionStatus.CONNECTED;\n+                        break;\n+                    }\n+                    catch (Exception ex) {\n+                        log.error(\"[connect] - Exception thrown while opening DeviceClient instance: \", ex);\n+                        if (ex instanceof TransportException && ((TransportException) ex).isRetryable()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE5MTk4MA=="}, "originalCommit": {"oid": "63ad99ade89472ad0669527ca4b32a99254e3dee"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc2MTUzOA==", "bodyText": "Too bad to hear that...", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r369761538", "createdAt": "2020-01-22T19:35:05Z", "author": {"login": "davilu"}, "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/DeviceClientManager.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package com.microsoft.azure.sdk.iot.digitaltwin.device;\n+\n+import com.microsoft.azure.sdk.iot.device.DeviceClient;\n+import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeCallback;\n+import com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason;\n+import com.microsoft.azure.sdk.iot.device.exceptions.DeviceOperationTimeoutException;\n+import com.microsoft.azure.sdk.iot.device.exceptions.TransportException;\n+import com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus;\n+import lombok.experimental.Delegate;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.NO_NETWORK;\n+import static com.microsoft.azure.sdk.iot.device.IotHubConnectionStatusChangeReason.RETRY_EXPIRED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED;\n+import static com.microsoft.azure.sdk.iot.device.transport.IotHubConnectionStatus.DISCONNECTED_RETRYING;\n+\n+@Slf4j\n+public class DeviceClientManager implements IotHubConnectionStatusChangeCallback {\n+    private enum ConnectionStatus {\n+        DISCONNECTED, CONNECTING, CONNECTED\n+    }\n+\n+    private static final Object lock = new Object();\n+    private static final int SLEEP_TIME_BEFORE_RECONNECTING_IN_SECONDS = 10;\n+    private ConnectionStatus connectionStatus;\n+    private Pair<IotHubConnectionStatusChangeCallback, Object> suppliedConnectionStatusChangeCallback;\n+\n+    private interface DeviceClientNonDelegatedFunction {\n+        void open();\n+        void closeNow();\n+        void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext);\n+    }\n+\n+    // The methods defined in the interface DeviceClientNonDelegatedFunction will be called on DeviceClientManager, and not on DeviceClient.\n+    @Delegate(excludes = DeviceClientNonDelegatedFunction.class)\n+    private final DeviceClient client;\n+\n+    DeviceClientManager(DeviceClient deviceClient) {\n+        this.connectionStatus = ConnectionStatus.DISCONNECTED;\n+        this.client = deviceClient;\n+        this.client.registerConnectionStatusChangeCallback(this, this);\n+    }\n+\n+    public void registerConnectionStatusChangeCallback(IotHubConnectionStatusChangeCallback callback, Object callbackContext) {\n+        this.suppliedConnectionStatusChangeCallback = new Pair<>(callback, callbackContext);\n+    }\n+\n+    public void open() throws Exception {\n+        synchronized (lock) {\n+            if (connectionStatus == ConnectionStatus.DISCONNECTED) {\n+                connectionStatus = ConnectionStatus.CONNECTING;\n+            } else {\n+                return;\n+            }\n+        }\n+        doConnect();\n+    }\n+\n+    private void doConnect() throws Exception {\n+        // Device client does not have retry on the initial open() call. Will need to be re-opened by the calling application\n+        while (connectionStatus == ConnectionStatus.CONNECTING) {\n+            synchronized (lock) {\n+                if (connectionStatus == ConnectionStatus.CONNECTING) {\n+                    try {\n+                        log.debug(\"[connect] - Opening the device client instance...\");\n+                        client.open();\n+                        connectionStatus = ConnectionStatus.CONNECTED;\n+                        break;\n+                    }\n+                    catch (Exception ex) {\n+                        log.error(\"[connect] - Exception thrown while opening DeviceClient instance: \", ex);\n+                        if (ex instanceof TransportException && ((TransportException) ex).isRetryable()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE5MTk4MA=="}, "originalCommit": {"oid": "63ad99ade89472ad0669527ca4b32a99254e3dee"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MTkzMzc3OnYy", "diffSide": "RIGHT", "path": "digital-twin/device/src/test/java/com/microsoft/azure/sdk/iot/digitaltwin/device/SdkInformationComponentTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMDoxMTowNFrOFgHUfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxOTozNDoyMlrOFgobsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIxODY4NQ==", "bodyText": "Isn't the behavior of eq() the same as same()?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r369218685", "createdAt": "2020-01-21T20:11:04Z", "author": {"login": "abhipsaMisra"}, "path": "digital-twin/device/src/test/java/com/microsoft/azure/sdk/iot/digitaltwin/device/SdkInformationComponentTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package com.microsoft.azure.sdk.iot.digitaltwin.device;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.powermock.core.classloader.annotations.PrepareForTest;\n+import org.powermock.modules.junit4.PowerMockRunner;\n+\n+import static com.microsoft.azure.sdk.iot.digitaltwin.device.DigitalTwinClientResult.DIGITALTWIN_CLIENT_OK;\n+import static com.microsoft.azure.sdk.iot.digitaltwin.device.SdkInformationComponent.SDK_INFORMATION_COMPONENT_NAME;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Matchers.same;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(PowerMockRunner.class)\n+@PrepareForTest({DigitalTwinDeviceClient.class})\n+public class SdkInformationComponentTest {\n+\n+    @Mock\n+    private DigitalTwinDeviceClient digitalTwinDeviceClient;\n+\n+    @Test\n+    public void singletonTest() {\n+        assertThat(SdkInformationComponent.getInstance()).isSameAs(SdkInformationComponent.getInstance());\n+        assertThat(SdkInformationComponent.getInstance().getSdkInformationProperties()).isNotEmpty();\n+    }\n+\n+    @Test\n+    public void readyTest() {\n+        SdkInformationComponent sdkInformationComponent = SdkInformationComponent.getInstance();\n+        when(digitalTwinDeviceClient.reportPropertiesAsync(eq(SDK_INFORMATION_COMPONENT_NAME), same(sdkInformationComponent.getSdkInformationProperties()))).thenReturn(Flowable.just(DIGITALTWIN_CLIENT_OK));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63ad99ade89472ad0669527ca4b32a99254e3dee"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc2MTIwMg==", "bodyText": "No. same must be the same instance.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r369761202", "createdAt": "2020-01-22T19:34:22Z", "author": {"login": "davilu"}, "path": "digital-twin/device/src/test/java/com/microsoft/azure/sdk/iot/digitaltwin/device/SdkInformationComponentTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package com.microsoft.azure.sdk.iot.digitaltwin.device;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.powermock.core.classloader.annotations.PrepareForTest;\n+import org.powermock.modules.junit4.PowerMockRunner;\n+\n+import static com.microsoft.azure.sdk.iot.digitaltwin.device.DigitalTwinClientResult.DIGITALTWIN_CLIENT_OK;\n+import static com.microsoft.azure.sdk.iot.digitaltwin.device.SdkInformationComponent.SDK_INFORMATION_COMPONENT_NAME;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Matchers.same;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(PowerMockRunner.class)\n+@PrepareForTest({DigitalTwinDeviceClient.class})\n+public class SdkInformationComponentTest {\n+\n+    @Mock\n+    private DigitalTwinDeviceClient digitalTwinDeviceClient;\n+\n+    @Test\n+    public void singletonTest() {\n+        assertThat(SdkInformationComponent.getInstance()).isSameAs(SdkInformationComponent.getInstance());\n+        assertThat(SdkInformationComponent.getInstance().getSdkInformationProperties()).isNotEmpty();\n+    }\n+\n+    @Test\n+    public void readyTest() {\n+        SdkInformationComponent sdkInformationComponent = SdkInformationComponent.getInstance();\n+        when(digitalTwinDeviceClient.reportPropertiesAsync(eq(SDK_INFORMATION_COMPONENT_NAME), same(sdkInformationComponent.getSdkInformationProperties()))).thenReturn(Flowable.just(DIGITALTWIN_CLIENT_OK));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIxODY4NQ=="}, "originalCommit": {"oid": "63ad99ade89472ad0669527ca4b32a99254e3dee"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MTk4NTQ1OnYy", "diffSide": "RIGHT", "path": "digital-twin/e2e-tests/digital-twin-e2e-tests-common/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/e2e/tests/DigitalTwinCommandE2ETests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMDozMDoxNFrOFgH0gQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMDozMDoxNFrOFgH0gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIyNjg4MQ==", "bodyText": "Should be retrieveComponentNameFromComponentId, but I can refactor these when I make the updates for the service client.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r369226881", "createdAt": "2020-01-21T20:30:14Z", "author": {"login": "abhipsaMisra"}, "path": "digital-twin/e2e-tests/digital-twin-e2e-tests-common/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/e2e/tests/DigitalTwinCommandE2ETests.java", "diffHunk": "@@ -54,17 +67,18 @@\n @RunWith(Parameterized.class)\n public class DigitalTwinCommandE2ETests {\n     private static final String IOT_HUB_CONNECTION_STRING = retrieveEnvironmentVariableValue(IOT_HUB_CONNECTION_STRING_ENV_VAR_NAME);\n-    private static final String TEST_INTERFACE_INSTANCE_NAME_1 = retrieveInterfaceNameFromInterfaceId(TestInterfaceInstance1.TEST_INTERFACE_ID);\n-    private static final String TEST_INTERFACE_INSTANCE_NAME_2 = retrieveInterfaceNameFromInterfaceId(TEST_INTERFACE_ID);\n+    private static final String TEST_COMPONENT_NAME_1 = retrieveComponentNameFromInterfaceId(TestComponent1.TEST_INTERFACE_ID);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63ad99ade89472ad0669527ca4b32a99254e3dee"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MjMxNTgxOnYy", "diffSide": "RIGHT", "path": "digital-twin/e2e-tests/digital-twin-e2e-tests-common/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/e2e/tests/DigitalTwinServiceClientE2ETests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMjozMjoxMFrOFgLBgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMjozMjoxMFrOFgLBgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI3OTM2MA==", "bodyText": "Our nightly run shows that this test passed, we should not ignore it.", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r369279360", "createdAt": "2020-01-21T22:32:10Z", "author": {"login": "abhipsaMisra"}, "path": "digital-twin/e2e-tests/digital-twin-e2e-tests-common/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/e2e/tests/DigitalTwinServiceClientE2ETests.java", "diffHunk": "@@ -58,14 +59,19 @@ public void setUpTest() throws IotHubException, IOException, URISyntaxException\n     }\n \n     @Test\n+    // TODO\n+    @Ignore(\"404 response from server\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63ad99ade89472ad0669527ca4b32a99254e3dee"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDIxMDQzOnYy", "diffSide": "RIGHT", "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/AbstractDigitalTwinComponent.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMDo0NDo1M1rOFiz3EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMDo0NDo1M1rOFiz3EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA0NTU4NQ==", "bodyText": "logging update to \"... component is not bound\"?", "url": "https://github.com/Azure/azure-iot-sdk-java/pull/682#discussion_r372045585", "createdAt": "2020-01-28T20:44:53Z", "author": {"login": "drwill-ms"}, "path": "digital-twin/device/src/main/java/com/microsoft/azure/sdk/iot/digitaltwin/device/AbstractDigitalTwinComponent.java", "diffHunk": "@@ -105,14 +104,14 @@ protected final DigitalTwinClientResult sendTelemetry(@NonNull final String tele\n      * @return Result of this async function.\n      */\n     protected final Single<DigitalTwinClientResult> reportPropertiesAsync(@NonNull final List<DigitalTwinReportProperty> digitalTwinReportProperties) {\n-        log.debug(\"Reporting PropertiesAsync from interface instance={}\", digitalTwinInterfaceInstanceName);\n+        log.debug(\"Reporting PropertiesAsync from component={}\", digitalTwinComponentName);\n         if (digitalTwinDeviceClient == null) {\n-            log.debug(\"Report PropertiesAsync from interface instance={} failed: interface instance is not registered.\", digitalTwinInterfaceInstanceName);\n-            return Single.just(DIGITALTWIN_CLIENT_ERROR_INTERFACE_NOT_REGISTERED);\n+            log.debug(\"Report PropertiesAsync from component={} failed: component is not registered.\", digitalTwinComponentName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cffa8395ca285e0124e952e0f2a82e751dc1d400"}, "originalPosition": 81}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2955, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}