{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3MjU5NDgx", "number": 8500, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxMzozMTozMFrOD-mQKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxMzoxNjoxOFrOFNOoSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2OTY1MDM1OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/model/ApiTypeWrapper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxMzozMTozMFrOGYy3UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxMzo0MDowNlrOGYzKgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY1MjM2OQ==", "bodyText": "Shall we use a ternary operator here? Lets check and fix other places where applicable.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (isAPIProduct) {\n          \n          \n            \n                        return apiProduct.getContextTemplate();\n          \n          \n            \n                    } else {\n          \n          \n            \n                        return api.getContextTemplate();\n          \n          \n            \n                    }\n          \n          \n            \n                    return isAPIProduct ? apiProduct.getContextTemplate() : api.getContextTemplate();", "url": "https://github.com/wso2/carbon-apimgt/pull/8500#discussion_r428652369", "createdAt": "2020-05-21T13:31:30Z", "author": {"login": "malinthaprasan"}, "path": "components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/model/ApiTypeWrapper.java", "diffHunk": "@@ -68,4 +68,68 @@ public void setTier(String tier) {\n             api.getId().setTier(tier);\n         }\n     }\n+\n+    public void setContext(String context) {\n+        if (isAPIProduct) {\n+            apiProduct.setContext(context);\n+        } else {\n+            api.setContext(context);\n+        }\n+    }\n+\n+    public String getContext() {\n+        if (isAPIProduct) {\n+            return apiProduct.getContext();\n+        } else {\n+            return api.getContext();\n+        }\n+    }\n+\n+    public void setContextTemplate(String contextTemplate) {\n+        if (isAPIProduct) {\n+            apiProduct.setContextTemplate(contextTemplate);\n+        } else {\n+            api.setContextTemplate(contextTemplate);\n+        }\n+    }\n+\n+    public String getContextTemplate() {\n+        if (isAPIProduct) {\n+            return apiProduct.getContextTemplate();\n+        } else {\n+            return api.getContextTemplate();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8588ed8e9529f4edd394272935b29aa22bf5cca7"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY1NzI4MQ==", "bodyText": "Sure", "url": "https://github.com/wso2/carbon-apimgt/pull/8500#discussion_r428657281", "createdAt": "2020-05-21T13:40:06Z", "author": {"login": "wasuradananjith"}, "path": "components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/model/ApiTypeWrapper.java", "diffHunk": "@@ -68,4 +68,68 @@ public void setTier(String tier) {\n             api.getId().setTier(tier);\n         }\n     }\n+\n+    public void setContext(String context) {\n+        if (isAPIProduct) {\n+            apiProduct.setContext(context);\n+        } else {\n+            api.setContext(context);\n+        }\n+    }\n+\n+    public String getContext() {\n+        if (isAPIProduct) {\n+            return apiProduct.getContext();\n+        } else {\n+            return api.getContext();\n+        }\n+    }\n+\n+    public void setContextTemplate(String contextTemplate) {\n+        if (isAPIProduct) {\n+            apiProduct.setContextTemplate(contextTemplate);\n+        } else {\n+            api.setContextTemplate(contextTemplate);\n+        }\n+    }\n+\n+    public String getContextTemplate() {\n+        if (isAPIProduct) {\n+            return apiProduct.getContextTemplate();\n+        } else {\n+            return api.getContextTemplate();\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY1MjM2OQ=="}, "originalCommit": {"oid": "8588ed8e9529f4edd394272935b29aa22bf5cca7"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2OTY3MjE2OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIProviderImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxMzozNzozMFrOGYzEwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNTowNTozOVrOGY2mnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY1NTgxMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        APIProductIdentifier productIdentifier = apiProductResource.getProductIdentifier();\n          \n          \n            \n                        if (productIdentifier != null) {\n          \n          \n            \n                        if (apiProductResource.getProductIdentifier() != null) {", "url": "https://github.com/wso2/carbon-apimgt/pull/8500#discussion_r428655810", "createdAt": "2020-05-21T13:37:30Z", "author": {"login": "malinthaprasan"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIProviderImpl.java", "diffHunk": "@@ -7380,19 +7420,22 @@ protected void checkAccessControlPermission(Identifier identifier) throws APIMan\n \n         List<APIProductResource> resources = product.getProductResources();\n \n-        // list to hold resouces which are actually in an existing api. If user has created an API product with invalid\n+        // list to hold resources which are actually in an existing api. If user has created an API product with invalid\n         // API or invalid resource of a valid API, that content will be removed .validResources array will have only\n         // legitimate apis\n         List<APIProductResource> validResources = new ArrayList<APIProductResource>();\n         for (APIProductResource apiProductResource : resources) {\n             API api = null;\n-            try {\n+            APIProductIdentifier productIdentifier = apiProductResource.getProductIdentifier();\n+            if (productIdentifier != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8588ed8e9529f4edd394272935b29aa22bf5cca7"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcxMzYyOQ==", "bodyText": "Sure", "url": "https://github.com/wso2/carbon-apimgt/pull/8500#discussion_r428713629", "createdAt": "2020-05-21T15:05:39Z", "author": {"login": "wasuradananjith"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIProviderImpl.java", "diffHunk": "@@ -7380,19 +7420,22 @@ protected void checkAccessControlPermission(Identifier identifier) throws APIMan\n \n         List<APIProductResource> resources = product.getProductResources();\n \n-        // list to hold resouces which are actually in an existing api. If user has created an API product with invalid\n+        // list to hold resources which are actually in an existing api. If user has created an API product with invalid\n         // API or invalid resource of a valid API, that content will be removed .validResources array will have only\n         // legitimate apis\n         List<APIProductResource> validResources = new ArrayList<APIProductResource>();\n         for (APIProductResource apiProductResource : resources) {\n             API api = null;\n-            try {\n+            APIProductIdentifier productIdentifier = apiProductResource.getProductIdentifier();\n+            if (productIdentifier != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY1NTgxMA=="}, "originalCommit": {"oid": "8588ed8e9529f4edd394272935b29aa22bf5cca7"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2OTcyODYzOnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/AbstractAPIManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxMzo1MzowMFrOGYzohg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNDo0Nzo0N1rOGY1skg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY2NDk2Ng==", "bodyText": "We shouldn't log and throw.", "url": "https://github.com/wso2/carbon-apimgt/pull/8500#discussion_r428664966", "createdAt": "2020-05-21T13:53:00Z", "author": {"login": "malinthaprasan"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/AbstractAPIManager.java", "diffHunk": "@@ -808,6 +808,19 @@ public boolean isAPIAvailable(APIIdentifier identifier) throws APIManagementExce\n         }\n     }\n \n+    public boolean isAPIProductAvailable(APIProductIdentifier identifier) throws APIManagementException {\n+        String path = APIConstants.API_ROOT_LOCATION + RegistryConstants.PATH_SEPARATOR +\n+                identifier.getProviderName() + RegistryConstants.PATH_SEPARATOR +\n+                identifier.getName() + RegistryConstants.PATH_SEPARATOR + identifier.getVersion();\n+        try {\n+            return registry.resourceExists(path);\n+        } catch (RegistryException e) {\n+            String msg = \"Failed to check availability of API Product :\" + path;\n+            log.error(msg, e);\n+            throw new APIManagementException(msg, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8588ed8e9529f4edd394272935b29aa22bf5cca7"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY5ODc3MA==", "bodyText": "Sure, the same procedure has been done in isAPIAvailable function in line numbers 805-807. Shall I change that too?", "url": "https://github.com/wso2/carbon-apimgt/pull/8500#discussion_r428698770", "createdAt": "2020-05-21T14:47:47Z", "author": {"login": "wasuradananjith"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/AbstractAPIManager.java", "diffHunk": "@@ -808,6 +808,19 @@ public boolean isAPIAvailable(APIIdentifier identifier) throws APIManagementExce\n         }\n     }\n \n+    public boolean isAPIProductAvailable(APIProductIdentifier identifier) throws APIManagementException {\n+        String path = APIConstants.API_ROOT_LOCATION + RegistryConstants.PATH_SEPARATOR +\n+                identifier.getProviderName() + RegistryConstants.PATH_SEPARATOR +\n+                identifier.getName() + RegistryConstants.PATH_SEPARATOR + identifier.getVersion();\n+        try {\n+            return registry.resourceExists(path);\n+        } catch (RegistryException e) {\n+            String msg = \"Failed to check availability of API Product :\" + path;\n+            log.error(msg, e);\n+            throw new APIManagementException(msg, e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY2NDk2Ng=="}, "originalCommit": {"oid": "8588ed8e9529f4edd394272935b29aa22bf5cca7"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2OTczMDA1OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/AbstractAPIManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxMzo1MzoyNVrOGYzpeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODoyMjowOVrOGY9ynw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY2NTIwOQ==", "bodyText": "Let's remove log.error. We shouldn't log and throw which is an antipattern.", "url": "https://github.com/wso2/carbon-apimgt/pull/8500#discussion_r428665209", "createdAt": "2020-05-21T13:53:25Z", "author": {"login": "malinthaprasan"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/AbstractAPIManager.java", "diffHunk": "@@ -808,6 +808,19 @@ public boolean isAPIAvailable(APIIdentifier identifier) throws APIManagementExce\n         }\n     }\n \n+    public boolean isAPIProductAvailable(APIProductIdentifier identifier) throws APIManagementException {\n+        String path = APIConstants.API_ROOT_LOCATION + RegistryConstants.PATH_SEPARATOR +\n+                identifier.getProviderName() + RegistryConstants.PATH_SEPARATOR +\n+                identifier.getName() + RegistryConstants.PATH_SEPARATOR + identifier.getVersion();\n+        try {\n+            return registry.resourceExists(path);\n+        } catch (RegistryException e) {\n+            String msg = \"Failed to check availability of API Product :\" + path;\n+            log.error(msg, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8588ed8e9529f4edd394272935b29aa22bf5cca7"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY5ODMyMA==", "bodyText": "Sure, the same procedure has been done in isAPIAvailable function in line numbers 805-807. Shall I change that too?", "url": "https://github.com/wso2/carbon-apimgt/pull/8500#discussion_r428698320", "createdAt": "2020-05-21T14:47:07Z", "author": {"login": "wasuradananjith"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/AbstractAPIManager.java", "diffHunk": "@@ -808,6 +808,19 @@ public boolean isAPIAvailable(APIIdentifier identifier) throws APIManagementExce\n         }\n     }\n \n+    public boolean isAPIProductAvailable(APIProductIdentifier identifier) throws APIManagementException {\n+        String path = APIConstants.API_ROOT_LOCATION + RegistryConstants.PATH_SEPARATOR +\n+                identifier.getProviderName() + RegistryConstants.PATH_SEPARATOR +\n+                identifier.getName() + RegistryConstants.PATH_SEPARATOR + identifier.getVersion();\n+        try {\n+            return registry.resourceExists(path);\n+        } catch (RegistryException e) {\n+            String msg = \"Failed to check availability of API Product :\" + path;\n+            log.error(msg, e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY2NTIwOQ=="}, "originalCommit": {"oid": "8588ed8e9529f4edd394272935b29aa22bf5cca7"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzMTM5MQ==", "bodyText": "Yes please, let's do this for other applicable places too,", "url": "https://github.com/wso2/carbon-apimgt/pull/8500#discussion_r428831391", "createdAt": "2020-05-21T18:22:09Z", "author": {"login": "malinthaprasan"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/AbstractAPIManager.java", "diffHunk": "@@ -808,6 +808,19 @@ public boolean isAPIAvailable(APIIdentifier identifier) throws APIManagementExce\n         }\n     }\n \n+    public boolean isAPIProductAvailable(APIProductIdentifier identifier) throws APIManagementException {\n+        String path = APIConstants.API_ROOT_LOCATION + RegistryConstants.PATH_SEPARATOR +\n+                identifier.getProviderName() + RegistryConstants.PATH_SEPARATOR +\n+                identifier.getName() + RegistryConstants.PATH_SEPARATOR + identifier.getVersion();\n+        try {\n+            return registry.resourceExists(path);\n+        } catch (RegistryException e) {\n+            String msg = \"Failed to check availability of API Product :\" + path;\n+            log.error(msg, e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY2NTIwOQ=="}, "originalCommit": {"oid": "8588ed8e9529f4edd394272935b29aa22bf5cca7"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2OTczMzY4OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/importexport/APIImportExportManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxMzo1NDozMFrOGYzr8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNDo1MDoyOVrOGY1z7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY2NTg0Mw==", "bodyText": "Do we need this as an info log? Shall we make this \"debug\"?", "url": "https://github.com/wso2/carbon-apimgt/pull/8500#discussion_r428665843", "createdAt": "2020-05-21T13:54:30Z", "author": {"login": "malinthaprasan"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/importexport/APIImportExportManager.java", "diffHunk": "@@ -59,19 +64,25 @@ public APIProvider getApiProvider() {\n     /**\n      * This method is used to export the given API as an archive (zip file).\n      *\n-     * @param apiToReturn       Requested API to export\n-     * @param isStatusPreserved Is API status preserved or not\n-     * @param exportFormat      Export file format of the API\n-     * @return Archive file for the requested API\n-     * @throws APIImportExportException If an error occurs while exporting the API and creating the archive\n+     * @param apiTypeWrapper    Requested API or API Product to export\n+     * @param isStatusPreserved Is API or API Product  status preserved or not\n+     * @param exportFormat      Export file format of the API or the API Product\n+     * @return Archive file for the requested API or API Product\n+     * @throws APIImportExportException If an error occurs while exporting the API or the API Product and creating the archive\n      */\n-    public File exportAPIArchive(API apiToReturn, boolean isStatusPreserved, ExportFormat exportFormat)\n+    public File exportAPIOrAPIProductArchive(ApiTypeWrapper apiTypeWrapper, boolean isStatusPreserved, ExportFormat exportFormat)\n             throws APIImportExportException {\n-\n-        APIIdentifier apiIdentifier = apiToReturn.getId();\n-        String archiveBasePath = exportAPIArtifacts(apiToReturn, isStatusPreserved, exportFormat);\n+        String archiveBasePath;\n+        if (!apiTypeWrapper.isAPIProduct()) {\n+            APIIdentifier apiIdentifier = apiTypeWrapper.getApi().getId();\n+            archiveBasePath = exportAPIArtifacts(apiTypeWrapper.getApi(), isStatusPreserved, exportFormat);\n+            log.info(\"API\" + apiIdentifier.getApiName() + \"-\" + apiIdentifier.getVersion() + \" exported successfully\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8588ed8e9529f4edd394272935b29aa22bf5cca7"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcwMDY1NQ==", "bodyText": "Sure will change it here and in line 83 as well.", "url": "https://github.com/wso2/carbon-apimgt/pull/8500#discussion_r428700655", "createdAt": "2020-05-21T14:50:29Z", "author": {"login": "wasuradananjith"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/importexport/APIImportExportManager.java", "diffHunk": "@@ -59,19 +64,25 @@ public APIProvider getApiProvider() {\n     /**\n      * This method is used to export the given API as an archive (zip file).\n      *\n-     * @param apiToReturn       Requested API to export\n-     * @param isStatusPreserved Is API status preserved or not\n-     * @param exportFormat      Export file format of the API\n-     * @return Archive file for the requested API\n-     * @throws APIImportExportException If an error occurs while exporting the API and creating the archive\n+     * @param apiTypeWrapper    Requested API or API Product to export\n+     * @param isStatusPreserved Is API or API Product  status preserved or not\n+     * @param exportFormat      Export file format of the API or the API Product\n+     * @return Archive file for the requested API or API Product\n+     * @throws APIImportExportException If an error occurs while exporting the API or the API Product and creating the archive\n      */\n-    public File exportAPIArchive(API apiToReturn, boolean isStatusPreserved, ExportFormat exportFormat)\n+    public File exportAPIOrAPIProductArchive(ApiTypeWrapper apiTypeWrapper, boolean isStatusPreserved, ExportFormat exportFormat)\n             throws APIImportExportException {\n-\n-        APIIdentifier apiIdentifier = apiToReturn.getId();\n-        String archiveBasePath = exportAPIArtifacts(apiToReturn, isStatusPreserved, exportFormat);\n+        String archiveBasePath;\n+        if (!apiTypeWrapper.isAPIProduct()) {\n+            APIIdentifier apiIdentifier = apiTypeWrapper.getApi().getId();\n+            archiveBasePath = exportAPIArtifacts(apiTypeWrapper.getApi(), isStatusPreserved, exportFormat);\n+            log.info(\"API\" + apiIdentifier.getApiName() + \"-\" + apiIdentifier.getVersion() + \" exported successfully\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY2NTg0Mw=="}, "originalCommit": {"oid": "8588ed8e9529f4edd394272935b29aa22bf5cca7"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2OTc2NTA5OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/importexport/utils/APIAndAPIProductCommonUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNDowMjozNlrOGYz_4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNDo1MTo1OVrOGY15BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY3MDk0Nw==", "bodyText": "Can we move this to Line no:183?\nString localFilePath = localDocDirectoryPath + File.separator + localFileName;", "url": "https://github.com/wso2/carbon-apimgt/pull/8500#discussion_r428670947", "createdAt": "2020-05-21T14:02:36Z", "author": {"login": "malinthaprasan"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/importexport/utils/APIAndAPIProductCommonUtil.java", "diffHunk": "@@ -0,0 +1,650 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.apimgt.impl.importexport.utils;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonParser;\n+import com.google.gson.reflect.TypeToken;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.APIProvider;\n+import org.wso2.carbon.apimgt.api.FaultGatewaysException;\n+import org.wso2.carbon.apimgt.api.dto.ClientCertificateDTO;\n+import org.wso2.carbon.apimgt.api.model.ApiTypeWrapper;\n+import org.wso2.carbon.apimgt.api.model.Documentation;\n+import org.wso2.carbon.apimgt.api.model.Identifier;\n+import org.wso2.carbon.apimgt.api.model.ResourceFile;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportException;\n+import org.wso2.carbon.apimgt.impl.importexport.ExportFormat;\n+import org.wso2.carbon.apimgt.impl.importexport.lifecycle.LifeCycle;\n+import org.wso2.carbon.apimgt.impl.importexport.lifecycle.LifeCycleTransition;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.base.MultitenantConstants;\n+import org.wso2.carbon.registry.api.Registry;\n+import org.wso2.carbon.registry.api.RegistryException;\n+import org.wso2.carbon.registry.api.Resource;\n+import org.wso2.carbon.registry.core.RegistryConstants;\n+import org.xml.sax.SAXException;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+/**\n+ * This is the util class which consists of all the functions for exporting API Product.\n+ */\n+public class APIAndAPIProductCommonUtil {\n+\n+    private static final Log log = LogFactory.getLog(APIAndAPIProductCommonUtil.class);\n+\n+    private APIAndAPIProductCommonUtil() {\n+    }\n+\n+    /**\n+     * Retrieve thumbnail image for the exporting API or API Product and store it in the archive directory.\n+     *\n+     * @param identifier                ID of the requesting API or API Product\n+     * @param registry                  Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void exportAPIOrAPIProductThumbnail(String archivePath, Identifier identifier, Registry registry)\n+            throws APIImportExportException {\n+        String thumbnailUrl = APIConstants.API_IMAGE_LOCATION + RegistryConstants.PATH_SEPARATOR\n+                + identifier.getProviderName() + RegistryConstants.PATH_SEPARATOR + identifier.getName()\n+                + RegistryConstants.PATH_SEPARATOR + identifier.getVersion() + RegistryConstants.PATH_SEPARATOR\n+                + APIConstants.API_ICON_IMAGE;\n+        String localImagePath = archivePath + File.separator + APIImportExportConstants.IMAGE_RESOURCE;\n+        try {\n+            if (registry.resourceExists(thumbnailUrl)) {\n+                Resource icon = registry.get(thumbnailUrl);\n+                String mediaType = icon.getMediaType();\n+                String extension = APIImportExportConstants.fileExtensionMapping.get(mediaType);\n+                if (extension != null) {\n+                    CommonUtil.createDirectory(localImagePath);\n+                    try (InputStream imageDataStream = icon.getContentStream();\n+                         OutputStream outputStream = new FileOutputStream(localImagePath + File.separator\n+                                 + APIConstants.API_ICON_IMAGE + APIConstants.DOT + extension)) {\n+                        IOUtils.copy(imageDataStream, outputStream);\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"Thumbnail image retrieved successfully for API/API Product: \" + identifier.getName()\n+                                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                                    + identifier.getVersion());\n+                        }\n+                    }\n+                } else {\n+                    //api gets imported without thumbnail\n+                    log.error(\"Unsupported media type for icon \" + mediaType + \". Skipping thumbnail export.\");\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"Thumbnail URL [\" + thumbnailUrl + \"] does not exists in registry for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion() + \". Skipping thumbnail export.\");\n+            }\n+        } catch (RegistryException e) {\n+            log.error(\"Error while retrieving API/API Product Thumbnail \" + thumbnailUrl, e);\n+        } catch (IOException e) {\n+            //Exception is ignored by logging due to the reason that Thumbnail is not essential for\n+            //an API to be recreated.\n+            log.error(\"I/O error while writing API/API Product Thumbnail: \" + thumbnailUrl + \" to file\", e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve documentation for the exporting API or API Product and store it in the archive directory.\n+     * FILE, INLINE, MARKDOWN and URL documentations are handled.\n+     *\n+     * @param identifier    ID of the requesting API or API Product\n+     * @param registry      Current tenant registry\n+     * @param docList       Documentation list of the exporting API or API Product\n+     * @param exportFormat  Format for export\n+     * @throws APIImportExportException If an error occurs while retrieving documents from the\n+     *                                  registry or storing in the archive directory\n+     */\n+    public static void exportAPIOrAPIProductDocumentation(String archivePath, List<Documentation> docList,\n+                                               Identifier identifier, Registry registry, ExportFormat exportFormat)\n+            throws APIImportExportException {\n+\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        String docDirectoryPath = File.separator + APIImportExportConstants.DOCUMENT_DIRECTORY;\n+        CommonUtil.createDirectory(archivePath + docDirectoryPath);\n+        try {\n+            for (Documentation doc : docList) {\n+                String sourceType = doc.getSourceType().name();\n+                String resourcePath = null;\n+                String localFilePath;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8588ed8e9529f4edd394272935b29aa22bf5cca7"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcwMTk1Ng==", "bodyText": "Sure", "url": "https://github.com/wso2/carbon-apimgt/pull/8500#discussion_r428701956", "createdAt": "2020-05-21T14:51:59Z", "author": {"login": "wasuradananjith"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/importexport/utils/APIAndAPIProductCommonUtil.java", "diffHunk": "@@ -0,0 +1,650 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.apimgt.impl.importexport.utils;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonParser;\n+import com.google.gson.reflect.TypeToken;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.APIProvider;\n+import org.wso2.carbon.apimgt.api.FaultGatewaysException;\n+import org.wso2.carbon.apimgt.api.dto.ClientCertificateDTO;\n+import org.wso2.carbon.apimgt.api.model.ApiTypeWrapper;\n+import org.wso2.carbon.apimgt.api.model.Documentation;\n+import org.wso2.carbon.apimgt.api.model.Identifier;\n+import org.wso2.carbon.apimgt.api.model.ResourceFile;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportException;\n+import org.wso2.carbon.apimgt.impl.importexport.ExportFormat;\n+import org.wso2.carbon.apimgt.impl.importexport.lifecycle.LifeCycle;\n+import org.wso2.carbon.apimgt.impl.importexport.lifecycle.LifeCycleTransition;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.base.MultitenantConstants;\n+import org.wso2.carbon.registry.api.Registry;\n+import org.wso2.carbon.registry.api.RegistryException;\n+import org.wso2.carbon.registry.api.Resource;\n+import org.wso2.carbon.registry.core.RegistryConstants;\n+import org.xml.sax.SAXException;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+/**\n+ * This is the util class which consists of all the functions for exporting API Product.\n+ */\n+public class APIAndAPIProductCommonUtil {\n+\n+    private static final Log log = LogFactory.getLog(APIAndAPIProductCommonUtil.class);\n+\n+    private APIAndAPIProductCommonUtil() {\n+    }\n+\n+    /**\n+     * Retrieve thumbnail image for the exporting API or API Product and store it in the archive directory.\n+     *\n+     * @param identifier                ID of the requesting API or API Product\n+     * @param registry                  Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void exportAPIOrAPIProductThumbnail(String archivePath, Identifier identifier, Registry registry)\n+            throws APIImportExportException {\n+        String thumbnailUrl = APIConstants.API_IMAGE_LOCATION + RegistryConstants.PATH_SEPARATOR\n+                + identifier.getProviderName() + RegistryConstants.PATH_SEPARATOR + identifier.getName()\n+                + RegistryConstants.PATH_SEPARATOR + identifier.getVersion() + RegistryConstants.PATH_SEPARATOR\n+                + APIConstants.API_ICON_IMAGE;\n+        String localImagePath = archivePath + File.separator + APIImportExportConstants.IMAGE_RESOURCE;\n+        try {\n+            if (registry.resourceExists(thumbnailUrl)) {\n+                Resource icon = registry.get(thumbnailUrl);\n+                String mediaType = icon.getMediaType();\n+                String extension = APIImportExportConstants.fileExtensionMapping.get(mediaType);\n+                if (extension != null) {\n+                    CommonUtil.createDirectory(localImagePath);\n+                    try (InputStream imageDataStream = icon.getContentStream();\n+                         OutputStream outputStream = new FileOutputStream(localImagePath + File.separator\n+                                 + APIConstants.API_ICON_IMAGE + APIConstants.DOT + extension)) {\n+                        IOUtils.copy(imageDataStream, outputStream);\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"Thumbnail image retrieved successfully for API/API Product: \" + identifier.getName()\n+                                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                                    + identifier.getVersion());\n+                        }\n+                    }\n+                } else {\n+                    //api gets imported without thumbnail\n+                    log.error(\"Unsupported media type for icon \" + mediaType + \". Skipping thumbnail export.\");\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"Thumbnail URL [\" + thumbnailUrl + \"] does not exists in registry for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion() + \". Skipping thumbnail export.\");\n+            }\n+        } catch (RegistryException e) {\n+            log.error(\"Error while retrieving API/API Product Thumbnail \" + thumbnailUrl, e);\n+        } catch (IOException e) {\n+            //Exception is ignored by logging due to the reason that Thumbnail is not essential for\n+            //an API to be recreated.\n+            log.error(\"I/O error while writing API/API Product Thumbnail: \" + thumbnailUrl + \" to file\", e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve documentation for the exporting API or API Product and store it in the archive directory.\n+     * FILE, INLINE, MARKDOWN and URL documentations are handled.\n+     *\n+     * @param identifier    ID of the requesting API or API Product\n+     * @param registry      Current tenant registry\n+     * @param docList       Documentation list of the exporting API or API Product\n+     * @param exportFormat  Format for export\n+     * @throws APIImportExportException If an error occurs while retrieving documents from the\n+     *                                  registry or storing in the archive directory\n+     */\n+    public static void exportAPIOrAPIProductDocumentation(String archivePath, List<Documentation> docList,\n+                                               Identifier identifier, Registry registry, ExportFormat exportFormat)\n+            throws APIImportExportException {\n+\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        String docDirectoryPath = File.separator + APIImportExportConstants.DOCUMENT_DIRECTORY;\n+        CommonUtil.createDirectory(archivePath + docDirectoryPath);\n+        try {\n+            for (Documentation doc : docList) {\n+                String sourceType = doc.getSourceType().name();\n+                String resourcePath = null;\n+                String localFilePath;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY3MDk0Nw=="}, "originalCommit": {"oid": "8588ed8e9529f4edd394272935b29aa22bf5cca7"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2OTc3NDA1OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/importexport/utils/APIAndAPIProductCommonUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNDowNTowOFrOGY0Fmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNDo1ODozNFrOGY2QZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY3MjQxMA==", "bodyText": "docDirectoryPath is not used further. So do we need a new variable? Can we reuse docDirectoryPath?", "url": "https://github.com/wso2/carbon-apimgt/pull/8500#discussion_r428672410", "createdAt": "2020-05-21T14:05:08Z", "author": {"login": "malinthaprasan"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/importexport/utils/APIAndAPIProductCommonUtil.java", "diffHunk": "@@ -0,0 +1,650 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.apimgt.impl.importexport.utils;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonParser;\n+import com.google.gson.reflect.TypeToken;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.APIProvider;\n+import org.wso2.carbon.apimgt.api.FaultGatewaysException;\n+import org.wso2.carbon.apimgt.api.dto.ClientCertificateDTO;\n+import org.wso2.carbon.apimgt.api.model.ApiTypeWrapper;\n+import org.wso2.carbon.apimgt.api.model.Documentation;\n+import org.wso2.carbon.apimgt.api.model.Identifier;\n+import org.wso2.carbon.apimgt.api.model.ResourceFile;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportException;\n+import org.wso2.carbon.apimgt.impl.importexport.ExportFormat;\n+import org.wso2.carbon.apimgt.impl.importexport.lifecycle.LifeCycle;\n+import org.wso2.carbon.apimgt.impl.importexport.lifecycle.LifeCycleTransition;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.base.MultitenantConstants;\n+import org.wso2.carbon.registry.api.Registry;\n+import org.wso2.carbon.registry.api.RegistryException;\n+import org.wso2.carbon.registry.api.Resource;\n+import org.wso2.carbon.registry.core.RegistryConstants;\n+import org.xml.sax.SAXException;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+/**\n+ * This is the util class which consists of all the functions for exporting API Product.\n+ */\n+public class APIAndAPIProductCommonUtil {\n+\n+    private static final Log log = LogFactory.getLog(APIAndAPIProductCommonUtil.class);\n+\n+    private APIAndAPIProductCommonUtil() {\n+    }\n+\n+    /**\n+     * Retrieve thumbnail image for the exporting API or API Product and store it in the archive directory.\n+     *\n+     * @param identifier                ID of the requesting API or API Product\n+     * @param registry                  Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void exportAPIOrAPIProductThumbnail(String archivePath, Identifier identifier, Registry registry)\n+            throws APIImportExportException {\n+        String thumbnailUrl = APIConstants.API_IMAGE_LOCATION + RegistryConstants.PATH_SEPARATOR\n+                + identifier.getProviderName() + RegistryConstants.PATH_SEPARATOR + identifier.getName()\n+                + RegistryConstants.PATH_SEPARATOR + identifier.getVersion() + RegistryConstants.PATH_SEPARATOR\n+                + APIConstants.API_ICON_IMAGE;\n+        String localImagePath = archivePath + File.separator + APIImportExportConstants.IMAGE_RESOURCE;\n+        try {\n+            if (registry.resourceExists(thumbnailUrl)) {\n+                Resource icon = registry.get(thumbnailUrl);\n+                String mediaType = icon.getMediaType();\n+                String extension = APIImportExportConstants.fileExtensionMapping.get(mediaType);\n+                if (extension != null) {\n+                    CommonUtil.createDirectory(localImagePath);\n+                    try (InputStream imageDataStream = icon.getContentStream();\n+                         OutputStream outputStream = new FileOutputStream(localImagePath + File.separator\n+                                 + APIConstants.API_ICON_IMAGE + APIConstants.DOT + extension)) {\n+                        IOUtils.copy(imageDataStream, outputStream);\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"Thumbnail image retrieved successfully for API/API Product: \" + identifier.getName()\n+                                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                                    + identifier.getVersion());\n+                        }\n+                    }\n+                } else {\n+                    //api gets imported without thumbnail\n+                    log.error(\"Unsupported media type for icon \" + mediaType + \". Skipping thumbnail export.\");\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"Thumbnail URL [\" + thumbnailUrl + \"] does not exists in registry for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion() + \". Skipping thumbnail export.\");\n+            }\n+        } catch (RegistryException e) {\n+            log.error(\"Error while retrieving API/API Product Thumbnail \" + thumbnailUrl, e);\n+        } catch (IOException e) {\n+            //Exception is ignored by logging due to the reason that Thumbnail is not essential for\n+            //an API to be recreated.\n+            log.error(\"I/O error while writing API/API Product Thumbnail: \" + thumbnailUrl + \" to file\", e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve documentation for the exporting API or API Product and store it in the archive directory.\n+     * FILE, INLINE, MARKDOWN and URL documentations are handled.\n+     *\n+     * @param identifier    ID of the requesting API or API Product\n+     * @param registry      Current tenant registry\n+     * @param docList       Documentation list of the exporting API or API Product\n+     * @param exportFormat  Format for export\n+     * @throws APIImportExportException If an error occurs while retrieving documents from the\n+     *                                  registry or storing in the archive directory\n+     */\n+    public static void exportAPIOrAPIProductDocumentation(String archivePath, List<Documentation> docList,\n+                                               Identifier identifier, Registry registry, ExportFormat exportFormat)\n+            throws APIImportExportException {\n+\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        String docDirectoryPath = File.separator + APIImportExportConstants.DOCUMENT_DIRECTORY;\n+        CommonUtil.createDirectory(archivePath + docDirectoryPath);\n+        try {\n+            for (Documentation doc : docList) {\n+                String sourceType = doc.getSourceType().name();\n+                String resourcePath = null;\n+                String localFilePath;\n+                String localFileName = null;\n+                String localDocDirectoryPath = docDirectoryPath;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8588ed8e9529f4edd394272935b29aa22bf5cca7"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcwNzk0MA==", "bodyText": "Yes we can resue it. Thanks for pointing it out.", "url": "https://github.com/wso2/carbon-apimgt/pull/8500#discussion_r428707940", "createdAt": "2020-05-21T14:58:34Z", "author": {"login": "wasuradananjith"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/importexport/utils/APIAndAPIProductCommonUtil.java", "diffHunk": "@@ -0,0 +1,650 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.apimgt.impl.importexport.utils;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonParser;\n+import com.google.gson.reflect.TypeToken;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.APIProvider;\n+import org.wso2.carbon.apimgt.api.FaultGatewaysException;\n+import org.wso2.carbon.apimgt.api.dto.ClientCertificateDTO;\n+import org.wso2.carbon.apimgt.api.model.ApiTypeWrapper;\n+import org.wso2.carbon.apimgt.api.model.Documentation;\n+import org.wso2.carbon.apimgt.api.model.Identifier;\n+import org.wso2.carbon.apimgt.api.model.ResourceFile;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportException;\n+import org.wso2.carbon.apimgt.impl.importexport.ExportFormat;\n+import org.wso2.carbon.apimgt.impl.importexport.lifecycle.LifeCycle;\n+import org.wso2.carbon.apimgt.impl.importexport.lifecycle.LifeCycleTransition;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.base.MultitenantConstants;\n+import org.wso2.carbon.registry.api.Registry;\n+import org.wso2.carbon.registry.api.RegistryException;\n+import org.wso2.carbon.registry.api.Resource;\n+import org.wso2.carbon.registry.core.RegistryConstants;\n+import org.xml.sax.SAXException;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+/**\n+ * This is the util class which consists of all the functions for exporting API Product.\n+ */\n+public class APIAndAPIProductCommonUtil {\n+\n+    private static final Log log = LogFactory.getLog(APIAndAPIProductCommonUtil.class);\n+\n+    private APIAndAPIProductCommonUtil() {\n+    }\n+\n+    /**\n+     * Retrieve thumbnail image for the exporting API or API Product and store it in the archive directory.\n+     *\n+     * @param identifier                ID of the requesting API or API Product\n+     * @param registry                  Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void exportAPIOrAPIProductThumbnail(String archivePath, Identifier identifier, Registry registry)\n+            throws APIImportExportException {\n+        String thumbnailUrl = APIConstants.API_IMAGE_LOCATION + RegistryConstants.PATH_SEPARATOR\n+                + identifier.getProviderName() + RegistryConstants.PATH_SEPARATOR + identifier.getName()\n+                + RegistryConstants.PATH_SEPARATOR + identifier.getVersion() + RegistryConstants.PATH_SEPARATOR\n+                + APIConstants.API_ICON_IMAGE;\n+        String localImagePath = archivePath + File.separator + APIImportExportConstants.IMAGE_RESOURCE;\n+        try {\n+            if (registry.resourceExists(thumbnailUrl)) {\n+                Resource icon = registry.get(thumbnailUrl);\n+                String mediaType = icon.getMediaType();\n+                String extension = APIImportExportConstants.fileExtensionMapping.get(mediaType);\n+                if (extension != null) {\n+                    CommonUtil.createDirectory(localImagePath);\n+                    try (InputStream imageDataStream = icon.getContentStream();\n+                         OutputStream outputStream = new FileOutputStream(localImagePath + File.separator\n+                                 + APIConstants.API_ICON_IMAGE + APIConstants.DOT + extension)) {\n+                        IOUtils.copy(imageDataStream, outputStream);\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"Thumbnail image retrieved successfully for API/API Product: \" + identifier.getName()\n+                                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                                    + identifier.getVersion());\n+                        }\n+                    }\n+                } else {\n+                    //api gets imported without thumbnail\n+                    log.error(\"Unsupported media type for icon \" + mediaType + \". Skipping thumbnail export.\");\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"Thumbnail URL [\" + thumbnailUrl + \"] does not exists in registry for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion() + \". Skipping thumbnail export.\");\n+            }\n+        } catch (RegistryException e) {\n+            log.error(\"Error while retrieving API/API Product Thumbnail \" + thumbnailUrl, e);\n+        } catch (IOException e) {\n+            //Exception is ignored by logging due to the reason that Thumbnail is not essential for\n+            //an API to be recreated.\n+            log.error(\"I/O error while writing API/API Product Thumbnail: \" + thumbnailUrl + \" to file\", e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve documentation for the exporting API or API Product and store it in the archive directory.\n+     * FILE, INLINE, MARKDOWN and URL documentations are handled.\n+     *\n+     * @param identifier    ID of the requesting API or API Product\n+     * @param registry      Current tenant registry\n+     * @param docList       Documentation list of the exporting API or API Product\n+     * @param exportFormat  Format for export\n+     * @throws APIImportExportException If an error occurs while retrieving documents from the\n+     *                                  registry or storing in the archive directory\n+     */\n+    public static void exportAPIOrAPIProductDocumentation(String archivePath, List<Documentation> docList,\n+                                               Identifier identifier, Registry registry, ExportFormat exportFormat)\n+            throws APIImportExportException {\n+\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        String docDirectoryPath = File.separator + APIImportExportConstants.DOCUMENT_DIRECTORY;\n+        CommonUtil.createDirectory(archivePath + docDirectoryPath);\n+        try {\n+            for (Documentation doc : docList) {\n+                String sourceType = doc.getSourceType().name();\n+                String resourcePath = null;\n+                String localFilePath;\n+                String localFileName = null;\n+                String localDocDirectoryPath = docDirectoryPath;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY3MjQxMA=="}, "originalCommit": {"oid": "8588ed8e9529f4edd394272935b29aa22bf5cca7"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2OTc5NzQ1OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/importexport/utils/APIAndAPIProductCommonUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNDoxMToyOVrOGY0UjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNDo1OTowMFrOGY2R3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY3NjIzNg==", "bodyText": "Remove \"!\" and swap the blocks. Saw couple of other places shall we fix them too", "url": "https://github.com/wso2/carbon-apimgt/pull/8500#discussion_r428676236", "createdAt": "2020-05-21T14:11:29Z", "author": {"login": "malinthaprasan"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/importexport/utils/APIAndAPIProductCommonUtil.java", "diffHunk": "@@ -0,0 +1,650 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.apimgt.impl.importexport.utils;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonParser;\n+import com.google.gson.reflect.TypeToken;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.APIProvider;\n+import org.wso2.carbon.apimgt.api.FaultGatewaysException;\n+import org.wso2.carbon.apimgt.api.dto.ClientCertificateDTO;\n+import org.wso2.carbon.apimgt.api.model.ApiTypeWrapper;\n+import org.wso2.carbon.apimgt.api.model.Documentation;\n+import org.wso2.carbon.apimgt.api.model.Identifier;\n+import org.wso2.carbon.apimgt.api.model.ResourceFile;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportException;\n+import org.wso2.carbon.apimgt.impl.importexport.ExportFormat;\n+import org.wso2.carbon.apimgt.impl.importexport.lifecycle.LifeCycle;\n+import org.wso2.carbon.apimgt.impl.importexport.lifecycle.LifeCycleTransition;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.base.MultitenantConstants;\n+import org.wso2.carbon.registry.api.Registry;\n+import org.wso2.carbon.registry.api.RegistryException;\n+import org.wso2.carbon.registry.api.Resource;\n+import org.wso2.carbon.registry.core.RegistryConstants;\n+import org.xml.sax.SAXException;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+/**\n+ * This is the util class which consists of all the functions for exporting API Product.\n+ */\n+public class APIAndAPIProductCommonUtil {\n+\n+    private static final Log log = LogFactory.getLog(APIAndAPIProductCommonUtil.class);\n+\n+    private APIAndAPIProductCommonUtil() {\n+    }\n+\n+    /**\n+     * Retrieve thumbnail image for the exporting API or API Product and store it in the archive directory.\n+     *\n+     * @param identifier                ID of the requesting API or API Product\n+     * @param registry                  Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void exportAPIOrAPIProductThumbnail(String archivePath, Identifier identifier, Registry registry)\n+            throws APIImportExportException {\n+        String thumbnailUrl = APIConstants.API_IMAGE_LOCATION + RegistryConstants.PATH_SEPARATOR\n+                + identifier.getProviderName() + RegistryConstants.PATH_SEPARATOR + identifier.getName()\n+                + RegistryConstants.PATH_SEPARATOR + identifier.getVersion() + RegistryConstants.PATH_SEPARATOR\n+                + APIConstants.API_ICON_IMAGE;\n+        String localImagePath = archivePath + File.separator + APIImportExportConstants.IMAGE_RESOURCE;\n+        try {\n+            if (registry.resourceExists(thumbnailUrl)) {\n+                Resource icon = registry.get(thumbnailUrl);\n+                String mediaType = icon.getMediaType();\n+                String extension = APIImportExportConstants.fileExtensionMapping.get(mediaType);\n+                if (extension != null) {\n+                    CommonUtil.createDirectory(localImagePath);\n+                    try (InputStream imageDataStream = icon.getContentStream();\n+                         OutputStream outputStream = new FileOutputStream(localImagePath + File.separator\n+                                 + APIConstants.API_ICON_IMAGE + APIConstants.DOT + extension)) {\n+                        IOUtils.copy(imageDataStream, outputStream);\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"Thumbnail image retrieved successfully for API/API Product: \" + identifier.getName()\n+                                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                                    + identifier.getVersion());\n+                        }\n+                    }\n+                } else {\n+                    //api gets imported without thumbnail\n+                    log.error(\"Unsupported media type for icon \" + mediaType + \". Skipping thumbnail export.\");\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"Thumbnail URL [\" + thumbnailUrl + \"] does not exists in registry for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion() + \". Skipping thumbnail export.\");\n+            }\n+        } catch (RegistryException e) {\n+            log.error(\"Error while retrieving API/API Product Thumbnail \" + thumbnailUrl, e);\n+        } catch (IOException e) {\n+            //Exception is ignored by logging due to the reason that Thumbnail is not essential for\n+            //an API to be recreated.\n+            log.error(\"I/O error while writing API/API Product Thumbnail: \" + thumbnailUrl + \" to file\", e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve documentation for the exporting API or API Product and store it in the archive directory.\n+     * FILE, INLINE, MARKDOWN and URL documentations are handled.\n+     *\n+     * @param identifier    ID of the requesting API or API Product\n+     * @param registry      Current tenant registry\n+     * @param docList       Documentation list of the exporting API or API Product\n+     * @param exportFormat  Format for export\n+     * @throws APIImportExportException If an error occurs while retrieving documents from the\n+     *                                  registry or storing in the archive directory\n+     */\n+    public static void exportAPIOrAPIProductDocumentation(String archivePath, List<Documentation> docList,\n+                                               Identifier identifier, Registry registry, ExportFormat exportFormat)\n+            throws APIImportExportException {\n+\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        String docDirectoryPath = File.separator + APIImportExportConstants.DOCUMENT_DIRECTORY;\n+        CommonUtil.createDirectory(archivePath + docDirectoryPath);\n+        try {\n+            for (Documentation doc : docList) {\n+                String sourceType = doc.getSourceType().name();\n+                String resourcePath = null;\n+                String localFilePath;\n+                String localFileName = null;\n+                String localDocDirectoryPath = docDirectoryPath;\n+                if (Documentation.DocumentSourceType.FILE.toString().equalsIgnoreCase(sourceType)) {\n+                    localFileName = doc.getFilePath().substring(\n+                            doc.getFilePath().lastIndexOf(RegistryConstants.PATH_SEPARATOR) + 1);\n+                    resourcePath = APIUtil.getDocumentationFilePath(identifier, localFileName);\n+                    localDocDirectoryPath += File.separator + APIImportExportConstants.FILE_DOCUMENT_DIRECTORY;\n+                    doc.setFilePath(localFileName);\n+                } else if (Documentation.DocumentSourceType.INLINE.toString().equalsIgnoreCase(sourceType)\n+                        || Documentation.DocumentSourceType.MARKDOWN.toString().equalsIgnoreCase(sourceType)) {\n+                    //Inline/Markdown content file name would be same as the documentation name\n+                    //Markdown content files will also be stored in InlineContents directory\n+                    localFileName = doc.getName();\n+                    resourcePath = APIUtil.getAPIOrAPIProductDocPath(identifier) + APIConstants.INLINE_DOCUMENT_CONTENT_DIR\n+                            + RegistryConstants.PATH_SEPARATOR + localFileName;\n+                    localDocDirectoryPath += File.separator + APIImportExportConstants.INLINE_DOCUMENT_DIRECTORY;\n+                }\n+\n+                if (resourcePath != null) {\n+                    //Write content separately for Inline/Markdown/File type documentations only\n+                    //check whether resource exists in the registry\n+                    if (registry.resourceExists(resourcePath)) {\n+                        CommonUtil.createDirectory(archivePath + localDocDirectoryPath);\n+                        localFilePath = localDocDirectoryPath + File.separator + localFileName;\n+                        Resource docFile = registry.get(resourcePath);\n+                        try (OutputStream outputStream = new FileOutputStream(archivePath + localFilePath);\n+                             InputStream fileInputStream = docFile.getContentStream()) {\n+                            IOUtils.copy(fileInputStream, outputStream);\n+                        }\n+                    } else {\n+                        //Log error and avoid throwing as we give capability to export document artifact without the\n+                        //content if does not exists\n+                        String errorMessage = \"Documentation resource for API/API Product: \" + identifier.getName()\n+                                + \" not found in \" + resourcePath;\n+                        log.error(errorMessage);\n+                    }\n+                }\n+            }\n+\n+            String json = gson.toJson(docList);\n+            switch (exportFormat) {\n+                case JSON:\n+                    CommonUtil.writeFile(archivePath + APIImportExportConstants.JSON_DOCUMENT_FILE_LOCATION, json);\n+                    break;\n+                case YAML:\n+                    String yaml = CommonUtil.jsonToYaml(json);\n+                    CommonUtil.writeFile(archivePath + APIImportExportConstants.YAML_DOCUMENT_FILE_LOCATION, yaml);\n+                    break;\n+            }\n+\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Documentation retrieved successfully for API/API Product: \" + identifier.getName()\n+                        + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + identifier.getVersion());\n+            }\n+        } catch (IOException e) {\n+            String errorMessage = \"I/O error while writing documentation to file for API/API Product: \"\n+                    + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                    + identifier.getVersion();\n+            log.error(errorMessage, e);\n+            throw new APIImportExportException(errorMessage, e);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while retrieving documentation for API/API Product: \" + identifier.getName()\n+                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + identifier.getVersion();\n+            log.error(errorMessage, e);\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+    }\n+    /**\n+     * Retrieve API Definition as JSON.\n+     *\n+     * @param pathToArchive Path to API or API Product archive\n+     * @throws IOException If an error occurs while reading the file\n+     */\n+    public static String getAPIDefinitionAsJson(String pathToArchive) throws IOException {\n+        String jsonContent = null;\n+        String pathToYamlFile = pathToArchive + APIImportExportConstants.YAML_API_FILE_LOCATION;\n+        String pathToJsonFile = pathToArchive + APIImportExportConstants.JSON_API_FILE_LOCATION;\n+\n+        // load yaml representation first if it is present\n+        if (CommonUtil.checkFileExistence(pathToYamlFile)) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Found api definition file \" + pathToYamlFile);\n+            }\n+            String yamlContent = FileUtils.readFileToString(new File(pathToYamlFile));\n+            jsonContent = CommonUtil.yamlToJson(yamlContent);\n+        } else if (CommonUtil.checkFileExistence(pathToJsonFile)) {\n+            // load as a json fallback\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Found api definition file \" + pathToJsonFile);\n+            }\n+            jsonContent = FileUtils.readFileToString(new File(pathToJsonFile));\n+        }\n+        return jsonContent;\n+    }\n+\n+    /**\n+     * Export Mutual SSL related certificates\n+     *\n+     * @param apiTypeWrapper    API or API Product to be exported\n+     * @param tenantId          Tenant id of the user\n+     * @param provider          Api Provider\n+     * @param exportFormat      Export format of file\n+     * @throws APIImportExportException\n+     */\n+    public static void exportClientCertificates(String archivePath, ApiTypeWrapper apiTypeWrapper, int tenantId, APIProvider provider,\n+                                                 ExportFormat exportFormat) throws APIImportExportException {\n+\n+        List<ClientCertificateDTO> certificateMetadataDTOS;\n+        try {\n+            if (!apiTypeWrapper.isAPIProduct()) {\n+                certificateMetadataDTOS = provider.searchClientCertificates(tenantId, null, apiTypeWrapper.getApi().getId());\n+            } else {\n+                certificateMetadataDTOS = provider.searchClientCertificates(tenantId, null, apiTypeWrapper.getApiProduct().getId());\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8588ed8e9529f4edd394272935b29aa22bf5cca7"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcwODMxOQ==", "bodyText": "Sure, will swap where applicable.", "url": "https://github.com/wso2/carbon-apimgt/pull/8500#discussion_r428708319", "createdAt": "2020-05-21T14:59:00Z", "author": {"login": "wasuradananjith"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/importexport/utils/APIAndAPIProductCommonUtil.java", "diffHunk": "@@ -0,0 +1,650 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.apimgt.impl.importexport.utils;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonParser;\n+import com.google.gson.reflect.TypeToken;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.APIProvider;\n+import org.wso2.carbon.apimgt.api.FaultGatewaysException;\n+import org.wso2.carbon.apimgt.api.dto.ClientCertificateDTO;\n+import org.wso2.carbon.apimgt.api.model.ApiTypeWrapper;\n+import org.wso2.carbon.apimgt.api.model.Documentation;\n+import org.wso2.carbon.apimgt.api.model.Identifier;\n+import org.wso2.carbon.apimgt.api.model.ResourceFile;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportException;\n+import org.wso2.carbon.apimgt.impl.importexport.ExportFormat;\n+import org.wso2.carbon.apimgt.impl.importexport.lifecycle.LifeCycle;\n+import org.wso2.carbon.apimgt.impl.importexport.lifecycle.LifeCycleTransition;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.base.MultitenantConstants;\n+import org.wso2.carbon.registry.api.Registry;\n+import org.wso2.carbon.registry.api.RegistryException;\n+import org.wso2.carbon.registry.api.Resource;\n+import org.wso2.carbon.registry.core.RegistryConstants;\n+import org.xml.sax.SAXException;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+/**\n+ * This is the util class which consists of all the functions for exporting API Product.\n+ */\n+public class APIAndAPIProductCommonUtil {\n+\n+    private static final Log log = LogFactory.getLog(APIAndAPIProductCommonUtil.class);\n+\n+    private APIAndAPIProductCommonUtil() {\n+    }\n+\n+    /**\n+     * Retrieve thumbnail image for the exporting API or API Product and store it in the archive directory.\n+     *\n+     * @param identifier                ID of the requesting API or API Product\n+     * @param registry                  Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void exportAPIOrAPIProductThumbnail(String archivePath, Identifier identifier, Registry registry)\n+            throws APIImportExportException {\n+        String thumbnailUrl = APIConstants.API_IMAGE_LOCATION + RegistryConstants.PATH_SEPARATOR\n+                + identifier.getProviderName() + RegistryConstants.PATH_SEPARATOR + identifier.getName()\n+                + RegistryConstants.PATH_SEPARATOR + identifier.getVersion() + RegistryConstants.PATH_SEPARATOR\n+                + APIConstants.API_ICON_IMAGE;\n+        String localImagePath = archivePath + File.separator + APIImportExportConstants.IMAGE_RESOURCE;\n+        try {\n+            if (registry.resourceExists(thumbnailUrl)) {\n+                Resource icon = registry.get(thumbnailUrl);\n+                String mediaType = icon.getMediaType();\n+                String extension = APIImportExportConstants.fileExtensionMapping.get(mediaType);\n+                if (extension != null) {\n+                    CommonUtil.createDirectory(localImagePath);\n+                    try (InputStream imageDataStream = icon.getContentStream();\n+                         OutputStream outputStream = new FileOutputStream(localImagePath + File.separator\n+                                 + APIConstants.API_ICON_IMAGE + APIConstants.DOT + extension)) {\n+                        IOUtils.copy(imageDataStream, outputStream);\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"Thumbnail image retrieved successfully for API/API Product: \" + identifier.getName()\n+                                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                                    + identifier.getVersion());\n+                        }\n+                    }\n+                } else {\n+                    //api gets imported without thumbnail\n+                    log.error(\"Unsupported media type for icon \" + mediaType + \". Skipping thumbnail export.\");\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"Thumbnail URL [\" + thumbnailUrl + \"] does not exists in registry for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion() + \". Skipping thumbnail export.\");\n+            }\n+        } catch (RegistryException e) {\n+            log.error(\"Error while retrieving API/API Product Thumbnail \" + thumbnailUrl, e);\n+        } catch (IOException e) {\n+            //Exception is ignored by logging due to the reason that Thumbnail is not essential for\n+            //an API to be recreated.\n+            log.error(\"I/O error while writing API/API Product Thumbnail: \" + thumbnailUrl + \" to file\", e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve documentation for the exporting API or API Product and store it in the archive directory.\n+     * FILE, INLINE, MARKDOWN and URL documentations are handled.\n+     *\n+     * @param identifier    ID of the requesting API or API Product\n+     * @param registry      Current tenant registry\n+     * @param docList       Documentation list of the exporting API or API Product\n+     * @param exportFormat  Format for export\n+     * @throws APIImportExportException If an error occurs while retrieving documents from the\n+     *                                  registry or storing in the archive directory\n+     */\n+    public static void exportAPIOrAPIProductDocumentation(String archivePath, List<Documentation> docList,\n+                                               Identifier identifier, Registry registry, ExportFormat exportFormat)\n+            throws APIImportExportException {\n+\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        String docDirectoryPath = File.separator + APIImportExportConstants.DOCUMENT_DIRECTORY;\n+        CommonUtil.createDirectory(archivePath + docDirectoryPath);\n+        try {\n+            for (Documentation doc : docList) {\n+                String sourceType = doc.getSourceType().name();\n+                String resourcePath = null;\n+                String localFilePath;\n+                String localFileName = null;\n+                String localDocDirectoryPath = docDirectoryPath;\n+                if (Documentation.DocumentSourceType.FILE.toString().equalsIgnoreCase(sourceType)) {\n+                    localFileName = doc.getFilePath().substring(\n+                            doc.getFilePath().lastIndexOf(RegistryConstants.PATH_SEPARATOR) + 1);\n+                    resourcePath = APIUtil.getDocumentationFilePath(identifier, localFileName);\n+                    localDocDirectoryPath += File.separator + APIImportExportConstants.FILE_DOCUMENT_DIRECTORY;\n+                    doc.setFilePath(localFileName);\n+                } else if (Documentation.DocumentSourceType.INLINE.toString().equalsIgnoreCase(sourceType)\n+                        || Documentation.DocumentSourceType.MARKDOWN.toString().equalsIgnoreCase(sourceType)) {\n+                    //Inline/Markdown content file name would be same as the documentation name\n+                    //Markdown content files will also be stored in InlineContents directory\n+                    localFileName = doc.getName();\n+                    resourcePath = APIUtil.getAPIOrAPIProductDocPath(identifier) + APIConstants.INLINE_DOCUMENT_CONTENT_DIR\n+                            + RegistryConstants.PATH_SEPARATOR + localFileName;\n+                    localDocDirectoryPath += File.separator + APIImportExportConstants.INLINE_DOCUMENT_DIRECTORY;\n+                }\n+\n+                if (resourcePath != null) {\n+                    //Write content separately for Inline/Markdown/File type documentations only\n+                    //check whether resource exists in the registry\n+                    if (registry.resourceExists(resourcePath)) {\n+                        CommonUtil.createDirectory(archivePath + localDocDirectoryPath);\n+                        localFilePath = localDocDirectoryPath + File.separator + localFileName;\n+                        Resource docFile = registry.get(resourcePath);\n+                        try (OutputStream outputStream = new FileOutputStream(archivePath + localFilePath);\n+                             InputStream fileInputStream = docFile.getContentStream()) {\n+                            IOUtils.copy(fileInputStream, outputStream);\n+                        }\n+                    } else {\n+                        //Log error and avoid throwing as we give capability to export document artifact without the\n+                        //content if does not exists\n+                        String errorMessage = \"Documentation resource for API/API Product: \" + identifier.getName()\n+                                + \" not found in \" + resourcePath;\n+                        log.error(errorMessage);\n+                    }\n+                }\n+            }\n+\n+            String json = gson.toJson(docList);\n+            switch (exportFormat) {\n+                case JSON:\n+                    CommonUtil.writeFile(archivePath + APIImportExportConstants.JSON_DOCUMENT_FILE_LOCATION, json);\n+                    break;\n+                case YAML:\n+                    String yaml = CommonUtil.jsonToYaml(json);\n+                    CommonUtil.writeFile(archivePath + APIImportExportConstants.YAML_DOCUMENT_FILE_LOCATION, yaml);\n+                    break;\n+            }\n+\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Documentation retrieved successfully for API/API Product: \" + identifier.getName()\n+                        + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + identifier.getVersion());\n+            }\n+        } catch (IOException e) {\n+            String errorMessage = \"I/O error while writing documentation to file for API/API Product: \"\n+                    + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                    + identifier.getVersion();\n+            log.error(errorMessage, e);\n+            throw new APIImportExportException(errorMessage, e);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while retrieving documentation for API/API Product: \" + identifier.getName()\n+                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + identifier.getVersion();\n+            log.error(errorMessage, e);\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+    }\n+    /**\n+     * Retrieve API Definition as JSON.\n+     *\n+     * @param pathToArchive Path to API or API Product archive\n+     * @throws IOException If an error occurs while reading the file\n+     */\n+    public static String getAPIDefinitionAsJson(String pathToArchive) throws IOException {\n+        String jsonContent = null;\n+        String pathToYamlFile = pathToArchive + APIImportExportConstants.YAML_API_FILE_LOCATION;\n+        String pathToJsonFile = pathToArchive + APIImportExportConstants.JSON_API_FILE_LOCATION;\n+\n+        // load yaml representation first if it is present\n+        if (CommonUtil.checkFileExistence(pathToYamlFile)) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Found api definition file \" + pathToYamlFile);\n+            }\n+            String yamlContent = FileUtils.readFileToString(new File(pathToYamlFile));\n+            jsonContent = CommonUtil.yamlToJson(yamlContent);\n+        } else if (CommonUtil.checkFileExistence(pathToJsonFile)) {\n+            // load as a json fallback\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Found api definition file \" + pathToJsonFile);\n+            }\n+            jsonContent = FileUtils.readFileToString(new File(pathToJsonFile));\n+        }\n+        return jsonContent;\n+    }\n+\n+    /**\n+     * Export Mutual SSL related certificates\n+     *\n+     * @param apiTypeWrapper    API or API Product to be exported\n+     * @param tenantId          Tenant id of the user\n+     * @param provider          Api Provider\n+     * @param exportFormat      Export format of file\n+     * @throws APIImportExportException\n+     */\n+    public static void exportClientCertificates(String archivePath, ApiTypeWrapper apiTypeWrapper, int tenantId, APIProvider provider,\n+                                                 ExportFormat exportFormat) throws APIImportExportException {\n+\n+        List<ClientCertificateDTO> certificateMetadataDTOS;\n+        try {\n+            if (!apiTypeWrapper.isAPIProduct()) {\n+                certificateMetadataDTOS = provider.searchClientCertificates(tenantId, null, apiTypeWrapper.getApi().getId());\n+            } else {\n+                certificateMetadataDTOS = provider.searchClientCertificates(tenantId, null, apiTypeWrapper.getApiProduct().getId());\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY3NjIzNg=="}, "originalCommit": {"oid": "8588ed8e9529f4edd394272935b29aa22bf5cca7"}, "originalPosition": 273}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2OTgwMjcyOnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/importexport/utils/APIAndAPIProductCommonUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNDoxMjo1MFrOGY0Xzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNTowMjo0NVrOGY2feA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY3NzA3MA==", "bodyText": "can change this as\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (!certificateMetadataDTOS.isEmpty()) {\n          \n          \n            \n                        if (certificateMetadataDTOS.isEmpty()) {\n          \n          \n            \n                            return;\n          \n          \n            \n                        }\n          \n          \n            \n                        <rest of the code>", "url": "https://github.com/wso2/carbon-apimgt/pull/8500#discussion_r428677070", "createdAt": "2020-05-21T14:12:50Z", "author": {"login": "malinthaprasan"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/importexport/utils/APIAndAPIProductCommonUtil.java", "diffHunk": "@@ -0,0 +1,650 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.apimgt.impl.importexport.utils;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonParser;\n+import com.google.gson.reflect.TypeToken;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.APIProvider;\n+import org.wso2.carbon.apimgt.api.FaultGatewaysException;\n+import org.wso2.carbon.apimgt.api.dto.ClientCertificateDTO;\n+import org.wso2.carbon.apimgt.api.model.ApiTypeWrapper;\n+import org.wso2.carbon.apimgt.api.model.Documentation;\n+import org.wso2.carbon.apimgt.api.model.Identifier;\n+import org.wso2.carbon.apimgt.api.model.ResourceFile;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportException;\n+import org.wso2.carbon.apimgt.impl.importexport.ExportFormat;\n+import org.wso2.carbon.apimgt.impl.importexport.lifecycle.LifeCycle;\n+import org.wso2.carbon.apimgt.impl.importexport.lifecycle.LifeCycleTransition;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.base.MultitenantConstants;\n+import org.wso2.carbon.registry.api.Registry;\n+import org.wso2.carbon.registry.api.RegistryException;\n+import org.wso2.carbon.registry.api.Resource;\n+import org.wso2.carbon.registry.core.RegistryConstants;\n+import org.xml.sax.SAXException;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+/**\n+ * This is the util class which consists of all the functions for exporting API Product.\n+ */\n+public class APIAndAPIProductCommonUtil {\n+\n+    private static final Log log = LogFactory.getLog(APIAndAPIProductCommonUtil.class);\n+\n+    private APIAndAPIProductCommonUtil() {\n+    }\n+\n+    /**\n+     * Retrieve thumbnail image for the exporting API or API Product and store it in the archive directory.\n+     *\n+     * @param identifier                ID of the requesting API or API Product\n+     * @param registry                  Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void exportAPIOrAPIProductThumbnail(String archivePath, Identifier identifier, Registry registry)\n+            throws APIImportExportException {\n+        String thumbnailUrl = APIConstants.API_IMAGE_LOCATION + RegistryConstants.PATH_SEPARATOR\n+                + identifier.getProviderName() + RegistryConstants.PATH_SEPARATOR + identifier.getName()\n+                + RegistryConstants.PATH_SEPARATOR + identifier.getVersion() + RegistryConstants.PATH_SEPARATOR\n+                + APIConstants.API_ICON_IMAGE;\n+        String localImagePath = archivePath + File.separator + APIImportExportConstants.IMAGE_RESOURCE;\n+        try {\n+            if (registry.resourceExists(thumbnailUrl)) {\n+                Resource icon = registry.get(thumbnailUrl);\n+                String mediaType = icon.getMediaType();\n+                String extension = APIImportExportConstants.fileExtensionMapping.get(mediaType);\n+                if (extension != null) {\n+                    CommonUtil.createDirectory(localImagePath);\n+                    try (InputStream imageDataStream = icon.getContentStream();\n+                         OutputStream outputStream = new FileOutputStream(localImagePath + File.separator\n+                                 + APIConstants.API_ICON_IMAGE + APIConstants.DOT + extension)) {\n+                        IOUtils.copy(imageDataStream, outputStream);\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"Thumbnail image retrieved successfully for API/API Product: \" + identifier.getName()\n+                                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                                    + identifier.getVersion());\n+                        }\n+                    }\n+                } else {\n+                    //api gets imported without thumbnail\n+                    log.error(\"Unsupported media type for icon \" + mediaType + \". Skipping thumbnail export.\");\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"Thumbnail URL [\" + thumbnailUrl + \"] does not exists in registry for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion() + \". Skipping thumbnail export.\");\n+            }\n+        } catch (RegistryException e) {\n+            log.error(\"Error while retrieving API/API Product Thumbnail \" + thumbnailUrl, e);\n+        } catch (IOException e) {\n+            //Exception is ignored by logging due to the reason that Thumbnail is not essential for\n+            //an API to be recreated.\n+            log.error(\"I/O error while writing API/API Product Thumbnail: \" + thumbnailUrl + \" to file\", e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve documentation for the exporting API or API Product and store it in the archive directory.\n+     * FILE, INLINE, MARKDOWN and URL documentations are handled.\n+     *\n+     * @param identifier    ID of the requesting API or API Product\n+     * @param registry      Current tenant registry\n+     * @param docList       Documentation list of the exporting API or API Product\n+     * @param exportFormat  Format for export\n+     * @throws APIImportExportException If an error occurs while retrieving documents from the\n+     *                                  registry or storing in the archive directory\n+     */\n+    public static void exportAPIOrAPIProductDocumentation(String archivePath, List<Documentation> docList,\n+                                               Identifier identifier, Registry registry, ExportFormat exportFormat)\n+            throws APIImportExportException {\n+\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        String docDirectoryPath = File.separator + APIImportExportConstants.DOCUMENT_DIRECTORY;\n+        CommonUtil.createDirectory(archivePath + docDirectoryPath);\n+        try {\n+            for (Documentation doc : docList) {\n+                String sourceType = doc.getSourceType().name();\n+                String resourcePath = null;\n+                String localFilePath;\n+                String localFileName = null;\n+                String localDocDirectoryPath = docDirectoryPath;\n+                if (Documentation.DocumentSourceType.FILE.toString().equalsIgnoreCase(sourceType)) {\n+                    localFileName = doc.getFilePath().substring(\n+                            doc.getFilePath().lastIndexOf(RegistryConstants.PATH_SEPARATOR) + 1);\n+                    resourcePath = APIUtil.getDocumentationFilePath(identifier, localFileName);\n+                    localDocDirectoryPath += File.separator + APIImportExportConstants.FILE_DOCUMENT_DIRECTORY;\n+                    doc.setFilePath(localFileName);\n+                } else if (Documentation.DocumentSourceType.INLINE.toString().equalsIgnoreCase(sourceType)\n+                        || Documentation.DocumentSourceType.MARKDOWN.toString().equalsIgnoreCase(sourceType)) {\n+                    //Inline/Markdown content file name would be same as the documentation name\n+                    //Markdown content files will also be stored in InlineContents directory\n+                    localFileName = doc.getName();\n+                    resourcePath = APIUtil.getAPIOrAPIProductDocPath(identifier) + APIConstants.INLINE_DOCUMENT_CONTENT_DIR\n+                            + RegistryConstants.PATH_SEPARATOR + localFileName;\n+                    localDocDirectoryPath += File.separator + APIImportExportConstants.INLINE_DOCUMENT_DIRECTORY;\n+                }\n+\n+                if (resourcePath != null) {\n+                    //Write content separately for Inline/Markdown/File type documentations only\n+                    //check whether resource exists in the registry\n+                    if (registry.resourceExists(resourcePath)) {\n+                        CommonUtil.createDirectory(archivePath + localDocDirectoryPath);\n+                        localFilePath = localDocDirectoryPath + File.separator + localFileName;\n+                        Resource docFile = registry.get(resourcePath);\n+                        try (OutputStream outputStream = new FileOutputStream(archivePath + localFilePath);\n+                             InputStream fileInputStream = docFile.getContentStream()) {\n+                            IOUtils.copy(fileInputStream, outputStream);\n+                        }\n+                    } else {\n+                        //Log error and avoid throwing as we give capability to export document artifact without the\n+                        //content if does not exists\n+                        String errorMessage = \"Documentation resource for API/API Product: \" + identifier.getName()\n+                                + \" not found in \" + resourcePath;\n+                        log.error(errorMessage);\n+                    }\n+                }\n+            }\n+\n+            String json = gson.toJson(docList);\n+            switch (exportFormat) {\n+                case JSON:\n+                    CommonUtil.writeFile(archivePath + APIImportExportConstants.JSON_DOCUMENT_FILE_LOCATION, json);\n+                    break;\n+                case YAML:\n+                    String yaml = CommonUtil.jsonToYaml(json);\n+                    CommonUtil.writeFile(archivePath + APIImportExportConstants.YAML_DOCUMENT_FILE_LOCATION, yaml);\n+                    break;\n+            }\n+\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Documentation retrieved successfully for API/API Product: \" + identifier.getName()\n+                        + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + identifier.getVersion());\n+            }\n+        } catch (IOException e) {\n+            String errorMessage = \"I/O error while writing documentation to file for API/API Product: \"\n+                    + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                    + identifier.getVersion();\n+            log.error(errorMessage, e);\n+            throw new APIImportExportException(errorMessage, e);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while retrieving documentation for API/API Product: \" + identifier.getName()\n+                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + identifier.getVersion();\n+            log.error(errorMessage, e);\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+    }\n+    /**\n+     * Retrieve API Definition as JSON.\n+     *\n+     * @param pathToArchive Path to API or API Product archive\n+     * @throws IOException If an error occurs while reading the file\n+     */\n+    public static String getAPIDefinitionAsJson(String pathToArchive) throws IOException {\n+        String jsonContent = null;\n+        String pathToYamlFile = pathToArchive + APIImportExportConstants.YAML_API_FILE_LOCATION;\n+        String pathToJsonFile = pathToArchive + APIImportExportConstants.JSON_API_FILE_LOCATION;\n+\n+        // load yaml representation first if it is present\n+        if (CommonUtil.checkFileExistence(pathToYamlFile)) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Found api definition file \" + pathToYamlFile);\n+            }\n+            String yamlContent = FileUtils.readFileToString(new File(pathToYamlFile));\n+            jsonContent = CommonUtil.yamlToJson(yamlContent);\n+        } else if (CommonUtil.checkFileExistence(pathToJsonFile)) {\n+            // load as a json fallback\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Found api definition file \" + pathToJsonFile);\n+            }\n+            jsonContent = FileUtils.readFileToString(new File(pathToJsonFile));\n+        }\n+        return jsonContent;\n+    }\n+\n+    /**\n+     * Export Mutual SSL related certificates\n+     *\n+     * @param apiTypeWrapper    API or API Product to be exported\n+     * @param tenantId          Tenant id of the user\n+     * @param provider          Api Provider\n+     * @param exportFormat      Export format of file\n+     * @throws APIImportExportException\n+     */\n+    public static void exportClientCertificates(String archivePath, ApiTypeWrapper apiTypeWrapper, int tenantId, APIProvider provider,\n+                                                 ExportFormat exportFormat) throws APIImportExportException {\n+\n+        List<ClientCertificateDTO> certificateMetadataDTOS;\n+        try {\n+            if (!apiTypeWrapper.isAPIProduct()) {\n+                certificateMetadataDTOS = provider.searchClientCertificates(tenantId, null, apiTypeWrapper.getApi().getId());\n+            } else {\n+                certificateMetadataDTOS = provider.searchClientCertificates(tenantId, null, apiTypeWrapper.getApiProduct().getId());\n+            }\n+            if (!certificateMetadataDTOS.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8588ed8e9529f4edd394272935b29aa22bf5cca7"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcxMTgwMA==", "bodyText": "Sure", "url": "https://github.com/wso2/carbon-apimgt/pull/8500#discussion_r428711800", "createdAt": "2020-05-21T15:02:45Z", "author": {"login": "wasuradananjith"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/importexport/utils/APIAndAPIProductCommonUtil.java", "diffHunk": "@@ -0,0 +1,650 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.apimgt.impl.importexport.utils;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonParser;\n+import com.google.gson.reflect.TypeToken;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.APIProvider;\n+import org.wso2.carbon.apimgt.api.FaultGatewaysException;\n+import org.wso2.carbon.apimgt.api.dto.ClientCertificateDTO;\n+import org.wso2.carbon.apimgt.api.model.ApiTypeWrapper;\n+import org.wso2.carbon.apimgt.api.model.Documentation;\n+import org.wso2.carbon.apimgt.api.model.Identifier;\n+import org.wso2.carbon.apimgt.api.model.ResourceFile;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportException;\n+import org.wso2.carbon.apimgt.impl.importexport.ExportFormat;\n+import org.wso2.carbon.apimgt.impl.importexport.lifecycle.LifeCycle;\n+import org.wso2.carbon.apimgt.impl.importexport.lifecycle.LifeCycleTransition;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.base.MultitenantConstants;\n+import org.wso2.carbon.registry.api.Registry;\n+import org.wso2.carbon.registry.api.RegistryException;\n+import org.wso2.carbon.registry.api.Resource;\n+import org.wso2.carbon.registry.core.RegistryConstants;\n+import org.xml.sax.SAXException;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+/**\n+ * This is the util class which consists of all the functions for exporting API Product.\n+ */\n+public class APIAndAPIProductCommonUtil {\n+\n+    private static final Log log = LogFactory.getLog(APIAndAPIProductCommonUtil.class);\n+\n+    private APIAndAPIProductCommonUtil() {\n+    }\n+\n+    /**\n+     * Retrieve thumbnail image for the exporting API or API Product and store it in the archive directory.\n+     *\n+     * @param identifier                ID of the requesting API or API Product\n+     * @param registry                  Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void exportAPIOrAPIProductThumbnail(String archivePath, Identifier identifier, Registry registry)\n+            throws APIImportExportException {\n+        String thumbnailUrl = APIConstants.API_IMAGE_LOCATION + RegistryConstants.PATH_SEPARATOR\n+                + identifier.getProviderName() + RegistryConstants.PATH_SEPARATOR + identifier.getName()\n+                + RegistryConstants.PATH_SEPARATOR + identifier.getVersion() + RegistryConstants.PATH_SEPARATOR\n+                + APIConstants.API_ICON_IMAGE;\n+        String localImagePath = archivePath + File.separator + APIImportExportConstants.IMAGE_RESOURCE;\n+        try {\n+            if (registry.resourceExists(thumbnailUrl)) {\n+                Resource icon = registry.get(thumbnailUrl);\n+                String mediaType = icon.getMediaType();\n+                String extension = APIImportExportConstants.fileExtensionMapping.get(mediaType);\n+                if (extension != null) {\n+                    CommonUtil.createDirectory(localImagePath);\n+                    try (InputStream imageDataStream = icon.getContentStream();\n+                         OutputStream outputStream = new FileOutputStream(localImagePath + File.separator\n+                                 + APIConstants.API_ICON_IMAGE + APIConstants.DOT + extension)) {\n+                        IOUtils.copy(imageDataStream, outputStream);\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"Thumbnail image retrieved successfully for API/API Product: \" + identifier.getName()\n+                                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                                    + identifier.getVersion());\n+                        }\n+                    }\n+                } else {\n+                    //api gets imported without thumbnail\n+                    log.error(\"Unsupported media type for icon \" + mediaType + \". Skipping thumbnail export.\");\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"Thumbnail URL [\" + thumbnailUrl + \"] does not exists in registry for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion() + \". Skipping thumbnail export.\");\n+            }\n+        } catch (RegistryException e) {\n+            log.error(\"Error while retrieving API/API Product Thumbnail \" + thumbnailUrl, e);\n+        } catch (IOException e) {\n+            //Exception is ignored by logging due to the reason that Thumbnail is not essential for\n+            //an API to be recreated.\n+            log.error(\"I/O error while writing API/API Product Thumbnail: \" + thumbnailUrl + \" to file\", e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve documentation for the exporting API or API Product and store it in the archive directory.\n+     * FILE, INLINE, MARKDOWN and URL documentations are handled.\n+     *\n+     * @param identifier    ID of the requesting API or API Product\n+     * @param registry      Current tenant registry\n+     * @param docList       Documentation list of the exporting API or API Product\n+     * @param exportFormat  Format for export\n+     * @throws APIImportExportException If an error occurs while retrieving documents from the\n+     *                                  registry or storing in the archive directory\n+     */\n+    public static void exportAPIOrAPIProductDocumentation(String archivePath, List<Documentation> docList,\n+                                               Identifier identifier, Registry registry, ExportFormat exportFormat)\n+            throws APIImportExportException {\n+\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        String docDirectoryPath = File.separator + APIImportExportConstants.DOCUMENT_DIRECTORY;\n+        CommonUtil.createDirectory(archivePath + docDirectoryPath);\n+        try {\n+            for (Documentation doc : docList) {\n+                String sourceType = doc.getSourceType().name();\n+                String resourcePath = null;\n+                String localFilePath;\n+                String localFileName = null;\n+                String localDocDirectoryPath = docDirectoryPath;\n+                if (Documentation.DocumentSourceType.FILE.toString().equalsIgnoreCase(sourceType)) {\n+                    localFileName = doc.getFilePath().substring(\n+                            doc.getFilePath().lastIndexOf(RegistryConstants.PATH_SEPARATOR) + 1);\n+                    resourcePath = APIUtil.getDocumentationFilePath(identifier, localFileName);\n+                    localDocDirectoryPath += File.separator + APIImportExportConstants.FILE_DOCUMENT_DIRECTORY;\n+                    doc.setFilePath(localFileName);\n+                } else if (Documentation.DocumentSourceType.INLINE.toString().equalsIgnoreCase(sourceType)\n+                        || Documentation.DocumentSourceType.MARKDOWN.toString().equalsIgnoreCase(sourceType)) {\n+                    //Inline/Markdown content file name would be same as the documentation name\n+                    //Markdown content files will also be stored in InlineContents directory\n+                    localFileName = doc.getName();\n+                    resourcePath = APIUtil.getAPIOrAPIProductDocPath(identifier) + APIConstants.INLINE_DOCUMENT_CONTENT_DIR\n+                            + RegistryConstants.PATH_SEPARATOR + localFileName;\n+                    localDocDirectoryPath += File.separator + APIImportExportConstants.INLINE_DOCUMENT_DIRECTORY;\n+                }\n+\n+                if (resourcePath != null) {\n+                    //Write content separately for Inline/Markdown/File type documentations only\n+                    //check whether resource exists in the registry\n+                    if (registry.resourceExists(resourcePath)) {\n+                        CommonUtil.createDirectory(archivePath + localDocDirectoryPath);\n+                        localFilePath = localDocDirectoryPath + File.separator + localFileName;\n+                        Resource docFile = registry.get(resourcePath);\n+                        try (OutputStream outputStream = new FileOutputStream(archivePath + localFilePath);\n+                             InputStream fileInputStream = docFile.getContentStream()) {\n+                            IOUtils.copy(fileInputStream, outputStream);\n+                        }\n+                    } else {\n+                        //Log error and avoid throwing as we give capability to export document artifact without the\n+                        //content if does not exists\n+                        String errorMessage = \"Documentation resource for API/API Product: \" + identifier.getName()\n+                                + \" not found in \" + resourcePath;\n+                        log.error(errorMessage);\n+                    }\n+                }\n+            }\n+\n+            String json = gson.toJson(docList);\n+            switch (exportFormat) {\n+                case JSON:\n+                    CommonUtil.writeFile(archivePath + APIImportExportConstants.JSON_DOCUMENT_FILE_LOCATION, json);\n+                    break;\n+                case YAML:\n+                    String yaml = CommonUtil.jsonToYaml(json);\n+                    CommonUtil.writeFile(archivePath + APIImportExportConstants.YAML_DOCUMENT_FILE_LOCATION, yaml);\n+                    break;\n+            }\n+\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Documentation retrieved successfully for API/API Product: \" + identifier.getName()\n+                        + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + identifier.getVersion());\n+            }\n+        } catch (IOException e) {\n+            String errorMessage = \"I/O error while writing documentation to file for API/API Product: \"\n+                    + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                    + identifier.getVersion();\n+            log.error(errorMessage, e);\n+            throw new APIImportExportException(errorMessage, e);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while retrieving documentation for API/API Product: \" + identifier.getName()\n+                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + identifier.getVersion();\n+            log.error(errorMessage, e);\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+    }\n+    /**\n+     * Retrieve API Definition as JSON.\n+     *\n+     * @param pathToArchive Path to API or API Product archive\n+     * @throws IOException If an error occurs while reading the file\n+     */\n+    public static String getAPIDefinitionAsJson(String pathToArchive) throws IOException {\n+        String jsonContent = null;\n+        String pathToYamlFile = pathToArchive + APIImportExportConstants.YAML_API_FILE_LOCATION;\n+        String pathToJsonFile = pathToArchive + APIImportExportConstants.JSON_API_FILE_LOCATION;\n+\n+        // load yaml representation first if it is present\n+        if (CommonUtil.checkFileExistence(pathToYamlFile)) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Found api definition file \" + pathToYamlFile);\n+            }\n+            String yamlContent = FileUtils.readFileToString(new File(pathToYamlFile));\n+            jsonContent = CommonUtil.yamlToJson(yamlContent);\n+        } else if (CommonUtil.checkFileExistence(pathToJsonFile)) {\n+            // load as a json fallback\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Found api definition file \" + pathToJsonFile);\n+            }\n+            jsonContent = FileUtils.readFileToString(new File(pathToJsonFile));\n+        }\n+        return jsonContent;\n+    }\n+\n+    /**\n+     * Export Mutual SSL related certificates\n+     *\n+     * @param apiTypeWrapper    API or API Product to be exported\n+     * @param tenantId          Tenant id of the user\n+     * @param provider          Api Provider\n+     * @param exportFormat      Export format of file\n+     * @throws APIImportExportException\n+     */\n+    public static void exportClientCertificates(String archivePath, ApiTypeWrapper apiTypeWrapper, int tenantId, APIProvider provider,\n+                                                 ExportFormat exportFormat) throws APIImportExportException {\n+\n+        List<ClientCertificateDTO> certificateMetadataDTOS;\n+        try {\n+            if (!apiTypeWrapper.isAPIProduct()) {\n+                certificateMetadataDTOS = provider.searchClientCertificates(tenantId, null, apiTypeWrapper.getApi().getId());\n+            } else {\n+                certificateMetadataDTOS = provider.searchClientCertificates(tenantId, null, apiTypeWrapper.getApiProduct().getId());\n+            }\n+            if (!certificateMetadataDTOS.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY3NzA3MA=="}, "originalCommit": {"oid": "8588ed8e9529f4edd394272935b29aa22bf5cca7"}, "originalPosition": 274}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2OTgwNTM0OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/importexport/utils/APIAndAPIProductCommonUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNDoxMzozNVrOGY0Zfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNTowNToxOFrOGY2lxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY3NzUwMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    String yaml = CommonUtil.jsonToYaml(element);\n          \n          \n            \n                                    CommonUtil.writeFile(archivePath + APIImportExportConstants.YAML_CLIENT_CERTIFICATE_FILE,\n          \n          \n            \n                                            yaml);\n          \n          \n            \n                                    CommonUtil.writeFile(archivePath + APIImportExportConstants.YAML_CLIENT_CERTIFICATE_FILE,\n          \n          \n            \n                                            CommonUtil.jsonToYaml(element));", "url": "https://github.com/wso2/carbon-apimgt/pull/8500#discussion_r428677502", "createdAt": "2020-05-21T14:13:35Z", "author": {"login": "malinthaprasan"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/importexport/utils/APIAndAPIProductCommonUtil.java", "diffHunk": "@@ -0,0 +1,650 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.apimgt.impl.importexport.utils;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonParser;\n+import com.google.gson.reflect.TypeToken;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.APIProvider;\n+import org.wso2.carbon.apimgt.api.FaultGatewaysException;\n+import org.wso2.carbon.apimgt.api.dto.ClientCertificateDTO;\n+import org.wso2.carbon.apimgt.api.model.ApiTypeWrapper;\n+import org.wso2.carbon.apimgt.api.model.Documentation;\n+import org.wso2.carbon.apimgt.api.model.Identifier;\n+import org.wso2.carbon.apimgt.api.model.ResourceFile;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportException;\n+import org.wso2.carbon.apimgt.impl.importexport.ExportFormat;\n+import org.wso2.carbon.apimgt.impl.importexport.lifecycle.LifeCycle;\n+import org.wso2.carbon.apimgt.impl.importexport.lifecycle.LifeCycleTransition;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.base.MultitenantConstants;\n+import org.wso2.carbon.registry.api.Registry;\n+import org.wso2.carbon.registry.api.RegistryException;\n+import org.wso2.carbon.registry.api.Resource;\n+import org.wso2.carbon.registry.core.RegistryConstants;\n+import org.xml.sax.SAXException;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+/**\n+ * This is the util class which consists of all the functions for exporting API Product.\n+ */\n+public class APIAndAPIProductCommonUtil {\n+\n+    private static final Log log = LogFactory.getLog(APIAndAPIProductCommonUtil.class);\n+\n+    private APIAndAPIProductCommonUtil() {\n+    }\n+\n+    /**\n+     * Retrieve thumbnail image for the exporting API or API Product and store it in the archive directory.\n+     *\n+     * @param identifier                ID of the requesting API or API Product\n+     * @param registry                  Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void exportAPIOrAPIProductThumbnail(String archivePath, Identifier identifier, Registry registry)\n+            throws APIImportExportException {\n+        String thumbnailUrl = APIConstants.API_IMAGE_LOCATION + RegistryConstants.PATH_SEPARATOR\n+                + identifier.getProviderName() + RegistryConstants.PATH_SEPARATOR + identifier.getName()\n+                + RegistryConstants.PATH_SEPARATOR + identifier.getVersion() + RegistryConstants.PATH_SEPARATOR\n+                + APIConstants.API_ICON_IMAGE;\n+        String localImagePath = archivePath + File.separator + APIImportExportConstants.IMAGE_RESOURCE;\n+        try {\n+            if (registry.resourceExists(thumbnailUrl)) {\n+                Resource icon = registry.get(thumbnailUrl);\n+                String mediaType = icon.getMediaType();\n+                String extension = APIImportExportConstants.fileExtensionMapping.get(mediaType);\n+                if (extension != null) {\n+                    CommonUtil.createDirectory(localImagePath);\n+                    try (InputStream imageDataStream = icon.getContentStream();\n+                         OutputStream outputStream = new FileOutputStream(localImagePath + File.separator\n+                                 + APIConstants.API_ICON_IMAGE + APIConstants.DOT + extension)) {\n+                        IOUtils.copy(imageDataStream, outputStream);\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"Thumbnail image retrieved successfully for API/API Product: \" + identifier.getName()\n+                                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                                    + identifier.getVersion());\n+                        }\n+                    }\n+                } else {\n+                    //api gets imported without thumbnail\n+                    log.error(\"Unsupported media type for icon \" + mediaType + \". Skipping thumbnail export.\");\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"Thumbnail URL [\" + thumbnailUrl + \"] does not exists in registry for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion() + \". Skipping thumbnail export.\");\n+            }\n+        } catch (RegistryException e) {\n+            log.error(\"Error while retrieving API/API Product Thumbnail \" + thumbnailUrl, e);\n+        } catch (IOException e) {\n+            //Exception is ignored by logging due to the reason that Thumbnail is not essential for\n+            //an API to be recreated.\n+            log.error(\"I/O error while writing API/API Product Thumbnail: \" + thumbnailUrl + \" to file\", e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve documentation for the exporting API or API Product and store it in the archive directory.\n+     * FILE, INLINE, MARKDOWN and URL documentations are handled.\n+     *\n+     * @param identifier    ID of the requesting API or API Product\n+     * @param registry      Current tenant registry\n+     * @param docList       Documentation list of the exporting API or API Product\n+     * @param exportFormat  Format for export\n+     * @throws APIImportExportException If an error occurs while retrieving documents from the\n+     *                                  registry or storing in the archive directory\n+     */\n+    public static void exportAPIOrAPIProductDocumentation(String archivePath, List<Documentation> docList,\n+                                               Identifier identifier, Registry registry, ExportFormat exportFormat)\n+            throws APIImportExportException {\n+\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        String docDirectoryPath = File.separator + APIImportExportConstants.DOCUMENT_DIRECTORY;\n+        CommonUtil.createDirectory(archivePath + docDirectoryPath);\n+        try {\n+            for (Documentation doc : docList) {\n+                String sourceType = doc.getSourceType().name();\n+                String resourcePath = null;\n+                String localFilePath;\n+                String localFileName = null;\n+                String localDocDirectoryPath = docDirectoryPath;\n+                if (Documentation.DocumentSourceType.FILE.toString().equalsIgnoreCase(sourceType)) {\n+                    localFileName = doc.getFilePath().substring(\n+                            doc.getFilePath().lastIndexOf(RegistryConstants.PATH_SEPARATOR) + 1);\n+                    resourcePath = APIUtil.getDocumentationFilePath(identifier, localFileName);\n+                    localDocDirectoryPath += File.separator + APIImportExportConstants.FILE_DOCUMENT_DIRECTORY;\n+                    doc.setFilePath(localFileName);\n+                } else if (Documentation.DocumentSourceType.INLINE.toString().equalsIgnoreCase(sourceType)\n+                        || Documentation.DocumentSourceType.MARKDOWN.toString().equalsIgnoreCase(sourceType)) {\n+                    //Inline/Markdown content file name would be same as the documentation name\n+                    //Markdown content files will also be stored in InlineContents directory\n+                    localFileName = doc.getName();\n+                    resourcePath = APIUtil.getAPIOrAPIProductDocPath(identifier) + APIConstants.INLINE_DOCUMENT_CONTENT_DIR\n+                            + RegistryConstants.PATH_SEPARATOR + localFileName;\n+                    localDocDirectoryPath += File.separator + APIImportExportConstants.INLINE_DOCUMENT_DIRECTORY;\n+                }\n+\n+                if (resourcePath != null) {\n+                    //Write content separately for Inline/Markdown/File type documentations only\n+                    //check whether resource exists in the registry\n+                    if (registry.resourceExists(resourcePath)) {\n+                        CommonUtil.createDirectory(archivePath + localDocDirectoryPath);\n+                        localFilePath = localDocDirectoryPath + File.separator + localFileName;\n+                        Resource docFile = registry.get(resourcePath);\n+                        try (OutputStream outputStream = new FileOutputStream(archivePath + localFilePath);\n+                             InputStream fileInputStream = docFile.getContentStream()) {\n+                            IOUtils.copy(fileInputStream, outputStream);\n+                        }\n+                    } else {\n+                        //Log error and avoid throwing as we give capability to export document artifact without the\n+                        //content if does not exists\n+                        String errorMessage = \"Documentation resource for API/API Product: \" + identifier.getName()\n+                                + \" not found in \" + resourcePath;\n+                        log.error(errorMessage);\n+                    }\n+                }\n+            }\n+\n+            String json = gson.toJson(docList);\n+            switch (exportFormat) {\n+                case JSON:\n+                    CommonUtil.writeFile(archivePath + APIImportExportConstants.JSON_DOCUMENT_FILE_LOCATION, json);\n+                    break;\n+                case YAML:\n+                    String yaml = CommonUtil.jsonToYaml(json);\n+                    CommonUtil.writeFile(archivePath + APIImportExportConstants.YAML_DOCUMENT_FILE_LOCATION, yaml);\n+                    break;\n+            }\n+\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Documentation retrieved successfully for API/API Product: \" + identifier.getName()\n+                        + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + identifier.getVersion());\n+            }\n+        } catch (IOException e) {\n+            String errorMessage = \"I/O error while writing documentation to file for API/API Product: \"\n+                    + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                    + identifier.getVersion();\n+            log.error(errorMessage, e);\n+            throw new APIImportExportException(errorMessage, e);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while retrieving documentation for API/API Product: \" + identifier.getName()\n+                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + identifier.getVersion();\n+            log.error(errorMessage, e);\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+    }\n+    /**\n+     * Retrieve API Definition as JSON.\n+     *\n+     * @param pathToArchive Path to API or API Product archive\n+     * @throws IOException If an error occurs while reading the file\n+     */\n+    public static String getAPIDefinitionAsJson(String pathToArchive) throws IOException {\n+        String jsonContent = null;\n+        String pathToYamlFile = pathToArchive + APIImportExportConstants.YAML_API_FILE_LOCATION;\n+        String pathToJsonFile = pathToArchive + APIImportExportConstants.JSON_API_FILE_LOCATION;\n+\n+        // load yaml representation first if it is present\n+        if (CommonUtil.checkFileExistence(pathToYamlFile)) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Found api definition file \" + pathToYamlFile);\n+            }\n+            String yamlContent = FileUtils.readFileToString(new File(pathToYamlFile));\n+            jsonContent = CommonUtil.yamlToJson(yamlContent);\n+        } else if (CommonUtil.checkFileExistence(pathToJsonFile)) {\n+            // load as a json fallback\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Found api definition file \" + pathToJsonFile);\n+            }\n+            jsonContent = FileUtils.readFileToString(new File(pathToJsonFile));\n+        }\n+        return jsonContent;\n+    }\n+\n+    /**\n+     * Export Mutual SSL related certificates\n+     *\n+     * @param apiTypeWrapper    API or API Product to be exported\n+     * @param tenantId          Tenant id of the user\n+     * @param provider          Api Provider\n+     * @param exportFormat      Export format of file\n+     * @throws APIImportExportException\n+     */\n+    public static void exportClientCertificates(String archivePath, ApiTypeWrapper apiTypeWrapper, int tenantId, APIProvider provider,\n+                                                 ExportFormat exportFormat) throws APIImportExportException {\n+\n+        List<ClientCertificateDTO> certificateMetadataDTOS;\n+        try {\n+            if (!apiTypeWrapper.isAPIProduct()) {\n+                certificateMetadataDTOS = provider.searchClientCertificates(tenantId, null, apiTypeWrapper.getApi().getId());\n+            } else {\n+                certificateMetadataDTOS = provider.searchClientCertificates(tenantId, null, apiTypeWrapper.getApiProduct().getId());\n+            }\n+            if (!certificateMetadataDTOS.isEmpty()) {\n+                CommonUtil.createDirectory(archivePath + File.separator + APIImportExportConstants.META_INFO_DIRECTORY);\n+\n+                Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+                String element = gson.toJson(certificateMetadataDTOS,\n+                        new TypeToken<ArrayList<ClientCertificateDTO>>() {\n+                        }.getType());\n+\n+                switch (exportFormat) {\n+                    case YAML:\n+                        String yaml = CommonUtil.jsonToYaml(element);\n+                        CommonUtil.writeFile(archivePath + APIImportExportConstants.YAML_CLIENT_CERTIFICATE_FILE,\n+                                yaml);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8588ed8e9529f4edd394272935b29aa22bf5cca7"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcxMzQxMg==", "bodyText": "Sure", "url": "https://github.com/wso2/carbon-apimgt/pull/8500#discussion_r428713412", "createdAt": "2020-05-21T15:05:18Z", "author": {"login": "wasuradananjith"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/importexport/utils/APIAndAPIProductCommonUtil.java", "diffHunk": "@@ -0,0 +1,650 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.apimgt.impl.importexport.utils;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonParser;\n+import com.google.gson.reflect.TypeToken;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.APIProvider;\n+import org.wso2.carbon.apimgt.api.FaultGatewaysException;\n+import org.wso2.carbon.apimgt.api.dto.ClientCertificateDTO;\n+import org.wso2.carbon.apimgt.api.model.ApiTypeWrapper;\n+import org.wso2.carbon.apimgt.api.model.Documentation;\n+import org.wso2.carbon.apimgt.api.model.Identifier;\n+import org.wso2.carbon.apimgt.api.model.ResourceFile;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportException;\n+import org.wso2.carbon.apimgt.impl.importexport.ExportFormat;\n+import org.wso2.carbon.apimgt.impl.importexport.lifecycle.LifeCycle;\n+import org.wso2.carbon.apimgt.impl.importexport.lifecycle.LifeCycleTransition;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.base.MultitenantConstants;\n+import org.wso2.carbon.registry.api.Registry;\n+import org.wso2.carbon.registry.api.RegistryException;\n+import org.wso2.carbon.registry.api.Resource;\n+import org.wso2.carbon.registry.core.RegistryConstants;\n+import org.xml.sax.SAXException;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+/**\n+ * This is the util class which consists of all the functions for exporting API Product.\n+ */\n+public class APIAndAPIProductCommonUtil {\n+\n+    private static final Log log = LogFactory.getLog(APIAndAPIProductCommonUtil.class);\n+\n+    private APIAndAPIProductCommonUtil() {\n+    }\n+\n+    /**\n+     * Retrieve thumbnail image for the exporting API or API Product and store it in the archive directory.\n+     *\n+     * @param identifier                ID of the requesting API or API Product\n+     * @param registry                  Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void exportAPIOrAPIProductThumbnail(String archivePath, Identifier identifier, Registry registry)\n+            throws APIImportExportException {\n+        String thumbnailUrl = APIConstants.API_IMAGE_LOCATION + RegistryConstants.PATH_SEPARATOR\n+                + identifier.getProviderName() + RegistryConstants.PATH_SEPARATOR + identifier.getName()\n+                + RegistryConstants.PATH_SEPARATOR + identifier.getVersion() + RegistryConstants.PATH_SEPARATOR\n+                + APIConstants.API_ICON_IMAGE;\n+        String localImagePath = archivePath + File.separator + APIImportExportConstants.IMAGE_RESOURCE;\n+        try {\n+            if (registry.resourceExists(thumbnailUrl)) {\n+                Resource icon = registry.get(thumbnailUrl);\n+                String mediaType = icon.getMediaType();\n+                String extension = APIImportExportConstants.fileExtensionMapping.get(mediaType);\n+                if (extension != null) {\n+                    CommonUtil.createDirectory(localImagePath);\n+                    try (InputStream imageDataStream = icon.getContentStream();\n+                         OutputStream outputStream = new FileOutputStream(localImagePath + File.separator\n+                                 + APIConstants.API_ICON_IMAGE + APIConstants.DOT + extension)) {\n+                        IOUtils.copy(imageDataStream, outputStream);\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"Thumbnail image retrieved successfully for API/API Product: \" + identifier.getName()\n+                                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                                    + identifier.getVersion());\n+                        }\n+                    }\n+                } else {\n+                    //api gets imported without thumbnail\n+                    log.error(\"Unsupported media type for icon \" + mediaType + \". Skipping thumbnail export.\");\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"Thumbnail URL [\" + thumbnailUrl + \"] does not exists in registry for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion() + \". Skipping thumbnail export.\");\n+            }\n+        } catch (RegistryException e) {\n+            log.error(\"Error while retrieving API/API Product Thumbnail \" + thumbnailUrl, e);\n+        } catch (IOException e) {\n+            //Exception is ignored by logging due to the reason that Thumbnail is not essential for\n+            //an API to be recreated.\n+            log.error(\"I/O error while writing API/API Product Thumbnail: \" + thumbnailUrl + \" to file\", e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve documentation for the exporting API or API Product and store it in the archive directory.\n+     * FILE, INLINE, MARKDOWN and URL documentations are handled.\n+     *\n+     * @param identifier    ID of the requesting API or API Product\n+     * @param registry      Current tenant registry\n+     * @param docList       Documentation list of the exporting API or API Product\n+     * @param exportFormat  Format for export\n+     * @throws APIImportExportException If an error occurs while retrieving documents from the\n+     *                                  registry or storing in the archive directory\n+     */\n+    public static void exportAPIOrAPIProductDocumentation(String archivePath, List<Documentation> docList,\n+                                               Identifier identifier, Registry registry, ExportFormat exportFormat)\n+            throws APIImportExportException {\n+\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        String docDirectoryPath = File.separator + APIImportExportConstants.DOCUMENT_DIRECTORY;\n+        CommonUtil.createDirectory(archivePath + docDirectoryPath);\n+        try {\n+            for (Documentation doc : docList) {\n+                String sourceType = doc.getSourceType().name();\n+                String resourcePath = null;\n+                String localFilePath;\n+                String localFileName = null;\n+                String localDocDirectoryPath = docDirectoryPath;\n+                if (Documentation.DocumentSourceType.FILE.toString().equalsIgnoreCase(sourceType)) {\n+                    localFileName = doc.getFilePath().substring(\n+                            doc.getFilePath().lastIndexOf(RegistryConstants.PATH_SEPARATOR) + 1);\n+                    resourcePath = APIUtil.getDocumentationFilePath(identifier, localFileName);\n+                    localDocDirectoryPath += File.separator + APIImportExportConstants.FILE_DOCUMENT_DIRECTORY;\n+                    doc.setFilePath(localFileName);\n+                } else if (Documentation.DocumentSourceType.INLINE.toString().equalsIgnoreCase(sourceType)\n+                        || Documentation.DocumentSourceType.MARKDOWN.toString().equalsIgnoreCase(sourceType)) {\n+                    //Inline/Markdown content file name would be same as the documentation name\n+                    //Markdown content files will also be stored in InlineContents directory\n+                    localFileName = doc.getName();\n+                    resourcePath = APIUtil.getAPIOrAPIProductDocPath(identifier) + APIConstants.INLINE_DOCUMENT_CONTENT_DIR\n+                            + RegistryConstants.PATH_SEPARATOR + localFileName;\n+                    localDocDirectoryPath += File.separator + APIImportExportConstants.INLINE_DOCUMENT_DIRECTORY;\n+                }\n+\n+                if (resourcePath != null) {\n+                    //Write content separately for Inline/Markdown/File type documentations only\n+                    //check whether resource exists in the registry\n+                    if (registry.resourceExists(resourcePath)) {\n+                        CommonUtil.createDirectory(archivePath + localDocDirectoryPath);\n+                        localFilePath = localDocDirectoryPath + File.separator + localFileName;\n+                        Resource docFile = registry.get(resourcePath);\n+                        try (OutputStream outputStream = new FileOutputStream(archivePath + localFilePath);\n+                             InputStream fileInputStream = docFile.getContentStream()) {\n+                            IOUtils.copy(fileInputStream, outputStream);\n+                        }\n+                    } else {\n+                        //Log error and avoid throwing as we give capability to export document artifact without the\n+                        //content if does not exists\n+                        String errorMessage = \"Documentation resource for API/API Product: \" + identifier.getName()\n+                                + \" not found in \" + resourcePath;\n+                        log.error(errorMessage);\n+                    }\n+                }\n+            }\n+\n+            String json = gson.toJson(docList);\n+            switch (exportFormat) {\n+                case JSON:\n+                    CommonUtil.writeFile(archivePath + APIImportExportConstants.JSON_DOCUMENT_FILE_LOCATION, json);\n+                    break;\n+                case YAML:\n+                    String yaml = CommonUtil.jsonToYaml(json);\n+                    CommonUtil.writeFile(archivePath + APIImportExportConstants.YAML_DOCUMENT_FILE_LOCATION, yaml);\n+                    break;\n+            }\n+\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Documentation retrieved successfully for API/API Product: \" + identifier.getName()\n+                        + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + identifier.getVersion());\n+            }\n+        } catch (IOException e) {\n+            String errorMessage = \"I/O error while writing documentation to file for API/API Product: \"\n+                    + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                    + identifier.getVersion();\n+            log.error(errorMessage, e);\n+            throw new APIImportExportException(errorMessage, e);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while retrieving documentation for API/API Product: \" + identifier.getName()\n+                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + identifier.getVersion();\n+            log.error(errorMessage, e);\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+    }\n+    /**\n+     * Retrieve API Definition as JSON.\n+     *\n+     * @param pathToArchive Path to API or API Product archive\n+     * @throws IOException If an error occurs while reading the file\n+     */\n+    public static String getAPIDefinitionAsJson(String pathToArchive) throws IOException {\n+        String jsonContent = null;\n+        String pathToYamlFile = pathToArchive + APIImportExportConstants.YAML_API_FILE_LOCATION;\n+        String pathToJsonFile = pathToArchive + APIImportExportConstants.JSON_API_FILE_LOCATION;\n+\n+        // load yaml representation first if it is present\n+        if (CommonUtil.checkFileExistence(pathToYamlFile)) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Found api definition file \" + pathToYamlFile);\n+            }\n+            String yamlContent = FileUtils.readFileToString(new File(pathToYamlFile));\n+            jsonContent = CommonUtil.yamlToJson(yamlContent);\n+        } else if (CommonUtil.checkFileExistence(pathToJsonFile)) {\n+            // load as a json fallback\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Found api definition file \" + pathToJsonFile);\n+            }\n+            jsonContent = FileUtils.readFileToString(new File(pathToJsonFile));\n+        }\n+        return jsonContent;\n+    }\n+\n+    /**\n+     * Export Mutual SSL related certificates\n+     *\n+     * @param apiTypeWrapper    API or API Product to be exported\n+     * @param tenantId          Tenant id of the user\n+     * @param provider          Api Provider\n+     * @param exportFormat      Export format of file\n+     * @throws APIImportExportException\n+     */\n+    public static void exportClientCertificates(String archivePath, ApiTypeWrapper apiTypeWrapper, int tenantId, APIProvider provider,\n+                                                 ExportFormat exportFormat) throws APIImportExportException {\n+\n+        List<ClientCertificateDTO> certificateMetadataDTOS;\n+        try {\n+            if (!apiTypeWrapper.isAPIProduct()) {\n+                certificateMetadataDTOS = provider.searchClientCertificates(tenantId, null, apiTypeWrapper.getApi().getId());\n+            } else {\n+                certificateMetadataDTOS = provider.searchClientCertificates(tenantId, null, apiTypeWrapper.getApiProduct().getId());\n+            }\n+            if (!certificateMetadataDTOS.isEmpty()) {\n+                CommonUtil.createDirectory(archivePath + File.separator + APIImportExportConstants.META_INFO_DIRECTORY);\n+\n+                Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+                String element = gson.toJson(certificateMetadataDTOS,\n+                        new TypeToken<ArrayList<ClientCertificateDTO>>() {\n+                        }.getType());\n+\n+                switch (exportFormat) {\n+                    case YAML:\n+                        String yaml = CommonUtil.jsonToYaml(element);\n+                        CommonUtil.writeFile(archivePath + APIImportExportConstants.YAML_CLIENT_CERTIFICATE_FILE,\n+                                yaml);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY3NzUwMg=="}, "originalCommit": {"oid": "8588ed8e9529f4edd394272935b29aa22bf5cca7"}, "originalPosition": 286}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NDE0Mzg1OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIProviderImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxMzoxMzoxN1rOIRUwNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQxODowMDoyMlrOIXK0Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTAzNjcyNQ==", "bodyText": "Shall we remove this empty line? Please check other places as well.", "url": "https://github.com/wso2/carbon-apimgt/pull/8500#discussion_r555036725", "createdAt": "2021-01-11T13:13:17Z", "author": {"login": "vithu30"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIProviderImpl.java", "diffHunk": "@@ -5322,6 +5324,36 @@ private void saveAPIDefinition(APIProduct apiProduct, String apiDefinitionJSON,\n         }\n     }\n \n+    @Override\n+    public void addAPIProductSwagger(Map<API, List<APIProductResource>> apiToProductResourceMapping, APIProduct apiProduct)\n+            throws APIManagementException {\n+        APIDefinition parser = new OAS3Parser();\n+        SwaggerData swaggerData = new SwaggerData(apiProduct);\n+        String apiProductSwagger = parser.generateAPIDefinition(swaggerData);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "955d38a97e275c5eab0c74ab94c018e0bf8b6b45"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE2NTMzNQ==", "bodyText": "Fixed via 08c2e6b", "url": "https://github.com/wso2/carbon-apimgt/pull/8500#discussion_r561165335", "createdAt": "2021-01-20T18:00:22Z", "author": {"login": "wasuradananjith"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIProviderImpl.java", "diffHunk": "@@ -5322,6 +5324,36 @@ private void saveAPIDefinition(APIProduct apiProduct, String apiDefinitionJSON,\n         }\n     }\n \n+    @Override\n+    public void addAPIProductSwagger(Map<API, List<APIProductResource>> apiToProductResourceMapping, APIProduct apiProduct)\n+            throws APIManagementException {\n+        APIDefinition parser = new OAS3Parser();\n+        SwaggerData swaggerData = new SwaggerData(apiProduct);\n+        String apiProductSwagger = parser.generateAPIDefinition(swaggerData);\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTAzNjcyNQ=="}, "originalCommit": {"oid": "955d38a97e275c5eab0c74ab94c018e0bf8b6b45"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NDE1NDYwOnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/certificatemgt/CertificateManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxMzoxNjoxMVrOIRU2zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQxODowMDo1M1rOIXK1aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTAzODQxMw==", "bodyText": "Seems this import is not used. Shall we remove it?", "url": "https://github.com/wso2/carbon-apimgt/pull/8500#discussion_r555038413", "createdAt": "2021-01-11T13:16:11Z", "author": {"login": "vithu30"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/certificatemgt/CertificateManager.java", "diffHunk": "@@ -22,6 +22,7 @@\n import org.wso2.carbon.apimgt.api.dto.CertificateMetadataDTO;\n import org.wso2.carbon.apimgt.api.dto.ClientCertificateDTO;\n import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.api.model.APIProductIdentifier;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "955d38a97e275c5eab0c74ab94c018e0bf8b6b45"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE2NTY3NQ==", "bodyText": "Fixed via 77531e9", "url": "https://github.com/wso2/carbon-apimgt/pull/8500#discussion_r561165675", "createdAt": "2021-01-20T18:00:53Z", "author": {"login": "wasuradananjith"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/certificatemgt/CertificateManager.java", "diffHunk": "@@ -22,6 +22,7 @@\n import org.wso2.carbon.apimgt.api.dto.CertificateMetadataDTO;\n import org.wso2.carbon.apimgt.api.dto.ClientCertificateDTO;\n import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.api.model.APIProductIdentifier;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTAzODQxMw=="}, "originalCommit": {"oid": "955d38a97e275c5eab0c74ab94c018e0bf8b6b45"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NDE1NDk2OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/certificatemgt/CertificateManagerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxMzoxNjoxOFrOIRU3DA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQxNzo1MDo0N1rOIXKcYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTAzODQ3Ng==", "bodyText": "Seems this import is not used. Shall we remove it?", "url": "https://github.com/wso2/carbon-apimgt/pull/8500#discussion_r555038476", "createdAt": "2021-01-11T13:16:18Z", "author": {"login": "vithu30"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/certificatemgt/CertificateManagerImpl.java", "diffHunk": "@@ -29,6 +29,7 @@\n import org.wso2.carbon.apimgt.api.dto.CertificateMetadataDTO;\n import org.wso2.carbon.apimgt.api.dto.ClientCertificateDTO;\n import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.api.model.APIProductIdentifier;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "955d38a97e275c5eab0c74ab94c018e0bf8b6b45"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE1OTI2NQ==", "bodyText": "This does not exist currently in [1].\n[1] https://github.com/wso2/carbon-apimgt/blob/master/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/certificatemgt/CertificateManagerImpl.java", "url": "https://github.com/wso2/carbon-apimgt/pull/8500#discussion_r561159265", "createdAt": "2021-01-20T17:50:47Z", "author": {"login": "wasuradananjith"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/certificatemgt/CertificateManagerImpl.java", "diffHunk": "@@ -29,6 +29,7 @@\n import org.wso2.carbon.apimgt.api.dto.CertificateMetadataDTO;\n import org.wso2.carbon.apimgt.api.dto.ClientCertificateDTO;\n import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.api.model.APIProductIdentifier;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTAzODQ3Ng=="}, "originalCommit": {"oid": "955d38a97e275c5eab0c74ab94c018e0bf8b6b45"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3372, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}