{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI0NDcwNDg5", "number": 9406, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwODo1NjozNFrOE7cgCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQxMDowNDowNlrOFUcNrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNzY4MzkyOnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/utils/ExportUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwODo1NjozNFrOH3GQCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMDoyMzo0MFrOH3JzDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzUzNjEzNw==", "bodyText": "Any reason for not using try with resources pattern here, we can avoid needing to close the stream.", "url": "https://github.com/wso2/carbon-apimgt/pull/9406#discussion_r527536137", "createdAt": "2020-11-20T08:56:34Z", "author": {"login": "uvindra"}, "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/utils/ExportUtils.java", "diffHunk": "@@ -0,0 +1,1087 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.apimgt.rest.api.publisher.v1.utils;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import org.apache.axiom.om.OMElement;\n+import org.apache.commons.codec.binary.Base64;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.json.JSONTokener;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.APIProvider;\n+import org.wso2.carbon.apimgt.api.dto.CertificateMetadataDTO;\n+import org.wso2.carbon.apimgt.api.dto.ClientCertificateDTO;\n+import org.wso2.carbon.apimgt.api.model.API;\n+import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.api.model.APIProduct;\n+import org.wso2.carbon.apimgt.api.model.APIProductIdentifier;\n+import org.wso2.carbon.apimgt.api.model.Documentation;\n+import org.wso2.carbon.apimgt.api.model.Identifier;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.certificatemgt.CertificateManager;\n+import org.wso2.carbon.apimgt.impl.certificatemgt.CertificateManagerImpl;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportException;\n+import org.wso2.carbon.apimgt.impl.importexport.ExportFormat;\n+import org.wso2.carbon.apimgt.impl.importexport.ImportExportConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.utils.CommonUtil;\n+import org.wso2.carbon.apimgt.impl.internal.ServiceReferenceHolder;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.apimgt.impl.wsdl.util.SOAPToRESTConstants;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.APIDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.APIProductDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.MediationPolicyDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.ProductAPIDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.utils.mappings.APIMappingUtil;\n+import org.wso2.carbon.apimgt.rest.api.util.RestApiConstants;\n+import org.wso2.carbon.apimgt.rest.api.util.utils.RestApiUtil;\n+import org.wso2.carbon.registry.api.Collection;\n+import org.wso2.carbon.registry.api.Registry;\n+import org.wso2.carbon.registry.api.RegistryException;\n+import org.wso2.carbon.registry.api.Resource;\n+import org.wso2.carbon.registry.core.RegistryConstants;\n+import org.wso2.carbon.registry.core.session.UserRegistry;\n+import org.wso2.carbon.utils.multitenancy.MultitenantUtils;\n+\n+import javax.xml.namespace.QName;\n+import javax.xml.stream.XMLStreamException;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ExportUtils {\n+\n+    private static final Log log = LogFactory.getLog(ExportUtils.class);\n+    private static final String IN = \"in\";\n+    private static final String OUT = \"out\";\n+    private static final String SOAPTOREST = \"SoapToRest\";\n+\n+    /**\n+     * Validate name, version and provider before exporting an API/API Product\n+     *\n+     * @param name         API/API Product Name\n+     * @param version      API/API Product version\n+     * @param providerName Name of the provider\n+     * @return Name of the provider\n+     * @throws APIManagementException If an error occurs while retrieving the provider name from name, version\n+     *                                and tenant\n+     */\n+    public static String validateExportParams(String name, String version, String providerName)\n+            throws APIManagementException {\n+        if (name == null || version == null) {\n+            RestApiUtil.handleBadRequest(\"'name' (\" + name + \") or 'version' (\" + version\n+                    + \") should not be null.\", log);\n+        }\n+        String apiRequesterDomain = RestApiUtil.getLoggedInUserTenantDomain();\n+\n+        // If provider name is not given\n+        if (StringUtils.isBlank(providerName)) {\n+            // Retrieve the provider who is in same tenant domain and who owns the same API (by comparing\n+            // API name and the version)\n+            providerName = APIUtil.getAPIProviderFromAPINameVersionTenant(name, version, apiRequesterDomain);\n+\n+            // If there is no provider in current domain, the API cannot be exported\n+            if (providerName == null) {\n+                String errorMessage = \"Error occurred while exporting. API: \" + name + \" version: \" + version\n+                        + \" not found\";\n+                RestApiUtil.handleResourceNotFoundError(errorMessage, log);\n+            }\n+        }\n+\n+        if (!StringUtils.equals(MultitenantUtils.getTenantDomain(providerName), apiRequesterDomain)) {\n+            // Not authorized to export requested API\n+            RestApiUtil.handleAuthorizationFailure(RestApiConstants.RESOURCE_API +\n+                    \" name:\" + name + \" version:\" + version + \" provider:\" + providerName, log);\n+        }\n+        return providerName;\n+    }\n+\n+    /**\n+     * Exports an API from API Manager for a given API. Meta information, API icon, documentation,\n+     * WSDL and sequences are exported.\n+     *\n+     * @param apiProvider    API Provider\n+     * @param apiIdentifier  API Identifier\n+     * @param apiDtoToReturn API DTO\n+     * @param userName       Username\n+     * @param exportFormat   Format of output documents. Can be YAML or JSON\n+     * @param preserveStatus Preserve API status on export\n+     * @return\n+     * @throws APIManagementException If an error occurs while getting governance registry\n+     */\n+    public static File exportApi(APIProvider apiProvider, APIIdentifier apiIdentifier, APIDTO apiDtoToReturn,\n+                                 String userName, ExportFormat exportFormat, Boolean preserveStatus)\n+            throws APIManagementException {\n+        int tenantId = 0;\n+        try {\n+            // Create temp location for storing API data\n+            File exportFolder = CommonUtil.createTempDirectory(apiIdentifier);\n+            String exportAPIBasePath = exportFolder.toString();\n+            String archivePath = exportAPIBasePath.concat(File.separator + apiIdentifier.getApiName() + \"-\"\n+                    + apiIdentifier.getVersion());\n+            tenantId = APIUtil.getTenantId(userName);\n+            UserRegistry registry = ServiceReferenceHolder.getInstance().getRegistryService().\n+                    getGovernanceSystemRegistry(tenantId);\n+\n+            CommonUtil.createDirectory(archivePath);\n+\n+            addThumbnailToArchive(archivePath, apiIdentifier, registry);\n+            addSOAPToRESTMediationToArchive(archivePath, apiIdentifier, registry);\n+            addDocumentationToArchive(archivePath, apiIdentifier, registry, exportFormat, apiProvider);\n+\n+            if (StringUtils.isNotEmpty(apiDtoToReturn.getWsdlUrl())) {\n+                addWSDLtoArchive(archivePath, apiIdentifier, registry);\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"No WSDL URL found for API: \" + apiIdentifier + \". Skipping WSDL export.\");\n+            }\n+\n+            addSequencesToArchive(archivePath, apiIdentifier, apiDtoToReturn, registry, exportFormat);\n+\n+            // Set API status to created if the status is not preserved\n+            if (!preserveStatus) {\n+                apiDtoToReturn.setLifeCycleStatus(APIConstants.CREATED);\n+            }\n+\n+            addEndpointCertificatesToArchive(archivePath, apiDtoToReturn, tenantId, exportFormat);\n+            addAPIMetaInformationToArchive(archivePath, apiDtoToReturn, exportFormat, apiProvider, apiIdentifier, userName);\n+\n+            // Export mTLS authentication related certificates\n+            if (apiProvider.isClientCertificateBasedAuthenticationConfigured()) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Mutual SSL enabled. Exporting client certificates.\");\n+                }\n+                addClientCertificatesToArchive(archivePath, apiIdentifier, tenantId, apiProvider, exportFormat);\n+            }\n+            CommonUtil.archiveDirectory(exportAPIBasePath);\n+            FileUtils.deleteQuietly(new File(exportAPIBasePath));\n+            return new File(exportAPIBasePath + APIConstants.ZIP_FILE_EXTENSION);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while getting governance registry for tenant: \" + tenantId;\n+            throw new APIManagementException(errorMessage, e);\n+        } catch (APIManagementException | APIImportExportException e) {\n+            RestApiUtil.handleInternalServerError(\"Error while exporting \" + RestApiConstants.RESOURCE_API, e, log);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Exports an API Product from API Manager for a given API Product. MMeta information, API Product icon, documentation, client certificates\n+     * and dependent APIs are exported.\n+     *\n+     * @param apiProvider           API Provider\n+     * @param apiProductIdentifier  API Product Identifier\n+     * @param apiProductDtoToReturn API Product DTO\n+     * @param userName              Username\n+     * @param exportFormat          Format of output documents. Can be YAML or JSON\n+     * @param preserveStatus        Preserve API Product status on export\n+     * @return\n+     * @throws APIManagementException If an error occurs while getting governance registry\n+     */\n+    public static File exportApiProduct(APIProvider apiProvider, APIProductIdentifier apiProductIdentifier,\n+                                        APIProductDTO apiProductDtoToReturn, String userName, ExportFormat exportFormat,\n+                                        Boolean preserveStatus)\n+            throws APIManagementException {\n+        int tenantId = 0;\n+        try {\n+            // Create temp location for storing API Product data\n+            File exportFolder = CommonUtil.createTempDirectory(apiProductIdentifier);\n+            String exportAPIBasePath = exportFolder.toString();\n+            String archivePath = exportAPIBasePath.concat(File.separator + apiProductIdentifier.getName() + \"-\"\n+                    + apiProductIdentifier.getVersion());\n+            tenantId = APIUtil.getTenantId(userName);\n+            UserRegistry registry = ServiceReferenceHolder.getInstance().getRegistryService().\n+                    getGovernanceSystemRegistry(tenantId);\n+            APIProduct apiProduct = APIMappingUtil.fromDTOtoAPIProduct(apiProductDtoToReturn, userName);\n+\n+            CommonUtil.createDirectory(archivePath);\n+\n+            addThumbnailToArchive(archivePath, apiProductIdentifier, registry);\n+            addDocumentationToArchive(archivePath, apiProductIdentifier, registry, exportFormat, apiProvider);\n+            addAPIProductMetaInformationToArchive(archivePath, apiProductDtoToReturn, exportFormat, apiProvider,\n+                    userName);\n+            addDependentAPIsToArchive(archivePath, apiProductDtoToReturn, exportFormat, apiProvider, userName,\n+                    preserveStatus);\n+\n+            // Export mTLS authentication related certificates\n+            if (apiProvider.isClientCertificateBasedAuthenticationConfigured()) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Mutual SSL enabled. Exporting client certificates.\");\n+                }\n+                addClientCertificatesToArchive(archivePath, apiProductIdentifier, tenantId, apiProvider, exportFormat);\n+            }\n+            CommonUtil.archiveDirectory(exportAPIBasePath);\n+            FileUtils.deleteQuietly(new File(exportAPIBasePath));\n+            return new File(exportAPIBasePath + APIConstants.ZIP_FILE_EXTENSION);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while getting governance registry for tenant: \" + tenantId;\n+            throw new APIManagementException(errorMessage, e);\n+        } catch (APIManagementException | APIImportExportException e) {\n+            RestApiUtil.handleInternalServerError(\"Error while exporting \" +\n+                    RestApiConstants.RESOURCE_API_PRODUCT, e, log);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Retrieve thumbnail image for the exporting API or API Product and store it in the archive directory.\n+     *\n+     * @param archivePath File path to export the thumbnail image\n+     * @param identifier  ID of the requesting API or API Product\n+     * @param registry    Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addThumbnailToArchive(String archivePath, Identifier identifier, Registry registry)\n+            throws APIImportExportException {\n+        String thumbnailUrl = APIConstants.API_IMAGE_LOCATION + RegistryConstants.PATH_SEPARATOR\n+                + identifier.getProviderName() + RegistryConstants.PATH_SEPARATOR + identifier.getName()\n+                + RegistryConstants.PATH_SEPARATOR + identifier.getVersion() + RegistryConstants.PATH_SEPARATOR\n+                + APIConstants.API_ICON_IMAGE;\n+        String localImagePath = archivePath + File.separator + ImportExportConstants.IMAGE_RESOURCE;\n+        try {\n+            if (registry.resourceExists(thumbnailUrl)) {\n+                Resource icon = registry.get(thumbnailUrl);\n+                String mediaType = icon.getMediaType();\n+                String extension = ImportExportConstants.fileExtensionMapping.get(mediaType);\n+                if (extension != null) {\n+                    CommonUtil.createDirectory(localImagePath);\n+                    try (InputStream imageDataStream = icon.getContentStream();\n+                         OutputStream outputStream = new FileOutputStream(localImagePath + File.separator\n+                                 + APIConstants.API_ICON_IMAGE + APIConstants.DOT + extension)) {\n+                        IOUtils.copy(imageDataStream, outputStream);\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"Thumbnail image retrieved successfully for API/API Product: \" + identifier.getName()\n+                                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                                    + identifier.getVersion());\n+                        }\n+                    }\n+                } else {\n+                    //api gets imported without thumbnail\n+                    log.error(\"Unsupported media type for icon \" + mediaType + \". Skipping thumbnail export.\");\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"Thumbnail URL [\" + thumbnailUrl + \"] does not exists in registry for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion() + \". Skipping thumbnail export.\");\n+            }\n+        } catch (RegistryException e) {\n+            log.error(\"Error while retrieving API/API Product Thumbnail \" + thumbnailUrl, e);\n+        } catch (IOException e) {\n+            //Exception is ignored by logging due to the reason that Thumbnail is not essential for\n+            //an API to be recreated.\n+            log.error(\"I/O error while writing API/API Product Thumbnail: \" + thumbnailUrl + \" to file\", e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve SOAP to REST mediation logic for the exporting API and store it in the archive directory\n+     *\n+     * @param archivePath   File path to export the SOAPToREST mediation logic\n+     * @param apiIdentifier ID of the requesting API\n+     * @param registry      Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addSOAPToRESTMediationToArchive(String archivePath, APIIdentifier apiIdentifier,\n+                                                       UserRegistry registry) throws APIImportExportException {\n+        String soapToRestBaseUrl = \"/apimgt/applicationdata/provider\" + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getProviderName() + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getApiName() + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getVersion() + RegistryConstants.PATH_SEPARATOR +\n+                SOAPToRESTConstants.SOAP_TO_REST_RESOURCE;\n+\n+        InputStream inputStream = null;\n+        OutputStream outputStream = null;\n+        try {\n+            if (registry.resourceExists(soapToRestBaseUrl)) {\n+                Collection inFlow = (org.wso2.carbon.registry.api.Collection) registry.get(soapToRestBaseUrl\n+                        + RegistryConstants.PATH_SEPARATOR + IN);\n+                Collection outFlow = (org.wso2.carbon.registry.api.Collection) registry.get(soapToRestBaseUrl\n+                        + RegistryConstants.PATH_SEPARATOR + OUT);\n+\n+                CommonUtil.createDirectory(archivePath + File.separator + SOAPTOREST + File.separator + IN);\n+                CommonUtil.createDirectory(archivePath + File.separator + SOAPTOREST + File.separator + OUT);\n+                if (inFlow != null) {\n+                    for (String inFlowPath : inFlow.getChildren()) {\n+                        inputStream = registry.get(inFlowPath).getContentStream();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67a7a292f0788f2879e86f6675caf1d27f063c89"}, "originalPosition": 342}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU5NDI1NA==", "bodyText": "Fixed via 150d9ab", "url": "https://github.com/wso2/carbon-apimgt/pull/9406#discussion_r527594254", "createdAt": "2020-11-20T10:23:40Z", "author": {"login": "wasuradananjith"}, "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/utils/ExportUtils.java", "diffHunk": "@@ -0,0 +1,1087 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.apimgt.rest.api.publisher.v1.utils;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import org.apache.axiom.om.OMElement;\n+import org.apache.commons.codec.binary.Base64;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.json.JSONTokener;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.APIProvider;\n+import org.wso2.carbon.apimgt.api.dto.CertificateMetadataDTO;\n+import org.wso2.carbon.apimgt.api.dto.ClientCertificateDTO;\n+import org.wso2.carbon.apimgt.api.model.API;\n+import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.api.model.APIProduct;\n+import org.wso2.carbon.apimgt.api.model.APIProductIdentifier;\n+import org.wso2.carbon.apimgt.api.model.Documentation;\n+import org.wso2.carbon.apimgt.api.model.Identifier;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.certificatemgt.CertificateManager;\n+import org.wso2.carbon.apimgt.impl.certificatemgt.CertificateManagerImpl;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportException;\n+import org.wso2.carbon.apimgt.impl.importexport.ExportFormat;\n+import org.wso2.carbon.apimgt.impl.importexport.ImportExportConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.utils.CommonUtil;\n+import org.wso2.carbon.apimgt.impl.internal.ServiceReferenceHolder;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.apimgt.impl.wsdl.util.SOAPToRESTConstants;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.APIDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.APIProductDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.MediationPolicyDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.ProductAPIDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.utils.mappings.APIMappingUtil;\n+import org.wso2.carbon.apimgt.rest.api.util.RestApiConstants;\n+import org.wso2.carbon.apimgt.rest.api.util.utils.RestApiUtil;\n+import org.wso2.carbon.registry.api.Collection;\n+import org.wso2.carbon.registry.api.Registry;\n+import org.wso2.carbon.registry.api.RegistryException;\n+import org.wso2.carbon.registry.api.Resource;\n+import org.wso2.carbon.registry.core.RegistryConstants;\n+import org.wso2.carbon.registry.core.session.UserRegistry;\n+import org.wso2.carbon.utils.multitenancy.MultitenantUtils;\n+\n+import javax.xml.namespace.QName;\n+import javax.xml.stream.XMLStreamException;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ExportUtils {\n+\n+    private static final Log log = LogFactory.getLog(ExportUtils.class);\n+    private static final String IN = \"in\";\n+    private static final String OUT = \"out\";\n+    private static final String SOAPTOREST = \"SoapToRest\";\n+\n+    /**\n+     * Validate name, version and provider before exporting an API/API Product\n+     *\n+     * @param name         API/API Product Name\n+     * @param version      API/API Product version\n+     * @param providerName Name of the provider\n+     * @return Name of the provider\n+     * @throws APIManagementException If an error occurs while retrieving the provider name from name, version\n+     *                                and tenant\n+     */\n+    public static String validateExportParams(String name, String version, String providerName)\n+            throws APIManagementException {\n+        if (name == null || version == null) {\n+            RestApiUtil.handleBadRequest(\"'name' (\" + name + \") or 'version' (\" + version\n+                    + \") should not be null.\", log);\n+        }\n+        String apiRequesterDomain = RestApiUtil.getLoggedInUserTenantDomain();\n+\n+        // If provider name is not given\n+        if (StringUtils.isBlank(providerName)) {\n+            // Retrieve the provider who is in same tenant domain and who owns the same API (by comparing\n+            // API name and the version)\n+            providerName = APIUtil.getAPIProviderFromAPINameVersionTenant(name, version, apiRequesterDomain);\n+\n+            // If there is no provider in current domain, the API cannot be exported\n+            if (providerName == null) {\n+                String errorMessage = \"Error occurred while exporting. API: \" + name + \" version: \" + version\n+                        + \" not found\";\n+                RestApiUtil.handleResourceNotFoundError(errorMessage, log);\n+            }\n+        }\n+\n+        if (!StringUtils.equals(MultitenantUtils.getTenantDomain(providerName), apiRequesterDomain)) {\n+            // Not authorized to export requested API\n+            RestApiUtil.handleAuthorizationFailure(RestApiConstants.RESOURCE_API +\n+                    \" name:\" + name + \" version:\" + version + \" provider:\" + providerName, log);\n+        }\n+        return providerName;\n+    }\n+\n+    /**\n+     * Exports an API from API Manager for a given API. Meta information, API icon, documentation,\n+     * WSDL and sequences are exported.\n+     *\n+     * @param apiProvider    API Provider\n+     * @param apiIdentifier  API Identifier\n+     * @param apiDtoToReturn API DTO\n+     * @param userName       Username\n+     * @param exportFormat   Format of output documents. Can be YAML or JSON\n+     * @param preserveStatus Preserve API status on export\n+     * @return\n+     * @throws APIManagementException If an error occurs while getting governance registry\n+     */\n+    public static File exportApi(APIProvider apiProvider, APIIdentifier apiIdentifier, APIDTO apiDtoToReturn,\n+                                 String userName, ExportFormat exportFormat, Boolean preserveStatus)\n+            throws APIManagementException {\n+        int tenantId = 0;\n+        try {\n+            // Create temp location for storing API data\n+            File exportFolder = CommonUtil.createTempDirectory(apiIdentifier);\n+            String exportAPIBasePath = exportFolder.toString();\n+            String archivePath = exportAPIBasePath.concat(File.separator + apiIdentifier.getApiName() + \"-\"\n+                    + apiIdentifier.getVersion());\n+            tenantId = APIUtil.getTenantId(userName);\n+            UserRegistry registry = ServiceReferenceHolder.getInstance().getRegistryService().\n+                    getGovernanceSystemRegistry(tenantId);\n+\n+            CommonUtil.createDirectory(archivePath);\n+\n+            addThumbnailToArchive(archivePath, apiIdentifier, registry);\n+            addSOAPToRESTMediationToArchive(archivePath, apiIdentifier, registry);\n+            addDocumentationToArchive(archivePath, apiIdentifier, registry, exportFormat, apiProvider);\n+\n+            if (StringUtils.isNotEmpty(apiDtoToReturn.getWsdlUrl())) {\n+                addWSDLtoArchive(archivePath, apiIdentifier, registry);\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"No WSDL URL found for API: \" + apiIdentifier + \". Skipping WSDL export.\");\n+            }\n+\n+            addSequencesToArchive(archivePath, apiIdentifier, apiDtoToReturn, registry, exportFormat);\n+\n+            // Set API status to created if the status is not preserved\n+            if (!preserveStatus) {\n+                apiDtoToReturn.setLifeCycleStatus(APIConstants.CREATED);\n+            }\n+\n+            addEndpointCertificatesToArchive(archivePath, apiDtoToReturn, tenantId, exportFormat);\n+            addAPIMetaInformationToArchive(archivePath, apiDtoToReturn, exportFormat, apiProvider, apiIdentifier, userName);\n+\n+            // Export mTLS authentication related certificates\n+            if (apiProvider.isClientCertificateBasedAuthenticationConfigured()) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Mutual SSL enabled. Exporting client certificates.\");\n+                }\n+                addClientCertificatesToArchive(archivePath, apiIdentifier, tenantId, apiProvider, exportFormat);\n+            }\n+            CommonUtil.archiveDirectory(exportAPIBasePath);\n+            FileUtils.deleteQuietly(new File(exportAPIBasePath));\n+            return new File(exportAPIBasePath + APIConstants.ZIP_FILE_EXTENSION);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while getting governance registry for tenant: \" + tenantId;\n+            throw new APIManagementException(errorMessage, e);\n+        } catch (APIManagementException | APIImportExportException e) {\n+            RestApiUtil.handleInternalServerError(\"Error while exporting \" + RestApiConstants.RESOURCE_API, e, log);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Exports an API Product from API Manager for a given API Product. MMeta information, API Product icon, documentation, client certificates\n+     * and dependent APIs are exported.\n+     *\n+     * @param apiProvider           API Provider\n+     * @param apiProductIdentifier  API Product Identifier\n+     * @param apiProductDtoToReturn API Product DTO\n+     * @param userName              Username\n+     * @param exportFormat          Format of output documents. Can be YAML or JSON\n+     * @param preserveStatus        Preserve API Product status on export\n+     * @return\n+     * @throws APIManagementException If an error occurs while getting governance registry\n+     */\n+    public static File exportApiProduct(APIProvider apiProvider, APIProductIdentifier apiProductIdentifier,\n+                                        APIProductDTO apiProductDtoToReturn, String userName, ExportFormat exportFormat,\n+                                        Boolean preserveStatus)\n+            throws APIManagementException {\n+        int tenantId = 0;\n+        try {\n+            // Create temp location for storing API Product data\n+            File exportFolder = CommonUtil.createTempDirectory(apiProductIdentifier);\n+            String exportAPIBasePath = exportFolder.toString();\n+            String archivePath = exportAPIBasePath.concat(File.separator + apiProductIdentifier.getName() + \"-\"\n+                    + apiProductIdentifier.getVersion());\n+            tenantId = APIUtil.getTenantId(userName);\n+            UserRegistry registry = ServiceReferenceHolder.getInstance().getRegistryService().\n+                    getGovernanceSystemRegistry(tenantId);\n+            APIProduct apiProduct = APIMappingUtil.fromDTOtoAPIProduct(apiProductDtoToReturn, userName);\n+\n+            CommonUtil.createDirectory(archivePath);\n+\n+            addThumbnailToArchive(archivePath, apiProductIdentifier, registry);\n+            addDocumentationToArchive(archivePath, apiProductIdentifier, registry, exportFormat, apiProvider);\n+            addAPIProductMetaInformationToArchive(archivePath, apiProductDtoToReturn, exportFormat, apiProvider,\n+                    userName);\n+            addDependentAPIsToArchive(archivePath, apiProductDtoToReturn, exportFormat, apiProvider, userName,\n+                    preserveStatus);\n+\n+            // Export mTLS authentication related certificates\n+            if (apiProvider.isClientCertificateBasedAuthenticationConfigured()) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Mutual SSL enabled. Exporting client certificates.\");\n+                }\n+                addClientCertificatesToArchive(archivePath, apiProductIdentifier, tenantId, apiProvider, exportFormat);\n+            }\n+            CommonUtil.archiveDirectory(exportAPIBasePath);\n+            FileUtils.deleteQuietly(new File(exportAPIBasePath));\n+            return new File(exportAPIBasePath + APIConstants.ZIP_FILE_EXTENSION);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while getting governance registry for tenant: \" + tenantId;\n+            throw new APIManagementException(errorMessage, e);\n+        } catch (APIManagementException | APIImportExportException e) {\n+            RestApiUtil.handleInternalServerError(\"Error while exporting \" +\n+                    RestApiConstants.RESOURCE_API_PRODUCT, e, log);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Retrieve thumbnail image for the exporting API or API Product and store it in the archive directory.\n+     *\n+     * @param archivePath File path to export the thumbnail image\n+     * @param identifier  ID of the requesting API or API Product\n+     * @param registry    Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addThumbnailToArchive(String archivePath, Identifier identifier, Registry registry)\n+            throws APIImportExportException {\n+        String thumbnailUrl = APIConstants.API_IMAGE_LOCATION + RegistryConstants.PATH_SEPARATOR\n+                + identifier.getProviderName() + RegistryConstants.PATH_SEPARATOR + identifier.getName()\n+                + RegistryConstants.PATH_SEPARATOR + identifier.getVersion() + RegistryConstants.PATH_SEPARATOR\n+                + APIConstants.API_ICON_IMAGE;\n+        String localImagePath = archivePath + File.separator + ImportExportConstants.IMAGE_RESOURCE;\n+        try {\n+            if (registry.resourceExists(thumbnailUrl)) {\n+                Resource icon = registry.get(thumbnailUrl);\n+                String mediaType = icon.getMediaType();\n+                String extension = ImportExportConstants.fileExtensionMapping.get(mediaType);\n+                if (extension != null) {\n+                    CommonUtil.createDirectory(localImagePath);\n+                    try (InputStream imageDataStream = icon.getContentStream();\n+                         OutputStream outputStream = new FileOutputStream(localImagePath + File.separator\n+                                 + APIConstants.API_ICON_IMAGE + APIConstants.DOT + extension)) {\n+                        IOUtils.copy(imageDataStream, outputStream);\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"Thumbnail image retrieved successfully for API/API Product: \" + identifier.getName()\n+                                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                                    + identifier.getVersion());\n+                        }\n+                    }\n+                } else {\n+                    //api gets imported without thumbnail\n+                    log.error(\"Unsupported media type for icon \" + mediaType + \". Skipping thumbnail export.\");\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"Thumbnail URL [\" + thumbnailUrl + \"] does not exists in registry for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion() + \". Skipping thumbnail export.\");\n+            }\n+        } catch (RegistryException e) {\n+            log.error(\"Error while retrieving API/API Product Thumbnail \" + thumbnailUrl, e);\n+        } catch (IOException e) {\n+            //Exception is ignored by logging due to the reason that Thumbnail is not essential for\n+            //an API to be recreated.\n+            log.error(\"I/O error while writing API/API Product Thumbnail: \" + thumbnailUrl + \" to file\", e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve SOAP to REST mediation logic for the exporting API and store it in the archive directory\n+     *\n+     * @param archivePath   File path to export the SOAPToREST mediation logic\n+     * @param apiIdentifier ID of the requesting API\n+     * @param registry      Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addSOAPToRESTMediationToArchive(String archivePath, APIIdentifier apiIdentifier,\n+                                                       UserRegistry registry) throws APIImportExportException {\n+        String soapToRestBaseUrl = \"/apimgt/applicationdata/provider\" + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getProviderName() + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getApiName() + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getVersion() + RegistryConstants.PATH_SEPARATOR +\n+                SOAPToRESTConstants.SOAP_TO_REST_RESOURCE;\n+\n+        InputStream inputStream = null;\n+        OutputStream outputStream = null;\n+        try {\n+            if (registry.resourceExists(soapToRestBaseUrl)) {\n+                Collection inFlow = (org.wso2.carbon.registry.api.Collection) registry.get(soapToRestBaseUrl\n+                        + RegistryConstants.PATH_SEPARATOR + IN);\n+                Collection outFlow = (org.wso2.carbon.registry.api.Collection) registry.get(soapToRestBaseUrl\n+                        + RegistryConstants.PATH_SEPARATOR + OUT);\n+\n+                CommonUtil.createDirectory(archivePath + File.separator + SOAPTOREST + File.separator + IN);\n+                CommonUtil.createDirectory(archivePath + File.separator + SOAPTOREST + File.separator + OUT);\n+                if (inFlow != null) {\n+                    for (String inFlowPath : inFlow.getChildren()) {\n+                        inputStream = registry.get(inFlowPath).getContentStream();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzUzNjEzNw=="}, "originalCommit": {"oid": "67a7a292f0788f2879e86f6675caf1d27f063c89"}, "originalPosition": 342}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNzY4NTExOnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/utils/ExportUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwODo1Njo1NlrOH3GQwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMDoyMzo0OVrOH3Jzcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzUzNjMyMA==", "bodyText": "Any reason for not using try with resources pattern here, we can avoid needing to close the stream.", "url": "https://github.com/wso2/carbon-apimgt/pull/9406#discussion_r527536320", "createdAt": "2020-11-20T08:56:56Z", "author": {"login": "uvindra"}, "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/utils/ExportUtils.java", "diffHunk": "@@ -0,0 +1,1087 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.apimgt.rest.api.publisher.v1.utils;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import org.apache.axiom.om.OMElement;\n+import org.apache.commons.codec.binary.Base64;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.json.JSONTokener;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.APIProvider;\n+import org.wso2.carbon.apimgt.api.dto.CertificateMetadataDTO;\n+import org.wso2.carbon.apimgt.api.dto.ClientCertificateDTO;\n+import org.wso2.carbon.apimgt.api.model.API;\n+import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.api.model.APIProduct;\n+import org.wso2.carbon.apimgt.api.model.APIProductIdentifier;\n+import org.wso2.carbon.apimgt.api.model.Documentation;\n+import org.wso2.carbon.apimgt.api.model.Identifier;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.certificatemgt.CertificateManager;\n+import org.wso2.carbon.apimgt.impl.certificatemgt.CertificateManagerImpl;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportException;\n+import org.wso2.carbon.apimgt.impl.importexport.ExportFormat;\n+import org.wso2.carbon.apimgt.impl.importexport.ImportExportConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.utils.CommonUtil;\n+import org.wso2.carbon.apimgt.impl.internal.ServiceReferenceHolder;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.apimgt.impl.wsdl.util.SOAPToRESTConstants;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.APIDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.APIProductDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.MediationPolicyDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.ProductAPIDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.utils.mappings.APIMappingUtil;\n+import org.wso2.carbon.apimgt.rest.api.util.RestApiConstants;\n+import org.wso2.carbon.apimgt.rest.api.util.utils.RestApiUtil;\n+import org.wso2.carbon.registry.api.Collection;\n+import org.wso2.carbon.registry.api.Registry;\n+import org.wso2.carbon.registry.api.RegistryException;\n+import org.wso2.carbon.registry.api.Resource;\n+import org.wso2.carbon.registry.core.RegistryConstants;\n+import org.wso2.carbon.registry.core.session.UserRegistry;\n+import org.wso2.carbon.utils.multitenancy.MultitenantUtils;\n+\n+import javax.xml.namespace.QName;\n+import javax.xml.stream.XMLStreamException;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ExportUtils {\n+\n+    private static final Log log = LogFactory.getLog(ExportUtils.class);\n+    private static final String IN = \"in\";\n+    private static final String OUT = \"out\";\n+    private static final String SOAPTOREST = \"SoapToRest\";\n+\n+    /**\n+     * Validate name, version and provider before exporting an API/API Product\n+     *\n+     * @param name         API/API Product Name\n+     * @param version      API/API Product version\n+     * @param providerName Name of the provider\n+     * @return Name of the provider\n+     * @throws APIManagementException If an error occurs while retrieving the provider name from name, version\n+     *                                and tenant\n+     */\n+    public static String validateExportParams(String name, String version, String providerName)\n+            throws APIManagementException {\n+        if (name == null || version == null) {\n+            RestApiUtil.handleBadRequest(\"'name' (\" + name + \") or 'version' (\" + version\n+                    + \") should not be null.\", log);\n+        }\n+        String apiRequesterDomain = RestApiUtil.getLoggedInUserTenantDomain();\n+\n+        // If provider name is not given\n+        if (StringUtils.isBlank(providerName)) {\n+            // Retrieve the provider who is in same tenant domain and who owns the same API (by comparing\n+            // API name and the version)\n+            providerName = APIUtil.getAPIProviderFromAPINameVersionTenant(name, version, apiRequesterDomain);\n+\n+            // If there is no provider in current domain, the API cannot be exported\n+            if (providerName == null) {\n+                String errorMessage = \"Error occurred while exporting. API: \" + name + \" version: \" + version\n+                        + \" not found\";\n+                RestApiUtil.handleResourceNotFoundError(errorMessage, log);\n+            }\n+        }\n+\n+        if (!StringUtils.equals(MultitenantUtils.getTenantDomain(providerName), apiRequesterDomain)) {\n+            // Not authorized to export requested API\n+            RestApiUtil.handleAuthorizationFailure(RestApiConstants.RESOURCE_API +\n+                    \" name:\" + name + \" version:\" + version + \" provider:\" + providerName, log);\n+        }\n+        return providerName;\n+    }\n+\n+    /**\n+     * Exports an API from API Manager for a given API. Meta information, API icon, documentation,\n+     * WSDL and sequences are exported.\n+     *\n+     * @param apiProvider    API Provider\n+     * @param apiIdentifier  API Identifier\n+     * @param apiDtoToReturn API DTO\n+     * @param userName       Username\n+     * @param exportFormat   Format of output documents. Can be YAML or JSON\n+     * @param preserveStatus Preserve API status on export\n+     * @return\n+     * @throws APIManagementException If an error occurs while getting governance registry\n+     */\n+    public static File exportApi(APIProvider apiProvider, APIIdentifier apiIdentifier, APIDTO apiDtoToReturn,\n+                                 String userName, ExportFormat exportFormat, Boolean preserveStatus)\n+            throws APIManagementException {\n+        int tenantId = 0;\n+        try {\n+            // Create temp location for storing API data\n+            File exportFolder = CommonUtil.createTempDirectory(apiIdentifier);\n+            String exportAPIBasePath = exportFolder.toString();\n+            String archivePath = exportAPIBasePath.concat(File.separator + apiIdentifier.getApiName() + \"-\"\n+                    + apiIdentifier.getVersion());\n+            tenantId = APIUtil.getTenantId(userName);\n+            UserRegistry registry = ServiceReferenceHolder.getInstance().getRegistryService().\n+                    getGovernanceSystemRegistry(tenantId);\n+\n+            CommonUtil.createDirectory(archivePath);\n+\n+            addThumbnailToArchive(archivePath, apiIdentifier, registry);\n+            addSOAPToRESTMediationToArchive(archivePath, apiIdentifier, registry);\n+            addDocumentationToArchive(archivePath, apiIdentifier, registry, exportFormat, apiProvider);\n+\n+            if (StringUtils.isNotEmpty(apiDtoToReturn.getWsdlUrl())) {\n+                addWSDLtoArchive(archivePath, apiIdentifier, registry);\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"No WSDL URL found for API: \" + apiIdentifier + \". Skipping WSDL export.\");\n+            }\n+\n+            addSequencesToArchive(archivePath, apiIdentifier, apiDtoToReturn, registry, exportFormat);\n+\n+            // Set API status to created if the status is not preserved\n+            if (!preserveStatus) {\n+                apiDtoToReturn.setLifeCycleStatus(APIConstants.CREATED);\n+            }\n+\n+            addEndpointCertificatesToArchive(archivePath, apiDtoToReturn, tenantId, exportFormat);\n+            addAPIMetaInformationToArchive(archivePath, apiDtoToReturn, exportFormat, apiProvider, apiIdentifier, userName);\n+\n+            // Export mTLS authentication related certificates\n+            if (apiProvider.isClientCertificateBasedAuthenticationConfigured()) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Mutual SSL enabled. Exporting client certificates.\");\n+                }\n+                addClientCertificatesToArchive(archivePath, apiIdentifier, tenantId, apiProvider, exportFormat);\n+            }\n+            CommonUtil.archiveDirectory(exportAPIBasePath);\n+            FileUtils.deleteQuietly(new File(exportAPIBasePath));\n+            return new File(exportAPIBasePath + APIConstants.ZIP_FILE_EXTENSION);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while getting governance registry for tenant: \" + tenantId;\n+            throw new APIManagementException(errorMessage, e);\n+        } catch (APIManagementException | APIImportExportException e) {\n+            RestApiUtil.handleInternalServerError(\"Error while exporting \" + RestApiConstants.RESOURCE_API, e, log);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Exports an API Product from API Manager for a given API Product. MMeta information, API Product icon, documentation, client certificates\n+     * and dependent APIs are exported.\n+     *\n+     * @param apiProvider           API Provider\n+     * @param apiProductIdentifier  API Product Identifier\n+     * @param apiProductDtoToReturn API Product DTO\n+     * @param userName              Username\n+     * @param exportFormat          Format of output documents. Can be YAML or JSON\n+     * @param preserveStatus        Preserve API Product status on export\n+     * @return\n+     * @throws APIManagementException If an error occurs while getting governance registry\n+     */\n+    public static File exportApiProduct(APIProvider apiProvider, APIProductIdentifier apiProductIdentifier,\n+                                        APIProductDTO apiProductDtoToReturn, String userName, ExportFormat exportFormat,\n+                                        Boolean preserveStatus)\n+            throws APIManagementException {\n+        int tenantId = 0;\n+        try {\n+            // Create temp location for storing API Product data\n+            File exportFolder = CommonUtil.createTempDirectory(apiProductIdentifier);\n+            String exportAPIBasePath = exportFolder.toString();\n+            String archivePath = exportAPIBasePath.concat(File.separator + apiProductIdentifier.getName() + \"-\"\n+                    + apiProductIdentifier.getVersion());\n+            tenantId = APIUtil.getTenantId(userName);\n+            UserRegistry registry = ServiceReferenceHolder.getInstance().getRegistryService().\n+                    getGovernanceSystemRegistry(tenantId);\n+            APIProduct apiProduct = APIMappingUtil.fromDTOtoAPIProduct(apiProductDtoToReturn, userName);\n+\n+            CommonUtil.createDirectory(archivePath);\n+\n+            addThumbnailToArchive(archivePath, apiProductIdentifier, registry);\n+            addDocumentationToArchive(archivePath, apiProductIdentifier, registry, exportFormat, apiProvider);\n+            addAPIProductMetaInformationToArchive(archivePath, apiProductDtoToReturn, exportFormat, apiProvider,\n+                    userName);\n+            addDependentAPIsToArchive(archivePath, apiProductDtoToReturn, exportFormat, apiProvider, userName,\n+                    preserveStatus);\n+\n+            // Export mTLS authentication related certificates\n+            if (apiProvider.isClientCertificateBasedAuthenticationConfigured()) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Mutual SSL enabled. Exporting client certificates.\");\n+                }\n+                addClientCertificatesToArchive(archivePath, apiProductIdentifier, tenantId, apiProvider, exportFormat);\n+            }\n+            CommonUtil.archiveDirectory(exportAPIBasePath);\n+            FileUtils.deleteQuietly(new File(exportAPIBasePath));\n+            return new File(exportAPIBasePath + APIConstants.ZIP_FILE_EXTENSION);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while getting governance registry for tenant: \" + tenantId;\n+            throw new APIManagementException(errorMessage, e);\n+        } catch (APIManagementException | APIImportExportException e) {\n+            RestApiUtil.handleInternalServerError(\"Error while exporting \" +\n+                    RestApiConstants.RESOURCE_API_PRODUCT, e, log);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Retrieve thumbnail image for the exporting API or API Product and store it in the archive directory.\n+     *\n+     * @param archivePath File path to export the thumbnail image\n+     * @param identifier  ID of the requesting API or API Product\n+     * @param registry    Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addThumbnailToArchive(String archivePath, Identifier identifier, Registry registry)\n+            throws APIImportExportException {\n+        String thumbnailUrl = APIConstants.API_IMAGE_LOCATION + RegistryConstants.PATH_SEPARATOR\n+                + identifier.getProviderName() + RegistryConstants.PATH_SEPARATOR + identifier.getName()\n+                + RegistryConstants.PATH_SEPARATOR + identifier.getVersion() + RegistryConstants.PATH_SEPARATOR\n+                + APIConstants.API_ICON_IMAGE;\n+        String localImagePath = archivePath + File.separator + ImportExportConstants.IMAGE_RESOURCE;\n+        try {\n+            if (registry.resourceExists(thumbnailUrl)) {\n+                Resource icon = registry.get(thumbnailUrl);\n+                String mediaType = icon.getMediaType();\n+                String extension = ImportExportConstants.fileExtensionMapping.get(mediaType);\n+                if (extension != null) {\n+                    CommonUtil.createDirectory(localImagePath);\n+                    try (InputStream imageDataStream = icon.getContentStream();\n+                         OutputStream outputStream = new FileOutputStream(localImagePath + File.separator\n+                                 + APIConstants.API_ICON_IMAGE + APIConstants.DOT + extension)) {\n+                        IOUtils.copy(imageDataStream, outputStream);\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"Thumbnail image retrieved successfully for API/API Product: \" + identifier.getName()\n+                                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                                    + identifier.getVersion());\n+                        }\n+                    }\n+                } else {\n+                    //api gets imported without thumbnail\n+                    log.error(\"Unsupported media type for icon \" + mediaType + \". Skipping thumbnail export.\");\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"Thumbnail URL [\" + thumbnailUrl + \"] does not exists in registry for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion() + \". Skipping thumbnail export.\");\n+            }\n+        } catch (RegistryException e) {\n+            log.error(\"Error while retrieving API/API Product Thumbnail \" + thumbnailUrl, e);\n+        } catch (IOException e) {\n+            //Exception is ignored by logging due to the reason that Thumbnail is not essential for\n+            //an API to be recreated.\n+            log.error(\"I/O error while writing API/API Product Thumbnail: \" + thumbnailUrl + \" to file\", e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve SOAP to REST mediation logic for the exporting API and store it in the archive directory\n+     *\n+     * @param archivePath   File path to export the SOAPToREST mediation logic\n+     * @param apiIdentifier ID of the requesting API\n+     * @param registry      Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addSOAPToRESTMediationToArchive(String archivePath, APIIdentifier apiIdentifier,\n+                                                       UserRegistry registry) throws APIImportExportException {\n+        String soapToRestBaseUrl = \"/apimgt/applicationdata/provider\" + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getProviderName() + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getApiName() + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getVersion() + RegistryConstants.PATH_SEPARATOR +\n+                SOAPToRESTConstants.SOAP_TO_REST_RESOURCE;\n+\n+        InputStream inputStream = null;\n+        OutputStream outputStream = null;\n+        try {\n+            if (registry.resourceExists(soapToRestBaseUrl)) {\n+                Collection inFlow = (org.wso2.carbon.registry.api.Collection) registry.get(soapToRestBaseUrl\n+                        + RegistryConstants.PATH_SEPARATOR + IN);\n+                Collection outFlow = (org.wso2.carbon.registry.api.Collection) registry.get(soapToRestBaseUrl\n+                        + RegistryConstants.PATH_SEPARATOR + OUT);\n+\n+                CommonUtil.createDirectory(archivePath + File.separator + SOAPTOREST + File.separator + IN);\n+                CommonUtil.createDirectory(archivePath + File.separator + SOAPTOREST + File.separator + OUT);\n+                if (inFlow != null) {\n+                    for (String inFlowPath : inFlow.getChildren()) {\n+                        inputStream = registry.get(inFlowPath).getContentStream();\n+                        outputStream = new FileOutputStream(archivePath + File.separator + SOAPTOREST\n+                                + File.separator + IN +\n+                                inFlowPath.substring(inFlowPath.lastIndexOf(RegistryConstants.PATH_SEPARATOR)));\n+                        IOUtils.copy(inputStream, outputStream);\n+                        IOUtils.closeQuietly(inputStream);\n+                        IOUtils.closeQuietly(outputStream);\n+                    }\n+                }\n+                if (outFlow != null) {\n+                    for (String outFlowPath : outFlow.getChildren()) {\n+                        inputStream = registry.get(outFlowPath).getContentStream();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67a7a292f0788f2879e86f6675caf1d27f063c89"}, "originalPosition": 353}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU5NDM1NQ==", "bodyText": "Fixed via 150d9ab", "url": "https://github.com/wso2/carbon-apimgt/pull/9406#discussion_r527594355", "createdAt": "2020-11-20T10:23:49Z", "author": {"login": "wasuradananjith"}, "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/utils/ExportUtils.java", "diffHunk": "@@ -0,0 +1,1087 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.apimgt.rest.api.publisher.v1.utils;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import org.apache.axiom.om.OMElement;\n+import org.apache.commons.codec.binary.Base64;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.json.JSONTokener;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.APIProvider;\n+import org.wso2.carbon.apimgt.api.dto.CertificateMetadataDTO;\n+import org.wso2.carbon.apimgt.api.dto.ClientCertificateDTO;\n+import org.wso2.carbon.apimgt.api.model.API;\n+import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.api.model.APIProduct;\n+import org.wso2.carbon.apimgt.api.model.APIProductIdentifier;\n+import org.wso2.carbon.apimgt.api.model.Documentation;\n+import org.wso2.carbon.apimgt.api.model.Identifier;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.certificatemgt.CertificateManager;\n+import org.wso2.carbon.apimgt.impl.certificatemgt.CertificateManagerImpl;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportException;\n+import org.wso2.carbon.apimgt.impl.importexport.ExportFormat;\n+import org.wso2.carbon.apimgt.impl.importexport.ImportExportConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.utils.CommonUtil;\n+import org.wso2.carbon.apimgt.impl.internal.ServiceReferenceHolder;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.apimgt.impl.wsdl.util.SOAPToRESTConstants;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.APIDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.APIProductDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.MediationPolicyDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.ProductAPIDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.utils.mappings.APIMappingUtil;\n+import org.wso2.carbon.apimgt.rest.api.util.RestApiConstants;\n+import org.wso2.carbon.apimgt.rest.api.util.utils.RestApiUtil;\n+import org.wso2.carbon.registry.api.Collection;\n+import org.wso2.carbon.registry.api.Registry;\n+import org.wso2.carbon.registry.api.RegistryException;\n+import org.wso2.carbon.registry.api.Resource;\n+import org.wso2.carbon.registry.core.RegistryConstants;\n+import org.wso2.carbon.registry.core.session.UserRegistry;\n+import org.wso2.carbon.utils.multitenancy.MultitenantUtils;\n+\n+import javax.xml.namespace.QName;\n+import javax.xml.stream.XMLStreamException;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ExportUtils {\n+\n+    private static final Log log = LogFactory.getLog(ExportUtils.class);\n+    private static final String IN = \"in\";\n+    private static final String OUT = \"out\";\n+    private static final String SOAPTOREST = \"SoapToRest\";\n+\n+    /**\n+     * Validate name, version and provider before exporting an API/API Product\n+     *\n+     * @param name         API/API Product Name\n+     * @param version      API/API Product version\n+     * @param providerName Name of the provider\n+     * @return Name of the provider\n+     * @throws APIManagementException If an error occurs while retrieving the provider name from name, version\n+     *                                and tenant\n+     */\n+    public static String validateExportParams(String name, String version, String providerName)\n+            throws APIManagementException {\n+        if (name == null || version == null) {\n+            RestApiUtil.handleBadRequest(\"'name' (\" + name + \") or 'version' (\" + version\n+                    + \") should not be null.\", log);\n+        }\n+        String apiRequesterDomain = RestApiUtil.getLoggedInUserTenantDomain();\n+\n+        // If provider name is not given\n+        if (StringUtils.isBlank(providerName)) {\n+            // Retrieve the provider who is in same tenant domain and who owns the same API (by comparing\n+            // API name and the version)\n+            providerName = APIUtil.getAPIProviderFromAPINameVersionTenant(name, version, apiRequesterDomain);\n+\n+            // If there is no provider in current domain, the API cannot be exported\n+            if (providerName == null) {\n+                String errorMessage = \"Error occurred while exporting. API: \" + name + \" version: \" + version\n+                        + \" not found\";\n+                RestApiUtil.handleResourceNotFoundError(errorMessage, log);\n+            }\n+        }\n+\n+        if (!StringUtils.equals(MultitenantUtils.getTenantDomain(providerName), apiRequesterDomain)) {\n+            // Not authorized to export requested API\n+            RestApiUtil.handleAuthorizationFailure(RestApiConstants.RESOURCE_API +\n+                    \" name:\" + name + \" version:\" + version + \" provider:\" + providerName, log);\n+        }\n+        return providerName;\n+    }\n+\n+    /**\n+     * Exports an API from API Manager for a given API. Meta information, API icon, documentation,\n+     * WSDL and sequences are exported.\n+     *\n+     * @param apiProvider    API Provider\n+     * @param apiIdentifier  API Identifier\n+     * @param apiDtoToReturn API DTO\n+     * @param userName       Username\n+     * @param exportFormat   Format of output documents. Can be YAML or JSON\n+     * @param preserveStatus Preserve API status on export\n+     * @return\n+     * @throws APIManagementException If an error occurs while getting governance registry\n+     */\n+    public static File exportApi(APIProvider apiProvider, APIIdentifier apiIdentifier, APIDTO apiDtoToReturn,\n+                                 String userName, ExportFormat exportFormat, Boolean preserveStatus)\n+            throws APIManagementException {\n+        int tenantId = 0;\n+        try {\n+            // Create temp location for storing API data\n+            File exportFolder = CommonUtil.createTempDirectory(apiIdentifier);\n+            String exportAPIBasePath = exportFolder.toString();\n+            String archivePath = exportAPIBasePath.concat(File.separator + apiIdentifier.getApiName() + \"-\"\n+                    + apiIdentifier.getVersion());\n+            tenantId = APIUtil.getTenantId(userName);\n+            UserRegistry registry = ServiceReferenceHolder.getInstance().getRegistryService().\n+                    getGovernanceSystemRegistry(tenantId);\n+\n+            CommonUtil.createDirectory(archivePath);\n+\n+            addThumbnailToArchive(archivePath, apiIdentifier, registry);\n+            addSOAPToRESTMediationToArchive(archivePath, apiIdentifier, registry);\n+            addDocumentationToArchive(archivePath, apiIdentifier, registry, exportFormat, apiProvider);\n+\n+            if (StringUtils.isNotEmpty(apiDtoToReturn.getWsdlUrl())) {\n+                addWSDLtoArchive(archivePath, apiIdentifier, registry);\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"No WSDL URL found for API: \" + apiIdentifier + \". Skipping WSDL export.\");\n+            }\n+\n+            addSequencesToArchive(archivePath, apiIdentifier, apiDtoToReturn, registry, exportFormat);\n+\n+            // Set API status to created if the status is not preserved\n+            if (!preserveStatus) {\n+                apiDtoToReturn.setLifeCycleStatus(APIConstants.CREATED);\n+            }\n+\n+            addEndpointCertificatesToArchive(archivePath, apiDtoToReturn, tenantId, exportFormat);\n+            addAPIMetaInformationToArchive(archivePath, apiDtoToReturn, exportFormat, apiProvider, apiIdentifier, userName);\n+\n+            // Export mTLS authentication related certificates\n+            if (apiProvider.isClientCertificateBasedAuthenticationConfigured()) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Mutual SSL enabled. Exporting client certificates.\");\n+                }\n+                addClientCertificatesToArchive(archivePath, apiIdentifier, tenantId, apiProvider, exportFormat);\n+            }\n+            CommonUtil.archiveDirectory(exportAPIBasePath);\n+            FileUtils.deleteQuietly(new File(exportAPIBasePath));\n+            return new File(exportAPIBasePath + APIConstants.ZIP_FILE_EXTENSION);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while getting governance registry for tenant: \" + tenantId;\n+            throw new APIManagementException(errorMessage, e);\n+        } catch (APIManagementException | APIImportExportException e) {\n+            RestApiUtil.handleInternalServerError(\"Error while exporting \" + RestApiConstants.RESOURCE_API, e, log);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Exports an API Product from API Manager for a given API Product. MMeta information, API Product icon, documentation, client certificates\n+     * and dependent APIs are exported.\n+     *\n+     * @param apiProvider           API Provider\n+     * @param apiProductIdentifier  API Product Identifier\n+     * @param apiProductDtoToReturn API Product DTO\n+     * @param userName              Username\n+     * @param exportFormat          Format of output documents. Can be YAML or JSON\n+     * @param preserveStatus        Preserve API Product status on export\n+     * @return\n+     * @throws APIManagementException If an error occurs while getting governance registry\n+     */\n+    public static File exportApiProduct(APIProvider apiProvider, APIProductIdentifier apiProductIdentifier,\n+                                        APIProductDTO apiProductDtoToReturn, String userName, ExportFormat exportFormat,\n+                                        Boolean preserveStatus)\n+            throws APIManagementException {\n+        int tenantId = 0;\n+        try {\n+            // Create temp location for storing API Product data\n+            File exportFolder = CommonUtil.createTempDirectory(apiProductIdentifier);\n+            String exportAPIBasePath = exportFolder.toString();\n+            String archivePath = exportAPIBasePath.concat(File.separator + apiProductIdentifier.getName() + \"-\"\n+                    + apiProductIdentifier.getVersion());\n+            tenantId = APIUtil.getTenantId(userName);\n+            UserRegistry registry = ServiceReferenceHolder.getInstance().getRegistryService().\n+                    getGovernanceSystemRegistry(tenantId);\n+            APIProduct apiProduct = APIMappingUtil.fromDTOtoAPIProduct(apiProductDtoToReturn, userName);\n+\n+            CommonUtil.createDirectory(archivePath);\n+\n+            addThumbnailToArchive(archivePath, apiProductIdentifier, registry);\n+            addDocumentationToArchive(archivePath, apiProductIdentifier, registry, exportFormat, apiProvider);\n+            addAPIProductMetaInformationToArchive(archivePath, apiProductDtoToReturn, exportFormat, apiProvider,\n+                    userName);\n+            addDependentAPIsToArchive(archivePath, apiProductDtoToReturn, exportFormat, apiProvider, userName,\n+                    preserveStatus);\n+\n+            // Export mTLS authentication related certificates\n+            if (apiProvider.isClientCertificateBasedAuthenticationConfigured()) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Mutual SSL enabled. Exporting client certificates.\");\n+                }\n+                addClientCertificatesToArchive(archivePath, apiProductIdentifier, tenantId, apiProvider, exportFormat);\n+            }\n+            CommonUtil.archiveDirectory(exportAPIBasePath);\n+            FileUtils.deleteQuietly(new File(exportAPIBasePath));\n+            return new File(exportAPIBasePath + APIConstants.ZIP_FILE_EXTENSION);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while getting governance registry for tenant: \" + tenantId;\n+            throw new APIManagementException(errorMessage, e);\n+        } catch (APIManagementException | APIImportExportException e) {\n+            RestApiUtil.handleInternalServerError(\"Error while exporting \" +\n+                    RestApiConstants.RESOURCE_API_PRODUCT, e, log);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Retrieve thumbnail image for the exporting API or API Product and store it in the archive directory.\n+     *\n+     * @param archivePath File path to export the thumbnail image\n+     * @param identifier  ID of the requesting API or API Product\n+     * @param registry    Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addThumbnailToArchive(String archivePath, Identifier identifier, Registry registry)\n+            throws APIImportExportException {\n+        String thumbnailUrl = APIConstants.API_IMAGE_LOCATION + RegistryConstants.PATH_SEPARATOR\n+                + identifier.getProviderName() + RegistryConstants.PATH_SEPARATOR + identifier.getName()\n+                + RegistryConstants.PATH_SEPARATOR + identifier.getVersion() + RegistryConstants.PATH_SEPARATOR\n+                + APIConstants.API_ICON_IMAGE;\n+        String localImagePath = archivePath + File.separator + ImportExportConstants.IMAGE_RESOURCE;\n+        try {\n+            if (registry.resourceExists(thumbnailUrl)) {\n+                Resource icon = registry.get(thumbnailUrl);\n+                String mediaType = icon.getMediaType();\n+                String extension = ImportExportConstants.fileExtensionMapping.get(mediaType);\n+                if (extension != null) {\n+                    CommonUtil.createDirectory(localImagePath);\n+                    try (InputStream imageDataStream = icon.getContentStream();\n+                         OutputStream outputStream = new FileOutputStream(localImagePath + File.separator\n+                                 + APIConstants.API_ICON_IMAGE + APIConstants.DOT + extension)) {\n+                        IOUtils.copy(imageDataStream, outputStream);\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"Thumbnail image retrieved successfully for API/API Product: \" + identifier.getName()\n+                                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                                    + identifier.getVersion());\n+                        }\n+                    }\n+                } else {\n+                    //api gets imported without thumbnail\n+                    log.error(\"Unsupported media type for icon \" + mediaType + \". Skipping thumbnail export.\");\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"Thumbnail URL [\" + thumbnailUrl + \"] does not exists in registry for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion() + \". Skipping thumbnail export.\");\n+            }\n+        } catch (RegistryException e) {\n+            log.error(\"Error while retrieving API/API Product Thumbnail \" + thumbnailUrl, e);\n+        } catch (IOException e) {\n+            //Exception is ignored by logging due to the reason that Thumbnail is not essential for\n+            //an API to be recreated.\n+            log.error(\"I/O error while writing API/API Product Thumbnail: \" + thumbnailUrl + \" to file\", e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve SOAP to REST mediation logic for the exporting API and store it in the archive directory\n+     *\n+     * @param archivePath   File path to export the SOAPToREST mediation logic\n+     * @param apiIdentifier ID of the requesting API\n+     * @param registry      Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addSOAPToRESTMediationToArchive(String archivePath, APIIdentifier apiIdentifier,\n+                                                       UserRegistry registry) throws APIImportExportException {\n+        String soapToRestBaseUrl = \"/apimgt/applicationdata/provider\" + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getProviderName() + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getApiName() + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getVersion() + RegistryConstants.PATH_SEPARATOR +\n+                SOAPToRESTConstants.SOAP_TO_REST_RESOURCE;\n+\n+        InputStream inputStream = null;\n+        OutputStream outputStream = null;\n+        try {\n+            if (registry.resourceExists(soapToRestBaseUrl)) {\n+                Collection inFlow = (org.wso2.carbon.registry.api.Collection) registry.get(soapToRestBaseUrl\n+                        + RegistryConstants.PATH_SEPARATOR + IN);\n+                Collection outFlow = (org.wso2.carbon.registry.api.Collection) registry.get(soapToRestBaseUrl\n+                        + RegistryConstants.PATH_SEPARATOR + OUT);\n+\n+                CommonUtil.createDirectory(archivePath + File.separator + SOAPTOREST + File.separator + IN);\n+                CommonUtil.createDirectory(archivePath + File.separator + SOAPTOREST + File.separator + OUT);\n+                if (inFlow != null) {\n+                    for (String inFlowPath : inFlow.getChildren()) {\n+                        inputStream = registry.get(inFlowPath).getContentStream();\n+                        outputStream = new FileOutputStream(archivePath + File.separator + SOAPTOREST\n+                                + File.separator + IN +\n+                                inFlowPath.substring(inFlowPath.lastIndexOf(RegistryConstants.PATH_SEPARATOR)));\n+                        IOUtils.copy(inputStream, outputStream);\n+                        IOUtils.closeQuietly(inputStream);\n+                        IOUtils.closeQuietly(outputStream);\n+                    }\n+                }\n+                if (outFlow != null) {\n+                    for (String outFlowPath : outFlow.getChildren()) {\n+                        inputStream = registry.get(outFlowPath).getContentStream();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzUzNjMyMA=="}, "originalCommit": {"oid": "67a7a292f0788f2879e86f6675caf1d27f063c89"}, "originalPosition": 353}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNzc0NzU2OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/utils/ExportUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwOTowNzowOVrOH3G5Xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMDoyNDowMVrOH3Jz2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU0NjcxOQ==", "bodyText": "ByteArrayInputStream certificate is accessed after it is closed. Better to use try whit resources to ensure that this is not required.", "url": "https://github.com/wso2/carbon-apimgt/pull/9406#discussion_r527546719", "createdAt": "2020-11-20T09:07:09Z", "author": {"login": "uvindra"}, "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/utils/ExportUtils.java", "diffHunk": "@@ -0,0 +1,1087 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.apimgt.rest.api.publisher.v1.utils;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import org.apache.axiom.om.OMElement;\n+import org.apache.commons.codec.binary.Base64;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.json.JSONTokener;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.APIProvider;\n+import org.wso2.carbon.apimgt.api.dto.CertificateMetadataDTO;\n+import org.wso2.carbon.apimgt.api.dto.ClientCertificateDTO;\n+import org.wso2.carbon.apimgt.api.model.API;\n+import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.api.model.APIProduct;\n+import org.wso2.carbon.apimgt.api.model.APIProductIdentifier;\n+import org.wso2.carbon.apimgt.api.model.Documentation;\n+import org.wso2.carbon.apimgt.api.model.Identifier;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.certificatemgt.CertificateManager;\n+import org.wso2.carbon.apimgt.impl.certificatemgt.CertificateManagerImpl;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportException;\n+import org.wso2.carbon.apimgt.impl.importexport.ExportFormat;\n+import org.wso2.carbon.apimgt.impl.importexport.ImportExportConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.utils.CommonUtil;\n+import org.wso2.carbon.apimgt.impl.internal.ServiceReferenceHolder;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.apimgt.impl.wsdl.util.SOAPToRESTConstants;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.APIDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.APIProductDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.MediationPolicyDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.ProductAPIDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.utils.mappings.APIMappingUtil;\n+import org.wso2.carbon.apimgt.rest.api.util.RestApiConstants;\n+import org.wso2.carbon.apimgt.rest.api.util.utils.RestApiUtil;\n+import org.wso2.carbon.registry.api.Collection;\n+import org.wso2.carbon.registry.api.Registry;\n+import org.wso2.carbon.registry.api.RegistryException;\n+import org.wso2.carbon.registry.api.Resource;\n+import org.wso2.carbon.registry.core.RegistryConstants;\n+import org.wso2.carbon.registry.core.session.UserRegistry;\n+import org.wso2.carbon.utils.multitenancy.MultitenantUtils;\n+\n+import javax.xml.namespace.QName;\n+import javax.xml.stream.XMLStreamException;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ExportUtils {\n+\n+    private static final Log log = LogFactory.getLog(ExportUtils.class);\n+    private static final String IN = \"in\";\n+    private static final String OUT = \"out\";\n+    private static final String SOAPTOREST = \"SoapToRest\";\n+\n+    /**\n+     * Validate name, version and provider before exporting an API/API Product\n+     *\n+     * @param name         API/API Product Name\n+     * @param version      API/API Product version\n+     * @param providerName Name of the provider\n+     * @return Name of the provider\n+     * @throws APIManagementException If an error occurs while retrieving the provider name from name, version\n+     *                                and tenant\n+     */\n+    public static String validateExportParams(String name, String version, String providerName)\n+            throws APIManagementException {\n+        if (name == null || version == null) {\n+            RestApiUtil.handleBadRequest(\"'name' (\" + name + \") or 'version' (\" + version\n+                    + \") should not be null.\", log);\n+        }\n+        String apiRequesterDomain = RestApiUtil.getLoggedInUserTenantDomain();\n+\n+        // If provider name is not given\n+        if (StringUtils.isBlank(providerName)) {\n+            // Retrieve the provider who is in same tenant domain and who owns the same API (by comparing\n+            // API name and the version)\n+            providerName = APIUtil.getAPIProviderFromAPINameVersionTenant(name, version, apiRequesterDomain);\n+\n+            // If there is no provider in current domain, the API cannot be exported\n+            if (providerName == null) {\n+                String errorMessage = \"Error occurred while exporting. API: \" + name + \" version: \" + version\n+                        + \" not found\";\n+                RestApiUtil.handleResourceNotFoundError(errorMessage, log);\n+            }\n+        }\n+\n+        if (!StringUtils.equals(MultitenantUtils.getTenantDomain(providerName), apiRequesterDomain)) {\n+            // Not authorized to export requested API\n+            RestApiUtil.handleAuthorizationFailure(RestApiConstants.RESOURCE_API +\n+                    \" name:\" + name + \" version:\" + version + \" provider:\" + providerName, log);\n+        }\n+        return providerName;\n+    }\n+\n+    /**\n+     * Exports an API from API Manager for a given API. Meta information, API icon, documentation,\n+     * WSDL and sequences are exported.\n+     *\n+     * @param apiProvider    API Provider\n+     * @param apiIdentifier  API Identifier\n+     * @param apiDtoToReturn API DTO\n+     * @param userName       Username\n+     * @param exportFormat   Format of output documents. Can be YAML or JSON\n+     * @param preserveStatus Preserve API status on export\n+     * @return\n+     * @throws APIManagementException If an error occurs while getting governance registry\n+     */\n+    public static File exportApi(APIProvider apiProvider, APIIdentifier apiIdentifier, APIDTO apiDtoToReturn,\n+                                 String userName, ExportFormat exportFormat, Boolean preserveStatus)\n+            throws APIManagementException {\n+        int tenantId = 0;\n+        try {\n+            // Create temp location for storing API data\n+            File exportFolder = CommonUtil.createTempDirectory(apiIdentifier);\n+            String exportAPIBasePath = exportFolder.toString();\n+            String archivePath = exportAPIBasePath.concat(File.separator + apiIdentifier.getApiName() + \"-\"\n+                    + apiIdentifier.getVersion());\n+            tenantId = APIUtil.getTenantId(userName);\n+            UserRegistry registry = ServiceReferenceHolder.getInstance().getRegistryService().\n+                    getGovernanceSystemRegistry(tenantId);\n+\n+            CommonUtil.createDirectory(archivePath);\n+\n+            addThumbnailToArchive(archivePath, apiIdentifier, registry);\n+            addSOAPToRESTMediationToArchive(archivePath, apiIdentifier, registry);\n+            addDocumentationToArchive(archivePath, apiIdentifier, registry, exportFormat, apiProvider);\n+\n+            if (StringUtils.isNotEmpty(apiDtoToReturn.getWsdlUrl())) {\n+                addWSDLtoArchive(archivePath, apiIdentifier, registry);\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"No WSDL URL found for API: \" + apiIdentifier + \". Skipping WSDL export.\");\n+            }\n+\n+            addSequencesToArchive(archivePath, apiIdentifier, apiDtoToReturn, registry, exportFormat);\n+\n+            // Set API status to created if the status is not preserved\n+            if (!preserveStatus) {\n+                apiDtoToReturn.setLifeCycleStatus(APIConstants.CREATED);\n+            }\n+\n+            addEndpointCertificatesToArchive(archivePath, apiDtoToReturn, tenantId, exportFormat);\n+            addAPIMetaInformationToArchive(archivePath, apiDtoToReturn, exportFormat, apiProvider, apiIdentifier, userName);\n+\n+            // Export mTLS authentication related certificates\n+            if (apiProvider.isClientCertificateBasedAuthenticationConfigured()) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Mutual SSL enabled. Exporting client certificates.\");\n+                }\n+                addClientCertificatesToArchive(archivePath, apiIdentifier, tenantId, apiProvider, exportFormat);\n+            }\n+            CommonUtil.archiveDirectory(exportAPIBasePath);\n+            FileUtils.deleteQuietly(new File(exportAPIBasePath));\n+            return new File(exportAPIBasePath + APIConstants.ZIP_FILE_EXTENSION);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while getting governance registry for tenant: \" + tenantId;\n+            throw new APIManagementException(errorMessage, e);\n+        } catch (APIManagementException | APIImportExportException e) {\n+            RestApiUtil.handleInternalServerError(\"Error while exporting \" + RestApiConstants.RESOURCE_API, e, log);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Exports an API Product from API Manager for a given API Product. MMeta information, API Product icon, documentation, client certificates\n+     * and dependent APIs are exported.\n+     *\n+     * @param apiProvider           API Provider\n+     * @param apiProductIdentifier  API Product Identifier\n+     * @param apiProductDtoToReturn API Product DTO\n+     * @param userName              Username\n+     * @param exportFormat          Format of output documents. Can be YAML or JSON\n+     * @param preserveStatus        Preserve API Product status on export\n+     * @return\n+     * @throws APIManagementException If an error occurs while getting governance registry\n+     */\n+    public static File exportApiProduct(APIProvider apiProvider, APIProductIdentifier apiProductIdentifier,\n+                                        APIProductDTO apiProductDtoToReturn, String userName, ExportFormat exportFormat,\n+                                        Boolean preserveStatus)\n+            throws APIManagementException {\n+        int tenantId = 0;\n+        try {\n+            // Create temp location for storing API Product data\n+            File exportFolder = CommonUtil.createTempDirectory(apiProductIdentifier);\n+            String exportAPIBasePath = exportFolder.toString();\n+            String archivePath = exportAPIBasePath.concat(File.separator + apiProductIdentifier.getName() + \"-\"\n+                    + apiProductIdentifier.getVersion());\n+            tenantId = APIUtil.getTenantId(userName);\n+            UserRegistry registry = ServiceReferenceHolder.getInstance().getRegistryService().\n+                    getGovernanceSystemRegistry(tenantId);\n+            APIProduct apiProduct = APIMappingUtil.fromDTOtoAPIProduct(apiProductDtoToReturn, userName);\n+\n+            CommonUtil.createDirectory(archivePath);\n+\n+            addThumbnailToArchive(archivePath, apiProductIdentifier, registry);\n+            addDocumentationToArchive(archivePath, apiProductIdentifier, registry, exportFormat, apiProvider);\n+            addAPIProductMetaInformationToArchive(archivePath, apiProductDtoToReturn, exportFormat, apiProvider,\n+                    userName);\n+            addDependentAPIsToArchive(archivePath, apiProductDtoToReturn, exportFormat, apiProvider, userName,\n+                    preserveStatus);\n+\n+            // Export mTLS authentication related certificates\n+            if (apiProvider.isClientCertificateBasedAuthenticationConfigured()) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Mutual SSL enabled. Exporting client certificates.\");\n+                }\n+                addClientCertificatesToArchive(archivePath, apiProductIdentifier, tenantId, apiProvider, exportFormat);\n+            }\n+            CommonUtil.archiveDirectory(exportAPIBasePath);\n+            FileUtils.deleteQuietly(new File(exportAPIBasePath));\n+            return new File(exportAPIBasePath + APIConstants.ZIP_FILE_EXTENSION);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while getting governance registry for tenant: \" + tenantId;\n+            throw new APIManagementException(errorMessage, e);\n+        } catch (APIManagementException | APIImportExportException e) {\n+            RestApiUtil.handleInternalServerError(\"Error while exporting \" +\n+                    RestApiConstants.RESOURCE_API_PRODUCT, e, log);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Retrieve thumbnail image for the exporting API or API Product and store it in the archive directory.\n+     *\n+     * @param archivePath File path to export the thumbnail image\n+     * @param identifier  ID of the requesting API or API Product\n+     * @param registry    Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addThumbnailToArchive(String archivePath, Identifier identifier, Registry registry)\n+            throws APIImportExportException {\n+        String thumbnailUrl = APIConstants.API_IMAGE_LOCATION + RegistryConstants.PATH_SEPARATOR\n+                + identifier.getProviderName() + RegistryConstants.PATH_SEPARATOR + identifier.getName()\n+                + RegistryConstants.PATH_SEPARATOR + identifier.getVersion() + RegistryConstants.PATH_SEPARATOR\n+                + APIConstants.API_ICON_IMAGE;\n+        String localImagePath = archivePath + File.separator + ImportExportConstants.IMAGE_RESOURCE;\n+        try {\n+            if (registry.resourceExists(thumbnailUrl)) {\n+                Resource icon = registry.get(thumbnailUrl);\n+                String mediaType = icon.getMediaType();\n+                String extension = ImportExportConstants.fileExtensionMapping.get(mediaType);\n+                if (extension != null) {\n+                    CommonUtil.createDirectory(localImagePath);\n+                    try (InputStream imageDataStream = icon.getContentStream();\n+                         OutputStream outputStream = new FileOutputStream(localImagePath + File.separator\n+                                 + APIConstants.API_ICON_IMAGE + APIConstants.DOT + extension)) {\n+                        IOUtils.copy(imageDataStream, outputStream);\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"Thumbnail image retrieved successfully for API/API Product: \" + identifier.getName()\n+                                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                                    + identifier.getVersion());\n+                        }\n+                    }\n+                } else {\n+                    //api gets imported without thumbnail\n+                    log.error(\"Unsupported media type for icon \" + mediaType + \". Skipping thumbnail export.\");\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"Thumbnail URL [\" + thumbnailUrl + \"] does not exists in registry for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion() + \". Skipping thumbnail export.\");\n+            }\n+        } catch (RegistryException e) {\n+            log.error(\"Error while retrieving API/API Product Thumbnail \" + thumbnailUrl, e);\n+        } catch (IOException e) {\n+            //Exception is ignored by logging due to the reason that Thumbnail is not essential for\n+            //an API to be recreated.\n+            log.error(\"I/O error while writing API/API Product Thumbnail: \" + thumbnailUrl + \" to file\", e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve SOAP to REST mediation logic for the exporting API and store it in the archive directory\n+     *\n+     * @param archivePath   File path to export the SOAPToREST mediation logic\n+     * @param apiIdentifier ID of the requesting API\n+     * @param registry      Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addSOAPToRESTMediationToArchive(String archivePath, APIIdentifier apiIdentifier,\n+                                                       UserRegistry registry) throws APIImportExportException {\n+        String soapToRestBaseUrl = \"/apimgt/applicationdata/provider\" + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getProviderName() + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getApiName() + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getVersion() + RegistryConstants.PATH_SEPARATOR +\n+                SOAPToRESTConstants.SOAP_TO_REST_RESOURCE;\n+\n+        InputStream inputStream = null;\n+        OutputStream outputStream = null;\n+        try {\n+            if (registry.resourceExists(soapToRestBaseUrl)) {\n+                Collection inFlow = (org.wso2.carbon.registry.api.Collection) registry.get(soapToRestBaseUrl\n+                        + RegistryConstants.PATH_SEPARATOR + IN);\n+                Collection outFlow = (org.wso2.carbon.registry.api.Collection) registry.get(soapToRestBaseUrl\n+                        + RegistryConstants.PATH_SEPARATOR + OUT);\n+\n+                CommonUtil.createDirectory(archivePath + File.separator + SOAPTOREST + File.separator + IN);\n+                CommonUtil.createDirectory(archivePath + File.separator + SOAPTOREST + File.separator + OUT);\n+                if (inFlow != null) {\n+                    for (String inFlowPath : inFlow.getChildren()) {\n+                        inputStream = registry.get(inFlowPath).getContentStream();\n+                        outputStream = new FileOutputStream(archivePath + File.separator + SOAPTOREST\n+                                + File.separator + IN +\n+                                inFlowPath.substring(inFlowPath.lastIndexOf(RegistryConstants.PATH_SEPARATOR)));\n+                        IOUtils.copy(inputStream, outputStream);\n+                        IOUtils.closeQuietly(inputStream);\n+                        IOUtils.closeQuietly(outputStream);\n+                    }\n+                }\n+                if (outFlow != null) {\n+                    for (String outFlowPath : outFlow.getChildren()) {\n+                        inputStream = registry.get(outFlowPath).getContentStream();\n+                        outputStream = new FileOutputStream(archivePath + File.separator + SOAPTOREST\n+                                + File.separator + OUT +\n+                                outFlowPath.substring(outFlowPath.lastIndexOf(RegistryConstants.PATH_SEPARATOR)));\n+                        IOUtils.copy(inputStream, outputStream);\n+                        IOUtils.closeQuietly(inputStream);\n+                        IOUtils.closeQuietly(outputStream);\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new APIImportExportException(\"I/O error while writing API SOAP to REST logic to file\", e);\n+        } catch (RegistryException e) {\n+            throw new APIImportExportException(\"Error while retrieving SOAP to REST logic\", e);\n+        } finally {\n+            IOUtils.closeQuietly(inputStream);\n+            IOUtils.closeQuietly(outputStream);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve documentation for the exporting API or API Product and store it in the archive directory.\n+     * FILE, INLINE, MARKDOWN and URL documentations are handled.\n+     *\n+     * @param archivePath  File path to export the documents\n+     * @param identifier   ID of the requesting API or API Product\n+     * @param registry     Current tenant registry\n+     * @param exportFormat Format for export\n+     * @param apiProvider  API Provider\n+     * @throws APIImportExportException If an error occurs while retrieving documents from the\n+     *                                  registry or storing in the archive directory\n+     * @throws APIManagementException   If an error occurs while retrieving document details\n+     */\n+    public static void addDocumentationToArchive(String archivePath, Identifier identifier, Registry registry,\n+                                                 ExportFormat exportFormat, APIProvider apiProvider)\n+            throws APIImportExportException, APIManagementException {\n+\n+        List<Documentation> docList = apiProvider.getAllDocumentation(identifier);\n+        String tenantDomain = RestApiUtil.getLoggedInUserTenantDomain();\n+        if (!docList.isEmpty()) {\n+            Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+            String docDirectoryPath = archivePath + File.separator + ImportExportConstants.DOCUMENT_DIRECTORY;\n+            CommonUtil.createDirectory(docDirectoryPath);\n+            try {\n+                for (Documentation doc : docList) {\n+                    // Retrieving the document again since objects in docList might have missing fields\n+                    Documentation individualDocument = apiProvider.getDocumentation(doc.getId(), tenantDomain);\n+                    String sourceType = individualDocument.getSourceType().name();\n+                    String resourcePath = null;\n+                    String localFileName = null;\n+                    String individualDocDirectoryPath = docDirectoryPath + File.separator + individualDocument.getName();\n+                    CommonUtil.createDirectory(individualDocDirectoryPath);\n+                    writeDtoToFile(individualDocDirectoryPath +\n+                                    ImportExportConstants.DOCUMENT_FILE_NAME, exportFormat,\n+                            ImportExportConstants.TYPE_DOCUMENTS, individualDocument);\n+                    if (Documentation.DocumentSourceType.FILE.toString().equalsIgnoreCase(sourceType)) {\n+                        localFileName = individualDocument.getFilePath().substring(\n+                                individualDocument.getFilePath().lastIndexOf(RegistryConstants.PATH_SEPARATOR) + 1);\n+                        resourcePath = APIUtil.getDocumentationFilePath(identifier, localFileName);\n+                        individualDocument.setFilePath(localFileName);\n+                    } else if (Documentation.DocumentSourceType.INLINE.toString().equalsIgnoreCase(sourceType)\n+                            || Documentation.DocumentSourceType.MARKDOWN.toString().equalsIgnoreCase(sourceType)) {\n+                        // Inline/Markdown content file name would be same as the documentation name\n+                        localFileName = individualDocument.getName();\n+                        resourcePath = APIUtil.getAPIOrAPIProductDocPath(identifier) + APIConstants.INLINE_DOCUMENT_CONTENT_DIR\n+                                + RegistryConstants.PATH_SEPARATOR + localFileName;\n+                    }\n+\n+                    if (resourcePath != null) {\n+                        // Write content for Inline/Markdown/File type documentations only\n+                        // Check whether resource exists in the registry\n+                        if (registry.resourceExists(resourcePath)) {\n+                            Resource docFile = registry.get(resourcePath);\n+                            try (OutputStream outputStream = new FileOutputStream(individualDocDirectoryPath +\n+                                    File.separator + localFileName);\n+                                 InputStream fileInputStream = docFile.getContentStream()) {\n+                                IOUtils.copy(fileInputStream, outputStream);\n+                            }\n+                        } else {\n+                            // Log error and avoid throwing as we give capability to export document artifact without the\n+                            // content if does not exists\n+                            String errorMessage = \"Documentation resource for API/API Product: \" + identifier.getName()\n+                                    + \" not found in \" + resourcePath;\n+                            log.error(errorMessage);\n+                        }\n+                    }\n+                }\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Documentation retrieved successfully for API/API Product: \" + identifier.getName()\n+                            + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + identifier.getVersion());\n+                }\n+            } catch (IOException e) {\n+                String errorMessage = \"I/O error while writing documentation to file for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion();\n+                log.error(errorMessage, e);\n+                throw new APIImportExportException(errorMessage, e);\n+            } catch (RegistryException e) {\n+                String errorMessage = \"Error while retrieving documentation for API/API Product: \" + identifier.getName()\n+                        + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + identifier.getVersion();\n+                log.error(errorMessage, e);\n+                throw new APIImportExportException(errorMessage, e);\n+            }\n+        } else if (log.isDebugEnabled()) {\n+            log.debug(\"No documentation found for API/API Product: \" + identifier + \". Skipping documentation export.\");\n+        }\n+    }\n+\n+    /**\n+     * Retrieve WSDL for the exporting API and store it in the archive directory.\n+     *\n+     * @param archivePath   File path to export the WSDL\n+     * @param apiIdentifier ID of the requesting API\n+     * @param registry      Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving WSDL from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addWSDLtoArchive(String archivePath, APIIdentifier apiIdentifier, Registry registry)\n+            throws APIImportExportException {\n+\n+        String wsdlPath = APIConstants.API_WSDL_RESOURCE_LOCATION + apiIdentifier.getProviderName() + \"--\"\n+                + apiIdentifier.getApiName() + apiIdentifier.getVersion() + APIConstants.WSDL_FILE_EXTENSION;\n+        try {\n+            if (registry.resourceExists(wsdlPath)) {\n+                CommonUtil.createDirectory(archivePath + File.separator + \"WSDL\");\n+                Resource wsdl = registry.get(wsdlPath);\n+                try (InputStream wsdlStream = wsdl.getContentStream();\n+                     OutputStream outputStream = new FileOutputStream(archivePath + File.separator + \"WSDL\"\n+                             + File.separator + apiIdentifier.getApiName() + \"-\" + apiIdentifier.getVersion()\n+                             + APIConstants.WSDL_FILE_EXTENSION)) {\n+                    IOUtils.copy(wsdlStream, outputStream);\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"WSDL file: \" + wsdlPath + \" retrieved successfully\");\n+                    }\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"WSDL resource does not exists in path: \" + wsdlPath + \". Skipping WSDL export.\");\n+            }\n+        } catch (IOException e) {\n+            String errorMessage = \"I/O error while writing WSDL: \" + wsdlPath + \" to file\";\n+            throw new APIImportExportException(errorMessage, e);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while retrieving WSDL: \" + wsdlPath + \" to file\";\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve available custom sequences and API specific sequences for API export, and store it in the archive\n+     * directory.\n+     *\n+     * @param archivePath   File path to export the sequences\n+     * @param apiIdentifier API Identifier\n+     * @param apiDto        API DTO\n+     * @param registry      Current tenant registry\n+     * @param exportFormat  Export format of file\n+     * @throws APIImportExportException If an error occurs while exporting sequences\n+     */\n+    public static void addSequencesToArchive(String archivePath, APIIdentifier apiIdentifier, APIDTO apiDto,\n+                                             Registry registry, ExportFormat exportFormat) throws APIImportExportException {\n+\n+        Map<String, String> sequences = new HashMap<>();\n+        String seqArchivePath = archivePath.concat(File.separator + \"Sequences\");\n+        List<MediationPolicyDTO> mediationPolicyDtos = apiDto.getMediationPolicies();\n+        if (!apiDto.getMediationPolicies().isEmpty()) {\n+            CommonUtil.createDirectory(seqArchivePath);\n+            for (MediationPolicyDTO mediationPolicyDto : mediationPolicyDtos) {\n+                AbstractMap.SimpleEntry<String, OMElement> sequenceDetails;\n+                String sequenceName = mediationPolicyDto.getName();\n+                String direction = mediationPolicyDto.getType().toLowerCase();\n+                String pathToExportedSequence = seqArchivePath + File.separator + direction + \"-sequence\" +\n+                        File.separator;\n+                String pathToIndividualSequenceFile = pathToExportedSequence + ImportExportConstants.SEQUENCE_FILE_NAME;\n+                if (sequenceName != null) {\n+                    sequenceDetails = getCustomSequence(sequenceName, direction, registry);\n+                    if (sequenceDetails == null) {\n+                        // If sequence doesn't exist in 'apimgt/customsequences/{in/out/fault}' directory check in API\n+                        // specific registry path\n+                        sequenceDetails = getAPISpecificSequence(apiIdentifier, sequenceName, direction, registry);\n+                        pathToExportedSequence += ImportExportConstants.CUSTOM_TYPE + File.separator;\n+                    }\n+                    writeSequenceToFile(pathToExportedSequence, sequenceDetails, apiIdentifier);\n+                    try {\n+                        writeDtoToFile(pathToIndividualSequenceFile, exportFormat, ImportExportConstants.TYPE_SEQUENCE,\n+                                mediationPolicyDto);\n+                    } catch (IOException e) {\n+                        String errorMessage = \"I/O error while writing sequence: \" + sequenceName + \" to file\";\n+                        throw new APIImportExportException(errorMessage, e);\n+                    }\n+                }\n+            }\n+        } else if (log.isDebugEnabled()) {\n+            log.debug(\"No custom sequences available for API: \" + apiIdentifier.getApiName() + StringUtils.SPACE\n+                    + APIConstants.API_DATA_VERSION + \": \" + apiIdentifier.getVersion()\n+                    + \". Skipping custom sequence export.\");\n+        }\n+    }\n+\n+    /**\n+     * Retrieve custom sequence details from the registry.\n+     *\n+     * @param sequenceName Name of the sequence\n+     * @param type         Sequence type\n+     * @param registry     Current tenant registry\n+     * @return Registry resource name of the sequence and its content\n+     * @throws APIImportExportException If an error occurs while retrieving registry elements\n+     */\n+    private static AbstractMap.SimpleEntry<String, OMElement> getCustomSequence(String sequenceName, String type,\n+                                                                                Registry registry)\n+            throws APIImportExportException {\n+\n+        String regPath = null;\n+        if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_IN.equals(type)) {\n+            regPath = APIConstants.API_CUSTOM_INSEQUENCE_LOCATION;\n+        } else if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_OUT.equals(type)) {\n+            regPath = APIConstants.API_CUSTOM_OUTSEQUENCE_LOCATION;\n+        } else if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_FAULT.equals(type)) {\n+            regPath = APIConstants.API_CUSTOM_FAULTSEQUENCE_LOCATION;\n+        }\n+        return getSeqDetailsFromRegistry(sequenceName, regPath, registry);\n+    }\n+\n+    /**\n+     * Retrieve API Specific sequence details from the registry.\n+     *\n+     * @param sequenceName Name of the sequence\n+     * @param type         Sequence type\n+     * @param registry     Current tenant registry\n+     * @return Registry resource name of the sequence and its content\n+     * @throws APIImportExportException If an error occurs while retrieving registry elements\n+     */\n+    private static AbstractMap.SimpleEntry<String, OMElement> getAPISpecificSequence(APIIdentifier api,\n+                                                                                     String sequenceName, String type,\n+                                                                                     Registry registry)\n+            throws APIImportExportException {\n+\n+        String regPath = APIConstants.API_ROOT_LOCATION + RegistryConstants.PATH_SEPARATOR + api.getProviderName()\n+                + RegistryConstants.PATH_SEPARATOR + api.getApiName() + RegistryConstants.PATH_SEPARATOR\n+                + api.getVersion() + RegistryConstants.PATH_SEPARATOR + type;\n+        return getSeqDetailsFromRegistry(sequenceName, regPath, registry);\n+    }\n+\n+    /**\n+     * Retrieve sequence details from registry by given registry path.\n+     *\n+     * @param sequenceName Sequence Name\n+     * @param regPath      Registry path\n+     * @param registry     Registry\n+     * @return Sequence details as a simple entry\n+     * @throws APIImportExportException If an error occurs while retrieving sequence details from registry\n+     */\n+    private static AbstractMap.SimpleEntry<String, OMElement> getSeqDetailsFromRegistry(String sequenceName,\n+                                                                                        String regPath, Registry registry)\n+            throws APIImportExportException {\n+\n+        AbstractMap.SimpleEntry<String, OMElement> sequenceDetails = null;\n+        Collection seqCollection;\n+\n+        try {\n+            seqCollection = (Collection) registry.get(regPath);\n+            if (seqCollection != null) {\n+                String[] childPaths = seqCollection.getChildren();\n+                for (String childPath : childPaths) {\n+                    Resource sequence = registry.get(childPath);\n+                    OMElement seqElement = APIUtil.buildOMElement(sequence.getContentStream());\n+                    if (sequenceName.equals(seqElement.getAttributeValue(new QName(\"name\")))) {\n+                        String sequenceFileName = sequenceName + APIConstants.XML_EXTENSION;\n+                        sequenceDetails = new AbstractMap.SimpleEntry<>(sequenceFileName, seqElement);\n+                        break;\n+                    }\n+                }\n+            }\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while retrieving sequence: \" + sequenceName + \" from the path: \" + regPath;\n+            throw new APIImportExportException(errorMessage, e);\n+        } catch (Exception e) {\n+            //APIUtil.buildOMElement() throws a generic exception\n+            String errorMessage = \"Error while reading content for sequence: \" + sequenceName + \" from the registry\";\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+        return sequenceDetails;\n+    }\n+\n+    /**\n+     * Store API Specific or custom sequences in the archive directory.\n+     *\n+     * @param sequenceDetails Details of the sequence\n+     * @param apiIdentifier   ID of the requesting API\n+     * @throws APIImportExportException If an error occurs while serializing XML stream or storing in\n+     *                                  archive directory\n+     */\n+    private static void writeSequenceToFile(String pathToExportedSequence,\n+                                            AbstractMap.SimpleEntry<String, OMElement> sequenceDetails,\n+                                            APIIdentifier apiIdentifier)\n+            throws APIImportExportException {\n+\n+        if (sequenceDetails != null) {\n+            String sequenceFileName = sequenceDetails.getKey();\n+            OMElement sequenceConfig = sequenceDetails.getValue();\n+            CommonUtil.createDirectory(pathToExportedSequence);\n+            String exportedSequenceFile = pathToExportedSequence + sequenceFileName;\n+            try (OutputStream outputStream = new FileOutputStream(exportedSequenceFile)) {\n+                sequenceConfig.serialize(outputStream);\n+                if (log.isDebugEnabled()) {\n+                    log.debug(sequenceFileName + \" of API: \" + apiIdentifier.getApiName() + \" retrieved successfully\");\n+                }\n+            } catch (IOException e) {\n+                String errorMessage = \"Unable to find file: \" + exportedSequenceFile;\n+                throw new APIImportExportException(errorMessage, e);\n+            } catch (XMLStreamException e) {\n+                String errorMessage = \"Error while processing XML stream \";\n+                throw new APIImportExportException(errorMessage, e);\n+            }\n+        } else {\n+            String errorMessage = \"Error while writing sequence of API: \" + apiIdentifier.getApiName() + \" to file.\";\n+            throw new APIImportExportException(errorMessage);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve the endpoint certificates and store those in the archive directory.\n+     *\n+     * @param archivePath  File path to export the endpoint certificates\n+     * @param apiDto       API DTO to be exported\n+     * @param tenantId     Tenant id of the user\n+     * @param exportFormat Export format of file\n+     * @throws APIImportExportException If an error occurs while exporting endpoint certificates\n+     */\n+    public static void addEndpointCertificatesToArchive(String archivePath, APIDTO apiDto, int tenantId,\n+                                                        ExportFormat exportFormat) throws APIImportExportException {\n+        List<String> productionEndpoints;\n+        List<String> sandboxEndpoints;\n+        Set<String> uniqueEndpointURLs = new HashSet<>();\n+        JsonArray endpointCertificatesDetails = new JsonArray();\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        String endpointConfigString = gson.toJson(apiDto.getEndpointConfig());\n+        String endpointCertsDirectoryPath = archivePath + File.separator\n+                + ImportExportConstants.ENDPOINT_CERTIFICATES_DIRECTORY;\n+        CommonUtil.createDirectory(endpointCertsDirectoryPath);\n+\n+        if (StringUtils.isEmpty(endpointConfigString)) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Endpoint Details are empty for API: \" + apiDto.getName() + StringUtils.SPACE\n+                        + APIConstants.API_DATA_VERSION + \": \" + apiDto.getVersion());\n+            }\n+            return;\n+        }\n+        try {\n+            JSONTokener tokener = new JSONTokener(endpointConfigString);\n+            JSONObject endpointConfig = new JSONObject(tokener);\n+            productionEndpoints = getEndpointURLs(endpointConfig, APIConstants.API_DATA_PRODUCTION_ENDPOINTS,\n+                    apiDto.getName());\n+            sandboxEndpoints = getEndpointURLs(endpointConfig, APIConstants.API_DATA_SANDBOX_ENDPOINTS,\n+                    apiDto.getName());\n+            uniqueEndpointURLs.addAll(productionEndpoints); // Remove duplicate and append result\n+            uniqueEndpointURLs.addAll(sandboxEndpoints);\n+\n+            for (String url : uniqueEndpointURLs) {\n+                JsonArray certificateListOfUrl = getEndpointCertificateContentAndMetaData(tenantId, url,\n+                        endpointCertsDirectoryPath);\n+                endpointCertificatesDetails.addAll(certificateListOfUrl);\n+            }\n+            if (endpointCertificatesDetails.size() > 0) {\n+                writeDtoToFile(endpointCertsDirectoryPath +\n+                                ImportExportConstants.ENDPOINTS_CERTIFICATE_FILE, exportFormat,\n+                        ImportExportConstants.TYPE_ENDPOINT_CERTIFICATES, endpointCertificatesDetails);\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"No endpoint certificates available for API: \" + apiDto.getName() + StringUtils.SPACE\n+                        + APIConstants.API_DATA_VERSION + \": \" + apiDto.getVersion() + \". Skipping certificate export.\");\n+            }\n+        } catch (JSONException e) {\n+            String errorMsg = \"Error in converting Endpoint config to JSON object in API: \" + apiDto.getName();\n+            throw new APIImportExportException(errorMsg, e);\n+        } catch (IOException e) {\n+            String errorMessage = \"Error while retrieving saving endpoint certificate details for API: \"\n+                    + apiDto.getName() + \" as YAML\";\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Get Endpoint Certificate MetaData and Certificate detail and build JSON Array.\n+     *\n+     * @param tenantId          Tenant id of the user\n+     * @param url               Url of the endpoint\n+     * @param certDirectoryPath Directory path to export the certificates\n+     * @return JSON Array of certificate details\n+     * @throws APIImportExportException If an error occurs while retrieving endpoint certificate metadata and content\n+     */\n+    private static JsonArray getEndpointCertificateContentAndMetaData(int tenantId, String url,\n+                                                                      String certDirectoryPath)\n+            throws APIImportExportException {\n+\n+        List<CertificateMetadataDTO> certificateMetadataDTOS;\n+        CertificateManager certificateManager = CertificateManagerImpl.getInstance();\n+\n+        try {\n+            certificateMetadataDTOS = certificateManager.getCertificates(tenantId, null, url);\n+        } catch (APIManagementException e) {\n+            String errorMsg = \"Error retrieving certificate meta data. For tenantId: \" + tenantId + \" hostname: \"\n+                    + url;\n+            throw new APIImportExportException(errorMsg, e);\n+        }\n+\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        JsonArray certificatesList = new JsonArray();\n+        certificateMetadataDTOS.forEach(metadataDTO -> {\n+            ByteArrayInputStream certificate = null;\n+            try {\n+                certificate = certificateManager.getCertificateContent(metadataDTO.getAlias());\n+                certificate.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67a7a292f0788f2879e86f6675caf1d27f063c89"}, "originalPosition": 763}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU5NDQ1Ng==", "bodyText": "Fixed via 150d9ab", "url": "https://github.com/wso2/carbon-apimgt/pull/9406#discussion_r527594456", "createdAt": "2020-11-20T10:24:01Z", "author": {"login": "wasuradananjith"}, "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/utils/ExportUtils.java", "diffHunk": "@@ -0,0 +1,1087 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.apimgt.rest.api.publisher.v1.utils;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import org.apache.axiom.om.OMElement;\n+import org.apache.commons.codec.binary.Base64;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.json.JSONTokener;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.APIProvider;\n+import org.wso2.carbon.apimgt.api.dto.CertificateMetadataDTO;\n+import org.wso2.carbon.apimgt.api.dto.ClientCertificateDTO;\n+import org.wso2.carbon.apimgt.api.model.API;\n+import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.api.model.APIProduct;\n+import org.wso2.carbon.apimgt.api.model.APIProductIdentifier;\n+import org.wso2.carbon.apimgt.api.model.Documentation;\n+import org.wso2.carbon.apimgt.api.model.Identifier;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.certificatemgt.CertificateManager;\n+import org.wso2.carbon.apimgt.impl.certificatemgt.CertificateManagerImpl;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportException;\n+import org.wso2.carbon.apimgt.impl.importexport.ExportFormat;\n+import org.wso2.carbon.apimgt.impl.importexport.ImportExportConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.utils.CommonUtil;\n+import org.wso2.carbon.apimgt.impl.internal.ServiceReferenceHolder;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.apimgt.impl.wsdl.util.SOAPToRESTConstants;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.APIDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.APIProductDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.MediationPolicyDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.ProductAPIDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.utils.mappings.APIMappingUtil;\n+import org.wso2.carbon.apimgt.rest.api.util.RestApiConstants;\n+import org.wso2.carbon.apimgt.rest.api.util.utils.RestApiUtil;\n+import org.wso2.carbon.registry.api.Collection;\n+import org.wso2.carbon.registry.api.Registry;\n+import org.wso2.carbon.registry.api.RegistryException;\n+import org.wso2.carbon.registry.api.Resource;\n+import org.wso2.carbon.registry.core.RegistryConstants;\n+import org.wso2.carbon.registry.core.session.UserRegistry;\n+import org.wso2.carbon.utils.multitenancy.MultitenantUtils;\n+\n+import javax.xml.namespace.QName;\n+import javax.xml.stream.XMLStreamException;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ExportUtils {\n+\n+    private static final Log log = LogFactory.getLog(ExportUtils.class);\n+    private static final String IN = \"in\";\n+    private static final String OUT = \"out\";\n+    private static final String SOAPTOREST = \"SoapToRest\";\n+\n+    /**\n+     * Validate name, version and provider before exporting an API/API Product\n+     *\n+     * @param name         API/API Product Name\n+     * @param version      API/API Product version\n+     * @param providerName Name of the provider\n+     * @return Name of the provider\n+     * @throws APIManagementException If an error occurs while retrieving the provider name from name, version\n+     *                                and tenant\n+     */\n+    public static String validateExportParams(String name, String version, String providerName)\n+            throws APIManagementException {\n+        if (name == null || version == null) {\n+            RestApiUtil.handleBadRequest(\"'name' (\" + name + \") or 'version' (\" + version\n+                    + \") should not be null.\", log);\n+        }\n+        String apiRequesterDomain = RestApiUtil.getLoggedInUserTenantDomain();\n+\n+        // If provider name is not given\n+        if (StringUtils.isBlank(providerName)) {\n+            // Retrieve the provider who is in same tenant domain and who owns the same API (by comparing\n+            // API name and the version)\n+            providerName = APIUtil.getAPIProviderFromAPINameVersionTenant(name, version, apiRequesterDomain);\n+\n+            // If there is no provider in current domain, the API cannot be exported\n+            if (providerName == null) {\n+                String errorMessage = \"Error occurred while exporting. API: \" + name + \" version: \" + version\n+                        + \" not found\";\n+                RestApiUtil.handleResourceNotFoundError(errorMessage, log);\n+            }\n+        }\n+\n+        if (!StringUtils.equals(MultitenantUtils.getTenantDomain(providerName), apiRequesterDomain)) {\n+            // Not authorized to export requested API\n+            RestApiUtil.handleAuthorizationFailure(RestApiConstants.RESOURCE_API +\n+                    \" name:\" + name + \" version:\" + version + \" provider:\" + providerName, log);\n+        }\n+        return providerName;\n+    }\n+\n+    /**\n+     * Exports an API from API Manager for a given API. Meta information, API icon, documentation,\n+     * WSDL and sequences are exported.\n+     *\n+     * @param apiProvider    API Provider\n+     * @param apiIdentifier  API Identifier\n+     * @param apiDtoToReturn API DTO\n+     * @param userName       Username\n+     * @param exportFormat   Format of output documents. Can be YAML or JSON\n+     * @param preserveStatus Preserve API status on export\n+     * @return\n+     * @throws APIManagementException If an error occurs while getting governance registry\n+     */\n+    public static File exportApi(APIProvider apiProvider, APIIdentifier apiIdentifier, APIDTO apiDtoToReturn,\n+                                 String userName, ExportFormat exportFormat, Boolean preserveStatus)\n+            throws APIManagementException {\n+        int tenantId = 0;\n+        try {\n+            // Create temp location for storing API data\n+            File exportFolder = CommonUtil.createTempDirectory(apiIdentifier);\n+            String exportAPIBasePath = exportFolder.toString();\n+            String archivePath = exportAPIBasePath.concat(File.separator + apiIdentifier.getApiName() + \"-\"\n+                    + apiIdentifier.getVersion());\n+            tenantId = APIUtil.getTenantId(userName);\n+            UserRegistry registry = ServiceReferenceHolder.getInstance().getRegistryService().\n+                    getGovernanceSystemRegistry(tenantId);\n+\n+            CommonUtil.createDirectory(archivePath);\n+\n+            addThumbnailToArchive(archivePath, apiIdentifier, registry);\n+            addSOAPToRESTMediationToArchive(archivePath, apiIdentifier, registry);\n+            addDocumentationToArchive(archivePath, apiIdentifier, registry, exportFormat, apiProvider);\n+\n+            if (StringUtils.isNotEmpty(apiDtoToReturn.getWsdlUrl())) {\n+                addWSDLtoArchive(archivePath, apiIdentifier, registry);\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"No WSDL URL found for API: \" + apiIdentifier + \". Skipping WSDL export.\");\n+            }\n+\n+            addSequencesToArchive(archivePath, apiIdentifier, apiDtoToReturn, registry, exportFormat);\n+\n+            // Set API status to created if the status is not preserved\n+            if (!preserveStatus) {\n+                apiDtoToReturn.setLifeCycleStatus(APIConstants.CREATED);\n+            }\n+\n+            addEndpointCertificatesToArchive(archivePath, apiDtoToReturn, tenantId, exportFormat);\n+            addAPIMetaInformationToArchive(archivePath, apiDtoToReturn, exportFormat, apiProvider, apiIdentifier, userName);\n+\n+            // Export mTLS authentication related certificates\n+            if (apiProvider.isClientCertificateBasedAuthenticationConfigured()) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Mutual SSL enabled. Exporting client certificates.\");\n+                }\n+                addClientCertificatesToArchive(archivePath, apiIdentifier, tenantId, apiProvider, exportFormat);\n+            }\n+            CommonUtil.archiveDirectory(exportAPIBasePath);\n+            FileUtils.deleteQuietly(new File(exportAPIBasePath));\n+            return new File(exportAPIBasePath + APIConstants.ZIP_FILE_EXTENSION);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while getting governance registry for tenant: \" + tenantId;\n+            throw new APIManagementException(errorMessage, e);\n+        } catch (APIManagementException | APIImportExportException e) {\n+            RestApiUtil.handleInternalServerError(\"Error while exporting \" + RestApiConstants.RESOURCE_API, e, log);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Exports an API Product from API Manager for a given API Product. MMeta information, API Product icon, documentation, client certificates\n+     * and dependent APIs are exported.\n+     *\n+     * @param apiProvider           API Provider\n+     * @param apiProductIdentifier  API Product Identifier\n+     * @param apiProductDtoToReturn API Product DTO\n+     * @param userName              Username\n+     * @param exportFormat          Format of output documents. Can be YAML or JSON\n+     * @param preserveStatus        Preserve API Product status on export\n+     * @return\n+     * @throws APIManagementException If an error occurs while getting governance registry\n+     */\n+    public static File exportApiProduct(APIProvider apiProvider, APIProductIdentifier apiProductIdentifier,\n+                                        APIProductDTO apiProductDtoToReturn, String userName, ExportFormat exportFormat,\n+                                        Boolean preserveStatus)\n+            throws APIManagementException {\n+        int tenantId = 0;\n+        try {\n+            // Create temp location for storing API Product data\n+            File exportFolder = CommonUtil.createTempDirectory(apiProductIdentifier);\n+            String exportAPIBasePath = exportFolder.toString();\n+            String archivePath = exportAPIBasePath.concat(File.separator + apiProductIdentifier.getName() + \"-\"\n+                    + apiProductIdentifier.getVersion());\n+            tenantId = APIUtil.getTenantId(userName);\n+            UserRegistry registry = ServiceReferenceHolder.getInstance().getRegistryService().\n+                    getGovernanceSystemRegistry(tenantId);\n+            APIProduct apiProduct = APIMappingUtil.fromDTOtoAPIProduct(apiProductDtoToReturn, userName);\n+\n+            CommonUtil.createDirectory(archivePath);\n+\n+            addThumbnailToArchive(archivePath, apiProductIdentifier, registry);\n+            addDocumentationToArchive(archivePath, apiProductIdentifier, registry, exportFormat, apiProvider);\n+            addAPIProductMetaInformationToArchive(archivePath, apiProductDtoToReturn, exportFormat, apiProvider,\n+                    userName);\n+            addDependentAPIsToArchive(archivePath, apiProductDtoToReturn, exportFormat, apiProvider, userName,\n+                    preserveStatus);\n+\n+            // Export mTLS authentication related certificates\n+            if (apiProvider.isClientCertificateBasedAuthenticationConfigured()) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Mutual SSL enabled. Exporting client certificates.\");\n+                }\n+                addClientCertificatesToArchive(archivePath, apiProductIdentifier, tenantId, apiProvider, exportFormat);\n+            }\n+            CommonUtil.archiveDirectory(exportAPIBasePath);\n+            FileUtils.deleteQuietly(new File(exportAPIBasePath));\n+            return new File(exportAPIBasePath + APIConstants.ZIP_FILE_EXTENSION);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while getting governance registry for tenant: \" + tenantId;\n+            throw new APIManagementException(errorMessage, e);\n+        } catch (APIManagementException | APIImportExportException e) {\n+            RestApiUtil.handleInternalServerError(\"Error while exporting \" +\n+                    RestApiConstants.RESOURCE_API_PRODUCT, e, log);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Retrieve thumbnail image for the exporting API or API Product and store it in the archive directory.\n+     *\n+     * @param archivePath File path to export the thumbnail image\n+     * @param identifier  ID of the requesting API or API Product\n+     * @param registry    Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addThumbnailToArchive(String archivePath, Identifier identifier, Registry registry)\n+            throws APIImportExportException {\n+        String thumbnailUrl = APIConstants.API_IMAGE_LOCATION + RegistryConstants.PATH_SEPARATOR\n+                + identifier.getProviderName() + RegistryConstants.PATH_SEPARATOR + identifier.getName()\n+                + RegistryConstants.PATH_SEPARATOR + identifier.getVersion() + RegistryConstants.PATH_SEPARATOR\n+                + APIConstants.API_ICON_IMAGE;\n+        String localImagePath = archivePath + File.separator + ImportExportConstants.IMAGE_RESOURCE;\n+        try {\n+            if (registry.resourceExists(thumbnailUrl)) {\n+                Resource icon = registry.get(thumbnailUrl);\n+                String mediaType = icon.getMediaType();\n+                String extension = ImportExportConstants.fileExtensionMapping.get(mediaType);\n+                if (extension != null) {\n+                    CommonUtil.createDirectory(localImagePath);\n+                    try (InputStream imageDataStream = icon.getContentStream();\n+                         OutputStream outputStream = new FileOutputStream(localImagePath + File.separator\n+                                 + APIConstants.API_ICON_IMAGE + APIConstants.DOT + extension)) {\n+                        IOUtils.copy(imageDataStream, outputStream);\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"Thumbnail image retrieved successfully for API/API Product: \" + identifier.getName()\n+                                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                                    + identifier.getVersion());\n+                        }\n+                    }\n+                } else {\n+                    //api gets imported without thumbnail\n+                    log.error(\"Unsupported media type for icon \" + mediaType + \". Skipping thumbnail export.\");\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"Thumbnail URL [\" + thumbnailUrl + \"] does not exists in registry for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion() + \". Skipping thumbnail export.\");\n+            }\n+        } catch (RegistryException e) {\n+            log.error(\"Error while retrieving API/API Product Thumbnail \" + thumbnailUrl, e);\n+        } catch (IOException e) {\n+            //Exception is ignored by logging due to the reason that Thumbnail is not essential for\n+            //an API to be recreated.\n+            log.error(\"I/O error while writing API/API Product Thumbnail: \" + thumbnailUrl + \" to file\", e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve SOAP to REST mediation logic for the exporting API and store it in the archive directory\n+     *\n+     * @param archivePath   File path to export the SOAPToREST mediation logic\n+     * @param apiIdentifier ID of the requesting API\n+     * @param registry      Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addSOAPToRESTMediationToArchive(String archivePath, APIIdentifier apiIdentifier,\n+                                                       UserRegistry registry) throws APIImportExportException {\n+        String soapToRestBaseUrl = \"/apimgt/applicationdata/provider\" + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getProviderName() + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getApiName() + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getVersion() + RegistryConstants.PATH_SEPARATOR +\n+                SOAPToRESTConstants.SOAP_TO_REST_RESOURCE;\n+\n+        InputStream inputStream = null;\n+        OutputStream outputStream = null;\n+        try {\n+            if (registry.resourceExists(soapToRestBaseUrl)) {\n+                Collection inFlow = (org.wso2.carbon.registry.api.Collection) registry.get(soapToRestBaseUrl\n+                        + RegistryConstants.PATH_SEPARATOR + IN);\n+                Collection outFlow = (org.wso2.carbon.registry.api.Collection) registry.get(soapToRestBaseUrl\n+                        + RegistryConstants.PATH_SEPARATOR + OUT);\n+\n+                CommonUtil.createDirectory(archivePath + File.separator + SOAPTOREST + File.separator + IN);\n+                CommonUtil.createDirectory(archivePath + File.separator + SOAPTOREST + File.separator + OUT);\n+                if (inFlow != null) {\n+                    for (String inFlowPath : inFlow.getChildren()) {\n+                        inputStream = registry.get(inFlowPath).getContentStream();\n+                        outputStream = new FileOutputStream(archivePath + File.separator + SOAPTOREST\n+                                + File.separator + IN +\n+                                inFlowPath.substring(inFlowPath.lastIndexOf(RegistryConstants.PATH_SEPARATOR)));\n+                        IOUtils.copy(inputStream, outputStream);\n+                        IOUtils.closeQuietly(inputStream);\n+                        IOUtils.closeQuietly(outputStream);\n+                    }\n+                }\n+                if (outFlow != null) {\n+                    for (String outFlowPath : outFlow.getChildren()) {\n+                        inputStream = registry.get(outFlowPath).getContentStream();\n+                        outputStream = new FileOutputStream(archivePath + File.separator + SOAPTOREST\n+                                + File.separator + OUT +\n+                                outFlowPath.substring(outFlowPath.lastIndexOf(RegistryConstants.PATH_SEPARATOR)));\n+                        IOUtils.copy(inputStream, outputStream);\n+                        IOUtils.closeQuietly(inputStream);\n+                        IOUtils.closeQuietly(outputStream);\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new APIImportExportException(\"I/O error while writing API SOAP to REST logic to file\", e);\n+        } catch (RegistryException e) {\n+            throw new APIImportExportException(\"Error while retrieving SOAP to REST logic\", e);\n+        } finally {\n+            IOUtils.closeQuietly(inputStream);\n+            IOUtils.closeQuietly(outputStream);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve documentation for the exporting API or API Product and store it in the archive directory.\n+     * FILE, INLINE, MARKDOWN and URL documentations are handled.\n+     *\n+     * @param archivePath  File path to export the documents\n+     * @param identifier   ID of the requesting API or API Product\n+     * @param registry     Current tenant registry\n+     * @param exportFormat Format for export\n+     * @param apiProvider  API Provider\n+     * @throws APIImportExportException If an error occurs while retrieving documents from the\n+     *                                  registry or storing in the archive directory\n+     * @throws APIManagementException   If an error occurs while retrieving document details\n+     */\n+    public static void addDocumentationToArchive(String archivePath, Identifier identifier, Registry registry,\n+                                                 ExportFormat exportFormat, APIProvider apiProvider)\n+            throws APIImportExportException, APIManagementException {\n+\n+        List<Documentation> docList = apiProvider.getAllDocumentation(identifier);\n+        String tenantDomain = RestApiUtil.getLoggedInUserTenantDomain();\n+        if (!docList.isEmpty()) {\n+            Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+            String docDirectoryPath = archivePath + File.separator + ImportExportConstants.DOCUMENT_DIRECTORY;\n+            CommonUtil.createDirectory(docDirectoryPath);\n+            try {\n+                for (Documentation doc : docList) {\n+                    // Retrieving the document again since objects in docList might have missing fields\n+                    Documentation individualDocument = apiProvider.getDocumentation(doc.getId(), tenantDomain);\n+                    String sourceType = individualDocument.getSourceType().name();\n+                    String resourcePath = null;\n+                    String localFileName = null;\n+                    String individualDocDirectoryPath = docDirectoryPath + File.separator + individualDocument.getName();\n+                    CommonUtil.createDirectory(individualDocDirectoryPath);\n+                    writeDtoToFile(individualDocDirectoryPath +\n+                                    ImportExportConstants.DOCUMENT_FILE_NAME, exportFormat,\n+                            ImportExportConstants.TYPE_DOCUMENTS, individualDocument);\n+                    if (Documentation.DocumentSourceType.FILE.toString().equalsIgnoreCase(sourceType)) {\n+                        localFileName = individualDocument.getFilePath().substring(\n+                                individualDocument.getFilePath().lastIndexOf(RegistryConstants.PATH_SEPARATOR) + 1);\n+                        resourcePath = APIUtil.getDocumentationFilePath(identifier, localFileName);\n+                        individualDocument.setFilePath(localFileName);\n+                    } else if (Documentation.DocumentSourceType.INLINE.toString().equalsIgnoreCase(sourceType)\n+                            || Documentation.DocumentSourceType.MARKDOWN.toString().equalsIgnoreCase(sourceType)) {\n+                        // Inline/Markdown content file name would be same as the documentation name\n+                        localFileName = individualDocument.getName();\n+                        resourcePath = APIUtil.getAPIOrAPIProductDocPath(identifier) + APIConstants.INLINE_DOCUMENT_CONTENT_DIR\n+                                + RegistryConstants.PATH_SEPARATOR + localFileName;\n+                    }\n+\n+                    if (resourcePath != null) {\n+                        // Write content for Inline/Markdown/File type documentations only\n+                        // Check whether resource exists in the registry\n+                        if (registry.resourceExists(resourcePath)) {\n+                            Resource docFile = registry.get(resourcePath);\n+                            try (OutputStream outputStream = new FileOutputStream(individualDocDirectoryPath +\n+                                    File.separator + localFileName);\n+                                 InputStream fileInputStream = docFile.getContentStream()) {\n+                                IOUtils.copy(fileInputStream, outputStream);\n+                            }\n+                        } else {\n+                            // Log error and avoid throwing as we give capability to export document artifact without the\n+                            // content if does not exists\n+                            String errorMessage = \"Documentation resource for API/API Product: \" + identifier.getName()\n+                                    + \" not found in \" + resourcePath;\n+                            log.error(errorMessage);\n+                        }\n+                    }\n+                }\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Documentation retrieved successfully for API/API Product: \" + identifier.getName()\n+                            + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + identifier.getVersion());\n+                }\n+            } catch (IOException e) {\n+                String errorMessage = \"I/O error while writing documentation to file for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion();\n+                log.error(errorMessage, e);\n+                throw new APIImportExportException(errorMessage, e);\n+            } catch (RegistryException e) {\n+                String errorMessage = \"Error while retrieving documentation for API/API Product: \" + identifier.getName()\n+                        + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + identifier.getVersion();\n+                log.error(errorMessage, e);\n+                throw new APIImportExportException(errorMessage, e);\n+            }\n+        } else if (log.isDebugEnabled()) {\n+            log.debug(\"No documentation found for API/API Product: \" + identifier + \". Skipping documentation export.\");\n+        }\n+    }\n+\n+    /**\n+     * Retrieve WSDL for the exporting API and store it in the archive directory.\n+     *\n+     * @param archivePath   File path to export the WSDL\n+     * @param apiIdentifier ID of the requesting API\n+     * @param registry      Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving WSDL from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addWSDLtoArchive(String archivePath, APIIdentifier apiIdentifier, Registry registry)\n+            throws APIImportExportException {\n+\n+        String wsdlPath = APIConstants.API_WSDL_RESOURCE_LOCATION + apiIdentifier.getProviderName() + \"--\"\n+                + apiIdentifier.getApiName() + apiIdentifier.getVersion() + APIConstants.WSDL_FILE_EXTENSION;\n+        try {\n+            if (registry.resourceExists(wsdlPath)) {\n+                CommonUtil.createDirectory(archivePath + File.separator + \"WSDL\");\n+                Resource wsdl = registry.get(wsdlPath);\n+                try (InputStream wsdlStream = wsdl.getContentStream();\n+                     OutputStream outputStream = new FileOutputStream(archivePath + File.separator + \"WSDL\"\n+                             + File.separator + apiIdentifier.getApiName() + \"-\" + apiIdentifier.getVersion()\n+                             + APIConstants.WSDL_FILE_EXTENSION)) {\n+                    IOUtils.copy(wsdlStream, outputStream);\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"WSDL file: \" + wsdlPath + \" retrieved successfully\");\n+                    }\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"WSDL resource does not exists in path: \" + wsdlPath + \". Skipping WSDL export.\");\n+            }\n+        } catch (IOException e) {\n+            String errorMessage = \"I/O error while writing WSDL: \" + wsdlPath + \" to file\";\n+            throw new APIImportExportException(errorMessage, e);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while retrieving WSDL: \" + wsdlPath + \" to file\";\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve available custom sequences and API specific sequences for API export, and store it in the archive\n+     * directory.\n+     *\n+     * @param archivePath   File path to export the sequences\n+     * @param apiIdentifier API Identifier\n+     * @param apiDto        API DTO\n+     * @param registry      Current tenant registry\n+     * @param exportFormat  Export format of file\n+     * @throws APIImportExportException If an error occurs while exporting sequences\n+     */\n+    public static void addSequencesToArchive(String archivePath, APIIdentifier apiIdentifier, APIDTO apiDto,\n+                                             Registry registry, ExportFormat exportFormat) throws APIImportExportException {\n+\n+        Map<String, String> sequences = new HashMap<>();\n+        String seqArchivePath = archivePath.concat(File.separator + \"Sequences\");\n+        List<MediationPolicyDTO> mediationPolicyDtos = apiDto.getMediationPolicies();\n+        if (!apiDto.getMediationPolicies().isEmpty()) {\n+            CommonUtil.createDirectory(seqArchivePath);\n+            for (MediationPolicyDTO mediationPolicyDto : mediationPolicyDtos) {\n+                AbstractMap.SimpleEntry<String, OMElement> sequenceDetails;\n+                String sequenceName = mediationPolicyDto.getName();\n+                String direction = mediationPolicyDto.getType().toLowerCase();\n+                String pathToExportedSequence = seqArchivePath + File.separator + direction + \"-sequence\" +\n+                        File.separator;\n+                String pathToIndividualSequenceFile = pathToExportedSequence + ImportExportConstants.SEQUENCE_FILE_NAME;\n+                if (sequenceName != null) {\n+                    sequenceDetails = getCustomSequence(sequenceName, direction, registry);\n+                    if (sequenceDetails == null) {\n+                        // If sequence doesn't exist in 'apimgt/customsequences/{in/out/fault}' directory check in API\n+                        // specific registry path\n+                        sequenceDetails = getAPISpecificSequence(apiIdentifier, sequenceName, direction, registry);\n+                        pathToExportedSequence += ImportExportConstants.CUSTOM_TYPE + File.separator;\n+                    }\n+                    writeSequenceToFile(pathToExportedSequence, sequenceDetails, apiIdentifier);\n+                    try {\n+                        writeDtoToFile(pathToIndividualSequenceFile, exportFormat, ImportExportConstants.TYPE_SEQUENCE,\n+                                mediationPolicyDto);\n+                    } catch (IOException e) {\n+                        String errorMessage = \"I/O error while writing sequence: \" + sequenceName + \" to file\";\n+                        throw new APIImportExportException(errorMessage, e);\n+                    }\n+                }\n+            }\n+        } else if (log.isDebugEnabled()) {\n+            log.debug(\"No custom sequences available for API: \" + apiIdentifier.getApiName() + StringUtils.SPACE\n+                    + APIConstants.API_DATA_VERSION + \": \" + apiIdentifier.getVersion()\n+                    + \". Skipping custom sequence export.\");\n+        }\n+    }\n+\n+    /**\n+     * Retrieve custom sequence details from the registry.\n+     *\n+     * @param sequenceName Name of the sequence\n+     * @param type         Sequence type\n+     * @param registry     Current tenant registry\n+     * @return Registry resource name of the sequence and its content\n+     * @throws APIImportExportException If an error occurs while retrieving registry elements\n+     */\n+    private static AbstractMap.SimpleEntry<String, OMElement> getCustomSequence(String sequenceName, String type,\n+                                                                                Registry registry)\n+            throws APIImportExportException {\n+\n+        String regPath = null;\n+        if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_IN.equals(type)) {\n+            regPath = APIConstants.API_CUSTOM_INSEQUENCE_LOCATION;\n+        } else if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_OUT.equals(type)) {\n+            regPath = APIConstants.API_CUSTOM_OUTSEQUENCE_LOCATION;\n+        } else if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_FAULT.equals(type)) {\n+            regPath = APIConstants.API_CUSTOM_FAULTSEQUENCE_LOCATION;\n+        }\n+        return getSeqDetailsFromRegistry(sequenceName, regPath, registry);\n+    }\n+\n+    /**\n+     * Retrieve API Specific sequence details from the registry.\n+     *\n+     * @param sequenceName Name of the sequence\n+     * @param type         Sequence type\n+     * @param registry     Current tenant registry\n+     * @return Registry resource name of the sequence and its content\n+     * @throws APIImportExportException If an error occurs while retrieving registry elements\n+     */\n+    private static AbstractMap.SimpleEntry<String, OMElement> getAPISpecificSequence(APIIdentifier api,\n+                                                                                     String sequenceName, String type,\n+                                                                                     Registry registry)\n+            throws APIImportExportException {\n+\n+        String regPath = APIConstants.API_ROOT_LOCATION + RegistryConstants.PATH_SEPARATOR + api.getProviderName()\n+                + RegistryConstants.PATH_SEPARATOR + api.getApiName() + RegistryConstants.PATH_SEPARATOR\n+                + api.getVersion() + RegistryConstants.PATH_SEPARATOR + type;\n+        return getSeqDetailsFromRegistry(sequenceName, regPath, registry);\n+    }\n+\n+    /**\n+     * Retrieve sequence details from registry by given registry path.\n+     *\n+     * @param sequenceName Sequence Name\n+     * @param regPath      Registry path\n+     * @param registry     Registry\n+     * @return Sequence details as a simple entry\n+     * @throws APIImportExportException If an error occurs while retrieving sequence details from registry\n+     */\n+    private static AbstractMap.SimpleEntry<String, OMElement> getSeqDetailsFromRegistry(String sequenceName,\n+                                                                                        String regPath, Registry registry)\n+            throws APIImportExportException {\n+\n+        AbstractMap.SimpleEntry<String, OMElement> sequenceDetails = null;\n+        Collection seqCollection;\n+\n+        try {\n+            seqCollection = (Collection) registry.get(regPath);\n+            if (seqCollection != null) {\n+                String[] childPaths = seqCollection.getChildren();\n+                for (String childPath : childPaths) {\n+                    Resource sequence = registry.get(childPath);\n+                    OMElement seqElement = APIUtil.buildOMElement(sequence.getContentStream());\n+                    if (sequenceName.equals(seqElement.getAttributeValue(new QName(\"name\")))) {\n+                        String sequenceFileName = sequenceName + APIConstants.XML_EXTENSION;\n+                        sequenceDetails = new AbstractMap.SimpleEntry<>(sequenceFileName, seqElement);\n+                        break;\n+                    }\n+                }\n+            }\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while retrieving sequence: \" + sequenceName + \" from the path: \" + regPath;\n+            throw new APIImportExportException(errorMessage, e);\n+        } catch (Exception e) {\n+            //APIUtil.buildOMElement() throws a generic exception\n+            String errorMessage = \"Error while reading content for sequence: \" + sequenceName + \" from the registry\";\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+        return sequenceDetails;\n+    }\n+\n+    /**\n+     * Store API Specific or custom sequences in the archive directory.\n+     *\n+     * @param sequenceDetails Details of the sequence\n+     * @param apiIdentifier   ID of the requesting API\n+     * @throws APIImportExportException If an error occurs while serializing XML stream or storing in\n+     *                                  archive directory\n+     */\n+    private static void writeSequenceToFile(String pathToExportedSequence,\n+                                            AbstractMap.SimpleEntry<String, OMElement> sequenceDetails,\n+                                            APIIdentifier apiIdentifier)\n+            throws APIImportExportException {\n+\n+        if (sequenceDetails != null) {\n+            String sequenceFileName = sequenceDetails.getKey();\n+            OMElement sequenceConfig = sequenceDetails.getValue();\n+            CommonUtil.createDirectory(pathToExportedSequence);\n+            String exportedSequenceFile = pathToExportedSequence + sequenceFileName;\n+            try (OutputStream outputStream = new FileOutputStream(exportedSequenceFile)) {\n+                sequenceConfig.serialize(outputStream);\n+                if (log.isDebugEnabled()) {\n+                    log.debug(sequenceFileName + \" of API: \" + apiIdentifier.getApiName() + \" retrieved successfully\");\n+                }\n+            } catch (IOException e) {\n+                String errorMessage = \"Unable to find file: \" + exportedSequenceFile;\n+                throw new APIImportExportException(errorMessage, e);\n+            } catch (XMLStreamException e) {\n+                String errorMessage = \"Error while processing XML stream \";\n+                throw new APIImportExportException(errorMessage, e);\n+            }\n+        } else {\n+            String errorMessage = \"Error while writing sequence of API: \" + apiIdentifier.getApiName() + \" to file.\";\n+            throw new APIImportExportException(errorMessage);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve the endpoint certificates and store those in the archive directory.\n+     *\n+     * @param archivePath  File path to export the endpoint certificates\n+     * @param apiDto       API DTO to be exported\n+     * @param tenantId     Tenant id of the user\n+     * @param exportFormat Export format of file\n+     * @throws APIImportExportException If an error occurs while exporting endpoint certificates\n+     */\n+    public static void addEndpointCertificatesToArchive(String archivePath, APIDTO apiDto, int tenantId,\n+                                                        ExportFormat exportFormat) throws APIImportExportException {\n+        List<String> productionEndpoints;\n+        List<String> sandboxEndpoints;\n+        Set<String> uniqueEndpointURLs = new HashSet<>();\n+        JsonArray endpointCertificatesDetails = new JsonArray();\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        String endpointConfigString = gson.toJson(apiDto.getEndpointConfig());\n+        String endpointCertsDirectoryPath = archivePath + File.separator\n+                + ImportExportConstants.ENDPOINT_CERTIFICATES_DIRECTORY;\n+        CommonUtil.createDirectory(endpointCertsDirectoryPath);\n+\n+        if (StringUtils.isEmpty(endpointConfigString)) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Endpoint Details are empty for API: \" + apiDto.getName() + StringUtils.SPACE\n+                        + APIConstants.API_DATA_VERSION + \": \" + apiDto.getVersion());\n+            }\n+            return;\n+        }\n+        try {\n+            JSONTokener tokener = new JSONTokener(endpointConfigString);\n+            JSONObject endpointConfig = new JSONObject(tokener);\n+            productionEndpoints = getEndpointURLs(endpointConfig, APIConstants.API_DATA_PRODUCTION_ENDPOINTS,\n+                    apiDto.getName());\n+            sandboxEndpoints = getEndpointURLs(endpointConfig, APIConstants.API_DATA_SANDBOX_ENDPOINTS,\n+                    apiDto.getName());\n+            uniqueEndpointURLs.addAll(productionEndpoints); // Remove duplicate and append result\n+            uniqueEndpointURLs.addAll(sandboxEndpoints);\n+\n+            for (String url : uniqueEndpointURLs) {\n+                JsonArray certificateListOfUrl = getEndpointCertificateContentAndMetaData(tenantId, url,\n+                        endpointCertsDirectoryPath);\n+                endpointCertificatesDetails.addAll(certificateListOfUrl);\n+            }\n+            if (endpointCertificatesDetails.size() > 0) {\n+                writeDtoToFile(endpointCertsDirectoryPath +\n+                                ImportExportConstants.ENDPOINTS_CERTIFICATE_FILE, exportFormat,\n+                        ImportExportConstants.TYPE_ENDPOINT_CERTIFICATES, endpointCertificatesDetails);\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"No endpoint certificates available for API: \" + apiDto.getName() + StringUtils.SPACE\n+                        + APIConstants.API_DATA_VERSION + \": \" + apiDto.getVersion() + \". Skipping certificate export.\");\n+            }\n+        } catch (JSONException e) {\n+            String errorMsg = \"Error in converting Endpoint config to JSON object in API: \" + apiDto.getName();\n+            throw new APIImportExportException(errorMsg, e);\n+        } catch (IOException e) {\n+            String errorMessage = \"Error while retrieving saving endpoint certificate details for API: \"\n+                    + apiDto.getName() + \" as YAML\";\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Get Endpoint Certificate MetaData and Certificate detail and build JSON Array.\n+     *\n+     * @param tenantId          Tenant id of the user\n+     * @param url               Url of the endpoint\n+     * @param certDirectoryPath Directory path to export the certificates\n+     * @return JSON Array of certificate details\n+     * @throws APIImportExportException If an error occurs while retrieving endpoint certificate metadata and content\n+     */\n+    private static JsonArray getEndpointCertificateContentAndMetaData(int tenantId, String url,\n+                                                                      String certDirectoryPath)\n+            throws APIImportExportException {\n+\n+        List<CertificateMetadataDTO> certificateMetadataDTOS;\n+        CertificateManager certificateManager = CertificateManagerImpl.getInstance();\n+\n+        try {\n+            certificateMetadataDTOS = certificateManager.getCertificates(tenantId, null, url);\n+        } catch (APIManagementException e) {\n+            String errorMsg = \"Error retrieving certificate meta data. For tenantId: \" + tenantId + \" hostname: \"\n+                    + url;\n+            throw new APIImportExportException(errorMsg, e);\n+        }\n+\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        JsonArray certificatesList = new JsonArray();\n+        certificateMetadataDTOS.forEach(metadataDTO -> {\n+            ByteArrayInputStream certificate = null;\n+            try {\n+                certificate = certificateManager.getCertificateContent(metadataDTO.getAlias());\n+                certificate.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU0NjcxOQ=="}, "originalCommit": {"oid": "67a7a292f0788f2879e86f6675caf1d27f063c89"}, "originalPosition": 763}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNzc3Njc5OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/utils/ExportUtils.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwOToxMjoxN1rOH3HMSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMDoyNDowOVrOH3J0Eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU1MTU2Mw==", "bodyText": "Should this scenario be ignored?", "url": "https://github.com/wso2/carbon-apimgt/pull/9406#discussion_r527551563", "createdAt": "2020-11-20T09:12:17Z", "author": {"login": "uvindra"}, "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/utils/ExportUtils.java", "diffHunk": "@@ -0,0 +1,1087 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.apimgt.rest.api.publisher.v1.utils;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import org.apache.axiom.om.OMElement;\n+import org.apache.commons.codec.binary.Base64;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.json.JSONTokener;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.APIProvider;\n+import org.wso2.carbon.apimgt.api.dto.CertificateMetadataDTO;\n+import org.wso2.carbon.apimgt.api.dto.ClientCertificateDTO;\n+import org.wso2.carbon.apimgt.api.model.API;\n+import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.api.model.APIProduct;\n+import org.wso2.carbon.apimgt.api.model.APIProductIdentifier;\n+import org.wso2.carbon.apimgt.api.model.Documentation;\n+import org.wso2.carbon.apimgt.api.model.Identifier;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.certificatemgt.CertificateManager;\n+import org.wso2.carbon.apimgt.impl.certificatemgt.CertificateManagerImpl;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportException;\n+import org.wso2.carbon.apimgt.impl.importexport.ExportFormat;\n+import org.wso2.carbon.apimgt.impl.importexport.ImportExportConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.utils.CommonUtil;\n+import org.wso2.carbon.apimgt.impl.internal.ServiceReferenceHolder;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.apimgt.impl.wsdl.util.SOAPToRESTConstants;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.APIDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.APIProductDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.MediationPolicyDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.ProductAPIDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.utils.mappings.APIMappingUtil;\n+import org.wso2.carbon.apimgt.rest.api.util.RestApiConstants;\n+import org.wso2.carbon.apimgt.rest.api.util.utils.RestApiUtil;\n+import org.wso2.carbon.registry.api.Collection;\n+import org.wso2.carbon.registry.api.Registry;\n+import org.wso2.carbon.registry.api.RegistryException;\n+import org.wso2.carbon.registry.api.Resource;\n+import org.wso2.carbon.registry.core.RegistryConstants;\n+import org.wso2.carbon.registry.core.session.UserRegistry;\n+import org.wso2.carbon.utils.multitenancy.MultitenantUtils;\n+\n+import javax.xml.namespace.QName;\n+import javax.xml.stream.XMLStreamException;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ExportUtils {\n+\n+    private static final Log log = LogFactory.getLog(ExportUtils.class);\n+    private static final String IN = \"in\";\n+    private static final String OUT = \"out\";\n+    private static final String SOAPTOREST = \"SoapToRest\";\n+\n+    /**\n+     * Validate name, version and provider before exporting an API/API Product\n+     *\n+     * @param name         API/API Product Name\n+     * @param version      API/API Product version\n+     * @param providerName Name of the provider\n+     * @return Name of the provider\n+     * @throws APIManagementException If an error occurs while retrieving the provider name from name, version\n+     *                                and tenant\n+     */\n+    public static String validateExportParams(String name, String version, String providerName)\n+            throws APIManagementException {\n+        if (name == null || version == null) {\n+            RestApiUtil.handleBadRequest(\"'name' (\" + name + \") or 'version' (\" + version\n+                    + \") should not be null.\", log);\n+        }\n+        String apiRequesterDomain = RestApiUtil.getLoggedInUserTenantDomain();\n+\n+        // If provider name is not given\n+        if (StringUtils.isBlank(providerName)) {\n+            // Retrieve the provider who is in same tenant domain and who owns the same API (by comparing\n+            // API name and the version)\n+            providerName = APIUtil.getAPIProviderFromAPINameVersionTenant(name, version, apiRequesterDomain);\n+\n+            // If there is no provider in current domain, the API cannot be exported\n+            if (providerName == null) {\n+                String errorMessage = \"Error occurred while exporting. API: \" + name + \" version: \" + version\n+                        + \" not found\";\n+                RestApiUtil.handleResourceNotFoundError(errorMessage, log);\n+            }\n+        }\n+\n+        if (!StringUtils.equals(MultitenantUtils.getTenantDomain(providerName), apiRequesterDomain)) {\n+            // Not authorized to export requested API\n+            RestApiUtil.handleAuthorizationFailure(RestApiConstants.RESOURCE_API +\n+                    \" name:\" + name + \" version:\" + version + \" provider:\" + providerName, log);\n+        }\n+        return providerName;\n+    }\n+\n+    /**\n+     * Exports an API from API Manager for a given API. Meta information, API icon, documentation,\n+     * WSDL and sequences are exported.\n+     *\n+     * @param apiProvider    API Provider\n+     * @param apiIdentifier  API Identifier\n+     * @param apiDtoToReturn API DTO\n+     * @param userName       Username\n+     * @param exportFormat   Format of output documents. Can be YAML or JSON\n+     * @param preserveStatus Preserve API status on export\n+     * @return\n+     * @throws APIManagementException If an error occurs while getting governance registry\n+     */\n+    public static File exportApi(APIProvider apiProvider, APIIdentifier apiIdentifier, APIDTO apiDtoToReturn,\n+                                 String userName, ExportFormat exportFormat, Boolean preserveStatus)\n+            throws APIManagementException {\n+        int tenantId = 0;\n+        try {\n+            // Create temp location for storing API data\n+            File exportFolder = CommonUtil.createTempDirectory(apiIdentifier);\n+            String exportAPIBasePath = exportFolder.toString();\n+            String archivePath = exportAPIBasePath.concat(File.separator + apiIdentifier.getApiName() + \"-\"\n+                    + apiIdentifier.getVersion());\n+            tenantId = APIUtil.getTenantId(userName);\n+            UserRegistry registry = ServiceReferenceHolder.getInstance().getRegistryService().\n+                    getGovernanceSystemRegistry(tenantId);\n+\n+            CommonUtil.createDirectory(archivePath);\n+\n+            addThumbnailToArchive(archivePath, apiIdentifier, registry);\n+            addSOAPToRESTMediationToArchive(archivePath, apiIdentifier, registry);\n+            addDocumentationToArchive(archivePath, apiIdentifier, registry, exportFormat, apiProvider);\n+\n+            if (StringUtils.isNotEmpty(apiDtoToReturn.getWsdlUrl())) {\n+                addWSDLtoArchive(archivePath, apiIdentifier, registry);\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"No WSDL URL found for API: \" + apiIdentifier + \". Skipping WSDL export.\");\n+            }\n+\n+            addSequencesToArchive(archivePath, apiIdentifier, apiDtoToReturn, registry, exportFormat);\n+\n+            // Set API status to created if the status is not preserved\n+            if (!preserveStatus) {\n+                apiDtoToReturn.setLifeCycleStatus(APIConstants.CREATED);\n+            }\n+\n+            addEndpointCertificatesToArchive(archivePath, apiDtoToReturn, tenantId, exportFormat);\n+            addAPIMetaInformationToArchive(archivePath, apiDtoToReturn, exportFormat, apiProvider, apiIdentifier, userName);\n+\n+            // Export mTLS authentication related certificates\n+            if (apiProvider.isClientCertificateBasedAuthenticationConfigured()) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Mutual SSL enabled. Exporting client certificates.\");\n+                }\n+                addClientCertificatesToArchive(archivePath, apiIdentifier, tenantId, apiProvider, exportFormat);\n+            }\n+            CommonUtil.archiveDirectory(exportAPIBasePath);\n+            FileUtils.deleteQuietly(new File(exportAPIBasePath));\n+            return new File(exportAPIBasePath + APIConstants.ZIP_FILE_EXTENSION);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while getting governance registry for tenant: \" + tenantId;\n+            throw new APIManagementException(errorMessage, e);\n+        } catch (APIManagementException | APIImportExportException e) {\n+            RestApiUtil.handleInternalServerError(\"Error while exporting \" + RestApiConstants.RESOURCE_API, e, log);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Exports an API Product from API Manager for a given API Product. MMeta information, API Product icon, documentation, client certificates\n+     * and dependent APIs are exported.\n+     *\n+     * @param apiProvider           API Provider\n+     * @param apiProductIdentifier  API Product Identifier\n+     * @param apiProductDtoToReturn API Product DTO\n+     * @param userName              Username\n+     * @param exportFormat          Format of output documents. Can be YAML or JSON\n+     * @param preserveStatus        Preserve API Product status on export\n+     * @return\n+     * @throws APIManagementException If an error occurs while getting governance registry\n+     */\n+    public static File exportApiProduct(APIProvider apiProvider, APIProductIdentifier apiProductIdentifier,\n+                                        APIProductDTO apiProductDtoToReturn, String userName, ExportFormat exportFormat,\n+                                        Boolean preserveStatus)\n+            throws APIManagementException {\n+        int tenantId = 0;\n+        try {\n+            // Create temp location for storing API Product data\n+            File exportFolder = CommonUtil.createTempDirectory(apiProductIdentifier);\n+            String exportAPIBasePath = exportFolder.toString();\n+            String archivePath = exportAPIBasePath.concat(File.separator + apiProductIdentifier.getName() + \"-\"\n+                    + apiProductIdentifier.getVersion());\n+            tenantId = APIUtil.getTenantId(userName);\n+            UserRegistry registry = ServiceReferenceHolder.getInstance().getRegistryService().\n+                    getGovernanceSystemRegistry(tenantId);\n+            APIProduct apiProduct = APIMappingUtil.fromDTOtoAPIProduct(apiProductDtoToReturn, userName);\n+\n+            CommonUtil.createDirectory(archivePath);\n+\n+            addThumbnailToArchive(archivePath, apiProductIdentifier, registry);\n+            addDocumentationToArchive(archivePath, apiProductIdentifier, registry, exportFormat, apiProvider);\n+            addAPIProductMetaInformationToArchive(archivePath, apiProductDtoToReturn, exportFormat, apiProvider,\n+                    userName);\n+            addDependentAPIsToArchive(archivePath, apiProductDtoToReturn, exportFormat, apiProvider, userName,\n+                    preserveStatus);\n+\n+            // Export mTLS authentication related certificates\n+            if (apiProvider.isClientCertificateBasedAuthenticationConfigured()) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Mutual SSL enabled. Exporting client certificates.\");\n+                }\n+                addClientCertificatesToArchive(archivePath, apiProductIdentifier, tenantId, apiProvider, exportFormat);\n+            }\n+            CommonUtil.archiveDirectory(exportAPIBasePath);\n+            FileUtils.deleteQuietly(new File(exportAPIBasePath));\n+            return new File(exportAPIBasePath + APIConstants.ZIP_FILE_EXTENSION);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while getting governance registry for tenant: \" + tenantId;\n+            throw new APIManagementException(errorMessage, e);\n+        } catch (APIManagementException | APIImportExportException e) {\n+            RestApiUtil.handleInternalServerError(\"Error while exporting \" +\n+                    RestApiConstants.RESOURCE_API_PRODUCT, e, log);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Retrieve thumbnail image for the exporting API or API Product and store it in the archive directory.\n+     *\n+     * @param archivePath File path to export the thumbnail image\n+     * @param identifier  ID of the requesting API or API Product\n+     * @param registry    Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addThumbnailToArchive(String archivePath, Identifier identifier, Registry registry)\n+            throws APIImportExportException {\n+        String thumbnailUrl = APIConstants.API_IMAGE_LOCATION + RegistryConstants.PATH_SEPARATOR\n+                + identifier.getProviderName() + RegistryConstants.PATH_SEPARATOR + identifier.getName()\n+                + RegistryConstants.PATH_SEPARATOR + identifier.getVersion() + RegistryConstants.PATH_SEPARATOR\n+                + APIConstants.API_ICON_IMAGE;\n+        String localImagePath = archivePath + File.separator + ImportExportConstants.IMAGE_RESOURCE;\n+        try {\n+            if (registry.resourceExists(thumbnailUrl)) {\n+                Resource icon = registry.get(thumbnailUrl);\n+                String mediaType = icon.getMediaType();\n+                String extension = ImportExportConstants.fileExtensionMapping.get(mediaType);\n+                if (extension != null) {\n+                    CommonUtil.createDirectory(localImagePath);\n+                    try (InputStream imageDataStream = icon.getContentStream();\n+                         OutputStream outputStream = new FileOutputStream(localImagePath + File.separator\n+                                 + APIConstants.API_ICON_IMAGE + APIConstants.DOT + extension)) {\n+                        IOUtils.copy(imageDataStream, outputStream);\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"Thumbnail image retrieved successfully for API/API Product: \" + identifier.getName()\n+                                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                                    + identifier.getVersion());\n+                        }\n+                    }\n+                } else {\n+                    //api gets imported without thumbnail\n+                    log.error(\"Unsupported media type for icon \" + mediaType + \". Skipping thumbnail export.\");\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"Thumbnail URL [\" + thumbnailUrl + \"] does not exists in registry for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion() + \". Skipping thumbnail export.\");\n+            }\n+        } catch (RegistryException e) {\n+            log.error(\"Error while retrieving API/API Product Thumbnail \" + thumbnailUrl, e);\n+        } catch (IOException e) {\n+            //Exception is ignored by logging due to the reason that Thumbnail is not essential for\n+            //an API to be recreated.\n+            log.error(\"I/O error while writing API/API Product Thumbnail: \" + thumbnailUrl + \" to file\", e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve SOAP to REST mediation logic for the exporting API and store it in the archive directory\n+     *\n+     * @param archivePath   File path to export the SOAPToREST mediation logic\n+     * @param apiIdentifier ID of the requesting API\n+     * @param registry      Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addSOAPToRESTMediationToArchive(String archivePath, APIIdentifier apiIdentifier,\n+                                                       UserRegistry registry) throws APIImportExportException {\n+        String soapToRestBaseUrl = \"/apimgt/applicationdata/provider\" + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getProviderName() + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getApiName() + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getVersion() + RegistryConstants.PATH_SEPARATOR +\n+                SOAPToRESTConstants.SOAP_TO_REST_RESOURCE;\n+\n+        InputStream inputStream = null;\n+        OutputStream outputStream = null;\n+        try {\n+            if (registry.resourceExists(soapToRestBaseUrl)) {\n+                Collection inFlow = (org.wso2.carbon.registry.api.Collection) registry.get(soapToRestBaseUrl\n+                        + RegistryConstants.PATH_SEPARATOR + IN);\n+                Collection outFlow = (org.wso2.carbon.registry.api.Collection) registry.get(soapToRestBaseUrl\n+                        + RegistryConstants.PATH_SEPARATOR + OUT);\n+\n+                CommonUtil.createDirectory(archivePath + File.separator + SOAPTOREST + File.separator + IN);\n+                CommonUtil.createDirectory(archivePath + File.separator + SOAPTOREST + File.separator + OUT);\n+                if (inFlow != null) {\n+                    for (String inFlowPath : inFlow.getChildren()) {\n+                        inputStream = registry.get(inFlowPath).getContentStream();\n+                        outputStream = new FileOutputStream(archivePath + File.separator + SOAPTOREST\n+                                + File.separator + IN +\n+                                inFlowPath.substring(inFlowPath.lastIndexOf(RegistryConstants.PATH_SEPARATOR)));\n+                        IOUtils.copy(inputStream, outputStream);\n+                        IOUtils.closeQuietly(inputStream);\n+                        IOUtils.closeQuietly(outputStream);\n+                    }\n+                }\n+                if (outFlow != null) {\n+                    for (String outFlowPath : outFlow.getChildren()) {\n+                        inputStream = registry.get(outFlowPath).getContentStream();\n+                        outputStream = new FileOutputStream(archivePath + File.separator + SOAPTOREST\n+                                + File.separator + OUT +\n+                                outFlowPath.substring(outFlowPath.lastIndexOf(RegistryConstants.PATH_SEPARATOR)));\n+                        IOUtils.copy(inputStream, outputStream);\n+                        IOUtils.closeQuietly(inputStream);\n+                        IOUtils.closeQuietly(outputStream);\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new APIImportExportException(\"I/O error while writing API SOAP to REST logic to file\", e);\n+        } catch (RegistryException e) {\n+            throw new APIImportExportException(\"Error while retrieving SOAP to REST logic\", e);\n+        } finally {\n+            IOUtils.closeQuietly(inputStream);\n+            IOUtils.closeQuietly(outputStream);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve documentation for the exporting API or API Product and store it in the archive directory.\n+     * FILE, INLINE, MARKDOWN and URL documentations are handled.\n+     *\n+     * @param archivePath  File path to export the documents\n+     * @param identifier   ID of the requesting API or API Product\n+     * @param registry     Current tenant registry\n+     * @param exportFormat Format for export\n+     * @param apiProvider  API Provider\n+     * @throws APIImportExportException If an error occurs while retrieving documents from the\n+     *                                  registry or storing in the archive directory\n+     * @throws APIManagementException   If an error occurs while retrieving document details\n+     */\n+    public static void addDocumentationToArchive(String archivePath, Identifier identifier, Registry registry,\n+                                                 ExportFormat exportFormat, APIProvider apiProvider)\n+            throws APIImportExportException, APIManagementException {\n+\n+        List<Documentation> docList = apiProvider.getAllDocumentation(identifier);\n+        String tenantDomain = RestApiUtil.getLoggedInUserTenantDomain();\n+        if (!docList.isEmpty()) {\n+            Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+            String docDirectoryPath = archivePath + File.separator + ImportExportConstants.DOCUMENT_DIRECTORY;\n+            CommonUtil.createDirectory(docDirectoryPath);\n+            try {\n+                for (Documentation doc : docList) {\n+                    // Retrieving the document again since objects in docList might have missing fields\n+                    Documentation individualDocument = apiProvider.getDocumentation(doc.getId(), tenantDomain);\n+                    String sourceType = individualDocument.getSourceType().name();\n+                    String resourcePath = null;\n+                    String localFileName = null;\n+                    String individualDocDirectoryPath = docDirectoryPath + File.separator + individualDocument.getName();\n+                    CommonUtil.createDirectory(individualDocDirectoryPath);\n+                    writeDtoToFile(individualDocDirectoryPath +\n+                                    ImportExportConstants.DOCUMENT_FILE_NAME, exportFormat,\n+                            ImportExportConstants.TYPE_DOCUMENTS, individualDocument);\n+                    if (Documentation.DocumentSourceType.FILE.toString().equalsIgnoreCase(sourceType)) {\n+                        localFileName = individualDocument.getFilePath().substring(\n+                                individualDocument.getFilePath().lastIndexOf(RegistryConstants.PATH_SEPARATOR) + 1);\n+                        resourcePath = APIUtil.getDocumentationFilePath(identifier, localFileName);\n+                        individualDocument.setFilePath(localFileName);\n+                    } else if (Documentation.DocumentSourceType.INLINE.toString().equalsIgnoreCase(sourceType)\n+                            || Documentation.DocumentSourceType.MARKDOWN.toString().equalsIgnoreCase(sourceType)) {\n+                        // Inline/Markdown content file name would be same as the documentation name\n+                        localFileName = individualDocument.getName();\n+                        resourcePath = APIUtil.getAPIOrAPIProductDocPath(identifier) + APIConstants.INLINE_DOCUMENT_CONTENT_DIR\n+                                + RegistryConstants.PATH_SEPARATOR + localFileName;\n+                    }\n+\n+                    if (resourcePath != null) {\n+                        // Write content for Inline/Markdown/File type documentations only\n+                        // Check whether resource exists in the registry\n+                        if (registry.resourceExists(resourcePath)) {\n+                            Resource docFile = registry.get(resourcePath);\n+                            try (OutputStream outputStream = new FileOutputStream(individualDocDirectoryPath +\n+                                    File.separator + localFileName);\n+                                 InputStream fileInputStream = docFile.getContentStream()) {\n+                                IOUtils.copy(fileInputStream, outputStream);\n+                            }\n+                        } else {\n+                            // Log error and avoid throwing as we give capability to export document artifact without the\n+                            // content if does not exists\n+                            String errorMessage = \"Documentation resource for API/API Product: \" + identifier.getName()\n+                                    + \" not found in \" + resourcePath;\n+                            log.error(errorMessage);\n+                        }\n+                    }\n+                }\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Documentation retrieved successfully for API/API Product: \" + identifier.getName()\n+                            + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + identifier.getVersion());\n+                }\n+            } catch (IOException e) {\n+                String errorMessage = \"I/O error while writing documentation to file for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion();\n+                log.error(errorMessage, e);\n+                throw new APIImportExportException(errorMessage, e);\n+            } catch (RegistryException e) {\n+                String errorMessage = \"Error while retrieving documentation for API/API Product: \" + identifier.getName()\n+                        + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + identifier.getVersion();\n+                log.error(errorMessage, e);\n+                throw new APIImportExportException(errorMessage, e);\n+            }\n+        } else if (log.isDebugEnabled()) {\n+            log.debug(\"No documentation found for API/API Product: \" + identifier + \". Skipping documentation export.\");\n+        }\n+    }\n+\n+    /**\n+     * Retrieve WSDL for the exporting API and store it in the archive directory.\n+     *\n+     * @param archivePath   File path to export the WSDL\n+     * @param apiIdentifier ID of the requesting API\n+     * @param registry      Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving WSDL from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addWSDLtoArchive(String archivePath, APIIdentifier apiIdentifier, Registry registry)\n+            throws APIImportExportException {\n+\n+        String wsdlPath = APIConstants.API_WSDL_RESOURCE_LOCATION + apiIdentifier.getProviderName() + \"--\"\n+                + apiIdentifier.getApiName() + apiIdentifier.getVersion() + APIConstants.WSDL_FILE_EXTENSION;\n+        try {\n+            if (registry.resourceExists(wsdlPath)) {\n+                CommonUtil.createDirectory(archivePath + File.separator + \"WSDL\");\n+                Resource wsdl = registry.get(wsdlPath);\n+                try (InputStream wsdlStream = wsdl.getContentStream();\n+                     OutputStream outputStream = new FileOutputStream(archivePath + File.separator + \"WSDL\"\n+                             + File.separator + apiIdentifier.getApiName() + \"-\" + apiIdentifier.getVersion()\n+                             + APIConstants.WSDL_FILE_EXTENSION)) {\n+                    IOUtils.copy(wsdlStream, outputStream);\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"WSDL file: \" + wsdlPath + \" retrieved successfully\");\n+                    }\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"WSDL resource does not exists in path: \" + wsdlPath + \". Skipping WSDL export.\");\n+            }\n+        } catch (IOException e) {\n+            String errorMessage = \"I/O error while writing WSDL: \" + wsdlPath + \" to file\";\n+            throw new APIImportExportException(errorMessage, e);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while retrieving WSDL: \" + wsdlPath + \" to file\";\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve available custom sequences and API specific sequences for API export, and store it in the archive\n+     * directory.\n+     *\n+     * @param archivePath   File path to export the sequences\n+     * @param apiIdentifier API Identifier\n+     * @param apiDto        API DTO\n+     * @param registry      Current tenant registry\n+     * @param exportFormat  Export format of file\n+     * @throws APIImportExportException If an error occurs while exporting sequences\n+     */\n+    public static void addSequencesToArchive(String archivePath, APIIdentifier apiIdentifier, APIDTO apiDto,\n+                                             Registry registry, ExportFormat exportFormat) throws APIImportExportException {\n+\n+        Map<String, String> sequences = new HashMap<>();\n+        String seqArchivePath = archivePath.concat(File.separator + \"Sequences\");\n+        List<MediationPolicyDTO> mediationPolicyDtos = apiDto.getMediationPolicies();\n+        if (!apiDto.getMediationPolicies().isEmpty()) {\n+            CommonUtil.createDirectory(seqArchivePath);\n+            for (MediationPolicyDTO mediationPolicyDto : mediationPolicyDtos) {\n+                AbstractMap.SimpleEntry<String, OMElement> sequenceDetails;\n+                String sequenceName = mediationPolicyDto.getName();\n+                String direction = mediationPolicyDto.getType().toLowerCase();\n+                String pathToExportedSequence = seqArchivePath + File.separator + direction + \"-sequence\" +\n+                        File.separator;\n+                String pathToIndividualSequenceFile = pathToExportedSequence + ImportExportConstants.SEQUENCE_FILE_NAME;\n+                if (sequenceName != null) {\n+                    sequenceDetails = getCustomSequence(sequenceName, direction, registry);\n+                    if (sequenceDetails == null) {\n+                        // If sequence doesn't exist in 'apimgt/customsequences/{in/out/fault}' directory check in API\n+                        // specific registry path\n+                        sequenceDetails = getAPISpecificSequence(apiIdentifier, sequenceName, direction, registry);\n+                        pathToExportedSequence += ImportExportConstants.CUSTOM_TYPE + File.separator;\n+                    }\n+                    writeSequenceToFile(pathToExportedSequence, sequenceDetails, apiIdentifier);\n+                    try {\n+                        writeDtoToFile(pathToIndividualSequenceFile, exportFormat, ImportExportConstants.TYPE_SEQUENCE,\n+                                mediationPolicyDto);\n+                    } catch (IOException e) {\n+                        String errorMessage = \"I/O error while writing sequence: \" + sequenceName + \" to file\";\n+                        throw new APIImportExportException(errorMessage, e);\n+                    }\n+                }\n+            }\n+        } else if (log.isDebugEnabled()) {\n+            log.debug(\"No custom sequences available for API: \" + apiIdentifier.getApiName() + StringUtils.SPACE\n+                    + APIConstants.API_DATA_VERSION + \": \" + apiIdentifier.getVersion()\n+                    + \". Skipping custom sequence export.\");\n+        }\n+    }\n+\n+    /**\n+     * Retrieve custom sequence details from the registry.\n+     *\n+     * @param sequenceName Name of the sequence\n+     * @param type         Sequence type\n+     * @param registry     Current tenant registry\n+     * @return Registry resource name of the sequence and its content\n+     * @throws APIImportExportException If an error occurs while retrieving registry elements\n+     */\n+    private static AbstractMap.SimpleEntry<String, OMElement> getCustomSequence(String sequenceName, String type,\n+                                                                                Registry registry)\n+            throws APIImportExportException {\n+\n+        String regPath = null;\n+        if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_IN.equals(type)) {\n+            regPath = APIConstants.API_CUSTOM_INSEQUENCE_LOCATION;\n+        } else if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_OUT.equals(type)) {\n+            regPath = APIConstants.API_CUSTOM_OUTSEQUENCE_LOCATION;\n+        } else if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_FAULT.equals(type)) {\n+            regPath = APIConstants.API_CUSTOM_FAULTSEQUENCE_LOCATION;\n+        }\n+        return getSeqDetailsFromRegistry(sequenceName, regPath, registry);\n+    }\n+\n+    /**\n+     * Retrieve API Specific sequence details from the registry.\n+     *\n+     * @param sequenceName Name of the sequence\n+     * @param type         Sequence type\n+     * @param registry     Current tenant registry\n+     * @return Registry resource name of the sequence and its content\n+     * @throws APIImportExportException If an error occurs while retrieving registry elements\n+     */\n+    private static AbstractMap.SimpleEntry<String, OMElement> getAPISpecificSequence(APIIdentifier api,\n+                                                                                     String sequenceName, String type,\n+                                                                                     Registry registry)\n+            throws APIImportExportException {\n+\n+        String regPath = APIConstants.API_ROOT_LOCATION + RegistryConstants.PATH_SEPARATOR + api.getProviderName()\n+                + RegistryConstants.PATH_SEPARATOR + api.getApiName() + RegistryConstants.PATH_SEPARATOR\n+                + api.getVersion() + RegistryConstants.PATH_SEPARATOR + type;\n+        return getSeqDetailsFromRegistry(sequenceName, regPath, registry);\n+    }\n+\n+    /**\n+     * Retrieve sequence details from registry by given registry path.\n+     *\n+     * @param sequenceName Sequence Name\n+     * @param regPath      Registry path\n+     * @param registry     Registry\n+     * @return Sequence details as a simple entry\n+     * @throws APIImportExportException If an error occurs while retrieving sequence details from registry\n+     */\n+    private static AbstractMap.SimpleEntry<String, OMElement> getSeqDetailsFromRegistry(String sequenceName,\n+                                                                                        String regPath, Registry registry)\n+            throws APIImportExportException {\n+\n+        AbstractMap.SimpleEntry<String, OMElement> sequenceDetails = null;\n+        Collection seqCollection;\n+\n+        try {\n+            seqCollection = (Collection) registry.get(regPath);\n+            if (seqCollection != null) {\n+                String[] childPaths = seqCollection.getChildren();\n+                for (String childPath : childPaths) {\n+                    Resource sequence = registry.get(childPath);\n+                    OMElement seqElement = APIUtil.buildOMElement(sequence.getContentStream());\n+                    if (sequenceName.equals(seqElement.getAttributeValue(new QName(\"name\")))) {\n+                        String sequenceFileName = sequenceName + APIConstants.XML_EXTENSION;\n+                        sequenceDetails = new AbstractMap.SimpleEntry<>(sequenceFileName, seqElement);\n+                        break;\n+                    }\n+                }\n+            }\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while retrieving sequence: \" + sequenceName + \" from the path: \" + regPath;\n+            throw new APIImportExportException(errorMessage, e);\n+        } catch (Exception e) {\n+            //APIUtil.buildOMElement() throws a generic exception\n+            String errorMessage = \"Error while reading content for sequence: \" + sequenceName + \" from the registry\";\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+        return sequenceDetails;\n+    }\n+\n+    /**\n+     * Store API Specific or custom sequences in the archive directory.\n+     *\n+     * @param sequenceDetails Details of the sequence\n+     * @param apiIdentifier   ID of the requesting API\n+     * @throws APIImportExportException If an error occurs while serializing XML stream or storing in\n+     *                                  archive directory\n+     */\n+    private static void writeSequenceToFile(String pathToExportedSequence,\n+                                            AbstractMap.SimpleEntry<String, OMElement> sequenceDetails,\n+                                            APIIdentifier apiIdentifier)\n+            throws APIImportExportException {\n+\n+        if (sequenceDetails != null) {\n+            String sequenceFileName = sequenceDetails.getKey();\n+            OMElement sequenceConfig = sequenceDetails.getValue();\n+            CommonUtil.createDirectory(pathToExportedSequence);\n+            String exportedSequenceFile = pathToExportedSequence + sequenceFileName;\n+            try (OutputStream outputStream = new FileOutputStream(exportedSequenceFile)) {\n+                sequenceConfig.serialize(outputStream);\n+                if (log.isDebugEnabled()) {\n+                    log.debug(sequenceFileName + \" of API: \" + apiIdentifier.getApiName() + \" retrieved successfully\");\n+                }\n+            } catch (IOException e) {\n+                String errorMessage = \"Unable to find file: \" + exportedSequenceFile;\n+                throw new APIImportExportException(errorMessage, e);\n+            } catch (XMLStreamException e) {\n+                String errorMessage = \"Error while processing XML stream \";\n+                throw new APIImportExportException(errorMessage, e);\n+            }\n+        } else {\n+            String errorMessage = \"Error while writing sequence of API: \" + apiIdentifier.getApiName() + \" to file.\";\n+            throw new APIImportExportException(errorMessage);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve the endpoint certificates and store those in the archive directory.\n+     *\n+     * @param archivePath  File path to export the endpoint certificates\n+     * @param apiDto       API DTO to be exported\n+     * @param tenantId     Tenant id of the user\n+     * @param exportFormat Export format of file\n+     * @throws APIImportExportException If an error occurs while exporting endpoint certificates\n+     */\n+    public static void addEndpointCertificatesToArchive(String archivePath, APIDTO apiDto, int tenantId,\n+                                                        ExportFormat exportFormat) throws APIImportExportException {\n+        List<String> productionEndpoints;\n+        List<String> sandboxEndpoints;\n+        Set<String> uniqueEndpointURLs = new HashSet<>();\n+        JsonArray endpointCertificatesDetails = new JsonArray();\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        String endpointConfigString = gson.toJson(apiDto.getEndpointConfig());\n+        String endpointCertsDirectoryPath = archivePath + File.separator\n+                + ImportExportConstants.ENDPOINT_CERTIFICATES_DIRECTORY;\n+        CommonUtil.createDirectory(endpointCertsDirectoryPath);\n+\n+        if (StringUtils.isEmpty(endpointConfigString)) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Endpoint Details are empty for API: \" + apiDto.getName() + StringUtils.SPACE\n+                        + APIConstants.API_DATA_VERSION + \": \" + apiDto.getVersion());\n+            }\n+            return;\n+        }\n+        try {\n+            JSONTokener tokener = new JSONTokener(endpointConfigString);\n+            JSONObject endpointConfig = new JSONObject(tokener);\n+            productionEndpoints = getEndpointURLs(endpointConfig, APIConstants.API_DATA_PRODUCTION_ENDPOINTS,\n+                    apiDto.getName());\n+            sandboxEndpoints = getEndpointURLs(endpointConfig, APIConstants.API_DATA_SANDBOX_ENDPOINTS,\n+                    apiDto.getName());\n+            uniqueEndpointURLs.addAll(productionEndpoints); // Remove duplicate and append result\n+            uniqueEndpointURLs.addAll(sandboxEndpoints);\n+\n+            for (String url : uniqueEndpointURLs) {\n+                JsonArray certificateListOfUrl = getEndpointCertificateContentAndMetaData(tenantId, url,\n+                        endpointCertsDirectoryPath);\n+                endpointCertificatesDetails.addAll(certificateListOfUrl);\n+            }\n+            if (endpointCertificatesDetails.size() > 0) {\n+                writeDtoToFile(endpointCertsDirectoryPath +\n+                                ImportExportConstants.ENDPOINTS_CERTIFICATE_FILE, exportFormat,\n+                        ImportExportConstants.TYPE_ENDPOINT_CERTIFICATES, endpointCertificatesDetails);\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"No endpoint certificates available for API: \" + apiDto.getName() + StringUtils.SPACE\n+                        + APIConstants.API_DATA_VERSION + \": \" + apiDto.getVersion() + \". Skipping certificate export.\");\n+            }\n+        } catch (JSONException e) {\n+            String errorMsg = \"Error in converting Endpoint config to JSON object in API: \" + apiDto.getName();\n+            throw new APIImportExportException(errorMsg, e);\n+        } catch (IOException e) {\n+            String errorMessage = \"Error while retrieving saving endpoint certificate details for API: \"\n+                    + apiDto.getName() + \" as YAML\";\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Get Endpoint Certificate MetaData and Certificate detail and build JSON Array.\n+     *\n+     * @param tenantId          Tenant id of the user\n+     * @param url               Url of the endpoint\n+     * @param certDirectoryPath Directory path to export the certificates\n+     * @return JSON Array of certificate details\n+     * @throws APIImportExportException If an error occurs while retrieving endpoint certificate metadata and content\n+     */\n+    private static JsonArray getEndpointCertificateContentAndMetaData(int tenantId, String url,\n+                                                                      String certDirectoryPath)\n+            throws APIImportExportException {\n+\n+        List<CertificateMetadataDTO> certificateMetadataDTOS;\n+        CertificateManager certificateManager = CertificateManagerImpl.getInstance();\n+\n+        try {\n+            certificateMetadataDTOS = certificateManager.getCertificates(tenantId, null, url);\n+        } catch (APIManagementException e) {\n+            String errorMsg = \"Error retrieving certificate meta data. For tenantId: \" + tenantId + \" hostname: \"\n+                    + url;\n+            throw new APIImportExportException(errorMsg, e);\n+        }\n+\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        JsonArray certificatesList = new JsonArray();\n+        certificateMetadataDTOS.forEach(metadataDTO -> {\n+            ByteArrayInputStream certificate = null;\n+            try {\n+                certificate = certificateManager.getCertificateContent(metadataDTO.getAlias());\n+                certificate.close();\n+                byte[] certificateContent = IOUtils.toByteArray(certificate);\n+                String certificateContentEncoded = APIConstants.BEGIN_CERTIFICATE_STRING\n+                        .concat(new String(Base64.encodeBase64(certificateContent))).concat(\"\\n\")\n+                        .concat(APIConstants.END_CERTIFICATE_STRING);\n+                CommonUtil.writeFile(certDirectoryPath + File.separator + metadataDTO.getAlias() + \".crt\",\n+                        certificateContentEncoded);\n+                // Add the file name to the Certificate Metadata\n+                JsonObject modifiedCertificateMetadata = (JsonObject) gson.toJsonTree(metadataDTO);\n+                modifiedCertificateMetadata.addProperty(ImportExportConstants.CERTIFICATE_FILE,\n+                        metadataDTO.getAlias() + \".crt\");\n+                certificatesList.add(modifiedCertificateMetadata);\n+            } catch (APIManagementException e) {\n+                log.error(\"Error retrieving certificate content. For tenantId: \" + tenantId + \" hostname: \"\n+                        + url + \" alias: \" + metadataDTO.getAlias(), e);\n+            } catch (IOException e) {\n+                log.error(\"Error while converting certificate content to Byte Array. For tenantId: \" + tenantId\n+                        + \" hostname: \" + url + \" alias: \" + metadataDTO.getAlias(), e);\n+            } catch (APIImportExportException e) {\n+                log.error(\"Error while writing the certificate content. For tenantId: \" + tenantId + \" hostname: \"\n+                        + url + \" alias: \" + metadataDTO.getAlias(), e);\n+            } finally {\n+                if (certificate != null) {\n+                    IOUtils.closeQuietly(certificate);\n+                }\n+            }\n+        });\n+        return certificatesList;\n+    }\n+\n+    /**\n+     * Get endpoint url list from endpoint config.\n+     *\n+     * @param endpointConfig JSON converted endpoint config\n+     * @param type           End point type - production/sandbox\n+     * @return List of host names\n+     */\n+    private static List<String> getEndpointURLs(JSONObject endpointConfig, String type, String apiName) {\n+        List<String> urls = new ArrayList<>();\n+        if (endpointConfig != null) {\n+            try {\n+                Object item;\n+                item = endpointConfig.get(type);\n+                if (item instanceof JSONArray) {\n+                    JSONArray endpointsJSON = new JSONArray(endpointConfig.getJSONArray(type).toString());\n+                    for (int i = 0; i < endpointsJSON.length(); i++) {\n+                        try {\n+                            String urlValue = endpointsJSON.getJSONObject(i).get(APIConstants.API_DATA_URL).toString();\n+                            urls.add(urlValue);\n+                        } catch (JSONException ex) {\n+                            log.error(\"Endpoint URL extraction from endpoints JSON object failed in API: \"\n+                                    + apiName, ex);\n+                        }\n+                    }\n+                } else if (item instanceof JSONObject) {\n+                    JSONObject endpointJSON = new JSONObject(endpointConfig.getJSONObject(type).toString());\n+                    try {\n+                        String urlValue = endpointJSON.get(APIConstants.API_DATA_URL).toString();\n+                        urls.add(urlValue);\n+                    } catch (JSONException ex) {\n+                        log.error(\"Endpoint URL extraction from endpoint JSON object failed in API: \" + apiName, ex);\n+                    }\n+                }\n+            } catch (JSONException ex) {\n+                log.info(\"Endpoint type: \" + type + \" not found in API: \" + apiName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67a7a292f0788f2879e86f6675caf1d27f063c89"}, "originalPosition": 827}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU3MjI5Mw==", "bodyText": "No, this should be thrown as an exception. Will fix it. Thanks!", "url": "https://github.com/wso2/carbon-apimgt/pull/9406#discussion_r527572293", "createdAt": "2020-11-20T09:47:25Z", "author": {"login": "wasuradananjith"}, "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/utils/ExportUtils.java", "diffHunk": "@@ -0,0 +1,1087 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.apimgt.rest.api.publisher.v1.utils;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import org.apache.axiom.om.OMElement;\n+import org.apache.commons.codec.binary.Base64;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.json.JSONTokener;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.APIProvider;\n+import org.wso2.carbon.apimgt.api.dto.CertificateMetadataDTO;\n+import org.wso2.carbon.apimgt.api.dto.ClientCertificateDTO;\n+import org.wso2.carbon.apimgt.api.model.API;\n+import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.api.model.APIProduct;\n+import org.wso2.carbon.apimgt.api.model.APIProductIdentifier;\n+import org.wso2.carbon.apimgt.api.model.Documentation;\n+import org.wso2.carbon.apimgt.api.model.Identifier;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.certificatemgt.CertificateManager;\n+import org.wso2.carbon.apimgt.impl.certificatemgt.CertificateManagerImpl;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportException;\n+import org.wso2.carbon.apimgt.impl.importexport.ExportFormat;\n+import org.wso2.carbon.apimgt.impl.importexport.ImportExportConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.utils.CommonUtil;\n+import org.wso2.carbon.apimgt.impl.internal.ServiceReferenceHolder;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.apimgt.impl.wsdl.util.SOAPToRESTConstants;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.APIDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.APIProductDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.MediationPolicyDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.ProductAPIDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.utils.mappings.APIMappingUtil;\n+import org.wso2.carbon.apimgt.rest.api.util.RestApiConstants;\n+import org.wso2.carbon.apimgt.rest.api.util.utils.RestApiUtil;\n+import org.wso2.carbon.registry.api.Collection;\n+import org.wso2.carbon.registry.api.Registry;\n+import org.wso2.carbon.registry.api.RegistryException;\n+import org.wso2.carbon.registry.api.Resource;\n+import org.wso2.carbon.registry.core.RegistryConstants;\n+import org.wso2.carbon.registry.core.session.UserRegistry;\n+import org.wso2.carbon.utils.multitenancy.MultitenantUtils;\n+\n+import javax.xml.namespace.QName;\n+import javax.xml.stream.XMLStreamException;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ExportUtils {\n+\n+    private static final Log log = LogFactory.getLog(ExportUtils.class);\n+    private static final String IN = \"in\";\n+    private static final String OUT = \"out\";\n+    private static final String SOAPTOREST = \"SoapToRest\";\n+\n+    /**\n+     * Validate name, version and provider before exporting an API/API Product\n+     *\n+     * @param name         API/API Product Name\n+     * @param version      API/API Product version\n+     * @param providerName Name of the provider\n+     * @return Name of the provider\n+     * @throws APIManagementException If an error occurs while retrieving the provider name from name, version\n+     *                                and tenant\n+     */\n+    public static String validateExportParams(String name, String version, String providerName)\n+            throws APIManagementException {\n+        if (name == null || version == null) {\n+            RestApiUtil.handleBadRequest(\"'name' (\" + name + \") or 'version' (\" + version\n+                    + \") should not be null.\", log);\n+        }\n+        String apiRequesterDomain = RestApiUtil.getLoggedInUserTenantDomain();\n+\n+        // If provider name is not given\n+        if (StringUtils.isBlank(providerName)) {\n+            // Retrieve the provider who is in same tenant domain and who owns the same API (by comparing\n+            // API name and the version)\n+            providerName = APIUtil.getAPIProviderFromAPINameVersionTenant(name, version, apiRequesterDomain);\n+\n+            // If there is no provider in current domain, the API cannot be exported\n+            if (providerName == null) {\n+                String errorMessage = \"Error occurred while exporting. API: \" + name + \" version: \" + version\n+                        + \" not found\";\n+                RestApiUtil.handleResourceNotFoundError(errorMessage, log);\n+            }\n+        }\n+\n+        if (!StringUtils.equals(MultitenantUtils.getTenantDomain(providerName), apiRequesterDomain)) {\n+            // Not authorized to export requested API\n+            RestApiUtil.handleAuthorizationFailure(RestApiConstants.RESOURCE_API +\n+                    \" name:\" + name + \" version:\" + version + \" provider:\" + providerName, log);\n+        }\n+        return providerName;\n+    }\n+\n+    /**\n+     * Exports an API from API Manager for a given API. Meta information, API icon, documentation,\n+     * WSDL and sequences are exported.\n+     *\n+     * @param apiProvider    API Provider\n+     * @param apiIdentifier  API Identifier\n+     * @param apiDtoToReturn API DTO\n+     * @param userName       Username\n+     * @param exportFormat   Format of output documents. Can be YAML or JSON\n+     * @param preserveStatus Preserve API status on export\n+     * @return\n+     * @throws APIManagementException If an error occurs while getting governance registry\n+     */\n+    public static File exportApi(APIProvider apiProvider, APIIdentifier apiIdentifier, APIDTO apiDtoToReturn,\n+                                 String userName, ExportFormat exportFormat, Boolean preserveStatus)\n+            throws APIManagementException {\n+        int tenantId = 0;\n+        try {\n+            // Create temp location for storing API data\n+            File exportFolder = CommonUtil.createTempDirectory(apiIdentifier);\n+            String exportAPIBasePath = exportFolder.toString();\n+            String archivePath = exportAPIBasePath.concat(File.separator + apiIdentifier.getApiName() + \"-\"\n+                    + apiIdentifier.getVersion());\n+            tenantId = APIUtil.getTenantId(userName);\n+            UserRegistry registry = ServiceReferenceHolder.getInstance().getRegistryService().\n+                    getGovernanceSystemRegistry(tenantId);\n+\n+            CommonUtil.createDirectory(archivePath);\n+\n+            addThumbnailToArchive(archivePath, apiIdentifier, registry);\n+            addSOAPToRESTMediationToArchive(archivePath, apiIdentifier, registry);\n+            addDocumentationToArchive(archivePath, apiIdentifier, registry, exportFormat, apiProvider);\n+\n+            if (StringUtils.isNotEmpty(apiDtoToReturn.getWsdlUrl())) {\n+                addWSDLtoArchive(archivePath, apiIdentifier, registry);\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"No WSDL URL found for API: \" + apiIdentifier + \". Skipping WSDL export.\");\n+            }\n+\n+            addSequencesToArchive(archivePath, apiIdentifier, apiDtoToReturn, registry, exportFormat);\n+\n+            // Set API status to created if the status is not preserved\n+            if (!preserveStatus) {\n+                apiDtoToReturn.setLifeCycleStatus(APIConstants.CREATED);\n+            }\n+\n+            addEndpointCertificatesToArchive(archivePath, apiDtoToReturn, tenantId, exportFormat);\n+            addAPIMetaInformationToArchive(archivePath, apiDtoToReturn, exportFormat, apiProvider, apiIdentifier, userName);\n+\n+            // Export mTLS authentication related certificates\n+            if (apiProvider.isClientCertificateBasedAuthenticationConfigured()) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Mutual SSL enabled. Exporting client certificates.\");\n+                }\n+                addClientCertificatesToArchive(archivePath, apiIdentifier, tenantId, apiProvider, exportFormat);\n+            }\n+            CommonUtil.archiveDirectory(exportAPIBasePath);\n+            FileUtils.deleteQuietly(new File(exportAPIBasePath));\n+            return new File(exportAPIBasePath + APIConstants.ZIP_FILE_EXTENSION);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while getting governance registry for tenant: \" + tenantId;\n+            throw new APIManagementException(errorMessage, e);\n+        } catch (APIManagementException | APIImportExportException e) {\n+            RestApiUtil.handleInternalServerError(\"Error while exporting \" + RestApiConstants.RESOURCE_API, e, log);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Exports an API Product from API Manager for a given API Product. MMeta information, API Product icon, documentation, client certificates\n+     * and dependent APIs are exported.\n+     *\n+     * @param apiProvider           API Provider\n+     * @param apiProductIdentifier  API Product Identifier\n+     * @param apiProductDtoToReturn API Product DTO\n+     * @param userName              Username\n+     * @param exportFormat          Format of output documents. Can be YAML or JSON\n+     * @param preserveStatus        Preserve API Product status on export\n+     * @return\n+     * @throws APIManagementException If an error occurs while getting governance registry\n+     */\n+    public static File exportApiProduct(APIProvider apiProvider, APIProductIdentifier apiProductIdentifier,\n+                                        APIProductDTO apiProductDtoToReturn, String userName, ExportFormat exportFormat,\n+                                        Boolean preserveStatus)\n+            throws APIManagementException {\n+        int tenantId = 0;\n+        try {\n+            // Create temp location for storing API Product data\n+            File exportFolder = CommonUtil.createTempDirectory(apiProductIdentifier);\n+            String exportAPIBasePath = exportFolder.toString();\n+            String archivePath = exportAPIBasePath.concat(File.separator + apiProductIdentifier.getName() + \"-\"\n+                    + apiProductIdentifier.getVersion());\n+            tenantId = APIUtil.getTenantId(userName);\n+            UserRegistry registry = ServiceReferenceHolder.getInstance().getRegistryService().\n+                    getGovernanceSystemRegistry(tenantId);\n+            APIProduct apiProduct = APIMappingUtil.fromDTOtoAPIProduct(apiProductDtoToReturn, userName);\n+\n+            CommonUtil.createDirectory(archivePath);\n+\n+            addThumbnailToArchive(archivePath, apiProductIdentifier, registry);\n+            addDocumentationToArchive(archivePath, apiProductIdentifier, registry, exportFormat, apiProvider);\n+            addAPIProductMetaInformationToArchive(archivePath, apiProductDtoToReturn, exportFormat, apiProvider,\n+                    userName);\n+            addDependentAPIsToArchive(archivePath, apiProductDtoToReturn, exportFormat, apiProvider, userName,\n+                    preserveStatus);\n+\n+            // Export mTLS authentication related certificates\n+            if (apiProvider.isClientCertificateBasedAuthenticationConfigured()) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Mutual SSL enabled. Exporting client certificates.\");\n+                }\n+                addClientCertificatesToArchive(archivePath, apiProductIdentifier, tenantId, apiProvider, exportFormat);\n+            }\n+            CommonUtil.archiveDirectory(exportAPIBasePath);\n+            FileUtils.deleteQuietly(new File(exportAPIBasePath));\n+            return new File(exportAPIBasePath + APIConstants.ZIP_FILE_EXTENSION);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while getting governance registry for tenant: \" + tenantId;\n+            throw new APIManagementException(errorMessage, e);\n+        } catch (APIManagementException | APIImportExportException e) {\n+            RestApiUtil.handleInternalServerError(\"Error while exporting \" +\n+                    RestApiConstants.RESOURCE_API_PRODUCT, e, log);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Retrieve thumbnail image for the exporting API or API Product and store it in the archive directory.\n+     *\n+     * @param archivePath File path to export the thumbnail image\n+     * @param identifier  ID of the requesting API or API Product\n+     * @param registry    Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addThumbnailToArchive(String archivePath, Identifier identifier, Registry registry)\n+            throws APIImportExportException {\n+        String thumbnailUrl = APIConstants.API_IMAGE_LOCATION + RegistryConstants.PATH_SEPARATOR\n+                + identifier.getProviderName() + RegistryConstants.PATH_SEPARATOR + identifier.getName()\n+                + RegistryConstants.PATH_SEPARATOR + identifier.getVersion() + RegistryConstants.PATH_SEPARATOR\n+                + APIConstants.API_ICON_IMAGE;\n+        String localImagePath = archivePath + File.separator + ImportExportConstants.IMAGE_RESOURCE;\n+        try {\n+            if (registry.resourceExists(thumbnailUrl)) {\n+                Resource icon = registry.get(thumbnailUrl);\n+                String mediaType = icon.getMediaType();\n+                String extension = ImportExportConstants.fileExtensionMapping.get(mediaType);\n+                if (extension != null) {\n+                    CommonUtil.createDirectory(localImagePath);\n+                    try (InputStream imageDataStream = icon.getContentStream();\n+                         OutputStream outputStream = new FileOutputStream(localImagePath + File.separator\n+                                 + APIConstants.API_ICON_IMAGE + APIConstants.DOT + extension)) {\n+                        IOUtils.copy(imageDataStream, outputStream);\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"Thumbnail image retrieved successfully for API/API Product: \" + identifier.getName()\n+                                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                                    + identifier.getVersion());\n+                        }\n+                    }\n+                } else {\n+                    //api gets imported without thumbnail\n+                    log.error(\"Unsupported media type for icon \" + mediaType + \". Skipping thumbnail export.\");\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"Thumbnail URL [\" + thumbnailUrl + \"] does not exists in registry for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion() + \". Skipping thumbnail export.\");\n+            }\n+        } catch (RegistryException e) {\n+            log.error(\"Error while retrieving API/API Product Thumbnail \" + thumbnailUrl, e);\n+        } catch (IOException e) {\n+            //Exception is ignored by logging due to the reason that Thumbnail is not essential for\n+            //an API to be recreated.\n+            log.error(\"I/O error while writing API/API Product Thumbnail: \" + thumbnailUrl + \" to file\", e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve SOAP to REST mediation logic for the exporting API and store it in the archive directory\n+     *\n+     * @param archivePath   File path to export the SOAPToREST mediation logic\n+     * @param apiIdentifier ID of the requesting API\n+     * @param registry      Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addSOAPToRESTMediationToArchive(String archivePath, APIIdentifier apiIdentifier,\n+                                                       UserRegistry registry) throws APIImportExportException {\n+        String soapToRestBaseUrl = \"/apimgt/applicationdata/provider\" + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getProviderName() + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getApiName() + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getVersion() + RegistryConstants.PATH_SEPARATOR +\n+                SOAPToRESTConstants.SOAP_TO_REST_RESOURCE;\n+\n+        InputStream inputStream = null;\n+        OutputStream outputStream = null;\n+        try {\n+            if (registry.resourceExists(soapToRestBaseUrl)) {\n+                Collection inFlow = (org.wso2.carbon.registry.api.Collection) registry.get(soapToRestBaseUrl\n+                        + RegistryConstants.PATH_SEPARATOR + IN);\n+                Collection outFlow = (org.wso2.carbon.registry.api.Collection) registry.get(soapToRestBaseUrl\n+                        + RegistryConstants.PATH_SEPARATOR + OUT);\n+\n+                CommonUtil.createDirectory(archivePath + File.separator + SOAPTOREST + File.separator + IN);\n+                CommonUtil.createDirectory(archivePath + File.separator + SOAPTOREST + File.separator + OUT);\n+                if (inFlow != null) {\n+                    for (String inFlowPath : inFlow.getChildren()) {\n+                        inputStream = registry.get(inFlowPath).getContentStream();\n+                        outputStream = new FileOutputStream(archivePath + File.separator + SOAPTOREST\n+                                + File.separator + IN +\n+                                inFlowPath.substring(inFlowPath.lastIndexOf(RegistryConstants.PATH_SEPARATOR)));\n+                        IOUtils.copy(inputStream, outputStream);\n+                        IOUtils.closeQuietly(inputStream);\n+                        IOUtils.closeQuietly(outputStream);\n+                    }\n+                }\n+                if (outFlow != null) {\n+                    for (String outFlowPath : outFlow.getChildren()) {\n+                        inputStream = registry.get(outFlowPath).getContentStream();\n+                        outputStream = new FileOutputStream(archivePath + File.separator + SOAPTOREST\n+                                + File.separator + OUT +\n+                                outFlowPath.substring(outFlowPath.lastIndexOf(RegistryConstants.PATH_SEPARATOR)));\n+                        IOUtils.copy(inputStream, outputStream);\n+                        IOUtils.closeQuietly(inputStream);\n+                        IOUtils.closeQuietly(outputStream);\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new APIImportExportException(\"I/O error while writing API SOAP to REST logic to file\", e);\n+        } catch (RegistryException e) {\n+            throw new APIImportExportException(\"Error while retrieving SOAP to REST logic\", e);\n+        } finally {\n+            IOUtils.closeQuietly(inputStream);\n+            IOUtils.closeQuietly(outputStream);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve documentation for the exporting API or API Product and store it in the archive directory.\n+     * FILE, INLINE, MARKDOWN and URL documentations are handled.\n+     *\n+     * @param archivePath  File path to export the documents\n+     * @param identifier   ID of the requesting API or API Product\n+     * @param registry     Current tenant registry\n+     * @param exportFormat Format for export\n+     * @param apiProvider  API Provider\n+     * @throws APIImportExportException If an error occurs while retrieving documents from the\n+     *                                  registry or storing in the archive directory\n+     * @throws APIManagementException   If an error occurs while retrieving document details\n+     */\n+    public static void addDocumentationToArchive(String archivePath, Identifier identifier, Registry registry,\n+                                                 ExportFormat exportFormat, APIProvider apiProvider)\n+            throws APIImportExportException, APIManagementException {\n+\n+        List<Documentation> docList = apiProvider.getAllDocumentation(identifier);\n+        String tenantDomain = RestApiUtil.getLoggedInUserTenantDomain();\n+        if (!docList.isEmpty()) {\n+            Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+            String docDirectoryPath = archivePath + File.separator + ImportExportConstants.DOCUMENT_DIRECTORY;\n+            CommonUtil.createDirectory(docDirectoryPath);\n+            try {\n+                for (Documentation doc : docList) {\n+                    // Retrieving the document again since objects in docList might have missing fields\n+                    Documentation individualDocument = apiProvider.getDocumentation(doc.getId(), tenantDomain);\n+                    String sourceType = individualDocument.getSourceType().name();\n+                    String resourcePath = null;\n+                    String localFileName = null;\n+                    String individualDocDirectoryPath = docDirectoryPath + File.separator + individualDocument.getName();\n+                    CommonUtil.createDirectory(individualDocDirectoryPath);\n+                    writeDtoToFile(individualDocDirectoryPath +\n+                                    ImportExportConstants.DOCUMENT_FILE_NAME, exportFormat,\n+                            ImportExportConstants.TYPE_DOCUMENTS, individualDocument);\n+                    if (Documentation.DocumentSourceType.FILE.toString().equalsIgnoreCase(sourceType)) {\n+                        localFileName = individualDocument.getFilePath().substring(\n+                                individualDocument.getFilePath().lastIndexOf(RegistryConstants.PATH_SEPARATOR) + 1);\n+                        resourcePath = APIUtil.getDocumentationFilePath(identifier, localFileName);\n+                        individualDocument.setFilePath(localFileName);\n+                    } else if (Documentation.DocumentSourceType.INLINE.toString().equalsIgnoreCase(sourceType)\n+                            || Documentation.DocumentSourceType.MARKDOWN.toString().equalsIgnoreCase(sourceType)) {\n+                        // Inline/Markdown content file name would be same as the documentation name\n+                        localFileName = individualDocument.getName();\n+                        resourcePath = APIUtil.getAPIOrAPIProductDocPath(identifier) + APIConstants.INLINE_DOCUMENT_CONTENT_DIR\n+                                + RegistryConstants.PATH_SEPARATOR + localFileName;\n+                    }\n+\n+                    if (resourcePath != null) {\n+                        // Write content for Inline/Markdown/File type documentations only\n+                        // Check whether resource exists in the registry\n+                        if (registry.resourceExists(resourcePath)) {\n+                            Resource docFile = registry.get(resourcePath);\n+                            try (OutputStream outputStream = new FileOutputStream(individualDocDirectoryPath +\n+                                    File.separator + localFileName);\n+                                 InputStream fileInputStream = docFile.getContentStream()) {\n+                                IOUtils.copy(fileInputStream, outputStream);\n+                            }\n+                        } else {\n+                            // Log error and avoid throwing as we give capability to export document artifact without the\n+                            // content if does not exists\n+                            String errorMessage = \"Documentation resource for API/API Product: \" + identifier.getName()\n+                                    + \" not found in \" + resourcePath;\n+                            log.error(errorMessage);\n+                        }\n+                    }\n+                }\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Documentation retrieved successfully for API/API Product: \" + identifier.getName()\n+                            + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + identifier.getVersion());\n+                }\n+            } catch (IOException e) {\n+                String errorMessage = \"I/O error while writing documentation to file for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion();\n+                log.error(errorMessage, e);\n+                throw new APIImportExportException(errorMessage, e);\n+            } catch (RegistryException e) {\n+                String errorMessage = \"Error while retrieving documentation for API/API Product: \" + identifier.getName()\n+                        + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + identifier.getVersion();\n+                log.error(errorMessage, e);\n+                throw new APIImportExportException(errorMessage, e);\n+            }\n+        } else if (log.isDebugEnabled()) {\n+            log.debug(\"No documentation found for API/API Product: \" + identifier + \". Skipping documentation export.\");\n+        }\n+    }\n+\n+    /**\n+     * Retrieve WSDL for the exporting API and store it in the archive directory.\n+     *\n+     * @param archivePath   File path to export the WSDL\n+     * @param apiIdentifier ID of the requesting API\n+     * @param registry      Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving WSDL from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addWSDLtoArchive(String archivePath, APIIdentifier apiIdentifier, Registry registry)\n+            throws APIImportExportException {\n+\n+        String wsdlPath = APIConstants.API_WSDL_RESOURCE_LOCATION + apiIdentifier.getProviderName() + \"--\"\n+                + apiIdentifier.getApiName() + apiIdentifier.getVersion() + APIConstants.WSDL_FILE_EXTENSION;\n+        try {\n+            if (registry.resourceExists(wsdlPath)) {\n+                CommonUtil.createDirectory(archivePath + File.separator + \"WSDL\");\n+                Resource wsdl = registry.get(wsdlPath);\n+                try (InputStream wsdlStream = wsdl.getContentStream();\n+                     OutputStream outputStream = new FileOutputStream(archivePath + File.separator + \"WSDL\"\n+                             + File.separator + apiIdentifier.getApiName() + \"-\" + apiIdentifier.getVersion()\n+                             + APIConstants.WSDL_FILE_EXTENSION)) {\n+                    IOUtils.copy(wsdlStream, outputStream);\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"WSDL file: \" + wsdlPath + \" retrieved successfully\");\n+                    }\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"WSDL resource does not exists in path: \" + wsdlPath + \". Skipping WSDL export.\");\n+            }\n+        } catch (IOException e) {\n+            String errorMessage = \"I/O error while writing WSDL: \" + wsdlPath + \" to file\";\n+            throw new APIImportExportException(errorMessage, e);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while retrieving WSDL: \" + wsdlPath + \" to file\";\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve available custom sequences and API specific sequences for API export, and store it in the archive\n+     * directory.\n+     *\n+     * @param archivePath   File path to export the sequences\n+     * @param apiIdentifier API Identifier\n+     * @param apiDto        API DTO\n+     * @param registry      Current tenant registry\n+     * @param exportFormat  Export format of file\n+     * @throws APIImportExportException If an error occurs while exporting sequences\n+     */\n+    public static void addSequencesToArchive(String archivePath, APIIdentifier apiIdentifier, APIDTO apiDto,\n+                                             Registry registry, ExportFormat exportFormat) throws APIImportExportException {\n+\n+        Map<String, String> sequences = new HashMap<>();\n+        String seqArchivePath = archivePath.concat(File.separator + \"Sequences\");\n+        List<MediationPolicyDTO> mediationPolicyDtos = apiDto.getMediationPolicies();\n+        if (!apiDto.getMediationPolicies().isEmpty()) {\n+            CommonUtil.createDirectory(seqArchivePath);\n+            for (MediationPolicyDTO mediationPolicyDto : mediationPolicyDtos) {\n+                AbstractMap.SimpleEntry<String, OMElement> sequenceDetails;\n+                String sequenceName = mediationPolicyDto.getName();\n+                String direction = mediationPolicyDto.getType().toLowerCase();\n+                String pathToExportedSequence = seqArchivePath + File.separator + direction + \"-sequence\" +\n+                        File.separator;\n+                String pathToIndividualSequenceFile = pathToExportedSequence + ImportExportConstants.SEQUENCE_FILE_NAME;\n+                if (sequenceName != null) {\n+                    sequenceDetails = getCustomSequence(sequenceName, direction, registry);\n+                    if (sequenceDetails == null) {\n+                        // If sequence doesn't exist in 'apimgt/customsequences/{in/out/fault}' directory check in API\n+                        // specific registry path\n+                        sequenceDetails = getAPISpecificSequence(apiIdentifier, sequenceName, direction, registry);\n+                        pathToExportedSequence += ImportExportConstants.CUSTOM_TYPE + File.separator;\n+                    }\n+                    writeSequenceToFile(pathToExportedSequence, sequenceDetails, apiIdentifier);\n+                    try {\n+                        writeDtoToFile(pathToIndividualSequenceFile, exportFormat, ImportExportConstants.TYPE_SEQUENCE,\n+                                mediationPolicyDto);\n+                    } catch (IOException e) {\n+                        String errorMessage = \"I/O error while writing sequence: \" + sequenceName + \" to file\";\n+                        throw new APIImportExportException(errorMessage, e);\n+                    }\n+                }\n+            }\n+        } else if (log.isDebugEnabled()) {\n+            log.debug(\"No custom sequences available for API: \" + apiIdentifier.getApiName() + StringUtils.SPACE\n+                    + APIConstants.API_DATA_VERSION + \": \" + apiIdentifier.getVersion()\n+                    + \". Skipping custom sequence export.\");\n+        }\n+    }\n+\n+    /**\n+     * Retrieve custom sequence details from the registry.\n+     *\n+     * @param sequenceName Name of the sequence\n+     * @param type         Sequence type\n+     * @param registry     Current tenant registry\n+     * @return Registry resource name of the sequence and its content\n+     * @throws APIImportExportException If an error occurs while retrieving registry elements\n+     */\n+    private static AbstractMap.SimpleEntry<String, OMElement> getCustomSequence(String sequenceName, String type,\n+                                                                                Registry registry)\n+            throws APIImportExportException {\n+\n+        String regPath = null;\n+        if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_IN.equals(type)) {\n+            regPath = APIConstants.API_CUSTOM_INSEQUENCE_LOCATION;\n+        } else if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_OUT.equals(type)) {\n+            regPath = APIConstants.API_CUSTOM_OUTSEQUENCE_LOCATION;\n+        } else if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_FAULT.equals(type)) {\n+            regPath = APIConstants.API_CUSTOM_FAULTSEQUENCE_LOCATION;\n+        }\n+        return getSeqDetailsFromRegistry(sequenceName, regPath, registry);\n+    }\n+\n+    /**\n+     * Retrieve API Specific sequence details from the registry.\n+     *\n+     * @param sequenceName Name of the sequence\n+     * @param type         Sequence type\n+     * @param registry     Current tenant registry\n+     * @return Registry resource name of the sequence and its content\n+     * @throws APIImportExportException If an error occurs while retrieving registry elements\n+     */\n+    private static AbstractMap.SimpleEntry<String, OMElement> getAPISpecificSequence(APIIdentifier api,\n+                                                                                     String sequenceName, String type,\n+                                                                                     Registry registry)\n+            throws APIImportExportException {\n+\n+        String regPath = APIConstants.API_ROOT_LOCATION + RegistryConstants.PATH_SEPARATOR + api.getProviderName()\n+                + RegistryConstants.PATH_SEPARATOR + api.getApiName() + RegistryConstants.PATH_SEPARATOR\n+                + api.getVersion() + RegistryConstants.PATH_SEPARATOR + type;\n+        return getSeqDetailsFromRegistry(sequenceName, regPath, registry);\n+    }\n+\n+    /**\n+     * Retrieve sequence details from registry by given registry path.\n+     *\n+     * @param sequenceName Sequence Name\n+     * @param regPath      Registry path\n+     * @param registry     Registry\n+     * @return Sequence details as a simple entry\n+     * @throws APIImportExportException If an error occurs while retrieving sequence details from registry\n+     */\n+    private static AbstractMap.SimpleEntry<String, OMElement> getSeqDetailsFromRegistry(String sequenceName,\n+                                                                                        String regPath, Registry registry)\n+            throws APIImportExportException {\n+\n+        AbstractMap.SimpleEntry<String, OMElement> sequenceDetails = null;\n+        Collection seqCollection;\n+\n+        try {\n+            seqCollection = (Collection) registry.get(regPath);\n+            if (seqCollection != null) {\n+                String[] childPaths = seqCollection.getChildren();\n+                for (String childPath : childPaths) {\n+                    Resource sequence = registry.get(childPath);\n+                    OMElement seqElement = APIUtil.buildOMElement(sequence.getContentStream());\n+                    if (sequenceName.equals(seqElement.getAttributeValue(new QName(\"name\")))) {\n+                        String sequenceFileName = sequenceName + APIConstants.XML_EXTENSION;\n+                        sequenceDetails = new AbstractMap.SimpleEntry<>(sequenceFileName, seqElement);\n+                        break;\n+                    }\n+                }\n+            }\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while retrieving sequence: \" + sequenceName + \" from the path: \" + regPath;\n+            throw new APIImportExportException(errorMessage, e);\n+        } catch (Exception e) {\n+            //APIUtil.buildOMElement() throws a generic exception\n+            String errorMessage = \"Error while reading content for sequence: \" + sequenceName + \" from the registry\";\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+        return sequenceDetails;\n+    }\n+\n+    /**\n+     * Store API Specific or custom sequences in the archive directory.\n+     *\n+     * @param sequenceDetails Details of the sequence\n+     * @param apiIdentifier   ID of the requesting API\n+     * @throws APIImportExportException If an error occurs while serializing XML stream or storing in\n+     *                                  archive directory\n+     */\n+    private static void writeSequenceToFile(String pathToExportedSequence,\n+                                            AbstractMap.SimpleEntry<String, OMElement> sequenceDetails,\n+                                            APIIdentifier apiIdentifier)\n+            throws APIImportExportException {\n+\n+        if (sequenceDetails != null) {\n+            String sequenceFileName = sequenceDetails.getKey();\n+            OMElement sequenceConfig = sequenceDetails.getValue();\n+            CommonUtil.createDirectory(pathToExportedSequence);\n+            String exportedSequenceFile = pathToExportedSequence + sequenceFileName;\n+            try (OutputStream outputStream = new FileOutputStream(exportedSequenceFile)) {\n+                sequenceConfig.serialize(outputStream);\n+                if (log.isDebugEnabled()) {\n+                    log.debug(sequenceFileName + \" of API: \" + apiIdentifier.getApiName() + \" retrieved successfully\");\n+                }\n+            } catch (IOException e) {\n+                String errorMessage = \"Unable to find file: \" + exportedSequenceFile;\n+                throw new APIImportExportException(errorMessage, e);\n+            } catch (XMLStreamException e) {\n+                String errorMessage = \"Error while processing XML stream \";\n+                throw new APIImportExportException(errorMessage, e);\n+            }\n+        } else {\n+            String errorMessage = \"Error while writing sequence of API: \" + apiIdentifier.getApiName() + \" to file.\";\n+            throw new APIImportExportException(errorMessage);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve the endpoint certificates and store those in the archive directory.\n+     *\n+     * @param archivePath  File path to export the endpoint certificates\n+     * @param apiDto       API DTO to be exported\n+     * @param tenantId     Tenant id of the user\n+     * @param exportFormat Export format of file\n+     * @throws APIImportExportException If an error occurs while exporting endpoint certificates\n+     */\n+    public static void addEndpointCertificatesToArchive(String archivePath, APIDTO apiDto, int tenantId,\n+                                                        ExportFormat exportFormat) throws APIImportExportException {\n+        List<String> productionEndpoints;\n+        List<String> sandboxEndpoints;\n+        Set<String> uniqueEndpointURLs = new HashSet<>();\n+        JsonArray endpointCertificatesDetails = new JsonArray();\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        String endpointConfigString = gson.toJson(apiDto.getEndpointConfig());\n+        String endpointCertsDirectoryPath = archivePath + File.separator\n+                + ImportExportConstants.ENDPOINT_CERTIFICATES_DIRECTORY;\n+        CommonUtil.createDirectory(endpointCertsDirectoryPath);\n+\n+        if (StringUtils.isEmpty(endpointConfigString)) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Endpoint Details are empty for API: \" + apiDto.getName() + StringUtils.SPACE\n+                        + APIConstants.API_DATA_VERSION + \": \" + apiDto.getVersion());\n+            }\n+            return;\n+        }\n+        try {\n+            JSONTokener tokener = new JSONTokener(endpointConfigString);\n+            JSONObject endpointConfig = new JSONObject(tokener);\n+            productionEndpoints = getEndpointURLs(endpointConfig, APIConstants.API_DATA_PRODUCTION_ENDPOINTS,\n+                    apiDto.getName());\n+            sandboxEndpoints = getEndpointURLs(endpointConfig, APIConstants.API_DATA_SANDBOX_ENDPOINTS,\n+                    apiDto.getName());\n+            uniqueEndpointURLs.addAll(productionEndpoints); // Remove duplicate and append result\n+            uniqueEndpointURLs.addAll(sandboxEndpoints);\n+\n+            for (String url : uniqueEndpointURLs) {\n+                JsonArray certificateListOfUrl = getEndpointCertificateContentAndMetaData(tenantId, url,\n+                        endpointCertsDirectoryPath);\n+                endpointCertificatesDetails.addAll(certificateListOfUrl);\n+            }\n+            if (endpointCertificatesDetails.size() > 0) {\n+                writeDtoToFile(endpointCertsDirectoryPath +\n+                                ImportExportConstants.ENDPOINTS_CERTIFICATE_FILE, exportFormat,\n+                        ImportExportConstants.TYPE_ENDPOINT_CERTIFICATES, endpointCertificatesDetails);\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"No endpoint certificates available for API: \" + apiDto.getName() + StringUtils.SPACE\n+                        + APIConstants.API_DATA_VERSION + \": \" + apiDto.getVersion() + \". Skipping certificate export.\");\n+            }\n+        } catch (JSONException e) {\n+            String errorMsg = \"Error in converting Endpoint config to JSON object in API: \" + apiDto.getName();\n+            throw new APIImportExportException(errorMsg, e);\n+        } catch (IOException e) {\n+            String errorMessage = \"Error while retrieving saving endpoint certificate details for API: \"\n+                    + apiDto.getName() + \" as YAML\";\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Get Endpoint Certificate MetaData and Certificate detail and build JSON Array.\n+     *\n+     * @param tenantId          Tenant id of the user\n+     * @param url               Url of the endpoint\n+     * @param certDirectoryPath Directory path to export the certificates\n+     * @return JSON Array of certificate details\n+     * @throws APIImportExportException If an error occurs while retrieving endpoint certificate metadata and content\n+     */\n+    private static JsonArray getEndpointCertificateContentAndMetaData(int tenantId, String url,\n+                                                                      String certDirectoryPath)\n+            throws APIImportExportException {\n+\n+        List<CertificateMetadataDTO> certificateMetadataDTOS;\n+        CertificateManager certificateManager = CertificateManagerImpl.getInstance();\n+\n+        try {\n+            certificateMetadataDTOS = certificateManager.getCertificates(tenantId, null, url);\n+        } catch (APIManagementException e) {\n+            String errorMsg = \"Error retrieving certificate meta data. For tenantId: \" + tenantId + \" hostname: \"\n+                    + url;\n+            throw new APIImportExportException(errorMsg, e);\n+        }\n+\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        JsonArray certificatesList = new JsonArray();\n+        certificateMetadataDTOS.forEach(metadataDTO -> {\n+            ByteArrayInputStream certificate = null;\n+            try {\n+                certificate = certificateManager.getCertificateContent(metadataDTO.getAlias());\n+                certificate.close();\n+                byte[] certificateContent = IOUtils.toByteArray(certificate);\n+                String certificateContentEncoded = APIConstants.BEGIN_CERTIFICATE_STRING\n+                        .concat(new String(Base64.encodeBase64(certificateContent))).concat(\"\\n\")\n+                        .concat(APIConstants.END_CERTIFICATE_STRING);\n+                CommonUtil.writeFile(certDirectoryPath + File.separator + metadataDTO.getAlias() + \".crt\",\n+                        certificateContentEncoded);\n+                // Add the file name to the Certificate Metadata\n+                JsonObject modifiedCertificateMetadata = (JsonObject) gson.toJsonTree(metadataDTO);\n+                modifiedCertificateMetadata.addProperty(ImportExportConstants.CERTIFICATE_FILE,\n+                        metadataDTO.getAlias() + \".crt\");\n+                certificatesList.add(modifiedCertificateMetadata);\n+            } catch (APIManagementException e) {\n+                log.error(\"Error retrieving certificate content. For tenantId: \" + tenantId + \" hostname: \"\n+                        + url + \" alias: \" + metadataDTO.getAlias(), e);\n+            } catch (IOException e) {\n+                log.error(\"Error while converting certificate content to Byte Array. For tenantId: \" + tenantId\n+                        + \" hostname: \" + url + \" alias: \" + metadataDTO.getAlias(), e);\n+            } catch (APIImportExportException e) {\n+                log.error(\"Error while writing the certificate content. For tenantId: \" + tenantId + \" hostname: \"\n+                        + url + \" alias: \" + metadataDTO.getAlias(), e);\n+            } finally {\n+                if (certificate != null) {\n+                    IOUtils.closeQuietly(certificate);\n+                }\n+            }\n+        });\n+        return certificatesList;\n+    }\n+\n+    /**\n+     * Get endpoint url list from endpoint config.\n+     *\n+     * @param endpointConfig JSON converted endpoint config\n+     * @param type           End point type - production/sandbox\n+     * @return List of host names\n+     */\n+    private static List<String> getEndpointURLs(JSONObject endpointConfig, String type, String apiName) {\n+        List<String> urls = new ArrayList<>();\n+        if (endpointConfig != null) {\n+            try {\n+                Object item;\n+                item = endpointConfig.get(type);\n+                if (item instanceof JSONArray) {\n+                    JSONArray endpointsJSON = new JSONArray(endpointConfig.getJSONArray(type).toString());\n+                    for (int i = 0; i < endpointsJSON.length(); i++) {\n+                        try {\n+                            String urlValue = endpointsJSON.getJSONObject(i).get(APIConstants.API_DATA_URL).toString();\n+                            urls.add(urlValue);\n+                        } catch (JSONException ex) {\n+                            log.error(\"Endpoint URL extraction from endpoints JSON object failed in API: \"\n+                                    + apiName, ex);\n+                        }\n+                    }\n+                } else if (item instanceof JSONObject) {\n+                    JSONObject endpointJSON = new JSONObject(endpointConfig.getJSONObject(type).toString());\n+                    try {\n+                        String urlValue = endpointJSON.get(APIConstants.API_DATA_URL).toString();\n+                        urls.add(urlValue);\n+                    } catch (JSONException ex) {\n+                        log.error(\"Endpoint URL extraction from endpoint JSON object failed in API: \" + apiName, ex);\n+                    }\n+                }\n+            } catch (JSONException ex) {\n+                log.info(\"Endpoint type: \" + type + \" not found in API: \" + apiName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU1MTU2Mw=="}, "originalCommit": {"oid": "67a7a292f0788f2879e86f6675caf1d27f063c89"}, "originalPosition": 827}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU5NDUxNA==", "bodyText": "Fixed via 150d9ab", "url": "https://github.com/wso2/carbon-apimgt/pull/9406#discussion_r527594514", "createdAt": "2020-11-20T10:24:09Z", "author": {"login": "wasuradananjith"}, "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/utils/ExportUtils.java", "diffHunk": "@@ -0,0 +1,1087 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.apimgt.rest.api.publisher.v1.utils;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import org.apache.axiom.om.OMElement;\n+import org.apache.commons.codec.binary.Base64;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.json.JSONTokener;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.APIProvider;\n+import org.wso2.carbon.apimgt.api.dto.CertificateMetadataDTO;\n+import org.wso2.carbon.apimgt.api.dto.ClientCertificateDTO;\n+import org.wso2.carbon.apimgt.api.model.API;\n+import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.api.model.APIProduct;\n+import org.wso2.carbon.apimgt.api.model.APIProductIdentifier;\n+import org.wso2.carbon.apimgt.api.model.Documentation;\n+import org.wso2.carbon.apimgt.api.model.Identifier;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.certificatemgt.CertificateManager;\n+import org.wso2.carbon.apimgt.impl.certificatemgt.CertificateManagerImpl;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportException;\n+import org.wso2.carbon.apimgt.impl.importexport.ExportFormat;\n+import org.wso2.carbon.apimgt.impl.importexport.ImportExportConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.utils.CommonUtil;\n+import org.wso2.carbon.apimgt.impl.internal.ServiceReferenceHolder;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.apimgt.impl.wsdl.util.SOAPToRESTConstants;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.APIDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.APIProductDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.MediationPolicyDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.ProductAPIDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.utils.mappings.APIMappingUtil;\n+import org.wso2.carbon.apimgt.rest.api.util.RestApiConstants;\n+import org.wso2.carbon.apimgt.rest.api.util.utils.RestApiUtil;\n+import org.wso2.carbon.registry.api.Collection;\n+import org.wso2.carbon.registry.api.Registry;\n+import org.wso2.carbon.registry.api.RegistryException;\n+import org.wso2.carbon.registry.api.Resource;\n+import org.wso2.carbon.registry.core.RegistryConstants;\n+import org.wso2.carbon.registry.core.session.UserRegistry;\n+import org.wso2.carbon.utils.multitenancy.MultitenantUtils;\n+\n+import javax.xml.namespace.QName;\n+import javax.xml.stream.XMLStreamException;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ExportUtils {\n+\n+    private static final Log log = LogFactory.getLog(ExportUtils.class);\n+    private static final String IN = \"in\";\n+    private static final String OUT = \"out\";\n+    private static final String SOAPTOREST = \"SoapToRest\";\n+\n+    /**\n+     * Validate name, version and provider before exporting an API/API Product\n+     *\n+     * @param name         API/API Product Name\n+     * @param version      API/API Product version\n+     * @param providerName Name of the provider\n+     * @return Name of the provider\n+     * @throws APIManagementException If an error occurs while retrieving the provider name from name, version\n+     *                                and tenant\n+     */\n+    public static String validateExportParams(String name, String version, String providerName)\n+            throws APIManagementException {\n+        if (name == null || version == null) {\n+            RestApiUtil.handleBadRequest(\"'name' (\" + name + \") or 'version' (\" + version\n+                    + \") should not be null.\", log);\n+        }\n+        String apiRequesterDomain = RestApiUtil.getLoggedInUserTenantDomain();\n+\n+        // If provider name is not given\n+        if (StringUtils.isBlank(providerName)) {\n+            // Retrieve the provider who is in same tenant domain and who owns the same API (by comparing\n+            // API name and the version)\n+            providerName = APIUtil.getAPIProviderFromAPINameVersionTenant(name, version, apiRequesterDomain);\n+\n+            // If there is no provider in current domain, the API cannot be exported\n+            if (providerName == null) {\n+                String errorMessage = \"Error occurred while exporting. API: \" + name + \" version: \" + version\n+                        + \" not found\";\n+                RestApiUtil.handleResourceNotFoundError(errorMessage, log);\n+            }\n+        }\n+\n+        if (!StringUtils.equals(MultitenantUtils.getTenantDomain(providerName), apiRequesterDomain)) {\n+            // Not authorized to export requested API\n+            RestApiUtil.handleAuthorizationFailure(RestApiConstants.RESOURCE_API +\n+                    \" name:\" + name + \" version:\" + version + \" provider:\" + providerName, log);\n+        }\n+        return providerName;\n+    }\n+\n+    /**\n+     * Exports an API from API Manager for a given API. Meta information, API icon, documentation,\n+     * WSDL and sequences are exported.\n+     *\n+     * @param apiProvider    API Provider\n+     * @param apiIdentifier  API Identifier\n+     * @param apiDtoToReturn API DTO\n+     * @param userName       Username\n+     * @param exportFormat   Format of output documents. Can be YAML or JSON\n+     * @param preserveStatus Preserve API status on export\n+     * @return\n+     * @throws APIManagementException If an error occurs while getting governance registry\n+     */\n+    public static File exportApi(APIProvider apiProvider, APIIdentifier apiIdentifier, APIDTO apiDtoToReturn,\n+                                 String userName, ExportFormat exportFormat, Boolean preserveStatus)\n+            throws APIManagementException {\n+        int tenantId = 0;\n+        try {\n+            // Create temp location for storing API data\n+            File exportFolder = CommonUtil.createTempDirectory(apiIdentifier);\n+            String exportAPIBasePath = exportFolder.toString();\n+            String archivePath = exportAPIBasePath.concat(File.separator + apiIdentifier.getApiName() + \"-\"\n+                    + apiIdentifier.getVersion());\n+            tenantId = APIUtil.getTenantId(userName);\n+            UserRegistry registry = ServiceReferenceHolder.getInstance().getRegistryService().\n+                    getGovernanceSystemRegistry(tenantId);\n+\n+            CommonUtil.createDirectory(archivePath);\n+\n+            addThumbnailToArchive(archivePath, apiIdentifier, registry);\n+            addSOAPToRESTMediationToArchive(archivePath, apiIdentifier, registry);\n+            addDocumentationToArchive(archivePath, apiIdentifier, registry, exportFormat, apiProvider);\n+\n+            if (StringUtils.isNotEmpty(apiDtoToReturn.getWsdlUrl())) {\n+                addWSDLtoArchive(archivePath, apiIdentifier, registry);\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"No WSDL URL found for API: \" + apiIdentifier + \". Skipping WSDL export.\");\n+            }\n+\n+            addSequencesToArchive(archivePath, apiIdentifier, apiDtoToReturn, registry, exportFormat);\n+\n+            // Set API status to created if the status is not preserved\n+            if (!preserveStatus) {\n+                apiDtoToReturn.setLifeCycleStatus(APIConstants.CREATED);\n+            }\n+\n+            addEndpointCertificatesToArchive(archivePath, apiDtoToReturn, tenantId, exportFormat);\n+            addAPIMetaInformationToArchive(archivePath, apiDtoToReturn, exportFormat, apiProvider, apiIdentifier, userName);\n+\n+            // Export mTLS authentication related certificates\n+            if (apiProvider.isClientCertificateBasedAuthenticationConfigured()) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Mutual SSL enabled. Exporting client certificates.\");\n+                }\n+                addClientCertificatesToArchive(archivePath, apiIdentifier, tenantId, apiProvider, exportFormat);\n+            }\n+            CommonUtil.archiveDirectory(exportAPIBasePath);\n+            FileUtils.deleteQuietly(new File(exportAPIBasePath));\n+            return new File(exportAPIBasePath + APIConstants.ZIP_FILE_EXTENSION);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while getting governance registry for tenant: \" + tenantId;\n+            throw new APIManagementException(errorMessage, e);\n+        } catch (APIManagementException | APIImportExportException e) {\n+            RestApiUtil.handleInternalServerError(\"Error while exporting \" + RestApiConstants.RESOURCE_API, e, log);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Exports an API Product from API Manager for a given API Product. MMeta information, API Product icon, documentation, client certificates\n+     * and dependent APIs are exported.\n+     *\n+     * @param apiProvider           API Provider\n+     * @param apiProductIdentifier  API Product Identifier\n+     * @param apiProductDtoToReturn API Product DTO\n+     * @param userName              Username\n+     * @param exportFormat          Format of output documents. Can be YAML or JSON\n+     * @param preserveStatus        Preserve API Product status on export\n+     * @return\n+     * @throws APIManagementException If an error occurs while getting governance registry\n+     */\n+    public static File exportApiProduct(APIProvider apiProvider, APIProductIdentifier apiProductIdentifier,\n+                                        APIProductDTO apiProductDtoToReturn, String userName, ExportFormat exportFormat,\n+                                        Boolean preserveStatus)\n+            throws APIManagementException {\n+        int tenantId = 0;\n+        try {\n+            // Create temp location for storing API Product data\n+            File exportFolder = CommonUtil.createTempDirectory(apiProductIdentifier);\n+            String exportAPIBasePath = exportFolder.toString();\n+            String archivePath = exportAPIBasePath.concat(File.separator + apiProductIdentifier.getName() + \"-\"\n+                    + apiProductIdentifier.getVersion());\n+            tenantId = APIUtil.getTenantId(userName);\n+            UserRegistry registry = ServiceReferenceHolder.getInstance().getRegistryService().\n+                    getGovernanceSystemRegistry(tenantId);\n+            APIProduct apiProduct = APIMappingUtil.fromDTOtoAPIProduct(apiProductDtoToReturn, userName);\n+\n+            CommonUtil.createDirectory(archivePath);\n+\n+            addThumbnailToArchive(archivePath, apiProductIdentifier, registry);\n+            addDocumentationToArchive(archivePath, apiProductIdentifier, registry, exportFormat, apiProvider);\n+            addAPIProductMetaInformationToArchive(archivePath, apiProductDtoToReturn, exportFormat, apiProvider,\n+                    userName);\n+            addDependentAPIsToArchive(archivePath, apiProductDtoToReturn, exportFormat, apiProvider, userName,\n+                    preserveStatus);\n+\n+            // Export mTLS authentication related certificates\n+            if (apiProvider.isClientCertificateBasedAuthenticationConfigured()) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Mutual SSL enabled. Exporting client certificates.\");\n+                }\n+                addClientCertificatesToArchive(archivePath, apiProductIdentifier, tenantId, apiProvider, exportFormat);\n+            }\n+            CommonUtil.archiveDirectory(exportAPIBasePath);\n+            FileUtils.deleteQuietly(new File(exportAPIBasePath));\n+            return new File(exportAPIBasePath + APIConstants.ZIP_FILE_EXTENSION);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while getting governance registry for tenant: \" + tenantId;\n+            throw new APIManagementException(errorMessage, e);\n+        } catch (APIManagementException | APIImportExportException e) {\n+            RestApiUtil.handleInternalServerError(\"Error while exporting \" +\n+                    RestApiConstants.RESOURCE_API_PRODUCT, e, log);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Retrieve thumbnail image for the exporting API or API Product and store it in the archive directory.\n+     *\n+     * @param archivePath File path to export the thumbnail image\n+     * @param identifier  ID of the requesting API or API Product\n+     * @param registry    Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addThumbnailToArchive(String archivePath, Identifier identifier, Registry registry)\n+            throws APIImportExportException {\n+        String thumbnailUrl = APIConstants.API_IMAGE_LOCATION + RegistryConstants.PATH_SEPARATOR\n+                + identifier.getProviderName() + RegistryConstants.PATH_SEPARATOR + identifier.getName()\n+                + RegistryConstants.PATH_SEPARATOR + identifier.getVersion() + RegistryConstants.PATH_SEPARATOR\n+                + APIConstants.API_ICON_IMAGE;\n+        String localImagePath = archivePath + File.separator + ImportExportConstants.IMAGE_RESOURCE;\n+        try {\n+            if (registry.resourceExists(thumbnailUrl)) {\n+                Resource icon = registry.get(thumbnailUrl);\n+                String mediaType = icon.getMediaType();\n+                String extension = ImportExportConstants.fileExtensionMapping.get(mediaType);\n+                if (extension != null) {\n+                    CommonUtil.createDirectory(localImagePath);\n+                    try (InputStream imageDataStream = icon.getContentStream();\n+                         OutputStream outputStream = new FileOutputStream(localImagePath + File.separator\n+                                 + APIConstants.API_ICON_IMAGE + APIConstants.DOT + extension)) {\n+                        IOUtils.copy(imageDataStream, outputStream);\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"Thumbnail image retrieved successfully for API/API Product: \" + identifier.getName()\n+                                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                                    + identifier.getVersion());\n+                        }\n+                    }\n+                } else {\n+                    //api gets imported without thumbnail\n+                    log.error(\"Unsupported media type for icon \" + mediaType + \". Skipping thumbnail export.\");\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"Thumbnail URL [\" + thumbnailUrl + \"] does not exists in registry for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion() + \". Skipping thumbnail export.\");\n+            }\n+        } catch (RegistryException e) {\n+            log.error(\"Error while retrieving API/API Product Thumbnail \" + thumbnailUrl, e);\n+        } catch (IOException e) {\n+            //Exception is ignored by logging due to the reason that Thumbnail is not essential for\n+            //an API to be recreated.\n+            log.error(\"I/O error while writing API/API Product Thumbnail: \" + thumbnailUrl + \" to file\", e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve SOAP to REST mediation logic for the exporting API and store it in the archive directory\n+     *\n+     * @param archivePath   File path to export the SOAPToREST mediation logic\n+     * @param apiIdentifier ID of the requesting API\n+     * @param registry      Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addSOAPToRESTMediationToArchive(String archivePath, APIIdentifier apiIdentifier,\n+                                                       UserRegistry registry) throws APIImportExportException {\n+        String soapToRestBaseUrl = \"/apimgt/applicationdata/provider\" + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getProviderName() + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getApiName() + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getVersion() + RegistryConstants.PATH_SEPARATOR +\n+                SOAPToRESTConstants.SOAP_TO_REST_RESOURCE;\n+\n+        InputStream inputStream = null;\n+        OutputStream outputStream = null;\n+        try {\n+            if (registry.resourceExists(soapToRestBaseUrl)) {\n+                Collection inFlow = (org.wso2.carbon.registry.api.Collection) registry.get(soapToRestBaseUrl\n+                        + RegistryConstants.PATH_SEPARATOR + IN);\n+                Collection outFlow = (org.wso2.carbon.registry.api.Collection) registry.get(soapToRestBaseUrl\n+                        + RegistryConstants.PATH_SEPARATOR + OUT);\n+\n+                CommonUtil.createDirectory(archivePath + File.separator + SOAPTOREST + File.separator + IN);\n+                CommonUtil.createDirectory(archivePath + File.separator + SOAPTOREST + File.separator + OUT);\n+                if (inFlow != null) {\n+                    for (String inFlowPath : inFlow.getChildren()) {\n+                        inputStream = registry.get(inFlowPath).getContentStream();\n+                        outputStream = new FileOutputStream(archivePath + File.separator + SOAPTOREST\n+                                + File.separator + IN +\n+                                inFlowPath.substring(inFlowPath.lastIndexOf(RegistryConstants.PATH_SEPARATOR)));\n+                        IOUtils.copy(inputStream, outputStream);\n+                        IOUtils.closeQuietly(inputStream);\n+                        IOUtils.closeQuietly(outputStream);\n+                    }\n+                }\n+                if (outFlow != null) {\n+                    for (String outFlowPath : outFlow.getChildren()) {\n+                        inputStream = registry.get(outFlowPath).getContentStream();\n+                        outputStream = new FileOutputStream(archivePath + File.separator + SOAPTOREST\n+                                + File.separator + OUT +\n+                                outFlowPath.substring(outFlowPath.lastIndexOf(RegistryConstants.PATH_SEPARATOR)));\n+                        IOUtils.copy(inputStream, outputStream);\n+                        IOUtils.closeQuietly(inputStream);\n+                        IOUtils.closeQuietly(outputStream);\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new APIImportExportException(\"I/O error while writing API SOAP to REST logic to file\", e);\n+        } catch (RegistryException e) {\n+            throw new APIImportExportException(\"Error while retrieving SOAP to REST logic\", e);\n+        } finally {\n+            IOUtils.closeQuietly(inputStream);\n+            IOUtils.closeQuietly(outputStream);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve documentation for the exporting API or API Product and store it in the archive directory.\n+     * FILE, INLINE, MARKDOWN and URL documentations are handled.\n+     *\n+     * @param archivePath  File path to export the documents\n+     * @param identifier   ID of the requesting API or API Product\n+     * @param registry     Current tenant registry\n+     * @param exportFormat Format for export\n+     * @param apiProvider  API Provider\n+     * @throws APIImportExportException If an error occurs while retrieving documents from the\n+     *                                  registry or storing in the archive directory\n+     * @throws APIManagementException   If an error occurs while retrieving document details\n+     */\n+    public static void addDocumentationToArchive(String archivePath, Identifier identifier, Registry registry,\n+                                                 ExportFormat exportFormat, APIProvider apiProvider)\n+            throws APIImportExportException, APIManagementException {\n+\n+        List<Documentation> docList = apiProvider.getAllDocumentation(identifier);\n+        String tenantDomain = RestApiUtil.getLoggedInUserTenantDomain();\n+        if (!docList.isEmpty()) {\n+            Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+            String docDirectoryPath = archivePath + File.separator + ImportExportConstants.DOCUMENT_DIRECTORY;\n+            CommonUtil.createDirectory(docDirectoryPath);\n+            try {\n+                for (Documentation doc : docList) {\n+                    // Retrieving the document again since objects in docList might have missing fields\n+                    Documentation individualDocument = apiProvider.getDocumentation(doc.getId(), tenantDomain);\n+                    String sourceType = individualDocument.getSourceType().name();\n+                    String resourcePath = null;\n+                    String localFileName = null;\n+                    String individualDocDirectoryPath = docDirectoryPath + File.separator + individualDocument.getName();\n+                    CommonUtil.createDirectory(individualDocDirectoryPath);\n+                    writeDtoToFile(individualDocDirectoryPath +\n+                                    ImportExportConstants.DOCUMENT_FILE_NAME, exportFormat,\n+                            ImportExportConstants.TYPE_DOCUMENTS, individualDocument);\n+                    if (Documentation.DocumentSourceType.FILE.toString().equalsIgnoreCase(sourceType)) {\n+                        localFileName = individualDocument.getFilePath().substring(\n+                                individualDocument.getFilePath().lastIndexOf(RegistryConstants.PATH_SEPARATOR) + 1);\n+                        resourcePath = APIUtil.getDocumentationFilePath(identifier, localFileName);\n+                        individualDocument.setFilePath(localFileName);\n+                    } else if (Documentation.DocumentSourceType.INLINE.toString().equalsIgnoreCase(sourceType)\n+                            || Documentation.DocumentSourceType.MARKDOWN.toString().equalsIgnoreCase(sourceType)) {\n+                        // Inline/Markdown content file name would be same as the documentation name\n+                        localFileName = individualDocument.getName();\n+                        resourcePath = APIUtil.getAPIOrAPIProductDocPath(identifier) + APIConstants.INLINE_DOCUMENT_CONTENT_DIR\n+                                + RegistryConstants.PATH_SEPARATOR + localFileName;\n+                    }\n+\n+                    if (resourcePath != null) {\n+                        // Write content for Inline/Markdown/File type documentations only\n+                        // Check whether resource exists in the registry\n+                        if (registry.resourceExists(resourcePath)) {\n+                            Resource docFile = registry.get(resourcePath);\n+                            try (OutputStream outputStream = new FileOutputStream(individualDocDirectoryPath +\n+                                    File.separator + localFileName);\n+                                 InputStream fileInputStream = docFile.getContentStream()) {\n+                                IOUtils.copy(fileInputStream, outputStream);\n+                            }\n+                        } else {\n+                            // Log error and avoid throwing as we give capability to export document artifact without the\n+                            // content if does not exists\n+                            String errorMessage = \"Documentation resource for API/API Product: \" + identifier.getName()\n+                                    + \" not found in \" + resourcePath;\n+                            log.error(errorMessage);\n+                        }\n+                    }\n+                }\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Documentation retrieved successfully for API/API Product: \" + identifier.getName()\n+                            + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + identifier.getVersion());\n+                }\n+            } catch (IOException e) {\n+                String errorMessage = \"I/O error while writing documentation to file for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion();\n+                log.error(errorMessage, e);\n+                throw new APIImportExportException(errorMessage, e);\n+            } catch (RegistryException e) {\n+                String errorMessage = \"Error while retrieving documentation for API/API Product: \" + identifier.getName()\n+                        + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + identifier.getVersion();\n+                log.error(errorMessage, e);\n+                throw new APIImportExportException(errorMessage, e);\n+            }\n+        } else if (log.isDebugEnabled()) {\n+            log.debug(\"No documentation found for API/API Product: \" + identifier + \". Skipping documentation export.\");\n+        }\n+    }\n+\n+    /**\n+     * Retrieve WSDL for the exporting API and store it in the archive directory.\n+     *\n+     * @param archivePath   File path to export the WSDL\n+     * @param apiIdentifier ID of the requesting API\n+     * @param registry      Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving WSDL from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addWSDLtoArchive(String archivePath, APIIdentifier apiIdentifier, Registry registry)\n+            throws APIImportExportException {\n+\n+        String wsdlPath = APIConstants.API_WSDL_RESOURCE_LOCATION + apiIdentifier.getProviderName() + \"--\"\n+                + apiIdentifier.getApiName() + apiIdentifier.getVersion() + APIConstants.WSDL_FILE_EXTENSION;\n+        try {\n+            if (registry.resourceExists(wsdlPath)) {\n+                CommonUtil.createDirectory(archivePath + File.separator + \"WSDL\");\n+                Resource wsdl = registry.get(wsdlPath);\n+                try (InputStream wsdlStream = wsdl.getContentStream();\n+                     OutputStream outputStream = new FileOutputStream(archivePath + File.separator + \"WSDL\"\n+                             + File.separator + apiIdentifier.getApiName() + \"-\" + apiIdentifier.getVersion()\n+                             + APIConstants.WSDL_FILE_EXTENSION)) {\n+                    IOUtils.copy(wsdlStream, outputStream);\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"WSDL file: \" + wsdlPath + \" retrieved successfully\");\n+                    }\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"WSDL resource does not exists in path: \" + wsdlPath + \". Skipping WSDL export.\");\n+            }\n+        } catch (IOException e) {\n+            String errorMessage = \"I/O error while writing WSDL: \" + wsdlPath + \" to file\";\n+            throw new APIImportExportException(errorMessage, e);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while retrieving WSDL: \" + wsdlPath + \" to file\";\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve available custom sequences and API specific sequences for API export, and store it in the archive\n+     * directory.\n+     *\n+     * @param archivePath   File path to export the sequences\n+     * @param apiIdentifier API Identifier\n+     * @param apiDto        API DTO\n+     * @param registry      Current tenant registry\n+     * @param exportFormat  Export format of file\n+     * @throws APIImportExportException If an error occurs while exporting sequences\n+     */\n+    public static void addSequencesToArchive(String archivePath, APIIdentifier apiIdentifier, APIDTO apiDto,\n+                                             Registry registry, ExportFormat exportFormat) throws APIImportExportException {\n+\n+        Map<String, String> sequences = new HashMap<>();\n+        String seqArchivePath = archivePath.concat(File.separator + \"Sequences\");\n+        List<MediationPolicyDTO> mediationPolicyDtos = apiDto.getMediationPolicies();\n+        if (!apiDto.getMediationPolicies().isEmpty()) {\n+            CommonUtil.createDirectory(seqArchivePath);\n+            for (MediationPolicyDTO mediationPolicyDto : mediationPolicyDtos) {\n+                AbstractMap.SimpleEntry<String, OMElement> sequenceDetails;\n+                String sequenceName = mediationPolicyDto.getName();\n+                String direction = mediationPolicyDto.getType().toLowerCase();\n+                String pathToExportedSequence = seqArchivePath + File.separator + direction + \"-sequence\" +\n+                        File.separator;\n+                String pathToIndividualSequenceFile = pathToExportedSequence + ImportExportConstants.SEQUENCE_FILE_NAME;\n+                if (sequenceName != null) {\n+                    sequenceDetails = getCustomSequence(sequenceName, direction, registry);\n+                    if (sequenceDetails == null) {\n+                        // If sequence doesn't exist in 'apimgt/customsequences/{in/out/fault}' directory check in API\n+                        // specific registry path\n+                        sequenceDetails = getAPISpecificSequence(apiIdentifier, sequenceName, direction, registry);\n+                        pathToExportedSequence += ImportExportConstants.CUSTOM_TYPE + File.separator;\n+                    }\n+                    writeSequenceToFile(pathToExportedSequence, sequenceDetails, apiIdentifier);\n+                    try {\n+                        writeDtoToFile(pathToIndividualSequenceFile, exportFormat, ImportExportConstants.TYPE_SEQUENCE,\n+                                mediationPolicyDto);\n+                    } catch (IOException e) {\n+                        String errorMessage = \"I/O error while writing sequence: \" + sequenceName + \" to file\";\n+                        throw new APIImportExportException(errorMessage, e);\n+                    }\n+                }\n+            }\n+        } else if (log.isDebugEnabled()) {\n+            log.debug(\"No custom sequences available for API: \" + apiIdentifier.getApiName() + StringUtils.SPACE\n+                    + APIConstants.API_DATA_VERSION + \": \" + apiIdentifier.getVersion()\n+                    + \". Skipping custom sequence export.\");\n+        }\n+    }\n+\n+    /**\n+     * Retrieve custom sequence details from the registry.\n+     *\n+     * @param sequenceName Name of the sequence\n+     * @param type         Sequence type\n+     * @param registry     Current tenant registry\n+     * @return Registry resource name of the sequence and its content\n+     * @throws APIImportExportException If an error occurs while retrieving registry elements\n+     */\n+    private static AbstractMap.SimpleEntry<String, OMElement> getCustomSequence(String sequenceName, String type,\n+                                                                                Registry registry)\n+            throws APIImportExportException {\n+\n+        String regPath = null;\n+        if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_IN.equals(type)) {\n+            regPath = APIConstants.API_CUSTOM_INSEQUENCE_LOCATION;\n+        } else if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_OUT.equals(type)) {\n+            regPath = APIConstants.API_CUSTOM_OUTSEQUENCE_LOCATION;\n+        } else if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_FAULT.equals(type)) {\n+            regPath = APIConstants.API_CUSTOM_FAULTSEQUENCE_LOCATION;\n+        }\n+        return getSeqDetailsFromRegistry(sequenceName, regPath, registry);\n+    }\n+\n+    /**\n+     * Retrieve API Specific sequence details from the registry.\n+     *\n+     * @param sequenceName Name of the sequence\n+     * @param type         Sequence type\n+     * @param registry     Current tenant registry\n+     * @return Registry resource name of the sequence and its content\n+     * @throws APIImportExportException If an error occurs while retrieving registry elements\n+     */\n+    private static AbstractMap.SimpleEntry<String, OMElement> getAPISpecificSequence(APIIdentifier api,\n+                                                                                     String sequenceName, String type,\n+                                                                                     Registry registry)\n+            throws APIImportExportException {\n+\n+        String regPath = APIConstants.API_ROOT_LOCATION + RegistryConstants.PATH_SEPARATOR + api.getProviderName()\n+                + RegistryConstants.PATH_SEPARATOR + api.getApiName() + RegistryConstants.PATH_SEPARATOR\n+                + api.getVersion() + RegistryConstants.PATH_SEPARATOR + type;\n+        return getSeqDetailsFromRegistry(sequenceName, regPath, registry);\n+    }\n+\n+    /**\n+     * Retrieve sequence details from registry by given registry path.\n+     *\n+     * @param sequenceName Sequence Name\n+     * @param regPath      Registry path\n+     * @param registry     Registry\n+     * @return Sequence details as a simple entry\n+     * @throws APIImportExportException If an error occurs while retrieving sequence details from registry\n+     */\n+    private static AbstractMap.SimpleEntry<String, OMElement> getSeqDetailsFromRegistry(String sequenceName,\n+                                                                                        String regPath, Registry registry)\n+            throws APIImportExportException {\n+\n+        AbstractMap.SimpleEntry<String, OMElement> sequenceDetails = null;\n+        Collection seqCollection;\n+\n+        try {\n+            seqCollection = (Collection) registry.get(regPath);\n+            if (seqCollection != null) {\n+                String[] childPaths = seqCollection.getChildren();\n+                for (String childPath : childPaths) {\n+                    Resource sequence = registry.get(childPath);\n+                    OMElement seqElement = APIUtil.buildOMElement(sequence.getContentStream());\n+                    if (sequenceName.equals(seqElement.getAttributeValue(new QName(\"name\")))) {\n+                        String sequenceFileName = sequenceName + APIConstants.XML_EXTENSION;\n+                        sequenceDetails = new AbstractMap.SimpleEntry<>(sequenceFileName, seqElement);\n+                        break;\n+                    }\n+                }\n+            }\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while retrieving sequence: \" + sequenceName + \" from the path: \" + regPath;\n+            throw new APIImportExportException(errorMessage, e);\n+        } catch (Exception e) {\n+            //APIUtil.buildOMElement() throws a generic exception\n+            String errorMessage = \"Error while reading content for sequence: \" + sequenceName + \" from the registry\";\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+        return sequenceDetails;\n+    }\n+\n+    /**\n+     * Store API Specific or custom sequences in the archive directory.\n+     *\n+     * @param sequenceDetails Details of the sequence\n+     * @param apiIdentifier   ID of the requesting API\n+     * @throws APIImportExportException If an error occurs while serializing XML stream or storing in\n+     *                                  archive directory\n+     */\n+    private static void writeSequenceToFile(String pathToExportedSequence,\n+                                            AbstractMap.SimpleEntry<String, OMElement> sequenceDetails,\n+                                            APIIdentifier apiIdentifier)\n+            throws APIImportExportException {\n+\n+        if (sequenceDetails != null) {\n+            String sequenceFileName = sequenceDetails.getKey();\n+            OMElement sequenceConfig = sequenceDetails.getValue();\n+            CommonUtil.createDirectory(pathToExportedSequence);\n+            String exportedSequenceFile = pathToExportedSequence + sequenceFileName;\n+            try (OutputStream outputStream = new FileOutputStream(exportedSequenceFile)) {\n+                sequenceConfig.serialize(outputStream);\n+                if (log.isDebugEnabled()) {\n+                    log.debug(sequenceFileName + \" of API: \" + apiIdentifier.getApiName() + \" retrieved successfully\");\n+                }\n+            } catch (IOException e) {\n+                String errorMessage = \"Unable to find file: \" + exportedSequenceFile;\n+                throw new APIImportExportException(errorMessage, e);\n+            } catch (XMLStreamException e) {\n+                String errorMessage = \"Error while processing XML stream \";\n+                throw new APIImportExportException(errorMessage, e);\n+            }\n+        } else {\n+            String errorMessage = \"Error while writing sequence of API: \" + apiIdentifier.getApiName() + \" to file.\";\n+            throw new APIImportExportException(errorMessage);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve the endpoint certificates and store those in the archive directory.\n+     *\n+     * @param archivePath  File path to export the endpoint certificates\n+     * @param apiDto       API DTO to be exported\n+     * @param tenantId     Tenant id of the user\n+     * @param exportFormat Export format of file\n+     * @throws APIImportExportException If an error occurs while exporting endpoint certificates\n+     */\n+    public static void addEndpointCertificatesToArchive(String archivePath, APIDTO apiDto, int tenantId,\n+                                                        ExportFormat exportFormat) throws APIImportExportException {\n+        List<String> productionEndpoints;\n+        List<String> sandboxEndpoints;\n+        Set<String> uniqueEndpointURLs = new HashSet<>();\n+        JsonArray endpointCertificatesDetails = new JsonArray();\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        String endpointConfigString = gson.toJson(apiDto.getEndpointConfig());\n+        String endpointCertsDirectoryPath = archivePath + File.separator\n+                + ImportExportConstants.ENDPOINT_CERTIFICATES_DIRECTORY;\n+        CommonUtil.createDirectory(endpointCertsDirectoryPath);\n+\n+        if (StringUtils.isEmpty(endpointConfigString)) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Endpoint Details are empty for API: \" + apiDto.getName() + StringUtils.SPACE\n+                        + APIConstants.API_DATA_VERSION + \": \" + apiDto.getVersion());\n+            }\n+            return;\n+        }\n+        try {\n+            JSONTokener tokener = new JSONTokener(endpointConfigString);\n+            JSONObject endpointConfig = new JSONObject(tokener);\n+            productionEndpoints = getEndpointURLs(endpointConfig, APIConstants.API_DATA_PRODUCTION_ENDPOINTS,\n+                    apiDto.getName());\n+            sandboxEndpoints = getEndpointURLs(endpointConfig, APIConstants.API_DATA_SANDBOX_ENDPOINTS,\n+                    apiDto.getName());\n+            uniqueEndpointURLs.addAll(productionEndpoints); // Remove duplicate and append result\n+            uniqueEndpointURLs.addAll(sandboxEndpoints);\n+\n+            for (String url : uniqueEndpointURLs) {\n+                JsonArray certificateListOfUrl = getEndpointCertificateContentAndMetaData(tenantId, url,\n+                        endpointCertsDirectoryPath);\n+                endpointCertificatesDetails.addAll(certificateListOfUrl);\n+            }\n+            if (endpointCertificatesDetails.size() > 0) {\n+                writeDtoToFile(endpointCertsDirectoryPath +\n+                                ImportExportConstants.ENDPOINTS_CERTIFICATE_FILE, exportFormat,\n+                        ImportExportConstants.TYPE_ENDPOINT_CERTIFICATES, endpointCertificatesDetails);\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"No endpoint certificates available for API: \" + apiDto.getName() + StringUtils.SPACE\n+                        + APIConstants.API_DATA_VERSION + \": \" + apiDto.getVersion() + \". Skipping certificate export.\");\n+            }\n+        } catch (JSONException e) {\n+            String errorMsg = \"Error in converting Endpoint config to JSON object in API: \" + apiDto.getName();\n+            throw new APIImportExportException(errorMsg, e);\n+        } catch (IOException e) {\n+            String errorMessage = \"Error while retrieving saving endpoint certificate details for API: \"\n+                    + apiDto.getName() + \" as YAML\";\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Get Endpoint Certificate MetaData and Certificate detail and build JSON Array.\n+     *\n+     * @param tenantId          Tenant id of the user\n+     * @param url               Url of the endpoint\n+     * @param certDirectoryPath Directory path to export the certificates\n+     * @return JSON Array of certificate details\n+     * @throws APIImportExportException If an error occurs while retrieving endpoint certificate metadata and content\n+     */\n+    private static JsonArray getEndpointCertificateContentAndMetaData(int tenantId, String url,\n+                                                                      String certDirectoryPath)\n+            throws APIImportExportException {\n+\n+        List<CertificateMetadataDTO> certificateMetadataDTOS;\n+        CertificateManager certificateManager = CertificateManagerImpl.getInstance();\n+\n+        try {\n+            certificateMetadataDTOS = certificateManager.getCertificates(tenantId, null, url);\n+        } catch (APIManagementException e) {\n+            String errorMsg = \"Error retrieving certificate meta data. For tenantId: \" + tenantId + \" hostname: \"\n+                    + url;\n+            throw new APIImportExportException(errorMsg, e);\n+        }\n+\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        JsonArray certificatesList = new JsonArray();\n+        certificateMetadataDTOS.forEach(metadataDTO -> {\n+            ByteArrayInputStream certificate = null;\n+            try {\n+                certificate = certificateManager.getCertificateContent(metadataDTO.getAlias());\n+                certificate.close();\n+                byte[] certificateContent = IOUtils.toByteArray(certificate);\n+                String certificateContentEncoded = APIConstants.BEGIN_CERTIFICATE_STRING\n+                        .concat(new String(Base64.encodeBase64(certificateContent))).concat(\"\\n\")\n+                        .concat(APIConstants.END_CERTIFICATE_STRING);\n+                CommonUtil.writeFile(certDirectoryPath + File.separator + metadataDTO.getAlias() + \".crt\",\n+                        certificateContentEncoded);\n+                // Add the file name to the Certificate Metadata\n+                JsonObject modifiedCertificateMetadata = (JsonObject) gson.toJsonTree(metadataDTO);\n+                modifiedCertificateMetadata.addProperty(ImportExportConstants.CERTIFICATE_FILE,\n+                        metadataDTO.getAlias() + \".crt\");\n+                certificatesList.add(modifiedCertificateMetadata);\n+            } catch (APIManagementException e) {\n+                log.error(\"Error retrieving certificate content. For tenantId: \" + tenantId + \" hostname: \"\n+                        + url + \" alias: \" + metadataDTO.getAlias(), e);\n+            } catch (IOException e) {\n+                log.error(\"Error while converting certificate content to Byte Array. For tenantId: \" + tenantId\n+                        + \" hostname: \" + url + \" alias: \" + metadataDTO.getAlias(), e);\n+            } catch (APIImportExportException e) {\n+                log.error(\"Error while writing the certificate content. For tenantId: \" + tenantId + \" hostname: \"\n+                        + url + \" alias: \" + metadataDTO.getAlias(), e);\n+            } finally {\n+                if (certificate != null) {\n+                    IOUtils.closeQuietly(certificate);\n+                }\n+            }\n+        });\n+        return certificatesList;\n+    }\n+\n+    /**\n+     * Get endpoint url list from endpoint config.\n+     *\n+     * @param endpointConfig JSON converted endpoint config\n+     * @param type           End point type - production/sandbox\n+     * @return List of host names\n+     */\n+    private static List<String> getEndpointURLs(JSONObject endpointConfig, String type, String apiName) {\n+        List<String> urls = new ArrayList<>();\n+        if (endpointConfig != null) {\n+            try {\n+                Object item;\n+                item = endpointConfig.get(type);\n+                if (item instanceof JSONArray) {\n+                    JSONArray endpointsJSON = new JSONArray(endpointConfig.getJSONArray(type).toString());\n+                    for (int i = 0; i < endpointsJSON.length(); i++) {\n+                        try {\n+                            String urlValue = endpointsJSON.getJSONObject(i).get(APIConstants.API_DATA_URL).toString();\n+                            urls.add(urlValue);\n+                        } catch (JSONException ex) {\n+                            log.error(\"Endpoint URL extraction from endpoints JSON object failed in API: \"\n+                                    + apiName, ex);\n+                        }\n+                    }\n+                } else if (item instanceof JSONObject) {\n+                    JSONObject endpointJSON = new JSONObject(endpointConfig.getJSONObject(type).toString());\n+                    try {\n+                        String urlValue = endpointJSON.get(APIConstants.API_DATA_URL).toString();\n+                        urls.add(urlValue);\n+                    } catch (JSONException ex) {\n+                        log.error(\"Endpoint URL extraction from endpoint JSON object failed in API: \" + apiName, ex);\n+                    }\n+                }\n+            } catch (JSONException ex) {\n+                log.info(\"Endpoint type: \" + type + \" not found in API: \" + apiName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU1MTU2Mw=="}, "originalCommit": {"oid": "67a7a292f0788f2879e86f6675caf1d27f063c89"}, "originalPosition": 827}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNzc4NTY4OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/utils/ExportUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwOToxNDo1MVrOH3HR6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMDoyNDoxNlrOH3J0SA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU1MzAwMQ==", "bodyText": "Use the stream with try with resources", "url": "https://github.com/wso2/carbon-apimgt/pull/9406#discussion_r527553001", "createdAt": "2020-11-20T09:14:51Z", "author": {"login": "uvindra"}, "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/utils/ExportUtils.java", "diffHunk": "@@ -0,0 +1,1087 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.apimgt.rest.api.publisher.v1.utils;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import org.apache.axiom.om.OMElement;\n+import org.apache.commons.codec.binary.Base64;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.json.JSONTokener;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.APIProvider;\n+import org.wso2.carbon.apimgt.api.dto.CertificateMetadataDTO;\n+import org.wso2.carbon.apimgt.api.dto.ClientCertificateDTO;\n+import org.wso2.carbon.apimgt.api.model.API;\n+import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.api.model.APIProduct;\n+import org.wso2.carbon.apimgt.api.model.APIProductIdentifier;\n+import org.wso2.carbon.apimgt.api.model.Documentation;\n+import org.wso2.carbon.apimgt.api.model.Identifier;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.certificatemgt.CertificateManager;\n+import org.wso2.carbon.apimgt.impl.certificatemgt.CertificateManagerImpl;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportException;\n+import org.wso2.carbon.apimgt.impl.importexport.ExportFormat;\n+import org.wso2.carbon.apimgt.impl.importexport.ImportExportConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.utils.CommonUtil;\n+import org.wso2.carbon.apimgt.impl.internal.ServiceReferenceHolder;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.apimgt.impl.wsdl.util.SOAPToRESTConstants;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.APIDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.APIProductDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.MediationPolicyDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.ProductAPIDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.utils.mappings.APIMappingUtil;\n+import org.wso2.carbon.apimgt.rest.api.util.RestApiConstants;\n+import org.wso2.carbon.apimgt.rest.api.util.utils.RestApiUtil;\n+import org.wso2.carbon.registry.api.Collection;\n+import org.wso2.carbon.registry.api.Registry;\n+import org.wso2.carbon.registry.api.RegistryException;\n+import org.wso2.carbon.registry.api.Resource;\n+import org.wso2.carbon.registry.core.RegistryConstants;\n+import org.wso2.carbon.registry.core.session.UserRegistry;\n+import org.wso2.carbon.utils.multitenancy.MultitenantUtils;\n+\n+import javax.xml.namespace.QName;\n+import javax.xml.stream.XMLStreamException;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ExportUtils {\n+\n+    private static final Log log = LogFactory.getLog(ExportUtils.class);\n+    private static final String IN = \"in\";\n+    private static final String OUT = \"out\";\n+    private static final String SOAPTOREST = \"SoapToRest\";\n+\n+    /**\n+     * Validate name, version and provider before exporting an API/API Product\n+     *\n+     * @param name         API/API Product Name\n+     * @param version      API/API Product version\n+     * @param providerName Name of the provider\n+     * @return Name of the provider\n+     * @throws APIManagementException If an error occurs while retrieving the provider name from name, version\n+     *                                and tenant\n+     */\n+    public static String validateExportParams(String name, String version, String providerName)\n+            throws APIManagementException {\n+        if (name == null || version == null) {\n+            RestApiUtil.handleBadRequest(\"'name' (\" + name + \") or 'version' (\" + version\n+                    + \") should not be null.\", log);\n+        }\n+        String apiRequesterDomain = RestApiUtil.getLoggedInUserTenantDomain();\n+\n+        // If provider name is not given\n+        if (StringUtils.isBlank(providerName)) {\n+            // Retrieve the provider who is in same tenant domain and who owns the same API (by comparing\n+            // API name and the version)\n+            providerName = APIUtil.getAPIProviderFromAPINameVersionTenant(name, version, apiRequesterDomain);\n+\n+            // If there is no provider in current domain, the API cannot be exported\n+            if (providerName == null) {\n+                String errorMessage = \"Error occurred while exporting. API: \" + name + \" version: \" + version\n+                        + \" not found\";\n+                RestApiUtil.handleResourceNotFoundError(errorMessage, log);\n+            }\n+        }\n+\n+        if (!StringUtils.equals(MultitenantUtils.getTenantDomain(providerName), apiRequesterDomain)) {\n+            // Not authorized to export requested API\n+            RestApiUtil.handleAuthorizationFailure(RestApiConstants.RESOURCE_API +\n+                    \" name:\" + name + \" version:\" + version + \" provider:\" + providerName, log);\n+        }\n+        return providerName;\n+    }\n+\n+    /**\n+     * Exports an API from API Manager for a given API. Meta information, API icon, documentation,\n+     * WSDL and sequences are exported.\n+     *\n+     * @param apiProvider    API Provider\n+     * @param apiIdentifier  API Identifier\n+     * @param apiDtoToReturn API DTO\n+     * @param userName       Username\n+     * @param exportFormat   Format of output documents. Can be YAML or JSON\n+     * @param preserveStatus Preserve API status on export\n+     * @return\n+     * @throws APIManagementException If an error occurs while getting governance registry\n+     */\n+    public static File exportApi(APIProvider apiProvider, APIIdentifier apiIdentifier, APIDTO apiDtoToReturn,\n+                                 String userName, ExportFormat exportFormat, Boolean preserveStatus)\n+            throws APIManagementException {\n+        int tenantId = 0;\n+        try {\n+            // Create temp location for storing API data\n+            File exportFolder = CommonUtil.createTempDirectory(apiIdentifier);\n+            String exportAPIBasePath = exportFolder.toString();\n+            String archivePath = exportAPIBasePath.concat(File.separator + apiIdentifier.getApiName() + \"-\"\n+                    + apiIdentifier.getVersion());\n+            tenantId = APIUtil.getTenantId(userName);\n+            UserRegistry registry = ServiceReferenceHolder.getInstance().getRegistryService().\n+                    getGovernanceSystemRegistry(tenantId);\n+\n+            CommonUtil.createDirectory(archivePath);\n+\n+            addThumbnailToArchive(archivePath, apiIdentifier, registry);\n+            addSOAPToRESTMediationToArchive(archivePath, apiIdentifier, registry);\n+            addDocumentationToArchive(archivePath, apiIdentifier, registry, exportFormat, apiProvider);\n+\n+            if (StringUtils.isNotEmpty(apiDtoToReturn.getWsdlUrl())) {\n+                addWSDLtoArchive(archivePath, apiIdentifier, registry);\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"No WSDL URL found for API: \" + apiIdentifier + \". Skipping WSDL export.\");\n+            }\n+\n+            addSequencesToArchive(archivePath, apiIdentifier, apiDtoToReturn, registry, exportFormat);\n+\n+            // Set API status to created if the status is not preserved\n+            if (!preserveStatus) {\n+                apiDtoToReturn.setLifeCycleStatus(APIConstants.CREATED);\n+            }\n+\n+            addEndpointCertificatesToArchive(archivePath, apiDtoToReturn, tenantId, exportFormat);\n+            addAPIMetaInformationToArchive(archivePath, apiDtoToReturn, exportFormat, apiProvider, apiIdentifier, userName);\n+\n+            // Export mTLS authentication related certificates\n+            if (apiProvider.isClientCertificateBasedAuthenticationConfigured()) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Mutual SSL enabled. Exporting client certificates.\");\n+                }\n+                addClientCertificatesToArchive(archivePath, apiIdentifier, tenantId, apiProvider, exportFormat);\n+            }\n+            CommonUtil.archiveDirectory(exportAPIBasePath);\n+            FileUtils.deleteQuietly(new File(exportAPIBasePath));\n+            return new File(exportAPIBasePath + APIConstants.ZIP_FILE_EXTENSION);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while getting governance registry for tenant: \" + tenantId;\n+            throw new APIManagementException(errorMessage, e);\n+        } catch (APIManagementException | APIImportExportException e) {\n+            RestApiUtil.handleInternalServerError(\"Error while exporting \" + RestApiConstants.RESOURCE_API, e, log);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Exports an API Product from API Manager for a given API Product. MMeta information, API Product icon, documentation, client certificates\n+     * and dependent APIs are exported.\n+     *\n+     * @param apiProvider           API Provider\n+     * @param apiProductIdentifier  API Product Identifier\n+     * @param apiProductDtoToReturn API Product DTO\n+     * @param userName              Username\n+     * @param exportFormat          Format of output documents. Can be YAML or JSON\n+     * @param preserveStatus        Preserve API Product status on export\n+     * @return\n+     * @throws APIManagementException If an error occurs while getting governance registry\n+     */\n+    public static File exportApiProduct(APIProvider apiProvider, APIProductIdentifier apiProductIdentifier,\n+                                        APIProductDTO apiProductDtoToReturn, String userName, ExportFormat exportFormat,\n+                                        Boolean preserveStatus)\n+            throws APIManagementException {\n+        int tenantId = 0;\n+        try {\n+            // Create temp location for storing API Product data\n+            File exportFolder = CommonUtil.createTempDirectory(apiProductIdentifier);\n+            String exportAPIBasePath = exportFolder.toString();\n+            String archivePath = exportAPIBasePath.concat(File.separator + apiProductIdentifier.getName() + \"-\"\n+                    + apiProductIdentifier.getVersion());\n+            tenantId = APIUtil.getTenantId(userName);\n+            UserRegistry registry = ServiceReferenceHolder.getInstance().getRegistryService().\n+                    getGovernanceSystemRegistry(tenantId);\n+            APIProduct apiProduct = APIMappingUtil.fromDTOtoAPIProduct(apiProductDtoToReturn, userName);\n+\n+            CommonUtil.createDirectory(archivePath);\n+\n+            addThumbnailToArchive(archivePath, apiProductIdentifier, registry);\n+            addDocumentationToArchive(archivePath, apiProductIdentifier, registry, exportFormat, apiProvider);\n+            addAPIProductMetaInformationToArchive(archivePath, apiProductDtoToReturn, exportFormat, apiProvider,\n+                    userName);\n+            addDependentAPIsToArchive(archivePath, apiProductDtoToReturn, exportFormat, apiProvider, userName,\n+                    preserveStatus);\n+\n+            // Export mTLS authentication related certificates\n+            if (apiProvider.isClientCertificateBasedAuthenticationConfigured()) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Mutual SSL enabled. Exporting client certificates.\");\n+                }\n+                addClientCertificatesToArchive(archivePath, apiProductIdentifier, tenantId, apiProvider, exportFormat);\n+            }\n+            CommonUtil.archiveDirectory(exportAPIBasePath);\n+            FileUtils.deleteQuietly(new File(exportAPIBasePath));\n+            return new File(exportAPIBasePath + APIConstants.ZIP_FILE_EXTENSION);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while getting governance registry for tenant: \" + tenantId;\n+            throw new APIManagementException(errorMessage, e);\n+        } catch (APIManagementException | APIImportExportException e) {\n+            RestApiUtil.handleInternalServerError(\"Error while exporting \" +\n+                    RestApiConstants.RESOURCE_API_PRODUCT, e, log);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Retrieve thumbnail image for the exporting API or API Product and store it in the archive directory.\n+     *\n+     * @param archivePath File path to export the thumbnail image\n+     * @param identifier  ID of the requesting API or API Product\n+     * @param registry    Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addThumbnailToArchive(String archivePath, Identifier identifier, Registry registry)\n+            throws APIImportExportException {\n+        String thumbnailUrl = APIConstants.API_IMAGE_LOCATION + RegistryConstants.PATH_SEPARATOR\n+                + identifier.getProviderName() + RegistryConstants.PATH_SEPARATOR + identifier.getName()\n+                + RegistryConstants.PATH_SEPARATOR + identifier.getVersion() + RegistryConstants.PATH_SEPARATOR\n+                + APIConstants.API_ICON_IMAGE;\n+        String localImagePath = archivePath + File.separator + ImportExportConstants.IMAGE_RESOURCE;\n+        try {\n+            if (registry.resourceExists(thumbnailUrl)) {\n+                Resource icon = registry.get(thumbnailUrl);\n+                String mediaType = icon.getMediaType();\n+                String extension = ImportExportConstants.fileExtensionMapping.get(mediaType);\n+                if (extension != null) {\n+                    CommonUtil.createDirectory(localImagePath);\n+                    try (InputStream imageDataStream = icon.getContentStream();\n+                         OutputStream outputStream = new FileOutputStream(localImagePath + File.separator\n+                                 + APIConstants.API_ICON_IMAGE + APIConstants.DOT + extension)) {\n+                        IOUtils.copy(imageDataStream, outputStream);\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"Thumbnail image retrieved successfully for API/API Product: \" + identifier.getName()\n+                                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                                    + identifier.getVersion());\n+                        }\n+                    }\n+                } else {\n+                    //api gets imported without thumbnail\n+                    log.error(\"Unsupported media type for icon \" + mediaType + \". Skipping thumbnail export.\");\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"Thumbnail URL [\" + thumbnailUrl + \"] does not exists in registry for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion() + \". Skipping thumbnail export.\");\n+            }\n+        } catch (RegistryException e) {\n+            log.error(\"Error while retrieving API/API Product Thumbnail \" + thumbnailUrl, e);\n+        } catch (IOException e) {\n+            //Exception is ignored by logging due to the reason that Thumbnail is not essential for\n+            //an API to be recreated.\n+            log.error(\"I/O error while writing API/API Product Thumbnail: \" + thumbnailUrl + \" to file\", e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve SOAP to REST mediation logic for the exporting API and store it in the archive directory\n+     *\n+     * @param archivePath   File path to export the SOAPToREST mediation logic\n+     * @param apiIdentifier ID of the requesting API\n+     * @param registry      Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addSOAPToRESTMediationToArchive(String archivePath, APIIdentifier apiIdentifier,\n+                                                       UserRegistry registry) throws APIImportExportException {\n+        String soapToRestBaseUrl = \"/apimgt/applicationdata/provider\" + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getProviderName() + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getApiName() + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getVersion() + RegistryConstants.PATH_SEPARATOR +\n+                SOAPToRESTConstants.SOAP_TO_REST_RESOURCE;\n+\n+        InputStream inputStream = null;\n+        OutputStream outputStream = null;\n+        try {\n+            if (registry.resourceExists(soapToRestBaseUrl)) {\n+                Collection inFlow = (org.wso2.carbon.registry.api.Collection) registry.get(soapToRestBaseUrl\n+                        + RegistryConstants.PATH_SEPARATOR + IN);\n+                Collection outFlow = (org.wso2.carbon.registry.api.Collection) registry.get(soapToRestBaseUrl\n+                        + RegistryConstants.PATH_SEPARATOR + OUT);\n+\n+                CommonUtil.createDirectory(archivePath + File.separator + SOAPTOREST + File.separator + IN);\n+                CommonUtil.createDirectory(archivePath + File.separator + SOAPTOREST + File.separator + OUT);\n+                if (inFlow != null) {\n+                    for (String inFlowPath : inFlow.getChildren()) {\n+                        inputStream = registry.get(inFlowPath).getContentStream();\n+                        outputStream = new FileOutputStream(archivePath + File.separator + SOAPTOREST\n+                                + File.separator + IN +\n+                                inFlowPath.substring(inFlowPath.lastIndexOf(RegistryConstants.PATH_SEPARATOR)));\n+                        IOUtils.copy(inputStream, outputStream);\n+                        IOUtils.closeQuietly(inputStream);\n+                        IOUtils.closeQuietly(outputStream);\n+                    }\n+                }\n+                if (outFlow != null) {\n+                    for (String outFlowPath : outFlow.getChildren()) {\n+                        inputStream = registry.get(outFlowPath).getContentStream();\n+                        outputStream = new FileOutputStream(archivePath + File.separator + SOAPTOREST\n+                                + File.separator + OUT +\n+                                outFlowPath.substring(outFlowPath.lastIndexOf(RegistryConstants.PATH_SEPARATOR)));\n+                        IOUtils.copy(inputStream, outputStream);\n+                        IOUtils.closeQuietly(inputStream);\n+                        IOUtils.closeQuietly(outputStream);\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new APIImportExportException(\"I/O error while writing API SOAP to REST logic to file\", e);\n+        } catch (RegistryException e) {\n+            throw new APIImportExportException(\"Error while retrieving SOAP to REST logic\", e);\n+        } finally {\n+            IOUtils.closeQuietly(inputStream);\n+            IOUtils.closeQuietly(outputStream);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve documentation for the exporting API or API Product and store it in the archive directory.\n+     * FILE, INLINE, MARKDOWN and URL documentations are handled.\n+     *\n+     * @param archivePath  File path to export the documents\n+     * @param identifier   ID of the requesting API or API Product\n+     * @param registry     Current tenant registry\n+     * @param exportFormat Format for export\n+     * @param apiProvider  API Provider\n+     * @throws APIImportExportException If an error occurs while retrieving documents from the\n+     *                                  registry or storing in the archive directory\n+     * @throws APIManagementException   If an error occurs while retrieving document details\n+     */\n+    public static void addDocumentationToArchive(String archivePath, Identifier identifier, Registry registry,\n+                                                 ExportFormat exportFormat, APIProvider apiProvider)\n+            throws APIImportExportException, APIManagementException {\n+\n+        List<Documentation> docList = apiProvider.getAllDocumentation(identifier);\n+        String tenantDomain = RestApiUtil.getLoggedInUserTenantDomain();\n+        if (!docList.isEmpty()) {\n+            Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+            String docDirectoryPath = archivePath + File.separator + ImportExportConstants.DOCUMENT_DIRECTORY;\n+            CommonUtil.createDirectory(docDirectoryPath);\n+            try {\n+                for (Documentation doc : docList) {\n+                    // Retrieving the document again since objects in docList might have missing fields\n+                    Documentation individualDocument = apiProvider.getDocumentation(doc.getId(), tenantDomain);\n+                    String sourceType = individualDocument.getSourceType().name();\n+                    String resourcePath = null;\n+                    String localFileName = null;\n+                    String individualDocDirectoryPath = docDirectoryPath + File.separator + individualDocument.getName();\n+                    CommonUtil.createDirectory(individualDocDirectoryPath);\n+                    writeDtoToFile(individualDocDirectoryPath +\n+                                    ImportExportConstants.DOCUMENT_FILE_NAME, exportFormat,\n+                            ImportExportConstants.TYPE_DOCUMENTS, individualDocument);\n+                    if (Documentation.DocumentSourceType.FILE.toString().equalsIgnoreCase(sourceType)) {\n+                        localFileName = individualDocument.getFilePath().substring(\n+                                individualDocument.getFilePath().lastIndexOf(RegistryConstants.PATH_SEPARATOR) + 1);\n+                        resourcePath = APIUtil.getDocumentationFilePath(identifier, localFileName);\n+                        individualDocument.setFilePath(localFileName);\n+                    } else if (Documentation.DocumentSourceType.INLINE.toString().equalsIgnoreCase(sourceType)\n+                            || Documentation.DocumentSourceType.MARKDOWN.toString().equalsIgnoreCase(sourceType)) {\n+                        // Inline/Markdown content file name would be same as the documentation name\n+                        localFileName = individualDocument.getName();\n+                        resourcePath = APIUtil.getAPIOrAPIProductDocPath(identifier) + APIConstants.INLINE_DOCUMENT_CONTENT_DIR\n+                                + RegistryConstants.PATH_SEPARATOR + localFileName;\n+                    }\n+\n+                    if (resourcePath != null) {\n+                        // Write content for Inline/Markdown/File type documentations only\n+                        // Check whether resource exists in the registry\n+                        if (registry.resourceExists(resourcePath)) {\n+                            Resource docFile = registry.get(resourcePath);\n+                            try (OutputStream outputStream = new FileOutputStream(individualDocDirectoryPath +\n+                                    File.separator + localFileName);\n+                                 InputStream fileInputStream = docFile.getContentStream()) {\n+                                IOUtils.copy(fileInputStream, outputStream);\n+                            }\n+                        } else {\n+                            // Log error and avoid throwing as we give capability to export document artifact without the\n+                            // content if does not exists\n+                            String errorMessage = \"Documentation resource for API/API Product: \" + identifier.getName()\n+                                    + \" not found in \" + resourcePath;\n+                            log.error(errorMessage);\n+                        }\n+                    }\n+                }\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Documentation retrieved successfully for API/API Product: \" + identifier.getName()\n+                            + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + identifier.getVersion());\n+                }\n+            } catch (IOException e) {\n+                String errorMessage = \"I/O error while writing documentation to file for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion();\n+                log.error(errorMessage, e);\n+                throw new APIImportExportException(errorMessage, e);\n+            } catch (RegistryException e) {\n+                String errorMessage = \"Error while retrieving documentation for API/API Product: \" + identifier.getName()\n+                        + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + identifier.getVersion();\n+                log.error(errorMessage, e);\n+                throw new APIImportExportException(errorMessage, e);\n+            }\n+        } else if (log.isDebugEnabled()) {\n+            log.debug(\"No documentation found for API/API Product: \" + identifier + \". Skipping documentation export.\");\n+        }\n+    }\n+\n+    /**\n+     * Retrieve WSDL for the exporting API and store it in the archive directory.\n+     *\n+     * @param archivePath   File path to export the WSDL\n+     * @param apiIdentifier ID of the requesting API\n+     * @param registry      Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving WSDL from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addWSDLtoArchive(String archivePath, APIIdentifier apiIdentifier, Registry registry)\n+            throws APIImportExportException {\n+\n+        String wsdlPath = APIConstants.API_WSDL_RESOURCE_LOCATION + apiIdentifier.getProviderName() + \"--\"\n+                + apiIdentifier.getApiName() + apiIdentifier.getVersion() + APIConstants.WSDL_FILE_EXTENSION;\n+        try {\n+            if (registry.resourceExists(wsdlPath)) {\n+                CommonUtil.createDirectory(archivePath + File.separator + \"WSDL\");\n+                Resource wsdl = registry.get(wsdlPath);\n+                try (InputStream wsdlStream = wsdl.getContentStream();\n+                     OutputStream outputStream = new FileOutputStream(archivePath + File.separator + \"WSDL\"\n+                             + File.separator + apiIdentifier.getApiName() + \"-\" + apiIdentifier.getVersion()\n+                             + APIConstants.WSDL_FILE_EXTENSION)) {\n+                    IOUtils.copy(wsdlStream, outputStream);\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"WSDL file: \" + wsdlPath + \" retrieved successfully\");\n+                    }\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"WSDL resource does not exists in path: \" + wsdlPath + \". Skipping WSDL export.\");\n+            }\n+        } catch (IOException e) {\n+            String errorMessage = \"I/O error while writing WSDL: \" + wsdlPath + \" to file\";\n+            throw new APIImportExportException(errorMessage, e);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while retrieving WSDL: \" + wsdlPath + \" to file\";\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve available custom sequences and API specific sequences for API export, and store it in the archive\n+     * directory.\n+     *\n+     * @param archivePath   File path to export the sequences\n+     * @param apiIdentifier API Identifier\n+     * @param apiDto        API DTO\n+     * @param registry      Current tenant registry\n+     * @param exportFormat  Export format of file\n+     * @throws APIImportExportException If an error occurs while exporting sequences\n+     */\n+    public static void addSequencesToArchive(String archivePath, APIIdentifier apiIdentifier, APIDTO apiDto,\n+                                             Registry registry, ExportFormat exportFormat) throws APIImportExportException {\n+\n+        Map<String, String> sequences = new HashMap<>();\n+        String seqArchivePath = archivePath.concat(File.separator + \"Sequences\");\n+        List<MediationPolicyDTO> mediationPolicyDtos = apiDto.getMediationPolicies();\n+        if (!apiDto.getMediationPolicies().isEmpty()) {\n+            CommonUtil.createDirectory(seqArchivePath);\n+            for (MediationPolicyDTO mediationPolicyDto : mediationPolicyDtos) {\n+                AbstractMap.SimpleEntry<String, OMElement> sequenceDetails;\n+                String sequenceName = mediationPolicyDto.getName();\n+                String direction = mediationPolicyDto.getType().toLowerCase();\n+                String pathToExportedSequence = seqArchivePath + File.separator + direction + \"-sequence\" +\n+                        File.separator;\n+                String pathToIndividualSequenceFile = pathToExportedSequence + ImportExportConstants.SEQUENCE_FILE_NAME;\n+                if (sequenceName != null) {\n+                    sequenceDetails = getCustomSequence(sequenceName, direction, registry);\n+                    if (sequenceDetails == null) {\n+                        // If sequence doesn't exist in 'apimgt/customsequences/{in/out/fault}' directory check in API\n+                        // specific registry path\n+                        sequenceDetails = getAPISpecificSequence(apiIdentifier, sequenceName, direction, registry);\n+                        pathToExportedSequence += ImportExportConstants.CUSTOM_TYPE + File.separator;\n+                    }\n+                    writeSequenceToFile(pathToExportedSequence, sequenceDetails, apiIdentifier);\n+                    try {\n+                        writeDtoToFile(pathToIndividualSequenceFile, exportFormat, ImportExportConstants.TYPE_SEQUENCE,\n+                                mediationPolicyDto);\n+                    } catch (IOException e) {\n+                        String errorMessage = \"I/O error while writing sequence: \" + sequenceName + \" to file\";\n+                        throw new APIImportExportException(errorMessage, e);\n+                    }\n+                }\n+            }\n+        } else if (log.isDebugEnabled()) {\n+            log.debug(\"No custom sequences available for API: \" + apiIdentifier.getApiName() + StringUtils.SPACE\n+                    + APIConstants.API_DATA_VERSION + \": \" + apiIdentifier.getVersion()\n+                    + \". Skipping custom sequence export.\");\n+        }\n+    }\n+\n+    /**\n+     * Retrieve custom sequence details from the registry.\n+     *\n+     * @param sequenceName Name of the sequence\n+     * @param type         Sequence type\n+     * @param registry     Current tenant registry\n+     * @return Registry resource name of the sequence and its content\n+     * @throws APIImportExportException If an error occurs while retrieving registry elements\n+     */\n+    private static AbstractMap.SimpleEntry<String, OMElement> getCustomSequence(String sequenceName, String type,\n+                                                                                Registry registry)\n+            throws APIImportExportException {\n+\n+        String regPath = null;\n+        if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_IN.equals(type)) {\n+            regPath = APIConstants.API_CUSTOM_INSEQUENCE_LOCATION;\n+        } else if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_OUT.equals(type)) {\n+            regPath = APIConstants.API_CUSTOM_OUTSEQUENCE_LOCATION;\n+        } else if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_FAULT.equals(type)) {\n+            regPath = APIConstants.API_CUSTOM_FAULTSEQUENCE_LOCATION;\n+        }\n+        return getSeqDetailsFromRegistry(sequenceName, regPath, registry);\n+    }\n+\n+    /**\n+     * Retrieve API Specific sequence details from the registry.\n+     *\n+     * @param sequenceName Name of the sequence\n+     * @param type         Sequence type\n+     * @param registry     Current tenant registry\n+     * @return Registry resource name of the sequence and its content\n+     * @throws APIImportExportException If an error occurs while retrieving registry elements\n+     */\n+    private static AbstractMap.SimpleEntry<String, OMElement> getAPISpecificSequence(APIIdentifier api,\n+                                                                                     String sequenceName, String type,\n+                                                                                     Registry registry)\n+            throws APIImportExportException {\n+\n+        String regPath = APIConstants.API_ROOT_LOCATION + RegistryConstants.PATH_SEPARATOR + api.getProviderName()\n+                + RegistryConstants.PATH_SEPARATOR + api.getApiName() + RegistryConstants.PATH_SEPARATOR\n+                + api.getVersion() + RegistryConstants.PATH_SEPARATOR + type;\n+        return getSeqDetailsFromRegistry(sequenceName, regPath, registry);\n+    }\n+\n+    /**\n+     * Retrieve sequence details from registry by given registry path.\n+     *\n+     * @param sequenceName Sequence Name\n+     * @param regPath      Registry path\n+     * @param registry     Registry\n+     * @return Sequence details as a simple entry\n+     * @throws APIImportExportException If an error occurs while retrieving sequence details from registry\n+     */\n+    private static AbstractMap.SimpleEntry<String, OMElement> getSeqDetailsFromRegistry(String sequenceName,\n+                                                                                        String regPath, Registry registry)\n+            throws APIImportExportException {\n+\n+        AbstractMap.SimpleEntry<String, OMElement> sequenceDetails = null;\n+        Collection seqCollection;\n+\n+        try {\n+            seqCollection = (Collection) registry.get(regPath);\n+            if (seqCollection != null) {\n+                String[] childPaths = seqCollection.getChildren();\n+                for (String childPath : childPaths) {\n+                    Resource sequence = registry.get(childPath);\n+                    OMElement seqElement = APIUtil.buildOMElement(sequence.getContentStream());\n+                    if (sequenceName.equals(seqElement.getAttributeValue(new QName(\"name\")))) {\n+                        String sequenceFileName = sequenceName + APIConstants.XML_EXTENSION;\n+                        sequenceDetails = new AbstractMap.SimpleEntry<>(sequenceFileName, seqElement);\n+                        break;\n+                    }\n+                }\n+            }\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while retrieving sequence: \" + sequenceName + \" from the path: \" + regPath;\n+            throw new APIImportExportException(errorMessage, e);\n+        } catch (Exception e) {\n+            //APIUtil.buildOMElement() throws a generic exception\n+            String errorMessage = \"Error while reading content for sequence: \" + sequenceName + \" from the registry\";\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+        return sequenceDetails;\n+    }\n+\n+    /**\n+     * Store API Specific or custom sequences in the archive directory.\n+     *\n+     * @param sequenceDetails Details of the sequence\n+     * @param apiIdentifier   ID of the requesting API\n+     * @throws APIImportExportException If an error occurs while serializing XML stream or storing in\n+     *                                  archive directory\n+     */\n+    private static void writeSequenceToFile(String pathToExportedSequence,\n+                                            AbstractMap.SimpleEntry<String, OMElement> sequenceDetails,\n+                                            APIIdentifier apiIdentifier)\n+            throws APIImportExportException {\n+\n+        if (sequenceDetails != null) {\n+            String sequenceFileName = sequenceDetails.getKey();\n+            OMElement sequenceConfig = sequenceDetails.getValue();\n+            CommonUtil.createDirectory(pathToExportedSequence);\n+            String exportedSequenceFile = pathToExportedSequence + sequenceFileName;\n+            try (OutputStream outputStream = new FileOutputStream(exportedSequenceFile)) {\n+                sequenceConfig.serialize(outputStream);\n+                if (log.isDebugEnabled()) {\n+                    log.debug(sequenceFileName + \" of API: \" + apiIdentifier.getApiName() + \" retrieved successfully\");\n+                }\n+            } catch (IOException e) {\n+                String errorMessage = \"Unable to find file: \" + exportedSequenceFile;\n+                throw new APIImportExportException(errorMessage, e);\n+            } catch (XMLStreamException e) {\n+                String errorMessage = \"Error while processing XML stream \";\n+                throw new APIImportExportException(errorMessage, e);\n+            }\n+        } else {\n+            String errorMessage = \"Error while writing sequence of API: \" + apiIdentifier.getApiName() + \" to file.\";\n+            throw new APIImportExportException(errorMessage);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve the endpoint certificates and store those in the archive directory.\n+     *\n+     * @param archivePath  File path to export the endpoint certificates\n+     * @param apiDto       API DTO to be exported\n+     * @param tenantId     Tenant id of the user\n+     * @param exportFormat Export format of file\n+     * @throws APIImportExportException If an error occurs while exporting endpoint certificates\n+     */\n+    public static void addEndpointCertificatesToArchive(String archivePath, APIDTO apiDto, int tenantId,\n+                                                        ExportFormat exportFormat) throws APIImportExportException {\n+        List<String> productionEndpoints;\n+        List<String> sandboxEndpoints;\n+        Set<String> uniqueEndpointURLs = new HashSet<>();\n+        JsonArray endpointCertificatesDetails = new JsonArray();\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        String endpointConfigString = gson.toJson(apiDto.getEndpointConfig());\n+        String endpointCertsDirectoryPath = archivePath + File.separator\n+                + ImportExportConstants.ENDPOINT_CERTIFICATES_DIRECTORY;\n+        CommonUtil.createDirectory(endpointCertsDirectoryPath);\n+\n+        if (StringUtils.isEmpty(endpointConfigString)) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Endpoint Details are empty for API: \" + apiDto.getName() + StringUtils.SPACE\n+                        + APIConstants.API_DATA_VERSION + \": \" + apiDto.getVersion());\n+            }\n+            return;\n+        }\n+        try {\n+            JSONTokener tokener = new JSONTokener(endpointConfigString);\n+            JSONObject endpointConfig = new JSONObject(tokener);\n+            productionEndpoints = getEndpointURLs(endpointConfig, APIConstants.API_DATA_PRODUCTION_ENDPOINTS,\n+                    apiDto.getName());\n+            sandboxEndpoints = getEndpointURLs(endpointConfig, APIConstants.API_DATA_SANDBOX_ENDPOINTS,\n+                    apiDto.getName());\n+            uniqueEndpointURLs.addAll(productionEndpoints); // Remove duplicate and append result\n+            uniqueEndpointURLs.addAll(sandboxEndpoints);\n+\n+            for (String url : uniqueEndpointURLs) {\n+                JsonArray certificateListOfUrl = getEndpointCertificateContentAndMetaData(tenantId, url,\n+                        endpointCertsDirectoryPath);\n+                endpointCertificatesDetails.addAll(certificateListOfUrl);\n+            }\n+            if (endpointCertificatesDetails.size() > 0) {\n+                writeDtoToFile(endpointCertsDirectoryPath +\n+                                ImportExportConstants.ENDPOINTS_CERTIFICATE_FILE, exportFormat,\n+                        ImportExportConstants.TYPE_ENDPOINT_CERTIFICATES, endpointCertificatesDetails);\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"No endpoint certificates available for API: \" + apiDto.getName() + StringUtils.SPACE\n+                        + APIConstants.API_DATA_VERSION + \": \" + apiDto.getVersion() + \". Skipping certificate export.\");\n+            }\n+        } catch (JSONException e) {\n+            String errorMsg = \"Error in converting Endpoint config to JSON object in API: \" + apiDto.getName();\n+            throw new APIImportExportException(errorMsg, e);\n+        } catch (IOException e) {\n+            String errorMessage = \"Error while retrieving saving endpoint certificate details for API: \"\n+                    + apiDto.getName() + \" as YAML\";\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Get Endpoint Certificate MetaData and Certificate detail and build JSON Array.\n+     *\n+     * @param tenantId          Tenant id of the user\n+     * @param url               Url of the endpoint\n+     * @param certDirectoryPath Directory path to export the certificates\n+     * @return JSON Array of certificate details\n+     * @throws APIImportExportException If an error occurs while retrieving endpoint certificate metadata and content\n+     */\n+    private static JsonArray getEndpointCertificateContentAndMetaData(int tenantId, String url,\n+                                                                      String certDirectoryPath)\n+            throws APIImportExportException {\n+\n+        List<CertificateMetadataDTO> certificateMetadataDTOS;\n+        CertificateManager certificateManager = CertificateManagerImpl.getInstance();\n+\n+        try {\n+            certificateMetadataDTOS = certificateManager.getCertificates(tenantId, null, url);\n+        } catch (APIManagementException e) {\n+            String errorMsg = \"Error retrieving certificate meta data. For tenantId: \" + tenantId + \" hostname: \"\n+                    + url;\n+            throw new APIImportExportException(errorMsg, e);\n+        }\n+\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        JsonArray certificatesList = new JsonArray();\n+        certificateMetadataDTOS.forEach(metadataDTO -> {\n+            ByteArrayInputStream certificate = null;\n+            try {\n+                certificate = certificateManager.getCertificateContent(metadataDTO.getAlias());\n+                certificate.close();\n+                byte[] certificateContent = IOUtils.toByteArray(certificate);\n+                String certificateContentEncoded = APIConstants.BEGIN_CERTIFICATE_STRING\n+                        .concat(new String(Base64.encodeBase64(certificateContent))).concat(\"\\n\")\n+                        .concat(APIConstants.END_CERTIFICATE_STRING);\n+                CommonUtil.writeFile(certDirectoryPath + File.separator + metadataDTO.getAlias() + \".crt\",\n+                        certificateContentEncoded);\n+                // Add the file name to the Certificate Metadata\n+                JsonObject modifiedCertificateMetadata = (JsonObject) gson.toJsonTree(metadataDTO);\n+                modifiedCertificateMetadata.addProperty(ImportExportConstants.CERTIFICATE_FILE,\n+                        metadataDTO.getAlias() + \".crt\");\n+                certificatesList.add(modifiedCertificateMetadata);\n+            } catch (APIManagementException e) {\n+                log.error(\"Error retrieving certificate content. For tenantId: \" + tenantId + \" hostname: \"\n+                        + url + \" alias: \" + metadataDTO.getAlias(), e);\n+            } catch (IOException e) {\n+                log.error(\"Error while converting certificate content to Byte Array. For tenantId: \" + tenantId\n+                        + \" hostname: \" + url + \" alias: \" + metadataDTO.getAlias(), e);\n+            } catch (APIImportExportException e) {\n+                log.error(\"Error while writing the certificate content. For tenantId: \" + tenantId + \" hostname: \"\n+                        + url + \" alias: \" + metadataDTO.getAlias(), e);\n+            } finally {\n+                if (certificate != null) {\n+                    IOUtils.closeQuietly(certificate);\n+                }\n+            }\n+        });\n+        return certificatesList;\n+    }\n+\n+    /**\n+     * Get endpoint url list from endpoint config.\n+     *\n+     * @param endpointConfig JSON converted endpoint config\n+     * @param type           End point type - production/sandbox\n+     * @return List of host names\n+     */\n+    private static List<String> getEndpointURLs(JSONObject endpointConfig, String type, String apiName) {\n+        List<String> urls = new ArrayList<>();\n+        if (endpointConfig != null) {\n+            try {\n+                Object item;\n+                item = endpointConfig.get(type);\n+                if (item instanceof JSONArray) {\n+                    JSONArray endpointsJSON = new JSONArray(endpointConfig.getJSONArray(type).toString());\n+                    for (int i = 0; i < endpointsJSON.length(); i++) {\n+                        try {\n+                            String urlValue = endpointsJSON.getJSONObject(i).get(APIConstants.API_DATA_URL).toString();\n+                            urls.add(urlValue);\n+                        } catch (JSONException ex) {\n+                            log.error(\"Endpoint URL extraction from endpoints JSON object failed in API: \"\n+                                    + apiName, ex);\n+                        }\n+                    }\n+                } else if (item instanceof JSONObject) {\n+                    JSONObject endpointJSON = new JSONObject(endpointConfig.getJSONObject(type).toString());\n+                    try {\n+                        String urlValue = endpointJSON.get(APIConstants.API_DATA_URL).toString();\n+                        urls.add(urlValue);\n+                    } catch (JSONException ex) {\n+                        log.error(\"Endpoint URL extraction from endpoint JSON object failed in API: \" + apiName, ex);\n+                    }\n+                }\n+            } catch (JSONException ex) {\n+                log.info(\"Endpoint type: \" + type + \" not found in API: \" + apiName);\n+            }\n+        }\n+        return urls;\n+    }\n+\n+    /**\n+     * Retrieve meta information of the API to export and store those in the archive directory.\n+     * URL template information are stored in swagger.json definition while rest of the required\n+     * data are in api.json\n+     *\n+     * @param archivePath    Folder path to export meta information to export\n+     * @param apiDtoToReturn API DTO to be exported\n+     * @param exportFormat   Export format of file\n+     * @param apiProvider    API Provider\n+     * @param apiIdentifier  API Identifier\n+     * @param userName       Username\n+     * @throws APIImportExportException If an error occurs while exporting meta information\n+     */\n+    public static void addAPIMetaInformationToArchive(String archivePath, APIDTO apiDtoToReturn, ExportFormat exportFormat,\n+                                                      APIProvider apiProvider, APIIdentifier apiIdentifier, String userName)\n+            throws APIImportExportException {\n+\n+        CommonUtil.createDirectory(archivePath + File.separator + ImportExportConstants.META_INFO_DIRECTORY);\n+\n+        try {\n+            Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+\n+            // If a web socket API is exported, it does not contain a swagger file.\n+            // Therefore swagger export is only required for REST, Graphql or SOAP based APIs\n+            String apiType = apiDtoToReturn.getType().toString();\n+            if (!APIConstants.APITransportType.WS.toString().equalsIgnoreCase(apiType)) {\n+                //For Graphql APIs, the graphql schema definition, swagger and the serialized api object are exported.\n+                if (StringUtils.equals(apiType, APIConstants.APITransportType.GRAPHQL.toString())) {\n+                    String schemaContent = apiProvider.getGraphqlSchema(apiIdentifier);\n+                    CommonUtil.writeFile(archivePath + ImportExportConstants.GRAPHQL_SCHEMA_DEFINITION_LOCATION,\n+                            schemaContent);\n+                }\n+                String formattedSwaggerJson = RestApiPublisherUtils.retrieveSwaggerDefinition(\n+                        APIMappingUtil.fromDTOtoAPI(apiDtoToReturn, userName), apiProvider);\n+                writeToYamlOrJson(archivePath + ImportExportConstants.SWAGGER_DEFINITION_LOCATION,\n+                        exportFormat, formattedSwaggerJson);\n+\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Meta information retrieved successfully for API: \" + apiDtoToReturn.getName()\n+                            + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + apiDtoToReturn.getVersion());\n+                }\n+            }\n+            writeDtoToFile(archivePath + ImportExportConstants.API_FILE_LOCATION, exportFormat,\n+                    ImportExportConstants.TYPE_API, apiDtoToReturn);\n+        } catch (APIManagementException e) {\n+            String errorMessage = \"Error while retrieving Swagger definition for API: \" + apiDtoToReturn.getName()\n+                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + apiDtoToReturn.getVersion();\n+            throw new APIImportExportException(errorMessage, e);\n+        } catch (IOException e) {\n+            String errorMessage = \"Error while retrieving saving as YAML for API: \" + apiDtoToReturn.getName()\n+                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + apiDtoToReturn.getVersion();\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve Mutual SSL related certificates and store those in the archive directory\n+     *\n+     * @param archivePath  Folder path to export client certificates\n+     * @param identifier   Identifier\n+     * @param tenantId     Tenant id of the user\n+     * @param provider     Api Provider\n+     * @param exportFormat Export format of file\n+     * @throws APIImportExportException If an error occurs when writing to file or retrieving certificate metadata\n+     */\n+    public static void addClientCertificatesToArchive(String archivePath, Identifier identifier,\n+                                                      int tenantId, APIProvider provider,\n+                                                      ExportFormat exportFormat) throws APIImportExportException {\n+        List<ClientCertificateDTO> certificateMetadataDTOs;\n+        try {\n+            if (identifier instanceof APIProductIdentifier) {\n+                certificateMetadataDTOs = provider.searchClientCertificates(tenantId, null,\n+                        (APIProductIdentifier) identifier);\n+            } else {\n+                certificateMetadataDTOs = provider.searchClientCertificates(tenantId, null,\n+                        (APIIdentifier) identifier);\n+            }\n+            if (!certificateMetadataDTOs.isEmpty()) {\n+                String clientCertsDirectoryPath = archivePath + File.separator\n+                        + ImportExportConstants.CLIENT_CERTIFICATES_DIRECTORY;\n+                CommonUtil.createDirectory(clientCertsDirectoryPath);\n+\n+                JsonArray certificateList = getClientCertificateContentAndMetaData(certificateMetadataDTOs, clientCertsDirectoryPath);\n+\n+                if (certificateList.size() > 0) {\n+                    writeDtoToFile(clientCertsDirectoryPath + ImportExportConstants.CLIENT_CERTIFICATE_FILE,\n+                            exportFormat, ImportExportConstants.TYPE_CLIENT_CERTIFICATES, certificateList);\n+                }\n+            }\n+        } catch (IOException e) {\n+            String errorMessage = \"Error while saving as YAML or JSON\";\n+            throw new APIImportExportException(errorMessage, e);\n+        } catch (APIManagementException e) {\n+            String errorMsg = \"Error retrieving certificate meta data. tenantId [\" + tenantId + \"] api [\"\n+                    + tenantId + \"]\";\n+            throw new APIImportExportException(errorMsg, e);\n+        }\n+    }\n+\n+    /**\n+     * Get Client Certificate MetaData and Certificate detail and build JSON list.\n+     *\n+     * @param clientCertificateDTOs client certificates list DTOs\n+     * @param certDirectoryPath     directory path to export the certificates\n+     * @return list of certificate detail JSON objects\n+     */\n+    private static JsonArray getClientCertificateContentAndMetaData(List<ClientCertificateDTO> clientCertificateDTOs,\n+                                                                    String certDirectoryPath) {\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        JsonArray certificatesList = new JsonArray();\n+        clientCertificateDTOs.forEach(metadataDTO -> {\n+            ByteArrayInputStream certificate = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67a7a292f0788f2879e86f6675caf1d27f063c89"}, "originalPosition": 944}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU5NDU2OA==", "bodyText": "Fixed via 150d9ab", "url": "https://github.com/wso2/carbon-apimgt/pull/9406#discussion_r527594568", "createdAt": "2020-11-20T10:24:16Z", "author": {"login": "wasuradananjith"}, "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/utils/ExportUtils.java", "diffHunk": "@@ -0,0 +1,1087 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.apimgt.rest.api.publisher.v1.utils;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import org.apache.axiom.om.OMElement;\n+import org.apache.commons.codec.binary.Base64;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.json.JSONTokener;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.APIProvider;\n+import org.wso2.carbon.apimgt.api.dto.CertificateMetadataDTO;\n+import org.wso2.carbon.apimgt.api.dto.ClientCertificateDTO;\n+import org.wso2.carbon.apimgt.api.model.API;\n+import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.api.model.APIProduct;\n+import org.wso2.carbon.apimgt.api.model.APIProductIdentifier;\n+import org.wso2.carbon.apimgt.api.model.Documentation;\n+import org.wso2.carbon.apimgt.api.model.Identifier;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.certificatemgt.CertificateManager;\n+import org.wso2.carbon.apimgt.impl.certificatemgt.CertificateManagerImpl;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportException;\n+import org.wso2.carbon.apimgt.impl.importexport.ExportFormat;\n+import org.wso2.carbon.apimgt.impl.importexport.ImportExportConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.utils.CommonUtil;\n+import org.wso2.carbon.apimgt.impl.internal.ServiceReferenceHolder;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.apimgt.impl.wsdl.util.SOAPToRESTConstants;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.APIDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.APIProductDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.MediationPolicyDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.ProductAPIDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.utils.mappings.APIMappingUtil;\n+import org.wso2.carbon.apimgt.rest.api.util.RestApiConstants;\n+import org.wso2.carbon.apimgt.rest.api.util.utils.RestApiUtil;\n+import org.wso2.carbon.registry.api.Collection;\n+import org.wso2.carbon.registry.api.Registry;\n+import org.wso2.carbon.registry.api.RegistryException;\n+import org.wso2.carbon.registry.api.Resource;\n+import org.wso2.carbon.registry.core.RegistryConstants;\n+import org.wso2.carbon.registry.core.session.UserRegistry;\n+import org.wso2.carbon.utils.multitenancy.MultitenantUtils;\n+\n+import javax.xml.namespace.QName;\n+import javax.xml.stream.XMLStreamException;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ExportUtils {\n+\n+    private static final Log log = LogFactory.getLog(ExportUtils.class);\n+    private static final String IN = \"in\";\n+    private static final String OUT = \"out\";\n+    private static final String SOAPTOREST = \"SoapToRest\";\n+\n+    /**\n+     * Validate name, version and provider before exporting an API/API Product\n+     *\n+     * @param name         API/API Product Name\n+     * @param version      API/API Product version\n+     * @param providerName Name of the provider\n+     * @return Name of the provider\n+     * @throws APIManagementException If an error occurs while retrieving the provider name from name, version\n+     *                                and tenant\n+     */\n+    public static String validateExportParams(String name, String version, String providerName)\n+            throws APIManagementException {\n+        if (name == null || version == null) {\n+            RestApiUtil.handleBadRequest(\"'name' (\" + name + \") or 'version' (\" + version\n+                    + \") should not be null.\", log);\n+        }\n+        String apiRequesterDomain = RestApiUtil.getLoggedInUserTenantDomain();\n+\n+        // If provider name is not given\n+        if (StringUtils.isBlank(providerName)) {\n+            // Retrieve the provider who is in same tenant domain and who owns the same API (by comparing\n+            // API name and the version)\n+            providerName = APIUtil.getAPIProviderFromAPINameVersionTenant(name, version, apiRequesterDomain);\n+\n+            // If there is no provider in current domain, the API cannot be exported\n+            if (providerName == null) {\n+                String errorMessage = \"Error occurred while exporting. API: \" + name + \" version: \" + version\n+                        + \" not found\";\n+                RestApiUtil.handleResourceNotFoundError(errorMessage, log);\n+            }\n+        }\n+\n+        if (!StringUtils.equals(MultitenantUtils.getTenantDomain(providerName), apiRequesterDomain)) {\n+            // Not authorized to export requested API\n+            RestApiUtil.handleAuthorizationFailure(RestApiConstants.RESOURCE_API +\n+                    \" name:\" + name + \" version:\" + version + \" provider:\" + providerName, log);\n+        }\n+        return providerName;\n+    }\n+\n+    /**\n+     * Exports an API from API Manager for a given API. Meta information, API icon, documentation,\n+     * WSDL and sequences are exported.\n+     *\n+     * @param apiProvider    API Provider\n+     * @param apiIdentifier  API Identifier\n+     * @param apiDtoToReturn API DTO\n+     * @param userName       Username\n+     * @param exportFormat   Format of output documents. Can be YAML or JSON\n+     * @param preserveStatus Preserve API status on export\n+     * @return\n+     * @throws APIManagementException If an error occurs while getting governance registry\n+     */\n+    public static File exportApi(APIProvider apiProvider, APIIdentifier apiIdentifier, APIDTO apiDtoToReturn,\n+                                 String userName, ExportFormat exportFormat, Boolean preserveStatus)\n+            throws APIManagementException {\n+        int tenantId = 0;\n+        try {\n+            // Create temp location for storing API data\n+            File exportFolder = CommonUtil.createTempDirectory(apiIdentifier);\n+            String exportAPIBasePath = exportFolder.toString();\n+            String archivePath = exportAPIBasePath.concat(File.separator + apiIdentifier.getApiName() + \"-\"\n+                    + apiIdentifier.getVersion());\n+            tenantId = APIUtil.getTenantId(userName);\n+            UserRegistry registry = ServiceReferenceHolder.getInstance().getRegistryService().\n+                    getGovernanceSystemRegistry(tenantId);\n+\n+            CommonUtil.createDirectory(archivePath);\n+\n+            addThumbnailToArchive(archivePath, apiIdentifier, registry);\n+            addSOAPToRESTMediationToArchive(archivePath, apiIdentifier, registry);\n+            addDocumentationToArchive(archivePath, apiIdentifier, registry, exportFormat, apiProvider);\n+\n+            if (StringUtils.isNotEmpty(apiDtoToReturn.getWsdlUrl())) {\n+                addWSDLtoArchive(archivePath, apiIdentifier, registry);\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"No WSDL URL found for API: \" + apiIdentifier + \". Skipping WSDL export.\");\n+            }\n+\n+            addSequencesToArchive(archivePath, apiIdentifier, apiDtoToReturn, registry, exportFormat);\n+\n+            // Set API status to created if the status is not preserved\n+            if (!preserveStatus) {\n+                apiDtoToReturn.setLifeCycleStatus(APIConstants.CREATED);\n+            }\n+\n+            addEndpointCertificatesToArchive(archivePath, apiDtoToReturn, tenantId, exportFormat);\n+            addAPIMetaInformationToArchive(archivePath, apiDtoToReturn, exportFormat, apiProvider, apiIdentifier, userName);\n+\n+            // Export mTLS authentication related certificates\n+            if (apiProvider.isClientCertificateBasedAuthenticationConfigured()) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Mutual SSL enabled. Exporting client certificates.\");\n+                }\n+                addClientCertificatesToArchive(archivePath, apiIdentifier, tenantId, apiProvider, exportFormat);\n+            }\n+            CommonUtil.archiveDirectory(exportAPIBasePath);\n+            FileUtils.deleteQuietly(new File(exportAPIBasePath));\n+            return new File(exportAPIBasePath + APIConstants.ZIP_FILE_EXTENSION);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while getting governance registry for tenant: \" + tenantId;\n+            throw new APIManagementException(errorMessage, e);\n+        } catch (APIManagementException | APIImportExportException e) {\n+            RestApiUtil.handleInternalServerError(\"Error while exporting \" + RestApiConstants.RESOURCE_API, e, log);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Exports an API Product from API Manager for a given API Product. MMeta information, API Product icon, documentation, client certificates\n+     * and dependent APIs are exported.\n+     *\n+     * @param apiProvider           API Provider\n+     * @param apiProductIdentifier  API Product Identifier\n+     * @param apiProductDtoToReturn API Product DTO\n+     * @param userName              Username\n+     * @param exportFormat          Format of output documents. Can be YAML or JSON\n+     * @param preserveStatus        Preserve API Product status on export\n+     * @return\n+     * @throws APIManagementException If an error occurs while getting governance registry\n+     */\n+    public static File exportApiProduct(APIProvider apiProvider, APIProductIdentifier apiProductIdentifier,\n+                                        APIProductDTO apiProductDtoToReturn, String userName, ExportFormat exportFormat,\n+                                        Boolean preserveStatus)\n+            throws APIManagementException {\n+        int tenantId = 0;\n+        try {\n+            // Create temp location for storing API Product data\n+            File exportFolder = CommonUtil.createTempDirectory(apiProductIdentifier);\n+            String exportAPIBasePath = exportFolder.toString();\n+            String archivePath = exportAPIBasePath.concat(File.separator + apiProductIdentifier.getName() + \"-\"\n+                    + apiProductIdentifier.getVersion());\n+            tenantId = APIUtil.getTenantId(userName);\n+            UserRegistry registry = ServiceReferenceHolder.getInstance().getRegistryService().\n+                    getGovernanceSystemRegistry(tenantId);\n+            APIProduct apiProduct = APIMappingUtil.fromDTOtoAPIProduct(apiProductDtoToReturn, userName);\n+\n+            CommonUtil.createDirectory(archivePath);\n+\n+            addThumbnailToArchive(archivePath, apiProductIdentifier, registry);\n+            addDocumentationToArchive(archivePath, apiProductIdentifier, registry, exportFormat, apiProvider);\n+            addAPIProductMetaInformationToArchive(archivePath, apiProductDtoToReturn, exportFormat, apiProvider,\n+                    userName);\n+            addDependentAPIsToArchive(archivePath, apiProductDtoToReturn, exportFormat, apiProvider, userName,\n+                    preserveStatus);\n+\n+            // Export mTLS authentication related certificates\n+            if (apiProvider.isClientCertificateBasedAuthenticationConfigured()) {\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Mutual SSL enabled. Exporting client certificates.\");\n+                }\n+                addClientCertificatesToArchive(archivePath, apiProductIdentifier, tenantId, apiProvider, exportFormat);\n+            }\n+            CommonUtil.archiveDirectory(exportAPIBasePath);\n+            FileUtils.deleteQuietly(new File(exportAPIBasePath));\n+            return new File(exportAPIBasePath + APIConstants.ZIP_FILE_EXTENSION);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while getting governance registry for tenant: \" + tenantId;\n+            throw new APIManagementException(errorMessage, e);\n+        } catch (APIManagementException | APIImportExportException e) {\n+            RestApiUtil.handleInternalServerError(\"Error while exporting \" +\n+                    RestApiConstants.RESOURCE_API_PRODUCT, e, log);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Retrieve thumbnail image for the exporting API or API Product and store it in the archive directory.\n+     *\n+     * @param archivePath File path to export the thumbnail image\n+     * @param identifier  ID of the requesting API or API Product\n+     * @param registry    Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addThumbnailToArchive(String archivePath, Identifier identifier, Registry registry)\n+            throws APIImportExportException {\n+        String thumbnailUrl = APIConstants.API_IMAGE_LOCATION + RegistryConstants.PATH_SEPARATOR\n+                + identifier.getProviderName() + RegistryConstants.PATH_SEPARATOR + identifier.getName()\n+                + RegistryConstants.PATH_SEPARATOR + identifier.getVersion() + RegistryConstants.PATH_SEPARATOR\n+                + APIConstants.API_ICON_IMAGE;\n+        String localImagePath = archivePath + File.separator + ImportExportConstants.IMAGE_RESOURCE;\n+        try {\n+            if (registry.resourceExists(thumbnailUrl)) {\n+                Resource icon = registry.get(thumbnailUrl);\n+                String mediaType = icon.getMediaType();\n+                String extension = ImportExportConstants.fileExtensionMapping.get(mediaType);\n+                if (extension != null) {\n+                    CommonUtil.createDirectory(localImagePath);\n+                    try (InputStream imageDataStream = icon.getContentStream();\n+                         OutputStream outputStream = new FileOutputStream(localImagePath + File.separator\n+                                 + APIConstants.API_ICON_IMAGE + APIConstants.DOT + extension)) {\n+                        IOUtils.copy(imageDataStream, outputStream);\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"Thumbnail image retrieved successfully for API/API Product: \" + identifier.getName()\n+                                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                                    + identifier.getVersion());\n+                        }\n+                    }\n+                } else {\n+                    //api gets imported without thumbnail\n+                    log.error(\"Unsupported media type for icon \" + mediaType + \". Skipping thumbnail export.\");\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"Thumbnail URL [\" + thumbnailUrl + \"] does not exists in registry for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion() + \". Skipping thumbnail export.\");\n+            }\n+        } catch (RegistryException e) {\n+            log.error(\"Error while retrieving API/API Product Thumbnail \" + thumbnailUrl, e);\n+        } catch (IOException e) {\n+            //Exception is ignored by logging due to the reason that Thumbnail is not essential for\n+            //an API to be recreated.\n+            log.error(\"I/O error while writing API/API Product Thumbnail: \" + thumbnailUrl + \" to file\", e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve SOAP to REST mediation logic for the exporting API and store it in the archive directory\n+     *\n+     * @param archivePath   File path to export the SOAPToREST mediation logic\n+     * @param apiIdentifier ID of the requesting API\n+     * @param registry      Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving image from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addSOAPToRESTMediationToArchive(String archivePath, APIIdentifier apiIdentifier,\n+                                                       UserRegistry registry) throws APIImportExportException {\n+        String soapToRestBaseUrl = \"/apimgt/applicationdata/provider\" + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getProviderName() + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getApiName() + RegistryConstants.PATH_SEPARATOR +\n+                apiIdentifier.getVersion() + RegistryConstants.PATH_SEPARATOR +\n+                SOAPToRESTConstants.SOAP_TO_REST_RESOURCE;\n+\n+        InputStream inputStream = null;\n+        OutputStream outputStream = null;\n+        try {\n+            if (registry.resourceExists(soapToRestBaseUrl)) {\n+                Collection inFlow = (org.wso2.carbon.registry.api.Collection) registry.get(soapToRestBaseUrl\n+                        + RegistryConstants.PATH_SEPARATOR + IN);\n+                Collection outFlow = (org.wso2.carbon.registry.api.Collection) registry.get(soapToRestBaseUrl\n+                        + RegistryConstants.PATH_SEPARATOR + OUT);\n+\n+                CommonUtil.createDirectory(archivePath + File.separator + SOAPTOREST + File.separator + IN);\n+                CommonUtil.createDirectory(archivePath + File.separator + SOAPTOREST + File.separator + OUT);\n+                if (inFlow != null) {\n+                    for (String inFlowPath : inFlow.getChildren()) {\n+                        inputStream = registry.get(inFlowPath).getContentStream();\n+                        outputStream = new FileOutputStream(archivePath + File.separator + SOAPTOREST\n+                                + File.separator + IN +\n+                                inFlowPath.substring(inFlowPath.lastIndexOf(RegistryConstants.PATH_SEPARATOR)));\n+                        IOUtils.copy(inputStream, outputStream);\n+                        IOUtils.closeQuietly(inputStream);\n+                        IOUtils.closeQuietly(outputStream);\n+                    }\n+                }\n+                if (outFlow != null) {\n+                    for (String outFlowPath : outFlow.getChildren()) {\n+                        inputStream = registry.get(outFlowPath).getContentStream();\n+                        outputStream = new FileOutputStream(archivePath + File.separator + SOAPTOREST\n+                                + File.separator + OUT +\n+                                outFlowPath.substring(outFlowPath.lastIndexOf(RegistryConstants.PATH_SEPARATOR)));\n+                        IOUtils.copy(inputStream, outputStream);\n+                        IOUtils.closeQuietly(inputStream);\n+                        IOUtils.closeQuietly(outputStream);\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new APIImportExportException(\"I/O error while writing API SOAP to REST logic to file\", e);\n+        } catch (RegistryException e) {\n+            throw new APIImportExportException(\"Error while retrieving SOAP to REST logic\", e);\n+        } finally {\n+            IOUtils.closeQuietly(inputStream);\n+            IOUtils.closeQuietly(outputStream);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve documentation for the exporting API or API Product and store it in the archive directory.\n+     * FILE, INLINE, MARKDOWN and URL documentations are handled.\n+     *\n+     * @param archivePath  File path to export the documents\n+     * @param identifier   ID of the requesting API or API Product\n+     * @param registry     Current tenant registry\n+     * @param exportFormat Format for export\n+     * @param apiProvider  API Provider\n+     * @throws APIImportExportException If an error occurs while retrieving documents from the\n+     *                                  registry or storing in the archive directory\n+     * @throws APIManagementException   If an error occurs while retrieving document details\n+     */\n+    public static void addDocumentationToArchive(String archivePath, Identifier identifier, Registry registry,\n+                                                 ExportFormat exportFormat, APIProvider apiProvider)\n+            throws APIImportExportException, APIManagementException {\n+\n+        List<Documentation> docList = apiProvider.getAllDocumentation(identifier);\n+        String tenantDomain = RestApiUtil.getLoggedInUserTenantDomain();\n+        if (!docList.isEmpty()) {\n+            Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+            String docDirectoryPath = archivePath + File.separator + ImportExportConstants.DOCUMENT_DIRECTORY;\n+            CommonUtil.createDirectory(docDirectoryPath);\n+            try {\n+                for (Documentation doc : docList) {\n+                    // Retrieving the document again since objects in docList might have missing fields\n+                    Documentation individualDocument = apiProvider.getDocumentation(doc.getId(), tenantDomain);\n+                    String sourceType = individualDocument.getSourceType().name();\n+                    String resourcePath = null;\n+                    String localFileName = null;\n+                    String individualDocDirectoryPath = docDirectoryPath + File.separator + individualDocument.getName();\n+                    CommonUtil.createDirectory(individualDocDirectoryPath);\n+                    writeDtoToFile(individualDocDirectoryPath +\n+                                    ImportExportConstants.DOCUMENT_FILE_NAME, exportFormat,\n+                            ImportExportConstants.TYPE_DOCUMENTS, individualDocument);\n+                    if (Documentation.DocumentSourceType.FILE.toString().equalsIgnoreCase(sourceType)) {\n+                        localFileName = individualDocument.getFilePath().substring(\n+                                individualDocument.getFilePath().lastIndexOf(RegistryConstants.PATH_SEPARATOR) + 1);\n+                        resourcePath = APIUtil.getDocumentationFilePath(identifier, localFileName);\n+                        individualDocument.setFilePath(localFileName);\n+                    } else if (Documentation.DocumentSourceType.INLINE.toString().equalsIgnoreCase(sourceType)\n+                            || Documentation.DocumentSourceType.MARKDOWN.toString().equalsIgnoreCase(sourceType)) {\n+                        // Inline/Markdown content file name would be same as the documentation name\n+                        localFileName = individualDocument.getName();\n+                        resourcePath = APIUtil.getAPIOrAPIProductDocPath(identifier) + APIConstants.INLINE_DOCUMENT_CONTENT_DIR\n+                                + RegistryConstants.PATH_SEPARATOR + localFileName;\n+                    }\n+\n+                    if (resourcePath != null) {\n+                        // Write content for Inline/Markdown/File type documentations only\n+                        // Check whether resource exists in the registry\n+                        if (registry.resourceExists(resourcePath)) {\n+                            Resource docFile = registry.get(resourcePath);\n+                            try (OutputStream outputStream = new FileOutputStream(individualDocDirectoryPath +\n+                                    File.separator + localFileName);\n+                                 InputStream fileInputStream = docFile.getContentStream()) {\n+                                IOUtils.copy(fileInputStream, outputStream);\n+                            }\n+                        } else {\n+                            // Log error and avoid throwing as we give capability to export document artifact without the\n+                            // content if does not exists\n+                            String errorMessage = \"Documentation resource for API/API Product: \" + identifier.getName()\n+                                    + \" not found in \" + resourcePath;\n+                            log.error(errorMessage);\n+                        }\n+                    }\n+                }\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Documentation retrieved successfully for API/API Product: \" + identifier.getName()\n+                            + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + identifier.getVersion());\n+                }\n+            } catch (IOException e) {\n+                String errorMessage = \"I/O error while writing documentation to file for API/API Product: \"\n+                        + identifier.getName() + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \"\n+                        + identifier.getVersion();\n+                log.error(errorMessage, e);\n+                throw new APIImportExportException(errorMessage, e);\n+            } catch (RegistryException e) {\n+                String errorMessage = \"Error while retrieving documentation for API/API Product: \" + identifier.getName()\n+                        + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + identifier.getVersion();\n+                log.error(errorMessage, e);\n+                throw new APIImportExportException(errorMessage, e);\n+            }\n+        } else if (log.isDebugEnabled()) {\n+            log.debug(\"No documentation found for API/API Product: \" + identifier + \". Skipping documentation export.\");\n+        }\n+    }\n+\n+    /**\n+     * Retrieve WSDL for the exporting API and store it in the archive directory.\n+     *\n+     * @param archivePath   File path to export the WSDL\n+     * @param apiIdentifier ID of the requesting API\n+     * @param registry      Current tenant registry\n+     * @throws APIImportExportException If an error occurs while retrieving WSDL from the registry or\n+     *                                  storing in the archive directory\n+     */\n+    public static void addWSDLtoArchive(String archivePath, APIIdentifier apiIdentifier, Registry registry)\n+            throws APIImportExportException {\n+\n+        String wsdlPath = APIConstants.API_WSDL_RESOURCE_LOCATION + apiIdentifier.getProviderName() + \"--\"\n+                + apiIdentifier.getApiName() + apiIdentifier.getVersion() + APIConstants.WSDL_FILE_EXTENSION;\n+        try {\n+            if (registry.resourceExists(wsdlPath)) {\n+                CommonUtil.createDirectory(archivePath + File.separator + \"WSDL\");\n+                Resource wsdl = registry.get(wsdlPath);\n+                try (InputStream wsdlStream = wsdl.getContentStream();\n+                     OutputStream outputStream = new FileOutputStream(archivePath + File.separator + \"WSDL\"\n+                             + File.separator + apiIdentifier.getApiName() + \"-\" + apiIdentifier.getVersion()\n+                             + APIConstants.WSDL_FILE_EXTENSION)) {\n+                    IOUtils.copy(wsdlStream, outputStream);\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"WSDL file: \" + wsdlPath + \" retrieved successfully\");\n+                    }\n+                }\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"WSDL resource does not exists in path: \" + wsdlPath + \". Skipping WSDL export.\");\n+            }\n+        } catch (IOException e) {\n+            String errorMessage = \"I/O error while writing WSDL: \" + wsdlPath + \" to file\";\n+            throw new APIImportExportException(errorMessage, e);\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while retrieving WSDL: \" + wsdlPath + \" to file\";\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve available custom sequences and API specific sequences for API export, and store it in the archive\n+     * directory.\n+     *\n+     * @param archivePath   File path to export the sequences\n+     * @param apiIdentifier API Identifier\n+     * @param apiDto        API DTO\n+     * @param registry      Current tenant registry\n+     * @param exportFormat  Export format of file\n+     * @throws APIImportExportException If an error occurs while exporting sequences\n+     */\n+    public static void addSequencesToArchive(String archivePath, APIIdentifier apiIdentifier, APIDTO apiDto,\n+                                             Registry registry, ExportFormat exportFormat) throws APIImportExportException {\n+\n+        Map<String, String> sequences = new HashMap<>();\n+        String seqArchivePath = archivePath.concat(File.separator + \"Sequences\");\n+        List<MediationPolicyDTO> mediationPolicyDtos = apiDto.getMediationPolicies();\n+        if (!apiDto.getMediationPolicies().isEmpty()) {\n+            CommonUtil.createDirectory(seqArchivePath);\n+            for (MediationPolicyDTO mediationPolicyDto : mediationPolicyDtos) {\n+                AbstractMap.SimpleEntry<String, OMElement> sequenceDetails;\n+                String sequenceName = mediationPolicyDto.getName();\n+                String direction = mediationPolicyDto.getType().toLowerCase();\n+                String pathToExportedSequence = seqArchivePath + File.separator + direction + \"-sequence\" +\n+                        File.separator;\n+                String pathToIndividualSequenceFile = pathToExportedSequence + ImportExportConstants.SEQUENCE_FILE_NAME;\n+                if (sequenceName != null) {\n+                    sequenceDetails = getCustomSequence(sequenceName, direction, registry);\n+                    if (sequenceDetails == null) {\n+                        // If sequence doesn't exist in 'apimgt/customsequences/{in/out/fault}' directory check in API\n+                        // specific registry path\n+                        sequenceDetails = getAPISpecificSequence(apiIdentifier, sequenceName, direction, registry);\n+                        pathToExportedSequence += ImportExportConstants.CUSTOM_TYPE + File.separator;\n+                    }\n+                    writeSequenceToFile(pathToExportedSequence, sequenceDetails, apiIdentifier);\n+                    try {\n+                        writeDtoToFile(pathToIndividualSequenceFile, exportFormat, ImportExportConstants.TYPE_SEQUENCE,\n+                                mediationPolicyDto);\n+                    } catch (IOException e) {\n+                        String errorMessage = \"I/O error while writing sequence: \" + sequenceName + \" to file\";\n+                        throw new APIImportExportException(errorMessage, e);\n+                    }\n+                }\n+            }\n+        } else if (log.isDebugEnabled()) {\n+            log.debug(\"No custom sequences available for API: \" + apiIdentifier.getApiName() + StringUtils.SPACE\n+                    + APIConstants.API_DATA_VERSION + \": \" + apiIdentifier.getVersion()\n+                    + \". Skipping custom sequence export.\");\n+        }\n+    }\n+\n+    /**\n+     * Retrieve custom sequence details from the registry.\n+     *\n+     * @param sequenceName Name of the sequence\n+     * @param type         Sequence type\n+     * @param registry     Current tenant registry\n+     * @return Registry resource name of the sequence and its content\n+     * @throws APIImportExportException If an error occurs while retrieving registry elements\n+     */\n+    private static AbstractMap.SimpleEntry<String, OMElement> getCustomSequence(String sequenceName, String type,\n+                                                                                Registry registry)\n+            throws APIImportExportException {\n+\n+        String regPath = null;\n+        if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_IN.equals(type)) {\n+            regPath = APIConstants.API_CUSTOM_INSEQUENCE_LOCATION;\n+        } else if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_OUT.equals(type)) {\n+            regPath = APIConstants.API_CUSTOM_OUTSEQUENCE_LOCATION;\n+        } else if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_FAULT.equals(type)) {\n+            regPath = APIConstants.API_CUSTOM_FAULTSEQUENCE_LOCATION;\n+        }\n+        return getSeqDetailsFromRegistry(sequenceName, regPath, registry);\n+    }\n+\n+    /**\n+     * Retrieve API Specific sequence details from the registry.\n+     *\n+     * @param sequenceName Name of the sequence\n+     * @param type         Sequence type\n+     * @param registry     Current tenant registry\n+     * @return Registry resource name of the sequence and its content\n+     * @throws APIImportExportException If an error occurs while retrieving registry elements\n+     */\n+    private static AbstractMap.SimpleEntry<String, OMElement> getAPISpecificSequence(APIIdentifier api,\n+                                                                                     String sequenceName, String type,\n+                                                                                     Registry registry)\n+            throws APIImportExportException {\n+\n+        String regPath = APIConstants.API_ROOT_LOCATION + RegistryConstants.PATH_SEPARATOR + api.getProviderName()\n+                + RegistryConstants.PATH_SEPARATOR + api.getApiName() + RegistryConstants.PATH_SEPARATOR\n+                + api.getVersion() + RegistryConstants.PATH_SEPARATOR + type;\n+        return getSeqDetailsFromRegistry(sequenceName, regPath, registry);\n+    }\n+\n+    /**\n+     * Retrieve sequence details from registry by given registry path.\n+     *\n+     * @param sequenceName Sequence Name\n+     * @param regPath      Registry path\n+     * @param registry     Registry\n+     * @return Sequence details as a simple entry\n+     * @throws APIImportExportException If an error occurs while retrieving sequence details from registry\n+     */\n+    private static AbstractMap.SimpleEntry<String, OMElement> getSeqDetailsFromRegistry(String sequenceName,\n+                                                                                        String regPath, Registry registry)\n+            throws APIImportExportException {\n+\n+        AbstractMap.SimpleEntry<String, OMElement> sequenceDetails = null;\n+        Collection seqCollection;\n+\n+        try {\n+            seqCollection = (Collection) registry.get(regPath);\n+            if (seqCollection != null) {\n+                String[] childPaths = seqCollection.getChildren();\n+                for (String childPath : childPaths) {\n+                    Resource sequence = registry.get(childPath);\n+                    OMElement seqElement = APIUtil.buildOMElement(sequence.getContentStream());\n+                    if (sequenceName.equals(seqElement.getAttributeValue(new QName(\"name\")))) {\n+                        String sequenceFileName = sequenceName + APIConstants.XML_EXTENSION;\n+                        sequenceDetails = new AbstractMap.SimpleEntry<>(sequenceFileName, seqElement);\n+                        break;\n+                    }\n+                }\n+            }\n+        } catch (RegistryException e) {\n+            String errorMessage = \"Error while retrieving sequence: \" + sequenceName + \" from the path: \" + regPath;\n+            throw new APIImportExportException(errorMessage, e);\n+        } catch (Exception e) {\n+            //APIUtil.buildOMElement() throws a generic exception\n+            String errorMessage = \"Error while reading content for sequence: \" + sequenceName + \" from the registry\";\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+        return sequenceDetails;\n+    }\n+\n+    /**\n+     * Store API Specific or custom sequences in the archive directory.\n+     *\n+     * @param sequenceDetails Details of the sequence\n+     * @param apiIdentifier   ID of the requesting API\n+     * @throws APIImportExportException If an error occurs while serializing XML stream or storing in\n+     *                                  archive directory\n+     */\n+    private static void writeSequenceToFile(String pathToExportedSequence,\n+                                            AbstractMap.SimpleEntry<String, OMElement> sequenceDetails,\n+                                            APIIdentifier apiIdentifier)\n+            throws APIImportExportException {\n+\n+        if (sequenceDetails != null) {\n+            String sequenceFileName = sequenceDetails.getKey();\n+            OMElement sequenceConfig = sequenceDetails.getValue();\n+            CommonUtil.createDirectory(pathToExportedSequence);\n+            String exportedSequenceFile = pathToExportedSequence + sequenceFileName;\n+            try (OutputStream outputStream = new FileOutputStream(exportedSequenceFile)) {\n+                sequenceConfig.serialize(outputStream);\n+                if (log.isDebugEnabled()) {\n+                    log.debug(sequenceFileName + \" of API: \" + apiIdentifier.getApiName() + \" retrieved successfully\");\n+                }\n+            } catch (IOException e) {\n+                String errorMessage = \"Unable to find file: \" + exportedSequenceFile;\n+                throw new APIImportExportException(errorMessage, e);\n+            } catch (XMLStreamException e) {\n+                String errorMessage = \"Error while processing XML stream \";\n+                throw new APIImportExportException(errorMessage, e);\n+            }\n+        } else {\n+            String errorMessage = \"Error while writing sequence of API: \" + apiIdentifier.getApiName() + \" to file.\";\n+            throw new APIImportExportException(errorMessage);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve the endpoint certificates and store those in the archive directory.\n+     *\n+     * @param archivePath  File path to export the endpoint certificates\n+     * @param apiDto       API DTO to be exported\n+     * @param tenantId     Tenant id of the user\n+     * @param exportFormat Export format of file\n+     * @throws APIImportExportException If an error occurs while exporting endpoint certificates\n+     */\n+    public static void addEndpointCertificatesToArchive(String archivePath, APIDTO apiDto, int tenantId,\n+                                                        ExportFormat exportFormat) throws APIImportExportException {\n+        List<String> productionEndpoints;\n+        List<String> sandboxEndpoints;\n+        Set<String> uniqueEndpointURLs = new HashSet<>();\n+        JsonArray endpointCertificatesDetails = new JsonArray();\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        String endpointConfigString = gson.toJson(apiDto.getEndpointConfig());\n+        String endpointCertsDirectoryPath = archivePath + File.separator\n+                + ImportExportConstants.ENDPOINT_CERTIFICATES_DIRECTORY;\n+        CommonUtil.createDirectory(endpointCertsDirectoryPath);\n+\n+        if (StringUtils.isEmpty(endpointConfigString)) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Endpoint Details are empty for API: \" + apiDto.getName() + StringUtils.SPACE\n+                        + APIConstants.API_DATA_VERSION + \": \" + apiDto.getVersion());\n+            }\n+            return;\n+        }\n+        try {\n+            JSONTokener tokener = new JSONTokener(endpointConfigString);\n+            JSONObject endpointConfig = new JSONObject(tokener);\n+            productionEndpoints = getEndpointURLs(endpointConfig, APIConstants.API_DATA_PRODUCTION_ENDPOINTS,\n+                    apiDto.getName());\n+            sandboxEndpoints = getEndpointURLs(endpointConfig, APIConstants.API_DATA_SANDBOX_ENDPOINTS,\n+                    apiDto.getName());\n+            uniqueEndpointURLs.addAll(productionEndpoints); // Remove duplicate and append result\n+            uniqueEndpointURLs.addAll(sandboxEndpoints);\n+\n+            for (String url : uniqueEndpointURLs) {\n+                JsonArray certificateListOfUrl = getEndpointCertificateContentAndMetaData(tenantId, url,\n+                        endpointCertsDirectoryPath);\n+                endpointCertificatesDetails.addAll(certificateListOfUrl);\n+            }\n+            if (endpointCertificatesDetails.size() > 0) {\n+                writeDtoToFile(endpointCertsDirectoryPath +\n+                                ImportExportConstants.ENDPOINTS_CERTIFICATE_FILE, exportFormat,\n+                        ImportExportConstants.TYPE_ENDPOINT_CERTIFICATES, endpointCertificatesDetails);\n+            } else if (log.isDebugEnabled()) {\n+                log.debug(\"No endpoint certificates available for API: \" + apiDto.getName() + StringUtils.SPACE\n+                        + APIConstants.API_DATA_VERSION + \": \" + apiDto.getVersion() + \". Skipping certificate export.\");\n+            }\n+        } catch (JSONException e) {\n+            String errorMsg = \"Error in converting Endpoint config to JSON object in API: \" + apiDto.getName();\n+            throw new APIImportExportException(errorMsg, e);\n+        } catch (IOException e) {\n+            String errorMessage = \"Error while retrieving saving endpoint certificate details for API: \"\n+                    + apiDto.getName() + \" as YAML\";\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Get Endpoint Certificate MetaData and Certificate detail and build JSON Array.\n+     *\n+     * @param tenantId          Tenant id of the user\n+     * @param url               Url of the endpoint\n+     * @param certDirectoryPath Directory path to export the certificates\n+     * @return JSON Array of certificate details\n+     * @throws APIImportExportException If an error occurs while retrieving endpoint certificate metadata and content\n+     */\n+    private static JsonArray getEndpointCertificateContentAndMetaData(int tenantId, String url,\n+                                                                      String certDirectoryPath)\n+            throws APIImportExportException {\n+\n+        List<CertificateMetadataDTO> certificateMetadataDTOS;\n+        CertificateManager certificateManager = CertificateManagerImpl.getInstance();\n+\n+        try {\n+            certificateMetadataDTOS = certificateManager.getCertificates(tenantId, null, url);\n+        } catch (APIManagementException e) {\n+            String errorMsg = \"Error retrieving certificate meta data. For tenantId: \" + tenantId + \" hostname: \"\n+                    + url;\n+            throw new APIImportExportException(errorMsg, e);\n+        }\n+\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        JsonArray certificatesList = new JsonArray();\n+        certificateMetadataDTOS.forEach(metadataDTO -> {\n+            ByteArrayInputStream certificate = null;\n+            try {\n+                certificate = certificateManager.getCertificateContent(metadataDTO.getAlias());\n+                certificate.close();\n+                byte[] certificateContent = IOUtils.toByteArray(certificate);\n+                String certificateContentEncoded = APIConstants.BEGIN_CERTIFICATE_STRING\n+                        .concat(new String(Base64.encodeBase64(certificateContent))).concat(\"\\n\")\n+                        .concat(APIConstants.END_CERTIFICATE_STRING);\n+                CommonUtil.writeFile(certDirectoryPath + File.separator + metadataDTO.getAlias() + \".crt\",\n+                        certificateContentEncoded);\n+                // Add the file name to the Certificate Metadata\n+                JsonObject modifiedCertificateMetadata = (JsonObject) gson.toJsonTree(metadataDTO);\n+                modifiedCertificateMetadata.addProperty(ImportExportConstants.CERTIFICATE_FILE,\n+                        metadataDTO.getAlias() + \".crt\");\n+                certificatesList.add(modifiedCertificateMetadata);\n+            } catch (APIManagementException e) {\n+                log.error(\"Error retrieving certificate content. For tenantId: \" + tenantId + \" hostname: \"\n+                        + url + \" alias: \" + metadataDTO.getAlias(), e);\n+            } catch (IOException e) {\n+                log.error(\"Error while converting certificate content to Byte Array. For tenantId: \" + tenantId\n+                        + \" hostname: \" + url + \" alias: \" + metadataDTO.getAlias(), e);\n+            } catch (APIImportExportException e) {\n+                log.error(\"Error while writing the certificate content. For tenantId: \" + tenantId + \" hostname: \"\n+                        + url + \" alias: \" + metadataDTO.getAlias(), e);\n+            } finally {\n+                if (certificate != null) {\n+                    IOUtils.closeQuietly(certificate);\n+                }\n+            }\n+        });\n+        return certificatesList;\n+    }\n+\n+    /**\n+     * Get endpoint url list from endpoint config.\n+     *\n+     * @param endpointConfig JSON converted endpoint config\n+     * @param type           End point type - production/sandbox\n+     * @return List of host names\n+     */\n+    private static List<String> getEndpointURLs(JSONObject endpointConfig, String type, String apiName) {\n+        List<String> urls = new ArrayList<>();\n+        if (endpointConfig != null) {\n+            try {\n+                Object item;\n+                item = endpointConfig.get(type);\n+                if (item instanceof JSONArray) {\n+                    JSONArray endpointsJSON = new JSONArray(endpointConfig.getJSONArray(type).toString());\n+                    for (int i = 0; i < endpointsJSON.length(); i++) {\n+                        try {\n+                            String urlValue = endpointsJSON.getJSONObject(i).get(APIConstants.API_DATA_URL).toString();\n+                            urls.add(urlValue);\n+                        } catch (JSONException ex) {\n+                            log.error(\"Endpoint URL extraction from endpoints JSON object failed in API: \"\n+                                    + apiName, ex);\n+                        }\n+                    }\n+                } else if (item instanceof JSONObject) {\n+                    JSONObject endpointJSON = new JSONObject(endpointConfig.getJSONObject(type).toString());\n+                    try {\n+                        String urlValue = endpointJSON.get(APIConstants.API_DATA_URL).toString();\n+                        urls.add(urlValue);\n+                    } catch (JSONException ex) {\n+                        log.error(\"Endpoint URL extraction from endpoint JSON object failed in API: \" + apiName, ex);\n+                    }\n+                }\n+            } catch (JSONException ex) {\n+                log.info(\"Endpoint type: \" + type + \" not found in API: \" + apiName);\n+            }\n+        }\n+        return urls;\n+    }\n+\n+    /**\n+     * Retrieve meta information of the API to export and store those in the archive directory.\n+     * URL template information are stored in swagger.json definition while rest of the required\n+     * data are in api.json\n+     *\n+     * @param archivePath    Folder path to export meta information to export\n+     * @param apiDtoToReturn API DTO to be exported\n+     * @param exportFormat   Export format of file\n+     * @param apiProvider    API Provider\n+     * @param apiIdentifier  API Identifier\n+     * @param userName       Username\n+     * @throws APIImportExportException If an error occurs while exporting meta information\n+     */\n+    public static void addAPIMetaInformationToArchive(String archivePath, APIDTO apiDtoToReturn, ExportFormat exportFormat,\n+                                                      APIProvider apiProvider, APIIdentifier apiIdentifier, String userName)\n+            throws APIImportExportException {\n+\n+        CommonUtil.createDirectory(archivePath + File.separator + ImportExportConstants.META_INFO_DIRECTORY);\n+\n+        try {\n+            Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+\n+            // If a web socket API is exported, it does not contain a swagger file.\n+            // Therefore swagger export is only required for REST, Graphql or SOAP based APIs\n+            String apiType = apiDtoToReturn.getType().toString();\n+            if (!APIConstants.APITransportType.WS.toString().equalsIgnoreCase(apiType)) {\n+                //For Graphql APIs, the graphql schema definition, swagger and the serialized api object are exported.\n+                if (StringUtils.equals(apiType, APIConstants.APITransportType.GRAPHQL.toString())) {\n+                    String schemaContent = apiProvider.getGraphqlSchema(apiIdentifier);\n+                    CommonUtil.writeFile(archivePath + ImportExportConstants.GRAPHQL_SCHEMA_DEFINITION_LOCATION,\n+                            schemaContent);\n+                }\n+                String formattedSwaggerJson = RestApiPublisherUtils.retrieveSwaggerDefinition(\n+                        APIMappingUtil.fromDTOtoAPI(apiDtoToReturn, userName), apiProvider);\n+                writeToYamlOrJson(archivePath + ImportExportConstants.SWAGGER_DEFINITION_LOCATION,\n+                        exportFormat, formattedSwaggerJson);\n+\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Meta information retrieved successfully for API: \" + apiDtoToReturn.getName()\n+                            + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + apiDtoToReturn.getVersion());\n+                }\n+            }\n+            writeDtoToFile(archivePath + ImportExportConstants.API_FILE_LOCATION, exportFormat,\n+                    ImportExportConstants.TYPE_API, apiDtoToReturn);\n+        } catch (APIManagementException e) {\n+            String errorMessage = \"Error while retrieving Swagger definition for API: \" + apiDtoToReturn.getName()\n+                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + apiDtoToReturn.getVersion();\n+            throw new APIImportExportException(errorMessage, e);\n+        } catch (IOException e) {\n+            String errorMessage = \"Error while retrieving saving as YAML for API: \" + apiDtoToReturn.getName()\n+                    + StringUtils.SPACE + APIConstants.API_DATA_VERSION + \": \" + apiDtoToReturn.getVersion();\n+            throw new APIImportExportException(errorMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve Mutual SSL related certificates and store those in the archive directory\n+     *\n+     * @param archivePath  Folder path to export client certificates\n+     * @param identifier   Identifier\n+     * @param tenantId     Tenant id of the user\n+     * @param provider     Api Provider\n+     * @param exportFormat Export format of file\n+     * @throws APIImportExportException If an error occurs when writing to file or retrieving certificate metadata\n+     */\n+    public static void addClientCertificatesToArchive(String archivePath, Identifier identifier,\n+                                                      int tenantId, APIProvider provider,\n+                                                      ExportFormat exportFormat) throws APIImportExportException {\n+        List<ClientCertificateDTO> certificateMetadataDTOs;\n+        try {\n+            if (identifier instanceof APIProductIdentifier) {\n+                certificateMetadataDTOs = provider.searchClientCertificates(tenantId, null,\n+                        (APIProductIdentifier) identifier);\n+            } else {\n+                certificateMetadataDTOs = provider.searchClientCertificates(tenantId, null,\n+                        (APIIdentifier) identifier);\n+            }\n+            if (!certificateMetadataDTOs.isEmpty()) {\n+                String clientCertsDirectoryPath = archivePath + File.separator\n+                        + ImportExportConstants.CLIENT_CERTIFICATES_DIRECTORY;\n+                CommonUtil.createDirectory(clientCertsDirectoryPath);\n+\n+                JsonArray certificateList = getClientCertificateContentAndMetaData(certificateMetadataDTOs, clientCertsDirectoryPath);\n+\n+                if (certificateList.size() > 0) {\n+                    writeDtoToFile(clientCertsDirectoryPath + ImportExportConstants.CLIENT_CERTIFICATE_FILE,\n+                            exportFormat, ImportExportConstants.TYPE_CLIENT_CERTIFICATES, certificateList);\n+                }\n+            }\n+        } catch (IOException e) {\n+            String errorMessage = \"Error while saving as YAML or JSON\";\n+            throw new APIImportExportException(errorMessage, e);\n+        } catch (APIManagementException e) {\n+            String errorMsg = \"Error retrieving certificate meta data. tenantId [\" + tenantId + \"] api [\"\n+                    + tenantId + \"]\";\n+            throw new APIImportExportException(errorMsg, e);\n+        }\n+    }\n+\n+    /**\n+     * Get Client Certificate MetaData and Certificate detail and build JSON list.\n+     *\n+     * @param clientCertificateDTOs client certificates list DTOs\n+     * @param certDirectoryPath     directory path to export the certificates\n+     * @return list of certificate detail JSON objects\n+     */\n+    private static JsonArray getClientCertificateContentAndMetaData(List<ClientCertificateDTO> clientCertificateDTOs,\n+                                                                    String certDirectoryPath) {\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        JsonArray certificatesList = new JsonArray();\n+        clientCertificateDTOs.forEach(metadataDTO -> {\n+            ByteArrayInputStream certificate = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU1MzAwMQ=="}, "originalCommit": {"oid": "67a7a292f0788f2879e86f6675caf1d27f063c89"}, "originalPosition": 944}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU2OTc3OTA3OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/utils/RestApiPublisherUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQxMDowMzozOVrOIcdKlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQxNDo1Mzo0NVrOIcnYDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjcwODg4Nw==", "bodyText": "Missing apiProvider in the java docs", "url": "https://github.com/wso2/carbon-apimgt/pull/9406#discussion_r566708887", "createdAt": "2021-01-29T10:03:39Z", "author": {"login": "npamudika"}, "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/utils/RestApiPublisherUtils.java", "diffHunk": "@@ -346,4 +349,16 @@ public static String getSOAPOperation() {\n                 + \"\\\"required\\\":false,\\\"in\\\":\\\"header\\\"}],\\\"responses\\\":{\\\"200\\\":{\\\"description\\\":\\\"OK\\\"}},\" +\n                 \"\\\"security\\\":[{\\\"default\\\":[]}],\\\"consumes\\\":[\\\"text/xml\\\",\\\"application/soap+xml\\\"]}}}\";\n     }\n+\n+    /**\n+     * This method retrieves the Swagger Definition for an API to be displayed\n+     * @param api API", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "104487012360314b382f40330851e4fcb24df53c"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg3NjE3NQ==", "bodyText": "Fixed via eb9b718", "url": "https://github.com/wso2/carbon-apimgt/pull/9406#discussion_r566876175", "createdAt": "2021-01-29T14:53:45Z", "author": {"login": "wasuradananjith"}, "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/utils/RestApiPublisherUtils.java", "diffHunk": "@@ -346,4 +349,16 @@ public static String getSOAPOperation() {\n                 + \"\\\"required\\\":false,\\\"in\\\":\\\"header\\\"}],\\\"responses\\\":{\\\"200\\\":{\\\"description\\\":\\\"OK\\\"}},\" +\n                 \"\\\"security\\\":[{\\\"default\\\":[]}],\\\"consumes\\\":[\\\"text/xml\\\",\\\"application/soap+xml\\\"]}}}\";\n     }\n+\n+    /**\n+     * This method retrieves the Swagger Definition for an API to be displayed\n+     * @param api API", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjcwODg4Nw=="}, "originalCommit": {"oid": "104487012360314b382f40330851e4fcb24df53c"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU2OTc4MDk1OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/utils/RestApiPublisherUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQxMDowNDowNlrOIcdLpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQxNDo1MzozOFrOIcnXtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjcwOTE1Nw==", "bodyText": "Please define what is return by the String value as well", "url": "https://github.com/wso2/carbon-apimgt/pull/9406#discussion_r566709157", "createdAt": "2021-01-29T10:04:06Z", "author": {"login": "npamudika"}, "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/utils/RestApiPublisherUtils.java", "diffHunk": "@@ -346,4 +349,16 @@ public static String getSOAPOperation() {\n                 + \"\\\"required\\\":false,\\\"in\\\":\\\"header\\\"}],\\\"responses\\\":{\\\"200\\\":{\\\"description\\\":\\\"OK\\\"}},\" +\n                 \"\\\"security\\\":[{\\\"default\\\":[]}],\\\"consumes\\\":[\\\"text/xml\\\",\\\"application/soap+xml\\\"]}}}\";\n     }\n+\n+    /**\n+     * This method retrieves the Swagger Definition for an API to be displayed\n+     * @param api API\n+     * @return String", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "104487012360314b382f40330851e4fcb24df53c"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg3NjA4NA==", "bodyText": "Fixed via eb9b718", "url": "https://github.com/wso2/carbon-apimgt/pull/9406#discussion_r566876084", "createdAt": "2021-01-29T14:53:38Z", "author": {"login": "wasuradananjith"}, "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/utils/RestApiPublisherUtils.java", "diffHunk": "@@ -346,4 +349,16 @@ public static String getSOAPOperation() {\n                 + \"\\\"required\\\":false,\\\"in\\\":\\\"header\\\"}],\\\"responses\\\":{\\\"200\\\":{\\\"description\\\":\\\"OK\\\"}},\" +\n                 \"\\\"security\\\":[{\\\"default\\\":[]}],\\\"consumes\\\":[\\\"text/xml\\\",\\\"application/soap+xml\\\"]}}}\";\n     }\n+\n+    /**\n+     * This method retrieves the Swagger Definition for an API to be displayed\n+     * @param api API\n+     * @return String", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjcwOTE1Nw=="}, "originalCommit": {"oid": "104487012360314b382f40330851e4fcb24df53c"}, "originalPosition": 24}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2943, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}