{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4MzU3Mzcw", "number": 8118, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxMToyMTo1OVrODexGDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxMTozMzoyNFrODexTZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNTg4MjM5OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.gateway/src/main/java/org/wso2/carbon/apimgt/gateway/handlers/graphQL/GraphQLQueryAnalysisHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxMToyMTo1OVrOFoFYZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxMToyMTo1OVrOFoFYZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU3NTUyNg==", "bodyText": "Java doc should say what the return value means.", "url": "https://github.com/wso2/carbon-apimgt/pull/8118#discussion_r377575526", "createdAt": "2020-02-11T11:21:59Z", "author": {"login": "bhathiya"}, "path": "components/apimgt/org.wso2.carbon.apimgt.gateway/src/main/java/org/wso2/carbon/apimgt/gateway/handlers/graphQL/GraphQLQueryAnalysisHandler.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ *  Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.wso2.carbon.apimgt.gateway.handlers.graphQL;\n+\n+import graphql.ExecutionResult;\n+import graphql.GraphQL;\n+import graphql.GraphQLError;\n+import graphql.analysis.FieldComplexityCalculator;\n+import graphql.analysis.MaxQueryComplexityInstrumentation;\n+import graphql.analysis.MaxQueryDepthInstrumentation;\n+import graphql.schema.GraphQLSchema;\n+\n+import org.apache.axiom.om.OMAbstractFactory;\n+import org.apache.axiom.om.OMElement;\n+import org.apache.axiom.om.OMFactory;\n+import org.apache.axiom.om.OMNamespace;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.http.HttpStatus;\n+import org.apache.synapse.Mediator;\n+import org.apache.synapse.MessageContext;\n+import org.apache.synapse.rest.AbstractHandler;\n+import org.json.simple.JSONObject;\n+import org.json.simple.parser.JSONParser;\n+import org.json.simple.parser.ParseException;\n+import org.wso2.carbon.apimgt.gateway.handlers.Utils;\n+import org.wso2.carbon.apimgt.gateway.handlers.security.APISecurityConstants;\n+import org.wso2.carbon.apimgt.gateway.handlers.security.APISecurityException;\n+import org.wso2.carbon.apimgt.gateway.handlers.security.APISecurityUtils;\n+import org.wso2.carbon.apimgt.gateway.handlers.security.usermgt.APIKeyMgtRemoteUserClient;\n+import org.wso2.carbon.apimgt.gateway.handlers.security.usermgt.APIKeyMgtRemoteUserClientPool;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+public class GraphQLQueryAnalysisHandler extends AbstractHandler {\n+\n+    private static final Log log = LogFactory.getLog(GraphQLQueryAnalysisHandler.class);\n+    private GraphQLSchema schema = null;\n+\n+    public boolean handleRequest(MessageContext messageContext) {\n+        schema = (GraphQLSchema) messageContext.getProperty(APIConstants.GRAPHQL_SCHEMA);\n+        String payload = messageContext.getProperty(APIConstants.GRAPHQL_PAYLOAD).toString();\n+        if (!analyseQuery(messageContext, payload)) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Query was blocked by the static query analyser\");\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This method returns the user roles\n+     *\n+     * @param username username of the user\n+     * @return list of user roles\n+     */\n+    private String[] getUserRoles(String username) throws APISecurityException {\n+        String[] userRoles;\n+        APIKeyMgtRemoteUserClient client;\n+        try {\n+            APIKeyMgtRemoteUserClientPool clientPool = APIKeyMgtRemoteUserClientPool.getInstance();\n+            client = clientPool.get();\n+            userRoles = client.getUserRoles(username);\n+        } catch (Exception e) {\n+            throw new APISecurityException(APISecurityConstants.API_AUTH_GENERAL_ERROR, e.getMessage(), e);\n+        }\n+        return userRoles;\n+    }\n+\n+    /**\n+     * This method returns the maximum query depth value\n+     *\n+     * @param userRoles        list of user roles\n+     * @param policyDefinition json object which contains the policy\n+     * @return maximum query depth value if exists, or -1 to denote no depth limitation\n+     */\n+    private int getMaxQueryDepth(String[] userRoles, JSONObject policyDefinition) {\n+        Object depthObject = policyDefinition.get(APIConstants.QUERY_ANALYSIS_DEPTH);\n+        boolean depthCheckEnabled = Boolean.parseBoolean(((JSONObject) depthObject).get(\"enabled\").toString());\n+        List<Integer> allocatedDepths = new ArrayList<>();\n+        if (depthCheckEnabled) {\n+            for (String role : userRoles) {\n+                Object depth = ((JSONObject) depthObject).get(role);\n+                if (depth != null) {\n+                    allocatedDepths.add(((Long) depth).intValue());\n+                } else {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"No depth limitation value was assigned for \" + role + \" role\");\n+                    }\n+                }\n+            }\n+            if (allocatedDepths.isEmpty()) {\n+                Object defaultDepth = ((JSONObject) depthObject).get(\"default\");\n+                if (defaultDepth != null) {\n+                    return ((Long) defaultDepth).intValue();\n+                } else {\n+                    log.error(\"No default depth was allocated\");\n+                    return -1;\n+                }\n+            } else {\n+                return Collections.max(allocatedDepths);\n+            }\n+        } else {\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * This method analyses the query\n+     *\n+     * @param messageContext message context of the request\n+     * @param payload        payload of the request\n+     * @return true or false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fda90e955847d20552638e1df45e7dd9cec7f53"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNTg5MzUzOnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.gateway/src/main/java/org/wso2/carbon/apimgt/gateway/handlers/graphQL/GraphQLQueryAnalysisHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxMToyNTo1OFrOFoFfOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxMToyNTo1OFrOFoFfOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU3NzI3Mw==", "bodyText": "method names should be verbs. how about analyseQueryDepth?", "url": "https://github.com/wso2/carbon-apimgt/pull/8118#discussion_r377577273", "createdAt": "2020-02-11T11:25:58Z", "author": {"login": "bhathiya"}, "path": "components/apimgt/org.wso2.carbon.apimgt.gateway/src/main/java/org/wso2/carbon/apimgt/gateway/handlers/graphQL/GraphQLQueryAnalysisHandler.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ *  Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.wso2.carbon.apimgt.gateway.handlers.graphQL;\n+\n+import graphql.ExecutionResult;\n+import graphql.GraphQL;\n+import graphql.GraphQLError;\n+import graphql.analysis.FieldComplexityCalculator;\n+import graphql.analysis.MaxQueryComplexityInstrumentation;\n+import graphql.analysis.MaxQueryDepthInstrumentation;\n+import graphql.schema.GraphQLSchema;\n+\n+import org.apache.axiom.om.OMAbstractFactory;\n+import org.apache.axiom.om.OMElement;\n+import org.apache.axiom.om.OMFactory;\n+import org.apache.axiom.om.OMNamespace;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.http.HttpStatus;\n+import org.apache.synapse.Mediator;\n+import org.apache.synapse.MessageContext;\n+import org.apache.synapse.rest.AbstractHandler;\n+import org.json.simple.JSONObject;\n+import org.json.simple.parser.JSONParser;\n+import org.json.simple.parser.ParseException;\n+import org.wso2.carbon.apimgt.gateway.handlers.Utils;\n+import org.wso2.carbon.apimgt.gateway.handlers.security.APISecurityConstants;\n+import org.wso2.carbon.apimgt.gateway.handlers.security.APISecurityException;\n+import org.wso2.carbon.apimgt.gateway.handlers.security.APISecurityUtils;\n+import org.wso2.carbon.apimgt.gateway.handlers.security.usermgt.APIKeyMgtRemoteUserClient;\n+import org.wso2.carbon.apimgt.gateway.handlers.security.usermgt.APIKeyMgtRemoteUserClientPool;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+public class GraphQLQueryAnalysisHandler extends AbstractHandler {\n+\n+    private static final Log log = LogFactory.getLog(GraphQLQueryAnalysisHandler.class);\n+    private GraphQLSchema schema = null;\n+\n+    public boolean handleRequest(MessageContext messageContext) {\n+        schema = (GraphQLSchema) messageContext.getProperty(APIConstants.GRAPHQL_SCHEMA);\n+        String payload = messageContext.getProperty(APIConstants.GRAPHQL_PAYLOAD).toString();\n+        if (!analyseQuery(messageContext, payload)) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Query was blocked by the static query analyser\");\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This method returns the user roles\n+     *\n+     * @param username username of the user\n+     * @return list of user roles\n+     */\n+    private String[] getUserRoles(String username) throws APISecurityException {\n+        String[] userRoles;\n+        APIKeyMgtRemoteUserClient client;\n+        try {\n+            APIKeyMgtRemoteUserClientPool clientPool = APIKeyMgtRemoteUserClientPool.getInstance();\n+            client = clientPool.get();\n+            userRoles = client.getUserRoles(username);\n+        } catch (Exception e) {\n+            throw new APISecurityException(APISecurityConstants.API_AUTH_GENERAL_ERROR, e.getMessage(), e);\n+        }\n+        return userRoles;\n+    }\n+\n+    /**\n+     * This method returns the maximum query depth value\n+     *\n+     * @param userRoles        list of user roles\n+     * @param policyDefinition json object which contains the policy\n+     * @return maximum query depth value if exists, or -1 to denote no depth limitation\n+     */\n+    private int getMaxQueryDepth(String[] userRoles, JSONObject policyDefinition) {\n+        Object depthObject = policyDefinition.get(APIConstants.QUERY_ANALYSIS_DEPTH);\n+        boolean depthCheckEnabled = Boolean.parseBoolean(((JSONObject) depthObject).get(\"enabled\").toString());\n+        List<Integer> allocatedDepths = new ArrayList<>();\n+        if (depthCheckEnabled) {\n+            for (String role : userRoles) {\n+                Object depth = ((JSONObject) depthObject).get(role);\n+                if (depth != null) {\n+                    allocatedDepths.add(((Long) depth).intValue());\n+                } else {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"No depth limitation value was assigned for \" + role + \" role\");\n+                    }\n+                }\n+            }\n+            if (allocatedDepths.isEmpty()) {\n+                Object defaultDepth = ((JSONObject) depthObject).get(\"default\");\n+                if (defaultDepth != null) {\n+                    return ((Long) defaultDepth).intValue();\n+                } else {\n+                    log.error(\"No default depth was allocated\");\n+                    return -1;\n+                }\n+            } else {\n+                return Collections.max(allocatedDepths);\n+            }\n+        } else {\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * This method analyses the query\n+     *\n+     * @param messageContext message context of the request\n+     * @param payload        payload of the request\n+     * @return true or false\n+     */\n+    private boolean analyseQuery(MessageContext messageContext, String payload) {\n+        JSONParser jsonParser = new JSONParser();\n+\n+        try {\n+            String graphQLAccessControlPolicy =\n+                    (String) messageContext.getProperty(APIConstants.GRAPHQL_ACCESS_CONTROL_POLICY);\n+            JSONObject policyDefinition = (JSONObject) jsonParser.parse(graphQLAccessControlPolicy);\n+            if (queryDepthAnalysis(messageContext, payload, policyDefinition) &&\n+                    queryComplexityAnalysis(messageContext, payload, policyDefinition)) {\n+                return true;\n+            } else {\n+                return false;\n+            }\n+        } catch (ParseException e) {\n+            log.error(\"Policy definition parsing failed. \" + e.getMessage(), e);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This method analyses the query depth\n+     *\n+     * @param messageContext   message context of the request\n+     * @param payload          payload of the request\n+     * @param policyDefinition json object which contains the policy\n+     * @return true or false\n+     */\n+    private boolean queryDepthAnalysis(MessageContext messageContext, String payload, JSONObject policyDefinition) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fda90e955847d20552638e1df45e7dd9cec7f53"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNTg5NTE4OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.gateway/src/main/java/org/wso2/carbon/apimgt/gateway/handlers/graphQL/GraphQLQueryAnalysisHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxMToyNjoyN1rOFoFgGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxMToyNjoyN1rOFoFgGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU3NzQ5OQ==", "bodyText": "same here.", "url": "https://github.com/wso2/carbon-apimgt/pull/8118#discussion_r377577499", "createdAt": "2020-02-11T11:26:27Z", "author": {"login": "bhathiya"}, "path": "components/apimgt/org.wso2.carbon.apimgt.gateway/src/main/java/org/wso2/carbon/apimgt/gateway/handlers/graphQL/GraphQLQueryAnalysisHandler.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ *  Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.wso2.carbon.apimgt.gateway.handlers.graphQL;\n+\n+import graphql.ExecutionResult;\n+import graphql.GraphQL;\n+import graphql.GraphQLError;\n+import graphql.analysis.FieldComplexityCalculator;\n+import graphql.analysis.MaxQueryComplexityInstrumentation;\n+import graphql.analysis.MaxQueryDepthInstrumentation;\n+import graphql.schema.GraphQLSchema;\n+\n+import org.apache.axiom.om.OMAbstractFactory;\n+import org.apache.axiom.om.OMElement;\n+import org.apache.axiom.om.OMFactory;\n+import org.apache.axiom.om.OMNamespace;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.http.HttpStatus;\n+import org.apache.synapse.Mediator;\n+import org.apache.synapse.MessageContext;\n+import org.apache.synapse.rest.AbstractHandler;\n+import org.json.simple.JSONObject;\n+import org.json.simple.parser.JSONParser;\n+import org.json.simple.parser.ParseException;\n+import org.wso2.carbon.apimgt.gateway.handlers.Utils;\n+import org.wso2.carbon.apimgt.gateway.handlers.security.APISecurityConstants;\n+import org.wso2.carbon.apimgt.gateway.handlers.security.APISecurityException;\n+import org.wso2.carbon.apimgt.gateway.handlers.security.APISecurityUtils;\n+import org.wso2.carbon.apimgt.gateway.handlers.security.usermgt.APIKeyMgtRemoteUserClient;\n+import org.wso2.carbon.apimgt.gateway.handlers.security.usermgt.APIKeyMgtRemoteUserClientPool;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+public class GraphQLQueryAnalysisHandler extends AbstractHandler {\n+\n+    private static final Log log = LogFactory.getLog(GraphQLQueryAnalysisHandler.class);\n+    private GraphQLSchema schema = null;\n+\n+    public boolean handleRequest(MessageContext messageContext) {\n+        schema = (GraphQLSchema) messageContext.getProperty(APIConstants.GRAPHQL_SCHEMA);\n+        String payload = messageContext.getProperty(APIConstants.GRAPHQL_PAYLOAD).toString();\n+        if (!analyseQuery(messageContext, payload)) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Query was blocked by the static query analyser\");\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This method returns the user roles\n+     *\n+     * @param username username of the user\n+     * @return list of user roles\n+     */\n+    private String[] getUserRoles(String username) throws APISecurityException {\n+        String[] userRoles;\n+        APIKeyMgtRemoteUserClient client;\n+        try {\n+            APIKeyMgtRemoteUserClientPool clientPool = APIKeyMgtRemoteUserClientPool.getInstance();\n+            client = clientPool.get();\n+            userRoles = client.getUserRoles(username);\n+        } catch (Exception e) {\n+            throw new APISecurityException(APISecurityConstants.API_AUTH_GENERAL_ERROR, e.getMessage(), e);\n+        }\n+        return userRoles;\n+    }\n+\n+    /**\n+     * This method returns the maximum query depth value\n+     *\n+     * @param userRoles        list of user roles\n+     * @param policyDefinition json object which contains the policy\n+     * @return maximum query depth value if exists, or -1 to denote no depth limitation\n+     */\n+    private int getMaxQueryDepth(String[] userRoles, JSONObject policyDefinition) {\n+        Object depthObject = policyDefinition.get(APIConstants.QUERY_ANALYSIS_DEPTH);\n+        boolean depthCheckEnabled = Boolean.parseBoolean(((JSONObject) depthObject).get(\"enabled\").toString());\n+        List<Integer> allocatedDepths = new ArrayList<>();\n+        if (depthCheckEnabled) {\n+            for (String role : userRoles) {\n+                Object depth = ((JSONObject) depthObject).get(role);\n+                if (depth != null) {\n+                    allocatedDepths.add(((Long) depth).intValue());\n+                } else {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"No depth limitation value was assigned for \" + role + \" role\");\n+                    }\n+                }\n+            }\n+            if (allocatedDepths.isEmpty()) {\n+                Object defaultDepth = ((JSONObject) depthObject).get(\"default\");\n+                if (defaultDepth != null) {\n+                    return ((Long) defaultDepth).intValue();\n+                } else {\n+                    log.error(\"No default depth was allocated\");\n+                    return -1;\n+                }\n+            } else {\n+                return Collections.max(allocatedDepths);\n+            }\n+        } else {\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * This method analyses the query\n+     *\n+     * @param messageContext message context of the request\n+     * @param payload        payload of the request\n+     * @return true or false\n+     */\n+    private boolean analyseQuery(MessageContext messageContext, String payload) {\n+        JSONParser jsonParser = new JSONParser();\n+\n+        try {\n+            String graphQLAccessControlPolicy =\n+                    (String) messageContext.getProperty(APIConstants.GRAPHQL_ACCESS_CONTROL_POLICY);\n+            JSONObject policyDefinition = (JSONObject) jsonParser.parse(graphQLAccessControlPolicy);\n+            if (queryDepthAnalysis(messageContext, payload, policyDefinition) &&\n+                    queryComplexityAnalysis(messageContext, payload, policyDefinition)) {\n+                return true;\n+            } else {\n+                return false;\n+            }\n+        } catch (ParseException e) {\n+            log.error(\"Policy definition parsing failed. \" + e.getMessage(), e);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This method analyses the query depth\n+     *\n+     * @param messageContext   message context of the request\n+     * @param payload          payload of the request\n+     * @param policyDefinition json object which contains the policy\n+     * @return true or false\n+     */\n+    private boolean queryDepthAnalysis(MessageContext messageContext, String payload, JSONObject policyDefinition) {\n+        String username = APISecurityUtils.getAuthenticationContext(messageContext).getUsername();\n+\n+        try {\n+            String[] userRoles = getUserRoles(username);\n+            int maxQueryDepth = getMaxQueryDepth(userRoles, policyDefinition);\n+            if (maxQueryDepth > 0) {\n+                MaxQueryDepthInstrumentation maxQueryDepthInstrumentation =\n+                        new MaxQueryDepthInstrumentation(maxQueryDepth);\n+                GraphQL runtime = GraphQL.newGraphQL(schema).instrumentation(maxQueryDepthInstrumentation).build();\n+\n+                try {\n+                    ExecutionResult executionResult = runtime.execute(payload);\n+                    List<GraphQLError> errors = executionResult.getErrors();\n+                    if (errors.size() > 0) {\n+                        List<String> errorList = new ArrayList<>();\n+                        for (GraphQLError error : errors) {\n+                            errorList.add(error.getMessage());\n+                        }\n+\n+                        // TODO: https://github.com/wso2/carbon-apimgt/issues/8147\n+                        ListIterator<String> iterator = errorList.listIterator();\n+                        while (iterator.hasNext()) {\n+                            if (iterator.next().contains(\"non-nullable\")) {\n+                                iterator.remove();\n+                            }\n+                        }\n+\n+                        if (errorList.size() == 0) {\n+                            if (log.isDebugEnabled()) {\n+                                log.debug(\"Maximum query depth of \" + maxQueryDepth + \" was not exceeded\");\n+                            }\n+                            return true;\n+                        }\n+\n+                        handleFailure(APISecurityConstants.GRAPHQL_QUERY_TOO_DEEP, messageContext,\n+                                APISecurityConstants.GRAPHQL_QUERY_TOO_DEEP_MESSAGE, errorList.toString());\n+                        log.error(errorList.toString());\n+                        return false;\n+                    }\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Maximum query depth of \" + maxQueryDepth + \" was not exceeded\");\n+                    }\n+                    return true;\n+                } catch (Throwable e) {\n+                    log.error(e);\n+                }\n+            } else {\n+                return true; // No depth limitation check\n+            }\n+        } catch (APISecurityException e) {\n+            log.error(e.getMessage(), e);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This method analyses the query complexity\n+     *\n+     * @param messageContext   message context of the request\n+     * @param payload          payload of the request\n+     * @param policyDefinition json object which contains the policy\n+     * @return true or false\n+     */\n+    private boolean queryComplexityAnalysis(MessageContext messageContext, String payload, JSONObject policyDefinition) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fda90e955847d20552638e1df45e7dd9cec7f53"}, "originalPosition": 226}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNTg5NTY2OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.gateway/src/main/java/org/wso2/carbon/apimgt/gateway/handlers/graphQL/GraphQLQueryAnalysisHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxMToyNjozNVrOFoFgWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxMToyNjozNVrOFoFgWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU3NzU2Mw==", "bodyText": "same here.", "url": "https://github.com/wso2/carbon-apimgt/pull/8118#discussion_r377577563", "createdAt": "2020-02-11T11:26:35Z", "author": {"login": "bhathiya"}, "path": "components/apimgt/org.wso2.carbon.apimgt.gateway/src/main/java/org/wso2/carbon/apimgt/gateway/handlers/graphQL/GraphQLQueryAnalysisHandler.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ *  Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.wso2.carbon.apimgt.gateway.handlers.graphQL;\n+\n+import graphql.ExecutionResult;\n+import graphql.GraphQL;\n+import graphql.GraphQLError;\n+import graphql.analysis.FieldComplexityCalculator;\n+import graphql.analysis.MaxQueryComplexityInstrumentation;\n+import graphql.analysis.MaxQueryDepthInstrumentation;\n+import graphql.schema.GraphQLSchema;\n+\n+import org.apache.axiom.om.OMAbstractFactory;\n+import org.apache.axiom.om.OMElement;\n+import org.apache.axiom.om.OMFactory;\n+import org.apache.axiom.om.OMNamespace;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.http.HttpStatus;\n+import org.apache.synapse.Mediator;\n+import org.apache.synapse.MessageContext;\n+import org.apache.synapse.rest.AbstractHandler;\n+import org.json.simple.JSONObject;\n+import org.json.simple.parser.JSONParser;\n+import org.json.simple.parser.ParseException;\n+import org.wso2.carbon.apimgt.gateway.handlers.Utils;\n+import org.wso2.carbon.apimgt.gateway.handlers.security.APISecurityConstants;\n+import org.wso2.carbon.apimgt.gateway.handlers.security.APISecurityException;\n+import org.wso2.carbon.apimgt.gateway.handlers.security.APISecurityUtils;\n+import org.wso2.carbon.apimgt.gateway.handlers.security.usermgt.APIKeyMgtRemoteUserClient;\n+import org.wso2.carbon.apimgt.gateway.handlers.security.usermgt.APIKeyMgtRemoteUserClientPool;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+public class GraphQLQueryAnalysisHandler extends AbstractHandler {\n+\n+    private static final Log log = LogFactory.getLog(GraphQLQueryAnalysisHandler.class);\n+    private GraphQLSchema schema = null;\n+\n+    public boolean handleRequest(MessageContext messageContext) {\n+        schema = (GraphQLSchema) messageContext.getProperty(APIConstants.GRAPHQL_SCHEMA);\n+        String payload = messageContext.getProperty(APIConstants.GRAPHQL_PAYLOAD).toString();\n+        if (!analyseQuery(messageContext, payload)) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Query was blocked by the static query analyser\");\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This method returns the user roles\n+     *\n+     * @param username username of the user\n+     * @return list of user roles\n+     */\n+    private String[] getUserRoles(String username) throws APISecurityException {\n+        String[] userRoles;\n+        APIKeyMgtRemoteUserClient client;\n+        try {\n+            APIKeyMgtRemoteUserClientPool clientPool = APIKeyMgtRemoteUserClientPool.getInstance();\n+            client = clientPool.get();\n+            userRoles = client.getUserRoles(username);\n+        } catch (Exception e) {\n+            throw new APISecurityException(APISecurityConstants.API_AUTH_GENERAL_ERROR, e.getMessage(), e);\n+        }\n+        return userRoles;\n+    }\n+\n+    /**\n+     * This method returns the maximum query depth value\n+     *\n+     * @param userRoles        list of user roles\n+     * @param policyDefinition json object which contains the policy\n+     * @return maximum query depth value if exists, or -1 to denote no depth limitation\n+     */\n+    private int getMaxQueryDepth(String[] userRoles, JSONObject policyDefinition) {\n+        Object depthObject = policyDefinition.get(APIConstants.QUERY_ANALYSIS_DEPTH);\n+        boolean depthCheckEnabled = Boolean.parseBoolean(((JSONObject) depthObject).get(\"enabled\").toString());\n+        List<Integer> allocatedDepths = new ArrayList<>();\n+        if (depthCheckEnabled) {\n+            for (String role : userRoles) {\n+                Object depth = ((JSONObject) depthObject).get(role);\n+                if (depth != null) {\n+                    allocatedDepths.add(((Long) depth).intValue());\n+                } else {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"No depth limitation value was assigned for \" + role + \" role\");\n+                    }\n+                }\n+            }\n+            if (allocatedDepths.isEmpty()) {\n+                Object defaultDepth = ((JSONObject) depthObject).get(\"default\");\n+                if (defaultDepth != null) {\n+                    return ((Long) defaultDepth).intValue();\n+                } else {\n+                    log.error(\"No default depth was allocated\");\n+                    return -1;\n+                }\n+            } else {\n+                return Collections.max(allocatedDepths);\n+            }\n+        } else {\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * This method analyses the query\n+     *\n+     * @param messageContext message context of the request\n+     * @param payload        payload of the request\n+     * @return true or false\n+     */\n+    private boolean analyseQuery(MessageContext messageContext, String payload) {\n+        JSONParser jsonParser = new JSONParser();\n+\n+        try {\n+            String graphQLAccessControlPolicy =\n+                    (String) messageContext.getProperty(APIConstants.GRAPHQL_ACCESS_CONTROL_POLICY);\n+            JSONObject policyDefinition = (JSONObject) jsonParser.parse(graphQLAccessControlPolicy);\n+            if (queryDepthAnalysis(messageContext, payload, policyDefinition) &&\n+                    queryComplexityAnalysis(messageContext, payload, policyDefinition)) {\n+                return true;\n+            } else {\n+                return false;\n+            }\n+        } catch (ParseException e) {\n+            log.error(\"Policy definition parsing failed. \" + e.getMessage(), e);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This method analyses the query depth\n+     *\n+     * @param messageContext   message context of the request\n+     * @param payload          payload of the request\n+     * @param policyDefinition json object which contains the policy\n+     * @return true or false\n+     */\n+    private boolean queryDepthAnalysis(MessageContext messageContext, String payload, JSONObject policyDefinition) {\n+        String username = APISecurityUtils.getAuthenticationContext(messageContext).getUsername();\n+\n+        try {\n+            String[] userRoles = getUserRoles(username);\n+            int maxQueryDepth = getMaxQueryDepth(userRoles, policyDefinition);\n+            if (maxQueryDepth > 0) {\n+                MaxQueryDepthInstrumentation maxQueryDepthInstrumentation =\n+                        new MaxQueryDepthInstrumentation(maxQueryDepth);\n+                GraphQL runtime = GraphQL.newGraphQL(schema).instrumentation(maxQueryDepthInstrumentation).build();\n+\n+                try {\n+                    ExecutionResult executionResult = runtime.execute(payload);\n+                    List<GraphQLError> errors = executionResult.getErrors();\n+                    if (errors.size() > 0) {\n+                        List<String> errorList = new ArrayList<>();\n+                        for (GraphQLError error : errors) {\n+                            errorList.add(error.getMessage());\n+                        }\n+\n+                        // TODO: https://github.com/wso2/carbon-apimgt/issues/8147\n+                        ListIterator<String> iterator = errorList.listIterator();\n+                        while (iterator.hasNext()) {\n+                            if (iterator.next().contains(\"non-nullable\")) {\n+                                iterator.remove();\n+                            }\n+                        }\n+\n+                        if (errorList.size() == 0) {\n+                            if (log.isDebugEnabled()) {\n+                                log.debug(\"Maximum query depth of \" + maxQueryDepth + \" was not exceeded\");\n+                            }\n+                            return true;\n+                        }\n+\n+                        handleFailure(APISecurityConstants.GRAPHQL_QUERY_TOO_DEEP, messageContext,\n+                                APISecurityConstants.GRAPHQL_QUERY_TOO_DEEP_MESSAGE, errorList.toString());\n+                        log.error(errorList.toString());\n+                        return false;\n+                    }\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Maximum query depth of \" + maxQueryDepth + \" was not exceeded\");\n+                    }\n+                    return true;\n+                } catch (Throwable e) {\n+                    log.error(e);\n+                }\n+            } else {\n+                return true; // No depth limitation check\n+            }\n+        } catch (APISecurityException e) {\n+            log.error(e.getMessage(), e);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This method analyses the query complexity\n+     *\n+     * @param messageContext   message context of the request\n+     * @param payload          payload of the request\n+     * @param policyDefinition json object which contains the policy\n+     * @return true or false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fda90e955847d20552638e1df45e7dd9cec7f53"}, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNTkwMTQwOnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.gateway/src/main/java/org/wso2/carbon/apimgt/gateway/handlers/graphQL/GraphQLQueryAnalysisHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxMToyODoyMVrOFoFjrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxMToyODoyMVrOFoFjrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU3ODQxMw==", "bodyText": "please create constants for strings like these.", "url": "https://github.com/wso2/carbon-apimgt/pull/8118#discussion_r377578413", "createdAt": "2020-02-11T11:28:21Z", "author": {"login": "bhathiya"}, "path": "components/apimgt/org.wso2.carbon.apimgt.gateway/src/main/java/org/wso2/carbon/apimgt/gateway/handlers/graphQL/GraphQLQueryAnalysisHandler.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ *  Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.wso2.carbon.apimgt.gateway.handlers.graphQL;\n+\n+import graphql.ExecutionResult;\n+import graphql.GraphQL;\n+import graphql.GraphQLError;\n+import graphql.analysis.FieldComplexityCalculator;\n+import graphql.analysis.MaxQueryComplexityInstrumentation;\n+import graphql.analysis.MaxQueryDepthInstrumentation;\n+import graphql.schema.GraphQLSchema;\n+\n+import org.apache.axiom.om.OMAbstractFactory;\n+import org.apache.axiom.om.OMElement;\n+import org.apache.axiom.om.OMFactory;\n+import org.apache.axiom.om.OMNamespace;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.http.HttpStatus;\n+import org.apache.synapse.Mediator;\n+import org.apache.synapse.MessageContext;\n+import org.apache.synapse.rest.AbstractHandler;\n+import org.json.simple.JSONObject;\n+import org.json.simple.parser.JSONParser;\n+import org.json.simple.parser.ParseException;\n+import org.wso2.carbon.apimgt.gateway.handlers.Utils;\n+import org.wso2.carbon.apimgt.gateway.handlers.security.APISecurityConstants;\n+import org.wso2.carbon.apimgt.gateway.handlers.security.APISecurityException;\n+import org.wso2.carbon.apimgt.gateway.handlers.security.APISecurityUtils;\n+import org.wso2.carbon.apimgt.gateway.handlers.security.usermgt.APIKeyMgtRemoteUserClient;\n+import org.wso2.carbon.apimgt.gateway.handlers.security.usermgt.APIKeyMgtRemoteUserClientPool;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+public class GraphQLQueryAnalysisHandler extends AbstractHandler {\n+\n+    private static final Log log = LogFactory.getLog(GraphQLQueryAnalysisHandler.class);\n+    private GraphQLSchema schema = null;\n+\n+    public boolean handleRequest(MessageContext messageContext) {\n+        schema = (GraphQLSchema) messageContext.getProperty(APIConstants.GRAPHQL_SCHEMA);\n+        String payload = messageContext.getProperty(APIConstants.GRAPHQL_PAYLOAD).toString();\n+        if (!analyseQuery(messageContext, payload)) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Query was blocked by the static query analyser\");\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This method returns the user roles\n+     *\n+     * @param username username of the user\n+     * @return list of user roles\n+     */\n+    private String[] getUserRoles(String username) throws APISecurityException {\n+        String[] userRoles;\n+        APIKeyMgtRemoteUserClient client;\n+        try {\n+            APIKeyMgtRemoteUserClientPool clientPool = APIKeyMgtRemoteUserClientPool.getInstance();\n+            client = clientPool.get();\n+            userRoles = client.getUserRoles(username);\n+        } catch (Exception e) {\n+            throw new APISecurityException(APISecurityConstants.API_AUTH_GENERAL_ERROR, e.getMessage(), e);\n+        }\n+        return userRoles;\n+    }\n+\n+    /**\n+     * This method returns the maximum query depth value\n+     *\n+     * @param userRoles        list of user roles\n+     * @param policyDefinition json object which contains the policy\n+     * @return maximum query depth value if exists, or -1 to denote no depth limitation\n+     */\n+    private int getMaxQueryDepth(String[] userRoles, JSONObject policyDefinition) {\n+        Object depthObject = policyDefinition.get(APIConstants.QUERY_ANALYSIS_DEPTH);\n+        boolean depthCheckEnabled = Boolean.parseBoolean(((JSONObject) depthObject).get(\"enabled\").toString());\n+        List<Integer> allocatedDepths = new ArrayList<>();\n+        if (depthCheckEnabled) {\n+            for (String role : userRoles) {\n+                Object depth = ((JSONObject) depthObject).get(role);\n+                if (depth != null) {\n+                    allocatedDepths.add(((Long) depth).intValue());\n+                } else {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"No depth limitation value was assigned for \" + role + \" role\");\n+                    }\n+                }\n+            }\n+            if (allocatedDepths.isEmpty()) {\n+                Object defaultDepth = ((JSONObject) depthObject).get(\"default\");\n+                if (defaultDepth != null) {\n+                    return ((Long) defaultDepth).intValue();\n+                } else {\n+                    log.error(\"No default depth was allocated\");\n+                    return -1;\n+                }\n+            } else {\n+                return Collections.max(allocatedDepths);\n+            }\n+        } else {\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * This method analyses the query\n+     *\n+     * @param messageContext message context of the request\n+     * @param payload        payload of the request\n+     * @return true or false\n+     */\n+    private boolean analyseQuery(MessageContext messageContext, String payload) {\n+        JSONParser jsonParser = new JSONParser();\n+\n+        try {\n+            String graphQLAccessControlPolicy =\n+                    (String) messageContext.getProperty(APIConstants.GRAPHQL_ACCESS_CONTROL_POLICY);\n+            JSONObject policyDefinition = (JSONObject) jsonParser.parse(graphQLAccessControlPolicy);\n+            if (queryDepthAnalysis(messageContext, payload, policyDefinition) &&\n+                    queryComplexityAnalysis(messageContext, payload, policyDefinition)) {\n+                return true;\n+            } else {\n+                return false;\n+            }\n+        } catch (ParseException e) {\n+            log.error(\"Policy definition parsing failed. \" + e.getMessage(), e);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This method analyses the query depth\n+     *\n+     * @param messageContext   message context of the request\n+     * @param payload          payload of the request\n+     * @param policyDefinition json object which contains the policy\n+     * @return true or false\n+     */\n+    private boolean queryDepthAnalysis(MessageContext messageContext, String payload, JSONObject policyDefinition) {\n+        String username = APISecurityUtils.getAuthenticationContext(messageContext).getUsername();\n+\n+        try {\n+            String[] userRoles = getUserRoles(username);\n+            int maxQueryDepth = getMaxQueryDepth(userRoles, policyDefinition);\n+            if (maxQueryDepth > 0) {\n+                MaxQueryDepthInstrumentation maxQueryDepthInstrumentation =\n+                        new MaxQueryDepthInstrumentation(maxQueryDepth);\n+                GraphQL runtime = GraphQL.newGraphQL(schema).instrumentation(maxQueryDepthInstrumentation).build();\n+\n+                try {\n+                    ExecutionResult executionResult = runtime.execute(payload);\n+                    List<GraphQLError> errors = executionResult.getErrors();\n+                    if (errors.size() > 0) {\n+                        List<String> errorList = new ArrayList<>();\n+                        for (GraphQLError error : errors) {\n+                            errorList.add(error.getMessage());\n+                        }\n+\n+                        // TODO: https://github.com/wso2/carbon-apimgt/issues/8147\n+                        ListIterator<String> iterator = errorList.listIterator();\n+                        while (iterator.hasNext()) {\n+                            if (iterator.next().contains(\"non-nullable\")) {\n+                                iterator.remove();\n+                            }\n+                        }\n+\n+                        if (errorList.size() == 0) {\n+                            if (log.isDebugEnabled()) {\n+                                log.debug(\"Maximum query depth of \" + maxQueryDepth + \" was not exceeded\");\n+                            }\n+                            return true;\n+                        }\n+\n+                        handleFailure(APISecurityConstants.GRAPHQL_QUERY_TOO_DEEP, messageContext,\n+                                APISecurityConstants.GRAPHQL_QUERY_TOO_DEEP_MESSAGE, errorList.toString());\n+                        log.error(errorList.toString());\n+                        return false;\n+                    }\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Maximum query depth of \" + maxQueryDepth + \" was not exceeded\");\n+                    }\n+                    return true;\n+                } catch (Throwable e) {\n+                    log.error(e);\n+                }\n+            } else {\n+                return true; // No depth limitation check\n+            }\n+        } catch (APISecurityException e) {\n+            log.error(e.getMessage(), e);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This method analyses the query complexity\n+     *\n+     * @param messageContext   message context of the request\n+     * @param payload          payload of the request\n+     * @param policyDefinition json object which contains the policy\n+     * @return true or false\n+     */\n+    private boolean queryComplexityAnalysis(MessageContext messageContext, String payload, JSONObject policyDefinition) {\n+        FieldComplexityCalculator fieldComplexityCalculator = new FieldComplexityCalculatorImpl(messageContext);\n+        int maxQueryComplexity = getMaxQueryComplexity(policyDefinition);\n+\n+        if (maxQueryComplexity > 0) {\n+            MaxQueryComplexityInstrumentation maxQueryComplexityInstrumentation =\n+                    new MaxQueryComplexityInstrumentation(maxQueryComplexity, fieldComplexityCalculator);\n+            GraphQL runtime = GraphQL.newGraphQL(schema).instrumentation(maxQueryComplexityInstrumentation).build();\n+\n+            try {\n+                ExecutionResult executionResult = runtime.execute(payload);\n+                List<GraphQLError> errors = executionResult.getErrors();\n+                if (errors.size() > 0) {\n+                    List<String> errorList = new ArrayList<>();\n+                    for (GraphQLError error : errors) {\n+                        errorList.add(error.getMessage());\n+                    }\n+\n+                    // TODO: https://github.com/wso2/carbon-apimgt/issues/8147\n+                    ListIterator<String> iterator = errorList.listIterator();\n+                    while (iterator.hasNext()) {\n+                        if (iterator.next().contains(\"non-nullable\")) {\n+                            iterator.remove();\n+                        }\n+                    }\n+\n+                    if (errorList.size() == 0) {\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"Maximum query complexity was not exceeded\");\n+                        }\n+                        return true;\n+                    } else {\n+                        log.error(errorList);\n+                        errorList.clear();\n+                        errorList.add(\"maximum query complexity exceeded\");\n+                    }\n+\n+                    handleFailure(APISecurityConstants.GRAPHQL_QUERY_TOO_COMPLEX, messageContext,\n+                            APISecurityConstants.GRAPHQL_QUERY_TOO_COMPLEX_MESSAGE, errorList.toString());\n+                    return false;\n+                }\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Maximum query complexity was not exceeded\");\n+                }\n+                return true;\n+            } catch (Exception e) {\n+                log.error(e.getMessage(), e);\n+            }\n+        } else {\n+            return true; // No complexity limitation check\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This method returns the maximum query complexity value\n+     *\n+     * @param policyDefinition json object which contains the policy\n+     * @return maximum query complexity value if exists, or -1 to denote no complexity limitation\n+     */\n+    private int getMaxQueryComplexity(JSONObject policyDefinition) {\n+        Object complexityObject = policyDefinition.get(APIConstants.QUERY_ANALYSIS_COMPLEXITY);\n+        boolean complexityCheckEnabled = Boolean.parseBoolean(((JSONObject) complexityObject).get(\"enabled\").toString());\n+        if (complexityCheckEnabled) {\n+            Object maxQueryComplexity = ((JSONObject) complexityObject).get(\"max_query_complexity\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fda90e955847d20552638e1df45e7dd9cec7f53"}, "originalPosition": 290}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNTkxNjU1OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxMTozMzoyNFrOFoFsow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxMTozMzoyNFrOFoFsow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU4MDcwNw==", "bodyText": "are we handling connection rollback inside this?", "url": "https://github.com/wso2/carbon-apimgt/pull/8118#discussion_r377580707", "createdAt": "2020-02-11T11:33:24Z", "author": {"login": "bhathiya"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14234,6 +14254,368 @@ public String getAuditApiId(APIIdentifier apiIdentifier) throws APIManagementExc\n         return auditUuid;\n     }\n \n+    /**\n+     * Add complexity and depth as disabled at API creation\n+     *\n+     * @param apiIdentifier APIIdentifier object to retrieve API ID\n+     * @throws APIManagementException\n+     */\n+    public void addQueryAnalysisInfo(APIIdentifier apiIdentifier) throws APIManagementException {\n+        String query = SQLConstants.ADD_INITIAL_QUERY_ANALYSIS_SQL;\n+        try (Connection conn = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = conn.prepareStatement(query)) {\n+            conn.setAutoCommit(false);\n+            int apiId = getAPIID(apiIdentifier, conn);\n+            ps.setInt(1, apiId);\n+            ps.setBoolean(2, false);\n+            ps.setBoolean(3, false);\n+            ps.setInt(4, 0);\n+            ps.executeUpdate();\n+            conn.commit();\n+        } catch (SQLException ex) {\n+            handleException(\"Error while adding query analysis info: \", ex);\n+        }\n+    }\n+\n+    /**\n+     * Update complexity details\n+     *\n+     * @param apiIdentifier         APIIdentifier object to retrieve API ID\n+     * @param graphqlComplexityInfo GraphqlComplexityDetails object\n+     * @throws APIManagementException\n+     */\n+    public void updateComplexityDetails(APIIdentifier apiIdentifier, GraphqlComplexityInfo graphqlComplexityInfo)\n+            throws APIManagementException {\n+        String checkEntry = SQLConstants.GET_COMPLEXITY_DETAILS_SQL;\n+        String addCustomComplexityDetails = SQLConstants.ADD_CUSTOM_COMPLEXITY_DETAILS_SQL;\n+        String updateCustomComplexityDetails = SQLConstants.UPDATE_CUSTOM_COMPLEXITY_DETAILS_SQL;\n+        try (Connection conn = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps1 = conn.prepareStatement(checkEntry)) {\n+            conn.setAutoCommit(false);\n+            int apiId = getAPIID(apiIdentifier, conn);\n+            ps1.setInt(1, apiId);\n+            try (ResultSet rs = ps1.executeQuery()) {\n+                if (rs.next()) {\n+                    if (rs.getInt(\"MAX_COMPLEXITY\") == 0) {\n+                        // Update query analysis table entries and add query complexity table entries\n+                        updateComplexityValues(apiIdentifier, graphqlComplexityInfo);\n+                        try (PreparedStatement ps2 = conn.prepareStatement(addCustomComplexityDetails)) {\n+                            for (CustomComplexityDetails customComplexity : graphqlComplexityInfo.getList()) {\n+                                UUID uuid = UUID.randomUUID();\n+                                String randomUUIDString = uuid.toString();\n+                                ps2.setString(1, randomUUIDString);\n+                                ps2.setInt(2, apiId);\n+                                ps2.setString(3, customComplexity.getType());\n+                                ps2.setString(4, customComplexity.getField());\n+                                ps2.setInt(5, customComplexity.getComplexityValue());\n+                                ps2.executeUpdate();\n+                            }\n+                        } catch (SQLException e) {\n+                            handleException(\"Error while adding custom complexity details: \", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fda90e955847d20552638e1df45e7dd9cec7f53"}, "originalPosition": 102}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2917, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}