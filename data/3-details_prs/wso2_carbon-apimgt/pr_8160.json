{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyMzI2NzIw", "number": 8160, "title": "Recommendation Feature additional changes", "bodyText": "Recommendation feature changes after the alpha release.\n\nAdded a new output adapter to publish recommendation events to the server.\nConfigurations changes to support both basic OAuth and OAuth2 to connect with the recommendation server.\nSupport disabling recommendation feature per tenant.", "createdAt": "2020-02-07T09:58:06Z", "url": "https://github.com/wso2/carbon-apimgt/pull/8160", "merged": true, "mergeCommit": {"oid": "b0230351cce833bbe06543679043133e6241c884"}, "closed": true, "closedAt": "2020-02-14T03:50:02Z", "author": {"login": "1akshitha"}, "timelineItems": {"totalCount": 57, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcAblACAH2gAyMzcyMzI2NzIwOjQ1OWMxMzBkNjJiYWRmM2EyMDE5ZTQ0YjhmOTg0OWYzZTNlMGZkYTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcEHQNOgFqTM1ODY5ODE5OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "459c130d62badf3a2019e44b8f9849f3e3e0fda3", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/459c130d62badf3a2019e44b8f9849f3e3e0fda3", "committedDate": "2020-02-02T17:13:56Z", "message": "New adapter to push events using oauth2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "315f14ca0d0d001c27c1f3f0cf05e9a2a78cd1da", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/315f14ca0d0d001c27c1f3f0cf05e9a2a78cd1da", "committedDate": "2020-02-02T18:09:49Z", "message": "Changes in recommendation feature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2bc88abf05d5b070b8b32ca53d3c78e899d89a1a", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/2bc88abf05d5b070b8b32ca53d3c78e899d89a1a", "committedDate": "2020-02-02T18:11:04Z", "message": "Merge remote-tracking branch 'remotes/upstream/master'"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91375e79ae0576ab78770f7cba9394c0bf5f30b6", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/91375e79ae0576ab78770f7cba9394c0bf5f30b6", "committedDate": "2020-02-04T05:34:27Z", "message": "minor changes in recommendation feature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58627bb45324f710077cb3edfc950ddb2b7e8693", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/58627bb45324f710077cb3edfc950ddb2b7e8693", "committedDate": "2020-02-05T16:19:52Z", "message": "removed accessTokenGenerator from output adapter and places inside impl package"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "013839e42900234ee6a655db46cd2278a7bac651", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/013839e42900234ee6a655db46cd2278a7bac651", "committedDate": "2020-02-05T16:20:54Z", "message": "Added license and fixed minor issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c4da27c86f25898b42fcacb988565915eb82ec6", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/0c4da27c86f25898b42fcacb988565915eb82ec6", "committedDate": "2020-02-05T16:21:47Z", "message": "Added new properties related to oauth"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9bc58aee449828cf7c2e3f78e95d8fb9fd9cd945", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/9bc58aee449828cf7c2e3f78e95d8fb9fd9cd945", "committedDate": "2020-02-05T16:34:27Z", "message": "Added basic oauth support for recommendation server"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41dd4e604269328a8a0f606e784fc04f6b0ec42b", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/41dd4e604269328a8a0f606e784fc04f6b0ec42b", "committedDate": "2020-02-05T16:35:06Z", "message": "minor bug fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22608a858b568d23d7af5a533a4bab34f7ddbec3", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/22608a858b568d23d7af5a533a4bab34f7ddbec3", "committedDate": "2020-02-07T06:26:09Z", "message": "Added support to enable feature with a tenat configuration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cefac0ab637c7778c2cae97474d409f26e6d6222", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/cefac0ab637c7778c2cae97474d409f26e6d6222", "committedDate": "2020-02-07T07:18:18Z", "message": "Updated the license text"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "08a65835ccdda55b65f6c7c0c124f2ddff1754d2", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/08a65835ccdda55b65f6c7c0c124f2ddff1754d2", "committedDate": "2020-02-07T09:06:20Z", "message": "Added tests for Extended Http output event adapter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60d6c22c5ec86ae47847be921b7c5792e068f831", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/60d6c22c5ec86ae47847be921b7c5792e068f831", "committedDate": "2020-02-07T09:48:20Z", "message": "Removed faulty exclusions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "723f1a0c55cf9cf15f1a78cf432a514c5e41a6cd", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/723f1a0c55cf9cf15f1a78cf432a514c5e41a6cd", "committedDate": "2020-02-07T09:49:22Z", "message": "Merge remote-tracking branch 'remotes/upstream/master'"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1MDQ2MDE0", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#pullrequestreview-355046014", "createdAt": "2020-02-07T09:59:21Z", "commit": {"oid": "723f1a0c55cf9cf15f1a78cf432a514c5e41a6cd"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwOTo1OToyMVrOFm37GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMDowMjoxMlrOFm4AUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMwNjQ1Nw==", "bodyText": "no wild card imports", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376306457", "createdAt": "2020-02-07T09:59:21Z", "author": {"login": "harsha89"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapterFactory.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+import org.wso2.carbon.event.output.adapter.core.*;\n+\n+import java.util.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "723f1a0c55cf9cf15f1a78cf432a514c5e41a6cd"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMwNjcyNQ==", "bodyText": "Don't catch throwables", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376306725", "createdAt": "2020-02-07T09:59:56Z", "author": {"login": "harsha89"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/internal/ds/ExtendedHTTPEventAdapterServiceDS.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ReferenceCardinality;\n+import org.osgi.service.component.annotations.ReferencePolicy;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.ExtendedHTTPEventAdapterFactory;\n+import org.wso2.carbon.apimgt.impl.recommendationmgt.AccessTokenGenerator;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterFactory;\n+\n+@Component(\n+        name = \"output.http.extended.AdapterService.component\",\n+        immediate = true)\n+public class ExtendedHTTPEventAdapterServiceDS {\n+\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapterServiceDS.class);\n+\n+    @Activate\n+    protected void activate(ComponentContext context) {\n+\n+        try {\n+            ExtendedHTTPEventAdapterFactory extendedHttpEventAdaptorFactory = new ExtendedHTTPEventAdapterFactory();\n+            BundleContext bundleContext = context.getBundleContext();\n+            bundleContext.registerService(OutputEventAdapterFactory.class.getName(),\n+                    extendedHttpEventAdaptorFactory, null);\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Successfully deployed the output recommendation event adaptor service\");\n+            }\n+        } catch (Throwable e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "723f1a0c55cf9cf15f1a78cf432a514c5e41a6cd"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMwNzM2Nw==", "bodyText": "log with a message", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376307367", "createdAt": "2020-02-07T10:01:20Z", "author": {"login": "harsha89"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIConsumerImpl.java", "diffHunk": "@@ -5758,54 +5763,96 @@ public void publishClickedAPI(ApiTypeWrapper clickedApi, String username) {\n         }\n     }\n \n-    public boolean isRecommendationEnabled() {\n-        boolean recommendationEnabled = false;\n+    /**\n+     * To check whether the API recommendation is enabled. It can be either enabled globally or tenant vice.\n+     *\n+     * @param tenantDomain Tenant domain\n+     * @return whether recommendation is enabled or not\n+     */\n+\n+    public boolean isRecommendationEnabled(String tenantDomain) {\n \n         if (recommendationEnvironment != null) {\n-            recommendationEnabled = true;\n+            if (recommendationEnvironment.isApplyForAllTenants()) {\n+                return true;\n+            } else {\n+                JSONObject apiTenantConfig = null;\n+                try {\n+                    String content = apimRegistryService\n+                            .getConfigRegistryResourceContent(tenantDomain, APIConstants.API_TENANT_CONF_LOCATION);\n+                    if (content != null) {\n+                        JSONParser parser = new JSONParser();\n+                        apiTenantConfig = (JSONObject) parser.parse(content);\n+                    }\n+                    return getTenantConfigValue(tenantDomain, apiTenantConfig,\n+                            APIConstants.API_TENANT_CONF_ENABLE_RECOMMENDATION_KEY);\n+                } catch (UserStoreException e) {\n+                    log.error(\"UserStoreException thrown when getting API tenant config from registry\", e);\n+                } catch (RegistryException e) {\n+                    log.error(\"RegistryException thrown when getting API tenant config from registry\", e);\n+                } catch (ParseException e) {\n+                    log.error(\"ParseException thrown when passing API tenant config from registry\", e);\n+                } catch (APIManagementException e) {\n+                    log.debug(e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "723f1a0c55cf9cf15f1a78cf432a514c5e41a6cd"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMwNzc5Mg==", "bodyText": "is this added to all scripts?", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376307792", "createdAt": "2020-02-07T10:02:12Z", "author": {"login": "harsha89"}, "path": "features/apimgt/org.wso2.carbon.apimgt.core.feature/src/main/resources/sql/db2.sql", "diffHunk": "@@ -2508,6 +2508,12 @@ CREATE TABLE AM_REVOKED_JWT (\n     PRIMARY KEY (UUID)\n ); /\n \n+CREATE TABLE IF NOT EXISTS AM_USER (", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "723f1a0c55cf9cf15f1a78cf432a514c5e41a6cd"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3eed836f29a7bc284cdeee5b51ce21f5b0e0984b", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/3eed836f29a7bc284cdeee5b51ce21f5b0e0984b", "committedDate": "2020-02-10T09:24:59Z", "message": "Merge remote-tracking branch 'remotes/upstream/master'\n\n# Conflicts:\n#\tcomponents/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIConstants.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5df1baeb6039d4fa1e7482bea6223cc40ec0a97c", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/5df1baeb6039d4fa1e7482bea6223cc40ec0a97c", "committedDate": "2020-02-10T09:29:00Z", "message": "Addressed the review comments and minor changes in component"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb6d09a65f0bf56b5c18ad644f2144b1e1a8d794", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/eb6d09a65f0bf56b5c18ad644f2144b1e1a8d794", "committedDate": "2020-02-10T09:29:44Z", "message": "Added new log messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d5014d906e05b1902b868fd19e6646a7bee0058", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/0d5014d906e05b1902b868fd19e6646a7bee0058", "committedDate": "2020-02-10T09:30:10Z", "message": "Added EnableRecommendation as a tenant config"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c", "committedDate": "2020-02-10T09:30:39Z", "message": "Added a new table to db scripts"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1Nzk5NTE3", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#pullrequestreview-355799517", "createdAt": "2020-02-10T09:45:32Z", "commit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo0NTozMlrOFnfhKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo0NTozMlrOFnfhKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1NTE3Ng==", "bodyText": "better to define version in root pom.", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376955176", "createdAt": "2020-02-10T09:45:32Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/pom.xml", "diffHunk": "@@ -0,0 +1,131 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+  ~ Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+  ~\n+  ~ WSO2 Inc. licenses this file to you under the Apache License,\n+  ~ Version 2.0 (the \"License\"); you may not use this file except\n+  ~ in compliance with the License.\n+  ~ You may obtain a copy of the License at\n+  ~\n+  ~     http://www.apache.org/licenses/LICENSE-2.0\n+  ~\n+  ~ Unless required by applicable law or agreed to in writing,\n+  ~ software distributed under the License is distributed on an\n+  ~ \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+  ~ KIND, either express or implied.  See the License for the\n+  ~ specific language governing permissions and limitations\n+  ~ under the License.\n+  -->\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+    <parent>\n+        <groupId>org.wso2.carbon.apimgt</groupId>\n+        <artifactId>apimgt</artifactId>\n+        <version>6.6.47-SNAPSHOT</version>\n+        <relativePath>../pom.xml</relativePath>\n+    </parent>\n+\n+    <modelVersion>4.0.0</modelVersion>\n+    <artifactId>org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth</artifactId>\n+\n+    <packaging>bundle</packaging>\n+    <name>WSO2 Carbon - Event Output Extended HTTP adapter Module</name>\n+    <description>org.wso2.carbon.event.output.adapter.http.extended.oauth provides the back-end functionality of http event adapter\n+    </description>\n+    <url>http://wso2.org</url>\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.wso2.carbon.analytics-common</groupId>\n+            <artifactId>org.wso2.carbon.event.output.adapter.core</artifactId>\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>org.testng</groupId>\n+                    <artifactId>testng</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.wso2.carbon</groupId>\n+            <artifactId>org.wso2.carbon.core</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.axis2.transport</groupId>\n+            <artifactId>axis2-transport-mail</artifactId>\n+            <version>2.0.0-wso2v42</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1Nzk5NjEx", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#pullrequestreview-355799611", "createdAt": "2020-02-10T09:45:40Z", "commit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo0NTo0MFrOFnfhcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo0NTo0MFrOFnfhcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1NTI1MA==", "bodyText": "better to define version in root pom", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376955250", "createdAt": "2020-02-10T09:45:40Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/pom.xml", "diffHunk": "@@ -0,0 +1,131 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+  ~ Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+  ~\n+  ~ WSO2 Inc. licenses this file to you under the Apache License,\n+  ~ Version 2.0 (the \"License\"); you may not use this file except\n+  ~ in compliance with the License.\n+  ~ You may obtain a copy of the License at\n+  ~\n+  ~     http://www.apache.org/licenses/LICENSE-2.0\n+  ~\n+  ~ Unless required by applicable law or agreed to in writing,\n+  ~ software distributed under the License is distributed on an\n+  ~ \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+  ~ KIND, either express or implied.  See the License for the\n+  ~ specific language governing permissions and limitations\n+  ~ under the License.\n+  -->\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+    <parent>\n+        <groupId>org.wso2.carbon.apimgt</groupId>\n+        <artifactId>apimgt</artifactId>\n+        <version>6.6.47-SNAPSHOT</version>\n+        <relativePath>../pom.xml</relativePath>\n+    </parent>\n+\n+    <modelVersion>4.0.0</modelVersion>\n+    <artifactId>org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth</artifactId>\n+\n+    <packaging>bundle</packaging>\n+    <name>WSO2 Carbon - Event Output Extended HTTP adapter Module</name>\n+    <description>org.wso2.carbon.event.output.adapter.http.extended.oauth provides the back-end functionality of http event adapter\n+    </description>\n+    <url>http://wso2.org</url>\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.wso2.carbon.analytics-common</groupId>\n+            <artifactId>org.wso2.carbon.event.output.adapter.core</artifactId>\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>org.testng</groupId>\n+                    <artifactId>testng</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.wso2.carbon</groupId>\n+            <artifactId>org.wso2.carbon.core</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.axis2.transport</groupId>\n+            <artifactId>axis2-transport-mail</artifactId>\n+            <version>2.0.0-wso2v42</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.felix</groupId>\n+            <artifactId>org.apache.felix.scr.ds-annotations</artifactId>\n+            <scope>provided</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.httpcomponents.wso2</groupId>\n+            <artifactId>httpclient</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.json.wso2</groupId>\n+            <artifactId>json</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.wso2.carbon.apimgt</groupId>\n+            <artifactId>org.wso2.carbon.apimgt.impl</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>junit</groupId>\n+            <artifactId>junit</artifactId>\n+            <version>4.11</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 76}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1ODAwMDAz", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#pullrequestreview-355800003", "createdAt": "2020-02-10T09:46:12Z", "commit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo0NjoxMlrOFnfinw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo0NjoxMlrOFnfinw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1NTU1MQ==", "bodyText": "use proper/correct import/export versions", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376955551", "createdAt": "2020-02-10T09:46:12Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/pom.xml", "diffHunk": "@@ -0,0 +1,131 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+  ~ Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+  ~\n+  ~ WSO2 Inc. licenses this file to you under the Apache License,\n+  ~ Version 2.0 (the \"License\"); you may not use this file except\n+  ~ in compliance with the License.\n+  ~ You may obtain a copy of the License at\n+  ~\n+  ~     http://www.apache.org/licenses/LICENSE-2.0\n+  ~\n+  ~ Unless required by applicable law or agreed to in writing,\n+  ~ software distributed under the License is distributed on an\n+  ~ \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+  ~ KIND, either express or implied.  See the License for the\n+  ~ specific language governing permissions and limitations\n+  ~ under the License.\n+  -->\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+    <parent>\n+        <groupId>org.wso2.carbon.apimgt</groupId>\n+        <artifactId>apimgt</artifactId>\n+        <version>6.6.47-SNAPSHOT</version>\n+        <relativePath>../pom.xml</relativePath>\n+    </parent>\n+\n+    <modelVersion>4.0.0</modelVersion>\n+    <artifactId>org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth</artifactId>\n+\n+    <packaging>bundle</packaging>\n+    <name>WSO2 Carbon - Event Output Extended HTTP adapter Module</name>\n+    <description>org.wso2.carbon.event.output.adapter.http.extended.oauth provides the back-end functionality of http event adapter\n+    </description>\n+    <url>http://wso2.org</url>\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.wso2.carbon.analytics-common</groupId>\n+            <artifactId>org.wso2.carbon.event.output.adapter.core</artifactId>\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>org.testng</groupId>\n+                    <artifactId>testng</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.wso2.carbon</groupId>\n+            <artifactId>org.wso2.carbon.core</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.axis2.transport</groupId>\n+            <artifactId>axis2-transport-mail</artifactId>\n+            <version>2.0.0-wso2v42</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.felix</groupId>\n+            <artifactId>org.apache.felix.scr.ds-annotations</artifactId>\n+            <scope>provided</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.httpcomponents.wso2</groupId>\n+            <artifactId>httpclient</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.json.wso2</groupId>\n+            <artifactId>json</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.wso2.carbon.apimgt</groupId>\n+            <artifactId>org.wso2.carbon.apimgt.impl</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>junit</groupId>\n+            <artifactId>junit</artifactId>\n+            <version>4.11</version>\n+            <scope>test</scope>\n+        </dependency>\n+    </dependencies>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.felix</groupId>\n+                <artifactId>maven-bundle-plugin</artifactId>\n+                <extensions>true</extensions>\n+                <configuration>\n+                    <instructions>\n+                        <Bundle-SymbolicName>${project.artifactId}</Bundle-SymbolicName>\n+                        <Bundle-Name>${project.artifactId}</Bundle-Name>\n+                        <Private-Package>\n+                            org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal,\n+                            org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.*\n+                        </Private-Package>\n+                        <Export-Package>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 94}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1ODAzMjUz", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#pullrequestreview-355803253", "createdAt": "2020-02-10T09:50:54Z", "commit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo1MDo1NFrOFnftSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo1MDo1NFrOFnftSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1ODI4Mg==", "bodyText": "seems 'e' is missing", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376958282", "createdAt": "2020-02-10T09:50:54Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.apache.axiom.om.util.Base64;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.httpclient.HostConfiguration;\n+import org.apache.commons.httpclient.HttpClient;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;\n+import org.apache.commons.httpclient.methods.EntityEnclosingMethod;\n+import org.apache.commons.httpclient.methods.PostMethod;\n+import org.apache.commons.httpclient.methods.PutMethod;\n+import org.apache.commons.httpclient.methods.StringRequestEntity;\n+import org.apache.http.HttpHost;\n+import org.apache.http.conn.params.ConnRoutePNames;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds.ServiceReferenceHolder;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.event.output.adapter.core.EventAdapterUtil;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapter;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterConfiguration;\n+import org.wso2.carbon.event.output.adapter.core.exception.OutputEventAdapterException;\n+import org.wso2.carbon.event.output.adapter.core.exception.TestConnectionNotSupportedException;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+\n+\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+/**\n+ * The recommendation event adapter is used to publish events to recommendation server\n+ */\n+public class ExtendedHTTPEventAdapter implements OutputEventAdapter {\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapter.class);\n+    private OutputEventAdapterConfiguration eventAdapterConfiguration;\n+    private Map<String, String> globalProperties;\n+    private static ExecutorService executorService;\n+    private String clientMethod;\n+    private int tenantId;\n+\n+    private String contentType;\n+    private static HttpConnectionManager connectionManager;\n+    private static HttpClient httpClient = null;\n+    private HostConfiguration hostConfiguration = null;\n+\n+    public ExtendedHTTPEventAdapter(OutputEventAdapterConfiguration eventAdapterConfiguration,\n+                                    Map<String, String> globalProperties) {\n+        this.eventAdapterConfiguration = eventAdapterConfiguration;\n+        this.globalProperties = globalProperties;\n+        this.clientMethod = eventAdapterConfiguration.getStaticProperties()\n+                .get(ExtendedHTTPEventAdapterConstants.ADAPTER_HTTP_CLIENT_METHOD);\n+    }\n+\n+    @Override\n+    public void init() throws OutputEventAdapterException {\n+        tenantId = PrivilegedCarbonContext.getThreadLocalCarbonContext().getTenantId();\n+\n+        //ExecutorService will be assigned  if it is null\n+        if (executorService == null) {\n+            int minThread;\n+            int maxThread;\n+            long defaultKeepAliveTime;\n+            int jobQueSize;\n+\n+            //If global properties are available those will be assigned else constant values will be assigned\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME) != null) {\n+                minThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                minThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME) != null) {\n+                maxThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                maxThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME) != null) {\n+                defaultKeepAliveTime = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME));\n+            } else {\n+                defaultKeepAliveTime = ExtendedHTTPEventAdapterConstants.DEFAULT_KEEP_ALIVE_TIME_IN_MILLIS;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME) != null) {\n+                jobQueSize = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME));\n+            } else {\n+                jobQueSize = ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE;\n+            }\n+            executorService = new ThreadPoolExecutor(minThread, maxThread, defaultKeepAliveTime, TimeUnit.MILLISECONDS,\n+                    new LinkedBlockingQueue<Runnable>(jobQueSize));\n+\n+            //configurations for the httpConnectionManager which will be shared by every http adapter\n+            int defaultMaxConnectionsPerHost;\n+            int maxTotalConnections;\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST) != null) {\n+                defaultMaxConnectionsPerHost = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST));\n+            } else {\n+                defaultMaxConnectionsPerHost = ExtendedHTTPEventAdapterConstants.DEFAULT_DEFAULT_MAX_CONNECTIONS_PER_HOST;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS) != null) {\n+                maxTotalConnections = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS));\n+            } else {\n+                maxTotalConnections = ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_TOTAL_CONNECTIONS;\n+            }\n+\n+            connectionManager = new MultiThreadedHttpConnectionManager();\n+            connectionManager.getParams().setDefaultMaxConnectionsPerHost(defaultMaxConnectionsPerHost);\n+            connectionManager.getParams().setMaxTotalConnections(maxTotalConnections);\n+        }\n+    }\n+\n+    @Override\n+    public void testConnect() throws TestConnectionNotSupportedException {\n+        throw new TestConnectionNotSupportedException(\"Test connection is not available\");\n+    }\n+\n+    @Override\n+    public void connect() {\n+        this.checkHTTPClientInit(eventAdapterConfiguration.getStaticProperties());\n+    }\n+\n+    @Override\n+    public void publish(Object message, Map<String, String> dynamicProperties) {\n+        //Load dynamic properties\n+        String url = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MESSAGE_URL);\n+        String username = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_USERNAME);\n+        String password = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PASSWORD);\n+        String oauthUrl = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_URL);\n+        String consumerKey = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_KEY);\n+        String consumerSecret = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_SECRET);\n+\n+        Map<String, String> headers = this\n+                .extractHeaders(dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_HEADERS));\n+        String payload = message.toString();\n+\n+        try {\n+            if (username != null && password != null) {\n+                executorService.submit(new HTTPSender(url, payload, username, password, headers, httpClient));\n+            } else if(oauthUrl != null && consumerKey != null && consumerSecret != null ) {\n+                String accessToken = ServiceReferenceHolder.getInstance().getAccessTokenGenerator().getAccessToken(oauthUrl,consumerKey,\n+                        consumerSecret);\n+                executorService.submit(new HTTPSender(url, payload, accessToken, headers, httpClient));\n+            }\n+        } catch (RejectedExecutionException e) {\n+            EventAdapterUtil\n+                    .logAndDrop(eventAdapterConfiguration.getName(), message, \"Job queue is full\", e, log, tenantId);\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        //not required\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        //not required\n+    }\n+\n+    @Override\n+    public boolean isPolled() {\n+        return false;\n+    }\n+\n+    private void checkHTTPClientInit(Map<String, String> staticProperties) {\n+\n+        if (this.httpClient != null) {\n+            return;\n+        }\n+\n+        synchronized (ExtendedHTTPEventAdapter.class) {\n+            if (this.httpClient != null) {\n+                return;\n+            }\n+\n+            httpClient = new HttpClient(connectionManager);\n+            String proxyHost = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_HOST);\n+            String proxyPort = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_PORT);\n+            if (proxyHost != null && proxyHost.trim().length() > 0) {\n+                try {\n+                    HttpHost host = new HttpHost(proxyHost, Integer.parseInt(proxyPort));\n+                    this.httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, host);\n+                } catch (NumberFormatException e) {\n+                    log.error(\"Invalid proxy port: \" + proxyPort + \", \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 211}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1ODAzOTY0", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#pullrequestreview-355803964", "createdAt": "2020-02-10T09:51:55Z", "commit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo1MTo1NVrOFnfvtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo1MTo1NVrOFnfvtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1ODkwMg==", "bodyText": "We can use constants for MIME types", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376958902", "createdAt": "2020-02-10T09:51:55Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.apache.axiom.om.util.Base64;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.httpclient.HostConfiguration;\n+import org.apache.commons.httpclient.HttpClient;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;\n+import org.apache.commons.httpclient.methods.EntityEnclosingMethod;\n+import org.apache.commons.httpclient.methods.PostMethod;\n+import org.apache.commons.httpclient.methods.PutMethod;\n+import org.apache.commons.httpclient.methods.StringRequestEntity;\n+import org.apache.http.HttpHost;\n+import org.apache.http.conn.params.ConnRoutePNames;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds.ServiceReferenceHolder;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.event.output.adapter.core.EventAdapterUtil;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapter;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterConfiguration;\n+import org.wso2.carbon.event.output.adapter.core.exception.OutputEventAdapterException;\n+import org.wso2.carbon.event.output.adapter.core.exception.TestConnectionNotSupportedException;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+\n+\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+/**\n+ * The recommendation event adapter is used to publish events to recommendation server\n+ */\n+public class ExtendedHTTPEventAdapter implements OutputEventAdapter {\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapter.class);\n+    private OutputEventAdapterConfiguration eventAdapterConfiguration;\n+    private Map<String, String> globalProperties;\n+    private static ExecutorService executorService;\n+    private String clientMethod;\n+    private int tenantId;\n+\n+    private String contentType;\n+    private static HttpConnectionManager connectionManager;\n+    private static HttpClient httpClient = null;\n+    private HostConfiguration hostConfiguration = null;\n+\n+    public ExtendedHTTPEventAdapter(OutputEventAdapterConfiguration eventAdapterConfiguration,\n+                                    Map<String, String> globalProperties) {\n+        this.eventAdapterConfiguration = eventAdapterConfiguration;\n+        this.globalProperties = globalProperties;\n+        this.clientMethod = eventAdapterConfiguration.getStaticProperties()\n+                .get(ExtendedHTTPEventAdapterConstants.ADAPTER_HTTP_CLIENT_METHOD);\n+    }\n+\n+    @Override\n+    public void init() throws OutputEventAdapterException {\n+        tenantId = PrivilegedCarbonContext.getThreadLocalCarbonContext().getTenantId();\n+\n+        //ExecutorService will be assigned  if it is null\n+        if (executorService == null) {\n+            int minThread;\n+            int maxThread;\n+            long defaultKeepAliveTime;\n+            int jobQueSize;\n+\n+            //If global properties are available those will be assigned else constant values will be assigned\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME) != null) {\n+                minThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                minThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME) != null) {\n+                maxThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                maxThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME) != null) {\n+                defaultKeepAliveTime = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME));\n+            } else {\n+                defaultKeepAliveTime = ExtendedHTTPEventAdapterConstants.DEFAULT_KEEP_ALIVE_TIME_IN_MILLIS;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME) != null) {\n+                jobQueSize = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME));\n+            } else {\n+                jobQueSize = ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE;\n+            }\n+            executorService = new ThreadPoolExecutor(minThread, maxThread, defaultKeepAliveTime, TimeUnit.MILLISECONDS,\n+                    new LinkedBlockingQueue<Runnable>(jobQueSize));\n+\n+            //configurations for the httpConnectionManager which will be shared by every http adapter\n+            int defaultMaxConnectionsPerHost;\n+            int maxTotalConnections;\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST) != null) {\n+                defaultMaxConnectionsPerHost = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST));\n+            } else {\n+                defaultMaxConnectionsPerHost = ExtendedHTTPEventAdapterConstants.DEFAULT_DEFAULT_MAX_CONNECTIONS_PER_HOST;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS) != null) {\n+                maxTotalConnections = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS));\n+            } else {\n+                maxTotalConnections = ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_TOTAL_CONNECTIONS;\n+            }\n+\n+            connectionManager = new MultiThreadedHttpConnectionManager();\n+            connectionManager.getParams().setDefaultMaxConnectionsPerHost(defaultMaxConnectionsPerHost);\n+            connectionManager.getParams().setMaxTotalConnections(maxTotalConnections);\n+        }\n+    }\n+\n+    @Override\n+    public void testConnect() throws TestConnectionNotSupportedException {\n+        throw new TestConnectionNotSupportedException(\"Test connection is not available\");\n+    }\n+\n+    @Override\n+    public void connect() {\n+        this.checkHTTPClientInit(eventAdapterConfiguration.getStaticProperties());\n+    }\n+\n+    @Override\n+    public void publish(Object message, Map<String, String> dynamicProperties) {\n+        //Load dynamic properties\n+        String url = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MESSAGE_URL);\n+        String username = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_USERNAME);\n+        String password = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PASSWORD);\n+        String oauthUrl = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_URL);\n+        String consumerKey = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_KEY);\n+        String consumerSecret = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_SECRET);\n+\n+        Map<String, String> headers = this\n+                .extractHeaders(dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_HEADERS));\n+        String payload = message.toString();\n+\n+        try {\n+            if (username != null && password != null) {\n+                executorService.submit(new HTTPSender(url, payload, username, password, headers, httpClient));\n+            } else if(oauthUrl != null && consumerKey != null && consumerSecret != null ) {\n+                String accessToken = ServiceReferenceHolder.getInstance().getAccessTokenGenerator().getAccessToken(oauthUrl,consumerKey,\n+                        consumerSecret);\n+                executorService.submit(new HTTPSender(url, payload, accessToken, headers, httpClient));\n+            }\n+        } catch (RejectedExecutionException e) {\n+            EventAdapterUtil\n+                    .logAndDrop(eventAdapterConfiguration.getName(), message, \"Job queue is full\", e, log, tenantId);\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        //not required\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        //not required\n+    }\n+\n+    @Override\n+    public boolean isPolled() {\n+        return false;\n+    }\n+\n+    private void checkHTTPClientInit(Map<String, String> staticProperties) {\n+\n+        if (this.httpClient != null) {\n+            return;\n+        }\n+\n+        synchronized (ExtendedHTTPEventAdapter.class) {\n+            if (this.httpClient != null) {\n+                return;\n+            }\n+\n+            httpClient = new HttpClient(connectionManager);\n+            String proxyHost = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_HOST);\n+            String proxyPort = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_PORT);\n+            if (proxyHost != null && proxyHost.trim().length() > 0) {\n+                try {\n+                    HttpHost host = new HttpHost(proxyHost, Integer.parseInt(proxyPort));\n+                    this.httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, host);\n+                } catch (NumberFormatException e) {\n+                    log.error(\"Invalid proxy port: \" + proxyPort + \", \"\n+                            + \"ignoring proxy settings for HTTP output event adaptor...\");\n+                }\n+            }\n+\n+            String messageFormat = eventAdapterConfiguration.getMessageFormat();\n+            if (messageFormat.equalsIgnoreCase(\"json\")) {\n+                contentType = \"application/json\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 218}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1ODA0NjQw", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#pullrequestreview-355804640", "createdAt": "2020-02-10T09:52:53Z", "commit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo1Mjo1M1rOFnfx7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo1Mjo1M1rOFnfx7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1OTQ3MA==", "bodyText": "We can use https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#isEmpty() here.", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376959470", "createdAt": "2020-02-10T09:52:53Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.apache.axiom.om.util.Base64;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.httpclient.HostConfiguration;\n+import org.apache.commons.httpclient.HttpClient;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;\n+import org.apache.commons.httpclient.methods.EntityEnclosingMethod;\n+import org.apache.commons.httpclient.methods.PostMethod;\n+import org.apache.commons.httpclient.methods.PutMethod;\n+import org.apache.commons.httpclient.methods.StringRequestEntity;\n+import org.apache.http.HttpHost;\n+import org.apache.http.conn.params.ConnRoutePNames;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds.ServiceReferenceHolder;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.event.output.adapter.core.EventAdapterUtil;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapter;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterConfiguration;\n+import org.wso2.carbon.event.output.adapter.core.exception.OutputEventAdapterException;\n+import org.wso2.carbon.event.output.adapter.core.exception.TestConnectionNotSupportedException;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+\n+\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+/**\n+ * The recommendation event adapter is used to publish events to recommendation server\n+ */\n+public class ExtendedHTTPEventAdapter implements OutputEventAdapter {\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapter.class);\n+    private OutputEventAdapterConfiguration eventAdapterConfiguration;\n+    private Map<String, String> globalProperties;\n+    private static ExecutorService executorService;\n+    private String clientMethod;\n+    private int tenantId;\n+\n+    private String contentType;\n+    private static HttpConnectionManager connectionManager;\n+    private static HttpClient httpClient = null;\n+    private HostConfiguration hostConfiguration = null;\n+\n+    public ExtendedHTTPEventAdapter(OutputEventAdapterConfiguration eventAdapterConfiguration,\n+                                    Map<String, String> globalProperties) {\n+        this.eventAdapterConfiguration = eventAdapterConfiguration;\n+        this.globalProperties = globalProperties;\n+        this.clientMethod = eventAdapterConfiguration.getStaticProperties()\n+                .get(ExtendedHTTPEventAdapterConstants.ADAPTER_HTTP_CLIENT_METHOD);\n+    }\n+\n+    @Override\n+    public void init() throws OutputEventAdapterException {\n+        tenantId = PrivilegedCarbonContext.getThreadLocalCarbonContext().getTenantId();\n+\n+        //ExecutorService will be assigned  if it is null\n+        if (executorService == null) {\n+            int minThread;\n+            int maxThread;\n+            long defaultKeepAliveTime;\n+            int jobQueSize;\n+\n+            //If global properties are available those will be assigned else constant values will be assigned\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME) != null) {\n+                minThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                minThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME) != null) {\n+                maxThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                maxThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME) != null) {\n+                defaultKeepAliveTime = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME));\n+            } else {\n+                defaultKeepAliveTime = ExtendedHTTPEventAdapterConstants.DEFAULT_KEEP_ALIVE_TIME_IN_MILLIS;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME) != null) {\n+                jobQueSize = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME));\n+            } else {\n+                jobQueSize = ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE;\n+            }\n+            executorService = new ThreadPoolExecutor(minThread, maxThread, defaultKeepAliveTime, TimeUnit.MILLISECONDS,\n+                    new LinkedBlockingQueue<Runnable>(jobQueSize));\n+\n+            //configurations for the httpConnectionManager which will be shared by every http adapter\n+            int defaultMaxConnectionsPerHost;\n+            int maxTotalConnections;\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST) != null) {\n+                defaultMaxConnectionsPerHost = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST));\n+            } else {\n+                defaultMaxConnectionsPerHost = ExtendedHTTPEventAdapterConstants.DEFAULT_DEFAULT_MAX_CONNECTIONS_PER_HOST;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS) != null) {\n+                maxTotalConnections = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS));\n+            } else {\n+                maxTotalConnections = ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_TOTAL_CONNECTIONS;\n+            }\n+\n+            connectionManager = new MultiThreadedHttpConnectionManager();\n+            connectionManager.getParams().setDefaultMaxConnectionsPerHost(defaultMaxConnectionsPerHost);\n+            connectionManager.getParams().setMaxTotalConnections(maxTotalConnections);\n+        }\n+    }\n+\n+    @Override\n+    public void testConnect() throws TestConnectionNotSupportedException {\n+        throw new TestConnectionNotSupportedException(\"Test connection is not available\");\n+    }\n+\n+    @Override\n+    public void connect() {\n+        this.checkHTTPClientInit(eventAdapterConfiguration.getStaticProperties());\n+    }\n+\n+    @Override\n+    public void publish(Object message, Map<String, String> dynamicProperties) {\n+        //Load dynamic properties\n+        String url = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MESSAGE_URL);\n+        String username = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_USERNAME);\n+        String password = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PASSWORD);\n+        String oauthUrl = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_URL);\n+        String consumerKey = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_KEY);\n+        String consumerSecret = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_SECRET);\n+\n+        Map<String, String> headers = this\n+                .extractHeaders(dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_HEADERS));\n+        String payload = message.toString();\n+\n+        try {\n+            if (username != null && password != null) {\n+                executorService.submit(new HTTPSender(url, payload, username, password, headers, httpClient));\n+            } else if(oauthUrl != null && consumerKey != null && consumerSecret != null ) {\n+                String accessToken = ServiceReferenceHolder.getInstance().getAccessTokenGenerator().getAccessToken(oauthUrl,consumerKey,\n+                        consumerSecret);\n+                executorService.submit(new HTTPSender(url, payload, accessToken, headers, httpClient));\n+            }\n+        } catch (RejectedExecutionException e) {\n+            EventAdapterUtil\n+                    .logAndDrop(eventAdapterConfiguration.getName(), message, \"Job queue is full\", e, log, tenantId);\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        //not required\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        //not required\n+    }\n+\n+    @Override\n+    public boolean isPolled() {\n+        return false;\n+    }\n+\n+    private void checkHTTPClientInit(Map<String, String> staticProperties) {\n+\n+        if (this.httpClient != null) {\n+            return;\n+        }\n+\n+        synchronized (ExtendedHTTPEventAdapter.class) {\n+            if (this.httpClient != null) {\n+                return;\n+            }\n+\n+            httpClient = new HttpClient(connectionManager);\n+            String proxyHost = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_HOST);\n+            String proxyPort = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_PORT);\n+            if (proxyHost != null && proxyHost.trim().length() > 0) {\n+                try {\n+                    HttpHost host = new HttpHost(proxyHost, Integer.parseInt(proxyPort));\n+                    this.httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, host);\n+                } catch (NumberFormatException e) {\n+                    log.error(\"Invalid proxy port: \" + proxyPort + \", \"\n+                            + \"ignoring proxy settings for HTTP output event adaptor...\");\n+                }\n+            }\n+\n+            String messageFormat = eventAdapterConfiguration.getMessageFormat();\n+            if (messageFormat.equalsIgnoreCase(\"json\")) {\n+                contentType = \"application/json\";\n+            } else if (messageFormat.equalsIgnoreCase(\"text\")) {\n+                contentType = \"text/plain\";\n+            } else {\n+                contentType = \"text/xml\";\n+            }\n+\n+        }\n+\n+    }\n+\n+    private Map<String, String> extractHeaders(String headers) {\n+        if (headers == null || headers.trim().length() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 230}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1ODA1MjQ3", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#pullrequestreview-355805247", "createdAt": "2020-02-10T09:53:45Z", "commit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo1Mzo0NVrOFnfz9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo1Mzo0NVrOFnfz9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1OTk4OA==", "bodyText": "please explain reason to catch the generic exception.", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376959988", "createdAt": "2020-02-10T09:53:45Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.apache.axiom.om.util.Base64;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.httpclient.HostConfiguration;\n+import org.apache.commons.httpclient.HttpClient;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;\n+import org.apache.commons.httpclient.methods.EntityEnclosingMethod;\n+import org.apache.commons.httpclient.methods.PostMethod;\n+import org.apache.commons.httpclient.methods.PutMethod;\n+import org.apache.commons.httpclient.methods.StringRequestEntity;\n+import org.apache.http.HttpHost;\n+import org.apache.http.conn.params.ConnRoutePNames;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds.ServiceReferenceHolder;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.event.output.adapter.core.EventAdapterUtil;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapter;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterConfiguration;\n+import org.wso2.carbon.event.output.adapter.core.exception.OutputEventAdapterException;\n+import org.wso2.carbon.event.output.adapter.core.exception.TestConnectionNotSupportedException;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+\n+\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+/**\n+ * The recommendation event adapter is used to publish events to recommendation server\n+ */\n+public class ExtendedHTTPEventAdapter implements OutputEventAdapter {\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapter.class);\n+    private OutputEventAdapterConfiguration eventAdapterConfiguration;\n+    private Map<String, String> globalProperties;\n+    private static ExecutorService executorService;\n+    private String clientMethod;\n+    private int tenantId;\n+\n+    private String contentType;\n+    private static HttpConnectionManager connectionManager;\n+    private static HttpClient httpClient = null;\n+    private HostConfiguration hostConfiguration = null;\n+\n+    public ExtendedHTTPEventAdapter(OutputEventAdapterConfiguration eventAdapterConfiguration,\n+                                    Map<String, String> globalProperties) {\n+        this.eventAdapterConfiguration = eventAdapterConfiguration;\n+        this.globalProperties = globalProperties;\n+        this.clientMethod = eventAdapterConfiguration.getStaticProperties()\n+                .get(ExtendedHTTPEventAdapterConstants.ADAPTER_HTTP_CLIENT_METHOD);\n+    }\n+\n+    @Override\n+    public void init() throws OutputEventAdapterException {\n+        tenantId = PrivilegedCarbonContext.getThreadLocalCarbonContext().getTenantId();\n+\n+        //ExecutorService will be assigned  if it is null\n+        if (executorService == null) {\n+            int minThread;\n+            int maxThread;\n+            long defaultKeepAliveTime;\n+            int jobQueSize;\n+\n+            //If global properties are available those will be assigned else constant values will be assigned\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME) != null) {\n+                minThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                minThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME) != null) {\n+                maxThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                maxThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME) != null) {\n+                defaultKeepAliveTime = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME));\n+            } else {\n+                defaultKeepAliveTime = ExtendedHTTPEventAdapterConstants.DEFAULT_KEEP_ALIVE_TIME_IN_MILLIS;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME) != null) {\n+                jobQueSize = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME));\n+            } else {\n+                jobQueSize = ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE;\n+            }\n+            executorService = new ThreadPoolExecutor(minThread, maxThread, defaultKeepAliveTime, TimeUnit.MILLISECONDS,\n+                    new LinkedBlockingQueue<Runnable>(jobQueSize));\n+\n+            //configurations for the httpConnectionManager which will be shared by every http adapter\n+            int defaultMaxConnectionsPerHost;\n+            int maxTotalConnections;\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST) != null) {\n+                defaultMaxConnectionsPerHost = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST));\n+            } else {\n+                defaultMaxConnectionsPerHost = ExtendedHTTPEventAdapterConstants.DEFAULT_DEFAULT_MAX_CONNECTIONS_PER_HOST;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS) != null) {\n+                maxTotalConnections = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS));\n+            } else {\n+                maxTotalConnections = ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_TOTAL_CONNECTIONS;\n+            }\n+\n+            connectionManager = new MultiThreadedHttpConnectionManager();\n+            connectionManager.getParams().setDefaultMaxConnectionsPerHost(defaultMaxConnectionsPerHost);\n+            connectionManager.getParams().setMaxTotalConnections(maxTotalConnections);\n+        }\n+    }\n+\n+    @Override\n+    public void testConnect() throws TestConnectionNotSupportedException {\n+        throw new TestConnectionNotSupportedException(\"Test connection is not available\");\n+    }\n+\n+    @Override\n+    public void connect() {\n+        this.checkHTTPClientInit(eventAdapterConfiguration.getStaticProperties());\n+    }\n+\n+    @Override\n+    public void publish(Object message, Map<String, String> dynamicProperties) {\n+        //Load dynamic properties\n+        String url = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MESSAGE_URL);\n+        String username = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_USERNAME);\n+        String password = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PASSWORD);\n+        String oauthUrl = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_URL);\n+        String consumerKey = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_KEY);\n+        String consumerSecret = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_SECRET);\n+\n+        Map<String, String> headers = this\n+                .extractHeaders(dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_HEADERS));\n+        String payload = message.toString();\n+\n+        try {\n+            if (username != null && password != null) {\n+                executorService.submit(new HTTPSender(url, payload, username, password, headers, httpClient));\n+            } else if(oauthUrl != null && consumerKey != null && consumerSecret != null ) {\n+                String accessToken = ServiceReferenceHolder.getInstance().getAccessTokenGenerator().getAccessToken(oauthUrl,consumerKey,\n+                        consumerSecret);\n+                executorService.submit(new HTTPSender(url, payload, accessToken, headers, httpClient));\n+            }\n+        } catch (RejectedExecutionException e) {\n+            EventAdapterUtil\n+                    .logAndDrop(eventAdapterConfiguration.getName(), message, \"Job queue is full\", e, log, tenantId);\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        //not required\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        //not required\n+    }\n+\n+    @Override\n+    public boolean isPolled() {\n+        return false;\n+    }\n+\n+    private void checkHTTPClientInit(Map<String, String> staticProperties) {\n+\n+        if (this.httpClient != null) {\n+            return;\n+        }\n+\n+        synchronized (ExtendedHTTPEventAdapter.class) {\n+            if (this.httpClient != null) {\n+                return;\n+            }\n+\n+            httpClient = new HttpClient(connectionManager);\n+            String proxyHost = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_HOST);\n+            String proxyPort = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_PORT);\n+            if (proxyHost != null && proxyHost.trim().length() > 0) {\n+                try {\n+                    HttpHost host = new HttpHost(proxyHost, Integer.parseInt(proxyPort));\n+                    this.httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, host);\n+                } catch (NumberFormatException e) {\n+                    log.error(\"Invalid proxy port: \" + proxyPort + \", \"\n+                            + \"ignoring proxy settings for HTTP output event adaptor...\");\n+                }\n+            }\n+\n+            String messageFormat = eventAdapterConfiguration.getMessageFormat();\n+            if (messageFormat.equalsIgnoreCase(\"json\")) {\n+                contentType = \"application/json\";\n+            } else if (messageFormat.equalsIgnoreCase(\"text\")) {\n+                contentType = \"text/plain\";\n+            } else {\n+                contentType = \"text/xml\";\n+            }\n+\n+        }\n+\n+    }\n+\n+    private Map<String, String> extractHeaders(String headers) {\n+        if (headers == null || headers.trim().length() == 0) {\n+            return null;\n+        }\n+\n+        String[] entries = headers.split(ExtendedHTTPEventAdapterConstants.HEADER_SEPARATOR);\n+        String[] keyValue;\n+        Map<String, String> result = new HashMap<String, String>();\n+        for (String header : entries) {\n+            try {\n+                keyValue = header.split(ExtendedHTTPEventAdapterConstants.ENTRY_SEPARATOR, 2);\n+                result.put(keyValue[0].trim(), keyValue[1].trim());\n+            } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 241}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1ODA5MjY5", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#pullrequestreview-355809269", "createdAt": "2020-02-10T09:59:37Z", "commit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo1OTozN1rOFngA5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo1OTozN1rOFngA5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2MzMwMw==", "bodyText": "We can use isBlank() or isEmpty() frunction in https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/StringUtils.html", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376963303", "createdAt": "2020-02-10T09:59:37Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.apache.axiom.om.util.Base64;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.httpclient.HostConfiguration;\n+import org.apache.commons.httpclient.HttpClient;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;\n+import org.apache.commons.httpclient.methods.EntityEnclosingMethod;\n+import org.apache.commons.httpclient.methods.PostMethod;\n+import org.apache.commons.httpclient.methods.PutMethod;\n+import org.apache.commons.httpclient.methods.StringRequestEntity;\n+import org.apache.http.HttpHost;\n+import org.apache.http.conn.params.ConnRoutePNames;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds.ServiceReferenceHolder;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.event.output.adapter.core.EventAdapterUtil;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapter;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterConfiguration;\n+import org.wso2.carbon.event.output.adapter.core.exception.OutputEventAdapterException;\n+import org.wso2.carbon.event.output.adapter.core.exception.TestConnectionNotSupportedException;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+\n+\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+/**\n+ * The recommendation event adapter is used to publish events to recommendation server\n+ */\n+public class ExtendedHTTPEventAdapter implements OutputEventAdapter {\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapter.class);\n+    private OutputEventAdapterConfiguration eventAdapterConfiguration;\n+    private Map<String, String> globalProperties;\n+    private static ExecutorService executorService;\n+    private String clientMethod;\n+    private int tenantId;\n+\n+    private String contentType;\n+    private static HttpConnectionManager connectionManager;\n+    private static HttpClient httpClient = null;\n+    private HostConfiguration hostConfiguration = null;\n+\n+    public ExtendedHTTPEventAdapter(OutputEventAdapterConfiguration eventAdapterConfiguration,\n+                                    Map<String, String> globalProperties) {\n+        this.eventAdapterConfiguration = eventAdapterConfiguration;\n+        this.globalProperties = globalProperties;\n+        this.clientMethod = eventAdapterConfiguration.getStaticProperties()\n+                .get(ExtendedHTTPEventAdapterConstants.ADAPTER_HTTP_CLIENT_METHOD);\n+    }\n+\n+    @Override\n+    public void init() throws OutputEventAdapterException {\n+        tenantId = PrivilegedCarbonContext.getThreadLocalCarbonContext().getTenantId();\n+\n+        //ExecutorService will be assigned  if it is null\n+        if (executorService == null) {\n+            int minThread;\n+            int maxThread;\n+            long defaultKeepAliveTime;\n+            int jobQueSize;\n+\n+            //If global properties are available those will be assigned else constant values will be assigned\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME) != null) {\n+                minThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                minThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME) != null) {\n+                maxThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                maxThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME) != null) {\n+                defaultKeepAliveTime = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME));\n+            } else {\n+                defaultKeepAliveTime = ExtendedHTTPEventAdapterConstants.DEFAULT_KEEP_ALIVE_TIME_IN_MILLIS;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME) != null) {\n+                jobQueSize = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME));\n+            } else {\n+                jobQueSize = ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE;\n+            }\n+            executorService = new ThreadPoolExecutor(minThread, maxThread, defaultKeepAliveTime, TimeUnit.MILLISECONDS,\n+                    new LinkedBlockingQueue<Runnable>(jobQueSize));\n+\n+            //configurations for the httpConnectionManager which will be shared by every http adapter\n+            int defaultMaxConnectionsPerHost;\n+            int maxTotalConnections;\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST) != null) {\n+                defaultMaxConnectionsPerHost = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST));\n+            } else {\n+                defaultMaxConnectionsPerHost = ExtendedHTTPEventAdapterConstants.DEFAULT_DEFAULT_MAX_CONNECTIONS_PER_HOST;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS) != null) {\n+                maxTotalConnections = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS));\n+            } else {\n+                maxTotalConnections = ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_TOTAL_CONNECTIONS;\n+            }\n+\n+            connectionManager = new MultiThreadedHttpConnectionManager();\n+            connectionManager.getParams().setDefaultMaxConnectionsPerHost(defaultMaxConnectionsPerHost);\n+            connectionManager.getParams().setMaxTotalConnections(maxTotalConnections);\n+        }\n+    }\n+\n+    @Override\n+    public void testConnect() throws TestConnectionNotSupportedException {\n+        throw new TestConnectionNotSupportedException(\"Test connection is not available\");\n+    }\n+\n+    @Override\n+    public void connect() {\n+        this.checkHTTPClientInit(eventAdapterConfiguration.getStaticProperties());\n+    }\n+\n+    @Override\n+    public void publish(Object message, Map<String, String> dynamicProperties) {\n+        //Load dynamic properties\n+        String url = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MESSAGE_URL);\n+        String username = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_USERNAME);\n+        String password = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PASSWORD);\n+        String oauthUrl = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_URL);\n+        String consumerKey = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_KEY);\n+        String consumerSecret = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_SECRET);\n+\n+        Map<String, String> headers = this\n+                .extractHeaders(dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_HEADERS));\n+        String payload = message.toString();\n+\n+        try {\n+            if (username != null && password != null) {\n+                executorService.submit(new HTTPSender(url, payload, username, password, headers, httpClient));\n+            } else if(oauthUrl != null && consumerKey != null && consumerSecret != null ) {\n+                String accessToken = ServiceReferenceHolder.getInstance().getAccessTokenGenerator().getAccessToken(oauthUrl,consumerKey,\n+                        consumerSecret);\n+                executorService.submit(new HTTPSender(url, payload, accessToken, headers, httpClient));\n+            }\n+        } catch (RejectedExecutionException e) {\n+            EventAdapterUtil\n+                    .logAndDrop(eventAdapterConfiguration.getName(), message, \"Job queue is full\", e, log, tenantId);\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        //not required\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        //not required\n+    }\n+\n+    @Override\n+    public boolean isPolled() {\n+        return false;\n+    }\n+\n+    private void checkHTTPClientInit(Map<String, String> staticProperties) {\n+\n+        if (this.httpClient != null) {\n+            return;\n+        }\n+\n+        synchronized (ExtendedHTTPEventAdapter.class) {\n+            if (this.httpClient != null) {\n+                return;\n+            }\n+\n+            httpClient = new HttpClient(connectionManager);\n+            String proxyHost = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_HOST);\n+            String proxyPort = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_PORT);\n+            if (proxyHost != null && proxyHost.trim().length() > 0) {\n+                try {\n+                    HttpHost host = new HttpHost(proxyHost, Integer.parseInt(proxyPort));\n+                    this.httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, host);\n+                } catch (NumberFormatException e) {\n+                    log.error(\"Invalid proxy port: \" + proxyPort + \", \"\n+                            + \"ignoring proxy settings for HTTP output event adaptor...\");\n+                }\n+            }\n+\n+            String messageFormat = eventAdapterConfiguration.getMessageFormat();\n+            if (messageFormat.equalsIgnoreCase(\"json\")) {\n+                contentType = \"application/json\";\n+            } else if (messageFormat.equalsIgnoreCase(\"text\")) {\n+                contentType = \"text/plain\";\n+            } else {\n+                contentType = \"text/xml\";\n+            }\n+\n+        }\n+\n+    }\n+\n+    private Map<String, String> extractHeaders(String headers) {\n+        if (headers == null || headers.trim().length() == 0) {\n+            return null;\n+        }\n+\n+        String[] entries = headers.split(ExtendedHTTPEventAdapterConstants.HEADER_SEPARATOR);\n+        String[] keyValue;\n+        Map<String, String> result = new HashMap<String, String>();\n+        for (String header : entries) {\n+            try {\n+                keyValue = header.split(ExtendedHTTPEventAdapterConstants.ENTRY_SEPARATOR, 2);\n+                result.put(keyValue[0].trim(), keyValue[1].trim());\n+            } catch (Exception e) {\n+                log.warn(\"Header property '\" + header + \"' is not defined in the correct format.\", e);\n+            }\n+        }\n+        return result;\n+\n+    }\n+\n+    /**\n+     * This class represents a job to send an HTTP request to a target URL.\n+     */\n+    class HTTPSender implements Runnable {\n+\n+        private String url;\n+\n+        private String payload;\n+\n+        private String accessToken;\n+\n+        private String userName;\n+\n+        private String password;\n+\n+        private Map<String, String> headers;\n+\n+        private HttpClient httpClient;\n+\n+        public HTTPSender(String url, String payload, String accessToken, Map<String, String> headers,\n+                          HttpClient httpClient) {\n+            this.url = url;\n+            this.payload = payload;\n+            this.accessToken = accessToken;\n+            this.headers = headers;\n+            this.httpClient = httpClient;\n+        }\n+\n+        /**\n+         * If user name and password is given, basic auth is used. If not OAuth2 is used.\n+         */\n+        public HTTPSender(String url, String payload, String userName, String password, Map<String, String> headers,\n+                          HttpClient httpClient) {\n+            this.url = url;\n+            this.payload = payload;\n+            this.userName = userName;\n+            this.password = password;\n+            this.headers = headers;\n+            this.httpClient = httpClient;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getPayload() {\n+            return payload;\n+        }\n+\n+        public String getAccessToken() {\n+            return accessToken;\n+        }\n+\n+        public Map<String, String> getHeaders() {\n+            return headers;\n+        }\n+\n+        public HttpClient getHttpClient() {\n+            return httpClient;\n+        }\n+\n+        public String getUserName() {\n+            return userName;\n+        }\n+\n+        public String getPassword() {\n+            return password;\n+        }\n+\n+        public void run() {\n+\n+            EntityEnclosingMethod method = null;\n+\n+            try {\n+                if (clientMethod.equalsIgnoreCase(ExtendedHTTPEventAdapterConstants.CONSTANT_HTTP_PUT)) {\n+                    method = new PutMethod(this.getUrl());\n+                } else {\n+                    method = new PostMethod(this.getUrl());\n+                }\n+\n+                if (hostConfiguration == null) {\n+                    URL hostUrl = new URL(this.getUrl());\n+                    hostConfiguration = new HostConfiguration();\n+                    hostConfiguration.setHost(hostUrl.getHost(), hostUrl.getPort(), hostUrl.getProtocol());\n+                }\n+\n+                method.setRequestEntity(new StringRequestEntity(this.getPayload(), contentType, \"UTF-8\"));\n+\n+                if (this.getAccessToken() != null && this.getAccessToken().trim().length() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 337}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1ODA5NjU2", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#pullrequestreview-355809656", "createdAt": "2020-02-10T10:00:12Z", "commit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxMDowMDoxMlrOFngCGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxMDowMDoxMlrOFngCGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2MzYwOA==", "bodyText": "please use constants for security schemes.", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376963608", "createdAt": "2020-02-10T10:00:12Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.apache.axiom.om.util.Base64;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.httpclient.HostConfiguration;\n+import org.apache.commons.httpclient.HttpClient;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;\n+import org.apache.commons.httpclient.methods.EntityEnclosingMethod;\n+import org.apache.commons.httpclient.methods.PostMethod;\n+import org.apache.commons.httpclient.methods.PutMethod;\n+import org.apache.commons.httpclient.methods.StringRequestEntity;\n+import org.apache.http.HttpHost;\n+import org.apache.http.conn.params.ConnRoutePNames;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds.ServiceReferenceHolder;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.event.output.adapter.core.EventAdapterUtil;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapter;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterConfiguration;\n+import org.wso2.carbon.event.output.adapter.core.exception.OutputEventAdapterException;\n+import org.wso2.carbon.event.output.adapter.core.exception.TestConnectionNotSupportedException;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+\n+\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+/**\n+ * The recommendation event adapter is used to publish events to recommendation server\n+ */\n+public class ExtendedHTTPEventAdapter implements OutputEventAdapter {\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapter.class);\n+    private OutputEventAdapterConfiguration eventAdapterConfiguration;\n+    private Map<String, String> globalProperties;\n+    private static ExecutorService executorService;\n+    private String clientMethod;\n+    private int tenantId;\n+\n+    private String contentType;\n+    private static HttpConnectionManager connectionManager;\n+    private static HttpClient httpClient = null;\n+    private HostConfiguration hostConfiguration = null;\n+\n+    public ExtendedHTTPEventAdapter(OutputEventAdapterConfiguration eventAdapterConfiguration,\n+                                    Map<String, String> globalProperties) {\n+        this.eventAdapterConfiguration = eventAdapterConfiguration;\n+        this.globalProperties = globalProperties;\n+        this.clientMethod = eventAdapterConfiguration.getStaticProperties()\n+                .get(ExtendedHTTPEventAdapterConstants.ADAPTER_HTTP_CLIENT_METHOD);\n+    }\n+\n+    @Override\n+    public void init() throws OutputEventAdapterException {\n+        tenantId = PrivilegedCarbonContext.getThreadLocalCarbonContext().getTenantId();\n+\n+        //ExecutorService will be assigned  if it is null\n+        if (executorService == null) {\n+            int minThread;\n+            int maxThread;\n+            long defaultKeepAliveTime;\n+            int jobQueSize;\n+\n+            //If global properties are available those will be assigned else constant values will be assigned\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME) != null) {\n+                minThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                minThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME) != null) {\n+                maxThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                maxThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME) != null) {\n+                defaultKeepAliveTime = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME));\n+            } else {\n+                defaultKeepAliveTime = ExtendedHTTPEventAdapterConstants.DEFAULT_KEEP_ALIVE_TIME_IN_MILLIS;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME) != null) {\n+                jobQueSize = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME));\n+            } else {\n+                jobQueSize = ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE;\n+            }\n+            executorService = new ThreadPoolExecutor(minThread, maxThread, defaultKeepAliveTime, TimeUnit.MILLISECONDS,\n+                    new LinkedBlockingQueue<Runnable>(jobQueSize));\n+\n+            //configurations for the httpConnectionManager which will be shared by every http adapter\n+            int defaultMaxConnectionsPerHost;\n+            int maxTotalConnections;\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST) != null) {\n+                defaultMaxConnectionsPerHost = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST));\n+            } else {\n+                defaultMaxConnectionsPerHost = ExtendedHTTPEventAdapterConstants.DEFAULT_DEFAULT_MAX_CONNECTIONS_PER_HOST;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS) != null) {\n+                maxTotalConnections = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS));\n+            } else {\n+                maxTotalConnections = ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_TOTAL_CONNECTIONS;\n+            }\n+\n+            connectionManager = new MultiThreadedHttpConnectionManager();\n+            connectionManager.getParams().setDefaultMaxConnectionsPerHost(defaultMaxConnectionsPerHost);\n+            connectionManager.getParams().setMaxTotalConnections(maxTotalConnections);\n+        }\n+    }\n+\n+    @Override\n+    public void testConnect() throws TestConnectionNotSupportedException {\n+        throw new TestConnectionNotSupportedException(\"Test connection is not available\");\n+    }\n+\n+    @Override\n+    public void connect() {\n+        this.checkHTTPClientInit(eventAdapterConfiguration.getStaticProperties());\n+    }\n+\n+    @Override\n+    public void publish(Object message, Map<String, String> dynamicProperties) {\n+        //Load dynamic properties\n+        String url = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MESSAGE_URL);\n+        String username = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_USERNAME);\n+        String password = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PASSWORD);\n+        String oauthUrl = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_URL);\n+        String consumerKey = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_KEY);\n+        String consumerSecret = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_SECRET);\n+\n+        Map<String, String> headers = this\n+                .extractHeaders(dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_HEADERS));\n+        String payload = message.toString();\n+\n+        try {\n+            if (username != null && password != null) {\n+                executorService.submit(new HTTPSender(url, payload, username, password, headers, httpClient));\n+            } else if(oauthUrl != null && consumerKey != null && consumerSecret != null ) {\n+                String accessToken = ServiceReferenceHolder.getInstance().getAccessTokenGenerator().getAccessToken(oauthUrl,consumerKey,\n+                        consumerSecret);\n+                executorService.submit(new HTTPSender(url, payload, accessToken, headers, httpClient));\n+            }\n+        } catch (RejectedExecutionException e) {\n+            EventAdapterUtil\n+                    .logAndDrop(eventAdapterConfiguration.getName(), message, \"Job queue is full\", e, log, tenantId);\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        //not required\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        //not required\n+    }\n+\n+    @Override\n+    public boolean isPolled() {\n+        return false;\n+    }\n+\n+    private void checkHTTPClientInit(Map<String, String> staticProperties) {\n+\n+        if (this.httpClient != null) {\n+            return;\n+        }\n+\n+        synchronized (ExtendedHTTPEventAdapter.class) {\n+            if (this.httpClient != null) {\n+                return;\n+            }\n+\n+            httpClient = new HttpClient(connectionManager);\n+            String proxyHost = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_HOST);\n+            String proxyPort = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_PORT);\n+            if (proxyHost != null && proxyHost.trim().length() > 0) {\n+                try {\n+                    HttpHost host = new HttpHost(proxyHost, Integer.parseInt(proxyPort));\n+                    this.httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, host);\n+                } catch (NumberFormatException e) {\n+                    log.error(\"Invalid proxy port: \" + proxyPort + \", \"\n+                            + \"ignoring proxy settings for HTTP output event adaptor...\");\n+                }\n+            }\n+\n+            String messageFormat = eventAdapterConfiguration.getMessageFormat();\n+            if (messageFormat.equalsIgnoreCase(\"json\")) {\n+                contentType = \"application/json\";\n+            } else if (messageFormat.equalsIgnoreCase(\"text\")) {\n+                contentType = \"text/plain\";\n+            } else {\n+                contentType = \"text/xml\";\n+            }\n+\n+        }\n+\n+    }\n+\n+    private Map<String, String> extractHeaders(String headers) {\n+        if (headers == null || headers.trim().length() == 0) {\n+            return null;\n+        }\n+\n+        String[] entries = headers.split(ExtendedHTTPEventAdapterConstants.HEADER_SEPARATOR);\n+        String[] keyValue;\n+        Map<String, String> result = new HashMap<String, String>();\n+        for (String header : entries) {\n+            try {\n+                keyValue = header.split(ExtendedHTTPEventAdapterConstants.ENTRY_SEPARATOR, 2);\n+                result.put(keyValue[0].trim(), keyValue[1].trim());\n+            } catch (Exception e) {\n+                log.warn(\"Header property '\" + header + \"' is not defined in the correct format.\", e);\n+            }\n+        }\n+        return result;\n+\n+    }\n+\n+    /**\n+     * This class represents a job to send an HTTP request to a target URL.\n+     */\n+    class HTTPSender implements Runnable {\n+\n+        private String url;\n+\n+        private String payload;\n+\n+        private String accessToken;\n+\n+        private String userName;\n+\n+        private String password;\n+\n+        private Map<String, String> headers;\n+\n+        private HttpClient httpClient;\n+\n+        public HTTPSender(String url, String payload, String accessToken, Map<String, String> headers,\n+                          HttpClient httpClient) {\n+            this.url = url;\n+            this.payload = payload;\n+            this.accessToken = accessToken;\n+            this.headers = headers;\n+            this.httpClient = httpClient;\n+        }\n+\n+        /**\n+         * If user name and password is given, basic auth is used. If not OAuth2 is used.\n+         */\n+        public HTTPSender(String url, String payload, String userName, String password, Map<String, String> headers,\n+                          HttpClient httpClient) {\n+            this.url = url;\n+            this.payload = payload;\n+            this.userName = userName;\n+            this.password = password;\n+            this.headers = headers;\n+            this.httpClient = httpClient;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getPayload() {\n+            return payload;\n+        }\n+\n+        public String getAccessToken() {\n+            return accessToken;\n+        }\n+\n+        public Map<String, String> getHeaders() {\n+            return headers;\n+        }\n+\n+        public HttpClient getHttpClient() {\n+            return httpClient;\n+        }\n+\n+        public String getUserName() {\n+            return userName;\n+        }\n+\n+        public String getPassword() {\n+            return password;\n+        }\n+\n+        public void run() {\n+\n+            EntityEnclosingMethod method = null;\n+\n+            try {\n+                if (clientMethod.equalsIgnoreCase(ExtendedHTTPEventAdapterConstants.CONSTANT_HTTP_PUT)) {\n+                    method = new PutMethod(this.getUrl());\n+                } else {\n+                    method = new PostMethod(this.getUrl());\n+                }\n+\n+                if (hostConfiguration == null) {\n+                    URL hostUrl = new URL(this.getUrl());\n+                    hostConfiguration = new HostConfiguration();\n+                    hostConfiguration.setHost(hostUrl.getHost(), hostUrl.getPort(), hostUrl.getProtocol());\n+                }\n+\n+                method.setRequestEntity(new StringRequestEntity(this.getPayload(), contentType, \"UTF-8\"));\n+\n+                if (this.getAccessToken() != null && this.getAccessToken().trim().length() > 0) {\n+                    method.setRequestHeader(\"Authorization\", \"Bearer \" + this.getAccessToken());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 338}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1ODEwMjUw", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#pullrequestreview-355810250", "createdAt": "2020-02-10T10:01:01Z", "commit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxMDowMTowMVrOFngEGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxMDowMTowMVrOFngEGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2NDEyMw==", "bodyText": "Please mention the reason to use generic exception", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376964123", "createdAt": "2020-02-10T10:01:01Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/internal/ds/ExtendedHTTPEventAdapterServiceDS.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ReferenceCardinality;\n+import org.osgi.service.component.annotations.ReferencePolicy;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.ExtendedHTTPEventAdapterFactory;\n+import org.wso2.carbon.apimgt.impl.recommendationmgt.AccessTokenGenerator;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterFactory;\n+\n+@Component(\n+        name = \"output.http.extended.AdapterService.component\",\n+        immediate = true)\n+public class ExtendedHTTPEventAdapterServiceDS {\n+\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapterServiceDS.class);\n+\n+    @Activate\n+    protected void activate(ComponentContext context) {\n+\n+        try {\n+            ExtendedHTTPEventAdapterFactory extendedHttpEventAdaptorFactory = new ExtendedHTTPEventAdapterFactory();\n+            BundleContext bundleContext = context.getBundleContext();\n+            bundleContext.registerService(OutputEventAdapterFactory.class.getName(),\n+                    extendedHttpEventAdaptorFactory, null);\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Successfully deployed the Extended Http event adaptor service\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"Can not create the Extended Http event event adaptor service: \" + e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1ODExMDAz", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#pullrequestreview-355811003", "createdAt": "2020-02-10T10:02:07Z", "commit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxMDowMjowOFrOFngGYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxMDowMjowOFrOFngGYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2NDcwNQ==", "bodyText": "please use constants", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376964705", "createdAt": "2020-02-10T10:02:08Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIConsumerImpl.java", "diffHunk": "@@ -5758,54 +5763,92 @@ public void publishClickedAPI(ApiTypeWrapper clickedApi, String username) {\n         }\n     }\n \n-    public boolean isRecommendationEnabled() {\n-        boolean recommendationEnabled = false;\n+    /**\n+     * To check whether the API recommendation is enabled. It can be either enabled globally or tenant vice.\n+     *\n+     * @param tenantDomain Tenant domain\n+     * @return whether recommendation is enabled or not\n+     */\n+\n+    public boolean isRecommendationEnabled(String tenantDomain) {\n \n         if (recommendationEnvironment != null) {\n-            recommendationEnabled = true;\n+            if (recommendationEnvironment.isApplyForAllTenants()) {\n+                return true;\n+            } else {\n+                try {\n+                    String content = apimRegistryService\n+                            .getConfigRegistryResourceContent(tenantDomain, APIConstants.API_TENANT_CONF_LOCATION);\n+                    if (content != null) {\n+                        org.json.JSONObject apiTenantConfig = new org.json.JSONObject(content);\n+                        if (apiTenantConfig != null) {\n+                            if (apiTenantConfig.has(APIConstants.API_TENANT_CONF_ENABLE_RECOMMENDATION_KEY)) {\n+                                Object value = apiTenantConfig.get(APIConstants.API_TENANT_CONF_ENABLE_RECOMMENDATION_KEY);\n+                                return Boolean.parseBoolean(value.toString());\n+                            }\n+                        }\n+                    }\n+                } catch (UserStoreException | RegistryException e) {\n+                    log.error(\"Error occurred when getting API tenant config from registry\", e);\n+                }\n+            }\n         }\n-        return recommendationEnabled;\n+        return false;\n     }\n \n-    public String getApiRecommendations(String userName) {\n-        if (userName != null && requestedTenant != null && recommendationEnvironment != null) {\n-            String recommendationEndpointURL = recommendationEnvironment.getRecommendationEndpointURL();\n-            String adminUsername = recommendationEnvironment.getUsername();\n-            String adminPassword = recommendationEnvironment.getPassword();\n+    /**\n+     * Get recommendations for the user by connecting with the recommendation engine.\n+     *\n+     * @param userName     User's Name\n+     * @param tenantDomain tenantDomain\n+     * @return List of APIs recommended for the user\n+     */\n+    public String getApiRecommendations(String userName, String tenantDomain) {\n+\n+        if (isRecommendationEnabled(tenantDomain)) {\n+            String recommendationEndpointURL = recommendationEnvironment.getRecommendationServerURL()\n+                    + APIConstants.RECOMMENDATIONS_GET_RESOURCE;\n             try {\n+                String userID = apiMgtDAO.getUserID(userName);\n                 URL serverURL = new URL(recommendationEndpointURL);\n                 int serverPort = serverURL.getPort();\n                 String serverProtocol = serverURL.getProtocol();\n \n                 HttpGet method = new HttpGet(recommendationEndpointURL);\n                 HttpClient httpClient = APIUtil.getHttpClient(serverPort, serverProtocol);\n-\n-                byte[] credentials = org.apache.commons.codec.binary.Base64\n-                        .encodeBase64((adminUsername + \":\" + adminPassword).getBytes(StandardCharsets.UTF_8));\n-\n-                method.setHeader(\"Authorization\", \"Basic \" + new String(credentials, StandardCharsets.UTF_8));\n-                method.setHeader(\"User\", userName);\n-                method.setHeader(\"Account\", requestedTenant);\n+                if (recommendationEnvironment.getOauthURL() != null) {\n+                    String accessToken = AccessTokenGeneratorImpl.getInstance().getAccessToken(\n+                                    recommendationEnvironment.getOauthURL(),\n+                                    recommendationEnvironment.getConsumerKey(),\n+                                    recommendationEnvironment.getConsumerSecret());\n+                    method.setHeader(APIConstants.AUTHORIZATION_HEADER_DEFAULT, \"Bearer \" + accessToken);\n+                } else {\n+                    byte[] credentials = org.apache.commons.codec.binary.Base64.encodeBase64(\n+                            (recommendationEnvironment.getUserName() + \":\" + recommendationEnvironment.getPassword())\n+                                    .getBytes(StandardCharsets.UTF_8));\n+                    method.setHeader(\"Authorization\", \"Basic \" + new String(credentials, StandardCharsets.UTF_8));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 140}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1ODExOTUy", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#pullrequestreview-355811952", "createdAt": "2020-02-10T10:03:34Z", "commit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxMDowMzozNFrOFngJPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxMDowMzozNFrOFngJPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2NTQzNg==", "bodyText": "please use https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#equals(java.lang.Object) instead of ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376965436", "createdAt": "2020-02-10T10:03:34Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/recommendationmgt/AccessTokenGeneratorImpl.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.impl.recommendationmgt;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.entity.UrlEncodedFormEntity;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.message.BasicNameValuePair;\n+import org.apache.http.util.EntityUtils;\n+import org.json.JSONObject;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class AccessTokenGeneratorImpl implements AccessTokenGenerator {\n+\n+    private static final Log log = LogFactory.getLog(AccessTokenGeneratorImpl.class);\n+\n+    private static volatile AccessTokenGeneratorImpl accessTokenGenerator = null;\n+    long generatedTime = 0;\n+    long validityPeriod = 3600000;\n+    String accessToken = null;\n+    String oauthUrl = null;\n+    String consumerKey = null;\n+    String consumerSecret = null;\n+\n+    public AccessTokenGeneratorImpl() {\n+\n+    }\n+\n+    public static AccessTokenGeneratorImpl getInstance() {\n+\n+        if (accessTokenGenerator == null) {\n+            synchronized (AccessTokenGeneratorImpl.class) {\n+                if (accessTokenGenerator == null) {\n+                    accessTokenGenerator = new AccessTokenGeneratorImpl();\n+                }\n+            }\n+        }\n+        return accessTokenGenerator;\n+    }\n+\n+    @Override\n+    public String getAccessToken(String oauthUrl, String consumerKey, String consumerSecret) {\n+\n+        if (this.oauthUrl == oauthUrl && this.consumerKey == consumerKey && this.consumerSecret == consumerSecret", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1ODEyMjg2", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#pullrequestreview-355812286", "createdAt": "2020-02-10T10:04:05Z", "commit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxMDowNDowNVrOFngKOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxMDowNDowNVrOFngKOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2NTY5MQ==", "bodyText": "Move \"access_token\" to a constant", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376965691", "createdAt": "2020-02-10T10:04:05Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/recommendationmgt/AccessTokenGeneratorImpl.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.impl.recommendationmgt;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.entity.UrlEncodedFormEntity;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.message.BasicNameValuePair;\n+import org.apache.http.util.EntityUtils;\n+import org.json.JSONObject;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class AccessTokenGeneratorImpl implements AccessTokenGenerator {\n+\n+    private static final Log log = LogFactory.getLog(AccessTokenGeneratorImpl.class);\n+\n+    private static volatile AccessTokenGeneratorImpl accessTokenGenerator = null;\n+    long generatedTime = 0;\n+    long validityPeriod = 3600000;\n+    String accessToken = null;\n+    String oauthUrl = null;\n+    String consumerKey = null;\n+    String consumerSecret = null;\n+\n+    public AccessTokenGeneratorImpl() {\n+\n+    }\n+\n+    public static AccessTokenGeneratorImpl getInstance() {\n+\n+        if (accessTokenGenerator == null) {\n+            synchronized (AccessTokenGeneratorImpl.class) {\n+                if (accessTokenGenerator == null) {\n+                    accessTokenGenerator = new AccessTokenGeneratorImpl();\n+                }\n+            }\n+        }\n+        return accessTokenGenerator;\n+    }\n+\n+    @Override\n+    public String getAccessToken(String oauthUrl, String consumerKey, String consumerSecret) {\n+\n+        if (this.oauthUrl == oauthUrl && this.consumerKey == consumerKey && this.consumerSecret == consumerSecret\n+                && this.accessToken != null) {\n+            if (System.currentTimeMillis() > (this.generatedTime + this.validityPeriod)) {\n+                if(log.isDebugEnabled()) {\n+                    log.debug(\"Access token expired. New token requested\");\n+                }\n+                return generateNewAccessToken(oauthUrl, consumerKey, consumerSecret);\n+            } else {\n+                if(log.isDebugEnabled()) {\n+                    log.debug(\"Valid Access Token already available for the provided application\");\n+                }\n+                return this.accessToken;\n+            }\n+        } else {\n+            this.oauthUrl = oauthUrl;\n+            this.consumerKey = consumerKey;\n+            this.consumerSecret = consumerSecret;\n+            if(log.isDebugEnabled()) {\n+                log.debug(\"Valid Access token not found for the application. New token requested\");\n+            }\n+            return generateNewAccessToken(oauthUrl, consumerKey, consumerSecret);\n+        }\n+    }\n+\n+    public String generateNewAccessToken(String oauthUrl, String consumerKey, String consumerSecret) {\n+\n+        if(oauthUrl != null && consumerKey != null && consumerSecret != null) {\n+            try {\n+                URL oauthURL = new URL(oauthUrl);\n+                int serverPort = oauthURL.getPort();\n+                String serverProtocol = oauthURL.getProtocol();\n+\n+                HttpPost request = new HttpPost(oauthUrl);\n+                HttpClient httpClient = APIUtil.getHttpClient(serverPort, serverProtocol);\n+\n+                byte[] credentials = org.apache.commons.codec.binary.Base64\n+                        .encodeBase64((consumerKey + \":\" + consumerSecret).getBytes(StandardCharsets.UTF_8));\n+\n+                request.setHeader(\"Authorization\", \"Basic \" + new String(credentials, StandardCharsets.UTF_8));\n+                request.setHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n+\n+                List<BasicNameValuePair> urlParameters = new ArrayList<>();\n+                urlParameters.add(new BasicNameValuePair(\"grant_type\", \"client_credentials\"));\n+                request.setEntity(new UrlEncodedFormEntity(urlParameters));\n+                HttpResponse httpResponse = httpClient.execute(request);\n+\n+                if (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n+                    String payload = EntityUtils.toString(httpResponse.getEntity());\n+                    JSONObject response = new JSONObject(payload);\n+                    this.accessToken = (String) response.get(\"access_token\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 118}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35abec0172330393313c54e7dad553a8f3ac46db", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/35abec0172330393313c54e7dad553a8f3ac46db", "committedDate": "2020-02-12T05:43:20Z", "message": "Changed the module name of the http adapter and few changes after review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bbac35548057090d1ef83620c811aff2116fae11", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/bbac35548057090d1ef83620c811aff2116fae11", "committedDate": "2020-02-12T05:44:48Z", "message": "Changes after the code review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a63789776f5b5be6ba6a106aa5a9feed68b0e5f5", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/a63789776f5b5be6ba6a106aa5a9feed68b0e5f5", "committedDate": "2020-02-12T05:46:02Z", "message": "Removed the singleton methodology"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3OTQ4MjQy", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#pullrequestreview-357948242", "createdAt": "2020-02-13T04:29:50Z", "commit": {"oid": "a63789776f5b5be6ba6a106aa5a9feed68b0e5f5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwNDoyOTo1MFrOFpGteA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwNDoyOTo1MFrOFpGteA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY0NTg4MA==", "bodyText": "This isn't a service reference holder anymore right? Also, this doesn't have to be inside internal package since this isn't an osgi activator class", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378645880", "createdAt": "2020-02-13T04:29:50Z", "author": {"login": "fazlan-nazeem"}, "path": "components/apimgt/org.wso2.carbon.apimgt.output.adapter.http/src/main/java/org/wso2/carbon/apimgt/output/adapter/http/internal/ds/ServiceReferenceHolder.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.output.adapter.http.internal.ds;\n+\n+import org.wso2.carbon.apimgt.impl.recommendationmgt.AccessTokenGenerator;\n+\n+public class ServiceReferenceHolder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a63789776f5b5be6ba6a106aa5a9feed68b0e5f5"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4MTA1NjAx", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#pullrequestreview-358105601", "createdAt": "2020-02-13T10:27:43Z", "commit": {"oid": "a63789776f5b5be6ba6a106aa5a9feed68b0e5f5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ccb1b23f766b2344c53467137d718c562d4326cc", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/ccb1b23f766b2344c53467137d718c562d4326cc", "committedDate": "2020-02-13T11:56:24Z", "message": "Added a new cache for tenant-config"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61c53760a3cf5be32c86501e6f03eaf71211ff8d", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/61c53760a3cf5be32c86501e6f03eaf71211ff8d", "committedDate": "2020-02-13T11:56:51Z", "message": "Fixed minor bugs and log messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3100f53a8a1a82170c98349eda6edaec313ba57b", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/3100f53a8a1a82170c98349eda6edaec313ba57b", "committedDate": "2020-02-13T12:29:26Z", "message": "Fixed issue when returing cross tenant recommendations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e926468c9b3359dc331916fce1133b29edce1a32", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/e926468c9b3359dc331916fce1133b29edce1a32", "committedDate": "2020-02-13T12:56:07Z", "message": "Removed unused class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9ca4ec985cb0adca3b887bf665df1ef7d9d5b3f", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/d9ca4ec985cb0adca3b887bf665df1ef7d9d5b3f", "committedDate": "2020-02-13T12:58:42Z", "message": "Merge remote-tracking branch 'upstream/master'"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ace930e71474cc2869dee51146a25ccea3f2832b", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/ace930e71474cc2869dee51146a25ccea3f2832b", "committedDate": "2020-02-13T13:00:41Z", "message": "New component version fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a6d35b102f86f69df0a8d33fd329210ebca9760", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/8a6d35b102f86f69df0a8d33fd329210ebca9760", "committedDate": "2020-02-13T13:29:55Z", "message": "minor changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4MjE2Mzg5", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#pullrequestreview-358216389", "createdAt": "2020-02-13T13:32:36Z", "commit": {"oid": "8a6d35b102f86f69df0a8d33fd329210ebca9760"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ea7057baec23fc858d1487f358f4f725b266920", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/7ea7057baec23fc858d1487f358f4f725b266920", "committedDate": "2020-02-13T14:26:19Z", "message": "Addressed review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4MjgzODI1", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#pullrequestreview-358283825", "createdAt": "2020-02-13T14:58:13Z", "commit": {"oid": "7ea7057baec23fc858d1487f358f4f725b266920"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNDo1ODoxM1rOFpXANg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNDo1ODoxM1rOFpXANg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxMjgyMg==", "bodyText": "please check line legnth", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378912822", "createdAt": "2020-02-13T14:58:13Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIManagerConfiguration.java", "diffHunk": "@@ -1203,6 +1194,78 @@ private void setMonetizationAdditionalAttributes(OMElement element) {\n         }\n     }\n \n+    /**\n+     * To populate recommendation related configurations\n+     * @param element\n+     */\n+    private void setRecommendationConfigurations(OMElement element) {\n+        OMElement recommendationSeverEndpointElement = element.getFirstChildWithName(new QName(APIConstants.RECOMMENDATION_ENDPOINT));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ea7057baec23fc858d1487f358f4f725b266920"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4Mjg2NDg3", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#pullrequestreview-358286487", "createdAt": "2020-02-13T15:01:13Z", "commit": {"oid": "7ea7057baec23fc858d1487f358f4f725b266920"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNTowMToxM1rOFpXH9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNTowMToxM1rOFpXH9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxNDgwNw==", "bodyText": "looks length is exceeded.", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378914807", "createdAt": "2020-02-13T15:01:13Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/internal/APIManagerComponent.java", "diffHunk": "@@ -698,5 +706,18 @@ private void configureRecommendationEventPublisherProperties() {\n             }\n         }\n     }\n+\n+    private void setupAccessTokenGenerator(){\n+\n+        RecommendationEnvironment recommendationEnvironment =\n+                ServiceReferenceHolder.getInstance().getAPIManagerConfigurationService().getAPIManagerConfiguration().getApiRecommendationEnvironment();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ea7057baec23fc858d1487f358f4f725b266920"}, "originalPosition": 67}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4Mjg2NzI1", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#pullrequestreview-358286725", "createdAt": "2020-02-13T15:01:29Z", "commit": {"oid": "7ea7057baec23fc858d1487f358f4f725b266920"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNTowMTozMFrOFpXIug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNTowMTozMFrOFpXIug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxNTAwMg==", "bodyText": "formatting issue", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378915002", "createdAt": "2020-02-13T15:01:30Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/internal/APIManagerComponent.java", "diffHunk": "@@ -698,5 +706,18 @@ private void configureRecommendationEventPublisherProperties() {\n             }\n         }\n     }\n+\n+    private void setupAccessTokenGenerator(){\n+\n+        RecommendationEnvironment recommendationEnvironment =\n+                ServiceReferenceHolder.getInstance().getAPIManagerConfigurationService().getAPIManagerConfiguration().getApiRecommendationEnvironment();\n+        if (recommendationEnvironment != null && recommendationEnvironment.getOauthURL()!= null){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ea7057baec23fc858d1487f358f4f725b266920"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4MjkwMTkz", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#pullrequestreview-358290193", "createdAt": "2020-02-13T15:05:35Z", "commit": {"oid": "7ea7057baec23fc858d1487f358f4f725b266920"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNTowNTozNVrOFpXTEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNTowNTozNVrOFpXTEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxNzY0OQ==", "bodyText": "can we define appropriate access identifiers private or protected", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378917649", "createdAt": "2020-02-13T15:05:35Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/recommendationmgt/AccessTokenGenerator.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.impl.recommendationmgt;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.entity.UrlEncodedFormEntity;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.message.BasicNameValuePair;\n+import org.apache.http.util.EntityUtils;\n+import org.json.JSONObject;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class AccessTokenGenerator {\n+\n+    private static final Log log = LogFactory.getLog(AccessTokenGenerator.class);\n+\n+    private static volatile AccessTokenGenerator accessTokenGenerator = null;\n+    long expiryTime = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ea7057baec23fc858d1487f358f4f725b266920"}, "originalPosition": 44}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4cec104bd1cea39b67b0e03b16cf1516412c8e0b", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/4cec104bd1cea39b67b0e03b16cf1516412c8e0b", "committedDate": "2020-02-13T15:50:40Z", "message": "Version bump"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4b13b66462890868baaccac4303579604b480e5", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/f4b13b66462890868baaccac4303579604b480e5", "committedDate": "2020-02-13T15:50:54Z", "message": "Address review commits"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "521beed8ab675bc1ce8c32bbba6bacbf8be92267", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/521beed8ab675bc1ce8c32bbba6bacbf8be92267", "committedDate": "2020-02-13T17:13:34Z", "message": "Fixed incorrect tenant domain issue"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4Njg2MTMx", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#pullrequestreview-358686131", "createdAt": "2020-02-14T02:54:53Z", "commit": {"oid": "521beed8ab675bc1ce8c32bbba6bacbf8be92267"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "198ea1e7371c806b1b07f90b45dc2c26578b9755", "author": {"user": {"login": "1akshitha", "name": "Lakshitha Gunasekara"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/198ea1e7371c806b1b07f90b45dc2c26578b9755", "committedDate": "2020-02-14T03:46:06Z", "message": "only recommendations related to tenat of the user will be visible"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4Njk4MTk5", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#pullrequestreview-358698199", "createdAt": "2020-02-14T03:48:49Z", "commit": {"oid": "198ea1e7371c806b1b07f90b45dc2c26578b9755"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2983, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}