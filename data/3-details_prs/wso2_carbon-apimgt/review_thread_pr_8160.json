{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyMzI2NzIw", "number": 8160, "reviewThreads": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwOTo1OToyMVrODd-DVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNTowNTozNVrODflI5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNzUxOTU4OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapterFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwOTo1OToyMVrOFm37GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo0MTozMFrOFnfY3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMwNjQ1Nw==", "bodyText": "no wild card imports", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376306457", "createdAt": "2020-02-07T09:59:21Z", "author": {"login": "harsha89"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapterFactory.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+import org.wso2.carbon.event.output.adapter.core.*;\n+\n+import java.util.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "723f1a0c55cf9cf15f1a78cf432a514c5e41a6cd"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1MzA1Mw==", "bodyText": "Fixed", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376953053", "createdAt": "2020-02-10T09:41:30Z", "author": {"login": "1akshitha"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapterFactory.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+import org.wso2.carbon.event.output.adapter.core.*;\n+\n+import java.util.*;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMwNjQ1Nw=="}, "originalCommit": {"oid": "723f1a0c55cf9cf15f1a78cf432a514c5e41a6cd"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNzUyMTM2OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/internal/ds/ExtendedHTTPEventAdapterServiceDS.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwOTo1OTo1NlrOFm38JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo0MTozNFrOFnfZAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMwNjcyNQ==", "bodyText": "Don't catch throwables", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376306725", "createdAt": "2020-02-07T09:59:56Z", "author": {"login": "harsha89"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/internal/ds/ExtendedHTTPEventAdapterServiceDS.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ReferenceCardinality;\n+import org.osgi.service.component.annotations.ReferencePolicy;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.ExtendedHTTPEventAdapterFactory;\n+import org.wso2.carbon.apimgt.impl.recommendationmgt.AccessTokenGenerator;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterFactory;\n+\n+@Component(\n+        name = \"output.http.extended.AdapterService.component\",\n+        immediate = true)\n+public class ExtendedHTTPEventAdapterServiceDS {\n+\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapterServiceDS.class);\n+\n+    @Activate\n+    protected void activate(ComponentContext context) {\n+\n+        try {\n+            ExtendedHTTPEventAdapterFactory extendedHttpEventAdaptorFactory = new ExtendedHTTPEventAdapterFactory();\n+            BundleContext bundleContext = context.getBundleContext();\n+            bundleContext.registerService(OutputEventAdapterFactory.class.getName(),\n+                    extendedHttpEventAdaptorFactory, null);\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Successfully deployed the output recommendation event adaptor service\");\n+            }\n+        } catch (Throwable e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "723f1a0c55cf9cf15f1a78cf432a514c5e41a6cd"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1MzA4OQ==", "bodyText": "Fixed", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376953089", "createdAt": "2020-02-10T09:41:34Z", "author": {"login": "1akshitha"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/internal/ds/ExtendedHTTPEventAdapterServiceDS.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ReferenceCardinality;\n+import org.osgi.service.component.annotations.ReferencePolicy;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.ExtendedHTTPEventAdapterFactory;\n+import org.wso2.carbon.apimgt.impl.recommendationmgt.AccessTokenGenerator;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterFactory;\n+\n+@Component(\n+        name = \"output.http.extended.AdapterService.component\",\n+        immediate = true)\n+public class ExtendedHTTPEventAdapterServiceDS {\n+\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapterServiceDS.class);\n+\n+    @Activate\n+    protected void activate(ComponentContext context) {\n+\n+        try {\n+            ExtendedHTTPEventAdapterFactory extendedHttpEventAdaptorFactory = new ExtendedHTTPEventAdapterFactory();\n+            BundleContext bundleContext = context.getBundleContext();\n+            bundleContext.registerService(OutputEventAdapterFactory.class.getName(),\n+                    extendedHttpEventAdaptorFactory, null);\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Successfully deployed the output recommendation event adaptor service\");\n+            }\n+        } catch (Throwable e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMwNjcyNQ=="}, "originalCommit": {"oid": "723f1a0c55cf9cf15f1a78cf432a514c5e41a6cd"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNzUyNTM4OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIConsumerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMDowMToyMFrOFm3-pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo0MTozOFrOFnfZNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMwNzM2Nw==", "bodyText": "log with a message", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376307367", "createdAt": "2020-02-07T10:01:20Z", "author": {"login": "harsha89"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIConsumerImpl.java", "diffHunk": "@@ -5758,54 +5763,96 @@ public void publishClickedAPI(ApiTypeWrapper clickedApi, String username) {\n         }\n     }\n \n-    public boolean isRecommendationEnabled() {\n-        boolean recommendationEnabled = false;\n+    /**\n+     * To check whether the API recommendation is enabled. It can be either enabled globally or tenant vice.\n+     *\n+     * @param tenantDomain Tenant domain\n+     * @return whether recommendation is enabled or not\n+     */\n+\n+    public boolean isRecommendationEnabled(String tenantDomain) {\n \n         if (recommendationEnvironment != null) {\n-            recommendationEnabled = true;\n+            if (recommendationEnvironment.isApplyForAllTenants()) {\n+                return true;\n+            } else {\n+                JSONObject apiTenantConfig = null;\n+                try {\n+                    String content = apimRegistryService\n+                            .getConfigRegistryResourceContent(tenantDomain, APIConstants.API_TENANT_CONF_LOCATION);\n+                    if (content != null) {\n+                        JSONParser parser = new JSONParser();\n+                        apiTenantConfig = (JSONObject) parser.parse(content);\n+                    }\n+                    return getTenantConfigValue(tenantDomain, apiTenantConfig,\n+                            APIConstants.API_TENANT_CONF_ENABLE_RECOMMENDATION_KEY);\n+                } catch (UserStoreException e) {\n+                    log.error(\"UserStoreException thrown when getting API tenant config from registry\", e);\n+                } catch (RegistryException e) {\n+                    log.error(\"RegistryException thrown when getting API tenant config from registry\", e);\n+                } catch (ParseException e) {\n+                    log.error(\"ParseException thrown when passing API tenant config from registry\", e);\n+                } catch (APIManagementException e) {\n+                    log.debug(e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "723f1a0c55cf9cf15f1a78cf432a514c5e41a6cd"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1MzE0Mw==", "bodyText": "Fixed", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376953143", "createdAt": "2020-02-10T09:41:38Z", "author": {"login": "1akshitha"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIConsumerImpl.java", "diffHunk": "@@ -5758,54 +5763,96 @@ public void publishClickedAPI(ApiTypeWrapper clickedApi, String username) {\n         }\n     }\n \n-    public boolean isRecommendationEnabled() {\n-        boolean recommendationEnabled = false;\n+    /**\n+     * To check whether the API recommendation is enabled. It can be either enabled globally or tenant vice.\n+     *\n+     * @param tenantDomain Tenant domain\n+     * @return whether recommendation is enabled or not\n+     */\n+\n+    public boolean isRecommendationEnabled(String tenantDomain) {\n \n         if (recommendationEnvironment != null) {\n-            recommendationEnabled = true;\n+            if (recommendationEnvironment.isApplyForAllTenants()) {\n+                return true;\n+            } else {\n+                JSONObject apiTenantConfig = null;\n+                try {\n+                    String content = apimRegistryService\n+                            .getConfigRegistryResourceContent(tenantDomain, APIConstants.API_TENANT_CONF_LOCATION);\n+                    if (content != null) {\n+                        JSONParser parser = new JSONParser();\n+                        apiTenantConfig = (JSONObject) parser.parse(content);\n+                    }\n+                    return getTenantConfigValue(tenantDomain, apiTenantConfig,\n+                            APIConstants.API_TENANT_CONF_ENABLE_RECOMMENDATION_KEY);\n+                } catch (UserStoreException e) {\n+                    log.error(\"UserStoreException thrown when getting API tenant config from registry\", e);\n+                } catch (RegistryException e) {\n+                    log.error(\"RegistryException thrown when getting API tenant config from registry\", e);\n+                } catch (ParseException e) {\n+                    log.error(\"ParseException thrown when passing API tenant config from registry\", e);\n+                } catch (APIManagementException e) {\n+                    log.debug(e.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMwNzM2Nw=="}, "originalCommit": {"oid": "723f1a0c55cf9cf15f1a78cf432a514c5e41a6cd"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNzUyODAwOnYy", "diffSide": "RIGHT", "path": "features/apimgt/org.wso2.carbon.apimgt.core.feature/src/main/resources/sql/db2.sql", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMDowMjoxMlrOFm4AUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo0MTo0OFrOFnfZlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMwNzc5Mg==", "bodyText": "is this added to all scripts?", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376307792", "createdAt": "2020-02-07T10:02:12Z", "author": {"login": "harsha89"}, "path": "features/apimgt/org.wso2.carbon.apimgt.core.feature/src/main/resources/sql/db2.sql", "diffHunk": "@@ -2508,6 +2508,12 @@ CREATE TABLE AM_REVOKED_JWT (\n     PRIMARY KEY (UUID)\n ); /\n \n+CREATE TABLE IF NOT EXISTS AM_USER (", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "723f1a0c55cf9cf15f1a78cf432a514c5e41a6cd"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1MzIzOA==", "bodyText": "Yes. Updated all the scripts", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376953238", "createdAt": "2020-02-10T09:41:48Z", "author": {"login": "1akshitha"}, "path": "features/apimgt/org.wso2.carbon.apimgt.core.feature/src/main/resources/sql/db2.sql", "diffHunk": "@@ -2508,6 +2508,12 @@ CREATE TABLE AM_REVOKED_JWT (\n     PRIMARY KEY (UUID)\n ); /\n \n+CREATE TABLE IF NOT EXISTS AM_USER (", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMwNzc5Mg=="}, "originalCommit": {"oid": "723f1a0c55cf9cf15f1a78cf432a514c5e41a6cd"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMTg5NzY1OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo0NTozMlrOFnfhKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxMzozNjo1N1rOFpT8lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1NTE3Ng==", "bodyText": "better to define version in root pom.", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376955176", "createdAt": "2020-02-10T09:45:32Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/pom.xml", "diffHunk": "@@ -0,0 +1,131 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+  ~ Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+  ~\n+  ~ WSO2 Inc. licenses this file to you under the Apache License,\n+  ~ Version 2.0 (the \"License\"); you may not use this file except\n+  ~ in compliance with the License.\n+  ~ You may obtain a copy of the License at\n+  ~\n+  ~     http://www.apache.org/licenses/LICENSE-2.0\n+  ~\n+  ~ Unless required by applicable law or agreed to in writing,\n+  ~ software distributed under the License is distributed on an\n+  ~ \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+  ~ KIND, either express or implied.  See the License for the\n+  ~ specific language governing permissions and limitations\n+  ~ under the License.\n+  -->\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+    <parent>\n+        <groupId>org.wso2.carbon.apimgt</groupId>\n+        <artifactId>apimgt</artifactId>\n+        <version>6.6.47-SNAPSHOT</version>\n+        <relativePath>../pom.xml</relativePath>\n+    </parent>\n+\n+    <modelVersion>4.0.0</modelVersion>\n+    <artifactId>org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth</artifactId>\n+\n+    <packaging>bundle</packaging>\n+    <name>WSO2 Carbon - Event Output Extended HTTP adapter Module</name>\n+    <description>org.wso2.carbon.event.output.adapter.http.extended.oauth provides the back-end functionality of http event adapter\n+    </description>\n+    <url>http://wso2.org</url>\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.wso2.carbon.analytics-common</groupId>\n+            <artifactId>org.wso2.carbon.event.output.adapter.core</artifactId>\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>org.testng</groupId>\n+                    <artifactId>testng</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.wso2.carbon</groupId>\n+            <artifactId>org.wso2.carbon.core</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.axis2.transport</groupId>\n+            <artifactId>axis2-transport-mail</artifactId>\n+            <version>2.0.0-wso2v42</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg2Mjc0MQ==", "bodyText": "Fixed", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378862741", "createdAt": "2020-02-13T13:36:57Z", "author": {"login": "1akshitha"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/pom.xml", "diffHunk": "@@ -0,0 +1,131 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+  ~ Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+  ~\n+  ~ WSO2 Inc. licenses this file to you under the Apache License,\n+  ~ Version 2.0 (the \"License\"); you may not use this file except\n+  ~ in compliance with the License.\n+  ~ You may obtain a copy of the License at\n+  ~\n+  ~     http://www.apache.org/licenses/LICENSE-2.0\n+  ~\n+  ~ Unless required by applicable law or agreed to in writing,\n+  ~ software distributed under the License is distributed on an\n+  ~ \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+  ~ KIND, either express or implied.  See the License for the\n+  ~ specific language governing permissions and limitations\n+  ~ under the License.\n+  -->\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+    <parent>\n+        <groupId>org.wso2.carbon.apimgt</groupId>\n+        <artifactId>apimgt</artifactId>\n+        <version>6.6.47-SNAPSHOT</version>\n+        <relativePath>../pom.xml</relativePath>\n+    </parent>\n+\n+    <modelVersion>4.0.0</modelVersion>\n+    <artifactId>org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth</artifactId>\n+\n+    <packaging>bundle</packaging>\n+    <name>WSO2 Carbon - Event Output Extended HTTP adapter Module</name>\n+    <description>org.wso2.carbon.event.output.adapter.http.extended.oauth provides the back-end functionality of http event adapter\n+    </description>\n+    <url>http://wso2.org</url>\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.wso2.carbon.analytics-common</groupId>\n+            <artifactId>org.wso2.carbon.event.output.adapter.core</artifactId>\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>org.testng</groupId>\n+                    <artifactId>testng</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.wso2.carbon</groupId>\n+            <artifactId>org.wso2.carbon.core</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.axis2.transport</groupId>\n+            <artifactId>axis2-transport-mail</artifactId>\n+            <version>2.0.0-wso2v42</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1NTE3Ng=="}, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMTg5ODEzOnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo0NTo0MFrOFnfhcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxMzozNzowMlrOFpT8uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1NTI1MA==", "bodyText": "better to define version in root pom", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376955250", "createdAt": "2020-02-10T09:45:40Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/pom.xml", "diffHunk": "@@ -0,0 +1,131 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+  ~ Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+  ~\n+  ~ WSO2 Inc. licenses this file to you under the Apache License,\n+  ~ Version 2.0 (the \"License\"); you may not use this file except\n+  ~ in compliance with the License.\n+  ~ You may obtain a copy of the License at\n+  ~\n+  ~     http://www.apache.org/licenses/LICENSE-2.0\n+  ~\n+  ~ Unless required by applicable law or agreed to in writing,\n+  ~ software distributed under the License is distributed on an\n+  ~ \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+  ~ KIND, either express or implied.  See the License for the\n+  ~ specific language governing permissions and limitations\n+  ~ under the License.\n+  -->\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+    <parent>\n+        <groupId>org.wso2.carbon.apimgt</groupId>\n+        <artifactId>apimgt</artifactId>\n+        <version>6.6.47-SNAPSHOT</version>\n+        <relativePath>../pom.xml</relativePath>\n+    </parent>\n+\n+    <modelVersion>4.0.0</modelVersion>\n+    <artifactId>org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth</artifactId>\n+\n+    <packaging>bundle</packaging>\n+    <name>WSO2 Carbon - Event Output Extended HTTP adapter Module</name>\n+    <description>org.wso2.carbon.event.output.adapter.http.extended.oauth provides the back-end functionality of http event adapter\n+    </description>\n+    <url>http://wso2.org</url>\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.wso2.carbon.analytics-common</groupId>\n+            <artifactId>org.wso2.carbon.event.output.adapter.core</artifactId>\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>org.testng</groupId>\n+                    <artifactId>testng</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.wso2.carbon</groupId>\n+            <artifactId>org.wso2.carbon.core</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.axis2.transport</groupId>\n+            <artifactId>axis2-transport-mail</artifactId>\n+            <version>2.0.0-wso2v42</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.felix</groupId>\n+            <artifactId>org.apache.felix.scr.ds-annotations</artifactId>\n+            <scope>provided</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.httpcomponents.wso2</groupId>\n+            <artifactId>httpclient</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.json.wso2</groupId>\n+            <artifactId>json</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.wso2.carbon.apimgt</groupId>\n+            <artifactId>org.wso2.carbon.apimgt.impl</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>junit</groupId>\n+            <artifactId>junit</artifactId>\n+            <version>4.11</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg2Mjc3OQ==", "bodyText": "Fixed", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378862779", "createdAt": "2020-02-13T13:37:02Z", "author": {"login": "1akshitha"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/pom.xml", "diffHunk": "@@ -0,0 +1,131 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+  ~ Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+  ~\n+  ~ WSO2 Inc. licenses this file to you under the Apache License,\n+  ~ Version 2.0 (the \"License\"); you may not use this file except\n+  ~ in compliance with the License.\n+  ~ You may obtain a copy of the License at\n+  ~\n+  ~     http://www.apache.org/licenses/LICENSE-2.0\n+  ~\n+  ~ Unless required by applicable law or agreed to in writing,\n+  ~ software distributed under the License is distributed on an\n+  ~ \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+  ~ KIND, either express or implied.  See the License for the\n+  ~ specific language governing permissions and limitations\n+  ~ under the License.\n+  -->\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+    <parent>\n+        <groupId>org.wso2.carbon.apimgt</groupId>\n+        <artifactId>apimgt</artifactId>\n+        <version>6.6.47-SNAPSHOT</version>\n+        <relativePath>../pom.xml</relativePath>\n+    </parent>\n+\n+    <modelVersion>4.0.0</modelVersion>\n+    <artifactId>org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth</artifactId>\n+\n+    <packaging>bundle</packaging>\n+    <name>WSO2 Carbon - Event Output Extended HTTP adapter Module</name>\n+    <description>org.wso2.carbon.event.output.adapter.http.extended.oauth provides the back-end functionality of http event adapter\n+    </description>\n+    <url>http://wso2.org</url>\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.wso2.carbon.analytics-common</groupId>\n+            <artifactId>org.wso2.carbon.event.output.adapter.core</artifactId>\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>org.testng</groupId>\n+                    <artifactId>testng</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.wso2.carbon</groupId>\n+            <artifactId>org.wso2.carbon.core</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.axis2.transport</groupId>\n+            <artifactId>axis2-transport-mail</artifactId>\n+            <version>2.0.0-wso2v42</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.felix</groupId>\n+            <artifactId>org.apache.felix.scr.ds-annotations</artifactId>\n+            <scope>provided</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.httpcomponents.wso2</groupId>\n+            <artifactId>httpclient</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.json.wso2</groupId>\n+            <artifactId>json</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.wso2.carbon.apimgt</groupId>\n+            <artifactId>org.wso2.carbon.apimgt.impl</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>junit</groupId>\n+            <artifactId>junit</artifactId>\n+            <version>4.11</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1NTI1MA=="}, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMTkwMDA0OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo0NjoxMlrOFnfinw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxMzozOTo0MlrOFpUCiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1NTU1MQ==", "bodyText": "use proper/correct import/export versions", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376955551", "createdAt": "2020-02-10T09:46:12Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/pom.xml", "diffHunk": "@@ -0,0 +1,131 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+  ~ Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+  ~\n+  ~ WSO2 Inc. licenses this file to you under the Apache License,\n+  ~ Version 2.0 (the \"License\"); you may not use this file except\n+  ~ in compliance with the License.\n+  ~ You may obtain a copy of the License at\n+  ~\n+  ~     http://www.apache.org/licenses/LICENSE-2.0\n+  ~\n+  ~ Unless required by applicable law or agreed to in writing,\n+  ~ software distributed under the License is distributed on an\n+  ~ \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+  ~ KIND, either express or implied.  See the License for the\n+  ~ specific language governing permissions and limitations\n+  ~ under the License.\n+  -->\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+    <parent>\n+        <groupId>org.wso2.carbon.apimgt</groupId>\n+        <artifactId>apimgt</artifactId>\n+        <version>6.6.47-SNAPSHOT</version>\n+        <relativePath>../pom.xml</relativePath>\n+    </parent>\n+\n+    <modelVersion>4.0.0</modelVersion>\n+    <artifactId>org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth</artifactId>\n+\n+    <packaging>bundle</packaging>\n+    <name>WSO2 Carbon - Event Output Extended HTTP adapter Module</name>\n+    <description>org.wso2.carbon.event.output.adapter.http.extended.oauth provides the back-end functionality of http event adapter\n+    </description>\n+    <url>http://wso2.org</url>\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.wso2.carbon.analytics-common</groupId>\n+            <artifactId>org.wso2.carbon.event.output.adapter.core</artifactId>\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>org.testng</groupId>\n+                    <artifactId>testng</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.wso2.carbon</groupId>\n+            <artifactId>org.wso2.carbon.core</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.axis2.transport</groupId>\n+            <artifactId>axis2-transport-mail</artifactId>\n+            <version>2.0.0-wso2v42</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.felix</groupId>\n+            <artifactId>org.apache.felix.scr.ds-annotations</artifactId>\n+            <scope>provided</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.httpcomponents.wso2</groupId>\n+            <artifactId>httpclient</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.json.wso2</groupId>\n+            <artifactId>json</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.wso2.carbon.apimgt</groupId>\n+            <artifactId>org.wso2.carbon.apimgt.impl</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>junit</groupId>\n+            <artifactId>junit</artifactId>\n+            <version>4.11</version>\n+            <scope>test</scope>\n+        </dependency>\n+    </dependencies>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.felix</groupId>\n+                <artifactId>maven-bundle-plugin</artifactId>\n+                <extensions>true</extensions>\n+                <configuration>\n+                    <instructions>\n+                        <Bundle-SymbolicName>${project.artifactId}</Bundle-SymbolicName>\n+                        <Bundle-Name>${project.artifactId}</Bundle-Name>\n+                        <Private-Package>\n+                            org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal,\n+                            org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.*\n+                        </Private-Package>\n+                        <Export-Package>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg2NDI2NQ==", "bodyText": "Fixed", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378864265", "createdAt": "2020-02-13T13:39:42Z", "author": {"login": "1akshitha"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/pom.xml", "diffHunk": "@@ -0,0 +1,131 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+  ~ Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+  ~\n+  ~ WSO2 Inc. licenses this file to you under the Apache License,\n+  ~ Version 2.0 (the \"License\"); you may not use this file except\n+  ~ in compliance with the License.\n+  ~ You may obtain a copy of the License at\n+  ~\n+  ~     http://www.apache.org/licenses/LICENSE-2.0\n+  ~\n+  ~ Unless required by applicable law or agreed to in writing,\n+  ~ software distributed under the License is distributed on an\n+  ~ \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+  ~ KIND, either express or implied.  See the License for the\n+  ~ specific language governing permissions and limitations\n+  ~ under the License.\n+  -->\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+    <parent>\n+        <groupId>org.wso2.carbon.apimgt</groupId>\n+        <artifactId>apimgt</artifactId>\n+        <version>6.6.47-SNAPSHOT</version>\n+        <relativePath>../pom.xml</relativePath>\n+    </parent>\n+\n+    <modelVersion>4.0.0</modelVersion>\n+    <artifactId>org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth</artifactId>\n+\n+    <packaging>bundle</packaging>\n+    <name>WSO2 Carbon - Event Output Extended HTTP adapter Module</name>\n+    <description>org.wso2.carbon.event.output.adapter.http.extended.oauth provides the back-end functionality of http event adapter\n+    </description>\n+    <url>http://wso2.org</url>\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.wso2.carbon.analytics-common</groupId>\n+            <artifactId>org.wso2.carbon.event.output.adapter.core</artifactId>\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>org.testng</groupId>\n+                    <artifactId>testng</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.wso2.carbon</groupId>\n+            <artifactId>org.wso2.carbon.core</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.axis2.transport</groupId>\n+            <artifactId>axis2-transport-mail</artifactId>\n+            <version>2.0.0-wso2v42</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.felix</groupId>\n+            <artifactId>org.apache.felix.scr.ds-annotations</artifactId>\n+            <scope>provided</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.httpcomponents.wso2</groupId>\n+            <artifactId>httpclient</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.json.wso2</groupId>\n+            <artifactId>json</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.wso2.carbon.apimgt</groupId>\n+            <artifactId>org.wso2.carbon.apimgt.impl</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>junit</groupId>\n+            <artifactId>junit</artifactId>\n+            <version>4.11</version>\n+            <scope>test</scope>\n+        </dependency>\n+    </dependencies>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.felix</groupId>\n+                <artifactId>maven-bundle-plugin</artifactId>\n+                <extensions>true</extensions>\n+                <configuration>\n+                    <instructions>\n+                        <Bundle-SymbolicName>${project.artifactId}</Bundle-SymbolicName>\n+                        <Bundle-Name>${project.artifactId}</Bundle-Name>\n+                        <Private-Package>\n+                            org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal,\n+                            org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.*\n+                        </Private-Package>\n+                        <Export-Package>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1NTU1MQ=="}, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMTkxODMxOnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo1MDo1NFrOFnftSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNDoyOTo1NlrOFpV5EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1ODI4Mg==", "bodyText": "seems 'e' is missing", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376958282", "createdAt": "2020-02-10T09:50:54Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.apache.axiom.om.util.Base64;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.httpclient.HostConfiguration;\n+import org.apache.commons.httpclient.HttpClient;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;\n+import org.apache.commons.httpclient.methods.EntityEnclosingMethod;\n+import org.apache.commons.httpclient.methods.PostMethod;\n+import org.apache.commons.httpclient.methods.PutMethod;\n+import org.apache.commons.httpclient.methods.StringRequestEntity;\n+import org.apache.http.HttpHost;\n+import org.apache.http.conn.params.ConnRoutePNames;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds.ServiceReferenceHolder;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.event.output.adapter.core.EventAdapterUtil;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapter;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterConfiguration;\n+import org.wso2.carbon.event.output.adapter.core.exception.OutputEventAdapterException;\n+import org.wso2.carbon.event.output.adapter.core.exception.TestConnectionNotSupportedException;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+\n+\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+/**\n+ * The recommendation event adapter is used to publish events to recommendation server\n+ */\n+public class ExtendedHTTPEventAdapter implements OutputEventAdapter {\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapter.class);\n+    private OutputEventAdapterConfiguration eventAdapterConfiguration;\n+    private Map<String, String> globalProperties;\n+    private static ExecutorService executorService;\n+    private String clientMethod;\n+    private int tenantId;\n+\n+    private String contentType;\n+    private static HttpConnectionManager connectionManager;\n+    private static HttpClient httpClient = null;\n+    private HostConfiguration hostConfiguration = null;\n+\n+    public ExtendedHTTPEventAdapter(OutputEventAdapterConfiguration eventAdapterConfiguration,\n+                                    Map<String, String> globalProperties) {\n+        this.eventAdapterConfiguration = eventAdapterConfiguration;\n+        this.globalProperties = globalProperties;\n+        this.clientMethod = eventAdapterConfiguration.getStaticProperties()\n+                .get(ExtendedHTTPEventAdapterConstants.ADAPTER_HTTP_CLIENT_METHOD);\n+    }\n+\n+    @Override\n+    public void init() throws OutputEventAdapterException {\n+        tenantId = PrivilegedCarbonContext.getThreadLocalCarbonContext().getTenantId();\n+\n+        //ExecutorService will be assigned  if it is null\n+        if (executorService == null) {\n+            int minThread;\n+            int maxThread;\n+            long defaultKeepAliveTime;\n+            int jobQueSize;\n+\n+            //If global properties are available those will be assigned else constant values will be assigned\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME) != null) {\n+                minThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                minThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME) != null) {\n+                maxThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                maxThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME) != null) {\n+                defaultKeepAliveTime = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME));\n+            } else {\n+                defaultKeepAliveTime = ExtendedHTTPEventAdapterConstants.DEFAULT_KEEP_ALIVE_TIME_IN_MILLIS;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME) != null) {\n+                jobQueSize = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME));\n+            } else {\n+                jobQueSize = ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE;\n+            }\n+            executorService = new ThreadPoolExecutor(minThread, maxThread, defaultKeepAliveTime, TimeUnit.MILLISECONDS,\n+                    new LinkedBlockingQueue<Runnable>(jobQueSize));\n+\n+            //configurations for the httpConnectionManager which will be shared by every http adapter\n+            int defaultMaxConnectionsPerHost;\n+            int maxTotalConnections;\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST) != null) {\n+                defaultMaxConnectionsPerHost = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST));\n+            } else {\n+                defaultMaxConnectionsPerHost = ExtendedHTTPEventAdapterConstants.DEFAULT_DEFAULT_MAX_CONNECTIONS_PER_HOST;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS) != null) {\n+                maxTotalConnections = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS));\n+            } else {\n+                maxTotalConnections = ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_TOTAL_CONNECTIONS;\n+            }\n+\n+            connectionManager = new MultiThreadedHttpConnectionManager();\n+            connectionManager.getParams().setDefaultMaxConnectionsPerHost(defaultMaxConnectionsPerHost);\n+            connectionManager.getParams().setMaxTotalConnections(maxTotalConnections);\n+        }\n+    }\n+\n+    @Override\n+    public void testConnect() throws TestConnectionNotSupportedException {\n+        throw new TestConnectionNotSupportedException(\"Test connection is not available\");\n+    }\n+\n+    @Override\n+    public void connect() {\n+        this.checkHTTPClientInit(eventAdapterConfiguration.getStaticProperties());\n+    }\n+\n+    @Override\n+    public void publish(Object message, Map<String, String> dynamicProperties) {\n+        //Load dynamic properties\n+        String url = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MESSAGE_URL);\n+        String username = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_USERNAME);\n+        String password = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PASSWORD);\n+        String oauthUrl = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_URL);\n+        String consumerKey = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_KEY);\n+        String consumerSecret = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_SECRET);\n+\n+        Map<String, String> headers = this\n+                .extractHeaders(dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_HEADERS));\n+        String payload = message.toString();\n+\n+        try {\n+            if (username != null && password != null) {\n+                executorService.submit(new HTTPSender(url, payload, username, password, headers, httpClient));\n+            } else if(oauthUrl != null && consumerKey != null && consumerSecret != null ) {\n+                String accessToken = ServiceReferenceHolder.getInstance().getAccessTokenGenerator().getAccessToken(oauthUrl,consumerKey,\n+                        consumerSecret);\n+                executorService.submit(new HTTPSender(url, payload, accessToken, headers, httpClient));\n+            }\n+        } catch (RejectedExecutionException e) {\n+            EventAdapterUtil\n+                    .logAndDrop(eventAdapterConfiguration.getName(), message, \"Job queue is full\", e, log, tenantId);\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        //not required\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        //not required\n+    }\n+\n+    @Override\n+    public boolean isPolled() {\n+        return false;\n+    }\n+\n+    private void checkHTTPClientInit(Map<String, String> staticProperties) {\n+\n+        if (this.httpClient != null) {\n+            return;\n+        }\n+\n+        synchronized (ExtendedHTTPEventAdapter.class) {\n+            if (this.httpClient != null) {\n+                return;\n+            }\n+\n+            httpClient = new HttpClient(connectionManager);\n+            String proxyHost = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_HOST);\n+            String proxyPort = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_PORT);\n+            if (proxyHost != null && proxyHost.trim().length() > 0) {\n+                try {\n+                    HttpHost host = new HttpHost(proxyHost, Integer.parseInt(proxyPort));\n+                    this.httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, host);\n+                } catch (NumberFormatException e) {\n+                    log.error(\"Invalid proxy port: \" + proxyPort + \", \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg5NDYwOQ==", "bodyText": "Fixed", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378894609", "createdAt": "2020-02-13T14:29:56Z", "author": {"login": "1akshitha"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.apache.axiom.om.util.Base64;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.httpclient.HostConfiguration;\n+import org.apache.commons.httpclient.HttpClient;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;\n+import org.apache.commons.httpclient.methods.EntityEnclosingMethod;\n+import org.apache.commons.httpclient.methods.PostMethod;\n+import org.apache.commons.httpclient.methods.PutMethod;\n+import org.apache.commons.httpclient.methods.StringRequestEntity;\n+import org.apache.http.HttpHost;\n+import org.apache.http.conn.params.ConnRoutePNames;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds.ServiceReferenceHolder;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.event.output.adapter.core.EventAdapterUtil;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapter;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterConfiguration;\n+import org.wso2.carbon.event.output.adapter.core.exception.OutputEventAdapterException;\n+import org.wso2.carbon.event.output.adapter.core.exception.TestConnectionNotSupportedException;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+\n+\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+/**\n+ * The recommendation event adapter is used to publish events to recommendation server\n+ */\n+public class ExtendedHTTPEventAdapter implements OutputEventAdapter {\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapter.class);\n+    private OutputEventAdapterConfiguration eventAdapterConfiguration;\n+    private Map<String, String> globalProperties;\n+    private static ExecutorService executorService;\n+    private String clientMethod;\n+    private int tenantId;\n+\n+    private String contentType;\n+    private static HttpConnectionManager connectionManager;\n+    private static HttpClient httpClient = null;\n+    private HostConfiguration hostConfiguration = null;\n+\n+    public ExtendedHTTPEventAdapter(OutputEventAdapterConfiguration eventAdapterConfiguration,\n+                                    Map<String, String> globalProperties) {\n+        this.eventAdapterConfiguration = eventAdapterConfiguration;\n+        this.globalProperties = globalProperties;\n+        this.clientMethod = eventAdapterConfiguration.getStaticProperties()\n+                .get(ExtendedHTTPEventAdapterConstants.ADAPTER_HTTP_CLIENT_METHOD);\n+    }\n+\n+    @Override\n+    public void init() throws OutputEventAdapterException {\n+        tenantId = PrivilegedCarbonContext.getThreadLocalCarbonContext().getTenantId();\n+\n+        //ExecutorService will be assigned  if it is null\n+        if (executorService == null) {\n+            int minThread;\n+            int maxThread;\n+            long defaultKeepAliveTime;\n+            int jobQueSize;\n+\n+            //If global properties are available those will be assigned else constant values will be assigned\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME) != null) {\n+                minThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                minThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME) != null) {\n+                maxThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                maxThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME) != null) {\n+                defaultKeepAliveTime = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME));\n+            } else {\n+                defaultKeepAliveTime = ExtendedHTTPEventAdapterConstants.DEFAULT_KEEP_ALIVE_TIME_IN_MILLIS;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME) != null) {\n+                jobQueSize = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME));\n+            } else {\n+                jobQueSize = ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE;\n+            }\n+            executorService = new ThreadPoolExecutor(minThread, maxThread, defaultKeepAliveTime, TimeUnit.MILLISECONDS,\n+                    new LinkedBlockingQueue<Runnable>(jobQueSize));\n+\n+            //configurations for the httpConnectionManager which will be shared by every http adapter\n+            int defaultMaxConnectionsPerHost;\n+            int maxTotalConnections;\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST) != null) {\n+                defaultMaxConnectionsPerHost = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST));\n+            } else {\n+                defaultMaxConnectionsPerHost = ExtendedHTTPEventAdapterConstants.DEFAULT_DEFAULT_MAX_CONNECTIONS_PER_HOST;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS) != null) {\n+                maxTotalConnections = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS));\n+            } else {\n+                maxTotalConnections = ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_TOTAL_CONNECTIONS;\n+            }\n+\n+            connectionManager = new MultiThreadedHttpConnectionManager();\n+            connectionManager.getParams().setDefaultMaxConnectionsPerHost(defaultMaxConnectionsPerHost);\n+            connectionManager.getParams().setMaxTotalConnections(maxTotalConnections);\n+        }\n+    }\n+\n+    @Override\n+    public void testConnect() throws TestConnectionNotSupportedException {\n+        throw new TestConnectionNotSupportedException(\"Test connection is not available\");\n+    }\n+\n+    @Override\n+    public void connect() {\n+        this.checkHTTPClientInit(eventAdapterConfiguration.getStaticProperties());\n+    }\n+\n+    @Override\n+    public void publish(Object message, Map<String, String> dynamicProperties) {\n+        //Load dynamic properties\n+        String url = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MESSAGE_URL);\n+        String username = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_USERNAME);\n+        String password = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PASSWORD);\n+        String oauthUrl = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_URL);\n+        String consumerKey = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_KEY);\n+        String consumerSecret = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_SECRET);\n+\n+        Map<String, String> headers = this\n+                .extractHeaders(dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_HEADERS));\n+        String payload = message.toString();\n+\n+        try {\n+            if (username != null && password != null) {\n+                executorService.submit(new HTTPSender(url, payload, username, password, headers, httpClient));\n+            } else if(oauthUrl != null && consumerKey != null && consumerSecret != null ) {\n+                String accessToken = ServiceReferenceHolder.getInstance().getAccessTokenGenerator().getAccessToken(oauthUrl,consumerKey,\n+                        consumerSecret);\n+                executorService.submit(new HTTPSender(url, payload, accessToken, headers, httpClient));\n+            }\n+        } catch (RejectedExecutionException e) {\n+            EventAdapterUtil\n+                    .logAndDrop(eventAdapterConfiguration.getName(), message, \"Job queue is full\", e, log, tenantId);\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        //not required\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        //not required\n+    }\n+\n+    @Override\n+    public boolean isPolled() {\n+        return false;\n+    }\n+\n+    private void checkHTTPClientInit(Map<String, String> staticProperties) {\n+\n+        if (this.httpClient != null) {\n+            return;\n+        }\n+\n+        synchronized (ExtendedHTTPEventAdapter.class) {\n+            if (this.httpClient != null) {\n+                return;\n+            }\n+\n+            httpClient = new HttpClient(connectionManager);\n+            String proxyHost = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_HOST);\n+            String proxyPort = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_PORT);\n+            if (proxyHost != null && proxyHost.trim().length() > 0) {\n+                try {\n+                    HttpHost host = new HttpHost(proxyHost, Integer.parseInt(proxyPort));\n+                    this.httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, host);\n+                } catch (NumberFormatException e) {\n+                    log.error(\"Invalid proxy port: \" + proxyPort + \", \"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1ODI4Mg=="}, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 211}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMTkyMjQxOnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo1MTo1NVrOFnfvtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNDozMDowMlrOFpV5TQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1ODkwMg==", "bodyText": "We can use constants for MIME types", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376958902", "createdAt": "2020-02-10T09:51:55Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.apache.axiom.om.util.Base64;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.httpclient.HostConfiguration;\n+import org.apache.commons.httpclient.HttpClient;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;\n+import org.apache.commons.httpclient.methods.EntityEnclosingMethod;\n+import org.apache.commons.httpclient.methods.PostMethod;\n+import org.apache.commons.httpclient.methods.PutMethod;\n+import org.apache.commons.httpclient.methods.StringRequestEntity;\n+import org.apache.http.HttpHost;\n+import org.apache.http.conn.params.ConnRoutePNames;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds.ServiceReferenceHolder;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.event.output.adapter.core.EventAdapterUtil;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapter;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterConfiguration;\n+import org.wso2.carbon.event.output.adapter.core.exception.OutputEventAdapterException;\n+import org.wso2.carbon.event.output.adapter.core.exception.TestConnectionNotSupportedException;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+\n+\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+/**\n+ * The recommendation event adapter is used to publish events to recommendation server\n+ */\n+public class ExtendedHTTPEventAdapter implements OutputEventAdapter {\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapter.class);\n+    private OutputEventAdapterConfiguration eventAdapterConfiguration;\n+    private Map<String, String> globalProperties;\n+    private static ExecutorService executorService;\n+    private String clientMethod;\n+    private int tenantId;\n+\n+    private String contentType;\n+    private static HttpConnectionManager connectionManager;\n+    private static HttpClient httpClient = null;\n+    private HostConfiguration hostConfiguration = null;\n+\n+    public ExtendedHTTPEventAdapter(OutputEventAdapterConfiguration eventAdapterConfiguration,\n+                                    Map<String, String> globalProperties) {\n+        this.eventAdapterConfiguration = eventAdapterConfiguration;\n+        this.globalProperties = globalProperties;\n+        this.clientMethod = eventAdapterConfiguration.getStaticProperties()\n+                .get(ExtendedHTTPEventAdapterConstants.ADAPTER_HTTP_CLIENT_METHOD);\n+    }\n+\n+    @Override\n+    public void init() throws OutputEventAdapterException {\n+        tenantId = PrivilegedCarbonContext.getThreadLocalCarbonContext().getTenantId();\n+\n+        //ExecutorService will be assigned  if it is null\n+        if (executorService == null) {\n+            int minThread;\n+            int maxThread;\n+            long defaultKeepAliveTime;\n+            int jobQueSize;\n+\n+            //If global properties are available those will be assigned else constant values will be assigned\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME) != null) {\n+                minThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                minThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME) != null) {\n+                maxThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                maxThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME) != null) {\n+                defaultKeepAliveTime = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME));\n+            } else {\n+                defaultKeepAliveTime = ExtendedHTTPEventAdapterConstants.DEFAULT_KEEP_ALIVE_TIME_IN_MILLIS;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME) != null) {\n+                jobQueSize = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME));\n+            } else {\n+                jobQueSize = ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE;\n+            }\n+            executorService = new ThreadPoolExecutor(minThread, maxThread, defaultKeepAliveTime, TimeUnit.MILLISECONDS,\n+                    new LinkedBlockingQueue<Runnable>(jobQueSize));\n+\n+            //configurations for the httpConnectionManager which will be shared by every http adapter\n+            int defaultMaxConnectionsPerHost;\n+            int maxTotalConnections;\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST) != null) {\n+                defaultMaxConnectionsPerHost = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST));\n+            } else {\n+                defaultMaxConnectionsPerHost = ExtendedHTTPEventAdapterConstants.DEFAULT_DEFAULT_MAX_CONNECTIONS_PER_HOST;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS) != null) {\n+                maxTotalConnections = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS));\n+            } else {\n+                maxTotalConnections = ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_TOTAL_CONNECTIONS;\n+            }\n+\n+            connectionManager = new MultiThreadedHttpConnectionManager();\n+            connectionManager.getParams().setDefaultMaxConnectionsPerHost(defaultMaxConnectionsPerHost);\n+            connectionManager.getParams().setMaxTotalConnections(maxTotalConnections);\n+        }\n+    }\n+\n+    @Override\n+    public void testConnect() throws TestConnectionNotSupportedException {\n+        throw new TestConnectionNotSupportedException(\"Test connection is not available\");\n+    }\n+\n+    @Override\n+    public void connect() {\n+        this.checkHTTPClientInit(eventAdapterConfiguration.getStaticProperties());\n+    }\n+\n+    @Override\n+    public void publish(Object message, Map<String, String> dynamicProperties) {\n+        //Load dynamic properties\n+        String url = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MESSAGE_URL);\n+        String username = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_USERNAME);\n+        String password = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PASSWORD);\n+        String oauthUrl = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_URL);\n+        String consumerKey = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_KEY);\n+        String consumerSecret = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_SECRET);\n+\n+        Map<String, String> headers = this\n+                .extractHeaders(dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_HEADERS));\n+        String payload = message.toString();\n+\n+        try {\n+            if (username != null && password != null) {\n+                executorService.submit(new HTTPSender(url, payload, username, password, headers, httpClient));\n+            } else if(oauthUrl != null && consumerKey != null && consumerSecret != null ) {\n+                String accessToken = ServiceReferenceHolder.getInstance().getAccessTokenGenerator().getAccessToken(oauthUrl,consumerKey,\n+                        consumerSecret);\n+                executorService.submit(new HTTPSender(url, payload, accessToken, headers, httpClient));\n+            }\n+        } catch (RejectedExecutionException e) {\n+            EventAdapterUtil\n+                    .logAndDrop(eventAdapterConfiguration.getName(), message, \"Job queue is full\", e, log, tenantId);\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        //not required\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        //not required\n+    }\n+\n+    @Override\n+    public boolean isPolled() {\n+        return false;\n+    }\n+\n+    private void checkHTTPClientInit(Map<String, String> staticProperties) {\n+\n+        if (this.httpClient != null) {\n+            return;\n+        }\n+\n+        synchronized (ExtendedHTTPEventAdapter.class) {\n+            if (this.httpClient != null) {\n+                return;\n+            }\n+\n+            httpClient = new HttpClient(connectionManager);\n+            String proxyHost = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_HOST);\n+            String proxyPort = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_PORT);\n+            if (proxyHost != null && proxyHost.trim().length() > 0) {\n+                try {\n+                    HttpHost host = new HttpHost(proxyHost, Integer.parseInt(proxyPort));\n+                    this.httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, host);\n+                } catch (NumberFormatException e) {\n+                    log.error(\"Invalid proxy port: \" + proxyPort + \", \"\n+                            + \"ignoring proxy settings for HTTP output event adaptor...\");\n+                }\n+            }\n+\n+            String messageFormat = eventAdapterConfiguration.getMessageFormat();\n+            if (messageFormat.equalsIgnoreCase(\"json\")) {\n+                contentType = \"application/json\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg5NDY2OQ==", "bodyText": "Fixed", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378894669", "createdAt": "2020-02-13T14:30:02Z", "author": {"login": "1akshitha"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.apache.axiom.om.util.Base64;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.httpclient.HostConfiguration;\n+import org.apache.commons.httpclient.HttpClient;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;\n+import org.apache.commons.httpclient.methods.EntityEnclosingMethod;\n+import org.apache.commons.httpclient.methods.PostMethod;\n+import org.apache.commons.httpclient.methods.PutMethod;\n+import org.apache.commons.httpclient.methods.StringRequestEntity;\n+import org.apache.http.HttpHost;\n+import org.apache.http.conn.params.ConnRoutePNames;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds.ServiceReferenceHolder;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.event.output.adapter.core.EventAdapterUtil;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapter;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterConfiguration;\n+import org.wso2.carbon.event.output.adapter.core.exception.OutputEventAdapterException;\n+import org.wso2.carbon.event.output.adapter.core.exception.TestConnectionNotSupportedException;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+\n+\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+/**\n+ * The recommendation event adapter is used to publish events to recommendation server\n+ */\n+public class ExtendedHTTPEventAdapter implements OutputEventAdapter {\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapter.class);\n+    private OutputEventAdapterConfiguration eventAdapterConfiguration;\n+    private Map<String, String> globalProperties;\n+    private static ExecutorService executorService;\n+    private String clientMethod;\n+    private int tenantId;\n+\n+    private String contentType;\n+    private static HttpConnectionManager connectionManager;\n+    private static HttpClient httpClient = null;\n+    private HostConfiguration hostConfiguration = null;\n+\n+    public ExtendedHTTPEventAdapter(OutputEventAdapterConfiguration eventAdapterConfiguration,\n+                                    Map<String, String> globalProperties) {\n+        this.eventAdapterConfiguration = eventAdapterConfiguration;\n+        this.globalProperties = globalProperties;\n+        this.clientMethod = eventAdapterConfiguration.getStaticProperties()\n+                .get(ExtendedHTTPEventAdapterConstants.ADAPTER_HTTP_CLIENT_METHOD);\n+    }\n+\n+    @Override\n+    public void init() throws OutputEventAdapterException {\n+        tenantId = PrivilegedCarbonContext.getThreadLocalCarbonContext().getTenantId();\n+\n+        //ExecutorService will be assigned  if it is null\n+        if (executorService == null) {\n+            int minThread;\n+            int maxThread;\n+            long defaultKeepAliveTime;\n+            int jobQueSize;\n+\n+            //If global properties are available those will be assigned else constant values will be assigned\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME) != null) {\n+                minThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                minThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME) != null) {\n+                maxThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                maxThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME) != null) {\n+                defaultKeepAliveTime = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME));\n+            } else {\n+                defaultKeepAliveTime = ExtendedHTTPEventAdapterConstants.DEFAULT_KEEP_ALIVE_TIME_IN_MILLIS;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME) != null) {\n+                jobQueSize = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME));\n+            } else {\n+                jobQueSize = ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE;\n+            }\n+            executorService = new ThreadPoolExecutor(minThread, maxThread, defaultKeepAliveTime, TimeUnit.MILLISECONDS,\n+                    new LinkedBlockingQueue<Runnable>(jobQueSize));\n+\n+            //configurations for the httpConnectionManager which will be shared by every http adapter\n+            int defaultMaxConnectionsPerHost;\n+            int maxTotalConnections;\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST) != null) {\n+                defaultMaxConnectionsPerHost = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST));\n+            } else {\n+                defaultMaxConnectionsPerHost = ExtendedHTTPEventAdapterConstants.DEFAULT_DEFAULT_MAX_CONNECTIONS_PER_HOST;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS) != null) {\n+                maxTotalConnections = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS));\n+            } else {\n+                maxTotalConnections = ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_TOTAL_CONNECTIONS;\n+            }\n+\n+            connectionManager = new MultiThreadedHttpConnectionManager();\n+            connectionManager.getParams().setDefaultMaxConnectionsPerHost(defaultMaxConnectionsPerHost);\n+            connectionManager.getParams().setMaxTotalConnections(maxTotalConnections);\n+        }\n+    }\n+\n+    @Override\n+    public void testConnect() throws TestConnectionNotSupportedException {\n+        throw new TestConnectionNotSupportedException(\"Test connection is not available\");\n+    }\n+\n+    @Override\n+    public void connect() {\n+        this.checkHTTPClientInit(eventAdapterConfiguration.getStaticProperties());\n+    }\n+\n+    @Override\n+    public void publish(Object message, Map<String, String> dynamicProperties) {\n+        //Load dynamic properties\n+        String url = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MESSAGE_URL);\n+        String username = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_USERNAME);\n+        String password = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PASSWORD);\n+        String oauthUrl = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_URL);\n+        String consumerKey = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_KEY);\n+        String consumerSecret = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_SECRET);\n+\n+        Map<String, String> headers = this\n+                .extractHeaders(dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_HEADERS));\n+        String payload = message.toString();\n+\n+        try {\n+            if (username != null && password != null) {\n+                executorService.submit(new HTTPSender(url, payload, username, password, headers, httpClient));\n+            } else if(oauthUrl != null && consumerKey != null && consumerSecret != null ) {\n+                String accessToken = ServiceReferenceHolder.getInstance().getAccessTokenGenerator().getAccessToken(oauthUrl,consumerKey,\n+                        consumerSecret);\n+                executorService.submit(new HTTPSender(url, payload, accessToken, headers, httpClient));\n+            }\n+        } catch (RejectedExecutionException e) {\n+            EventAdapterUtil\n+                    .logAndDrop(eventAdapterConfiguration.getName(), message, \"Job queue is full\", e, log, tenantId);\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        //not required\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        //not required\n+    }\n+\n+    @Override\n+    public boolean isPolled() {\n+        return false;\n+    }\n+\n+    private void checkHTTPClientInit(Map<String, String> staticProperties) {\n+\n+        if (this.httpClient != null) {\n+            return;\n+        }\n+\n+        synchronized (ExtendedHTTPEventAdapter.class) {\n+            if (this.httpClient != null) {\n+                return;\n+            }\n+\n+            httpClient = new HttpClient(connectionManager);\n+            String proxyHost = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_HOST);\n+            String proxyPort = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_PORT);\n+            if (proxyHost != null && proxyHost.trim().length() > 0) {\n+                try {\n+                    HttpHost host = new HttpHost(proxyHost, Integer.parseInt(proxyPort));\n+                    this.httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, host);\n+                } catch (NumberFormatException e) {\n+                    log.error(\"Invalid proxy port: \" + proxyPort + \", \"\n+                            + \"ignoring proxy settings for HTTP output event adaptor...\");\n+                }\n+            }\n+\n+            String messageFormat = eventAdapterConfiguration.getMessageFormat();\n+            if (messageFormat.equalsIgnoreCase(\"json\")) {\n+                contentType = \"application/json\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1ODkwMg=="}, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 218}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMTkyNjI2OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo1Mjo1M1rOFnfx7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxMzo0MDoxM1rOFpUDnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1OTQ3MA==", "bodyText": "We can use https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#isEmpty() here.", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376959470", "createdAt": "2020-02-10T09:52:53Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.apache.axiom.om.util.Base64;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.httpclient.HostConfiguration;\n+import org.apache.commons.httpclient.HttpClient;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;\n+import org.apache.commons.httpclient.methods.EntityEnclosingMethod;\n+import org.apache.commons.httpclient.methods.PostMethod;\n+import org.apache.commons.httpclient.methods.PutMethod;\n+import org.apache.commons.httpclient.methods.StringRequestEntity;\n+import org.apache.http.HttpHost;\n+import org.apache.http.conn.params.ConnRoutePNames;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds.ServiceReferenceHolder;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.event.output.adapter.core.EventAdapterUtil;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapter;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterConfiguration;\n+import org.wso2.carbon.event.output.adapter.core.exception.OutputEventAdapterException;\n+import org.wso2.carbon.event.output.adapter.core.exception.TestConnectionNotSupportedException;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+\n+\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+/**\n+ * The recommendation event adapter is used to publish events to recommendation server\n+ */\n+public class ExtendedHTTPEventAdapter implements OutputEventAdapter {\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapter.class);\n+    private OutputEventAdapterConfiguration eventAdapterConfiguration;\n+    private Map<String, String> globalProperties;\n+    private static ExecutorService executorService;\n+    private String clientMethod;\n+    private int tenantId;\n+\n+    private String contentType;\n+    private static HttpConnectionManager connectionManager;\n+    private static HttpClient httpClient = null;\n+    private HostConfiguration hostConfiguration = null;\n+\n+    public ExtendedHTTPEventAdapter(OutputEventAdapterConfiguration eventAdapterConfiguration,\n+                                    Map<String, String> globalProperties) {\n+        this.eventAdapterConfiguration = eventAdapterConfiguration;\n+        this.globalProperties = globalProperties;\n+        this.clientMethod = eventAdapterConfiguration.getStaticProperties()\n+                .get(ExtendedHTTPEventAdapterConstants.ADAPTER_HTTP_CLIENT_METHOD);\n+    }\n+\n+    @Override\n+    public void init() throws OutputEventAdapterException {\n+        tenantId = PrivilegedCarbonContext.getThreadLocalCarbonContext().getTenantId();\n+\n+        //ExecutorService will be assigned  if it is null\n+        if (executorService == null) {\n+            int minThread;\n+            int maxThread;\n+            long defaultKeepAliveTime;\n+            int jobQueSize;\n+\n+            //If global properties are available those will be assigned else constant values will be assigned\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME) != null) {\n+                minThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                minThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME) != null) {\n+                maxThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                maxThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME) != null) {\n+                defaultKeepAliveTime = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME));\n+            } else {\n+                defaultKeepAliveTime = ExtendedHTTPEventAdapterConstants.DEFAULT_KEEP_ALIVE_TIME_IN_MILLIS;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME) != null) {\n+                jobQueSize = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME));\n+            } else {\n+                jobQueSize = ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE;\n+            }\n+            executorService = new ThreadPoolExecutor(minThread, maxThread, defaultKeepAliveTime, TimeUnit.MILLISECONDS,\n+                    new LinkedBlockingQueue<Runnable>(jobQueSize));\n+\n+            //configurations for the httpConnectionManager which will be shared by every http adapter\n+            int defaultMaxConnectionsPerHost;\n+            int maxTotalConnections;\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST) != null) {\n+                defaultMaxConnectionsPerHost = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST));\n+            } else {\n+                defaultMaxConnectionsPerHost = ExtendedHTTPEventAdapterConstants.DEFAULT_DEFAULT_MAX_CONNECTIONS_PER_HOST;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS) != null) {\n+                maxTotalConnections = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS));\n+            } else {\n+                maxTotalConnections = ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_TOTAL_CONNECTIONS;\n+            }\n+\n+            connectionManager = new MultiThreadedHttpConnectionManager();\n+            connectionManager.getParams().setDefaultMaxConnectionsPerHost(defaultMaxConnectionsPerHost);\n+            connectionManager.getParams().setMaxTotalConnections(maxTotalConnections);\n+        }\n+    }\n+\n+    @Override\n+    public void testConnect() throws TestConnectionNotSupportedException {\n+        throw new TestConnectionNotSupportedException(\"Test connection is not available\");\n+    }\n+\n+    @Override\n+    public void connect() {\n+        this.checkHTTPClientInit(eventAdapterConfiguration.getStaticProperties());\n+    }\n+\n+    @Override\n+    public void publish(Object message, Map<String, String> dynamicProperties) {\n+        //Load dynamic properties\n+        String url = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MESSAGE_URL);\n+        String username = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_USERNAME);\n+        String password = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PASSWORD);\n+        String oauthUrl = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_URL);\n+        String consumerKey = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_KEY);\n+        String consumerSecret = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_SECRET);\n+\n+        Map<String, String> headers = this\n+                .extractHeaders(dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_HEADERS));\n+        String payload = message.toString();\n+\n+        try {\n+            if (username != null && password != null) {\n+                executorService.submit(new HTTPSender(url, payload, username, password, headers, httpClient));\n+            } else if(oauthUrl != null && consumerKey != null && consumerSecret != null ) {\n+                String accessToken = ServiceReferenceHolder.getInstance().getAccessTokenGenerator().getAccessToken(oauthUrl,consumerKey,\n+                        consumerSecret);\n+                executorService.submit(new HTTPSender(url, payload, accessToken, headers, httpClient));\n+            }\n+        } catch (RejectedExecutionException e) {\n+            EventAdapterUtil\n+                    .logAndDrop(eventAdapterConfiguration.getName(), message, \"Job queue is full\", e, log, tenantId);\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        //not required\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        //not required\n+    }\n+\n+    @Override\n+    public boolean isPolled() {\n+        return false;\n+    }\n+\n+    private void checkHTTPClientInit(Map<String, String> staticProperties) {\n+\n+        if (this.httpClient != null) {\n+            return;\n+        }\n+\n+        synchronized (ExtendedHTTPEventAdapter.class) {\n+            if (this.httpClient != null) {\n+                return;\n+            }\n+\n+            httpClient = new HttpClient(connectionManager);\n+            String proxyHost = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_HOST);\n+            String proxyPort = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_PORT);\n+            if (proxyHost != null && proxyHost.trim().length() > 0) {\n+                try {\n+                    HttpHost host = new HttpHost(proxyHost, Integer.parseInt(proxyPort));\n+                    this.httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, host);\n+                } catch (NumberFormatException e) {\n+                    log.error(\"Invalid proxy port: \" + proxyPort + \", \"\n+                            + \"ignoring proxy settings for HTTP output event adaptor...\");\n+                }\n+            }\n+\n+            String messageFormat = eventAdapterConfiguration.getMessageFormat();\n+            if (messageFormat.equalsIgnoreCase(\"json\")) {\n+                contentType = \"application/json\";\n+            } else if (messageFormat.equalsIgnoreCase(\"text\")) {\n+                contentType = \"text/plain\";\n+            } else {\n+                contentType = \"text/xml\";\n+            }\n+\n+        }\n+\n+    }\n+\n+    private Map<String, String> extractHeaders(String headers) {\n+        if (headers == null || headers.trim().length() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg2NDU0MQ==", "bodyText": "Fixed", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378864541", "createdAt": "2020-02-13T13:40:13Z", "author": {"login": "1akshitha"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.apache.axiom.om.util.Base64;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.httpclient.HostConfiguration;\n+import org.apache.commons.httpclient.HttpClient;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;\n+import org.apache.commons.httpclient.methods.EntityEnclosingMethod;\n+import org.apache.commons.httpclient.methods.PostMethod;\n+import org.apache.commons.httpclient.methods.PutMethod;\n+import org.apache.commons.httpclient.methods.StringRequestEntity;\n+import org.apache.http.HttpHost;\n+import org.apache.http.conn.params.ConnRoutePNames;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds.ServiceReferenceHolder;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.event.output.adapter.core.EventAdapterUtil;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapter;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterConfiguration;\n+import org.wso2.carbon.event.output.adapter.core.exception.OutputEventAdapterException;\n+import org.wso2.carbon.event.output.adapter.core.exception.TestConnectionNotSupportedException;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+\n+\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+/**\n+ * The recommendation event adapter is used to publish events to recommendation server\n+ */\n+public class ExtendedHTTPEventAdapter implements OutputEventAdapter {\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapter.class);\n+    private OutputEventAdapterConfiguration eventAdapterConfiguration;\n+    private Map<String, String> globalProperties;\n+    private static ExecutorService executorService;\n+    private String clientMethod;\n+    private int tenantId;\n+\n+    private String contentType;\n+    private static HttpConnectionManager connectionManager;\n+    private static HttpClient httpClient = null;\n+    private HostConfiguration hostConfiguration = null;\n+\n+    public ExtendedHTTPEventAdapter(OutputEventAdapterConfiguration eventAdapterConfiguration,\n+                                    Map<String, String> globalProperties) {\n+        this.eventAdapterConfiguration = eventAdapterConfiguration;\n+        this.globalProperties = globalProperties;\n+        this.clientMethod = eventAdapterConfiguration.getStaticProperties()\n+                .get(ExtendedHTTPEventAdapterConstants.ADAPTER_HTTP_CLIENT_METHOD);\n+    }\n+\n+    @Override\n+    public void init() throws OutputEventAdapterException {\n+        tenantId = PrivilegedCarbonContext.getThreadLocalCarbonContext().getTenantId();\n+\n+        //ExecutorService will be assigned  if it is null\n+        if (executorService == null) {\n+            int minThread;\n+            int maxThread;\n+            long defaultKeepAliveTime;\n+            int jobQueSize;\n+\n+            //If global properties are available those will be assigned else constant values will be assigned\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME) != null) {\n+                minThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                minThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME) != null) {\n+                maxThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                maxThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME) != null) {\n+                defaultKeepAliveTime = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME));\n+            } else {\n+                defaultKeepAliveTime = ExtendedHTTPEventAdapterConstants.DEFAULT_KEEP_ALIVE_TIME_IN_MILLIS;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME) != null) {\n+                jobQueSize = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME));\n+            } else {\n+                jobQueSize = ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE;\n+            }\n+            executorService = new ThreadPoolExecutor(minThread, maxThread, defaultKeepAliveTime, TimeUnit.MILLISECONDS,\n+                    new LinkedBlockingQueue<Runnable>(jobQueSize));\n+\n+            //configurations for the httpConnectionManager which will be shared by every http adapter\n+            int defaultMaxConnectionsPerHost;\n+            int maxTotalConnections;\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST) != null) {\n+                defaultMaxConnectionsPerHost = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST));\n+            } else {\n+                defaultMaxConnectionsPerHost = ExtendedHTTPEventAdapterConstants.DEFAULT_DEFAULT_MAX_CONNECTIONS_PER_HOST;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS) != null) {\n+                maxTotalConnections = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS));\n+            } else {\n+                maxTotalConnections = ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_TOTAL_CONNECTIONS;\n+            }\n+\n+            connectionManager = new MultiThreadedHttpConnectionManager();\n+            connectionManager.getParams().setDefaultMaxConnectionsPerHost(defaultMaxConnectionsPerHost);\n+            connectionManager.getParams().setMaxTotalConnections(maxTotalConnections);\n+        }\n+    }\n+\n+    @Override\n+    public void testConnect() throws TestConnectionNotSupportedException {\n+        throw new TestConnectionNotSupportedException(\"Test connection is not available\");\n+    }\n+\n+    @Override\n+    public void connect() {\n+        this.checkHTTPClientInit(eventAdapterConfiguration.getStaticProperties());\n+    }\n+\n+    @Override\n+    public void publish(Object message, Map<String, String> dynamicProperties) {\n+        //Load dynamic properties\n+        String url = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MESSAGE_URL);\n+        String username = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_USERNAME);\n+        String password = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PASSWORD);\n+        String oauthUrl = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_URL);\n+        String consumerKey = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_KEY);\n+        String consumerSecret = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_SECRET);\n+\n+        Map<String, String> headers = this\n+                .extractHeaders(dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_HEADERS));\n+        String payload = message.toString();\n+\n+        try {\n+            if (username != null && password != null) {\n+                executorService.submit(new HTTPSender(url, payload, username, password, headers, httpClient));\n+            } else if(oauthUrl != null && consumerKey != null && consumerSecret != null ) {\n+                String accessToken = ServiceReferenceHolder.getInstance().getAccessTokenGenerator().getAccessToken(oauthUrl,consumerKey,\n+                        consumerSecret);\n+                executorService.submit(new HTTPSender(url, payload, accessToken, headers, httpClient));\n+            }\n+        } catch (RejectedExecutionException e) {\n+            EventAdapterUtil\n+                    .logAndDrop(eventAdapterConfiguration.getName(), message, \"Job queue is full\", e, log, tenantId);\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        //not required\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        //not required\n+    }\n+\n+    @Override\n+    public boolean isPolled() {\n+        return false;\n+    }\n+\n+    private void checkHTTPClientInit(Map<String, String> staticProperties) {\n+\n+        if (this.httpClient != null) {\n+            return;\n+        }\n+\n+        synchronized (ExtendedHTTPEventAdapter.class) {\n+            if (this.httpClient != null) {\n+                return;\n+            }\n+\n+            httpClient = new HttpClient(connectionManager);\n+            String proxyHost = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_HOST);\n+            String proxyPort = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_PORT);\n+            if (proxyHost != null && proxyHost.trim().length() > 0) {\n+                try {\n+                    HttpHost host = new HttpHost(proxyHost, Integer.parseInt(proxyPort));\n+                    this.httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, host);\n+                } catch (NumberFormatException e) {\n+                    log.error(\"Invalid proxy port: \" + proxyPort + \", \"\n+                            + \"ignoring proxy settings for HTTP output event adaptor...\");\n+                }\n+            }\n+\n+            String messageFormat = eventAdapterConfiguration.getMessageFormat();\n+            if (messageFormat.equalsIgnoreCase(\"json\")) {\n+                contentType = \"application/json\";\n+            } else if (messageFormat.equalsIgnoreCase(\"text\")) {\n+                contentType = \"text/plain\";\n+            } else {\n+                contentType = \"text/xml\";\n+            }\n+\n+        }\n+\n+    }\n+\n+    private Map<String, String> extractHeaders(String headers) {\n+        if (headers == null || headers.trim().length() == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1OTQ3MA=="}, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 230}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMTkyOTk4OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo1Mzo0NVrOFnfz9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxMzo0MDozMFrOFpUEMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1OTk4OA==", "bodyText": "please explain reason to catch the generic exception.", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376959988", "createdAt": "2020-02-10T09:53:45Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.apache.axiom.om.util.Base64;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.httpclient.HostConfiguration;\n+import org.apache.commons.httpclient.HttpClient;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;\n+import org.apache.commons.httpclient.methods.EntityEnclosingMethod;\n+import org.apache.commons.httpclient.methods.PostMethod;\n+import org.apache.commons.httpclient.methods.PutMethod;\n+import org.apache.commons.httpclient.methods.StringRequestEntity;\n+import org.apache.http.HttpHost;\n+import org.apache.http.conn.params.ConnRoutePNames;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds.ServiceReferenceHolder;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.event.output.adapter.core.EventAdapterUtil;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapter;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterConfiguration;\n+import org.wso2.carbon.event.output.adapter.core.exception.OutputEventAdapterException;\n+import org.wso2.carbon.event.output.adapter.core.exception.TestConnectionNotSupportedException;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+\n+\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+/**\n+ * The recommendation event adapter is used to publish events to recommendation server\n+ */\n+public class ExtendedHTTPEventAdapter implements OutputEventAdapter {\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapter.class);\n+    private OutputEventAdapterConfiguration eventAdapterConfiguration;\n+    private Map<String, String> globalProperties;\n+    private static ExecutorService executorService;\n+    private String clientMethod;\n+    private int tenantId;\n+\n+    private String contentType;\n+    private static HttpConnectionManager connectionManager;\n+    private static HttpClient httpClient = null;\n+    private HostConfiguration hostConfiguration = null;\n+\n+    public ExtendedHTTPEventAdapter(OutputEventAdapterConfiguration eventAdapterConfiguration,\n+                                    Map<String, String> globalProperties) {\n+        this.eventAdapterConfiguration = eventAdapterConfiguration;\n+        this.globalProperties = globalProperties;\n+        this.clientMethod = eventAdapterConfiguration.getStaticProperties()\n+                .get(ExtendedHTTPEventAdapterConstants.ADAPTER_HTTP_CLIENT_METHOD);\n+    }\n+\n+    @Override\n+    public void init() throws OutputEventAdapterException {\n+        tenantId = PrivilegedCarbonContext.getThreadLocalCarbonContext().getTenantId();\n+\n+        //ExecutorService will be assigned  if it is null\n+        if (executorService == null) {\n+            int minThread;\n+            int maxThread;\n+            long defaultKeepAliveTime;\n+            int jobQueSize;\n+\n+            //If global properties are available those will be assigned else constant values will be assigned\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME) != null) {\n+                minThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                minThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME) != null) {\n+                maxThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                maxThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME) != null) {\n+                defaultKeepAliveTime = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME));\n+            } else {\n+                defaultKeepAliveTime = ExtendedHTTPEventAdapterConstants.DEFAULT_KEEP_ALIVE_TIME_IN_MILLIS;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME) != null) {\n+                jobQueSize = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME));\n+            } else {\n+                jobQueSize = ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE;\n+            }\n+            executorService = new ThreadPoolExecutor(minThread, maxThread, defaultKeepAliveTime, TimeUnit.MILLISECONDS,\n+                    new LinkedBlockingQueue<Runnable>(jobQueSize));\n+\n+            //configurations for the httpConnectionManager which will be shared by every http adapter\n+            int defaultMaxConnectionsPerHost;\n+            int maxTotalConnections;\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST) != null) {\n+                defaultMaxConnectionsPerHost = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST));\n+            } else {\n+                defaultMaxConnectionsPerHost = ExtendedHTTPEventAdapterConstants.DEFAULT_DEFAULT_MAX_CONNECTIONS_PER_HOST;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS) != null) {\n+                maxTotalConnections = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS));\n+            } else {\n+                maxTotalConnections = ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_TOTAL_CONNECTIONS;\n+            }\n+\n+            connectionManager = new MultiThreadedHttpConnectionManager();\n+            connectionManager.getParams().setDefaultMaxConnectionsPerHost(defaultMaxConnectionsPerHost);\n+            connectionManager.getParams().setMaxTotalConnections(maxTotalConnections);\n+        }\n+    }\n+\n+    @Override\n+    public void testConnect() throws TestConnectionNotSupportedException {\n+        throw new TestConnectionNotSupportedException(\"Test connection is not available\");\n+    }\n+\n+    @Override\n+    public void connect() {\n+        this.checkHTTPClientInit(eventAdapterConfiguration.getStaticProperties());\n+    }\n+\n+    @Override\n+    public void publish(Object message, Map<String, String> dynamicProperties) {\n+        //Load dynamic properties\n+        String url = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MESSAGE_URL);\n+        String username = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_USERNAME);\n+        String password = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PASSWORD);\n+        String oauthUrl = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_URL);\n+        String consumerKey = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_KEY);\n+        String consumerSecret = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_SECRET);\n+\n+        Map<String, String> headers = this\n+                .extractHeaders(dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_HEADERS));\n+        String payload = message.toString();\n+\n+        try {\n+            if (username != null && password != null) {\n+                executorService.submit(new HTTPSender(url, payload, username, password, headers, httpClient));\n+            } else if(oauthUrl != null && consumerKey != null && consumerSecret != null ) {\n+                String accessToken = ServiceReferenceHolder.getInstance().getAccessTokenGenerator().getAccessToken(oauthUrl,consumerKey,\n+                        consumerSecret);\n+                executorService.submit(new HTTPSender(url, payload, accessToken, headers, httpClient));\n+            }\n+        } catch (RejectedExecutionException e) {\n+            EventAdapterUtil\n+                    .logAndDrop(eventAdapterConfiguration.getName(), message, \"Job queue is full\", e, log, tenantId);\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        //not required\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        //not required\n+    }\n+\n+    @Override\n+    public boolean isPolled() {\n+        return false;\n+    }\n+\n+    private void checkHTTPClientInit(Map<String, String> staticProperties) {\n+\n+        if (this.httpClient != null) {\n+            return;\n+        }\n+\n+        synchronized (ExtendedHTTPEventAdapter.class) {\n+            if (this.httpClient != null) {\n+                return;\n+            }\n+\n+            httpClient = new HttpClient(connectionManager);\n+            String proxyHost = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_HOST);\n+            String proxyPort = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_PORT);\n+            if (proxyHost != null && proxyHost.trim().length() > 0) {\n+                try {\n+                    HttpHost host = new HttpHost(proxyHost, Integer.parseInt(proxyPort));\n+                    this.httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, host);\n+                } catch (NumberFormatException e) {\n+                    log.error(\"Invalid proxy port: \" + proxyPort + \", \"\n+                            + \"ignoring proxy settings for HTTP output event adaptor...\");\n+                }\n+            }\n+\n+            String messageFormat = eventAdapterConfiguration.getMessageFormat();\n+            if (messageFormat.equalsIgnoreCase(\"json\")) {\n+                contentType = \"application/json\";\n+            } else if (messageFormat.equalsIgnoreCase(\"text\")) {\n+                contentType = \"text/plain\";\n+            } else {\n+                contentType = \"text/xml\";\n+            }\n+\n+        }\n+\n+    }\n+\n+    private Map<String, String> extractHeaders(String headers) {\n+        if (headers == null || headers.trim().length() == 0) {\n+            return null;\n+        }\n+\n+        String[] entries = headers.split(ExtendedHTTPEventAdapterConstants.HEADER_SEPARATOR);\n+        String[] keyValue;\n+        Map<String, String> result = new HashMap<String, String>();\n+        for (String header : entries) {\n+            try {\n+                keyValue = header.split(ExtendedHTTPEventAdapterConstants.ENTRY_SEPARATOR, 2);\n+                result.put(keyValue[0].trim(), keyValue[1].trim());\n+            } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg2NDY4OA==", "bodyText": "Removed the exception", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378864688", "createdAt": "2020-02-13T13:40:30Z", "author": {"login": "1akshitha"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.apache.axiom.om.util.Base64;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.httpclient.HostConfiguration;\n+import org.apache.commons.httpclient.HttpClient;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;\n+import org.apache.commons.httpclient.methods.EntityEnclosingMethod;\n+import org.apache.commons.httpclient.methods.PostMethod;\n+import org.apache.commons.httpclient.methods.PutMethod;\n+import org.apache.commons.httpclient.methods.StringRequestEntity;\n+import org.apache.http.HttpHost;\n+import org.apache.http.conn.params.ConnRoutePNames;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds.ServiceReferenceHolder;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.event.output.adapter.core.EventAdapterUtil;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapter;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterConfiguration;\n+import org.wso2.carbon.event.output.adapter.core.exception.OutputEventAdapterException;\n+import org.wso2.carbon.event.output.adapter.core.exception.TestConnectionNotSupportedException;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+\n+\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+/**\n+ * The recommendation event adapter is used to publish events to recommendation server\n+ */\n+public class ExtendedHTTPEventAdapter implements OutputEventAdapter {\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapter.class);\n+    private OutputEventAdapterConfiguration eventAdapterConfiguration;\n+    private Map<String, String> globalProperties;\n+    private static ExecutorService executorService;\n+    private String clientMethod;\n+    private int tenantId;\n+\n+    private String contentType;\n+    private static HttpConnectionManager connectionManager;\n+    private static HttpClient httpClient = null;\n+    private HostConfiguration hostConfiguration = null;\n+\n+    public ExtendedHTTPEventAdapter(OutputEventAdapterConfiguration eventAdapterConfiguration,\n+                                    Map<String, String> globalProperties) {\n+        this.eventAdapterConfiguration = eventAdapterConfiguration;\n+        this.globalProperties = globalProperties;\n+        this.clientMethod = eventAdapterConfiguration.getStaticProperties()\n+                .get(ExtendedHTTPEventAdapterConstants.ADAPTER_HTTP_CLIENT_METHOD);\n+    }\n+\n+    @Override\n+    public void init() throws OutputEventAdapterException {\n+        tenantId = PrivilegedCarbonContext.getThreadLocalCarbonContext().getTenantId();\n+\n+        //ExecutorService will be assigned  if it is null\n+        if (executorService == null) {\n+            int minThread;\n+            int maxThread;\n+            long defaultKeepAliveTime;\n+            int jobQueSize;\n+\n+            //If global properties are available those will be assigned else constant values will be assigned\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME) != null) {\n+                minThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                minThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME) != null) {\n+                maxThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                maxThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME) != null) {\n+                defaultKeepAliveTime = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME));\n+            } else {\n+                defaultKeepAliveTime = ExtendedHTTPEventAdapterConstants.DEFAULT_KEEP_ALIVE_TIME_IN_MILLIS;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME) != null) {\n+                jobQueSize = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME));\n+            } else {\n+                jobQueSize = ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE;\n+            }\n+            executorService = new ThreadPoolExecutor(minThread, maxThread, defaultKeepAliveTime, TimeUnit.MILLISECONDS,\n+                    new LinkedBlockingQueue<Runnable>(jobQueSize));\n+\n+            //configurations for the httpConnectionManager which will be shared by every http adapter\n+            int defaultMaxConnectionsPerHost;\n+            int maxTotalConnections;\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST) != null) {\n+                defaultMaxConnectionsPerHost = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST));\n+            } else {\n+                defaultMaxConnectionsPerHost = ExtendedHTTPEventAdapterConstants.DEFAULT_DEFAULT_MAX_CONNECTIONS_PER_HOST;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS) != null) {\n+                maxTotalConnections = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS));\n+            } else {\n+                maxTotalConnections = ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_TOTAL_CONNECTIONS;\n+            }\n+\n+            connectionManager = new MultiThreadedHttpConnectionManager();\n+            connectionManager.getParams().setDefaultMaxConnectionsPerHost(defaultMaxConnectionsPerHost);\n+            connectionManager.getParams().setMaxTotalConnections(maxTotalConnections);\n+        }\n+    }\n+\n+    @Override\n+    public void testConnect() throws TestConnectionNotSupportedException {\n+        throw new TestConnectionNotSupportedException(\"Test connection is not available\");\n+    }\n+\n+    @Override\n+    public void connect() {\n+        this.checkHTTPClientInit(eventAdapterConfiguration.getStaticProperties());\n+    }\n+\n+    @Override\n+    public void publish(Object message, Map<String, String> dynamicProperties) {\n+        //Load dynamic properties\n+        String url = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MESSAGE_URL);\n+        String username = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_USERNAME);\n+        String password = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PASSWORD);\n+        String oauthUrl = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_URL);\n+        String consumerKey = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_KEY);\n+        String consumerSecret = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_SECRET);\n+\n+        Map<String, String> headers = this\n+                .extractHeaders(dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_HEADERS));\n+        String payload = message.toString();\n+\n+        try {\n+            if (username != null && password != null) {\n+                executorService.submit(new HTTPSender(url, payload, username, password, headers, httpClient));\n+            } else if(oauthUrl != null && consumerKey != null && consumerSecret != null ) {\n+                String accessToken = ServiceReferenceHolder.getInstance().getAccessTokenGenerator().getAccessToken(oauthUrl,consumerKey,\n+                        consumerSecret);\n+                executorService.submit(new HTTPSender(url, payload, accessToken, headers, httpClient));\n+            }\n+        } catch (RejectedExecutionException e) {\n+            EventAdapterUtil\n+                    .logAndDrop(eventAdapterConfiguration.getName(), message, \"Job queue is full\", e, log, tenantId);\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        //not required\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        //not required\n+    }\n+\n+    @Override\n+    public boolean isPolled() {\n+        return false;\n+    }\n+\n+    private void checkHTTPClientInit(Map<String, String> staticProperties) {\n+\n+        if (this.httpClient != null) {\n+            return;\n+        }\n+\n+        synchronized (ExtendedHTTPEventAdapter.class) {\n+            if (this.httpClient != null) {\n+                return;\n+            }\n+\n+            httpClient = new HttpClient(connectionManager);\n+            String proxyHost = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_HOST);\n+            String proxyPort = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_PORT);\n+            if (proxyHost != null && proxyHost.trim().length() > 0) {\n+                try {\n+                    HttpHost host = new HttpHost(proxyHost, Integer.parseInt(proxyPort));\n+                    this.httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, host);\n+                } catch (NumberFormatException e) {\n+                    log.error(\"Invalid proxy port: \" + proxyPort + \", \"\n+                            + \"ignoring proxy settings for HTTP output event adaptor...\");\n+                }\n+            }\n+\n+            String messageFormat = eventAdapterConfiguration.getMessageFormat();\n+            if (messageFormat.equalsIgnoreCase(\"json\")) {\n+                contentType = \"application/json\";\n+            } else if (messageFormat.equalsIgnoreCase(\"text\")) {\n+                contentType = \"text/plain\";\n+            } else {\n+                contentType = \"text/xml\";\n+            }\n+\n+        }\n+\n+    }\n+\n+    private Map<String, String> extractHeaders(String headers) {\n+        if (headers == null || headers.trim().length() == 0) {\n+            return null;\n+        }\n+\n+        String[] entries = headers.split(ExtendedHTTPEventAdapterConstants.HEADER_SEPARATOR);\n+        String[] keyValue;\n+        Map<String, String> result = new HashMap<String, String>();\n+        for (String header : entries) {\n+            try {\n+                keyValue = header.split(ExtendedHTTPEventAdapterConstants.ENTRY_SEPARATOR, 2);\n+                result.put(keyValue[0].trim(), keyValue[1].trim());\n+            } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1OTk4OA=="}, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 241}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMTk1MTkwOnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwOTo1OTozN1rOFngA5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxMzo0MDo0NlrOFpUEuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2MzMwMw==", "bodyText": "We can use isBlank() or isEmpty() frunction in https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/StringUtils.html", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376963303", "createdAt": "2020-02-10T09:59:37Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.apache.axiom.om.util.Base64;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.httpclient.HostConfiguration;\n+import org.apache.commons.httpclient.HttpClient;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;\n+import org.apache.commons.httpclient.methods.EntityEnclosingMethod;\n+import org.apache.commons.httpclient.methods.PostMethod;\n+import org.apache.commons.httpclient.methods.PutMethod;\n+import org.apache.commons.httpclient.methods.StringRequestEntity;\n+import org.apache.http.HttpHost;\n+import org.apache.http.conn.params.ConnRoutePNames;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds.ServiceReferenceHolder;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.event.output.adapter.core.EventAdapterUtil;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapter;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterConfiguration;\n+import org.wso2.carbon.event.output.adapter.core.exception.OutputEventAdapterException;\n+import org.wso2.carbon.event.output.adapter.core.exception.TestConnectionNotSupportedException;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+\n+\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+/**\n+ * The recommendation event adapter is used to publish events to recommendation server\n+ */\n+public class ExtendedHTTPEventAdapter implements OutputEventAdapter {\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapter.class);\n+    private OutputEventAdapterConfiguration eventAdapterConfiguration;\n+    private Map<String, String> globalProperties;\n+    private static ExecutorService executorService;\n+    private String clientMethod;\n+    private int tenantId;\n+\n+    private String contentType;\n+    private static HttpConnectionManager connectionManager;\n+    private static HttpClient httpClient = null;\n+    private HostConfiguration hostConfiguration = null;\n+\n+    public ExtendedHTTPEventAdapter(OutputEventAdapterConfiguration eventAdapterConfiguration,\n+                                    Map<String, String> globalProperties) {\n+        this.eventAdapterConfiguration = eventAdapterConfiguration;\n+        this.globalProperties = globalProperties;\n+        this.clientMethod = eventAdapterConfiguration.getStaticProperties()\n+                .get(ExtendedHTTPEventAdapterConstants.ADAPTER_HTTP_CLIENT_METHOD);\n+    }\n+\n+    @Override\n+    public void init() throws OutputEventAdapterException {\n+        tenantId = PrivilegedCarbonContext.getThreadLocalCarbonContext().getTenantId();\n+\n+        //ExecutorService will be assigned  if it is null\n+        if (executorService == null) {\n+            int minThread;\n+            int maxThread;\n+            long defaultKeepAliveTime;\n+            int jobQueSize;\n+\n+            //If global properties are available those will be assigned else constant values will be assigned\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME) != null) {\n+                minThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                minThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME) != null) {\n+                maxThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                maxThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME) != null) {\n+                defaultKeepAliveTime = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME));\n+            } else {\n+                defaultKeepAliveTime = ExtendedHTTPEventAdapterConstants.DEFAULT_KEEP_ALIVE_TIME_IN_MILLIS;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME) != null) {\n+                jobQueSize = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME));\n+            } else {\n+                jobQueSize = ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE;\n+            }\n+            executorService = new ThreadPoolExecutor(minThread, maxThread, defaultKeepAliveTime, TimeUnit.MILLISECONDS,\n+                    new LinkedBlockingQueue<Runnable>(jobQueSize));\n+\n+            //configurations for the httpConnectionManager which will be shared by every http adapter\n+            int defaultMaxConnectionsPerHost;\n+            int maxTotalConnections;\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST) != null) {\n+                defaultMaxConnectionsPerHost = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST));\n+            } else {\n+                defaultMaxConnectionsPerHost = ExtendedHTTPEventAdapterConstants.DEFAULT_DEFAULT_MAX_CONNECTIONS_PER_HOST;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS) != null) {\n+                maxTotalConnections = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS));\n+            } else {\n+                maxTotalConnections = ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_TOTAL_CONNECTIONS;\n+            }\n+\n+            connectionManager = new MultiThreadedHttpConnectionManager();\n+            connectionManager.getParams().setDefaultMaxConnectionsPerHost(defaultMaxConnectionsPerHost);\n+            connectionManager.getParams().setMaxTotalConnections(maxTotalConnections);\n+        }\n+    }\n+\n+    @Override\n+    public void testConnect() throws TestConnectionNotSupportedException {\n+        throw new TestConnectionNotSupportedException(\"Test connection is not available\");\n+    }\n+\n+    @Override\n+    public void connect() {\n+        this.checkHTTPClientInit(eventAdapterConfiguration.getStaticProperties());\n+    }\n+\n+    @Override\n+    public void publish(Object message, Map<String, String> dynamicProperties) {\n+        //Load dynamic properties\n+        String url = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MESSAGE_URL);\n+        String username = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_USERNAME);\n+        String password = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PASSWORD);\n+        String oauthUrl = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_URL);\n+        String consumerKey = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_KEY);\n+        String consumerSecret = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_SECRET);\n+\n+        Map<String, String> headers = this\n+                .extractHeaders(dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_HEADERS));\n+        String payload = message.toString();\n+\n+        try {\n+            if (username != null && password != null) {\n+                executorService.submit(new HTTPSender(url, payload, username, password, headers, httpClient));\n+            } else if(oauthUrl != null && consumerKey != null && consumerSecret != null ) {\n+                String accessToken = ServiceReferenceHolder.getInstance().getAccessTokenGenerator().getAccessToken(oauthUrl,consumerKey,\n+                        consumerSecret);\n+                executorService.submit(new HTTPSender(url, payload, accessToken, headers, httpClient));\n+            }\n+        } catch (RejectedExecutionException e) {\n+            EventAdapterUtil\n+                    .logAndDrop(eventAdapterConfiguration.getName(), message, \"Job queue is full\", e, log, tenantId);\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        //not required\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        //not required\n+    }\n+\n+    @Override\n+    public boolean isPolled() {\n+        return false;\n+    }\n+\n+    private void checkHTTPClientInit(Map<String, String> staticProperties) {\n+\n+        if (this.httpClient != null) {\n+            return;\n+        }\n+\n+        synchronized (ExtendedHTTPEventAdapter.class) {\n+            if (this.httpClient != null) {\n+                return;\n+            }\n+\n+            httpClient = new HttpClient(connectionManager);\n+            String proxyHost = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_HOST);\n+            String proxyPort = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_PORT);\n+            if (proxyHost != null && proxyHost.trim().length() > 0) {\n+                try {\n+                    HttpHost host = new HttpHost(proxyHost, Integer.parseInt(proxyPort));\n+                    this.httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, host);\n+                } catch (NumberFormatException e) {\n+                    log.error(\"Invalid proxy port: \" + proxyPort + \", \"\n+                            + \"ignoring proxy settings for HTTP output event adaptor...\");\n+                }\n+            }\n+\n+            String messageFormat = eventAdapterConfiguration.getMessageFormat();\n+            if (messageFormat.equalsIgnoreCase(\"json\")) {\n+                contentType = \"application/json\";\n+            } else if (messageFormat.equalsIgnoreCase(\"text\")) {\n+                contentType = \"text/plain\";\n+            } else {\n+                contentType = \"text/xml\";\n+            }\n+\n+        }\n+\n+    }\n+\n+    private Map<String, String> extractHeaders(String headers) {\n+        if (headers == null || headers.trim().length() == 0) {\n+            return null;\n+        }\n+\n+        String[] entries = headers.split(ExtendedHTTPEventAdapterConstants.HEADER_SEPARATOR);\n+        String[] keyValue;\n+        Map<String, String> result = new HashMap<String, String>();\n+        for (String header : entries) {\n+            try {\n+                keyValue = header.split(ExtendedHTTPEventAdapterConstants.ENTRY_SEPARATOR, 2);\n+                result.put(keyValue[0].trim(), keyValue[1].trim());\n+            } catch (Exception e) {\n+                log.warn(\"Header property '\" + header + \"' is not defined in the correct format.\", e);\n+            }\n+        }\n+        return result;\n+\n+    }\n+\n+    /**\n+     * This class represents a job to send an HTTP request to a target URL.\n+     */\n+    class HTTPSender implements Runnable {\n+\n+        private String url;\n+\n+        private String payload;\n+\n+        private String accessToken;\n+\n+        private String userName;\n+\n+        private String password;\n+\n+        private Map<String, String> headers;\n+\n+        private HttpClient httpClient;\n+\n+        public HTTPSender(String url, String payload, String accessToken, Map<String, String> headers,\n+                          HttpClient httpClient) {\n+            this.url = url;\n+            this.payload = payload;\n+            this.accessToken = accessToken;\n+            this.headers = headers;\n+            this.httpClient = httpClient;\n+        }\n+\n+        /**\n+         * If user name and password is given, basic auth is used. If not OAuth2 is used.\n+         */\n+        public HTTPSender(String url, String payload, String userName, String password, Map<String, String> headers,\n+                          HttpClient httpClient) {\n+            this.url = url;\n+            this.payload = payload;\n+            this.userName = userName;\n+            this.password = password;\n+            this.headers = headers;\n+            this.httpClient = httpClient;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getPayload() {\n+            return payload;\n+        }\n+\n+        public String getAccessToken() {\n+            return accessToken;\n+        }\n+\n+        public Map<String, String> getHeaders() {\n+            return headers;\n+        }\n+\n+        public HttpClient getHttpClient() {\n+            return httpClient;\n+        }\n+\n+        public String getUserName() {\n+            return userName;\n+        }\n+\n+        public String getPassword() {\n+            return password;\n+        }\n+\n+        public void run() {\n+\n+            EntityEnclosingMethod method = null;\n+\n+            try {\n+                if (clientMethod.equalsIgnoreCase(ExtendedHTTPEventAdapterConstants.CONSTANT_HTTP_PUT)) {\n+                    method = new PutMethod(this.getUrl());\n+                } else {\n+                    method = new PostMethod(this.getUrl());\n+                }\n+\n+                if (hostConfiguration == null) {\n+                    URL hostUrl = new URL(this.getUrl());\n+                    hostConfiguration = new HostConfiguration();\n+                    hostConfiguration.setHost(hostUrl.getHost(), hostUrl.getPort(), hostUrl.getProtocol());\n+                }\n+\n+                method.setRequestEntity(new StringRequestEntity(this.getPayload(), contentType, \"UTF-8\"));\n+\n+                if (this.getAccessToken() != null && this.getAccessToken().trim().length() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 337}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg2NDgyNQ==", "bodyText": "Fixed", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378864825", "createdAt": "2020-02-13T13:40:46Z", "author": {"login": "1akshitha"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.apache.axiom.om.util.Base64;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.httpclient.HostConfiguration;\n+import org.apache.commons.httpclient.HttpClient;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;\n+import org.apache.commons.httpclient.methods.EntityEnclosingMethod;\n+import org.apache.commons.httpclient.methods.PostMethod;\n+import org.apache.commons.httpclient.methods.PutMethod;\n+import org.apache.commons.httpclient.methods.StringRequestEntity;\n+import org.apache.http.HttpHost;\n+import org.apache.http.conn.params.ConnRoutePNames;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds.ServiceReferenceHolder;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.event.output.adapter.core.EventAdapterUtil;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapter;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterConfiguration;\n+import org.wso2.carbon.event.output.adapter.core.exception.OutputEventAdapterException;\n+import org.wso2.carbon.event.output.adapter.core.exception.TestConnectionNotSupportedException;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+\n+\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+/**\n+ * The recommendation event adapter is used to publish events to recommendation server\n+ */\n+public class ExtendedHTTPEventAdapter implements OutputEventAdapter {\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapter.class);\n+    private OutputEventAdapterConfiguration eventAdapterConfiguration;\n+    private Map<String, String> globalProperties;\n+    private static ExecutorService executorService;\n+    private String clientMethod;\n+    private int tenantId;\n+\n+    private String contentType;\n+    private static HttpConnectionManager connectionManager;\n+    private static HttpClient httpClient = null;\n+    private HostConfiguration hostConfiguration = null;\n+\n+    public ExtendedHTTPEventAdapter(OutputEventAdapterConfiguration eventAdapterConfiguration,\n+                                    Map<String, String> globalProperties) {\n+        this.eventAdapterConfiguration = eventAdapterConfiguration;\n+        this.globalProperties = globalProperties;\n+        this.clientMethod = eventAdapterConfiguration.getStaticProperties()\n+                .get(ExtendedHTTPEventAdapterConstants.ADAPTER_HTTP_CLIENT_METHOD);\n+    }\n+\n+    @Override\n+    public void init() throws OutputEventAdapterException {\n+        tenantId = PrivilegedCarbonContext.getThreadLocalCarbonContext().getTenantId();\n+\n+        //ExecutorService will be assigned  if it is null\n+        if (executorService == null) {\n+            int minThread;\n+            int maxThread;\n+            long defaultKeepAliveTime;\n+            int jobQueSize;\n+\n+            //If global properties are available those will be assigned else constant values will be assigned\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME) != null) {\n+                minThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                minThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME) != null) {\n+                maxThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                maxThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME) != null) {\n+                defaultKeepAliveTime = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME));\n+            } else {\n+                defaultKeepAliveTime = ExtendedHTTPEventAdapterConstants.DEFAULT_KEEP_ALIVE_TIME_IN_MILLIS;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME) != null) {\n+                jobQueSize = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME));\n+            } else {\n+                jobQueSize = ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE;\n+            }\n+            executorService = new ThreadPoolExecutor(minThread, maxThread, defaultKeepAliveTime, TimeUnit.MILLISECONDS,\n+                    new LinkedBlockingQueue<Runnable>(jobQueSize));\n+\n+            //configurations for the httpConnectionManager which will be shared by every http adapter\n+            int defaultMaxConnectionsPerHost;\n+            int maxTotalConnections;\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST) != null) {\n+                defaultMaxConnectionsPerHost = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST));\n+            } else {\n+                defaultMaxConnectionsPerHost = ExtendedHTTPEventAdapterConstants.DEFAULT_DEFAULT_MAX_CONNECTIONS_PER_HOST;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS) != null) {\n+                maxTotalConnections = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS));\n+            } else {\n+                maxTotalConnections = ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_TOTAL_CONNECTIONS;\n+            }\n+\n+            connectionManager = new MultiThreadedHttpConnectionManager();\n+            connectionManager.getParams().setDefaultMaxConnectionsPerHost(defaultMaxConnectionsPerHost);\n+            connectionManager.getParams().setMaxTotalConnections(maxTotalConnections);\n+        }\n+    }\n+\n+    @Override\n+    public void testConnect() throws TestConnectionNotSupportedException {\n+        throw new TestConnectionNotSupportedException(\"Test connection is not available\");\n+    }\n+\n+    @Override\n+    public void connect() {\n+        this.checkHTTPClientInit(eventAdapterConfiguration.getStaticProperties());\n+    }\n+\n+    @Override\n+    public void publish(Object message, Map<String, String> dynamicProperties) {\n+        //Load dynamic properties\n+        String url = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MESSAGE_URL);\n+        String username = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_USERNAME);\n+        String password = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PASSWORD);\n+        String oauthUrl = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_URL);\n+        String consumerKey = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_KEY);\n+        String consumerSecret = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_SECRET);\n+\n+        Map<String, String> headers = this\n+                .extractHeaders(dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_HEADERS));\n+        String payload = message.toString();\n+\n+        try {\n+            if (username != null && password != null) {\n+                executorService.submit(new HTTPSender(url, payload, username, password, headers, httpClient));\n+            } else if(oauthUrl != null && consumerKey != null && consumerSecret != null ) {\n+                String accessToken = ServiceReferenceHolder.getInstance().getAccessTokenGenerator().getAccessToken(oauthUrl,consumerKey,\n+                        consumerSecret);\n+                executorService.submit(new HTTPSender(url, payload, accessToken, headers, httpClient));\n+            }\n+        } catch (RejectedExecutionException e) {\n+            EventAdapterUtil\n+                    .logAndDrop(eventAdapterConfiguration.getName(), message, \"Job queue is full\", e, log, tenantId);\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        //not required\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        //not required\n+    }\n+\n+    @Override\n+    public boolean isPolled() {\n+        return false;\n+    }\n+\n+    private void checkHTTPClientInit(Map<String, String> staticProperties) {\n+\n+        if (this.httpClient != null) {\n+            return;\n+        }\n+\n+        synchronized (ExtendedHTTPEventAdapter.class) {\n+            if (this.httpClient != null) {\n+                return;\n+            }\n+\n+            httpClient = new HttpClient(connectionManager);\n+            String proxyHost = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_HOST);\n+            String proxyPort = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_PORT);\n+            if (proxyHost != null && proxyHost.trim().length() > 0) {\n+                try {\n+                    HttpHost host = new HttpHost(proxyHost, Integer.parseInt(proxyPort));\n+                    this.httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, host);\n+                } catch (NumberFormatException e) {\n+                    log.error(\"Invalid proxy port: \" + proxyPort + \", \"\n+                            + \"ignoring proxy settings for HTTP output event adaptor...\");\n+                }\n+            }\n+\n+            String messageFormat = eventAdapterConfiguration.getMessageFormat();\n+            if (messageFormat.equalsIgnoreCase(\"json\")) {\n+                contentType = \"application/json\";\n+            } else if (messageFormat.equalsIgnoreCase(\"text\")) {\n+                contentType = \"text/plain\";\n+            } else {\n+                contentType = \"text/xml\";\n+            }\n+\n+        }\n+\n+    }\n+\n+    private Map<String, String> extractHeaders(String headers) {\n+        if (headers == null || headers.trim().length() == 0) {\n+            return null;\n+        }\n+\n+        String[] entries = headers.split(ExtendedHTTPEventAdapterConstants.HEADER_SEPARATOR);\n+        String[] keyValue;\n+        Map<String, String> result = new HashMap<String, String>();\n+        for (String header : entries) {\n+            try {\n+                keyValue = header.split(ExtendedHTTPEventAdapterConstants.ENTRY_SEPARATOR, 2);\n+                result.put(keyValue[0].trim(), keyValue[1].trim());\n+            } catch (Exception e) {\n+                log.warn(\"Header property '\" + header + \"' is not defined in the correct format.\", e);\n+            }\n+        }\n+        return result;\n+\n+    }\n+\n+    /**\n+     * This class represents a job to send an HTTP request to a target URL.\n+     */\n+    class HTTPSender implements Runnable {\n+\n+        private String url;\n+\n+        private String payload;\n+\n+        private String accessToken;\n+\n+        private String userName;\n+\n+        private String password;\n+\n+        private Map<String, String> headers;\n+\n+        private HttpClient httpClient;\n+\n+        public HTTPSender(String url, String payload, String accessToken, Map<String, String> headers,\n+                          HttpClient httpClient) {\n+            this.url = url;\n+            this.payload = payload;\n+            this.accessToken = accessToken;\n+            this.headers = headers;\n+            this.httpClient = httpClient;\n+        }\n+\n+        /**\n+         * If user name and password is given, basic auth is used. If not OAuth2 is used.\n+         */\n+        public HTTPSender(String url, String payload, String userName, String password, Map<String, String> headers,\n+                          HttpClient httpClient) {\n+            this.url = url;\n+            this.payload = payload;\n+            this.userName = userName;\n+            this.password = password;\n+            this.headers = headers;\n+            this.httpClient = httpClient;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getPayload() {\n+            return payload;\n+        }\n+\n+        public String getAccessToken() {\n+            return accessToken;\n+        }\n+\n+        public Map<String, String> getHeaders() {\n+            return headers;\n+        }\n+\n+        public HttpClient getHttpClient() {\n+            return httpClient;\n+        }\n+\n+        public String getUserName() {\n+            return userName;\n+        }\n+\n+        public String getPassword() {\n+            return password;\n+        }\n+\n+        public void run() {\n+\n+            EntityEnclosingMethod method = null;\n+\n+            try {\n+                if (clientMethod.equalsIgnoreCase(ExtendedHTTPEventAdapterConstants.CONSTANT_HTTP_PUT)) {\n+                    method = new PutMethod(this.getUrl());\n+                } else {\n+                    method = new PostMethod(this.getUrl());\n+                }\n+\n+                if (hostConfiguration == null) {\n+                    URL hostUrl = new URL(this.getUrl());\n+                    hostConfiguration = new HostConfiguration();\n+                    hostConfiguration.setHost(hostUrl.getHost(), hostUrl.getPort(), hostUrl.getProtocol());\n+                }\n+\n+                method.setRequestEntity(new StringRequestEntity(this.getPayload(), contentType, \"UTF-8\"));\n+\n+                if (this.getAccessToken() != null && this.getAccessToken().trim().length() > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2MzMwMw=="}, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 337}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMTk1Mzg3OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxMDowMDoxMlrOFngCGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNDozMDowN1rOFpV5fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2MzYwOA==", "bodyText": "please use constants for security schemes.", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376963608", "createdAt": "2020-02-10T10:00:12Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.apache.axiom.om.util.Base64;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.httpclient.HostConfiguration;\n+import org.apache.commons.httpclient.HttpClient;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;\n+import org.apache.commons.httpclient.methods.EntityEnclosingMethod;\n+import org.apache.commons.httpclient.methods.PostMethod;\n+import org.apache.commons.httpclient.methods.PutMethod;\n+import org.apache.commons.httpclient.methods.StringRequestEntity;\n+import org.apache.http.HttpHost;\n+import org.apache.http.conn.params.ConnRoutePNames;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds.ServiceReferenceHolder;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.event.output.adapter.core.EventAdapterUtil;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapter;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterConfiguration;\n+import org.wso2.carbon.event.output.adapter.core.exception.OutputEventAdapterException;\n+import org.wso2.carbon.event.output.adapter.core.exception.TestConnectionNotSupportedException;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+\n+\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+/**\n+ * The recommendation event adapter is used to publish events to recommendation server\n+ */\n+public class ExtendedHTTPEventAdapter implements OutputEventAdapter {\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapter.class);\n+    private OutputEventAdapterConfiguration eventAdapterConfiguration;\n+    private Map<String, String> globalProperties;\n+    private static ExecutorService executorService;\n+    private String clientMethod;\n+    private int tenantId;\n+\n+    private String contentType;\n+    private static HttpConnectionManager connectionManager;\n+    private static HttpClient httpClient = null;\n+    private HostConfiguration hostConfiguration = null;\n+\n+    public ExtendedHTTPEventAdapter(OutputEventAdapterConfiguration eventAdapterConfiguration,\n+                                    Map<String, String> globalProperties) {\n+        this.eventAdapterConfiguration = eventAdapterConfiguration;\n+        this.globalProperties = globalProperties;\n+        this.clientMethod = eventAdapterConfiguration.getStaticProperties()\n+                .get(ExtendedHTTPEventAdapterConstants.ADAPTER_HTTP_CLIENT_METHOD);\n+    }\n+\n+    @Override\n+    public void init() throws OutputEventAdapterException {\n+        tenantId = PrivilegedCarbonContext.getThreadLocalCarbonContext().getTenantId();\n+\n+        //ExecutorService will be assigned  if it is null\n+        if (executorService == null) {\n+            int minThread;\n+            int maxThread;\n+            long defaultKeepAliveTime;\n+            int jobQueSize;\n+\n+            //If global properties are available those will be assigned else constant values will be assigned\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME) != null) {\n+                minThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                minThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME) != null) {\n+                maxThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                maxThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME) != null) {\n+                defaultKeepAliveTime = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME));\n+            } else {\n+                defaultKeepAliveTime = ExtendedHTTPEventAdapterConstants.DEFAULT_KEEP_ALIVE_TIME_IN_MILLIS;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME) != null) {\n+                jobQueSize = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME));\n+            } else {\n+                jobQueSize = ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE;\n+            }\n+            executorService = new ThreadPoolExecutor(minThread, maxThread, defaultKeepAliveTime, TimeUnit.MILLISECONDS,\n+                    new LinkedBlockingQueue<Runnable>(jobQueSize));\n+\n+            //configurations for the httpConnectionManager which will be shared by every http adapter\n+            int defaultMaxConnectionsPerHost;\n+            int maxTotalConnections;\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST) != null) {\n+                defaultMaxConnectionsPerHost = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST));\n+            } else {\n+                defaultMaxConnectionsPerHost = ExtendedHTTPEventAdapterConstants.DEFAULT_DEFAULT_MAX_CONNECTIONS_PER_HOST;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS) != null) {\n+                maxTotalConnections = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS));\n+            } else {\n+                maxTotalConnections = ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_TOTAL_CONNECTIONS;\n+            }\n+\n+            connectionManager = new MultiThreadedHttpConnectionManager();\n+            connectionManager.getParams().setDefaultMaxConnectionsPerHost(defaultMaxConnectionsPerHost);\n+            connectionManager.getParams().setMaxTotalConnections(maxTotalConnections);\n+        }\n+    }\n+\n+    @Override\n+    public void testConnect() throws TestConnectionNotSupportedException {\n+        throw new TestConnectionNotSupportedException(\"Test connection is not available\");\n+    }\n+\n+    @Override\n+    public void connect() {\n+        this.checkHTTPClientInit(eventAdapterConfiguration.getStaticProperties());\n+    }\n+\n+    @Override\n+    public void publish(Object message, Map<String, String> dynamicProperties) {\n+        //Load dynamic properties\n+        String url = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MESSAGE_URL);\n+        String username = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_USERNAME);\n+        String password = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PASSWORD);\n+        String oauthUrl = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_URL);\n+        String consumerKey = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_KEY);\n+        String consumerSecret = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_SECRET);\n+\n+        Map<String, String> headers = this\n+                .extractHeaders(dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_HEADERS));\n+        String payload = message.toString();\n+\n+        try {\n+            if (username != null && password != null) {\n+                executorService.submit(new HTTPSender(url, payload, username, password, headers, httpClient));\n+            } else if(oauthUrl != null && consumerKey != null && consumerSecret != null ) {\n+                String accessToken = ServiceReferenceHolder.getInstance().getAccessTokenGenerator().getAccessToken(oauthUrl,consumerKey,\n+                        consumerSecret);\n+                executorService.submit(new HTTPSender(url, payload, accessToken, headers, httpClient));\n+            }\n+        } catch (RejectedExecutionException e) {\n+            EventAdapterUtil\n+                    .logAndDrop(eventAdapterConfiguration.getName(), message, \"Job queue is full\", e, log, tenantId);\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        //not required\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        //not required\n+    }\n+\n+    @Override\n+    public boolean isPolled() {\n+        return false;\n+    }\n+\n+    private void checkHTTPClientInit(Map<String, String> staticProperties) {\n+\n+        if (this.httpClient != null) {\n+            return;\n+        }\n+\n+        synchronized (ExtendedHTTPEventAdapter.class) {\n+            if (this.httpClient != null) {\n+                return;\n+            }\n+\n+            httpClient = new HttpClient(connectionManager);\n+            String proxyHost = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_HOST);\n+            String proxyPort = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_PORT);\n+            if (proxyHost != null && proxyHost.trim().length() > 0) {\n+                try {\n+                    HttpHost host = new HttpHost(proxyHost, Integer.parseInt(proxyPort));\n+                    this.httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, host);\n+                } catch (NumberFormatException e) {\n+                    log.error(\"Invalid proxy port: \" + proxyPort + \", \"\n+                            + \"ignoring proxy settings for HTTP output event adaptor...\");\n+                }\n+            }\n+\n+            String messageFormat = eventAdapterConfiguration.getMessageFormat();\n+            if (messageFormat.equalsIgnoreCase(\"json\")) {\n+                contentType = \"application/json\";\n+            } else if (messageFormat.equalsIgnoreCase(\"text\")) {\n+                contentType = \"text/plain\";\n+            } else {\n+                contentType = \"text/xml\";\n+            }\n+\n+        }\n+\n+    }\n+\n+    private Map<String, String> extractHeaders(String headers) {\n+        if (headers == null || headers.trim().length() == 0) {\n+            return null;\n+        }\n+\n+        String[] entries = headers.split(ExtendedHTTPEventAdapterConstants.HEADER_SEPARATOR);\n+        String[] keyValue;\n+        Map<String, String> result = new HashMap<String, String>();\n+        for (String header : entries) {\n+            try {\n+                keyValue = header.split(ExtendedHTTPEventAdapterConstants.ENTRY_SEPARATOR, 2);\n+                result.put(keyValue[0].trim(), keyValue[1].trim());\n+            } catch (Exception e) {\n+                log.warn(\"Header property '\" + header + \"' is not defined in the correct format.\", e);\n+            }\n+        }\n+        return result;\n+\n+    }\n+\n+    /**\n+     * This class represents a job to send an HTTP request to a target URL.\n+     */\n+    class HTTPSender implements Runnable {\n+\n+        private String url;\n+\n+        private String payload;\n+\n+        private String accessToken;\n+\n+        private String userName;\n+\n+        private String password;\n+\n+        private Map<String, String> headers;\n+\n+        private HttpClient httpClient;\n+\n+        public HTTPSender(String url, String payload, String accessToken, Map<String, String> headers,\n+                          HttpClient httpClient) {\n+            this.url = url;\n+            this.payload = payload;\n+            this.accessToken = accessToken;\n+            this.headers = headers;\n+            this.httpClient = httpClient;\n+        }\n+\n+        /**\n+         * If user name and password is given, basic auth is used. If not OAuth2 is used.\n+         */\n+        public HTTPSender(String url, String payload, String userName, String password, Map<String, String> headers,\n+                          HttpClient httpClient) {\n+            this.url = url;\n+            this.payload = payload;\n+            this.userName = userName;\n+            this.password = password;\n+            this.headers = headers;\n+            this.httpClient = httpClient;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getPayload() {\n+            return payload;\n+        }\n+\n+        public String getAccessToken() {\n+            return accessToken;\n+        }\n+\n+        public Map<String, String> getHeaders() {\n+            return headers;\n+        }\n+\n+        public HttpClient getHttpClient() {\n+            return httpClient;\n+        }\n+\n+        public String getUserName() {\n+            return userName;\n+        }\n+\n+        public String getPassword() {\n+            return password;\n+        }\n+\n+        public void run() {\n+\n+            EntityEnclosingMethod method = null;\n+\n+            try {\n+                if (clientMethod.equalsIgnoreCase(ExtendedHTTPEventAdapterConstants.CONSTANT_HTTP_PUT)) {\n+                    method = new PutMethod(this.getUrl());\n+                } else {\n+                    method = new PostMethod(this.getUrl());\n+                }\n+\n+                if (hostConfiguration == null) {\n+                    URL hostUrl = new URL(this.getUrl());\n+                    hostConfiguration = new HostConfiguration();\n+                    hostConfiguration.setHost(hostUrl.getHost(), hostUrl.getPort(), hostUrl.getProtocol());\n+                }\n+\n+                method.setRequestEntity(new StringRequestEntity(this.getPayload(), contentType, \"UTF-8\"));\n+\n+                if (this.getAccessToken() != null && this.getAccessToken().trim().length() > 0) {\n+                    method.setRequestHeader(\"Authorization\", \"Bearer \" + this.getAccessToken());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 338}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg5NDcxOA==", "bodyText": "Fixed", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378894718", "createdAt": "2020-02-13T14:30:07Z", "author": {"login": "1akshitha"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.apache.axiom.om.util.Base64;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.httpclient.HostConfiguration;\n+import org.apache.commons.httpclient.HttpClient;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;\n+import org.apache.commons.httpclient.methods.EntityEnclosingMethod;\n+import org.apache.commons.httpclient.methods.PostMethod;\n+import org.apache.commons.httpclient.methods.PutMethod;\n+import org.apache.commons.httpclient.methods.StringRequestEntity;\n+import org.apache.http.HttpHost;\n+import org.apache.http.conn.params.ConnRoutePNames;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds.ServiceReferenceHolder;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.event.output.adapter.core.EventAdapterUtil;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapter;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterConfiguration;\n+import org.wso2.carbon.event.output.adapter.core.exception.OutputEventAdapterException;\n+import org.wso2.carbon.event.output.adapter.core.exception.TestConnectionNotSupportedException;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+\n+\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+/**\n+ * The recommendation event adapter is used to publish events to recommendation server\n+ */\n+public class ExtendedHTTPEventAdapter implements OutputEventAdapter {\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapter.class);\n+    private OutputEventAdapterConfiguration eventAdapterConfiguration;\n+    private Map<String, String> globalProperties;\n+    private static ExecutorService executorService;\n+    private String clientMethod;\n+    private int tenantId;\n+\n+    private String contentType;\n+    private static HttpConnectionManager connectionManager;\n+    private static HttpClient httpClient = null;\n+    private HostConfiguration hostConfiguration = null;\n+\n+    public ExtendedHTTPEventAdapter(OutputEventAdapterConfiguration eventAdapterConfiguration,\n+                                    Map<String, String> globalProperties) {\n+        this.eventAdapterConfiguration = eventAdapterConfiguration;\n+        this.globalProperties = globalProperties;\n+        this.clientMethod = eventAdapterConfiguration.getStaticProperties()\n+                .get(ExtendedHTTPEventAdapterConstants.ADAPTER_HTTP_CLIENT_METHOD);\n+    }\n+\n+    @Override\n+    public void init() throws OutputEventAdapterException {\n+        tenantId = PrivilegedCarbonContext.getThreadLocalCarbonContext().getTenantId();\n+\n+        //ExecutorService will be assigned  if it is null\n+        if (executorService == null) {\n+            int minThread;\n+            int maxThread;\n+            long defaultKeepAliveTime;\n+            int jobQueSize;\n+\n+            //If global properties are available those will be assigned else constant values will be assigned\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME) != null) {\n+                minThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                minThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME) != null) {\n+                maxThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                maxThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME) != null) {\n+                defaultKeepAliveTime = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME));\n+            } else {\n+                defaultKeepAliveTime = ExtendedHTTPEventAdapterConstants.DEFAULT_KEEP_ALIVE_TIME_IN_MILLIS;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME) != null) {\n+                jobQueSize = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME));\n+            } else {\n+                jobQueSize = ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE;\n+            }\n+            executorService = new ThreadPoolExecutor(minThread, maxThread, defaultKeepAliveTime, TimeUnit.MILLISECONDS,\n+                    new LinkedBlockingQueue<Runnable>(jobQueSize));\n+\n+            //configurations for the httpConnectionManager which will be shared by every http adapter\n+            int defaultMaxConnectionsPerHost;\n+            int maxTotalConnections;\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST) != null) {\n+                defaultMaxConnectionsPerHost = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST));\n+            } else {\n+                defaultMaxConnectionsPerHost = ExtendedHTTPEventAdapterConstants.DEFAULT_DEFAULT_MAX_CONNECTIONS_PER_HOST;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS) != null) {\n+                maxTotalConnections = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS));\n+            } else {\n+                maxTotalConnections = ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_TOTAL_CONNECTIONS;\n+            }\n+\n+            connectionManager = new MultiThreadedHttpConnectionManager();\n+            connectionManager.getParams().setDefaultMaxConnectionsPerHost(defaultMaxConnectionsPerHost);\n+            connectionManager.getParams().setMaxTotalConnections(maxTotalConnections);\n+        }\n+    }\n+\n+    @Override\n+    public void testConnect() throws TestConnectionNotSupportedException {\n+        throw new TestConnectionNotSupportedException(\"Test connection is not available\");\n+    }\n+\n+    @Override\n+    public void connect() {\n+        this.checkHTTPClientInit(eventAdapterConfiguration.getStaticProperties());\n+    }\n+\n+    @Override\n+    public void publish(Object message, Map<String, String> dynamicProperties) {\n+        //Load dynamic properties\n+        String url = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MESSAGE_URL);\n+        String username = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_USERNAME);\n+        String password = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PASSWORD);\n+        String oauthUrl = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_URL);\n+        String consumerKey = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_KEY);\n+        String consumerSecret = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_SECRET);\n+\n+        Map<String, String> headers = this\n+                .extractHeaders(dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_HEADERS));\n+        String payload = message.toString();\n+\n+        try {\n+            if (username != null && password != null) {\n+                executorService.submit(new HTTPSender(url, payload, username, password, headers, httpClient));\n+            } else if(oauthUrl != null && consumerKey != null && consumerSecret != null ) {\n+                String accessToken = ServiceReferenceHolder.getInstance().getAccessTokenGenerator().getAccessToken(oauthUrl,consumerKey,\n+                        consumerSecret);\n+                executorService.submit(new HTTPSender(url, payload, accessToken, headers, httpClient));\n+            }\n+        } catch (RejectedExecutionException e) {\n+            EventAdapterUtil\n+                    .logAndDrop(eventAdapterConfiguration.getName(), message, \"Job queue is full\", e, log, tenantId);\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        //not required\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        //not required\n+    }\n+\n+    @Override\n+    public boolean isPolled() {\n+        return false;\n+    }\n+\n+    private void checkHTTPClientInit(Map<String, String> staticProperties) {\n+\n+        if (this.httpClient != null) {\n+            return;\n+        }\n+\n+        synchronized (ExtendedHTTPEventAdapter.class) {\n+            if (this.httpClient != null) {\n+                return;\n+            }\n+\n+            httpClient = new HttpClient(connectionManager);\n+            String proxyHost = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_HOST);\n+            String proxyPort = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_PORT);\n+            if (proxyHost != null && proxyHost.trim().length() > 0) {\n+                try {\n+                    HttpHost host = new HttpHost(proxyHost, Integer.parseInt(proxyPort));\n+                    this.httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, host);\n+                } catch (NumberFormatException e) {\n+                    log.error(\"Invalid proxy port: \" + proxyPort + \", \"\n+                            + \"ignoring proxy settings for HTTP output event adaptor...\");\n+                }\n+            }\n+\n+            String messageFormat = eventAdapterConfiguration.getMessageFormat();\n+            if (messageFormat.equalsIgnoreCase(\"json\")) {\n+                contentType = \"application/json\";\n+            } else if (messageFormat.equalsIgnoreCase(\"text\")) {\n+                contentType = \"text/plain\";\n+            } else {\n+                contentType = \"text/xml\";\n+            }\n+\n+        }\n+\n+    }\n+\n+    private Map<String, String> extractHeaders(String headers) {\n+        if (headers == null || headers.trim().length() == 0) {\n+            return null;\n+        }\n+\n+        String[] entries = headers.split(ExtendedHTTPEventAdapterConstants.HEADER_SEPARATOR);\n+        String[] keyValue;\n+        Map<String, String> result = new HashMap<String, String>();\n+        for (String header : entries) {\n+            try {\n+                keyValue = header.split(ExtendedHTTPEventAdapterConstants.ENTRY_SEPARATOR, 2);\n+                result.put(keyValue[0].trim(), keyValue[1].trim());\n+            } catch (Exception e) {\n+                log.warn(\"Header property '\" + header + \"' is not defined in the correct format.\", e);\n+            }\n+        }\n+        return result;\n+\n+    }\n+\n+    /**\n+     * This class represents a job to send an HTTP request to a target URL.\n+     */\n+    class HTTPSender implements Runnable {\n+\n+        private String url;\n+\n+        private String payload;\n+\n+        private String accessToken;\n+\n+        private String userName;\n+\n+        private String password;\n+\n+        private Map<String, String> headers;\n+\n+        private HttpClient httpClient;\n+\n+        public HTTPSender(String url, String payload, String accessToken, Map<String, String> headers,\n+                          HttpClient httpClient) {\n+            this.url = url;\n+            this.payload = payload;\n+            this.accessToken = accessToken;\n+            this.headers = headers;\n+            this.httpClient = httpClient;\n+        }\n+\n+        /**\n+         * If user name and password is given, basic auth is used. If not OAuth2 is used.\n+         */\n+        public HTTPSender(String url, String payload, String userName, String password, Map<String, String> headers,\n+                          HttpClient httpClient) {\n+            this.url = url;\n+            this.payload = payload;\n+            this.userName = userName;\n+            this.password = password;\n+            this.headers = headers;\n+            this.httpClient = httpClient;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getPayload() {\n+            return payload;\n+        }\n+\n+        public String getAccessToken() {\n+            return accessToken;\n+        }\n+\n+        public Map<String, String> getHeaders() {\n+            return headers;\n+        }\n+\n+        public HttpClient getHttpClient() {\n+            return httpClient;\n+        }\n+\n+        public String getUserName() {\n+            return userName;\n+        }\n+\n+        public String getPassword() {\n+            return password;\n+        }\n+\n+        public void run() {\n+\n+            EntityEnclosingMethod method = null;\n+\n+            try {\n+                if (clientMethod.equalsIgnoreCase(ExtendedHTTPEventAdapterConstants.CONSTANT_HTTP_PUT)) {\n+                    method = new PutMethod(this.getUrl());\n+                } else {\n+                    method = new PostMethod(this.getUrl());\n+                }\n+\n+                if (hostConfiguration == null) {\n+                    URL hostUrl = new URL(this.getUrl());\n+                    hostConfiguration = new HostConfiguration();\n+                    hostConfiguration.setHost(hostUrl.getHost(), hostUrl.getPort(), hostUrl.getProtocol());\n+                }\n+\n+                method.setRequestEntity(new StringRequestEntity(this.getPayload(), contentType, \"UTF-8\"));\n+\n+                if (this.getAccessToken() != null && this.getAccessToken().trim().length() > 0) {\n+                    method.setRequestHeader(\"Authorization\", \"Bearer \" + this.getAccessToken());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2MzYwOA=="}, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 338}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMTk1NzM5OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/internal/ds/ExtendedHTTPEventAdapterServiceDS.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxMDowMTowMVrOFngEGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNDozMDoyNVrOFpV6OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2NDEyMw==", "bodyText": "Please mention the reason to use generic exception", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376964123", "createdAt": "2020-02-10T10:01:01Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/internal/ds/ExtendedHTTPEventAdapterServiceDS.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ReferenceCardinality;\n+import org.osgi.service.component.annotations.ReferencePolicy;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.ExtendedHTTPEventAdapterFactory;\n+import org.wso2.carbon.apimgt.impl.recommendationmgt.AccessTokenGenerator;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterFactory;\n+\n+@Component(\n+        name = \"output.http.extended.AdapterService.component\",\n+        immediate = true)\n+public class ExtendedHTTPEventAdapterServiceDS {\n+\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapterServiceDS.class);\n+\n+    @Activate\n+    protected void activate(ComponentContext context) {\n+\n+        try {\n+            ExtendedHTTPEventAdapterFactory extendedHttpEventAdaptorFactory = new ExtendedHTTPEventAdapterFactory();\n+            BundleContext bundleContext = context.getBundleContext();\n+            bundleContext.registerService(OutputEventAdapterFactory.class.getName(),\n+                    extendedHttpEventAdaptorFactory, null);\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Successfully deployed the Extended Http event adaptor service\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"Can not create the Extended Http event event adaptor service: \" + e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg5NDkwNQ==", "bodyText": "Removed the unnecessary try-catch block", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378894905", "createdAt": "2020-02-13T14:30:25Z", "author": {"login": "1akshitha"}, "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/internal/ds/ExtendedHTTPEventAdapterServiceDS.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ReferenceCardinality;\n+import org.osgi.service.component.annotations.ReferencePolicy;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.ExtendedHTTPEventAdapterFactory;\n+import org.wso2.carbon.apimgt.impl.recommendationmgt.AccessTokenGenerator;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterFactory;\n+\n+@Component(\n+        name = \"output.http.extended.AdapterService.component\",\n+        immediate = true)\n+public class ExtendedHTTPEventAdapterServiceDS {\n+\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapterServiceDS.class);\n+\n+    @Activate\n+    protected void activate(ComponentContext context) {\n+\n+        try {\n+            ExtendedHTTPEventAdapterFactory extendedHttpEventAdaptorFactory = new ExtendedHTTPEventAdapterFactory();\n+            BundleContext bundleContext = context.getBundleContext();\n+            bundleContext.registerService(OutputEventAdapterFactory.class.getName(),\n+                    extendedHttpEventAdaptorFactory, null);\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Successfully deployed the Extended Http event adaptor service\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"Can not create the Extended Http event event adaptor service: \" + e.getMessage(), e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2NDEyMw=="}, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMTk2MDk1OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIConsumerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxMDowMjowOFrOFngGYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxMzo0MToxOFrOFpUF8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2NDcwNQ==", "bodyText": "please use constants", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376964705", "createdAt": "2020-02-10T10:02:08Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIConsumerImpl.java", "diffHunk": "@@ -5758,54 +5763,92 @@ public void publishClickedAPI(ApiTypeWrapper clickedApi, String username) {\n         }\n     }\n \n-    public boolean isRecommendationEnabled() {\n-        boolean recommendationEnabled = false;\n+    /**\n+     * To check whether the API recommendation is enabled. It can be either enabled globally or tenant vice.\n+     *\n+     * @param tenantDomain Tenant domain\n+     * @return whether recommendation is enabled or not\n+     */\n+\n+    public boolean isRecommendationEnabled(String tenantDomain) {\n \n         if (recommendationEnvironment != null) {\n-            recommendationEnabled = true;\n+            if (recommendationEnvironment.isApplyForAllTenants()) {\n+                return true;\n+            } else {\n+                try {\n+                    String content = apimRegistryService\n+                            .getConfigRegistryResourceContent(tenantDomain, APIConstants.API_TENANT_CONF_LOCATION);\n+                    if (content != null) {\n+                        org.json.JSONObject apiTenantConfig = new org.json.JSONObject(content);\n+                        if (apiTenantConfig != null) {\n+                            if (apiTenantConfig.has(APIConstants.API_TENANT_CONF_ENABLE_RECOMMENDATION_KEY)) {\n+                                Object value = apiTenantConfig.get(APIConstants.API_TENANT_CONF_ENABLE_RECOMMENDATION_KEY);\n+                                return Boolean.parseBoolean(value.toString());\n+                            }\n+                        }\n+                    }\n+                } catch (UserStoreException | RegistryException e) {\n+                    log.error(\"Error occurred when getting API tenant config from registry\", e);\n+                }\n+            }\n         }\n-        return recommendationEnabled;\n+        return false;\n     }\n \n-    public String getApiRecommendations(String userName) {\n-        if (userName != null && requestedTenant != null && recommendationEnvironment != null) {\n-            String recommendationEndpointURL = recommendationEnvironment.getRecommendationEndpointURL();\n-            String adminUsername = recommendationEnvironment.getUsername();\n-            String adminPassword = recommendationEnvironment.getPassword();\n+    /**\n+     * Get recommendations for the user by connecting with the recommendation engine.\n+     *\n+     * @param userName     User's Name\n+     * @param tenantDomain tenantDomain\n+     * @return List of APIs recommended for the user\n+     */\n+    public String getApiRecommendations(String userName, String tenantDomain) {\n+\n+        if (isRecommendationEnabled(tenantDomain)) {\n+            String recommendationEndpointURL = recommendationEnvironment.getRecommendationServerURL()\n+                    + APIConstants.RECOMMENDATIONS_GET_RESOURCE;\n             try {\n+                String userID = apiMgtDAO.getUserID(userName);\n                 URL serverURL = new URL(recommendationEndpointURL);\n                 int serverPort = serverURL.getPort();\n                 String serverProtocol = serverURL.getProtocol();\n \n                 HttpGet method = new HttpGet(recommendationEndpointURL);\n                 HttpClient httpClient = APIUtil.getHttpClient(serverPort, serverProtocol);\n-\n-                byte[] credentials = org.apache.commons.codec.binary.Base64\n-                        .encodeBase64((adminUsername + \":\" + adminPassword).getBytes(StandardCharsets.UTF_8));\n-\n-                method.setHeader(\"Authorization\", \"Basic \" + new String(credentials, StandardCharsets.UTF_8));\n-                method.setHeader(\"User\", userName);\n-                method.setHeader(\"Account\", requestedTenant);\n+                if (recommendationEnvironment.getOauthURL() != null) {\n+                    String accessToken = AccessTokenGeneratorImpl.getInstance().getAccessToken(\n+                                    recommendationEnvironment.getOauthURL(),\n+                                    recommendationEnvironment.getConsumerKey(),\n+                                    recommendationEnvironment.getConsumerSecret());\n+                    method.setHeader(APIConstants.AUTHORIZATION_HEADER_DEFAULT, \"Bearer \" + accessToken);\n+                } else {\n+                    byte[] credentials = org.apache.commons.codec.binary.Base64.encodeBase64(\n+                            (recommendationEnvironment.getUserName() + \":\" + recommendationEnvironment.getPassword())\n+                                    .getBytes(StandardCharsets.UTF_8));\n+                    method.setHeader(\"Authorization\", \"Basic \" + new String(credentials, StandardCharsets.UTF_8));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg2NTEzOA==", "bodyText": "Fixed", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378865138", "createdAt": "2020-02-13T13:41:18Z", "author": {"login": "1akshitha"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIConsumerImpl.java", "diffHunk": "@@ -5758,54 +5763,92 @@ public void publishClickedAPI(ApiTypeWrapper clickedApi, String username) {\n         }\n     }\n \n-    public boolean isRecommendationEnabled() {\n-        boolean recommendationEnabled = false;\n+    /**\n+     * To check whether the API recommendation is enabled. It can be either enabled globally or tenant vice.\n+     *\n+     * @param tenantDomain Tenant domain\n+     * @return whether recommendation is enabled or not\n+     */\n+\n+    public boolean isRecommendationEnabled(String tenantDomain) {\n \n         if (recommendationEnvironment != null) {\n-            recommendationEnabled = true;\n+            if (recommendationEnvironment.isApplyForAllTenants()) {\n+                return true;\n+            } else {\n+                try {\n+                    String content = apimRegistryService\n+                            .getConfigRegistryResourceContent(tenantDomain, APIConstants.API_TENANT_CONF_LOCATION);\n+                    if (content != null) {\n+                        org.json.JSONObject apiTenantConfig = new org.json.JSONObject(content);\n+                        if (apiTenantConfig != null) {\n+                            if (apiTenantConfig.has(APIConstants.API_TENANT_CONF_ENABLE_RECOMMENDATION_KEY)) {\n+                                Object value = apiTenantConfig.get(APIConstants.API_TENANT_CONF_ENABLE_RECOMMENDATION_KEY);\n+                                return Boolean.parseBoolean(value.toString());\n+                            }\n+                        }\n+                    }\n+                } catch (UserStoreException | RegistryException e) {\n+                    log.error(\"Error occurred when getting API tenant config from registry\", e);\n+                }\n+            }\n         }\n-        return recommendationEnabled;\n+        return false;\n     }\n \n-    public String getApiRecommendations(String userName) {\n-        if (userName != null && requestedTenant != null && recommendationEnvironment != null) {\n-            String recommendationEndpointURL = recommendationEnvironment.getRecommendationEndpointURL();\n-            String adminUsername = recommendationEnvironment.getUsername();\n-            String adminPassword = recommendationEnvironment.getPassword();\n+    /**\n+     * Get recommendations for the user by connecting with the recommendation engine.\n+     *\n+     * @param userName     User's Name\n+     * @param tenantDomain tenantDomain\n+     * @return List of APIs recommended for the user\n+     */\n+    public String getApiRecommendations(String userName, String tenantDomain) {\n+\n+        if (isRecommendationEnabled(tenantDomain)) {\n+            String recommendationEndpointURL = recommendationEnvironment.getRecommendationServerURL()\n+                    + APIConstants.RECOMMENDATIONS_GET_RESOURCE;\n             try {\n+                String userID = apiMgtDAO.getUserID(userName);\n                 URL serverURL = new URL(recommendationEndpointURL);\n                 int serverPort = serverURL.getPort();\n                 String serverProtocol = serverURL.getProtocol();\n \n                 HttpGet method = new HttpGet(recommendationEndpointURL);\n                 HttpClient httpClient = APIUtil.getHttpClient(serverPort, serverProtocol);\n-\n-                byte[] credentials = org.apache.commons.codec.binary.Base64\n-                        .encodeBase64((adminUsername + \":\" + adminPassword).getBytes(StandardCharsets.UTF_8));\n-\n-                method.setHeader(\"Authorization\", \"Basic \" + new String(credentials, StandardCharsets.UTF_8));\n-                method.setHeader(\"User\", userName);\n-                method.setHeader(\"Account\", requestedTenant);\n+                if (recommendationEnvironment.getOauthURL() != null) {\n+                    String accessToken = AccessTokenGeneratorImpl.getInstance().getAccessToken(\n+                                    recommendationEnvironment.getOauthURL(),\n+                                    recommendationEnvironment.getConsumerKey(),\n+                                    recommendationEnvironment.getConsumerSecret());\n+                    method.setHeader(APIConstants.AUTHORIZATION_HEADER_DEFAULT, \"Bearer \" + accessToken);\n+                } else {\n+                    byte[] credentials = org.apache.commons.codec.binary.Base64.encodeBase64(\n+                            (recommendationEnvironment.getUserName() + \":\" + recommendationEnvironment.getPassword())\n+                                    .getBytes(StandardCharsets.UTF_8));\n+                    method.setHeader(\"Authorization\", \"Basic \" + new String(credentials, StandardCharsets.UTF_8));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2NDcwNQ=="}, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMTk2NTQ0OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/recommendationmgt/AccessTokenGeneratorImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxMDowMzozNFrOFngJPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxMzo0MTo0N1rOFpUHCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2NTQzNg==", "bodyText": "please use https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#equals(java.lang.Object) instead of ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376965436", "createdAt": "2020-02-10T10:03:34Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/recommendationmgt/AccessTokenGeneratorImpl.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.impl.recommendationmgt;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.entity.UrlEncodedFormEntity;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.message.BasicNameValuePair;\n+import org.apache.http.util.EntityUtils;\n+import org.json.JSONObject;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class AccessTokenGeneratorImpl implements AccessTokenGenerator {\n+\n+    private static final Log log = LogFactory.getLog(AccessTokenGeneratorImpl.class);\n+\n+    private static volatile AccessTokenGeneratorImpl accessTokenGenerator = null;\n+    long generatedTime = 0;\n+    long validityPeriod = 3600000;\n+    String accessToken = null;\n+    String oauthUrl = null;\n+    String consumerKey = null;\n+    String consumerSecret = null;\n+\n+    public AccessTokenGeneratorImpl() {\n+\n+    }\n+\n+    public static AccessTokenGeneratorImpl getInstance() {\n+\n+        if (accessTokenGenerator == null) {\n+            synchronized (AccessTokenGeneratorImpl.class) {\n+                if (accessTokenGenerator == null) {\n+                    accessTokenGenerator = new AccessTokenGeneratorImpl();\n+                }\n+            }\n+        }\n+        return accessTokenGenerator;\n+    }\n+\n+    @Override\n+    public String getAccessToken(String oauthUrl, String consumerKey, String consumerSecret) {\n+\n+        if (this.oauthUrl == oauthUrl && this.consumerKey == consumerKey && this.consumerSecret == consumerSecret", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg2NTQxOQ==", "bodyText": "Fixed", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378865419", "createdAt": "2020-02-13T13:41:47Z", "author": {"login": "1akshitha"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/recommendationmgt/AccessTokenGeneratorImpl.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.impl.recommendationmgt;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.entity.UrlEncodedFormEntity;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.message.BasicNameValuePair;\n+import org.apache.http.util.EntityUtils;\n+import org.json.JSONObject;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class AccessTokenGeneratorImpl implements AccessTokenGenerator {\n+\n+    private static final Log log = LogFactory.getLog(AccessTokenGeneratorImpl.class);\n+\n+    private static volatile AccessTokenGeneratorImpl accessTokenGenerator = null;\n+    long generatedTime = 0;\n+    long validityPeriod = 3600000;\n+    String accessToken = null;\n+    String oauthUrl = null;\n+    String consumerKey = null;\n+    String consumerSecret = null;\n+\n+    public AccessTokenGeneratorImpl() {\n+\n+    }\n+\n+    public static AccessTokenGeneratorImpl getInstance() {\n+\n+        if (accessTokenGenerator == null) {\n+            synchronized (AccessTokenGeneratorImpl.class) {\n+                if (accessTokenGenerator == null) {\n+                    accessTokenGenerator = new AccessTokenGeneratorImpl();\n+                }\n+            }\n+        }\n+        return accessTokenGenerator;\n+    }\n+\n+    @Override\n+    public String getAccessToken(String oauthUrl, String consumerKey, String consumerSecret) {\n+\n+        if (this.oauthUrl == oauthUrl && this.consumerKey == consumerKey && this.consumerSecret == consumerSecret", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2NTQzNg=="}, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMTk2NzA4OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/recommendationmgt/AccessTokenGeneratorImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxMDowNDowNVrOFngKOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxMzo0MToyN1rOFpUGSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2NTY5MQ==", "bodyText": "Move \"access_token\" to a constant", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376965691", "createdAt": "2020-02-10T10:04:05Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/recommendationmgt/AccessTokenGeneratorImpl.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.impl.recommendationmgt;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.entity.UrlEncodedFormEntity;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.message.BasicNameValuePair;\n+import org.apache.http.util.EntityUtils;\n+import org.json.JSONObject;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class AccessTokenGeneratorImpl implements AccessTokenGenerator {\n+\n+    private static final Log log = LogFactory.getLog(AccessTokenGeneratorImpl.class);\n+\n+    private static volatile AccessTokenGeneratorImpl accessTokenGenerator = null;\n+    long generatedTime = 0;\n+    long validityPeriod = 3600000;\n+    String accessToken = null;\n+    String oauthUrl = null;\n+    String consumerKey = null;\n+    String consumerSecret = null;\n+\n+    public AccessTokenGeneratorImpl() {\n+\n+    }\n+\n+    public static AccessTokenGeneratorImpl getInstance() {\n+\n+        if (accessTokenGenerator == null) {\n+            synchronized (AccessTokenGeneratorImpl.class) {\n+                if (accessTokenGenerator == null) {\n+                    accessTokenGenerator = new AccessTokenGeneratorImpl();\n+                }\n+            }\n+        }\n+        return accessTokenGenerator;\n+    }\n+\n+    @Override\n+    public String getAccessToken(String oauthUrl, String consumerKey, String consumerSecret) {\n+\n+        if (this.oauthUrl == oauthUrl && this.consumerKey == consumerKey && this.consumerSecret == consumerSecret\n+                && this.accessToken != null) {\n+            if (System.currentTimeMillis() > (this.generatedTime + this.validityPeriod)) {\n+                if(log.isDebugEnabled()) {\n+                    log.debug(\"Access token expired. New token requested\");\n+                }\n+                return generateNewAccessToken(oauthUrl, consumerKey, consumerSecret);\n+            } else {\n+                if(log.isDebugEnabled()) {\n+                    log.debug(\"Valid Access Token already available for the provided application\");\n+                }\n+                return this.accessToken;\n+            }\n+        } else {\n+            this.oauthUrl = oauthUrl;\n+            this.consumerKey = consumerKey;\n+            this.consumerSecret = consumerSecret;\n+            if(log.isDebugEnabled()) {\n+                log.debug(\"Valid Access token not found for the application. New token requested\");\n+            }\n+            return generateNewAccessToken(oauthUrl, consumerKey, consumerSecret);\n+        }\n+    }\n+\n+    public String generateNewAccessToken(String oauthUrl, String consumerKey, String consumerSecret) {\n+\n+        if(oauthUrl != null && consumerKey != null && consumerSecret != null) {\n+            try {\n+                URL oauthURL = new URL(oauthUrl);\n+                int serverPort = oauthURL.getPort();\n+                String serverProtocol = oauthURL.getProtocol();\n+\n+                HttpPost request = new HttpPost(oauthUrl);\n+                HttpClient httpClient = APIUtil.getHttpClient(serverPort, serverProtocol);\n+\n+                byte[] credentials = org.apache.commons.codec.binary.Base64\n+                        .encodeBase64((consumerKey + \":\" + consumerSecret).getBytes(StandardCharsets.UTF_8));\n+\n+                request.setHeader(\"Authorization\", \"Basic \" + new String(credentials, StandardCharsets.UTF_8));\n+                request.setHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n+\n+                List<BasicNameValuePair> urlParameters = new ArrayList<>();\n+                urlParameters.add(new BasicNameValuePair(\"grant_type\", \"client_credentials\"));\n+                request.setEntity(new UrlEncodedFormEntity(urlParameters));\n+                HttpResponse httpResponse = httpClient.execute(request);\n+\n+                if (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n+                    String payload = EntityUtils.toString(httpResponse.getEntity());\n+                    JSONObject response = new JSONObject(payload);\n+                    this.accessToken = (String) response.get(\"access_token\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg2NTIyNQ==", "bodyText": "Fixed", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378865225", "createdAt": "2020-02-13T13:41:27Z", "author": {"login": "1akshitha"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/recommendationmgt/AccessTokenGeneratorImpl.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.impl.recommendationmgt;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.entity.UrlEncodedFormEntity;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.message.BasicNameValuePair;\n+import org.apache.http.util.EntityUtils;\n+import org.json.JSONObject;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class AccessTokenGeneratorImpl implements AccessTokenGenerator {\n+\n+    private static final Log log = LogFactory.getLog(AccessTokenGeneratorImpl.class);\n+\n+    private static volatile AccessTokenGeneratorImpl accessTokenGenerator = null;\n+    long generatedTime = 0;\n+    long validityPeriod = 3600000;\n+    String accessToken = null;\n+    String oauthUrl = null;\n+    String consumerKey = null;\n+    String consumerSecret = null;\n+\n+    public AccessTokenGeneratorImpl() {\n+\n+    }\n+\n+    public static AccessTokenGeneratorImpl getInstance() {\n+\n+        if (accessTokenGenerator == null) {\n+            synchronized (AccessTokenGeneratorImpl.class) {\n+                if (accessTokenGenerator == null) {\n+                    accessTokenGenerator = new AccessTokenGeneratorImpl();\n+                }\n+            }\n+        }\n+        return accessTokenGenerator;\n+    }\n+\n+    @Override\n+    public String getAccessToken(String oauthUrl, String consumerKey, String consumerSecret) {\n+\n+        if (this.oauthUrl == oauthUrl && this.consumerKey == consumerKey && this.consumerSecret == consumerSecret\n+                && this.accessToken != null) {\n+            if (System.currentTimeMillis() > (this.generatedTime + this.validityPeriod)) {\n+                if(log.isDebugEnabled()) {\n+                    log.debug(\"Access token expired. New token requested\");\n+                }\n+                return generateNewAccessToken(oauthUrl, consumerKey, consumerSecret);\n+            } else {\n+                if(log.isDebugEnabled()) {\n+                    log.debug(\"Valid Access Token already available for the provided application\");\n+                }\n+                return this.accessToken;\n+            }\n+        } else {\n+            this.oauthUrl = oauthUrl;\n+            this.consumerKey = consumerKey;\n+            this.consumerSecret = consumerSecret;\n+            if(log.isDebugEnabled()) {\n+                log.debug(\"Valid Access token not found for the application. New token requested\");\n+            }\n+            return generateNewAccessToken(oauthUrl, consumerKey, consumerSecret);\n+        }\n+    }\n+\n+    public String generateNewAccessToken(String oauthUrl, String consumerKey, String consumerSecret) {\n+\n+        if(oauthUrl != null && consumerKey != null && consumerSecret != null) {\n+            try {\n+                URL oauthURL = new URL(oauthUrl);\n+                int serverPort = oauthURL.getPort();\n+                String serverProtocol = oauthURL.getProtocol();\n+\n+                HttpPost request = new HttpPost(oauthUrl);\n+                HttpClient httpClient = APIUtil.getHttpClient(serverPort, serverProtocol);\n+\n+                byte[] credentials = org.apache.commons.codec.binary.Base64\n+                        .encodeBase64((consumerKey + \":\" + consumerSecret).getBytes(StandardCharsets.UTF_8));\n+\n+                request.setHeader(\"Authorization\", \"Basic \" + new String(credentials, StandardCharsets.UTF_8));\n+                request.setHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n+\n+                List<BasicNameValuePair> urlParameters = new ArrayList<>();\n+                urlParameters.add(new BasicNameValuePair(\"grant_type\", \"client_credentials\"));\n+                request.setEntity(new UrlEncodedFormEntity(urlParameters));\n+                HttpResponse httpResponse = httpClient.execute(request);\n+\n+                if (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n+                    String payload = EntityUtils.toString(httpResponse.getEntity());\n+                    JSONObject response = new JSONObject(payload);\n+                    this.accessToken = (String) response.get(\"access_token\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2NTY5MQ=="}, "originalCommit": {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MjY2MjUwOnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.output.adapter.http/src/main/java/org/wso2/carbon/apimgt/output/adapter/http/internal/ds/ServiceReferenceHolder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwNDoyOTo1MFrOFpGteA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxMzozMToxOFrOFpTxGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY0NTg4MA==", "bodyText": "This isn't a service reference holder anymore right? Also, this doesn't have to be inside internal package since this isn't an osgi activator class", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378645880", "createdAt": "2020-02-13T04:29:50Z", "author": {"login": "fazlan-nazeem"}, "path": "components/apimgt/org.wso2.carbon.apimgt.output.adapter.http/src/main/java/org/wso2/carbon/apimgt/output/adapter/http/internal/ds/ServiceReferenceHolder.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.output.adapter.http.internal.ds;\n+\n+import org.wso2.carbon.apimgt.impl.recommendationmgt.AccessTokenGenerator;\n+\n+public class ServiceReferenceHolder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a63789776f5b5be6ba6a106aa5a9feed68b0e5f5"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg1OTgwMA==", "bodyText": "Fixed", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378859800", "createdAt": "2020-02-13T13:31:18Z", "author": {"login": "1akshitha"}, "path": "components/apimgt/org.wso2.carbon.apimgt.output.adapter.http/src/main/java/org/wso2/carbon/apimgt/output/adapter/http/internal/ds/ServiceReferenceHolder.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.output.adapter.http.internal.ds;\n+\n+import org.wso2.carbon.apimgt.impl.recommendationmgt.AccessTokenGenerator;\n+\n+public class ServiceReferenceHolder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY0NTg4MA=="}, "originalCommit": {"oid": "a63789776f5b5be6ba6a106aa5a9feed68b0e5f5"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NDM3OTcyOnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIManagerConfiguration.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNDo1ODoxM1rOFpXANg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNTo1MjoxOFrOFpZNSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxMjgyMg==", "bodyText": "please check line legnth", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378912822", "createdAt": "2020-02-13T14:58:13Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIManagerConfiguration.java", "diffHunk": "@@ -1203,6 +1194,78 @@ private void setMonetizationAdditionalAttributes(OMElement element) {\n         }\n     }\n \n+    /**\n+     * To populate recommendation related configurations\n+     * @param element\n+     */\n+    private void setRecommendationConfigurations(OMElement element) {\n+        OMElement recommendationSeverEndpointElement = element.getFirstChildWithName(new QName(APIConstants.RECOMMENDATION_ENDPOINT));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ea7057baec23fc858d1487f358f4f725b266920"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk0ODkzNg==", "bodyText": "fixed", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378948936", "createdAt": "2020-02-13T15:52:18Z", "author": {"login": "1akshitha"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIManagerConfiguration.java", "diffHunk": "@@ -1203,6 +1194,78 @@ private void setMonetizationAdditionalAttributes(OMElement element) {\n         }\n     }\n \n+    /**\n+     * To populate recommendation related configurations\n+     * @param element\n+     */\n+    private void setRecommendationConfigurations(OMElement element) {\n+        OMElement recommendationSeverEndpointElement = element.getFirstChildWithName(new QName(APIConstants.RECOMMENDATION_ENDPOINT));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxMjgyMg=="}, "originalCommit": {"oid": "7ea7057baec23fc858d1487f358f4f725b266920"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NDM5MjA4OnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/internal/APIManagerComponent.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNTowMToxM1rOFpXH9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNTo1MjoyNFrOFpZNjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxNDgwNw==", "bodyText": "looks length is exceeded.", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378914807", "createdAt": "2020-02-13T15:01:13Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/internal/APIManagerComponent.java", "diffHunk": "@@ -698,5 +706,18 @@ private void configureRecommendationEventPublisherProperties() {\n             }\n         }\n     }\n+\n+    private void setupAccessTokenGenerator(){\n+\n+        RecommendationEnvironment recommendationEnvironment =\n+                ServiceReferenceHolder.getInstance().getAPIManagerConfigurationService().getAPIManagerConfiguration().getApiRecommendationEnvironment();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ea7057baec23fc858d1487f358f4f725b266920"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk0OTAwNQ==", "bodyText": "Fixed", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378949005", "createdAt": "2020-02-13T15:52:24Z", "author": {"login": "1akshitha"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/internal/APIManagerComponent.java", "diffHunk": "@@ -698,5 +706,18 @@ private void configureRecommendationEventPublisherProperties() {\n             }\n         }\n     }\n+\n+    private void setupAccessTokenGenerator(){\n+\n+        RecommendationEnvironment recommendationEnvironment =\n+                ServiceReferenceHolder.getInstance().getAPIManagerConfigurationService().getAPIManagerConfiguration().getApiRecommendationEnvironment();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxNDgwNw=="}, "originalCommit": {"oid": "7ea7057baec23fc858d1487f358f4f725b266920"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NDM5MzIzOnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/internal/APIManagerComponent.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNTowMTozMFrOFpXIug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNTo1Mjo0NFrOFpZOaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxNTAwMg==", "bodyText": "formatting issue", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378915002", "createdAt": "2020-02-13T15:01:30Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/internal/APIManagerComponent.java", "diffHunk": "@@ -698,5 +706,18 @@ private void configureRecommendationEventPublisherProperties() {\n             }\n         }\n     }\n+\n+    private void setupAccessTokenGenerator(){\n+\n+        RecommendationEnvironment recommendationEnvironment =\n+                ServiceReferenceHolder.getInstance().getAPIManagerConfigurationService().getAPIManagerConfiguration().getApiRecommendationEnvironment();\n+        if (recommendationEnvironment != null && recommendationEnvironment.getOauthURL()!= null){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ea7057baec23fc858d1487f358f4f725b266920"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk0ODU4MQ==", "bodyText": "Fixed", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378948581", "createdAt": "2020-02-13T15:51:48Z", "author": {"login": "1akshitha"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/internal/APIManagerComponent.java", "diffHunk": "@@ -698,5 +706,18 @@ private void configureRecommendationEventPublisherProperties() {\n             }\n         }\n     }\n+\n+    private void setupAccessTokenGenerator(){\n+\n+        RecommendationEnvironment recommendationEnvironment =\n+                ServiceReferenceHolder.getInstance().getAPIManagerConfigurationService().getAPIManagerConfiguration().getApiRecommendationEnvironment();\n+        if (recommendationEnvironment != null && recommendationEnvironment.getOauthURL()!= null){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxNTAwMg=="}, "originalCommit": {"oid": "7ea7057baec23fc858d1487f358f4f725b266920"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk0OTIyNQ==", "bodyText": "Fixed", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378949225", "createdAt": "2020-02-13T15:52:44Z", "author": {"login": "1akshitha"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/internal/APIManagerComponent.java", "diffHunk": "@@ -698,5 +706,18 @@ private void configureRecommendationEventPublisherProperties() {\n             }\n         }\n     }\n+\n+    private void setupAccessTokenGenerator(){\n+\n+        RecommendationEnvironment recommendationEnvironment =\n+                ServiceReferenceHolder.getInstance().getAPIManagerConfigurationService().getAPIManagerConfiguration().getApiRecommendationEnvironment();\n+        if (recommendationEnvironment != null && recommendationEnvironment.getOauthURL()!= null){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxNTAwMg=="}, "originalCommit": {"oid": "7ea7057baec23fc858d1487f358f4f725b266920"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NDQwOTMzOnYy", "diffSide": "RIGHT", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/recommendationmgt/AccessTokenGenerator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNTowNTozNVrOFpXTEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNTo1Mjo1MVrOFpZOrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxNzY0OQ==", "bodyText": "can we define appropriate access identifiers private or protected", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378917649", "createdAt": "2020-02-13T15:05:35Z", "author": {"login": "ruks"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/recommendationmgt/AccessTokenGenerator.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.impl.recommendationmgt;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.entity.UrlEncodedFormEntity;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.message.BasicNameValuePair;\n+import org.apache.http.util.EntityUtils;\n+import org.json.JSONObject;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class AccessTokenGenerator {\n+\n+    private static final Log log = LogFactory.getLog(AccessTokenGenerator.class);\n+\n+    private static volatile AccessTokenGenerator accessTokenGenerator = null;\n+    long expiryTime = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ea7057baec23fc858d1487f358f4f725b266920"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk0OTI5NA==", "bodyText": "Fixed", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378949294", "createdAt": "2020-02-13T15:52:51Z", "author": {"login": "1akshitha"}, "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/recommendationmgt/AccessTokenGenerator.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.impl.recommendationmgt;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.entity.UrlEncodedFormEntity;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.message.BasicNameValuePair;\n+import org.apache.http.util.EntityUtils;\n+import org.json.JSONObject;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class AccessTokenGenerator {\n+\n+    private static final Log log = LogFactory.getLog(AccessTokenGenerator.class);\n+\n+    private static volatile AccessTokenGenerator accessTokenGenerator = null;\n+    long expiryTime = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxNzY0OQ=="}, "originalCommit": {"oid": "7ea7057baec23fc858d1487f358f4f725b266920"}, "originalPosition": 44}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2854, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}