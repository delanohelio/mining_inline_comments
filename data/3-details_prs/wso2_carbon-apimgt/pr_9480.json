{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM0NDEyMjE3", "number": 9480, "title": "Support to export/import multiple custom mediation policies attached to an API through APICTL", "bodyText": "Purpose\nFixes the issue mentioned in wso2/product-apim-tooling#330 (comment)\nGoals\nExport multiple custom mediation policies attached to an API and import those when importing that particular API.\nApproach\n\nPreviously only one mediation policy per direction (in/out/fault) was exported. But with this improvement, all the attached mediations to a particular API will be exported for all the directions.\nPizzaShackAPI-1.0.0\n\u251c\u2500\u2500 api.yaml\n\u251c\u2500\u2500 Definitions\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 swagger.yaml\n\u2514\u2500\u2500 Sequences\n    \u251c\u2500\u2500 fault-sequence\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 Custom\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 sequence1.xml\n    \u251c\u2500\u2500 in-sequence\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 Custom\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 sequence1.xml\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 sequence2.xml\n    \u2514\u2500\u2500 out-sequence\n        \u2514\u2500\u2500 disable_chunking.xml\n\nAs shown in the above example, you can see that there are multiple in-sequences inside the Custom directory. Earlier we were able only to export the sequence which has been set in runtime.\nIf you import the above like API archive, all the custom sequences will be imported which are attached to it. For example, both sequence1.xml and sequence2.xml will be imported under the API specific registry path for in-sequences. Also, there will be three (3) mediation policy objects inside the api.yaml file (Inside the API DTO) as below.\n  mediationPolicies:\n   -\n    id: 9f8941e6-b056-4c3d-a84a-1adafed4cc60\n    name: sequence1\n    type: IN\n    shared: false\n   -\n    id: 507c7c9d-6542-4420-a285-f7b4d9bbe88c\n    name: disable_chunking\n    type: OUT\n    shared: true\n   -\n    id: a90b38dd-93e9-4ad3-8ca7-8511bde4b9cf\n    name: sequence1\n    type: FAULT\n    shared: false\n\nThese will be the policies that will be enforced during the runtime. Simply it means, even you have imported both sequence1.xml and sequence2.xml as in-sequences, only sequence1.xml will be enforced during the runtime.\n\nUser stories\nUser stories related to wso2/product-apim-tooling#330 (comment) will be satisfied.\nRelated PRs\n#9464\nTest environment\n\nJDK 1.8.0_251\nUbuntu 20.04.1 LTS", "createdAt": "2020-12-08T12:18:45Z", "url": "https://github.com/wso2/carbon-apimgt/pull/9480", "merged": true, "mergeCommit": {"oid": "b15a1da5881a614cc2e13a6f59a9b06bc520f742"}, "closed": true, "closedAt": "2020-12-11T12:02:34Z", "author": {"login": "wasuradananjith"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdkjkDdAH2gAyNTM0NDEyMjE3OmUxMjQ0NGUxNWFmZGY3YzZlZTEyY2VkZjAyMDI5MWYyOTI5YjdmYWM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdlGtpFgFqTU1MDAzOTMwMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e12444e15afdf7c6ee12cedf020291f2929b7fac", "author": {"user": {"login": "wasuradananjith", "name": "Wasura Wattearachchi"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/e12444e15afdf7c6ee12cedf020291f2929b7fac", "committedDate": "2020-12-09T19:04:34Z", "message": "Support importing/exporting multiple medations attached to an API"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63d3b62755d69f37a943c332f9a775162b698377", "author": {"user": {"login": "wasuradananjith", "name": "Wasura Wattearachchi"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/63d3b62755d69f37a943c332f9a775162b698377", "committedDate": "2020-12-09T19:04:34Z", "message": "Remove unnecessary code related to import/export mediations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3a09c77113115bb688a0326421039071f6ae9c2", "author": {"user": {"login": "wasuradananjith", "name": "Wasura Wattearachchi"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/c3a09c77113115bb688a0326421039071f6ae9c2", "committedDate": "2020-12-09T19:04:34Z", "message": "Modify constants related to in/out/fault sequences"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7eef4e01259aec730c42c9746179e984e6a05492", "author": {"user": {"login": "wasuradananjith", "name": "Wasura Wattearachchi"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/7eef4e01259aec730c42c9746179e984e6a05492", "committedDate": "2020-12-09T19:04:34Z", "message": "Fix certificate import error when a full certificate is passed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1da860639b4edf0d79a9435dff46c3d949c10e9c", "author": {"user": {"login": "wasuradananjith", "name": "Wasura Wattearachchi"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/1da860639b4edf0d79a9435dff46c3d949c10e9c", "committedDate": "2020-12-09T19:04:34Z", "message": "Format addAPISpecificSequences function"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c355d5d8ffac36cb7ab65648e665227bc1077f46", "author": {"user": {"login": "wasuradananjith", "name": "Wasura Wattearachchi"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/c355d5d8ffac36cb7ab65648e665227bc1077f46", "committedDate": "2020-12-08T11:54:05Z", "message": "Format addAPISpecificSequences function"}, "afterCommit": {"oid": "1da860639b4edf0d79a9435dff46c3d949c10e9c", "author": {"user": {"login": "wasuradananjith", "name": "Wasura Wattearachchi"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/1da860639b4edf0d79a9435dff46c3d949c10e9c", "committedDate": "2020-12-09T19:04:34Z", "message": "Format addAPISpecificSequences function"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b4914061864d871ff52059c3105b76bbf910b2a", "author": {"user": {"login": "wasuradananjith", "name": "Wasura Wattearachchi"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/1b4914061864d871ff52059c3105b76bbf910b2a", "committedDate": "2020-12-10T14:23:48Z", "message": "Fix the error when update import an API if operations are empty"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5ODY2Nzk0", "url": "https://github.com/wso2/carbon-apimgt/pull/9480#pullrequestreview-549866794", "createdAt": "2020-12-11T07:49:46Z", "commit": {"oid": "1b4914061864d871ff52059c3105b76bbf910b2a"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwNzo0OTo0N1rOIDs5TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwNzo1MjowMVrOIDs9ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc1MjIwNA==", "bodyText": "IOException has been Swallowed", "url": "https://github.com/wso2/carbon-apimgt/pull/9480#discussion_r540752204", "createdAt": "2020-12-11T07:49:47Z", "author": {"login": "uvindra"}, "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1.common/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/common/mappings/ExportUtils.java", "diffHunk": "@@ -506,150 +502,91 @@ public static void addWSDLtoArchive(String archivePath, APIIdentifier apiIdentif\n      * @param apiIdentifier API Identifier\n      * @param apiDto        API DTO\n      * @param registry      Current tenant registry\n+     * @param apiProvider   API Provider\n      * @throws APIImportExportException If an error occurs while exporting sequences\n      */\n     public static void addSequencesToArchive(String archivePath, APIIdentifier apiIdentifier, APIDTO apiDto,\n-            Registry registry) throws APIImportExportException {\n+            Registry registry, APIProvider apiProvider)\n+            throws APIImportExportException, APIManagementException, RegistryException {\n \n         String seqArchivePath = archivePath.concat(File.separator + ImportExportConstants.SEQUENCES_RESOURCE);\n         List<MediationPolicyDTO> mediationPolicyDtos = apiDto.getMediationPolicies();\n-        if (!apiDto.getMediationPolicies().isEmpty()) {\n+\n+        if (!mediationPolicyDtos.isEmpty()) {\n             CommonUtil.createDirectory(seqArchivePath);\n             for (MediationPolicyDTO mediationPolicyDto : mediationPolicyDtos) {\n-                AbstractMap.SimpleEntry<String, OMElement> sequenceDetails;\n-                String sequenceName = mediationPolicyDto.getName();\n-                String direction = mediationPolicyDto.getType().toLowerCase();\n-                String pathToExportedSequence =\n-                        seqArchivePath + File.separator + direction + \"-sequence\" + File.separator;\n-                if (sequenceName != null) {\n-                    sequenceDetails = getCustomSequence(sequenceName, direction, registry);\n-                    if (sequenceDetails == null) {\n-                        // If sequence doesn't exist in 'apimgt/customsequences/{in/out/fault}' directory check in API\n-                        // specific registry path\n-                        sequenceDetails = getAPISpecificSequence(apiIdentifier, sequenceName, direction, registry);\n-                        pathToExportedSequence += ImportExportConstants.CUSTOM_TYPE + File.separator;\n+                if (mediationPolicyDto.isShared()) {\n+                    String individualSequenceExportPath =\n+                            seqArchivePath + File.separator + mediationPolicyDto.getType().toLowerCase()\n+                                    + ImportExportConstants.SEQUENCE_LOCATION_POSTFIX;\n+                    if (!CommonUtil.checkFileExistence(individualSequenceExportPath)) {\n+                        CommonUtil.createDirectory(individualSequenceExportPath);\n                     }\n-                    writeSequenceToFile(pathToExportedSequence, sequenceDetails, apiIdentifier);\n+                    //Get registry resource correspond to identifier\n+                    Resource mediationResource = apiProvider\n+                            .getCustomMediationResourceFromUuid(mediationPolicyDto.getId());\n+                    writeSequenceToArchive(mediationResource, individualSequenceExportPath, registry,\n+                            mediationPolicyDto.getName(), apiIdentifier);\n                 }\n             }\n-        } else if (log.isDebugEnabled()) {\n-            log.debug(\"No custom sequences available for API: \" + apiIdentifier.getApiName() + StringUtils.SPACE\n-                    + APIConstants.API_DATA_VERSION + \": \" + apiIdentifier.getVersion()\n-                    + \". Skipping custom sequence export.\");\n-        }\n-    }\n-\n-    /**\n-     * Retrieve custom sequence details from the registry.\n-     *\n-     * @param sequenceName Name of the sequence\n-     * @param type         Sequence type\n-     * @param registry     Current tenant registry\n-     * @return Registry resource name of the sequence and its content\n-     * @throws APIImportExportException If an error occurs while retrieving registry elements\n-     */\n-    private static AbstractMap.SimpleEntry<String, OMElement> getCustomSequence(String sequenceName, String type,\n-            Registry registry) throws APIImportExportException {\n-\n-        String regPath = null;\n-        if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_IN.equals(type)) {\n-            regPath = APIConstants.API_CUSTOM_INSEQUENCE_LOCATION;\n-        } else if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_OUT.equals(type)) {\n-            regPath = APIConstants.API_CUSTOM_OUTSEQUENCE_LOCATION;\n-        } else if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_FAULT.equals(type)) {\n-            regPath = APIConstants.API_CUSTOM_FAULTSEQUENCE_LOCATION;\n-        }\n-        return getSeqDetailsFromRegistry(sequenceName, regPath, registry);\n-    }\n \n-    /**\n-     * Retrieve API Specific sequence details from the registry.\n-     *\n-     * @param sequenceName Name of the sequence\n-     * @param type         Sequence type\n-     * @param registry     Current tenant registry\n-     * @return Registry resource name of the sequence and its content\n-     * @throws APIImportExportException If an error occurs while retrieving registry elements\n-     */\n-    private static AbstractMap.SimpleEntry<String, OMElement> getAPISpecificSequence(APIIdentifier api,\n-            String sequenceName, String type, Registry registry) throws APIImportExportException {\n-\n-        String regPath = APIConstants.API_ROOT_LOCATION + RegistryConstants.PATH_SEPARATOR + api.getProviderName()\n-                + RegistryConstants.PATH_SEPARATOR + api.getApiName() + RegistryConstants.PATH_SEPARATOR + api\n-                .getVersion() + RegistryConstants.PATH_SEPARATOR + type;\n-        return getSeqDetailsFromRegistry(sequenceName, regPath, registry);\n-    }\n-\n-    /**\n-     * Retrieve sequence details from registry by given registry path.\n-     *\n-     * @param sequenceName Sequence Name\n-     * @param regPath      Registry path\n-     * @param registry     Registry\n-     * @return Sequence details as a simple entry\n-     * @throws APIImportExportException If an error occurs while retrieving sequence details from registry\n-     */\n-    private static AbstractMap.SimpleEntry<String, OMElement> getSeqDetailsFromRegistry(String sequenceName,\n-            String regPath, Registry registry) throws APIImportExportException {\n-\n-        AbstractMap.SimpleEntry<String, OMElement> sequenceDetails = null;\n-        Collection seqCollection;\n-\n-        try {\n-            seqCollection = (Collection) registry.get(regPath);\n-            if (seqCollection != null) {\n-                String[] childPaths = seqCollection.getChildren();\n-                for (String childPath : childPaths) {\n-                    Resource sequence = registry.get(childPath);\n-                    OMElement seqElement = APIUtil.buildOMElement(sequence.getContentStream());\n-                    if (sequenceName.equals(seqElement.getAttributeValue(new QName(\"name\")))) {\n-                        String sequenceFileName = sequenceName + APIConstants.XML_EXTENSION;\n-                        sequenceDetails = new AbstractMap.SimpleEntry<>(sequenceFileName, seqElement);\n-                        break;\n+            // Getting list of API specific custom mediation policies\n+            List<Mediation> apiSpecificMediationList = apiProvider.getAllApiSpecificMediationPolicies(apiIdentifier);\n+            if (!apiSpecificMediationList.isEmpty()) {\n+                for (Mediation mediation : apiSpecificMediationList) {\n+                    String individualSequenceExportPath =\n+                            seqArchivePath + File.separator + mediation.getType().toLowerCase()\n+                                    + ImportExportConstants.SEQUENCE_LOCATION_POSTFIX + File.separator\n+                                    + ImportExportConstants.CUSTOM_TYPE;\n+                    if (!CommonUtil.checkFileExistence(individualSequenceExportPath)) {\n+                        CommonUtil.createDirectory(individualSequenceExportPath);\n                     }\n+                    // Get registry resource correspond to identifier\n+                    String apiResourcePath = APIUtil.getAPIPath(apiIdentifier);\n+                    apiResourcePath = apiResourcePath.substring(0, apiResourcePath.lastIndexOf(\"/\"));\n+                    Resource mediationResource = apiProvider\n+                            .getApiSpecificMediationResourceFromUuid(apiIdentifier, mediation.getUuid(),\n+                                    apiResourcePath);\n+                    writeSequenceToArchive(mediationResource, individualSequenceExportPath, registry,\n+                            mediation.getName(), apiIdentifier);\n                 }\n             }\n-        } catch (RegistryException e) {\n-            throw new APIImportExportException(\n-                    \"Error while retrieving sequence: \" + sequenceName + \" from the path: \" + regPath, e);\n-        } catch (Exception e) {\n-            // APIUtil.buildOMElement() throws a generic exception\n-            throw new APIImportExportException(\n-                    \"Error while reading content for sequence: \" + sequenceName + \" from the registry\", e);\n         }\n-        return sequenceDetails;\n     }\n \n     /**\n-     * Store API Specific or custom sequences in the archive directory.\n+     * Write the sequence to API archive.\n      *\n-     * @param sequenceDetails Details of the sequence\n-     * @param apiIdentifier   ID of the requesting API\n-     * @throws APIImportExportException If an error occurs while serializing XML stream or storing in\n-     *                                  archive directory\n+     * @param mediationResource Mediation resource\n+     * @param individualSequenceExportPath         Path to export the mediation sequence\n+     * @param registry     Current tenant registry\n+     * @param mediationName     Name of the mediation policy\n+     * @param apiIdentifier     API Identifier\n+     * @throws RegistryException If an error occurs while retrieving registry elements\n+     * @throws APIManagementException If an error occurs while writing the mediation policy to file\n      */\n-    private static void writeSequenceToFile(String pathToExportedSequence,\n-            AbstractMap.SimpleEntry<String, OMElement> sequenceDetails, APIIdentifier apiIdentifier)\n-            throws APIImportExportException {\n-\n-        if (sequenceDetails != null) {\n-            String sequenceFileName = sequenceDetails.getKey();\n-            OMElement sequenceConfig = sequenceDetails.getValue();\n-            CommonUtil.createDirectory(pathToExportedSequence);\n-            String exportedSequenceFile = pathToExportedSequence + sequenceFileName;\n-            try (OutputStream outputStream = new FileOutputStream(exportedSequenceFile)) {\n-                sequenceConfig.serialize(outputStream);\n-                if (log.isDebugEnabled()) {\n-                    log.debug(sequenceFileName + \" of API: \" + apiIdentifier.getApiName() + \" retrieved successfully\");\n+    private static void writeSequenceToArchive(Resource mediationResource, String individualSequenceExportPath,\n+            Registry registry, String mediationName, APIIdentifier apiIdentifier)\n+            throws RegistryException, APIManagementException {\n+        if (mediationResource != null) {\n+            // Get the registry resource path\n+            String resourcePath = mediationResource.getPath();\n+            // Check whether resource exists in the registry\n+            if (registry.resourceExists(resourcePath)) {\n+                Resource mediationFile = registry.get(resourcePath);\n+                try (OutputStream outputStream = new FileOutputStream(\n+                        individualSequenceExportPath + File.separator + mediationName + APIConstants.DOT\n+                                + APIConstants.XML_DOC_EXTENSION);\n+                        InputStream fileInputStream = mediationFile.getContentStream()) {\n+                    IOUtils.copy(fileInputStream, outputStream);\n+                } catch (IOException e) {\n+                    throw new APIManagementException(\"Error while writing the mediation sequence\"+ mediationName+ \"to file\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b4914061864d871ff52059c3105b76bbf910b2a"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc1Mjg4OQ==", "bodyText": "Should this be logged as an error since this is a valid scenario?", "url": "https://github.com/wso2/carbon-apimgt/pull/9480#discussion_r540752889", "createdAt": "2020-12-11T07:51:08Z", "author": {"login": "uvindra"}, "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1.common/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/common/mappings/ExportUtils.java", "diffHunk": "@@ -506,150 +502,91 @@ public static void addWSDLtoArchive(String archivePath, APIIdentifier apiIdentif\n      * @param apiIdentifier API Identifier\n      * @param apiDto        API DTO\n      * @param registry      Current tenant registry\n+     * @param apiProvider   API Provider\n      * @throws APIImportExportException If an error occurs while exporting sequences\n      */\n     public static void addSequencesToArchive(String archivePath, APIIdentifier apiIdentifier, APIDTO apiDto,\n-            Registry registry) throws APIImportExportException {\n+            Registry registry, APIProvider apiProvider)\n+            throws APIImportExportException, APIManagementException, RegistryException {\n \n         String seqArchivePath = archivePath.concat(File.separator + ImportExportConstants.SEQUENCES_RESOURCE);\n         List<MediationPolicyDTO> mediationPolicyDtos = apiDto.getMediationPolicies();\n-        if (!apiDto.getMediationPolicies().isEmpty()) {\n+\n+        if (!mediationPolicyDtos.isEmpty()) {\n             CommonUtil.createDirectory(seqArchivePath);\n             for (MediationPolicyDTO mediationPolicyDto : mediationPolicyDtos) {\n-                AbstractMap.SimpleEntry<String, OMElement> sequenceDetails;\n-                String sequenceName = mediationPolicyDto.getName();\n-                String direction = mediationPolicyDto.getType().toLowerCase();\n-                String pathToExportedSequence =\n-                        seqArchivePath + File.separator + direction + \"-sequence\" + File.separator;\n-                if (sequenceName != null) {\n-                    sequenceDetails = getCustomSequence(sequenceName, direction, registry);\n-                    if (sequenceDetails == null) {\n-                        // If sequence doesn't exist in 'apimgt/customsequences/{in/out/fault}' directory check in API\n-                        // specific registry path\n-                        sequenceDetails = getAPISpecificSequence(apiIdentifier, sequenceName, direction, registry);\n-                        pathToExportedSequence += ImportExportConstants.CUSTOM_TYPE + File.separator;\n+                if (mediationPolicyDto.isShared()) {\n+                    String individualSequenceExportPath =\n+                            seqArchivePath + File.separator + mediationPolicyDto.getType().toLowerCase()\n+                                    + ImportExportConstants.SEQUENCE_LOCATION_POSTFIX;\n+                    if (!CommonUtil.checkFileExistence(individualSequenceExportPath)) {\n+                        CommonUtil.createDirectory(individualSequenceExportPath);\n                     }\n-                    writeSequenceToFile(pathToExportedSequence, sequenceDetails, apiIdentifier);\n+                    //Get registry resource correspond to identifier\n+                    Resource mediationResource = apiProvider\n+                            .getCustomMediationResourceFromUuid(mediationPolicyDto.getId());\n+                    writeSequenceToArchive(mediationResource, individualSequenceExportPath, registry,\n+                            mediationPolicyDto.getName(), apiIdentifier);\n                 }\n             }\n-        } else if (log.isDebugEnabled()) {\n-            log.debug(\"No custom sequences available for API: \" + apiIdentifier.getApiName() + StringUtils.SPACE\n-                    + APIConstants.API_DATA_VERSION + \": \" + apiIdentifier.getVersion()\n-                    + \". Skipping custom sequence export.\");\n-        }\n-    }\n-\n-    /**\n-     * Retrieve custom sequence details from the registry.\n-     *\n-     * @param sequenceName Name of the sequence\n-     * @param type         Sequence type\n-     * @param registry     Current tenant registry\n-     * @return Registry resource name of the sequence and its content\n-     * @throws APIImportExportException If an error occurs while retrieving registry elements\n-     */\n-    private static AbstractMap.SimpleEntry<String, OMElement> getCustomSequence(String sequenceName, String type,\n-            Registry registry) throws APIImportExportException {\n-\n-        String regPath = null;\n-        if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_IN.equals(type)) {\n-            regPath = APIConstants.API_CUSTOM_INSEQUENCE_LOCATION;\n-        } else if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_OUT.equals(type)) {\n-            regPath = APIConstants.API_CUSTOM_OUTSEQUENCE_LOCATION;\n-        } else if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_FAULT.equals(type)) {\n-            regPath = APIConstants.API_CUSTOM_FAULTSEQUENCE_LOCATION;\n-        }\n-        return getSeqDetailsFromRegistry(sequenceName, regPath, registry);\n-    }\n \n-    /**\n-     * Retrieve API Specific sequence details from the registry.\n-     *\n-     * @param sequenceName Name of the sequence\n-     * @param type         Sequence type\n-     * @param registry     Current tenant registry\n-     * @return Registry resource name of the sequence and its content\n-     * @throws APIImportExportException If an error occurs while retrieving registry elements\n-     */\n-    private static AbstractMap.SimpleEntry<String, OMElement> getAPISpecificSequence(APIIdentifier api,\n-            String sequenceName, String type, Registry registry) throws APIImportExportException {\n-\n-        String regPath = APIConstants.API_ROOT_LOCATION + RegistryConstants.PATH_SEPARATOR + api.getProviderName()\n-                + RegistryConstants.PATH_SEPARATOR + api.getApiName() + RegistryConstants.PATH_SEPARATOR + api\n-                .getVersion() + RegistryConstants.PATH_SEPARATOR + type;\n-        return getSeqDetailsFromRegistry(sequenceName, regPath, registry);\n-    }\n-\n-    /**\n-     * Retrieve sequence details from registry by given registry path.\n-     *\n-     * @param sequenceName Sequence Name\n-     * @param regPath      Registry path\n-     * @param registry     Registry\n-     * @return Sequence details as a simple entry\n-     * @throws APIImportExportException If an error occurs while retrieving sequence details from registry\n-     */\n-    private static AbstractMap.SimpleEntry<String, OMElement> getSeqDetailsFromRegistry(String sequenceName,\n-            String regPath, Registry registry) throws APIImportExportException {\n-\n-        AbstractMap.SimpleEntry<String, OMElement> sequenceDetails = null;\n-        Collection seqCollection;\n-\n-        try {\n-            seqCollection = (Collection) registry.get(regPath);\n-            if (seqCollection != null) {\n-                String[] childPaths = seqCollection.getChildren();\n-                for (String childPath : childPaths) {\n-                    Resource sequence = registry.get(childPath);\n-                    OMElement seqElement = APIUtil.buildOMElement(sequence.getContentStream());\n-                    if (sequenceName.equals(seqElement.getAttributeValue(new QName(\"name\")))) {\n-                        String sequenceFileName = sequenceName + APIConstants.XML_EXTENSION;\n-                        sequenceDetails = new AbstractMap.SimpleEntry<>(sequenceFileName, seqElement);\n-                        break;\n+            // Getting list of API specific custom mediation policies\n+            List<Mediation> apiSpecificMediationList = apiProvider.getAllApiSpecificMediationPolicies(apiIdentifier);\n+            if (!apiSpecificMediationList.isEmpty()) {\n+                for (Mediation mediation : apiSpecificMediationList) {\n+                    String individualSequenceExportPath =\n+                            seqArchivePath + File.separator + mediation.getType().toLowerCase()\n+                                    + ImportExportConstants.SEQUENCE_LOCATION_POSTFIX + File.separator\n+                                    + ImportExportConstants.CUSTOM_TYPE;\n+                    if (!CommonUtil.checkFileExistence(individualSequenceExportPath)) {\n+                        CommonUtil.createDirectory(individualSequenceExportPath);\n                     }\n+                    // Get registry resource correspond to identifier\n+                    String apiResourcePath = APIUtil.getAPIPath(apiIdentifier);\n+                    apiResourcePath = apiResourcePath.substring(0, apiResourcePath.lastIndexOf(\"/\"));\n+                    Resource mediationResource = apiProvider\n+                            .getApiSpecificMediationResourceFromUuid(apiIdentifier, mediation.getUuid(),\n+                                    apiResourcePath);\n+                    writeSequenceToArchive(mediationResource, individualSequenceExportPath, registry,\n+                            mediation.getName(), apiIdentifier);\n                 }\n             }\n-        } catch (RegistryException e) {\n-            throw new APIImportExportException(\n-                    \"Error while retrieving sequence: \" + sequenceName + \" from the path: \" + regPath, e);\n-        } catch (Exception e) {\n-            // APIUtil.buildOMElement() throws a generic exception\n-            throw new APIImportExportException(\n-                    \"Error while reading content for sequence: \" + sequenceName + \" from the registry\", e);\n         }\n-        return sequenceDetails;\n     }\n \n     /**\n-     * Store API Specific or custom sequences in the archive directory.\n+     * Write the sequence to API archive.\n      *\n-     * @param sequenceDetails Details of the sequence\n-     * @param apiIdentifier   ID of the requesting API\n-     * @throws APIImportExportException If an error occurs while serializing XML stream or storing in\n-     *                                  archive directory\n+     * @param mediationResource Mediation resource\n+     * @param individualSequenceExportPath         Path to export the mediation sequence\n+     * @param registry     Current tenant registry\n+     * @param mediationName     Name of the mediation policy\n+     * @param apiIdentifier     API Identifier\n+     * @throws RegistryException If an error occurs while retrieving registry elements\n+     * @throws APIManagementException If an error occurs while writing the mediation policy to file\n      */\n-    private static void writeSequenceToFile(String pathToExportedSequence,\n-            AbstractMap.SimpleEntry<String, OMElement> sequenceDetails, APIIdentifier apiIdentifier)\n-            throws APIImportExportException {\n-\n-        if (sequenceDetails != null) {\n-            String sequenceFileName = sequenceDetails.getKey();\n-            OMElement sequenceConfig = sequenceDetails.getValue();\n-            CommonUtil.createDirectory(pathToExportedSequence);\n-            String exportedSequenceFile = pathToExportedSequence + sequenceFileName;\n-            try (OutputStream outputStream = new FileOutputStream(exportedSequenceFile)) {\n-                sequenceConfig.serialize(outputStream);\n-                if (log.isDebugEnabled()) {\n-                    log.debug(sequenceFileName + \" of API: \" + apiIdentifier.getApiName() + \" retrieved successfully\");\n+    private static void writeSequenceToArchive(Resource mediationResource, String individualSequenceExportPath,\n+            Registry registry, String mediationName, APIIdentifier apiIdentifier)\n+            throws RegistryException, APIManagementException {\n+        if (mediationResource != null) {\n+            // Get the registry resource path\n+            String resourcePath = mediationResource.getPath();\n+            // Check whether resource exists in the registry\n+            if (registry.resourceExists(resourcePath)) {\n+                Resource mediationFile = registry.get(resourcePath);\n+                try (OutputStream outputStream = new FileOutputStream(\n+                        individualSequenceExportPath + File.separator + mediationName + APIConstants.DOT\n+                                + APIConstants.XML_DOC_EXTENSION);\n+                        InputStream fileInputStream = mediationFile.getContentStream()) {\n+                    IOUtils.copy(fileInputStream, outputStream);\n+                } catch (IOException e) {\n+                    throw new APIManagementException(\"Error while writing the mediation sequence\"+ mediationName+ \"to file\");\n                 }\n-            } catch (IOException e) {\n-                throw new APIImportExportException(\"Unable to find file: \" + exportedSequenceFile, e);\n-            } catch (XMLStreamException e) {\n-                throw new APIImportExportException(\"Error while processing XML stream \", e);\n+            } else {\n+                // Log error and avoid throwing as we give capability to export an API without sequences\n+                log.error(\"Sequence resource for API/API Product: \" + apiIdentifier.getName() + \" not found in \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b4914061864d871ff52059c3105b76bbf910b2a"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc1MzMzOA==", "bodyText": "Code formatting issue in '='", "url": "https://github.com/wso2/carbon-apimgt/pull/9480#discussion_r540753338", "createdAt": "2020-12-11T07:52:01Z", "author": {"login": "uvindra"}, "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1.common/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/common/mappings/ImportUtils.java", "diffHunk": "@@ -277,6 +285,21 @@ public static API importApi(String extractedFolderPath, APIDTO importedApiDTO, B\n         }\n     }\n \n+    /**\n+     * This method sets the operations which were retrieved from the swagger definition to the API DTO.\n+     *\n+     * @param apiDto             API DTO\n+     * @param response          API Validation Response\n+     * @throws APIManagementException If an error occurs when retrieving the URI templates\n+     */\n+    private static void setOperationsToDTO(APIDTO apiDto, APIDefinitionValidationResponse response)\n+            throws APIManagementException {\n+        List<URITemplate> uriTemplates = new ArrayList<>();\n+        uriTemplates.addAll(response.getParser().getURITemplates(response.getJsonContent()));\n+        List<APIOperationsDTO> apiOperationsDtos =APIMappingUtil.fromURITemplateListToOprationList(uriTemplates);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b4914061864d871ff52059c3105b76bbf910b2a"}, "originalPosition": 46}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5348d62a58ef3f675074a88af5b2e2bf607660db", "author": {"user": {"login": "wasuradananjith", "name": "Wasura Wattearachchi"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/5348d62a58ef3f675074a88af5b2e2bf607660db", "committedDate": "2020-12-11T10:47:16Z", "message": "Format setOperationsToDTO function"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1a9950578cb6e9db87036e285e0448a53bebb42", "author": {"user": {"login": "wasuradananjith", "name": "Wasura Wattearachchi"}}, "url": "https://github.com/wso2/carbon-apimgt/commit/d1a9950578cb6e9db87036e285e0448a53bebb42", "committedDate": "2020-12-11T10:55:56Z", "message": "Modify exceptions for mediation export errors"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMDM5MzAz", "url": "https://github.com/wso2/carbon-apimgt/pull/9480#pullrequestreview-550039303", "createdAt": "2020-12-11T12:01:43Z", "commit": {"oid": "d1a9950578cb6e9db87036e285e0448a53bebb42"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3076, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}