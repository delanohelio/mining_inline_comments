{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA1OTY3NTE3", "number": 1860, "reviewThreads": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMToyNDoxOVrOD0tDug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwOTo1ODo1MFrOD1sdRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTkwNzc4OnYy", "diffSide": "RIGHT", "path": "telefonica_eclipse_checkstyle.xml", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMToyNDoxOVrOGJxPrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxMToyMjo0OFrOGNPRmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg5NzE5Nw==", "bodyText": "Maybe this file was unintencionally added to the PR? (Note that we already have a telefonica_checkstyle.xml file in the repository)", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r412897197", "createdAt": "2020-04-22T11:24:19Z", "author": {"login": "fgalan"}, "path": "telefonica_eclipse_checkstyle.xml", "diffHunk": "@@ -0,0 +1,235 @@\n+<?xml version=\"1.0\"?>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk0MzA3OQ==", "bodyText": "Actual checkstyle, doesn't works whit Eclipse IDE, this one was created to avoid the problems.\nshould we remove it?", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r412943079", "createdAt": "2020-04-22T12:36:36Z", "author": {"login": "pmo-sdr"}, "path": "telefonica_eclipse_checkstyle.xml", "diffHunk": "@@ -0,0 +1,235 @@\n+<?xml version=\"1.0\"?>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg5NzE5Nw=="}, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk0NTM0Mw==", "bodyText": "If telefonica_checkstyle.xml is broken, then a solution is to replace that one with yours. Does it contain the same rules?\nQuestion: apart from Eclipse, does your telefonica_checkstyle_eclipse.xml file works with plain check style? (I mean mvn checkstyle or similar... I don't remember right now the exact syntax of the command...)", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r412945343", "createdAt": "2020-04-22T12:39:54Z", "author": {"login": "fgalan"}, "path": "telefonica_eclipse_checkstyle.xml", "diffHunk": "@@ -0,0 +1,235 @@\n+<?xml version=\"1.0\"?>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg5NzE5Nw=="}, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMzMDU0MQ==", "bodyText": "Two modules throwing error on Eclipse was disabled.\n<module name=\"FileContentsHolder\"/>\n<module name=\"RedundantThrows\"/>", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r414330541", "createdAt": "2020-04-24T06:36:34Z", "author": {"login": "pmo-sdr"}, "path": "telefonica_eclipse_checkstyle.xml", "diffHunk": "@@ -0,0 +1,235 @@\n+<?xml version=\"1.0\"?>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg5NzE5Nw=="}, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQxODMzNA==", "bodyText": "We'll take a look closely to this checkstyle plugin, for now it seems to be better to leave this file out of the PR. But thanks for the feedback.", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r416418334", "createdAt": "2020-04-28T08:13:18Z", "author": {"login": "IvanHdzC"}, "path": "telefonica_eclipse_checkstyle.xml", "diffHunk": "@@ -0,0 +1,235 @@\n+<?xml version=\"1.0\"?>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg5NzE5Nw=="}, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUzNDkzOQ==", "bodyText": "New Checkstyle removed\nStdri@1941e81", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r416534939", "createdAt": "2020-04-28T11:22:48Z", "author": {"login": "pmo-sdr"}, "path": "telefonica_eclipse_checkstyle.xml", "diffHunk": "@@ -0,0 +1,235 @@\n+<?xml version=\"1.0\"?>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg5NzE5Nw=="}, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTkxMjA0OnYy", "diffSide": "RIGHT", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/backends/arcgis/baselogger/BaseLogger.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMToyNToyN1rOGJxSLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwODowNToxOVrOGMWJCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg5NzgzNw==", "bodyText": "All new files should include the standard Cygnus license header\n(General comment, it applies to all the new files addd in this PR)", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r412897837", "createdAt": "2020-04-22T11:25:27Z", "author": {"login": "fgalan"}, "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/backends/arcgis/baselogger/BaseLogger.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU5ODg1Nw==", "bodyText": "Done c8d4419", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r415598857", "createdAt": "2020-04-27T08:05:19Z", "author": {"login": "pmo-sdr"}, "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/backends/arcgis/baselogger/BaseLogger.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg5NzgzNw=="}, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTk2MTE1OnYy", "diffSide": "RIGHT", "path": "cygnus-arcgis/pom.xml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMTozNzo1NlrOGJxu_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwODowNjoxMlrOGMWLLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkwNTIxNA==", "bodyText": "Looking to how the contribution is structured (cygnus-argis/ directory in the root) I wonder if this means a kind of \"independent\" Cygnus implementation with ArcGis support (as a sibling of Cygnus Twitter or Cygnus NGSI) or a sink for regular Cygnus (I mean, Cygnus NGSI) to be used along with all the other sinks.\nAs far as I understand, tha old implementation in PR #1683 was in that later way (a sink).", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r412905214", "createdAt": "2020-04-22T11:37:56Z", "author": {"login": "fgalan"}, "path": "cygnus-arcgis/pom.xml", "diffHunk": "@@ -0,0 +1,157 @@\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU5OTQwNQ==", "bodyText": "Structure changed to fit into cygnus-common and cygnus-ngsi projects. c8d4419", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r415599405", "createdAt": "2020-04-27T08:06:12Z", "author": {"login": "pmo-sdr"}, "path": "cygnus-arcgis/pom.xml", "diffHunk": "@@ -0,0 +1,157 @@\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkwNTIxNA=="}, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTM4OTA1OnYy", "diffSide": "RIGHT", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMTowNToyMlrOGKjoug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMDowODo1OFrOGLQfXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyMjgxMA==", "bodyText": "please remove comments.", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r413722810", "createdAt": "2020-04-23T11:05:22Z", "author": {"login": "IvanHdzC"}, "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "diffHunk": "@@ -0,0 +1,789 @@\n+/**\n+ * Copyright 2014-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+\n+package com.telefonica.iot.cygnus.sinks;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.commons.lang.exception.ExceptionUtils;\n+import org.apache.flume.Context;\n+import org.apache.flume.EventDeliveryException;\n+import org.json.JSONException;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Point;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.ArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.NGSIArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextAttribute;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextElement;\n+import com.telefonica.iot.cygnus.errors.CygnusBadConfiguration;\n+import com.telefonica.iot.cygnus.errors.CygnusBadContextData;\n+import com.telefonica.iot.cygnus.errors.CygnusCappingError;\n+import com.telefonica.iot.cygnus.errors.CygnusExpiratingError;\n+import com.telefonica.iot.cygnus.errors.CygnusPersistenceError;\n+import com.telefonica.iot.cygnus.errors.CygnusRuntimeError;\n+import com.telefonica.iot.cygnus.interceptors.NGSIEvent;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+import com.telefonica.iot.cygnus.utils.NGSIConstants;\n+\n+import jodd.util.URLDecoder;\n+\n+/**\n+ *\n+ * @author dmartinez\n+ * \n+ *         Detailed documentation can be found at:\n+ *         https://github.com/telefonicaid/fiware-cygnus/blob/master/doc/flume_extensions_catalogue/ngsi_arcgis_sink.md\n+ */\n+public class NGSIArcgisFeatureTableSink extends NGSISink {\n+\n+    private static final String DEFAULT_ARCGIS_SERVICE_URL = \"localhost\";\n+    private static final String DEFAULT_GETTOKEN_URL = \"localhost\";\n+    private static final String DEFAULT_USER_NAME = \"root\";\n+    private static final String DEFAULT_PASSWORD = \"\";\n+    private static final int DEFAULT_MAX_BATCH_SIZE = 10;\n+    private static final int DEFAULT_BATCH_TIMEOUT_SECS = 60;\n+    private static final String ARCGIS_INSTANCE_NAME = \"arcgis\";\n+\n+    private static final CygnusLogger LOGGER = new CygnusLogger(NGSIArcgisFeatureTableSink.class);\n+    private String arcgisServicesUrl;\n+    private String getTokenUrl;\n+    private String userName;\n+    private String password;\n+    private int maxBatchSize;\n+    private long timeoutSecs;\n+    private static volatile Map<String, NGSIArcgisFeatureTable> arcgisPersistenceBackend;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public NGSIArcgisFeatureTableSink() {\n+        super();\n+    } // NGSIArcgisFeatureTableSink\n+\n+    /**\n+     * Gets the Argis services url. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The services url\n+     */\n+    protected String getrAcgisServicesUrl() {\n+        return arcgisServicesUrl;\n+    } // getrAcgisServicesUrl\n+\n+    /**\n+     * Gets getToken's service url.\n+     * \n+     * @return\n+     */\n+    public String getGetTokenUrl() {\n+        return getTokenUrl;\n+    }\n+\n+    /**\n+     * Sets getToken service url.\n+     * \n+     * @param getTokenUrl\n+     */\n+    public void setGetTokenUrl(String getTokenUrl) {\n+        this.getTokenUrl = getTokenUrl;\n+    }\n+\n+    /**\n+     * Gets the username. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The username\n+     */\n+    protected String getUsername() {\n+        return userName;\n+    } // getUsername\n+\n+    /**\n+     * Gets the password. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The password\n+     */\n+    protected String getPassword() {\n+        return password;\n+    } // getPassword\n+\n+    /**\n+     * \n+     */\n+    protected int featuresBatched() {\n+        int total = 0;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table != null) {\n+                total += table.featuresBatched();\n+            }\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Returns the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The persistence backend\n+     * @throws CygnusRuntimeError\n+     */\n+    protected ArcgisFeatureTable getPersistenceBackend(String featureServiceUrl) throws CygnusRuntimeError {\n+\n+        if (arcgisPersistenceBackend.containsKey(featureServiceUrl)) {\n+            return arcgisPersistenceBackend.get(featureServiceUrl);\n+        } else {\n+            LOGGER.debug(\"Creating new persistenceBackend for Feature table: \" + featureServiceUrl);\n+            LOGGER.debug(\"Token url: \" + getGetTokenUrl());\n+            LOGGER.debug(\"User name: \" + getUsername());\n+            LOGGER.debug(\"Passwd: \" + getPassword());\n+            try {\n+                NGSIArcgisFeatureTable newTable = new NGSIArcgisFeatureTable(featureServiceUrl, getUsername(),\n+                        getPassword(), getGetTokenUrl(), timeoutSecs, LOGGER);\n+                newTable.setBatchAction(ArcgisFeatureTable.ADD_UPDATE_ACTION);\n+                newTable.setBatchSize(maxBatchSize);\n+\n+                if (newTable.hasError()) {\n+                    throw new CygnusRuntimeError(\"[\" + this.getName() + \"Error creating Persistence backend: \"\n+                            + newTable.getErrorCode() + \" - \" + newTable.getErrorDesc());\n+                } else {\n+                    arcgisPersistenceBackend.put(featureServiceUrl, newTable);\n+                    return newTable;\n+                }\n+            } catch (Throwable e) {\n+                String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+                LOGGER.debug(stackTrace);\n+                throw new CygnusRuntimeError(\"Error creating new persistence Backend. \", e.getClass().getName(),\n+                        e.getMessage());\n+            }\n+        }\n+    } // getPersistenceBackend\n+\n+    /**\n+     * Sets the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @param persistenceBackend\n+     */\n+    protected void setPersistenceBackend(String featureServiceUrl, NGSIArcgisFeatureTable persistenceBackend) {\n+        arcgisPersistenceBackend.put(featureServiceUrl, persistenceBackend);\n+    } // setPersistenceBackend\n+\n+    @Override\n+    public void configure(Context context) {\n+        arcgisServicesUrl = context.getString(\"arcgis_service_url\", DEFAULT_ARCGIS_SERVICE_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_service_url=\" + arcgisServicesUrl + \")\");\n+\n+        getTokenUrl = context.getString(\"arcgis_gettoken_url\", DEFAULT_GETTOKEN_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_fearcgis_gettoken_urlature_table_url=\"\n+                + getTokenUrl + \")\");\n+\n+        userName = context.getString(\"arcgis_username\", DEFAULT_USER_NAME);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_username=\" + userName + \")\");\n+        // FIXME: Password should be read encrypted and decoded here\n+        password = context.getString(\"arcgis_password\", DEFAULT_PASSWORD);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_password=\" + password + \")\");\n+\n+        maxBatchSize = context.getInteger(\"arcgis_maxBatchSize\", DEFAULT_MAX_BATCH_SIZE);\n+        if (maxBatchSize <= 0 || maxBatchSize > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_maxBatchSize=\" + maxBatchSize + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_maxBatchSize=\" + maxBatchSize + \")\");\n+        }\n+\n+        timeoutSecs = context.getInteger(\"arcgis_timeoutSecs\", DEFAULT_BATCH_TIMEOUT_SECS);\n+        if (timeoutSecs <= 0 || timeoutSecs > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_timeoutSecs=\" + timeoutSecs + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_timeoutSecs=\" + maxBatchSize + \")\");\n+        }\n+\n+        super.configure(context);\n+    } // configure\n+\n+    @Override\n+    public void start() {\n+        try {\n+            createPersistenceBackend();\n+            LOGGER.debug(\"[\" + this.getName() + \"] Arcgis persistence backend created\");\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error while creating the Arcgis persistence backend. Details=\" + e.getMessage());\n+        } // try catch\n+\n+        super.start();\n+    } // start\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (arcgisPersistenceBackend != null) {\n+            for (Map.Entry<String, NGSIArcgisFeatureTable> backend : arcgisPersistenceBackend.entrySet()) {\n+                backend.getValue().flushBatch();\n+            }\n+            arcgisPersistenceBackend.clear();\n+        }\n+    } // stop\n+\n+    /**\n+     * Initialices a lazy singleton to share among instances on JVM.\n+     */\n+    private static synchronized void createPersistenceBackend() {\n+        if (arcgisPersistenceBackend == null) {\n+            arcgisPersistenceBackend = new ConcurrentHashMap<String, NGSIArcgisFeatureTable>();\n+        }\n+    }\n+\n+    @Override\n+    void persistBatch(NGSIBatch batch)\n+            throws CygnusBadConfiguration, CygnusPersistenceError, CygnusRuntimeError, CygnusBadContextData {\n+        if (batch == null) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Null batch, nothing to do\");\n+            return;\n+        } // if\n+\n+        try {\n+            // Iterate on the destinations\n+            batch.startIterator();\n+\n+            while (batch.hasNext()) {\n+                String destination = batch.getNextDestination();\n+                LOGGER.debug(\n+                        \"[\" + this.getName() + \"] Processing sub-batch regarding the \" + destination + \" destination\");\n+\n+                // Get the events within the current sub-batch\n+                ArrayList<NGSIEvent> events = batch.getNextEvents();\n+\n+                // Get an aggregator for this destination and initialize it\n+                NGSIArcgisAggregator aggregator = new NGSIArcgisAggregator(getrAcgisServicesUrl(), enableNameMappings);\n+                // aggregator.setService(events.get(0).getServiceForNaming(enableNameMappings));\n+                // aggregator.setServicePathForData(events.get(0).getServicePathForData());\n+                // aggregator.setServicePathForNaming(events.get(0).getServicePathForNaming(enableGrouping,\n+                // enableNameMappings));\n+                // aggregator.setEntityForNaming(events.get(0).getEntityForNaming(enableGrouping, enableNameMappings,\n+                // enableEncoding));\n+                // aggregator.setEntityType(events.get(0).getEntityTypeForNaming(enableGrouping, enableNameMappings));\n+                // aggregator.setAttribute(events.get(0).getAttributeForNaming(enableNameMappings));\n+                // aggregator.setDbName(buildDbName(aggregator.getService()));\n+                // aggregator.setTableName(buildTableName(aggregator.getServicePathForNaming(),\n+                // aggregator.getEntityForNaming(), aggregator.getEntityType(), aggregator.getAttribute()));\n+                // aggregator.setAttrNativeTypes(attrNativeTypes);\n+                // aggregator.setAttrMetadataStore(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 299}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMzMTIzOQ==", "bodyText": "Done.", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r414331239", "createdAt": "2020-04-24T06:38:14Z", "author": {"login": "pmo-sdr"}, "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "diffHunk": "@@ -0,0 +1,789 @@\n+/**\n+ * Copyright 2014-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+\n+package com.telefonica.iot.cygnus.sinks;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.commons.lang.exception.ExceptionUtils;\n+import org.apache.flume.Context;\n+import org.apache.flume.EventDeliveryException;\n+import org.json.JSONException;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Point;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.ArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.NGSIArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextAttribute;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextElement;\n+import com.telefonica.iot.cygnus.errors.CygnusBadConfiguration;\n+import com.telefonica.iot.cygnus.errors.CygnusBadContextData;\n+import com.telefonica.iot.cygnus.errors.CygnusCappingError;\n+import com.telefonica.iot.cygnus.errors.CygnusExpiratingError;\n+import com.telefonica.iot.cygnus.errors.CygnusPersistenceError;\n+import com.telefonica.iot.cygnus.errors.CygnusRuntimeError;\n+import com.telefonica.iot.cygnus.interceptors.NGSIEvent;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+import com.telefonica.iot.cygnus.utils.NGSIConstants;\n+\n+import jodd.util.URLDecoder;\n+\n+/**\n+ *\n+ * @author dmartinez\n+ * \n+ *         Detailed documentation can be found at:\n+ *         https://github.com/telefonicaid/fiware-cygnus/blob/master/doc/flume_extensions_catalogue/ngsi_arcgis_sink.md\n+ */\n+public class NGSIArcgisFeatureTableSink extends NGSISink {\n+\n+    private static final String DEFAULT_ARCGIS_SERVICE_URL = \"localhost\";\n+    private static final String DEFAULT_GETTOKEN_URL = \"localhost\";\n+    private static final String DEFAULT_USER_NAME = \"root\";\n+    private static final String DEFAULT_PASSWORD = \"\";\n+    private static final int DEFAULT_MAX_BATCH_SIZE = 10;\n+    private static final int DEFAULT_BATCH_TIMEOUT_SECS = 60;\n+    private static final String ARCGIS_INSTANCE_NAME = \"arcgis\";\n+\n+    private static final CygnusLogger LOGGER = new CygnusLogger(NGSIArcgisFeatureTableSink.class);\n+    private String arcgisServicesUrl;\n+    private String getTokenUrl;\n+    private String userName;\n+    private String password;\n+    private int maxBatchSize;\n+    private long timeoutSecs;\n+    private static volatile Map<String, NGSIArcgisFeatureTable> arcgisPersistenceBackend;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public NGSIArcgisFeatureTableSink() {\n+        super();\n+    } // NGSIArcgisFeatureTableSink\n+\n+    /**\n+     * Gets the Argis services url. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The services url\n+     */\n+    protected String getrAcgisServicesUrl() {\n+        return arcgisServicesUrl;\n+    } // getrAcgisServicesUrl\n+\n+    /**\n+     * Gets getToken's service url.\n+     * \n+     * @return\n+     */\n+    public String getGetTokenUrl() {\n+        return getTokenUrl;\n+    }\n+\n+    /**\n+     * Sets getToken service url.\n+     * \n+     * @param getTokenUrl\n+     */\n+    public void setGetTokenUrl(String getTokenUrl) {\n+        this.getTokenUrl = getTokenUrl;\n+    }\n+\n+    /**\n+     * Gets the username. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The username\n+     */\n+    protected String getUsername() {\n+        return userName;\n+    } // getUsername\n+\n+    /**\n+     * Gets the password. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The password\n+     */\n+    protected String getPassword() {\n+        return password;\n+    } // getPassword\n+\n+    /**\n+     * \n+     */\n+    protected int featuresBatched() {\n+        int total = 0;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table != null) {\n+                total += table.featuresBatched();\n+            }\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Returns the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The persistence backend\n+     * @throws CygnusRuntimeError\n+     */\n+    protected ArcgisFeatureTable getPersistenceBackend(String featureServiceUrl) throws CygnusRuntimeError {\n+\n+        if (arcgisPersistenceBackend.containsKey(featureServiceUrl)) {\n+            return arcgisPersistenceBackend.get(featureServiceUrl);\n+        } else {\n+            LOGGER.debug(\"Creating new persistenceBackend for Feature table: \" + featureServiceUrl);\n+            LOGGER.debug(\"Token url: \" + getGetTokenUrl());\n+            LOGGER.debug(\"User name: \" + getUsername());\n+            LOGGER.debug(\"Passwd: \" + getPassword());\n+            try {\n+                NGSIArcgisFeatureTable newTable = new NGSIArcgisFeatureTable(featureServiceUrl, getUsername(),\n+                        getPassword(), getGetTokenUrl(), timeoutSecs, LOGGER);\n+                newTable.setBatchAction(ArcgisFeatureTable.ADD_UPDATE_ACTION);\n+                newTable.setBatchSize(maxBatchSize);\n+\n+                if (newTable.hasError()) {\n+                    throw new CygnusRuntimeError(\"[\" + this.getName() + \"Error creating Persistence backend: \"\n+                            + newTable.getErrorCode() + \" - \" + newTable.getErrorDesc());\n+                } else {\n+                    arcgisPersistenceBackend.put(featureServiceUrl, newTable);\n+                    return newTable;\n+                }\n+            } catch (Throwable e) {\n+                String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+                LOGGER.debug(stackTrace);\n+                throw new CygnusRuntimeError(\"Error creating new persistence Backend. \", e.getClass().getName(),\n+                        e.getMessage());\n+            }\n+        }\n+    } // getPersistenceBackend\n+\n+    /**\n+     * Sets the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @param persistenceBackend\n+     */\n+    protected void setPersistenceBackend(String featureServiceUrl, NGSIArcgisFeatureTable persistenceBackend) {\n+        arcgisPersistenceBackend.put(featureServiceUrl, persistenceBackend);\n+    } // setPersistenceBackend\n+\n+    @Override\n+    public void configure(Context context) {\n+        arcgisServicesUrl = context.getString(\"arcgis_service_url\", DEFAULT_ARCGIS_SERVICE_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_service_url=\" + arcgisServicesUrl + \")\");\n+\n+        getTokenUrl = context.getString(\"arcgis_gettoken_url\", DEFAULT_GETTOKEN_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_fearcgis_gettoken_urlature_table_url=\"\n+                + getTokenUrl + \")\");\n+\n+        userName = context.getString(\"arcgis_username\", DEFAULT_USER_NAME);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_username=\" + userName + \")\");\n+        // FIXME: Password should be read encrypted and decoded here\n+        password = context.getString(\"arcgis_password\", DEFAULT_PASSWORD);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_password=\" + password + \")\");\n+\n+        maxBatchSize = context.getInteger(\"arcgis_maxBatchSize\", DEFAULT_MAX_BATCH_SIZE);\n+        if (maxBatchSize <= 0 || maxBatchSize > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_maxBatchSize=\" + maxBatchSize + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_maxBatchSize=\" + maxBatchSize + \")\");\n+        }\n+\n+        timeoutSecs = context.getInteger(\"arcgis_timeoutSecs\", DEFAULT_BATCH_TIMEOUT_SECS);\n+        if (timeoutSecs <= 0 || timeoutSecs > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_timeoutSecs=\" + timeoutSecs + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_timeoutSecs=\" + maxBatchSize + \")\");\n+        }\n+\n+        super.configure(context);\n+    } // configure\n+\n+    @Override\n+    public void start() {\n+        try {\n+            createPersistenceBackend();\n+            LOGGER.debug(\"[\" + this.getName() + \"] Arcgis persistence backend created\");\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error while creating the Arcgis persistence backend. Details=\" + e.getMessage());\n+        } // try catch\n+\n+        super.start();\n+    } // start\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (arcgisPersistenceBackend != null) {\n+            for (Map.Entry<String, NGSIArcgisFeatureTable> backend : arcgisPersistenceBackend.entrySet()) {\n+                backend.getValue().flushBatch();\n+            }\n+            arcgisPersistenceBackend.clear();\n+        }\n+    } // stop\n+\n+    /**\n+     * Initialices a lazy singleton to share among instances on JVM.\n+     */\n+    private static synchronized void createPersistenceBackend() {\n+        if (arcgisPersistenceBackend == null) {\n+            arcgisPersistenceBackend = new ConcurrentHashMap<String, NGSIArcgisFeatureTable>();\n+        }\n+    }\n+\n+    @Override\n+    void persistBatch(NGSIBatch batch)\n+            throws CygnusBadConfiguration, CygnusPersistenceError, CygnusRuntimeError, CygnusBadContextData {\n+        if (batch == null) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Null batch, nothing to do\");\n+            return;\n+        } // if\n+\n+        try {\n+            // Iterate on the destinations\n+            batch.startIterator();\n+\n+            while (batch.hasNext()) {\n+                String destination = batch.getNextDestination();\n+                LOGGER.debug(\n+                        \"[\" + this.getName() + \"] Processing sub-batch regarding the \" + destination + \" destination\");\n+\n+                // Get the events within the current sub-batch\n+                ArrayList<NGSIEvent> events = batch.getNextEvents();\n+\n+                // Get an aggregator for this destination and initialize it\n+                NGSIArcgisAggregator aggregator = new NGSIArcgisAggregator(getrAcgisServicesUrl(), enableNameMappings);\n+                // aggregator.setService(events.get(0).getServiceForNaming(enableNameMappings));\n+                // aggregator.setServicePathForData(events.get(0).getServicePathForData());\n+                // aggregator.setServicePathForNaming(events.get(0).getServicePathForNaming(enableGrouping,\n+                // enableNameMappings));\n+                // aggregator.setEntityForNaming(events.get(0).getEntityForNaming(enableGrouping, enableNameMappings,\n+                // enableEncoding));\n+                // aggregator.setEntityType(events.get(0).getEntityTypeForNaming(enableGrouping, enableNameMappings));\n+                // aggregator.setAttribute(events.get(0).getAttributeForNaming(enableNameMappings));\n+                // aggregator.setDbName(buildDbName(aggregator.getService()));\n+                // aggregator.setTableName(buildTableName(aggregator.getServicePathForNaming(),\n+                // aggregator.getEntityForNaming(), aggregator.getEntityType(), aggregator.getAttribute()));\n+                // aggregator.setAttrNativeTypes(attrNativeTypes);\n+                // aggregator.setAttrMetadataStore(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyMjgxMA=="}, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 299}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ1NzY5Mw==", "bodyText": "Fixed in e531743", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r414457693", "createdAt": "2020-04-24T10:08:58Z", "author": {"login": "IvanHdzC"}, "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "diffHunk": "@@ -0,0 +1,789 @@\n+/**\n+ * Copyright 2014-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+\n+package com.telefonica.iot.cygnus.sinks;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.commons.lang.exception.ExceptionUtils;\n+import org.apache.flume.Context;\n+import org.apache.flume.EventDeliveryException;\n+import org.json.JSONException;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Point;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.ArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.NGSIArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextAttribute;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextElement;\n+import com.telefonica.iot.cygnus.errors.CygnusBadConfiguration;\n+import com.telefonica.iot.cygnus.errors.CygnusBadContextData;\n+import com.telefonica.iot.cygnus.errors.CygnusCappingError;\n+import com.telefonica.iot.cygnus.errors.CygnusExpiratingError;\n+import com.telefonica.iot.cygnus.errors.CygnusPersistenceError;\n+import com.telefonica.iot.cygnus.errors.CygnusRuntimeError;\n+import com.telefonica.iot.cygnus.interceptors.NGSIEvent;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+import com.telefonica.iot.cygnus.utils.NGSIConstants;\n+\n+import jodd.util.URLDecoder;\n+\n+/**\n+ *\n+ * @author dmartinez\n+ * \n+ *         Detailed documentation can be found at:\n+ *         https://github.com/telefonicaid/fiware-cygnus/blob/master/doc/flume_extensions_catalogue/ngsi_arcgis_sink.md\n+ */\n+public class NGSIArcgisFeatureTableSink extends NGSISink {\n+\n+    private static final String DEFAULT_ARCGIS_SERVICE_URL = \"localhost\";\n+    private static final String DEFAULT_GETTOKEN_URL = \"localhost\";\n+    private static final String DEFAULT_USER_NAME = \"root\";\n+    private static final String DEFAULT_PASSWORD = \"\";\n+    private static final int DEFAULT_MAX_BATCH_SIZE = 10;\n+    private static final int DEFAULT_BATCH_TIMEOUT_SECS = 60;\n+    private static final String ARCGIS_INSTANCE_NAME = \"arcgis\";\n+\n+    private static final CygnusLogger LOGGER = new CygnusLogger(NGSIArcgisFeatureTableSink.class);\n+    private String arcgisServicesUrl;\n+    private String getTokenUrl;\n+    private String userName;\n+    private String password;\n+    private int maxBatchSize;\n+    private long timeoutSecs;\n+    private static volatile Map<String, NGSIArcgisFeatureTable> arcgisPersistenceBackend;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public NGSIArcgisFeatureTableSink() {\n+        super();\n+    } // NGSIArcgisFeatureTableSink\n+\n+    /**\n+     * Gets the Argis services url. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The services url\n+     */\n+    protected String getrAcgisServicesUrl() {\n+        return arcgisServicesUrl;\n+    } // getrAcgisServicesUrl\n+\n+    /**\n+     * Gets getToken's service url.\n+     * \n+     * @return\n+     */\n+    public String getGetTokenUrl() {\n+        return getTokenUrl;\n+    }\n+\n+    /**\n+     * Sets getToken service url.\n+     * \n+     * @param getTokenUrl\n+     */\n+    public void setGetTokenUrl(String getTokenUrl) {\n+        this.getTokenUrl = getTokenUrl;\n+    }\n+\n+    /**\n+     * Gets the username. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The username\n+     */\n+    protected String getUsername() {\n+        return userName;\n+    } // getUsername\n+\n+    /**\n+     * Gets the password. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The password\n+     */\n+    protected String getPassword() {\n+        return password;\n+    } // getPassword\n+\n+    /**\n+     * \n+     */\n+    protected int featuresBatched() {\n+        int total = 0;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table != null) {\n+                total += table.featuresBatched();\n+            }\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Returns the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The persistence backend\n+     * @throws CygnusRuntimeError\n+     */\n+    protected ArcgisFeatureTable getPersistenceBackend(String featureServiceUrl) throws CygnusRuntimeError {\n+\n+        if (arcgisPersistenceBackend.containsKey(featureServiceUrl)) {\n+            return arcgisPersistenceBackend.get(featureServiceUrl);\n+        } else {\n+            LOGGER.debug(\"Creating new persistenceBackend for Feature table: \" + featureServiceUrl);\n+            LOGGER.debug(\"Token url: \" + getGetTokenUrl());\n+            LOGGER.debug(\"User name: \" + getUsername());\n+            LOGGER.debug(\"Passwd: \" + getPassword());\n+            try {\n+                NGSIArcgisFeatureTable newTable = new NGSIArcgisFeatureTable(featureServiceUrl, getUsername(),\n+                        getPassword(), getGetTokenUrl(), timeoutSecs, LOGGER);\n+                newTable.setBatchAction(ArcgisFeatureTable.ADD_UPDATE_ACTION);\n+                newTable.setBatchSize(maxBatchSize);\n+\n+                if (newTable.hasError()) {\n+                    throw new CygnusRuntimeError(\"[\" + this.getName() + \"Error creating Persistence backend: \"\n+                            + newTable.getErrorCode() + \" - \" + newTable.getErrorDesc());\n+                } else {\n+                    arcgisPersistenceBackend.put(featureServiceUrl, newTable);\n+                    return newTable;\n+                }\n+            } catch (Throwable e) {\n+                String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+                LOGGER.debug(stackTrace);\n+                throw new CygnusRuntimeError(\"Error creating new persistence Backend. \", e.getClass().getName(),\n+                        e.getMessage());\n+            }\n+        }\n+    } // getPersistenceBackend\n+\n+    /**\n+     * Sets the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @param persistenceBackend\n+     */\n+    protected void setPersistenceBackend(String featureServiceUrl, NGSIArcgisFeatureTable persistenceBackend) {\n+        arcgisPersistenceBackend.put(featureServiceUrl, persistenceBackend);\n+    } // setPersistenceBackend\n+\n+    @Override\n+    public void configure(Context context) {\n+        arcgisServicesUrl = context.getString(\"arcgis_service_url\", DEFAULT_ARCGIS_SERVICE_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_service_url=\" + arcgisServicesUrl + \")\");\n+\n+        getTokenUrl = context.getString(\"arcgis_gettoken_url\", DEFAULT_GETTOKEN_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_fearcgis_gettoken_urlature_table_url=\"\n+                + getTokenUrl + \")\");\n+\n+        userName = context.getString(\"arcgis_username\", DEFAULT_USER_NAME);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_username=\" + userName + \")\");\n+        // FIXME: Password should be read encrypted and decoded here\n+        password = context.getString(\"arcgis_password\", DEFAULT_PASSWORD);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_password=\" + password + \")\");\n+\n+        maxBatchSize = context.getInteger(\"arcgis_maxBatchSize\", DEFAULT_MAX_BATCH_SIZE);\n+        if (maxBatchSize <= 0 || maxBatchSize > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_maxBatchSize=\" + maxBatchSize + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_maxBatchSize=\" + maxBatchSize + \")\");\n+        }\n+\n+        timeoutSecs = context.getInteger(\"arcgis_timeoutSecs\", DEFAULT_BATCH_TIMEOUT_SECS);\n+        if (timeoutSecs <= 0 || timeoutSecs > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_timeoutSecs=\" + timeoutSecs + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_timeoutSecs=\" + maxBatchSize + \")\");\n+        }\n+\n+        super.configure(context);\n+    } // configure\n+\n+    @Override\n+    public void start() {\n+        try {\n+            createPersistenceBackend();\n+            LOGGER.debug(\"[\" + this.getName() + \"] Arcgis persistence backend created\");\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error while creating the Arcgis persistence backend. Details=\" + e.getMessage());\n+        } // try catch\n+\n+        super.start();\n+    } // start\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (arcgisPersistenceBackend != null) {\n+            for (Map.Entry<String, NGSIArcgisFeatureTable> backend : arcgisPersistenceBackend.entrySet()) {\n+                backend.getValue().flushBatch();\n+            }\n+            arcgisPersistenceBackend.clear();\n+        }\n+    } // stop\n+\n+    /**\n+     * Initialices a lazy singleton to share among instances on JVM.\n+     */\n+    private static synchronized void createPersistenceBackend() {\n+        if (arcgisPersistenceBackend == null) {\n+            arcgisPersistenceBackend = new ConcurrentHashMap<String, NGSIArcgisFeatureTable>();\n+        }\n+    }\n+\n+    @Override\n+    void persistBatch(NGSIBatch batch)\n+            throws CygnusBadConfiguration, CygnusPersistenceError, CygnusRuntimeError, CygnusBadContextData {\n+        if (batch == null) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Null batch, nothing to do\");\n+            return;\n+        } // if\n+\n+        try {\n+            // Iterate on the destinations\n+            batch.startIterator();\n+\n+            while (batch.hasNext()) {\n+                String destination = batch.getNextDestination();\n+                LOGGER.debug(\n+                        \"[\" + this.getName() + \"] Processing sub-batch regarding the \" + destination + \" destination\");\n+\n+                // Get the events within the current sub-batch\n+                ArrayList<NGSIEvent> events = batch.getNextEvents();\n+\n+                // Get an aggregator for this destination and initialize it\n+                NGSIArcgisAggregator aggregator = new NGSIArcgisAggregator(getrAcgisServicesUrl(), enableNameMappings);\n+                // aggregator.setService(events.get(0).getServiceForNaming(enableNameMappings));\n+                // aggregator.setServicePathForData(events.get(0).getServicePathForData());\n+                // aggregator.setServicePathForNaming(events.get(0).getServicePathForNaming(enableGrouping,\n+                // enableNameMappings));\n+                // aggregator.setEntityForNaming(events.get(0).getEntityForNaming(enableGrouping, enableNameMappings,\n+                // enableEncoding));\n+                // aggregator.setEntityType(events.get(0).getEntityTypeForNaming(enableGrouping, enableNameMappings));\n+                // aggregator.setAttribute(events.get(0).getAttributeForNaming(enableNameMappings));\n+                // aggregator.setDbName(buildDbName(aggregator.getService()));\n+                // aggregator.setTableName(buildTableName(aggregator.getServicePathForNaming(),\n+                // aggregator.getEntityForNaming(), aggregator.getEntityType(), aggregator.getAttribute()));\n+                // aggregator.setAttrNativeTypes(attrNativeTypes);\n+                // aggregator.setAttrMetadataStore(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyMjgxMA=="}, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 299}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTM5NjgwOnYy", "diffSide": "RIGHT", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMTowNzoxMFrOGKjtFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxMTozMTowMVrOGNPifw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyMzkyNg==", "bodyText": "Is this call necessary?", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r413723926", "createdAt": "2020-04-23T11:07:10Z", "author": {"login": "IvanHdzC"}, "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "diffHunk": "@@ -0,0 +1,789 @@\n+/**\n+ * Copyright 2014-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+\n+package com.telefonica.iot.cygnus.sinks;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.commons.lang.exception.ExceptionUtils;\n+import org.apache.flume.Context;\n+import org.apache.flume.EventDeliveryException;\n+import org.json.JSONException;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Point;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.ArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.NGSIArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextAttribute;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextElement;\n+import com.telefonica.iot.cygnus.errors.CygnusBadConfiguration;\n+import com.telefonica.iot.cygnus.errors.CygnusBadContextData;\n+import com.telefonica.iot.cygnus.errors.CygnusCappingError;\n+import com.telefonica.iot.cygnus.errors.CygnusExpiratingError;\n+import com.telefonica.iot.cygnus.errors.CygnusPersistenceError;\n+import com.telefonica.iot.cygnus.errors.CygnusRuntimeError;\n+import com.telefonica.iot.cygnus.interceptors.NGSIEvent;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+import com.telefonica.iot.cygnus.utils.NGSIConstants;\n+\n+import jodd.util.URLDecoder;\n+\n+/**\n+ *\n+ * @author dmartinez\n+ * \n+ *         Detailed documentation can be found at:\n+ *         https://github.com/telefonicaid/fiware-cygnus/blob/master/doc/flume_extensions_catalogue/ngsi_arcgis_sink.md\n+ */\n+public class NGSIArcgisFeatureTableSink extends NGSISink {\n+\n+    private static final String DEFAULT_ARCGIS_SERVICE_URL = \"localhost\";\n+    private static final String DEFAULT_GETTOKEN_URL = \"localhost\";\n+    private static final String DEFAULT_USER_NAME = \"root\";\n+    private static final String DEFAULT_PASSWORD = \"\";\n+    private static final int DEFAULT_MAX_BATCH_SIZE = 10;\n+    private static final int DEFAULT_BATCH_TIMEOUT_SECS = 60;\n+    private static final String ARCGIS_INSTANCE_NAME = \"arcgis\";\n+\n+    private static final CygnusLogger LOGGER = new CygnusLogger(NGSIArcgisFeatureTableSink.class);\n+    private String arcgisServicesUrl;\n+    private String getTokenUrl;\n+    private String userName;\n+    private String password;\n+    private int maxBatchSize;\n+    private long timeoutSecs;\n+    private static volatile Map<String, NGSIArcgisFeatureTable> arcgisPersistenceBackend;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public NGSIArcgisFeatureTableSink() {\n+        super();\n+    } // NGSIArcgisFeatureTableSink\n+\n+    /**\n+     * Gets the Argis services url. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The services url\n+     */\n+    protected String getrAcgisServicesUrl() {\n+        return arcgisServicesUrl;\n+    } // getrAcgisServicesUrl\n+\n+    /**\n+     * Gets getToken's service url.\n+     * \n+     * @return\n+     */\n+    public String getGetTokenUrl() {\n+        return getTokenUrl;\n+    }\n+\n+    /**\n+     * Sets getToken service url.\n+     * \n+     * @param getTokenUrl\n+     */\n+    public void setGetTokenUrl(String getTokenUrl) {\n+        this.getTokenUrl = getTokenUrl;\n+    }\n+\n+    /**\n+     * Gets the username. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The username\n+     */\n+    protected String getUsername() {\n+        return userName;\n+    } // getUsername\n+\n+    /**\n+     * Gets the password. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The password\n+     */\n+    protected String getPassword() {\n+        return password;\n+    } // getPassword\n+\n+    /**\n+     * \n+     */\n+    protected int featuresBatched() {\n+        int total = 0;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table != null) {\n+                total += table.featuresBatched();\n+            }\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Returns the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The persistence backend\n+     * @throws CygnusRuntimeError\n+     */\n+    protected ArcgisFeatureTable getPersistenceBackend(String featureServiceUrl) throws CygnusRuntimeError {\n+\n+        if (arcgisPersistenceBackend.containsKey(featureServiceUrl)) {\n+            return arcgisPersistenceBackend.get(featureServiceUrl);\n+        } else {\n+            LOGGER.debug(\"Creating new persistenceBackend for Feature table: \" + featureServiceUrl);\n+            LOGGER.debug(\"Token url: \" + getGetTokenUrl());\n+            LOGGER.debug(\"User name: \" + getUsername());\n+            LOGGER.debug(\"Passwd: \" + getPassword());\n+            try {\n+                NGSIArcgisFeatureTable newTable = new NGSIArcgisFeatureTable(featureServiceUrl, getUsername(),\n+                        getPassword(), getGetTokenUrl(), timeoutSecs, LOGGER);\n+                newTable.setBatchAction(ArcgisFeatureTable.ADD_UPDATE_ACTION);\n+                newTable.setBatchSize(maxBatchSize);\n+\n+                if (newTable.hasError()) {\n+                    throw new CygnusRuntimeError(\"[\" + this.getName() + \"Error creating Persistence backend: \"\n+                            + newTable.getErrorCode() + \" - \" + newTable.getErrorDesc());\n+                } else {\n+                    arcgisPersistenceBackend.put(featureServiceUrl, newTable);\n+                    return newTable;\n+                }\n+            } catch (Throwable e) {\n+                String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+                LOGGER.debug(stackTrace);\n+                throw new CygnusRuntimeError(\"Error creating new persistence Backend. \", e.getClass().getName(),\n+                        e.getMessage());\n+            }\n+        }\n+    } // getPersistenceBackend\n+\n+    /**\n+     * Sets the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @param persistenceBackend\n+     */\n+    protected void setPersistenceBackend(String featureServiceUrl, NGSIArcgisFeatureTable persistenceBackend) {\n+        arcgisPersistenceBackend.put(featureServiceUrl, persistenceBackend);\n+    } // setPersistenceBackend\n+\n+    @Override\n+    public void configure(Context context) {\n+        arcgisServicesUrl = context.getString(\"arcgis_service_url\", DEFAULT_ARCGIS_SERVICE_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_service_url=\" + arcgisServicesUrl + \")\");\n+\n+        getTokenUrl = context.getString(\"arcgis_gettoken_url\", DEFAULT_GETTOKEN_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_fearcgis_gettoken_urlature_table_url=\"\n+                + getTokenUrl + \")\");\n+\n+        userName = context.getString(\"arcgis_username\", DEFAULT_USER_NAME);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_username=\" + userName + \")\");\n+        // FIXME: Password should be read encrypted and decoded here\n+        password = context.getString(\"arcgis_password\", DEFAULT_PASSWORD);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_password=\" + password + \")\");\n+\n+        maxBatchSize = context.getInteger(\"arcgis_maxBatchSize\", DEFAULT_MAX_BATCH_SIZE);\n+        if (maxBatchSize <= 0 || maxBatchSize > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_maxBatchSize=\" + maxBatchSize + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_maxBatchSize=\" + maxBatchSize + \")\");\n+        }\n+\n+        timeoutSecs = context.getInteger(\"arcgis_timeoutSecs\", DEFAULT_BATCH_TIMEOUT_SECS);\n+        if (timeoutSecs <= 0 || timeoutSecs > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_timeoutSecs=\" + timeoutSecs + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_timeoutSecs=\" + maxBatchSize + \")\");\n+        }\n+\n+        super.configure(context);\n+    } // configure\n+\n+    @Override\n+    public void start() {\n+        try {\n+            createPersistenceBackend();\n+            LOGGER.debug(\"[\" + this.getName() + \"] Arcgis persistence backend created\");\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error while creating the Arcgis persistence backend. Details=\" + e.getMessage());\n+        } // try catch\n+\n+        super.start();\n+    } // start\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (arcgisPersistenceBackend != null) {\n+            for (Map.Entry<String, NGSIArcgisFeatureTable> backend : arcgisPersistenceBackend.entrySet()) {\n+                backend.getValue().flushBatch();\n+            }\n+            arcgisPersistenceBackend.clear();\n+        }\n+    } // stop\n+\n+    /**\n+     * Initialices a lazy singleton to share among instances on JVM.\n+     */\n+    private static synchronized void createPersistenceBackend() {\n+        if (arcgisPersistenceBackend == null) {\n+            arcgisPersistenceBackend = new ConcurrentHashMap<String, NGSIArcgisFeatureTable>();\n+        }\n+    }\n+\n+    @Override\n+    void persistBatch(NGSIBatch batch)\n+            throws CygnusBadConfiguration, CygnusPersistenceError, CygnusRuntimeError, CygnusBadContextData {\n+        if (batch == null) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Null batch, nothing to do\");\n+            return;\n+        } // if\n+\n+        try {\n+            // Iterate on the destinations\n+            batch.startIterator();\n+\n+            while (batch.hasNext()) {\n+                String destination = batch.getNextDestination();\n+                LOGGER.debug(\n+                        \"[\" + this.getName() + \"] Processing sub-batch regarding the \" + destination + \" destination\");\n+\n+                // Get the events within the current sub-batch\n+                ArrayList<NGSIEvent> events = batch.getNextEvents();\n+\n+                // Get an aggregator for this destination and initialize it\n+                NGSIArcgisAggregator aggregator = new NGSIArcgisAggregator(getrAcgisServicesUrl(), enableNameMappings);\n+                // aggregator.setService(events.get(0).getServiceForNaming(enableNameMappings));\n+                // aggregator.setServicePathForData(events.get(0).getServicePathForData());\n+                // aggregator.setServicePathForNaming(events.get(0).getServicePathForNaming(enableGrouping,\n+                // enableNameMappings));\n+                // aggregator.setEntityForNaming(events.get(0).getEntityForNaming(enableGrouping, enableNameMappings,\n+                // enableEncoding));\n+                // aggregator.setEntityType(events.get(0).getEntityTypeForNaming(enableGrouping, enableNameMappings));\n+                // aggregator.setAttribute(events.get(0).getAttributeForNaming(enableNameMappings));\n+                // aggregator.setDbName(buildDbName(aggregator.getService()));\n+                // aggregator.setTableName(buildTableName(aggregator.getServicePathForNaming(),\n+                // aggregator.getEntityForNaming(), aggregator.getEntityType(), aggregator.getAttribute()));\n+                // aggregator.setAttrNativeTypes(attrNativeTypes);\n+                // aggregator.setAttrMetadataStore(false);\n+                aggregator.initialize(events.get(0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 300}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUzOTI2Mw==", "bodyText": "Removed\nStdri@1941e81", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r416539263", "createdAt": "2020-04-28T11:31:01Z", "author": {"login": "pmo-sdr"}, "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "diffHunk": "@@ -0,0 +1,789 @@\n+/**\n+ * Copyright 2014-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+\n+package com.telefonica.iot.cygnus.sinks;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.commons.lang.exception.ExceptionUtils;\n+import org.apache.flume.Context;\n+import org.apache.flume.EventDeliveryException;\n+import org.json.JSONException;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Point;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.ArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.NGSIArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextAttribute;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextElement;\n+import com.telefonica.iot.cygnus.errors.CygnusBadConfiguration;\n+import com.telefonica.iot.cygnus.errors.CygnusBadContextData;\n+import com.telefonica.iot.cygnus.errors.CygnusCappingError;\n+import com.telefonica.iot.cygnus.errors.CygnusExpiratingError;\n+import com.telefonica.iot.cygnus.errors.CygnusPersistenceError;\n+import com.telefonica.iot.cygnus.errors.CygnusRuntimeError;\n+import com.telefonica.iot.cygnus.interceptors.NGSIEvent;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+import com.telefonica.iot.cygnus.utils.NGSIConstants;\n+\n+import jodd.util.URLDecoder;\n+\n+/**\n+ *\n+ * @author dmartinez\n+ * \n+ *         Detailed documentation can be found at:\n+ *         https://github.com/telefonicaid/fiware-cygnus/blob/master/doc/flume_extensions_catalogue/ngsi_arcgis_sink.md\n+ */\n+public class NGSIArcgisFeatureTableSink extends NGSISink {\n+\n+    private static final String DEFAULT_ARCGIS_SERVICE_URL = \"localhost\";\n+    private static final String DEFAULT_GETTOKEN_URL = \"localhost\";\n+    private static final String DEFAULT_USER_NAME = \"root\";\n+    private static final String DEFAULT_PASSWORD = \"\";\n+    private static final int DEFAULT_MAX_BATCH_SIZE = 10;\n+    private static final int DEFAULT_BATCH_TIMEOUT_SECS = 60;\n+    private static final String ARCGIS_INSTANCE_NAME = \"arcgis\";\n+\n+    private static final CygnusLogger LOGGER = new CygnusLogger(NGSIArcgisFeatureTableSink.class);\n+    private String arcgisServicesUrl;\n+    private String getTokenUrl;\n+    private String userName;\n+    private String password;\n+    private int maxBatchSize;\n+    private long timeoutSecs;\n+    private static volatile Map<String, NGSIArcgisFeatureTable> arcgisPersistenceBackend;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public NGSIArcgisFeatureTableSink() {\n+        super();\n+    } // NGSIArcgisFeatureTableSink\n+\n+    /**\n+     * Gets the Argis services url. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The services url\n+     */\n+    protected String getrAcgisServicesUrl() {\n+        return arcgisServicesUrl;\n+    } // getrAcgisServicesUrl\n+\n+    /**\n+     * Gets getToken's service url.\n+     * \n+     * @return\n+     */\n+    public String getGetTokenUrl() {\n+        return getTokenUrl;\n+    }\n+\n+    /**\n+     * Sets getToken service url.\n+     * \n+     * @param getTokenUrl\n+     */\n+    public void setGetTokenUrl(String getTokenUrl) {\n+        this.getTokenUrl = getTokenUrl;\n+    }\n+\n+    /**\n+     * Gets the username. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The username\n+     */\n+    protected String getUsername() {\n+        return userName;\n+    } // getUsername\n+\n+    /**\n+     * Gets the password. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The password\n+     */\n+    protected String getPassword() {\n+        return password;\n+    } // getPassword\n+\n+    /**\n+     * \n+     */\n+    protected int featuresBatched() {\n+        int total = 0;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table != null) {\n+                total += table.featuresBatched();\n+            }\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Returns the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The persistence backend\n+     * @throws CygnusRuntimeError\n+     */\n+    protected ArcgisFeatureTable getPersistenceBackend(String featureServiceUrl) throws CygnusRuntimeError {\n+\n+        if (arcgisPersistenceBackend.containsKey(featureServiceUrl)) {\n+            return arcgisPersistenceBackend.get(featureServiceUrl);\n+        } else {\n+            LOGGER.debug(\"Creating new persistenceBackend for Feature table: \" + featureServiceUrl);\n+            LOGGER.debug(\"Token url: \" + getGetTokenUrl());\n+            LOGGER.debug(\"User name: \" + getUsername());\n+            LOGGER.debug(\"Passwd: \" + getPassword());\n+            try {\n+                NGSIArcgisFeatureTable newTable = new NGSIArcgisFeatureTable(featureServiceUrl, getUsername(),\n+                        getPassword(), getGetTokenUrl(), timeoutSecs, LOGGER);\n+                newTable.setBatchAction(ArcgisFeatureTable.ADD_UPDATE_ACTION);\n+                newTable.setBatchSize(maxBatchSize);\n+\n+                if (newTable.hasError()) {\n+                    throw new CygnusRuntimeError(\"[\" + this.getName() + \"Error creating Persistence backend: \"\n+                            + newTable.getErrorCode() + \" - \" + newTable.getErrorDesc());\n+                } else {\n+                    arcgisPersistenceBackend.put(featureServiceUrl, newTable);\n+                    return newTable;\n+                }\n+            } catch (Throwable e) {\n+                String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+                LOGGER.debug(stackTrace);\n+                throw new CygnusRuntimeError(\"Error creating new persistence Backend. \", e.getClass().getName(),\n+                        e.getMessage());\n+            }\n+        }\n+    } // getPersistenceBackend\n+\n+    /**\n+     * Sets the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @param persistenceBackend\n+     */\n+    protected void setPersistenceBackend(String featureServiceUrl, NGSIArcgisFeatureTable persistenceBackend) {\n+        arcgisPersistenceBackend.put(featureServiceUrl, persistenceBackend);\n+    } // setPersistenceBackend\n+\n+    @Override\n+    public void configure(Context context) {\n+        arcgisServicesUrl = context.getString(\"arcgis_service_url\", DEFAULT_ARCGIS_SERVICE_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_service_url=\" + arcgisServicesUrl + \")\");\n+\n+        getTokenUrl = context.getString(\"arcgis_gettoken_url\", DEFAULT_GETTOKEN_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_fearcgis_gettoken_urlature_table_url=\"\n+                + getTokenUrl + \")\");\n+\n+        userName = context.getString(\"arcgis_username\", DEFAULT_USER_NAME);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_username=\" + userName + \")\");\n+        // FIXME: Password should be read encrypted and decoded here\n+        password = context.getString(\"arcgis_password\", DEFAULT_PASSWORD);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_password=\" + password + \")\");\n+\n+        maxBatchSize = context.getInteger(\"arcgis_maxBatchSize\", DEFAULT_MAX_BATCH_SIZE);\n+        if (maxBatchSize <= 0 || maxBatchSize > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_maxBatchSize=\" + maxBatchSize + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_maxBatchSize=\" + maxBatchSize + \")\");\n+        }\n+\n+        timeoutSecs = context.getInteger(\"arcgis_timeoutSecs\", DEFAULT_BATCH_TIMEOUT_SECS);\n+        if (timeoutSecs <= 0 || timeoutSecs > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_timeoutSecs=\" + timeoutSecs + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_timeoutSecs=\" + maxBatchSize + \")\");\n+        }\n+\n+        super.configure(context);\n+    } // configure\n+\n+    @Override\n+    public void start() {\n+        try {\n+            createPersistenceBackend();\n+            LOGGER.debug(\"[\" + this.getName() + \"] Arcgis persistence backend created\");\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error while creating the Arcgis persistence backend. Details=\" + e.getMessage());\n+        } // try catch\n+\n+        super.start();\n+    } // start\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (arcgisPersistenceBackend != null) {\n+            for (Map.Entry<String, NGSIArcgisFeatureTable> backend : arcgisPersistenceBackend.entrySet()) {\n+                backend.getValue().flushBatch();\n+            }\n+            arcgisPersistenceBackend.clear();\n+        }\n+    } // stop\n+\n+    /**\n+     * Initialices a lazy singleton to share among instances on JVM.\n+     */\n+    private static synchronized void createPersistenceBackend() {\n+        if (arcgisPersistenceBackend == null) {\n+            arcgisPersistenceBackend = new ConcurrentHashMap<String, NGSIArcgisFeatureTable>();\n+        }\n+    }\n+\n+    @Override\n+    void persistBatch(NGSIBatch batch)\n+            throws CygnusBadConfiguration, CygnusPersistenceError, CygnusRuntimeError, CygnusBadContextData {\n+        if (batch == null) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Null batch, nothing to do\");\n+            return;\n+        } // if\n+\n+        try {\n+            // Iterate on the destinations\n+            batch.startIterator();\n+\n+            while (batch.hasNext()) {\n+                String destination = batch.getNextDestination();\n+                LOGGER.debug(\n+                        \"[\" + this.getName() + \"] Processing sub-batch regarding the \" + destination + \" destination\");\n+\n+                // Get the events within the current sub-batch\n+                ArrayList<NGSIEvent> events = batch.getNextEvents();\n+\n+                // Get an aggregator for this destination and initialize it\n+                NGSIArcgisAggregator aggregator = new NGSIArcgisAggregator(getrAcgisServicesUrl(), enableNameMappings);\n+                // aggregator.setService(events.get(0).getServiceForNaming(enableNameMappings));\n+                // aggregator.setServicePathForData(events.get(0).getServicePathForData());\n+                // aggregator.setServicePathForNaming(events.get(0).getServicePathForNaming(enableGrouping,\n+                // enableNameMappings));\n+                // aggregator.setEntityForNaming(events.get(0).getEntityForNaming(enableGrouping, enableNameMappings,\n+                // enableEncoding));\n+                // aggregator.setEntityType(events.get(0).getEntityTypeForNaming(enableGrouping, enableNameMappings));\n+                // aggregator.setAttribute(events.get(0).getAttributeForNaming(enableNameMappings));\n+                // aggregator.setDbName(buildDbName(aggregator.getService()));\n+                // aggregator.setTableName(buildTableName(aggregator.getServicePathForNaming(),\n+                // aggregator.getEntityForNaming(), aggregator.getEntityType(), aggregator.getAttribute()));\n+                // aggregator.setAttrNativeTypes(attrNativeTypes);\n+                // aggregator.setAttrMetadataStore(false);\n+                aggregator.initialize(events.get(0));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyMzkyNg=="}, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 300}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTQwMjI2OnYy", "diffSide": "RIGHT", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMTowODoyNlrOGKjwOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwODoxNDo0N1rOGMWhWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyNDczMQ==", "bodyText": "Is this necessary? The constructor that matches with that signature seems to be empty.", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r413724731", "createdAt": "2020-04-23T11:08:26Z", "author": {"login": "IvanHdzC"}, "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "diffHunk": "@@ -0,0 +1,789 @@\n+/**\n+ * Copyright 2014-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+\n+package com.telefonica.iot.cygnus.sinks;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.commons.lang.exception.ExceptionUtils;\n+import org.apache.flume.Context;\n+import org.apache.flume.EventDeliveryException;\n+import org.json.JSONException;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Point;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.ArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.NGSIArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextAttribute;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextElement;\n+import com.telefonica.iot.cygnus.errors.CygnusBadConfiguration;\n+import com.telefonica.iot.cygnus.errors.CygnusBadContextData;\n+import com.telefonica.iot.cygnus.errors.CygnusCappingError;\n+import com.telefonica.iot.cygnus.errors.CygnusExpiratingError;\n+import com.telefonica.iot.cygnus.errors.CygnusPersistenceError;\n+import com.telefonica.iot.cygnus.errors.CygnusRuntimeError;\n+import com.telefonica.iot.cygnus.interceptors.NGSIEvent;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+import com.telefonica.iot.cygnus.utils.NGSIConstants;\n+\n+import jodd.util.URLDecoder;\n+\n+/**\n+ *\n+ * @author dmartinez\n+ * \n+ *         Detailed documentation can be found at:\n+ *         https://github.com/telefonicaid/fiware-cygnus/blob/master/doc/flume_extensions_catalogue/ngsi_arcgis_sink.md\n+ */\n+public class NGSIArcgisFeatureTableSink extends NGSISink {\n+\n+    private static final String DEFAULT_ARCGIS_SERVICE_URL = \"localhost\";\n+    private static final String DEFAULT_GETTOKEN_URL = \"localhost\";\n+    private static final String DEFAULT_USER_NAME = \"root\";\n+    private static final String DEFAULT_PASSWORD = \"\";\n+    private static final int DEFAULT_MAX_BATCH_SIZE = 10;\n+    private static final int DEFAULT_BATCH_TIMEOUT_SECS = 60;\n+    private static final String ARCGIS_INSTANCE_NAME = \"arcgis\";\n+\n+    private static final CygnusLogger LOGGER = new CygnusLogger(NGSIArcgisFeatureTableSink.class);\n+    private String arcgisServicesUrl;\n+    private String getTokenUrl;\n+    private String userName;\n+    private String password;\n+    private int maxBatchSize;\n+    private long timeoutSecs;\n+    private static volatile Map<String, NGSIArcgisFeatureTable> arcgisPersistenceBackend;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public NGSIArcgisFeatureTableSink() {\n+        super();\n+    } // NGSIArcgisFeatureTableSink\n+\n+    /**\n+     * Gets the Argis services url. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The services url\n+     */\n+    protected String getrAcgisServicesUrl() {\n+        return arcgisServicesUrl;\n+    } // getrAcgisServicesUrl\n+\n+    /**\n+     * Gets getToken's service url.\n+     * \n+     * @return\n+     */\n+    public String getGetTokenUrl() {\n+        return getTokenUrl;\n+    }\n+\n+    /**\n+     * Sets getToken service url.\n+     * \n+     * @param getTokenUrl\n+     */\n+    public void setGetTokenUrl(String getTokenUrl) {\n+        this.getTokenUrl = getTokenUrl;\n+    }\n+\n+    /**\n+     * Gets the username. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The username\n+     */\n+    protected String getUsername() {\n+        return userName;\n+    } // getUsername\n+\n+    /**\n+     * Gets the password. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The password\n+     */\n+    protected String getPassword() {\n+        return password;\n+    } // getPassword\n+\n+    /**\n+     * \n+     */\n+    protected int featuresBatched() {\n+        int total = 0;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table != null) {\n+                total += table.featuresBatched();\n+            }\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Returns the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The persistence backend\n+     * @throws CygnusRuntimeError\n+     */\n+    protected ArcgisFeatureTable getPersistenceBackend(String featureServiceUrl) throws CygnusRuntimeError {\n+\n+        if (arcgisPersistenceBackend.containsKey(featureServiceUrl)) {\n+            return arcgisPersistenceBackend.get(featureServiceUrl);\n+        } else {\n+            LOGGER.debug(\"Creating new persistenceBackend for Feature table: \" + featureServiceUrl);\n+            LOGGER.debug(\"Token url: \" + getGetTokenUrl());\n+            LOGGER.debug(\"User name: \" + getUsername());\n+            LOGGER.debug(\"Passwd: \" + getPassword());\n+            try {\n+                NGSIArcgisFeatureTable newTable = new NGSIArcgisFeatureTable(featureServiceUrl, getUsername(),\n+                        getPassword(), getGetTokenUrl(), timeoutSecs, LOGGER);\n+                newTable.setBatchAction(ArcgisFeatureTable.ADD_UPDATE_ACTION);\n+                newTable.setBatchSize(maxBatchSize);\n+\n+                if (newTable.hasError()) {\n+                    throw new CygnusRuntimeError(\"[\" + this.getName() + \"Error creating Persistence backend: \"\n+                            + newTable.getErrorCode() + \" - \" + newTable.getErrorDesc());\n+                } else {\n+                    arcgisPersistenceBackend.put(featureServiceUrl, newTable);\n+                    return newTable;\n+                }\n+            } catch (Throwable e) {\n+                String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+                LOGGER.debug(stackTrace);\n+                throw new CygnusRuntimeError(\"Error creating new persistence Backend. \", e.getClass().getName(),\n+                        e.getMessage());\n+            }\n+        }\n+    } // getPersistenceBackend\n+\n+    /**\n+     * Sets the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @param persistenceBackend\n+     */\n+    protected void setPersistenceBackend(String featureServiceUrl, NGSIArcgisFeatureTable persistenceBackend) {\n+        arcgisPersistenceBackend.put(featureServiceUrl, persistenceBackend);\n+    } // setPersistenceBackend\n+\n+    @Override\n+    public void configure(Context context) {\n+        arcgisServicesUrl = context.getString(\"arcgis_service_url\", DEFAULT_ARCGIS_SERVICE_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_service_url=\" + arcgisServicesUrl + \")\");\n+\n+        getTokenUrl = context.getString(\"arcgis_gettoken_url\", DEFAULT_GETTOKEN_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_fearcgis_gettoken_urlature_table_url=\"\n+                + getTokenUrl + \")\");\n+\n+        userName = context.getString(\"arcgis_username\", DEFAULT_USER_NAME);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_username=\" + userName + \")\");\n+        // FIXME: Password should be read encrypted and decoded here\n+        password = context.getString(\"arcgis_password\", DEFAULT_PASSWORD);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_password=\" + password + \")\");\n+\n+        maxBatchSize = context.getInteger(\"arcgis_maxBatchSize\", DEFAULT_MAX_BATCH_SIZE);\n+        if (maxBatchSize <= 0 || maxBatchSize > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_maxBatchSize=\" + maxBatchSize + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_maxBatchSize=\" + maxBatchSize + \")\");\n+        }\n+\n+        timeoutSecs = context.getInteger(\"arcgis_timeoutSecs\", DEFAULT_BATCH_TIMEOUT_SECS);\n+        if (timeoutSecs <= 0 || timeoutSecs > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_timeoutSecs=\" + timeoutSecs + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_timeoutSecs=\" + maxBatchSize + \")\");\n+        }\n+\n+        super.configure(context);\n+    } // configure\n+\n+    @Override\n+    public void start() {\n+        try {\n+            createPersistenceBackend();\n+            LOGGER.debug(\"[\" + this.getName() + \"] Arcgis persistence backend created\");\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error while creating the Arcgis persistence backend. Details=\" + e.getMessage());\n+        } // try catch\n+\n+        super.start();\n+    } // start\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (arcgisPersistenceBackend != null) {\n+            for (Map.Entry<String, NGSIArcgisFeatureTable> backend : arcgisPersistenceBackend.entrySet()) {\n+                backend.getValue().flushBatch();\n+            }\n+            arcgisPersistenceBackend.clear();\n+        }\n+    } // stop\n+\n+    /**\n+     * Initialices a lazy singleton to share among instances on JVM.\n+     */\n+    private static synchronized void createPersistenceBackend() {\n+        if (arcgisPersistenceBackend == null) {\n+            arcgisPersistenceBackend = new ConcurrentHashMap<String, NGSIArcgisFeatureTable>();\n+        }\n+    }\n+\n+    @Override\n+    void persistBatch(NGSIBatch batch)\n+            throws CygnusBadConfiguration, CygnusPersistenceError, CygnusRuntimeError, CygnusBadContextData {\n+        if (batch == null) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Null batch, nothing to do\");\n+            return;\n+        } // if\n+\n+        try {\n+            // Iterate on the destinations\n+            batch.startIterator();\n+\n+            while (batch.hasNext()) {\n+                String destination = batch.getNextDestination();\n+                LOGGER.debug(\n+                        \"[\" + this.getName() + \"] Processing sub-batch regarding the \" + destination + \" destination\");\n+\n+                // Get the events within the current sub-batch\n+                ArrayList<NGSIEvent> events = batch.getNextEvents();\n+\n+                // Get an aggregator for this destination and initialize it\n+                NGSIArcgisAggregator aggregator = new NGSIArcgisAggregator(getrAcgisServicesUrl(), enableNameMappings);\n+                // aggregator.setService(events.get(0).getServiceForNaming(enableNameMappings));\n+                // aggregator.setServicePathForData(events.get(0).getServicePathForData());\n+                // aggregator.setServicePathForNaming(events.get(0).getServicePathForNaming(enableGrouping,\n+                // enableNameMappings));\n+                // aggregator.setEntityForNaming(events.get(0).getEntityForNaming(enableGrouping, enableNameMappings,\n+                // enableEncoding));\n+                // aggregator.setEntityType(events.get(0).getEntityTypeForNaming(enableGrouping, enableNameMappings));\n+                // aggregator.setAttribute(events.get(0).getAttributeForNaming(enableNameMappings));\n+                // aggregator.setDbName(buildDbName(aggregator.getService()));\n+                // aggregator.setTableName(buildTableName(aggregator.getServicePathForNaming(),\n+                // aggregator.getEntityForNaming(), aggregator.getEntityType(), aggregator.getAttribute()));\n+                // aggregator.setAttrNativeTypes(attrNativeTypes);\n+                // aggregator.setAttrMetadataStore(false);\n+                aggregator.initialize(events.get(0));\n+                for (NGSIEvent event : events) {\n+                    aggregator.aggregate(event);\n+                } // for\n+\n+                // Persist the aggregation\n+                persistAggregation(aggregator);\n+                batch.setNextPersisted(true);\n+\n+            } // while\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistBatch\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see com.telefonica.iot.cygnus.sinks.NGSISink#process()\n+     */\n+    @Override\n+    public Status process() throws EventDeliveryException {\n+        checkTimeouts();\n+        Status status = null;\n+        try {\n+            status = super.process();\n+        } catch (Throwable e) {\n+            LOGGER.error(e.getMessage() + \"Stack trace: \" + Arrays.toString(e.getStackTrace()));\n+        }\n+        return status;\n+    }\n+\n+    /**\n+     * Flush if timeout.\n+     */\n+    protected void checkTimeouts() {\n+        boolean timeoutFound = false;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table.hasTimeout()) {\n+                timeoutFound = true;\n+                LOGGER.info(\"[\" + this.getName() + \"] Feature table Timeout, flushing batch. \" + entry.getKey());\n+                table.flushBatch();\n+            }\n+        }\n+        if (!timeoutFound) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] No Feature table Timeouts found. Features in batch: \"\n+                    + featuresBatched());\n+        }\n+    }\n+\n+    @Override\n+    public void capRecords(NGSIBatch batch, long maxRecords) throws CygnusCappingError {\n+        // no capping\n+        LOGGER.warn(\"[\" + this.getName() + \"] Skipping capping records, just persisting it.\");\n+        try {\n+            persistBatch(batch);\n+        } catch (CygnusBadConfiguration | CygnusPersistenceError | CygnusRuntimeError | CygnusBadContextData e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error capping Records: \" + e);\n+            throw new CygnusCappingError(e.getMessage());\n+        }\n+    } // capRecords\n+\n+    @Override\n+    public void expirateRecords(long expirationTime) throws CygnusExpiratingError {\n+        LOGGER.debug(\"[\" + this.getName() + \"] Expirating records (time=\" + expirationTime + \")\");\n+\n+    } // expirateRecords\n+\n+    /**\n+     * Persist Aggregation.\n+     * \n+     * @param aggregator\n+     * @throws CygnusRuntimeError\n+     */\n+    public void persistAggregation(NGSIArcgisAggregator aggregator) throws CygnusRuntimeError {\n+        try {\n+            List<ArcgisAggregatorDomain> aggregationList = aggregator.getListArcgisAggregatorDomain();\n+            LOGGER.debug(\"[\" + this.getName() + \"] persisting aggregation, \"\n+                    + aggregator.getListArcgisAggregatorDomain().size() + \" features.\");\n+            for (ArcgisAggregatorDomain aggregation : aggregationList) {\n+                String featureTableUrl = aggregation.getFeatureTableUrl();\n+\n+                boolean isNewFeatureTable = !arcgisPersistenceBackend.containsKey(featureTableUrl);\n+                LOGGER.debug(\"[\" + this.getName() + \"] persistAggregation - Feature table: \" + featureTableUrl\n+                        + \" is new: \" + isNewFeatureTable);\n+                ArcgisFeatureTable featureTable = getPersistenceBackend(featureTableUrl);\n+\n+                // If it's a new one, sets uniqueField value\n+                if (isNewFeatureTable) {\n+                    LOGGER.debug(\"[\" + this.getName() + \"] Created new backend for \" + featureTableUrl\n+                            + \" with uniqueField: \" + aggregation.getUniqueField());\n+                    featureTable.setUniqueField(aggregation.getUniqueField());\n+                }\n+\n+                featureTable.addToBatch(aggregation.getFeature());\n+            }\n+        } catch (CygnusRuntimeError e) {\n+            String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+            LOGGER.debug(\" PersistAggregation Error: \" + stackTrace);\n+            throw (e);\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getClass().getSimpleName() + \" - \"\n+                    + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistAggregation\n+\n+    /**\n+     * @author dmartinez\n+     *\n+     */\n+    public class NGSIArcgisAggregator {\n+\n+        private List<ArcgisAggregatorDomain> listArcgisAggregatorDomain = new ArrayList<ArcgisAggregatorDomain>();\n+        private boolean enableNameMappings = true;\n+        private String argisServiceUrl = \"\";\n+\n+        private NGSIArcgisAggregator() {\n+        } // ArcgisAggregator\n+\n+        /**\n+         * Constructor.\n+         * \n+         * @param argisServiceUrl\n+         * @param enableNameMappings\n+         */\n+        public NGSIArcgisAggregator(String argisServiceUrl, boolean enableNameMappings) {\n+            this();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 429}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYwNTA4Mw==", "bodyText": "It's no empty anymore.\nhttps://github.com/Stdri/fiware-cygnus/blob/c8d4419a2cf00210fcaf968d5ed96375ce2828cd/cygnus-ngsi/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java#L407-L411", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r415605083", "createdAt": "2020-04-27T08:14:47Z", "author": {"login": "pmo-sdr"}, "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "diffHunk": "@@ -0,0 +1,789 @@\n+/**\n+ * Copyright 2014-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+\n+package com.telefonica.iot.cygnus.sinks;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.commons.lang.exception.ExceptionUtils;\n+import org.apache.flume.Context;\n+import org.apache.flume.EventDeliveryException;\n+import org.json.JSONException;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Point;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.ArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.NGSIArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextAttribute;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextElement;\n+import com.telefonica.iot.cygnus.errors.CygnusBadConfiguration;\n+import com.telefonica.iot.cygnus.errors.CygnusBadContextData;\n+import com.telefonica.iot.cygnus.errors.CygnusCappingError;\n+import com.telefonica.iot.cygnus.errors.CygnusExpiratingError;\n+import com.telefonica.iot.cygnus.errors.CygnusPersistenceError;\n+import com.telefonica.iot.cygnus.errors.CygnusRuntimeError;\n+import com.telefonica.iot.cygnus.interceptors.NGSIEvent;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+import com.telefonica.iot.cygnus.utils.NGSIConstants;\n+\n+import jodd.util.URLDecoder;\n+\n+/**\n+ *\n+ * @author dmartinez\n+ * \n+ *         Detailed documentation can be found at:\n+ *         https://github.com/telefonicaid/fiware-cygnus/blob/master/doc/flume_extensions_catalogue/ngsi_arcgis_sink.md\n+ */\n+public class NGSIArcgisFeatureTableSink extends NGSISink {\n+\n+    private static final String DEFAULT_ARCGIS_SERVICE_URL = \"localhost\";\n+    private static final String DEFAULT_GETTOKEN_URL = \"localhost\";\n+    private static final String DEFAULT_USER_NAME = \"root\";\n+    private static final String DEFAULT_PASSWORD = \"\";\n+    private static final int DEFAULT_MAX_BATCH_SIZE = 10;\n+    private static final int DEFAULT_BATCH_TIMEOUT_SECS = 60;\n+    private static final String ARCGIS_INSTANCE_NAME = \"arcgis\";\n+\n+    private static final CygnusLogger LOGGER = new CygnusLogger(NGSIArcgisFeatureTableSink.class);\n+    private String arcgisServicesUrl;\n+    private String getTokenUrl;\n+    private String userName;\n+    private String password;\n+    private int maxBatchSize;\n+    private long timeoutSecs;\n+    private static volatile Map<String, NGSIArcgisFeatureTable> arcgisPersistenceBackend;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public NGSIArcgisFeatureTableSink() {\n+        super();\n+    } // NGSIArcgisFeatureTableSink\n+\n+    /**\n+     * Gets the Argis services url. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The services url\n+     */\n+    protected String getrAcgisServicesUrl() {\n+        return arcgisServicesUrl;\n+    } // getrAcgisServicesUrl\n+\n+    /**\n+     * Gets getToken's service url.\n+     * \n+     * @return\n+     */\n+    public String getGetTokenUrl() {\n+        return getTokenUrl;\n+    }\n+\n+    /**\n+     * Sets getToken service url.\n+     * \n+     * @param getTokenUrl\n+     */\n+    public void setGetTokenUrl(String getTokenUrl) {\n+        this.getTokenUrl = getTokenUrl;\n+    }\n+\n+    /**\n+     * Gets the username. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The username\n+     */\n+    protected String getUsername() {\n+        return userName;\n+    } // getUsername\n+\n+    /**\n+     * Gets the password. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The password\n+     */\n+    protected String getPassword() {\n+        return password;\n+    } // getPassword\n+\n+    /**\n+     * \n+     */\n+    protected int featuresBatched() {\n+        int total = 0;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table != null) {\n+                total += table.featuresBatched();\n+            }\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Returns the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The persistence backend\n+     * @throws CygnusRuntimeError\n+     */\n+    protected ArcgisFeatureTable getPersistenceBackend(String featureServiceUrl) throws CygnusRuntimeError {\n+\n+        if (arcgisPersistenceBackend.containsKey(featureServiceUrl)) {\n+            return arcgisPersistenceBackend.get(featureServiceUrl);\n+        } else {\n+            LOGGER.debug(\"Creating new persistenceBackend for Feature table: \" + featureServiceUrl);\n+            LOGGER.debug(\"Token url: \" + getGetTokenUrl());\n+            LOGGER.debug(\"User name: \" + getUsername());\n+            LOGGER.debug(\"Passwd: \" + getPassword());\n+            try {\n+                NGSIArcgisFeatureTable newTable = new NGSIArcgisFeatureTable(featureServiceUrl, getUsername(),\n+                        getPassword(), getGetTokenUrl(), timeoutSecs, LOGGER);\n+                newTable.setBatchAction(ArcgisFeatureTable.ADD_UPDATE_ACTION);\n+                newTable.setBatchSize(maxBatchSize);\n+\n+                if (newTable.hasError()) {\n+                    throw new CygnusRuntimeError(\"[\" + this.getName() + \"Error creating Persistence backend: \"\n+                            + newTable.getErrorCode() + \" - \" + newTable.getErrorDesc());\n+                } else {\n+                    arcgisPersistenceBackend.put(featureServiceUrl, newTable);\n+                    return newTable;\n+                }\n+            } catch (Throwable e) {\n+                String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+                LOGGER.debug(stackTrace);\n+                throw new CygnusRuntimeError(\"Error creating new persistence Backend. \", e.getClass().getName(),\n+                        e.getMessage());\n+            }\n+        }\n+    } // getPersistenceBackend\n+\n+    /**\n+     * Sets the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @param persistenceBackend\n+     */\n+    protected void setPersistenceBackend(String featureServiceUrl, NGSIArcgisFeatureTable persistenceBackend) {\n+        arcgisPersistenceBackend.put(featureServiceUrl, persistenceBackend);\n+    } // setPersistenceBackend\n+\n+    @Override\n+    public void configure(Context context) {\n+        arcgisServicesUrl = context.getString(\"arcgis_service_url\", DEFAULT_ARCGIS_SERVICE_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_service_url=\" + arcgisServicesUrl + \")\");\n+\n+        getTokenUrl = context.getString(\"arcgis_gettoken_url\", DEFAULT_GETTOKEN_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_fearcgis_gettoken_urlature_table_url=\"\n+                + getTokenUrl + \")\");\n+\n+        userName = context.getString(\"arcgis_username\", DEFAULT_USER_NAME);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_username=\" + userName + \")\");\n+        // FIXME: Password should be read encrypted and decoded here\n+        password = context.getString(\"arcgis_password\", DEFAULT_PASSWORD);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_password=\" + password + \")\");\n+\n+        maxBatchSize = context.getInteger(\"arcgis_maxBatchSize\", DEFAULT_MAX_BATCH_SIZE);\n+        if (maxBatchSize <= 0 || maxBatchSize > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_maxBatchSize=\" + maxBatchSize + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_maxBatchSize=\" + maxBatchSize + \")\");\n+        }\n+\n+        timeoutSecs = context.getInteger(\"arcgis_timeoutSecs\", DEFAULT_BATCH_TIMEOUT_SECS);\n+        if (timeoutSecs <= 0 || timeoutSecs > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_timeoutSecs=\" + timeoutSecs + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_timeoutSecs=\" + maxBatchSize + \")\");\n+        }\n+\n+        super.configure(context);\n+    } // configure\n+\n+    @Override\n+    public void start() {\n+        try {\n+            createPersistenceBackend();\n+            LOGGER.debug(\"[\" + this.getName() + \"] Arcgis persistence backend created\");\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error while creating the Arcgis persistence backend. Details=\" + e.getMessage());\n+        } // try catch\n+\n+        super.start();\n+    } // start\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (arcgisPersistenceBackend != null) {\n+            for (Map.Entry<String, NGSIArcgisFeatureTable> backend : arcgisPersistenceBackend.entrySet()) {\n+                backend.getValue().flushBatch();\n+            }\n+            arcgisPersistenceBackend.clear();\n+        }\n+    } // stop\n+\n+    /**\n+     * Initialices a lazy singleton to share among instances on JVM.\n+     */\n+    private static synchronized void createPersistenceBackend() {\n+        if (arcgisPersistenceBackend == null) {\n+            arcgisPersistenceBackend = new ConcurrentHashMap<String, NGSIArcgisFeatureTable>();\n+        }\n+    }\n+\n+    @Override\n+    void persistBatch(NGSIBatch batch)\n+            throws CygnusBadConfiguration, CygnusPersistenceError, CygnusRuntimeError, CygnusBadContextData {\n+        if (batch == null) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Null batch, nothing to do\");\n+            return;\n+        } // if\n+\n+        try {\n+            // Iterate on the destinations\n+            batch.startIterator();\n+\n+            while (batch.hasNext()) {\n+                String destination = batch.getNextDestination();\n+                LOGGER.debug(\n+                        \"[\" + this.getName() + \"] Processing sub-batch regarding the \" + destination + \" destination\");\n+\n+                // Get the events within the current sub-batch\n+                ArrayList<NGSIEvent> events = batch.getNextEvents();\n+\n+                // Get an aggregator for this destination and initialize it\n+                NGSIArcgisAggregator aggregator = new NGSIArcgisAggregator(getrAcgisServicesUrl(), enableNameMappings);\n+                // aggregator.setService(events.get(0).getServiceForNaming(enableNameMappings));\n+                // aggregator.setServicePathForData(events.get(0).getServicePathForData());\n+                // aggregator.setServicePathForNaming(events.get(0).getServicePathForNaming(enableGrouping,\n+                // enableNameMappings));\n+                // aggregator.setEntityForNaming(events.get(0).getEntityForNaming(enableGrouping, enableNameMappings,\n+                // enableEncoding));\n+                // aggregator.setEntityType(events.get(0).getEntityTypeForNaming(enableGrouping, enableNameMappings));\n+                // aggregator.setAttribute(events.get(0).getAttributeForNaming(enableNameMappings));\n+                // aggregator.setDbName(buildDbName(aggregator.getService()));\n+                // aggregator.setTableName(buildTableName(aggregator.getServicePathForNaming(),\n+                // aggregator.getEntityForNaming(), aggregator.getEntityType(), aggregator.getAttribute()));\n+                // aggregator.setAttrNativeTypes(attrNativeTypes);\n+                // aggregator.setAttrMetadataStore(false);\n+                aggregator.initialize(events.get(0));\n+                for (NGSIEvent event : events) {\n+                    aggregator.aggregate(event);\n+                } // for\n+\n+                // Persist the aggregation\n+                persistAggregation(aggregator);\n+                batch.setNextPersisted(true);\n+\n+            } // while\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistBatch\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see com.telefonica.iot.cygnus.sinks.NGSISink#process()\n+     */\n+    @Override\n+    public Status process() throws EventDeliveryException {\n+        checkTimeouts();\n+        Status status = null;\n+        try {\n+            status = super.process();\n+        } catch (Throwable e) {\n+            LOGGER.error(e.getMessage() + \"Stack trace: \" + Arrays.toString(e.getStackTrace()));\n+        }\n+        return status;\n+    }\n+\n+    /**\n+     * Flush if timeout.\n+     */\n+    protected void checkTimeouts() {\n+        boolean timeoutFound = false;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table.hasTimeout()) {\n+                timeoutFound = true;\n+                LOGGER.info(\"[\" + this.getName() + \"] Feature table Timeout, flushing batch. \" + entry.getKey());\n+                table.flushBatch();\n+            }\n+        }\n+        if (!timeoutFound) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] No Feature table Timeouts found. Features in batch: \"\n+                    + featuresBatched());\n+        }\n+    }\n+\n+    @Override\n+    public void capRecords(NGSIBatch batch, long maxRecords) throws CygnusCappingError {\n+        // no capping\n+        LOGGER.warn(\"[\" + this.getName() + \"] Skipping capping records, just persisting it.\");\n+        try {\n+            persistBatch(batch);\n+        } catch (CygnusBadConfiguration | CygnusPersistenceError | CygnusRuntimeError | CygnusBadContextData e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error capping Records: \" + e);\n+            throw new CygnusCappingError(e.getMessage());\n+        }\n+    } // capRecords\n+\n+    @Override\n+    public void expirateRecords(long expirationTime) throws CygnusExpiratingError {\n+        LOGGER.debug(\"[\" + this.getName() + \"] Expirating records (time=\" + expirationTime + \")\");\n+\n+    } // expirateRecords\n+\n+    /**\n+     * Persist Aggregation.\n+     * \n+     * @param aggregator\n+     * @throws CygnusRuntimeError\n+     */\n+    public void persistAggregation(NGSIArcgisAggregator aggregator) throws CygnusRuntimeError {\n+        try {\n+            List<ArcgisAggregatorDomain> aggregationList = aggregator.getListArcgisAggregatorDomain();\n+            LOGGER.debug(\"[\" + this.getName() + \"] persisting aggregation, \"\n+                    + aggregator.getListArcgisAggregatorDomain().size() + \" features.\");\n+            for (ArcgisAggregatorDomain aggregation : aggregationList) {\n+                String featureTableUrl = aggregation.getFeatureTableUrl();\n+\n+                boolean isNewFeatureTable = !arcgisPersistenceBackend.containsKey(featureTableUrl);\n+                LOGGER.debug(\"[\" + this.getName() + \"] persistAggregation - Feature table: \" + featureTableUrl\n+                        + \" is new: \" + isNewFeatureTable);\n+                ArcgisFeatureTable featureTable = getPersistenceBackend(featureTableUrl);\n+\n+                // If it's a new one, sets uniqueField value\n+                if (isNewFeatureTable) {\n+                    LOGGER.debug(\"[\" + this.getName() + \"] Created new backend for \" + featureTableUrl\n+                            + \" with uniqueField: \" + aggregation.getUniqueField());\n+                    featureTable.setUniqueField(aggregation.getUniqueField());\n+                }\n+\n+                featureTable.addToBatch(aggregation.getFeature());\n+            }\n+        } catch (CygnusRuntimeError e) {\n+            String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+            LOGGER.debug(\" PersistAggregation Error: \" + stackTrace);\n+            throw (e);\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getClass().getSimpleName() + \" - \"\n+                    + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistAggregation\n+\n+    /**\n+     * @author dmartinez\n+     *\n+     */\n+    public class NGSIArcgisAggregator {\n+\n+        private List<ArcgisAggregatorDomain> listArcgisAggregatorDomain = new ArrayList<ArcgisAggregatorDomain>();\n+        private boolean enableNameMappings = true;\n+        private String argisServiceUrl = \"\";\n+\n+        private NGSIArcgisAggregator() {\n+        } // ArcgisAggregator\n+\n+        /**\n+         * Constructor.\n+         * \n+         * @param argisServiceUrl\n+         * @param enableNameMappings\n+         */\n+        public NGSIArcgisAggregator(String argisServiceUrl, boolean enableNameMappings) {\n+            this();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyNDczMQ=="}, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 429}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTQwMzk5OnYy", "diffSide": "RIGHT", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMTowODo1NVrOGKjxOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMTowODo1NVrOGKjxOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyNDk4Ng==", "bodyText": "It this constructor used?", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r413724986", "createdAt": "2020-04-23T11:08:55Z", "author": {"login": "IvanHdzC"}, "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "diffHunk": "@@ -0,0 +1,789 @@\n+/**\n+ * Copyright 2014-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+\n+package com.telefonica.iot.cygnus.sinks;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.commons.lang.exception.ExceptionUtils;\n+import org.apache.flume.Context;\n+import org.apache.flume.EventDeliveryException;\n+import org.json.JSONException;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Point;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.ArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.NGSIArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextAttribute;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextElement;\n+import com.telefonica.iot.cygnus.errors.CygnusBadConfiguration;\n+import com.telefonica.iot.cygnus.errors.CygnusBadContextData;\n+import com.telefonica.iot.cygnus.errors.CygnusCappingError;\n+import com.telefonica.iot.cygnus.errors.CygnusExpiratingError;\n+import com.telefonica.iot.cygnus.errors.CygnusPersistenceError;\n+import com.telefonica.iot.cygnus.errors.CygnusRuntimeError;\n+import com.telefonica.iot.cygnus.interceptors.NGSIEvent;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+import com.telefonica.iot.cygnus.utils.NGSIConstants;\n+\n+import jodd.util.URLDecoder;\n+\n+/**\n+ *\n+ * @author dmartinez\n+ * \n+ *         Detailed documentation can be found at:\n+ *         https://github.com/telefonicaid/fiware-cygnus/blob/master/doc/flume_extensions_catalogue/ngsi_arcgis_sink.md\n+ */\n+public class NGSIArcgisFeatureTableSink extends NGSISink {\n+\n+    private static final String DEFAULT_ARCGIS_SERVICE_URL = \"localhost\";\n+    private static final String DEFAULT_GETTOKEN_URL = \"localhost\";\n+    private static final String DEFAULT_USER_NAME = \"root\";\n+    private static final String DEFAULT_PASSWORD = \"\";\n+    private static final int DEFAULT_MAX_BATCH_SIZE = 10;\n+    private static final int DEFAULT_BATCH_TIMEOUT_SECS = 60;\n+    private static final String ARCGIS_INSTANCE_NAME = \"arcgis\";\n+\n+    private static final CygnusLogger LOGGER = new CygnusLogger(NGSIArcgisFeatureTableSink.class);\n+    private String arcgisServicesUrl;\n+    private String getTokenUrl;\n+    private String userName;\n+    private String password;\n+    private int maxBatchSize;\n+    private long timeoutSecs;\n+    private static volatile Map<String, NGSIArcgisFeatureTable> arcgisPersistenceBackend;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public NGSIArcgisFeatureTableSink() {\n+        super();\n+    } // NGSIArcgisFeatureTableSink\n+\n+    /**\n+     * Gets the Argis services url. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The services url\n+     */\n+    protected String getrAcgisServicesUrl() {\n+        return arcgisServicesUrl;\n+    } // getrAcgisServicesUrl\n+\n+    /**\n+     * Gets getToken's service url.\n+     * \n+     * @return\n+     */\n+    public String getGetTokenUrl() {\n+        return getTokenUrl;\n+    }\n+\n+    /**\n+     * Sets getToken service url.\n+     * \n+     * @param getTokenUrl\n+     */\n+    public void setGetTokenUrl(String getTokenUrl) {\n+        this.getTokenUrl = getTokenUrl;\n+    }\n+\n+    /**\n+     * Gets the username. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The username\n+     */\n+    protected String getUsername() {\n+        return userName;\n+    } // getUsername\n+\n+    /**\n+     * Gets the password. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The password\n+     */\n+    protected String getPassword() {\n+        return password;\n+    } // getPassword\n+\n+    /**\n+     * \n+     */\n+    protected int featuresBatched() {\n+        int total = 0;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table != null) {\n+                total += table.featuresBatched();\n+            }\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Returns the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The persistence backend\n+     * @throws CygnusRuntimeError\n+     */\n+    protected ArcgisFeatureTable getPersistenceBackend(String featureServiceUrl) throws CygnusRuntimeError {\n+\n+        if (arcgisPersistenceBackend.containsKey(featureServiceUrl)) {\n+            return arcgisPersistenceBackend.get(featureServiceUrl);\n+        } else {\n+            LOGGER.debug(\"Creating new persistenceBackend for Feature table: \" + featureServiceUrl);\n+            LOGGER.debug(\"Token url: \" + getGetTokenUrl());\n+            LOGGER.debug(\"User name: \" + getUsername());\n+            LOGGER.debug(\"Passwd: \" + getPassword());\n+            try {\n+                NGSIArcgisFeatureTable newTable = new NGSIArcgisFeatureTable(featureServiceUrl, getUsername(),\n+                        getPassword(), getGetTokenUrl(), timeoutSecs, LOGGER);\n+                newTable.setBatchAction(ArcgisFeatureTable.ADD_UPDATE_ACTION);\n+                newTable.setBatchSize(maxBatchSize);\n+\n+                if (newTable.hasError()) {\n+                    throw new CygnusRuntimeError(\"[\" + this.getName() + \"Error creating Persistence backend: \"\n+                            + newTable.getErrorCode() + \" - \" + newTable.getErrorDesc());\n+                } else {\n+                    arcgisPersistenceBackend.put(featureServiceUrl, newTable);\n+                    return newTable;\n+                }\n+            } catch (Throwable e) {\n+                String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+                LOGGER.debug(stackTrace);\n+                throw new CygnusRuntimeError(\"Error creating new persistence Backend. \", e.getClass().getName(),\n+                        e.getMessage());\n+            }\n+        }\n+    } // getPersistenceBackend\n+\n+    /**\n+     * Sets the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @param persistenceBackend\n+     */\n+    protected void setPersistenceBackend(String featureServiceUrl, NGSIArcgisFeatureTable persistenceBackend) {\n+        arcgisPersistenceBackend.put(featureServiceUrl, persistenceBackend);\n+    } // setPersistenceBackend\n+\n+    @Override\n+    public void configure(Context context) {\n+        arcgisServicesUrl = context.getString(\"arcgis_service_url\", DEFAULT_ARCGIS_SERVICE_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_service_url=\" + arcgisServicesUrl + \")\");\n+\n+        getTokenUrl = context.getString(\"arcgis_gettoken_url\", DEFAULT_GETTOKEN_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_fearcgis_gettoken_urlature_table_url=\"\n+                + getTokenUrl + \")\");\n+\n+        userName = context.getString(\"arcgis_username\", DEFAULT_USER_NAME);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_username=\" + userName + \")\");\n+        // FIXME: Password should be read encrypted and decoded here\n+        password = context.getString(\"arcgis_password\", DEFAULT_PASSWORD);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_password=\" + password + \")\");\n+\n+        maxBatchSize = context.getInteger(\"arcgis_maxBatchSize\", DEFAULT_MAX_BATCH_SIZE);\n+        if (maxBatchSize <= 0 || maxBatchSize > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_maxBatchSize=\" + maxBatchSize + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_maxBatchSize=\" + maxBatchSize + \")\");\n+        }\n+\n+        timeoutSecs = context.getInteger(\"arcgis_timeoutSecs\", DEFAULT_BATCH_TIMEOUT_SECS);\n+        if (timeoutSecs <= 0 || timeoutSecs > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_timeoutSecs=\" + timeoutSecs + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_timeoutSecs=\" + maxBatchSize + \")\");\n+        }\n+\n+        super.configure(context);\n+    } // configure\n+\n+    @Override\n+    public void start() {\n+        try {\n+            createPersistenceBackend();\n+            LOGGER.debug(\"[\" + this.getName() + \"] Arcgis persistence backend created\");\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error while creating the Arcgis persistence backend. Details=\" + e.getMessage());\n+        } // try catch\n+\n+        super.start();\n+    } // start\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (arcgisPersistenceBackend != null) {\n+            for (Map.Entry<String, NGSIArcgisFeatureTable> backend : arcgisPersistenceBackend.entrySet()) {\n+                backend.getValue().flushBatch();\n+            }\n+            arcgisPersistenceBackend.clear();\n+        }\n+    } // stop\n+\n+    /**\n+     * Initialices a lazy singleton to share among instances on JVM.\n+     */\n+    private static synchronized void createPersistenceBackend() {\n+        if (arcgisPersistenceBackend == null) {\n+            arcgisPersistenceBackend = new ConcurrentHashMap<String, NGSIArcgisFeatureTable>();\n+        }\n+    }\n+\n+    @Override\n+    void persistBatch(NGSIBatch batch)\n+            throws CygnusBadConfiguration, CygnusPersistenceError, CygnusRuntimeError, CygnusBadContextData {\n+        if (batch == null) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Null batch, nothing to do\");\n+            return;\n+        } // if\n+\n+        try {\n+            // Iterate on the destinations\n+            batch.startIterator();\n+\n+            while (batch.hasNext()) {\n+                String destination = batch.getNextDestination();\n+                LOGGER.debug(\n+                        \"[\" + this.getName() + \"] Processing sub-batch regarding the \" + destination + \" destination\");\n+\n+                // Get the events within the current sub-batch\n+                ArrayList<NGSIEvent> events = batch.getNextEvents();\n+\n+                // Get an aggregator for this destination and initialize it\n+                NGSIArcgisAggregator aggregator = new NGSIArcgisAggregator(getrAcgisServicesUrl(), enableNameMappings);\n+                // aggregator.setService(events.get(0).getServiceForNaming(enableNameMappings));\n+                // aggregator.setServicePathForData(events.get(0).getServicePathForData());\n+                // aggregator.setServicePathForNaming(events.get(0).getServicePathForNaming(enableGrouping,\n+                // enableNameMappings));\n+                // aggregator.setEntityForNaming(events.get(0).getEntityForNaming(enableGrouping, enableNameMappings,\n+                // enableEncoding));\n+                // aggregator.setEntityType(events.get(0).getEntityTypeForNaming(enableGrouping, enableNameMappings));\n+                // aggregator.setAttribute(events.get(0).getAttributeForNaming(enableNameMappings));\n+                // aggregator.setDbName(buildDbName(aggregator.getService()));\n+                // aggregator.setTableName(buildTableName(aggregator.getServicePathForNaming(),\n+                // aggregator.getEntityForNaming(), aggregator.getEntityType(), aggregator.getAttribute()));\n+                // aggregator.setAttrNativeTypes(attrNativeTypes);\n+                // aggregator.setAttrMetadataStore(false);\n+                aggregator.initialize(events.get(0));\n+                for (NGSIEvent event : events) {\n+                    aggregator.aggregate(event);\n+                } // for\n+\n+                // Persist the aggregation\n+                persistAggregation(aggregator);\n+                batch.setNextPersisted(true);\n+\n+            } // while\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistBatch\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see com.telefonica.iot.cygnus.sinks.NGSISink#process()\n+     */\n+    @Override\n+    public Status process() throws EventDeliveryException {\n+        checkTimeouts();\n+        Status status = null;\n+        try {\n+            status = super.process();\n+        } catch (Throwable e) {\n+            LOGGER.error(e.getMessage() + \"Stack trace: \" + Arrays.toString(e.getStackTrace()));\n+        }\n+        return status;\n+    }\n+\n+    /**\n+     * Flush if timeout.\n+     */\n+    protected void checkTimeouts() {\n+        boolean timeoutFound = false;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table.hasTimeout()) {\n+                timeoutFound = true;\n+                LOGGER.info(\"[\" + this.getName() + \"] Feature table Timeout, flushing batch. \" + entry.getKey());\n+                table.flushBatch();\n+            }\n+        }\n+        if (!timeoutFound) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] No Feature table Timeouts found. Features in batch: \"\n+                    + featuresBatched());\n+        }\n+    }\n+\n+    @Override\n+    public void capRecords(NGSIBatch batch, long maxRecords) throws CygnusCappingError {\n+        // no capping\n+        LOGGER.warn(\"[\" + this.getName() + \"] Skipping capping records, just persisting it.\");\n+        try {\n+            persistBatch(batch);\n+        } catch (CygnusBadConfiguration | CygnusPersistenceError | CygnusRuntimeError | CygnusBadContextData e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error capping Records: \" + e);\n+            throw new CygnusCappingError(e.getMessage());\n+        }\n+    } // capRecords\n+\n+    @Override\n+    public void expirateRecords(long expirationTime) throws CygnusExpiratingError {\n+        LOGGER.debug(\"[\" + this.getName() + \"] Expirating records (time=\" + expirationTime + \")\");\n+\n+    } // expirateRecords\n+\n+    /**\n+     * Persist Aggregation.\n+     * \n+     * @param aggregator\n+     * @throws CygnusRuntimeError\n+     */\n+    public void persistAggregation(NGSIArcgisAggregator aggregator) throws CygnusRuntimeError {\n+        try {\n+            List<ArcgisAggregatorDomain> aggregationList = aggregator.getListArcgisAggregatorDomain();\n+            LOGGER.debug(\"[\" + this.getName() + \"] persisting aggregation, \"\n+                    + aggregator.getListArcgisAggregatorDomain().size() + \" features.\");\n+            for (ArcgisAggregatorDomain aggregation : aggregationList) {\n+                String featureTableUrl = aggregation.getFeatureTableUrl();\n+\n+                boolean isNewFeatureTable = !arcgisPersistenceBackend.containsKey(featureTableUrl);\n+                LOGGER.debug(\"[\" + this.getName() + \"] persistAggregation - Feature table: \" + featureTableUrl\n+                        + \" is new: \" + isNewFeatureTable);\n+                ArcgisFeatureTable featureTable = getPersistenceBackend(featureTableUrl);\n+\n+                // If it's a new one, sets uniqueField value\n+                if (isNewFeatureTable) {\n+                    LOGGER.debug(\"[\" + this.getName() + \"] Created new backend for \" + featureTableUrl\n+                            + \" with uniqueField: \" + aggregation.getUniqueField());\n+                    featureTable.setUniqueField(aggregation.getUniqueField());\n+                }\n+\n+                featureTable.addToBatch(aggregation.getFeature());\n+            }\n+        } catch (CygnusRuntimeError e) {\n+            String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+            LOGGER.debug(\" PersistAggregation Error: \" + stackTrace);\n+            throw (e);\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getClass().getSimpleName() + \" - \"\n+                    + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistAggregation\n+\n+    /**\n+     * @author dmartinez\n+     *\n+     */\n+    public class NGSIArcgisAggregator {\n+\n+        private List<ArcgisAggregatorDomain> listArcgisAggregatorDomain = new ArrayList<ArcgisAggregatorDomain>();\n+        private boolean enableNameMappings = true;\n+        private String argisServiceUrl = \"\";\n+\n+        private NGSIArcgisAggregator() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 419}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTQwNjYxOnYy", "diffSide": "RIGHT", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMTowOTo0MFrOGKjy0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxMTozMTo0MlrOGNPkAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyNTM5Mw==", "bodyText": "This function seems to be empty, is it used?", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r413725393", "createdAt": "2020-04-23T11:09:40Z", "author": {"login": "IvanHdzC"}, "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "diffHunk": "@@ -0,0 +1,789 @@\n+/**\n+ * Copyright 2014-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+\n+package com.telefonica.iot.cygnus.sinks;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.commons.lang.exception.ExceptionUtils;\n+import org.apache.flume.Context;\n+import org.apache.flume.EventDeliveryException;\n+import org.json.JSONException;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Point;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.ArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.NGSIArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextAttribute;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextElement;\n+import com.telefonica.iot.cygnus.errors.CygnusBadConfiguration;\n+import com.telefonica.iot.cygnus.errors.CygnusBadContextData;\n+import com.telefonica.iot.cygnus.errors.CygnusCappingError;\n+import com.telefonica.iot.cygnus.errors.CygnusExpiratingError;\n+import com.telefonica.iot.cygnus.errors.CygnusPersistenceError;\n+import com.telefonica.iot.cygnus.errors.CygnusRuntimeError;\n+import com.telefonica.iot.cygnus.interceptors.NGSIEvent;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+import com.telefonica.iot.cygnus.utils.NGSIConstants;\n+\n+import jodd.util.URLDecoder;\n+\n+/**\n+ *\n+ * @author dmartinez\n+ * \n+ *         Detailed documentation can be found at:\n+ *         https://github.com/telefonicaid/fiware-cygnus/blob/master/doc/flume_extensions_catalogue/ngsi_arcgis_sink.md\n+ */\n+public class NGSIArcgisFeatureTableSink extends NGSISink {\n+\n+    private static final String DEFAULT_ARCGIS_SERVICE_URL = \"localhost\";\n+    private static final String DEFAULT_GETTOKEN_URL = \"localhost\";\n+    private static final String DEFAULT_USER_NAME = \"root\";\n+    private static final String DEFAULT_PASSWORD = \"\";\n+    private static final int DEFAULT_MAX_BATCH_SIZE = 10;\n+    private static final int DEFAULT_BATCH_TIMEOUT_SECS = 60;\n+    private static final String ARCGIS_INSTANCE_NAME = \"arcgis\";\n+\n+    private static final CygnusLogger LOGGER = new CygnusLogger(NGSIArcgisFeatureTableSink.class);\n+    private String arcgisServicesUrl;\n+    private String getTokenUrl;\n+    private String userName;\n+    private String password;\n+    private int maxBatchSize;\n+    private long timeoutSecs;\n+    private static volatile Map<String, NGSIArcgisFeatureTable> arcgisPersistenceBackend;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public NGSIArcgisFeatureTableSink() {\n+        super();\n+    } // NGSIArcgisFeatureTableSink\n+\n+    /**\n+     * Gets the Argis services url. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The services url\n+     */\n+    protected String getrAcgisServicesUrl() {\n+        return arcgisServicesUrl;\n+    } // getrAcgisServicesUrl\n+\n+    /**\n+     * Gets getToken's service url.\n+     * \n+     * @return\n+     */\n+    public String getGetTokenUrl() {\n+        return getTokenUrl;\n+    }\n+\n+    /**\n+     * Sets getToken service url.\n+     * \n+     * @param getTokenUrl\n+     */\n+    public void setGetTokenUrl(String getTokenUrl) {\n+        this.getTokenUrl = getTokenUrl;\n+    }\n+\n+    /**\n+     * Gets the username. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The username\n+     */\n+    protected String getUsername() {\n+        return userName;\n+    } // getUsername\n+\n+    /**\n+     * Gets the password. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The password\n+     */\n+    protected String getPassword() {\n+        return password;\n+    } // getPassword\n+\n+    /**\n+     * \n+     */\n+    protected int featuresBatched() {\n+        int total = 0;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table != null) {\n+                total += table.featuresBatched();\n+            }\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Returns the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The persistence backend\n+     * @throws CygnusRuntimeError\n+     */\n+    protected ArcgisFeatureTable getPersistenceBackend(String featureServiceUrl) throws CygnusRuntimeError {\n+\n+        if (arcgisPersistenceBackend.containsKey(featureServiceUrl)) {\n+            return arcgisPersistenceBackend.get(featureServiceUrl);\n+        } else {\n+            LOGGER.debug(\"Creating new persistenceBackend for Feature table: \" + featureServiceUrl);\n+            LOGGER.debug(\"Token url: \" + getGetTokenUrl());\n+            LOGGER.debug(\"User name: \" + getUsername());\n+            LOGGER.debug(\"Passwd: \" + getPassword());\n+            try {\n+                NGSIArcgisFeatureTable newTable = new NGSIArcgisFeatureTable(featureServiceUrl, getUsername(),\n+                        getPassword(), getGetTokenUrl(), timeoutSecs, LOGGER);\n+                newTable.setBatchAction(ArcgisFeatureTable.ADD_UPDATE_ACTION);\n+                newTable.setBatchSize(maxBatchSize);\n+\n+                if (newTable.hasError()) {\n+                    throw new CygnusRuntimeError(\"[\" + this.getName() + \"Error creating Persistence backend: \"\n+                            + newTable.getErrorCode() + \" - \" + newTable.getErrorDesc());\n+                } else {\n+                    arcgisPersistenceBackend.put(featureServiceUrl, newTable);\n+                    return newTable;\n+                }\n+            } catch (Throwable e) {\n+                String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+                LOGGER.debug(stackTrace);\n+                throw new CygnusRuntimeError(\"Error creating new persistence Backend. \", e.getClass().getName(),\n+                        e.getMessage());\n+            }\n+        }\n+    } // getPersistenceBackend\n+\n+    /**\n+     * Sets the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @param persistenceBackend\n+     */\n+    protected void setPersistenceBackend(String featureServiceUrl, NGSIArcgisFeatureTable persistenceBackend) {\n+        arcgisPersistenceBackend.put(featureServiceUrl, persistenceBackend);\n+    } // setPersistenceBackend\n+\n+    @Override\n+    public void configure(Context context) {\n+        arcgisServicesUrl = context.getString(\"arcgis_service_url\", DEFAULT_ARCGIS_SERVICE_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_service_url=\" + arcgisServicesUrl + \")\");\n+\n+        getTokenUrl = context.getString(\"arcgis_gettoken_url\", DEFAULT_GETTOKEN_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_fearcgis_gettoken_urlature_table_url=\"\n+                + getTokenUrl + \")\");\n+\n+        userName = context.getString(\"arcgis_username\", DEFAULT_USER_NAME);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_username=\" + userName + \")\");\n+        // FIXME: Password should be read encrypted and decoded here\n+        password = context.getString(\"arcgis_password\", DEFAULT_PASSWORD);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_password=\" + password + \")\");\n+\n+        maxBatchSize = context.getInteger(\"arcgis_maxBatchSize\", DEFAULT_MAX_BATCH_SIZE);\n+        if (maxBatchSize <= 0 || maxBatchSize > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_maxBatchSize=\" + maxBatchSize + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_maxBatchSize=\" + maxBatchSize + \")\");\n+        }\n+\n+        timeoutSecs = context.getInteger(\"arcgis_timeoutSecs\", DEFAULT_BATCH_TIMEOUT_SECS);\n+        if (timeoutSecs <= 0 || timeoutSecs > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_timeoutSecs=\" + timeoutSecs + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_timeoutSecs=\" + maxBatchSize + \")\");\n+        }\n+\n+        super.configure(context);\n+    } // configure\n+\n+    @Override\n+    public void start() {\n+        try {\n+            createPersistenceBackend();\n+            LOGGER.debug(\"[\" + this.getName() + \"] Arcgis persistence backend created\");\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error while creating the Arcgis persistence backend. Details=\" + e.getMessage());\n+        } // try catch\n+\n+        super.start();\n+    } // start\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (arcgisPersistenceBackend != null) {\n+            for (Map.Entry<String, NGSIArcgisFeatureTable> backend : arcgisPersistenceBackend.entrySet()) {\n+                backend.getValue().flushBatch();\n+            }\n+            arcgisPersistenceBackend.clear();\n+        }\n+    } // stop\n+\n+    /**\n+     * Initialices a lazy singleton to share among instances on JVM.\n+     */\n+    private static synchronized void createPersistenceBackend() {\n+        if (arcgisPersistenceBackend == null) {\n+            arcgisPersistenceBackend = new ConcurrentHashMap<String, NGSIArcgisFeatureTable>();\n+        }\n+    }\n+\n+    @Override\n+    void persistBatch(NGSIBatch batch)\n+            throws CygnusBadConfiguration, CygnusPersistenceError, CygnusRuntimeError, CygnusBadContextData {\n+        if (batch == null) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Null batch, nothing to do\");\n+            return;\n+        } // if\n+\n+        try {\n+            // Iterate on the destinations\n+            batch.startIterator();\n+\n+            while (batch.hasNext()) {\n+                String destination = batch.getNextDestination();\n+                LOGGER.debug(\n+                        \"[\" + this.getName() + \"] Processing sub-batch regarding the \" + destination + \" destination\");\n+\n+                // Get the events within the current sub-batch\n+                ArrayList<NGSIEvent> events = batch.getNextEvents();\n+\n+                // Get an aggregator for this destination and initialize it\n+                NGSIArcgisAggregator aggregator = new NGSIArcgisAggregator(getrAcgisServicesUrl(), enableNameMappings);\n+                // aggregator.setService(events.get(0).getServiceForNaming(enableNameMappings));\n+                // aggregator.setServicePathForData(events.get(0).getServicePathForData());\n+                // aggregator.setServicePathForNaming(events.get(0).getServicePathForNaming(enableGrouping,\n+                // enableNameMappings));\n+                // aggregator.setEntityForNaming(events.get(0).getEntityForNaming(enableGrouping, enableNameMappings,\n+                // enableEncoding));\n+                // aggregator.setEntityType(events.get(0).getEntityTypeForNaming(enableGrouping, enableNameMappings));\n+                // aggregator.setAttribute(events.get(0).getAttributeForNaming(enableNameMappings));\n+                // aggregator.setDbName(buildDbName(aggregator.getService()));\n+                // aggregator.setTableName(buildTableName(aggregator.getServicePathForNaming(),\n+                // aggregator.getEntityForNaming(), aggregator.getEntityType(), aggregator.getAttribute()));\n+                // aggregator.setAttrNativeTypes(attrNativeTypes);\n+                // aggregator.setAttrMetadataStore(false);\n+                aggregator.initialize(events.get(0));\n+                for (NGSIEvent event : events) {\n+                    aggregator.aggregate(event);\n+                } // for\n+\n+                // Persist the aggregation\n+                persistAggregation(aggregator);\n+                batch.setNextPersisted(true);\n+\n+            } // while\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistBatch\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see com.telefonica.iot.cygnus.sinks.NGSISink#process()\n+     */\n+    @Override\n+    public Status process() throws EventDeliveryException {\n+        checkTimeouts();\n+        Status status = null;\n+        try {\n+            status = super.process();\n+        } catch (Throwable e) {\n+            LOGGER.error(e.getMessage() + \"Stack trace: \" + Arrays.toString(e.getStackTrace()));\n+        }\n+        return status;\n+    }\n+\n+    /**\n+     * Flush if timeout.\n+     */\n+    protected void checkTimeouts() {\n+        boolean timeoutFound = false;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table.hasTimeout()) {\n+                timeoutFound = true;\n+                LOGGER.info(\"[\" + this.getName() + \"] Feature table Timeout, flushing batch. \" + entry.getKey());\n+                table.flushBatch();\n+            }\n+        }\n+        if (!timeoutFound) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] No Feature table Timeouts found. Features in batch: \"\n+                    + featuresBatched());\n+        }\n+    }\n+\n+    @Override\n+    public void capRecords(NGSIBatch batch, long maxRecords) throws CygnusCappingError {\n+        // no capping\n+        LOGGER.warn(\"[\" + this.getName() + \"] Skipping capping records, just persisting it.\");\n+        try {\n+            persistBatch(batch);\n+        } catch (CygnusBadConfiguration | CygnusPersistenceError | CygnusRuntimeError | CygnusBadContextData e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error capping Records: \" + e);\n+            throw new CygnusCappingError(e.getMessage());\n+        }\n+    } // capRecords\n+\n+    @Override\n+    public void expirateRecords(long expirationTime) throws CygnusExpiratingError {\n+        LOGGER.debug(\"[\" + this.getName() + \"] Expirating records (time=\" + expirationTime + \")\");\n+\n+    } // expirateRecords\n+\n+    /**\n+     * Persist Aggregation.\n+     * \n+     * @param aggregator\n+     * @throws CygnusRuntimeError\n+     */\n+    public void persistAggregation(NGSIArcgisAggregator aggregator) throws CygnusRuntimeError {\n+        try {\n+            List<ArcgisAggregatorDomain> aggregationList = aggregator.getListArcgisAggregatorDomain();\n+            LOGGER.debug(\"[\" + this.getName() + \"] persisting aggregation, \"\n+                    + aggregator.getListArcgisAggregatorDomain().size() + \" features.\");\n+            for (ArcgisAggregatorDomain aggregation : aggregationList) {\n+                String featureTableUrl = aggregation.getFeatureTableUrl();\n+\n+                boolean isNewFeatureTable = !arcgisPersistenceBackend.containsKey(featureTableUrl);\n+                LOGGER.debug(\"[\" + this.getName() + \"] persistAggregation - Feature table: \" + featureTableUrl\n+                        + \" is new: \" + isNewFeatureTable);\n+                ArcgisFeatureTable featureTable = getPersistenceBackend(featureTableUrl);\n+\n+                // If it's a new one, sets uniqueField value\n+                if (isNewFeatureTable) {\n+                    LOGGER.debug(\"[\" + this.getName() + \"] Created new backend for \" + featureTableUrl\n+                            + \" with uniqueField: \" + aggregation.getUniqueField());\n+                    featureTable.setUniqueField(aggregation.getUniqueField());\n+                }\n+\n+                featureTable.addToBatch(aggregation.getFeature());\n+            }\n+        } catch (CygnusRuntimeError e) {\n+            String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+            LOGGER.debug(\" PersistAggregation Error: \" + stackTrace);\n+            throw (e);\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getClass().getSimpleName() + \" - \"\n+                    + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistAggregation\n+\n+    /**\n+     * @author dmartinez\n+     *\n+     */\n+    public class NGSIArcgisAggregator {\n+\n+        private List<ArcgisAggregatorDomain> listArcgisAggregatorDomain = new ArrayList<ArcgisAggregatorDomain>();\n+        private boolean enableNameMappings = true;\n+        private String argisServiceUrl = \"\";\n+\n+        private NGSIArcgisAggregator() {\n+        } // ArcgisAggregator\n+\n+        /**\n+         * Constructor.\n+         * \n+         * @param argisServiceUrl\n+         * @param enableNameMappings\n+         */\n+        public NGSIArcgisAggregator(String argisServiceUrl, boolean enableNameMappings) {\n+            this();\n+            this.enableNameMappings = enableNameMappings;\n+            this.argisServiceUrl = argisServiceUrl;\n+        } // ArcgisAggregator\n+\n+        /**\n+         * \n+         * @param event\n+         */\n+        public void initialize(NGSIEvent event) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 438}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUzOTY1MA==", "bodyText": "Removed\nStdri@1941e81", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r416539650", "createdAt": "2020-04-28T11:31:42Z", "author": {"login": "pmo-sdr"}, "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "diffHunk": "@@ -0,0 +1,789 @@\n+/**\n+ * Copyright 2014-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+\n+package com.telefonica.iot.cygnus.sinks;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.commons.lang.exception.ExceptionUtils;\n+import org.apache.flume.Context;\n+import org.apache.flume.EventDeliveryException;\n+import org.json.JSONException;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Point;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.ArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.NGSIArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextAttribute;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextElement;\n+import com.telefonica.iot.cygnus.errors.CygnusBadConfiguration;\n+import com.telefonica.iot.cygnus.errors.CygnusBadContextData;\n+import com.telefonica.iot.cygnus.errors.CygnusCappingError;\n+import com.telefonica.iot.cygnus.errors.CygnusExpiratingError;\n+import com.telefonica.iot.cygnus.errors.CygnusPersistenceError;\n+import com.telefonica.iot.cygnus.errors.CygnusRuntimeError;\n+import com.telefonica.iot.cygnus.interceptors.NGSIEvent;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+import com.telefonica.iot.cygnus.utils.NGSIConstants;\n+\n+import jodd.util.URLDecoder;\n+\n+/**\n+ *\n+ * @author dmartinez\n+ * \n+ *         Detailed documentation can be found at:\n+ *         https://github.com/telefonicaid/fiware-cygnus/blob/master/doc/flume_extensions_catalogue/ngsi_arcgis_sink.md\n+ */\n+public class NGSIArcgisFeatureTableSink extends NGSISink {\n+\n+    private static final String DEFAULT_ARCGIS_SERVICE_URL = \"localhost\";\n+    private static final String DEFAULT_GETTOKEN_URL = \"localhost\";\n+    private static final String DEFAULT_USER_NAME = \"root\";\n+    private static final String DEFAULT_PASSWORD = \"\";\n+    private static final int DEFAULT_MAX_BATCH_SIZE = 10;\n+    private static final int DEFAULT_BATCH_TIMEOUT_SECS = 60;\n+    private static final String ARCGIS_INSTANCE_NAME = \"arcgis\";\n+\n+    private static final CygnusLogger LOGGER = new CygnusLogger(NGSIArcgisFeatureTableSink.class);\n+    private String arcgisServicesUrl;\n+    private String getTokenUrl;\n+    private String userName;\n+    private String password;\n+    private int maxBatchSize;\n+    private long timeoutSecs;\n+    private static volatile Map<String, NGSIArcgisFeatureTable> arcgisPersistenceBackend;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public NGSIArcgisFeatureTableSink() {\n+        super();\n+    } // NGSIArcgisFeatureTableSink\n+\n+    /**\n+     * Gets the Argis services url. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The services url\n+     */\n+    protected String getrAcgisServicesUrl() {\n+        return arcgisServicesUrl;\n+    } // getrAcgisServicesUrl\n+\n+    /**\n+     * Gets getToken's service url.\n+     * \n+     * @return\n+     */\n+    public String getGetTokenUrl() {\n+        return getTokenUrl;\n+    }\n+\n+    /**\n+     * Sets getToken service url.\n+     * \n+     * @param getTokenUrl\n+     */\n+    public void setGetTokenUrl(String getTokenUrl) {\n+        this.getTokenUrl = getTokenUrl;\n+    }\n+\n+    /**\n+     * Gets the username. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The username\n+     */\n+    protected String getUsername() {\n+        return userName;\n+    } // getUsername\n+\n+    /**\n+     * Gets the password. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The password\n+     */\n+    protected String getPassword() {\n+        return password;\n+    } // getPassword\n+\n+    /**\n+     * \n+     */\n+    protected int featuresBatched() {\n+        int total = 0;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table != null) {\n+                total += table.featuresBatched();\n+            }\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Returns the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The persistence backend\n+     * @throws CygnusRuntimeError\n+     */\n+    protected ArcgisFeatureTable getPersistenceBackend(String featureServiceUrl) throws CygnusRuntimeError {\n+\n+        if (arcgisPersistenceBackend.containsKey(featureServiceUrl)) {\n+            return arcgisPersistenceBackend.get(featureServiceUrl);\n+        } else {\n+            LOGGER.debug(\"Creating new persistenceBackend for Feature table: \" + featureServiceUrl);\n+            LOGGER.debug(\"Token url: \" + getGetTokenUrl());\n+            LOGGER.debug(\"User name: \" + getUsername());\n+            LOGGER.debug(\"Passwd: \" + getPassword());\n+            try {\n+                NGSIArcgisFeatureTable newTable = new NGSIArcgisFeatureTable(featureServiceUrl, getUsername(),\n+                        getPassword(), getGetTokenUrl(), timeoutSecs, LOGGER);\n+                newTable.setBatchAction(ArcgisFeatureTable.ADD_UPDATE_ACTION);\n+                newTable.setBatchSize(maxBatchSize);\n+\n+                if (newTable.hasError()) {\n+                    throw new CygnusRuntimeError(\"[\" + this.getName() + \"Error creating Persistence backend: \"\n+                            + newTable.getErrorCode() + \" - \" + newTable.getErrorDesc());\n+                } else {\n+                    arcgisPersistenceBackend.put(featureServiceUrl, newTable);\n+                    return newTable;\n+                }\n+            } catch (Throwable e) {\n+                String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+                LOGGER.debug(stackTrace);\n+                throw new CygnusRuntimeError(\"Error creating new persistence Backend. \", e.getClass().getName(),\n+                        e.getMessage());\n+            }\n+        }\n+    } // getPersistenceBackend\n+\n+    /**\n+     * Sets the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @param persistenceBackend\n+     */\n+    protected void setPersistenceBackend(String featureServiceUrl, NGSIArcgisFeatureTable persistenceBackend) {\n+        arcgisPersistenceBackend.put(featureServiceUrl, persistenceBackend);\n+    } // setPersistenceBackend\n+\n+    @Override\n+    public void configure(Context context) {\n+        arcgisServicesUrl = context.getString(\"arcgis_service_url\", DEFAULT_ARCGIS_SERVICE_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_service_url=\" + arcgisServicesUrl + \")\");\n+\n+        getTokenUrl = context.getString(\"arcgis_gettoken_url\", DEFAULT_GETTOKEN_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_fearcgis_gettoken_urlature_table_url=\"\n+                + getTokenUrl + \")\");\n+\n+        userName = context.getString(\"arcgis_username\", DEFAULT_USER_NAME);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_username=\" + userName + \")\");\n+        // FIXME: Password should be read encrypted and decoded here\n+        password = context.getString(\"arcgis_password\", DEFAULT_PASSWORD);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_password=\" + password + \")\");\n+\n+        maxBatchSize = context.getInteger(\"arcgis_maxBatchSize\", DEFAULT_MAX_BATCH_SIZE);\n+        if (maxBatchSize <= 0 || maxBatchSize > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_maxBatchSize=\" + maxBatchSize + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_maxBatchSize=\" + maxBatchSize + \")\");\n+        }\n+\n+        timeoutSecs = context.getInteger(\"arcgis_timeoutSecs\", DEFAULT_BATCH_TIMEOUT_SECS);\n+        if (timeoutSecs <= 0 || timeoutSecs > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_timeoutSecs=\" + timeoutSecs + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_timeoutSecs=\" + maxBatchSize + \")\");\n+        }\n+\n+        super.configure(context);\n+    } // configure\n+\n+    @Override\n+    public void start() {\n+        try {\n+            createPersistenceBackend();\n+            LOGGER.debug(\"[\" + this.getName() + \"] Arcgis persistence backend created\");\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error while creating the Arcgis persistence backend. Details=\" + e.getMessage());\n+        } // try catch\n+\n+        super.start();\n+    } // start\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (arcgisPersistenceBackend != null) {\n+            for (Map.Entry<String, NGSIArcgisFeatureTable> backend : arcgisPersistenceBackend.entrySet()) {\n+                backend.getValue().flushBatch();\n+            }\n+            arcgisPersistenceBackend.clear();\n+        }\n+    } // stop\n+\n+    /**\n+     * Initialices a lazy singleton to share among instances on JVM.\n+     */\n+    private static synchronized void createPersistenceBackend() {\n+        if (arcgisPersistenceBackend == null) {\n+            arcgisPersistenceBackend = new ConcurrentHashMap<String, NGSIArcgisFeatureTable>();\n+        }\n+    }\n+\n+    @Override\n+    void persistBatch(NGSIBatch batch)\n+            throws CygnusBadConfiguration, CygnusPersistenceError, CygnusRuntimeError, CygnusBadContextData {\n+        if (batch == null) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Null batch, nothing to do\");\n+            return;\n+        } // if\n+\n+        try {\n+            // Iterate on the destinations\n+            batch.startIterator();\n+\n+            while (batch.hasNext()) {\n+                String destination = batch.getNextDestination();\n+                LOGGER.debug(\n+                        \"[\" + this.getName() + \"] Processing sub-batch regarding the \" + destination + \" destination\");\n+\n+                // Get the events within the current sub-batch\n+                ArrayList<NGSIEvent> events = batch.getNextEvents();\n+\n+                // Get an aggregator for this destination and initialize it\n+                NGSIArcgisAggregator aggregator = new NGSIArcgisAggregator(getrAcgisServicesUrl(), enableNameMappings);\n+                // aggregator.setService(events.get(0).getServiceForNaming(enableNameMappings));\n+                // aggregator.setServicePathForData(events.get(0).getServicePathForData());\n+                // aggregator.setServicePathForNaming(events.get(0).getServicePathForNaming(enableGrouping,\n+                // enableNameMappings));\n+                // aggregator.setEntityForNaming(events.get(0).getEntityForNaming(enableGrouping, enableNameMappings,\n+                // enableEncoding));\n+                // aggregator.setEntityType(events.get(0).getEntityTypeForNaming(enableGrouping, enableNameMappings));\n+                // aggregator.setAttribute(events.get(0).getAttributeForNaming(enableNameMappings));\n+                // aggregator.setDbName(buildDbName(aggregator.getService()));\n+                // aggregator.setTableName(buildTableName(aggregator.getServicePathForNaming(),\n+                // aggregator.getEntityForNaming(), aggregator.getEntityType(), aggregator.getAttribute()));\n+                // aggregator.setAttrNativeTypes(attrNativeTypes);\n+                // aggregator.setAttrMetadataStore(false);\n+                aggregator.initialize(events.get(0));\n+                for (NGSIEvent event : events) {\n+                    aggregator.aggregate(event);\n+                } // for\n+\n+                // Persist the aggregation\n+                persistAggregation(aggregator);\n+                batch.setNextPersisted(true);\n+\n+            } // while\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistBatch\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see com.telefonica.iot.cygnus.sinks.NGSISink#process()\n+     */\n+    @Override\n+    public Status process() throws EventDeliveryException {\n+        checkTimeouts();\n+        Status status = null;\n+        try {\n+            status = super.process();\n+        } catch (Throwable e) {\n+            LOGGER.error(e.getMessage() + \"Stack trace: \" + Arrays.toString(e.getStackTrace()));\n+        }\n+        return status;\n+    }\n+\n+    /**\n+     * Flush if timeout.\n+     */\n+    protected void checkTimeouts() {\n+        boolean timeoutFound = false;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table.hasTimeout()) {\n+                timeoutFound = true;\n+                LOGGER.info(\"[\" + this.getName() + \"] Feature table Timeout, flushing batch. \" + entry.getKey());\n+                table.flushBatch();\n+            }\n+        }\n+        if (!timeoutFound) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] No Feature table Timeouts found. Features in batch: \"\n+                    + featuresBatched());\n+        }\n+    }\n+\n+    @Override\n+    public void capRecords(NGSIBatch batch, long maxRecords) throws CygnusCappingError {\n+        // no capping\n+        LOGGER.warn(\"[\" + this.getName() + \"] Skipping capping records, just persisting it.\");\n+        try {\n+            persistBatch(batch);\n+        } catch (CygnusBadConfiguration | CygnusPersistenceError | CygnusRuntimeError | CygnusBadContextData e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error capping Records: \" + e);\n+            throw new CygnusCappingError(e.getMessage());\n+        }\n+    } // capRecords\n+\n+    @Override\n+    public void expirateRecords(long expirationTime) throws CygnusExpiratingError {\n+        LOGGER.debug(\"[\" + this.getName() + \"] Expirating records (time=\" + expirationTime + \")\");\n+\n+    } // expirateRecords\n+\n+    /**\n+     * Persist Aggregation.\n+     * \n+     * @param aggregator\n+     * @throws CygnusRuntimeError\n+     */\n+    public void persistAggregation(NGSIArcgisAggregator aggregator) throws CygnusRuntimeError {\n+        try {\n+            List<ArcgisAggregatorDomain> aggregationList = aggregator.getListArcgisAggregatorDomain();\n+            LOGGER.debug(\"[\" + this.getName() + \"] persisting aggregation, \"\n+                    + aggregator.getListArcgisAggregatorDomain().size() + \" features.\");\n+            for (ArcgisAggregatorDomain aggregation : aggregationList) {\n+                String featureTableUrl = aggregation.getFeatureTableUrl();\n+\n+                boolean isNewFeatureTable = !arcgisPersistenceBackend.containsKey(featureTableUrl);\n+                LOGGER.debug(\"[\" + this.getName() + \"] persistAggregation - Feature table: \" + featureTableUrl\n+                        + \" is new: \" + isNewFeatureTable);\n+                ArcgisFeatureTable featureTable = getPersistenceBackend(featureTableUrl);\n+\n+                // If it's a new one, sets uniqueField value\n+                if (isNewFeatureTable) {\n+                    LOGGER.debug(\"[\" + this.getName() + \"] Created new backend for \" + featureTableUrl\n+                            + \" with uniqueField: \" + aggregation.getUniqueField());\n+                    featureTable.setUniqueField(aggregation.getUniqueField());\n+                }\n+\n+                featureTable.addToBatch(aggregation.getFeature());\n+            }\n+        } catch (CygnusRuntimeError e) {\n+            String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+            LOGGER.debug(\" PersistAggregation Error: \" + stackTrace);\n+            throw (e);\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getClass().getSimpleName() + \" - \"\n+                    + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistAggregation\n+\n+    /**\n+     * @author dmartinez\n+     *\n+     */\n+    public class NGSIArcgisAggregator {\n+\n+        private List<ArcgisAggregatorDomain> listArcgisAggregatorDomain = new ArrayList<ArcgisAggregatorDomain>();\n+        private boolean enableNameMappings = true;\n+        private String argisServiceUrl = \"\";\n+\n+        private NGSIArcgisAggregator() {\n+        } // ArcgisAggregator\n+\n+        /**\n+         * Constructor.\n+         * \n+         * @param argisServiceUrl\n+         * @param enableNameMappings\n+         */\n+        public NGSIArcgisAggregator(String argisServiceUrl, boolean enableNameMappings) {\n+            this();\n+            this.enableNameMappings = enableNameMappings;\n+            this.argisServiceUrl = argisServiceUrl;\n+        } // ArcgisAggregator\n+\n+        /**\n+         * \n+         * @param event\n+         */\n+        public void initialize(NGSIEvent event) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyNTM5Mw=="}, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 438}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTQzNzYzOnYy", "diffSide": "RIGHT", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMToxODowN1rOGKkFtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxMTozNDoyNVrOGNPpjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczMDIyOA==", "bodyText": "That \"1\" String is so mysterious. It would be better to add it as a constant on the class", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r413730228", "createdAt": "2020-04-23T11:18:07Z", "author": {"login": "IvanHdzC"}, "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "diffHunk": "@@ -0,0 +1,789 @@\n+/**\n+ * Copyright 2014-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+\n+package com.telefonica.iot.cygnus.sinks;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.commons.lang.exception.ExceptionUtils;\n+import org.apache.flume.Context;\n+import org.apache.flume.EventDeliveryException;\n+import org.json.JSONException;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Point;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.ArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.NGSIArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextAttribute;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextElement;\n+import com.telefonica.iot.cygnus.errors.CygnusBadConfiguration;\n+import com.telefonica.iot.cygnus.errors.CygnusBadContextData;\n+import com.telefonica.iot.cygnus.errors.CygnusCappingError;\n+import com.telefonica.iot.cygnus.errors.CygnusExpiratingError;\n+import com.telefonica.iot.cygnus.errors.CygnusPersistenceError;\n+import com.telefonica.iot.cygnus.errors.CygnusRuntimeError;\n+import com.telefonica.iot.cygnus.interceptors.NGSIEvent;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+import com.telefonica.iot.cygnus.utils.NGSIConstants;\n+\n+import jodd.util.URLDecoder;\n+\n+/**\n+ *\n+ * @author dmartinez\n+ * \n+ *         Detailed documentation can be found at:\n+ *         https://github.com/telefonicaid/fiware-cygnus/blob/master/doc/flume_extensions_catalogue/ngsi_arcgis_sink.md\n+ */\n+public class NGSIArcgisFeatureTableSink extends NGSISink {\n+\n+    private static final String DEFAULT_ARCGIS_SERVICE_URL = \"localhost\";\n+    private static final String DEFAULT_GETTOKEN_URL = \"localhost\";\n+    private static final String DEFAULT_USER_NAME = \"root\";\n+    private static final String DEFAULT_PASSWORD = \"\";\n+    private static final int DEFAULT_MAX_BATCH_SIZE = 10;\n+    private static final int DEFAULT_BATCH_TIMEOUT_SECS = 60;\n+    private static final String ARCGIS_INSTANCE_NAME = \"arcgis\";\n+\n+    private static final CygnusLogger LOGGER = new CygnusLogger(NGSIArcgisFeatureTableSink.class);\n+    private String arcgisServicesUrl;\n+    private String getTokenUrl;\n+    private String userName;\n+    private String password;\n+    private int maxBatchSize;\n+    private long timeoutSecs;\n+    private static volatile Map<String, NGSIArcgisFeatureTable> arcgisPersistenceBackend;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public NGSIArcgisFeatureTableSink() {\n+        super();\n+    } // NGSIArcgisFeatureTableSink\n+\n+    /**\n+     * Gets the Argis services url. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The services url\n+     */\n+    protected String getrAcgisServicesUrl() {\n+        return arcgisServicesUrl;\n+    } // getrAcgisServicesUrl\n+\n+    /**\n+     * Gets getToken's service url.\n+     * \n+     * @return\n+     */\n+    public String getGetTokenUrl() {\n+        return getTokenUrl;\n+    }\n+\n+    /**\n+     * Sets getToken service url.\n+     * \n+     * @param getTokenUrl\n+     */\n+    public void setGetTokenUrl(String getTokenUrl) {\n+        this.getTokenUrl = getTokenUrl;\n+    }\n+\n+    /**\n+     * Gets the username. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The username\n+     */\n+    protected String getUsername() {\n+        return userName;\n+    } // getUsername\n+\n+    /**\n+     * Gets the password. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The password\n+     */\n+    protected String getPassword() {\n+        return password;\n+    } // getPassword\n+\n+    /**\n+     * \n+     */\n+    protected int featuresBatched() {\n+        int total = 0;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table != null) {\n+                total += table.featuresBatched();\n+            }\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Returns the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The persistence backend\n+     * @throws CygnusRuntimeError\n+     */\n+    protected ArcgisFeatureTable getPersistenceBackend(String featureServiceUrl) throws CygnusRuntimeError {\n+\n+        if (arcgisPersistenceBackend.containsKey(featureServiceUrl)) {\n+            return arcgisPersistenceBackend.get(featureServiceUrl);\n+        } else {\n+            LOGGER.debug(\"Creating new persistenceBackend for Feature table: \" + featureServiceUrl);\n+            LOGGER.debug(\"Token url: \" + getGetTokenUrl());\n+            LOGGER.debug(\"User name: \" + getUsername());\n+            LOGGER.debug(\"Passwd: \" + getPassword());\n+            try {\n+                NGSIArcgisFeatureTable newTable = new NGSIArcgisFeatureTable(featureServiceUrl, getUsername(),\n+                        getPassword(), getGetTokenUrl(), timeoutSecs, LOGGER);\n+                newTable.setBatchAction(ArcgisFeatureTable.ADD_UPDATE_ACTION);\n+                newTable.setBatchSize(maxBatchSize);\n+\n+                if (newTable.hasError()) {\n+                    throw new CygnusRuntimeError(\"[\" + this.getName() + \"Error creating Persistence backend: \"\n+                            + newTable.getErrorCode() + \" - \" + newTable.getErrorDesc());\n+                } else {\n+                    arcgisPersistenceBackend.put(featureServiceUrl, newTable);\n+                    return newTable;\n+                }\n+            } catch (Throwable e) {\n+                String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+                LOGGER.debug(stackTrace);\n+                throw new CygnusRuntimeError(\"Error creating new persistence Backend. \", e.getClass().getName(),\n+                        e.getMessage());\n+            }\n+        }\n+    } // getPersistenceBackend\n+\n+    /**\n+     * Sets the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @param persistenceBackend\n+     */\n+    protected void setPersistenceBackend(String featureServiceUrl, NGSIArcgisFeatureTable persistenceBackend) {\n+        arcgisPersistenceBackend.put(featureServiceUrl, persistenceBackend);\n+    } // setPersistenceBackend\n+\n+    @Override\n+    public void configure(Context context) {\n+        arcgisServicesUrl = context.getString(\"arcgis_service_url\", DEFAULT_ARCGIS_SERVICE_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_service_url=\" + arcgisServicesUrl + \")\");\n+\n+        getTokenUrl = context.getString(\"arcgis_gettoken_url\", DEFAULT_GETTOKEN_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_fearcgis_gettoken_urlature_table_url=\"\n+                + getTokenUrl + \")\");\n+\n+        userName = context.getString(\"arcgis_username\", DEFAULT_USER_NAME);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_username=\" + userName + \")\");\n+        // FIXME: Password should be read encrypted and decoded here\n+        password = context.getString(\"arcgis_password\", DEFAULT_PASSWORD);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_password=\" + password + \")\");\n+\n+        maxBatchSize = context.getInteger(\"arcgis_maxBatchSize\", DEFAULT_MAX_BATCH_SIZE);\n+        if (maxBatchSize <= 0 || maxBatchSize > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_maxBatchSize=\" + maxBatchSize + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_maxBatchSize=\" + maxBatchSize + \")\");\n+        }\n+\n+        timeoutSecs = context.getInteger(\"arcgis_timeoutSecs\", DEFAULT_BATCH_TIMEOUT_SECS);\n+        if (timeoutSecs <= 0 || timeoutSecs > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_timeoutSecs=\" + timeoutSecs + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_timeoutSecs=\" + maxBatchSize + \")\");\n+        }\n+\n+        super.configure(context);\n+    } // configure\n+\n+    @Override\n+    public void start() {\n+        try {\n+            createPersistenceBackend();\n+            LOGGER.debug(\"[\" + this.getName() + \"] Arcgis persistence backend created\");\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error while creating the Arcgis persistence backend. Details=\" + e.getMessage());\n+        } // try catch\n+\n+        super.start();\n+    } // start\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (arcgisPersistenceBackend != null) {\n+            for (Map.Entry<String, NGSIArcgisFeatureTable> backend : arcgisPersistenceBackend.entrySet()) {\n+                backend.getValue().flushBatch();\n+            }\n+            arcgisPersistenceBackend.clear();\n+        }\n+    } // stop\n+\n+    /**\n+     * Initialices a lazy singleton to share among instances on JVM.\n+     */\n+    private static synchronized void createPersistenceBackend() {\n+        if (arcgisPersistenceBackend == null) {\n+            arcgisPersistenceBackend = new ConcurrentHashMap<String, NGSIArcgisFeatureTable>();\n+        }\n+    }\n+\n+    @Override\n+    void persistBatch(NGSIBatch batch)\n+            throws CygnusBadConfiguration, CygnusPersistenceError, CygnusRuntimeError, CygnusBadContextData {\n+        if (batch == null) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Null batch, nothing to do\");\n+            return;\n+        } // if\n+\n+        try {\n+            // Iterate on the destinations\n+            batch.startIterator();\n+\n+            while (batch.hasNext()) {\n+                String destination = batch.getNextDestination();\n+                LOGGER.debug(\n+                        \"[\" + this.getName() + \"] Processing sub-batch regarding the \" + destination + \" destination\");\n+\n+                // Get the events within the current sub-batch\n+                ArrayList<NGSIEvent> events = batch.getNextEvents();\n+\n+                // Get an aggregator for this destination and initialize it\n+                NGSIArcgisAggregator aggregator = new NGSIArcgisAggregator(getrAcgisServicesUrl(), enableNameMappings);\n+                // aggregator.setService(events.get(0).getServiceForNaming(enableNameMappings));\n+                // aggregator.setServicePathForData(events.get(0).getServicePathForData());\n+                // aggregator.setServicePathForNaming(events.get(0).getServicePathForNaming(enableGrouping,\n+                // enableNameMappings));\n+                // aggregator.setEntityForNaming(events.get(0).getEntityForNaming(enableGrouping, enableNameMappings,\n+                // enableEncoding));\n+                // aggregator.setEntityType(events.get(0).getEntityTypeForNaming(enableGrouping, enableNameMappings));\n+                // aggregator.setAttribute(events.get(0).getAttributeForNaming(enableNameMappings));\n+                // aggregator.setDbName(buildDbName(aggregator.getService()));\n+                // aggregator.setTableName(buildTableName(aggregator.getServicePathForNaming(),\n+                // aggregator.getEntityForNaming(), aggregator.getEntityType(), aggregator.getAttribute()));\n+                // aggregator.setAttrNativeTypes(attrNativeTypes);\n+                // aggregator.setAttrMetadataStore(false);\n+                aggregator.initialize(events.get(0));\n+                for (NGSIEvent event : events) {\n+                    aggregator.aggregate(event);\n+                } // for\n+\n+                // Persist the aggregation\n+                persistAggregation(aggregator);\n+                batch.setNextPersisted(true);\n+\n+            } // while\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistBatch\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see com.telefonica.iot.cygnus.sinks.NGSISink#process()\n+     */\n+    @Override\n+    public Status process() throws EventDeliveryException {\n+        checkTimeouts();\n+        Status status = null;\n+        try {\n+            status = super.process();\n+        } catch (Throwable e) {\n+            LOGGER.error(e.getMessage() + \"Stack trace: \" + Arrays.toString(e.getStackTrace()));\n+        }\n+        return status;\n+    }\n+\n+    /**\n+     * Flush if timeout.\n+     */\n+    protected void checkTimeouts() {\n+        boolean timeoutFound = false;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table.hasTimeout()) {\n+                timeoutFound = true;\n+                LOGGER.info(\"[\" + this.getName() + \"] Feature table Timeout, flushing batch. \" + entry.getKey());\n+                table.flushBatch();\n+            }\n+        }\n+        if (!timeoutFound) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] No Feature table Timeouts found. Features in batch: \"\n+                    + featuresBatched());\n+        }\n+    }\n+\n+    @Override\n+    public void capRecords(NGSIBatch batch, long maxRecords) throws CygnusCappingError {\n+        // no capping\n+        LOGGER.warn(\"[\" + this.getName() + \"] Skipping capping records, just persisting it.\");\n+        try {\n+            persistBatch(batch);\n+        } catch (CygnusBadConfiguration | CygnusPersistenceError | CygnusRuntimeError | CygnusBadContextData e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error capping Records: \" + e);\n+            throw new CygnusCappingError(e.getMessage());\n+        }\n+    } // capRecords\n+\n+    @Override\n+    public void expirateRecords(long expirationTime) throws CygnusExpiratingError {\n+        LOGGER.debug(\"[\" + this.getName() + \"] Expirating records (time=\" + expirationTime + \")\");\n+\n+    } // expirateRecords\n+\n+    /**\n+     * Persist Aggregation.\n+     * \n+     * @param aggregator\n+     * @throws CygnusRuntimeError\n+     */\n+    public void persistAggregation(NGSIArcgisAggregator aggregator) throws CygnusRuntimeError {\n+        try {\n+            List<ArcgisAggregatorDomain> aggregationList = aggregator.getListArcgisAggregatorDomain();\n+            LOGGER.debug(\"[\" + this.getName() + \"] persisting aggregation, \"\n+                    + aggregator.getListArcgisAggregatorDomain().size() + \" features.\");\n+            for (ArcgisAggregatorDomain aggregation : aggregationList) {\n+                String featureTableUrl = aggregation.getFeatureTableUrl();\n+\n+                boolean isNewFeatureTable = !arcgisPersistenceBackend.containsKey(featureTableUrl);\n+                LOGGER.debug(\"[\" + this.getName() + \"] persistAggregation - Feature table: \" + featureTableUrl\n+                        + \" is new: \" + isNewFeatureTable);\n+                ArcgisFeatureTable featureTable = getPersistenceBackend(featureTableUrl);\n+\n+                // If it's a new one, sets uniqueField value\n+                if (isNewFeatureTable) {\n+                    LOGGER.debug(\"[\" + this.getName() + \"] Created new backend for \" + featureTableUrl\n+                            + \" with uniqueField: \" + aggregation.getUniqueField());\n+                    featureTable.setUniqueField(aggregation.getUniqueField());\n+                }\n+\n+                featureTable.addToBatch(aggregation.getFeature());\n+            }\n+        } catch (CygnusRuntimeError e) {\n+            String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+            LOGGER.debug(\" PersistAggregation Error: \" + stackTrace);\n+            throw (e);\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getClass().getSimpleName() + \" - \"\n+                    + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistAggregation\n+\n+    /**\n+     * @author dmartinez\n+     *\n+     */\n+    public class NGSIArcgisAggregator {\n+\n+        private List<ArcgisAggregatorDomain> listArcgisAggregatorDomain = new ArrayList<ArcgisAggregatorDomain>();\n+        private boolean enableNameMappings = true;\n+        private String argisServiceUrl = \"\";\n+\n+        private NGSIArcgisAggregator() {\n+        } // ArcgisAggregator\n+\n+        /**\n+         * Constructor.\n+         * \n+         * @param argisServiceUrl\n+         * @param enableNameMappings\n+         */\n+        public NGSIArcgisAggregator(String argisServiceUrl, boolean enableNameMappings) {\n+            this();\n+            this.enableNameMappings = enableNameMappings;\n+            this.argisServiceUrl = argisServiceUrl;\n+        } // ArcgisAggregator\n+\n+        /**\n+         * \n+         * @param event\n+         */\n+        public void initialize(NGSIEvent event) {\n+        } // initialize\n+\n+        /**\n+         * @return the listArcgisAggregatorDomain\n+         */\n+        public List<ArcgisAggregatorDomain> getListArcgisAggregatorDomain() {\n+            return listArcgisAggregatorDomain;\n+        }\n+\n+        /**\n+         * Determines if input sitring is quoted or not.\n+         * \n+         * @param string\n+         * @return boolean\n+         */\n+\n+        /**\n+         * \n+         * @param event\n+         * @throws CygnusRuntimeError\n+         */\n+        public void aggregate(NGSIEvent event) throws CygnusRuntimeError {\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - ContextElement ->\" + event.getContextElement());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate -  MappedCE ->\" + event.getMappedCE());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - OriginalCE ->\" + event.getOriginalCE());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - enableNameMappings status -> \" + enableNameMappings);\n+\n+            ContextElement contextElement = null;\n+            try {\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - creating new aggregation object.\");\n+                ArcgisAggregatorDomain aggregation = new ArcgisAggregatorDomain(LOGGER);\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - aggregation created\");\n+                Feature feature = aggregation.getFeature();\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Feature getted\");\n+                String service = \"\";\n+                String subService = \"\";\n+                String featureTableUrl = \"\";\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Selecting context\");\n+                // get the contextElement\n+                if (!enableNameMappings) {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - no mappings\");\n+                    contextElement = event.getContextElement();\n+                } else {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - mappings\");\n+                    contextElement = event.getMappedCE();\n+                }\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Selected context ->\" + contextElement);\n+\n+                // get the getRecvTimeTs headers\n+                Map<String, String> headers = event.getHeaders();\n+\n+                for (Entry<String, String> entry : headers.entrySet()) {\n+                    LOGGER.debug(\"Header entry key --> \" + entry.getKey().toString() + \", value --> \"\n+                            + entry.getValue().toString());\n+                    if (entry.getKey() != null\n+                            && NGSIConstants.FLUME_HEADER_MAPPED_SERVICE.equals(entry.getKey().toString())) {\n+                        service = entry.getValue().toString();\n+                    } else if (entry.getKey() != null\n+                            && NGSIConstants.FLUME_HEADER_MAPPED_SERVICE_PATH.equals(entry.getKey().toString())) {\n+                        subService = entry.getValue().toString();\n+                    }\n+                } // for\n+                \n+                // Compose full url\n+                featureTableUrl = argisServiceUrl + \"/\" + service + \"/\" + subService;\n+                featureTableUrl = featureTableUrl.replaceAll(\"([^:])\\\\/\\\\/\", \"$1/\");\n+                aggregation.setFeatureTableUrl(featureTableUrl);\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - featureTableUrl ->\" + featureTableUrl);\n+\n+                // iterate on all this context element attributes, if there are\n+                // attributes\n+                ArrayList<ContextAttribute> contextAttributes = contextElement.getAttributes();\n+\n+                String entityId = contextElement.getId();\n+                String entityType = contextElement.getType();\n+\n+                // Set unique filed and it's value.\n+                aggregation.setUniqueField(entityType);\n+                feature.addAttribute(entityType, entityId);\n+\n+                contextAttrToFeature(feature, contextAttributes);\n+\n+                aggregation.setFeature(feature);\n+                listArcgisAggregatorDomain.add(aggregation);\n+\n+            } catch (JSONException e) {\n+                LOGGER.error(\n+                        \"[NGSIArcgisAggregator] aggregate - Error pharsing JSON BODY \" + contextElement.toString());\n+                throw new CygnusRuntimeError(e.getMessage());\n+            } catch (Exception e) {\n+                LOGGER.error(\"[NGSIArcgisAggregator] aggregate - Unexpected Error\" + e.getMessage()\n+                        + \"\\n contextElement: \" + contextElement.toString());\n+                throw new CygnusRuntimeError(e.getMessage());\n+            }\n+\n+        } // aggregate\n+\n+        /**\n+         * \n+         * @param feature\n+         * @param contextAttributes\n+         */\n+        protected void contextAttrToFeature(Feature feature, ArrayList<ContextAttribute> contextAttributes) {\n+            if (contextAttributes == null || contextAttributes.isEmpty()) {\n+                LOGGER.debug(\n+                        \"[NGSIArcgisAggregator-contextAttrToFeature] contextAttributes NULL or empty, ignoring it. \");\n+            } else {\n+                for (ContextAttribute contextAttribute : contextAttributes) {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator-contextAttrToFeature] Processing Attribute: \"\n+                            + contextAttribute.toString());\n+                    String attrName = contextAttribute.getName();\n+                    String attrType = contextAttribute.getType();\n+                    // get attribute value as is, quoted or not\n+                    JsonElement attrValue = contextAttribute.getValue();\n+\n+                    // TODO crop metadata values\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Atribute (name --> \" + attrName + \", type --> \"\n+                            + attrType + \", value --> \" + attrValue + \", metadata= \" + \"ignored \" + \")\");\n+\n+                    // Get Feature attributes\n+                    LOGGER.debug(\"Proccessing attribute value:  \" + attrName + \" --> \" + attrValue);\n+\n+                    jsonElementToFeatureAttr(attrName, attrType, attrValue, feature);\n+\n+                } // for\n+            } // if else\n+        }\n+    } // NGSIArcgisAggregator\n+\n+    /**\n+     * Extracts Feature attributes from JSON.\n+     * \n+     * @param attrName\n+     * @param attrType\n+     * @param attrValue\n+     * @param feature\n+     */\n+    protected void jsonElementToFeatureAttr(String attrName, String attrType, JsonElement attrValue, Feature feature) {\n+\n+        // Get Feature attributes\n+        LOGGER.debug(\"Proccessing attribute value:  \" + attrName + \" --> \" + attrValue);\n+\n+        attrType = attrType.trim().toLowerCase();\n+\n+        switch (attrType) {\n+\n+            case \"geo:json\":\n+                try {\n+                    JsonObject location = attrValue.getAsJsonObject();\n+                    if (location.get(\"type\").getAsString().equals(\"Point\")) {\n+                        JsonArray coordinates = location.get(\"coordinates\").getAsJsonArray();\n+                        double latitude = coordinates.get(0).getAsDouble();\n+                        double longitude = coordinates.get(1).getAsDouble();\n+\n+                        Point point = new Point(latitude, longitude);\n+                        feature.setGeometry(point);\n+\n+                    } else {\n+                        LOGGER.warn(\"Invalid geo:json type, only points allowed: \" + location.toString());\n+                    }\n+                } catch (Exception e) {\n+                    LOGGER.error(\"Invalid geo:json format, (sikipped): \" + attrValue.toString() + \" - Error: \"\n+                            + e.getMessage());\n+                }\n+                break;\n+            case \"boolean\":\n+                if (attrValue.isJsonPrimitive() && attrValue.getAsJsonPrimitive().isBoolean()) {\n+                    feature.addAttribute(attrName, attrValue.getAsBoolean());\n+                } else {\n+                    String strValue = attrValue.getAsString().toLowerCase().trim();\n+                    boolean result = \"true\".equals(strValue) || \"1\".equals(strValue);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 612}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU0MTA3MA==", "bodyText": "Fixed\nhttps://github.com/Stdri/fiware-cygnus/blob/df4b24bbcced902efbd41a66da84356ed8ef6435/cygnus-ngsi/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java#L602", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r416541070", "createdAt": "2020-04-28T11:34:25Z", "author": {"login": "pmo-sdr"}, "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "diffHunk": "@@ -0,0 +1,789 @@\n+/**\n+ * Copyright 2014-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+\n+package com.telefonica.iot.cygnus.sinks;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.commons.lang.exception.ExceptionUtils;\n+import org.apache.flume.Context;\n+import org.apache.flume.EventDeliveryException;\n+import org.json.JSONException;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Point;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.ArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.NGSIArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextAttribute;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextElement;\n+import com.telefonica.iot.cygnus.errors.CygnusBadConfiguration;\n+import com.telefonica.iot.cygnus.errors.CygnusBadContextData;\n+import com.telefonica.iot.cygnus.errors.CygnusCappingError;\n+import com.telefonica.iot.cygnus.errors.CygnusExpiratingError;\n+import com.telefonica.iot.cygnus.errors.CygnusPersistenceError;\n+import com.telefonica.iot.cygnus.errors.CygnusRuntimeError;\n+import com.telefonica.iot.cygnus.interceptors.NGSIEvent;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+import com.telefonica.iot.cygnus.utils.NGSIConstants;\n+\n+import jodd.util.URLDecoder;\n+\n+/**\n+ *\n+ * @author dmartinez\n+ * \n+ *         Detailed documentation can be found at:\n+ *         https://github.com/telefonicaid/fiware-cygnus/blob/master/doc/flume_extensions_catalogue/ngsi_arcgis_sink.md\n+ */\n+public class NGSIArcgisFeatureTableSink extends NGSISink {\n+\n+    private static final String DEFAULT_ARCGIS_SERVICE_URL = \"localhost\";\n+    private static final String DEFAULT_GETTOKEN_URL = \"localhost\";\n+    private static final String DEFAULT_USER_NAME = \"root\";\n+    private static final String DEFAULT_PASSWORD = \"\";\n+    private static final int DEFAULT_MAX_BATCH_SIZE = 10;\n+    private static final int DEFAULT_BATCH_TIMEOUT_SECS = 60;\n+    private static final String ARCGIS_INSTANCE_NAME = \"arcgis\";\n+\n+    private static final CygnusLogger LOGGER = new CygnusLogger(NGSIArcgisFeatureTableSink.class);\n+    private String arcgisServicesUrl;\n+    private String getTokenUrl;\n+    private String userName;\n+    private String password;\n+    private int maxBatchSize;\n+    private long timeoutSecs;\n+    private static volatile Map<String, NGSIArcgisFeatureTable> arcgisPersistenceBackend;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public NGSIArcgisFeatureTableSink() {\n+        super();\n+    } // NGSIArcgisFeatureTableSink\n+\n+    /**\n+     * Gets the Argis services url. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The services url\n+     */\n+    protected String getrAcgisServicesUrl() {\n+        return arcgisServicesUrl;\n+    } // getrAcgisServicesUrl\n+\n+    /**\n+     * Gets getToken's service url.\n+     * \n+     * @return\n+     */\n+    public String getGetTokenUrl() {\n+        return getTokenUrl;\n+    }\n+\n+    /**\n+     * Sets getToken service url.\n+     * \n+     * @param getTokenUrl\n+     */\n+    public void setGetTokenUrl(String getTokenUrl) {\n+        this.getTokenUrl = getTokenUrl;\n+    }\n+\n+    /**\n+     * Gets the username. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The username\n+     */\n+    protected String getUsername() {\n+        return userName;\n+    } // getUsername\n+\n+    /**\n+     * Gets the password. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The password\n+     */\n+    protected String getPassword() {\n+        return password;\n+    } // getPassword\n+\n+    /**\n+     * \n+     */\n+    protected int featuresBatched() {\n+        int total = 0;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table != null) {\n+                total += table.featuresBatched();\n+            }\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Returns the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The persistence backend\n+     * @throws CygnusRuntimeError\n+     */\n+    protected ArcgisFeatureTable getPersistenceBackend(String featureServiceUrl) throws CygnusRuntimeError {\n+\n+        if (arcgisPersistenceBackend.containsKey(featureServiceUrl)) {\n+            return arcgisPersistenceBackend.get(featureServiceUrl);\n+        } else {\n+            LOGGER.debug(\"Creating new persistenceBackend for Feature table: \" + featureServiceUrl);\n+            LOGGER.debug(\"Token url: \" + getGetTokenUrl());\n+            LOGGER.debug(\"User name: \" + getUsername());\n+            LOGGER.debug(\"Passwd: \" + getPassword());\n+            try {\n+                NGSIArcgisFeatureTable newTable = new NGSIArcgisFeatureTable(featureServiceUrl, getUsername(),\n+                        getPassword(), getGetTokenUrl(), timeoutSecs, LOGGER);\n+                newTable.setBatchAction(ArcgisFeatureTable.ADD_UPDATE_ACTION);\n+                newTable.setBatchSize(maxBatchSize);\n+\n+                if (newTable.hasError()) {\n+                    throw new CygnusRuntimeError(\"[\" + this.getName() + \"Error creating Persistence backend: \"\n+                            + newTable.getErrorCode() + \" - \" + newTable.getErrorDesc());\n+                } else {\n+                    arcgisPersistenceBackend.put(featureServiceUrl, newTable);\n+                    return newTable;\n+                }\n+            } catch (Throwable e) {\n+                String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+                LOGGER.debug(stackTrace);\n+                throw new CygnusRuntimeError(\"Error creating new persistence Backend. \", e.getClass().getName(),\n+                        e.getMessage());\n+            }\n+        }\n+    } // getPersistenceBackend\n+\n+    /**\n+     * Sets the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @param persistenceBackend\n+     */\n+    protected void setPersistenceBackend(String featureServiceUrl, NGSIArcgisFeatureTable persistenceBackend) {\n+        arcgisPersistenceBackend.put(featureServiceUrl, persistenceBackend);\n+    } // setPersistenceBackend\n+\n+    @Override\n+    public void configure(Context context) {\n+        arcgisServicesUrl = context.getString(\"arcgis_service_url\", DEFAULT_ARCGIS_SERVICE_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_service_url=\" + arcgisServicesUrl + \")\");\n+\n+        getTokenUrl = context.getString(\"arcgis_gettoken_url\", DEFAULT_GETTOKEN_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_fearcgis_gettoken_urlature_table_url=\"\n+                + getTokenUrl + \")\");\n+\n+        userName = context.getString(\"arcgis_username\", DEFAULT_USER_NAME);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_username=\" + userName + \")\");\n+        // FIXME: Password should be read encrypted and decoded here\n+        password = context.getString(\"arcgis_password\", DEFAULT_PASSWORD);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_password=\" + password + \")\");\n+\n+        maxBatchSize = context.getInteger(\"arcgis_maxBatchSize\", DEFAULT_MAX_BATCH_SIZE);\n+        if (maxBatchSize <= 0 || maxBatchSize > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_maxBatchSize=\" + maxBatchSize + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_maxBatchSize=\" + maxBatchSize + \")\");\n+        }\n+\n+        timeoutSecs = context.getInteger(\"arcgis_timeoutSecs\", DEFAULT_BATCH_TIMEOUT_SECS);\n+        if (timeoutSecs <= 0 || timeoutSecs > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_timeoutSecs=\" + timeoutSecs + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_timeoutSecs=\" + maxBatchSize + \")\");\n+        }\n+\n+        super.configure(context);\n+    } // configure\n+\n+    @Override\n+    public void start() {\n+        try {\n+            createPersistenceBackend();\n+            LOGGER.debug(\"[\" + this.getName() + \"] Arcgis persistence backend created\");\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error while creating the Arcgis persistence backend. Details=\" + e.getMessage());\n+        } // try catch\n+\n+        super.start();\n+    } // start\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (arcgisPersistenceBackend != null) {\n+            for (Map.Entry<String, NGSIArcgisFeatureTable> backend : arcgisPersistenceBackend.entrySet()) {\n+                backend.getValue().flushBatch();\n+            }\n+            arcgisPersistenceBackend.clear();\n+        }\n+    } // stop\n+\n+    /**\n+     * Initialices a lazy singleton to share among instances on JVM.\n+     */\n+    private static synchronized void createPersistenceBackend() {\n+        if (arcgisPersistenceBackend == null) {\n+            arcgisPersistenceBackend = new ConcurrentHashMap<String, NGSIArcgisFeatureTable>();\n+        }\n+    }\n+\n+    @Override\n+    void persistBatch(NGSIBatch batch)\n+            throws CygnusBadConfiguration, CygnusPersistenceError, CygnusRuntimeError, CygnusBadContextData {\n+        if (batch == null) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Null batch, nothing to do\");\n+            return;\n+        } // if\n+\n+        try {\n+            // Iterate on the destinations\n+            batch.startIterator();\n+\n+            while (batch.hasNext()) {\n+                String destination = batch.getNextDestination();\n+                LOGGER.debug(\n+                        \"[\" + this.getName() + \"] Processing sub-batch regarding the \" + destination + \" destination\");\n+\n+                // Get the events within the current sub-batch\n+                ArrayList<NGSIEvent> events = batch.getNextEvents();\n+\n+                // Get an aggregator for this destination and initialize it\n+                NGSIArcgisAggregator aggregator = new NGSIArcgisAggregator(getrAcgisServicesUrl(), enableNameMappings);\n+                // aggregator.setService(events.get(0).getServiceForNaming(enableNameMappings));\n+                // aggregator.setServicePathForData(events.get(0).getServicePathForData());\n+                // aggregator.setServicePathForNaming(events.get(0).getServicePathForNaming(enableGrouping,\n+                // enableNameMappings));\n+                // aggregator.setEntityForNaming(events.get(0).getEntityForNaming(enableGrouping, enableNameMappings,\n+                // enableEncoding));\n+                // aggregator.setEntityType(events.get(0).getEntityTypeForNaming(enableGrouping, enableNameMappings));\n+                // aggregator.setAttribute(events.get(0).getAttributeForNaming(enableNameMappings));\n+                // aggregator.setDbName(buildDbName(aggregator.getService()));\n+                // aggregator.setTableName(buildTableName(aggregator.getServicePathForNaming(),\n+                // aggregator.getEntityForNaming(), aggregator.getEntityType(), aggregator.getAttribute()));\n+                // aggregator.setAttrNativeTypes(attrNativeTypes);\n+                // aggregator.setAttrMetadataStore(false);\n+                aggregator.initialize(events.get(0));\n+                for (NGSIEvent event : events) {\n+                    aggregator.aggregate(event);\n+                } // for\n+\n+                // Persist the aggregation\n+                persistAggregation(aggregator);\n+                batch.setNextPersisted(true);\n+\n+            } // while\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistBatch\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see com.telefonica.iot.cygnus.sinks.NGSISink#process()\n+     */\n+    @Override\n+    public Status process() throws EventDeliveryException {\n+        checkTimeouts();\n+        Status status = null;\n+        try {\n+            status = super.process();\n+        } catch (Throwable e) {\n+            LOGGER.error(e.getMessage() + \"Stack trace: \" + Arrays.toString(e.getStackTrace()));\n+        }\n+        return status;\n+    }\n+\n+    /**\n+     * Flush if timeout.\n+     */\n+    protected void checkTimeouts() {\n+        boolean timeoutFound = false;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table.hasTimeout()) {\n+                timeoutFound = true;\n+                LOGGER.info(\"[\" + this.getName() + \"] Feature table Timeout, flushing batch. \" + entry.getKey());\n+                table.flushBatch();\n+            }\n+        }\n+        if (!timeoutFound) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] No Feature table Timeouts found. Features in batch: \"\n+                    + featuresBatched());\n+        }\n+    }\n+\n+    @Override\n+    public void capRecords(NGSIBatch batch, long maxRecords) throws CygnusCappingError {\n+        // no capping\n+        LOGGER.warn(\"[\" + this.getName() + \"] Skipping capping records, just persisting it.\");\n+        try {\n+            persistBatch(batch);\n+        } catch (CygnusBadConfiguration | CygnusPersistenceError | CygnusRuntimeError | CygnusBadContextData e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error capping Records: \" + e);\n+            throw new CygnusCappingError(e.getMessage());\n+        }\n+    } // capRecords\n+\n+    @Override\n+    public void expirateRecords(long expirationTime) throws CygnusExpiratingError {\n+        LOGGER.debug(\"[\" + this.getName() + \"] Expirating records (time=\" + expirationTime + \")\");\n+\n+    } // expirateRecords\n+\n+    /**\n+     * Persist Aggregation.\n+     * \n+     * @param aggregator\n+     * @throws CygnusRuntimeError\n+     */\n+    public void persistAggregation(NGSIArcgisAggregator aggregator) throws CygnusRuntimeError {\n+        try {\n+            List<ArcgisAggregatorDomain> aggregationList = aggregator.getListArcgisAggregatorDomain();\n+            LOGGER.debug(\"[\" + this.getName() + \"] persisting aggregation, \"\n+                    + aggregator.getListArcgisAggregatorDomain().size() + \" features.\");\n+            for (ArcgisAggregatorDomain aggregation : aggregationList) {\n+                String featureTableUrl = aggregation.getFeatureTableUrl();\n+\n+                boolean isNewFeatureTable = !arcgisPersistenceBackend.containsKey(featureTableUrl);\n+                LOGGER.debug(\"[\" + this.getName() + \"] persistAggregation - Feature table: \" + featureTableUrl\n+                        + \" is new: \" + isNewFeatureTable);\n+                ArcgisFeatureTable featureTable = getPersistenceBackend(featureTableUrl);\n+\n+                // If it's a new one, sets uniqueField value\n+                if (isNewFeatureTable) {\n+                    LOGGER.debug(\"[\" + this.getName() + \"] Created new backend for \" + featureTableUrl\n+                            + \" with uniqueField: \" + aggregation.getUniqueField());\n+                    featureTable.setUniqueField(aggregation.getUniqueField());\n+                }\n+\n+                featureTable.addToBatch(aggregation.getFeature());\n+            }\n+        } catch (CygnusRuntimeError e) {\n+            String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+            LOGGER.debug(\" PersistAggregation Error: \" + stackTrace);\n+            throw (e);\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getClass().getSimpleName() + \" - \"\n+                    + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistAggregation\n+\n+    /**\n+     * @author dmartinez\n+     *\n+     */\n+    public class NGSIArcgisAggregator {\n+\n+        private List<ArcgisAggregatorDomain> listArcgisAggregatorDomain = new ArrayList<ArcgisAggregatorDomain>();\n+        private boolean enableNameMappings = true;\n+        private String argisServiceUrl = \"\";\n+\n+        private NGSIArcgisAggregator() {\n+        } // ArcgisAggregator\n+\n+        /**\n+         * Constructor.\n+         * \n+         * @param argisServiceUrl\n+         * @param enableNameMappings\n+         */\n+        public NGSIArcgisAggregator(String argisServiceUrl, boolean enableNameMappings) {\n+            this();\n+            this.enableNameMappings = enableNameMappings;\n+            this.argisServiceUrl = argisServiceUrl;\n+        } // ArcgisAggregator\n+\n+        /**\n+         * \n+         * @param event\n+         */\n+        public void initialize(NGSIEvent event) {\n+        } // initialize\n+\n+        /**\n+         * @return the listArcgisAggregatorDomain\n+         */\n+        public List<ArcgisAggregatorDomain> getListArcgisAggregatorDomain() {\n+            return listArcgisAggregatorDomain;\n+        }\n+\n+        /**\n+         * Determines if input sitring is quoted or not.\n+         * \n+         * @param string\n+         * @return boolean\n+         */\n+\n+        /**\n+         * \n+         * @param event\n+         * @throws CygnusRuntimeError\n+         */\n+        public void aggregate(NGSIEvent event) throws CygnusRuntimeError {\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - ContextElement ->\" + event.getContextElement());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate -  MappedCE ->\" + event.getMappedCE());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - OriginalCE ->\" + event.getOriginalCE());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - enableNameMappings status -> \" + enableNameMappings);\n+\n+            ContextElement contextElement = null;\n+            try {\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - creating new aggregation object.\");\n+                ArcgisAggregatorDomain aggregation = new ArcgisAggregatorDomain(LOGGER);\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - aggregation created\");\n+                Feature feature = aggregation.getFeature();\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Feature getted\");\n+                String service = \"\";\n+                String subService = \"\";\n+                String featureTableUrl = \"\";\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Selecting context\");\n+                // get the contextElement\n+                if (!enableNameMappings) {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - no mappings\");\n+                    contextElement = event.getContextElement();\n+                } else {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - mappings\");\n+                    contextElement = event.getMappedCE();\n+                }\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Selected context ->\" + contextElement);\n+\n+                // get the getRecvTimeTs headers\n+                Map<String, String> headers = event.getHeaders();\n+\n+                for (Entry<String, String> entry : headers.entrySet()) {\n+                    LOGGER.debug(\"Header entry key --> \" + entry.getKey().toString() + \", value --> \"\n+                            + entry.getValue().toString());\n+                    if (entry.getKey() != null\n+                            && NGSIConstants.FLUME_HEADER_MAPPED_SERVICE.equals(entry.getKey().toString())) {\n+                        service = entry.getValue().toString();\n+                    } else if (entry.getKey() != null\n+                            && NGSIConstants.FLUME_HEADER_MAPPED_SERVICE_PATH.equals(entry.getKey().toString())) {\n+                        subService = entry.getValue().toString();\n+                    }\n+                } // for\n+                \n+                // Compose full url\n+                featureTableUrl = argisServiceUrl + \"/\" + service + \"/\" + subService;\n+                featureTableUrl = featureTableUrl.replaceAll(\"([^:])\\\\/\\\\/\", \"$1/\");\n+                aggregation.setFeatureTableUrl(featureTableUrl);\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - featureTableUrl ->\" + featureTableUrl);\n+\n+                // iterate on all this context element attributes, if there are\n+                // attributes\n+                ArrayList<ContextAttribute> contextAttributes = contextElement.getAttributes();\n+\n+                String entityId = contextElement.getId();\n+                String entityType = contextElement.getType();\n+\n+                // Set unique filed and it's value.\n+                aggregation.setUniqueField(entityType);\n+                feature.addAttribute(entityType, entityId);\n+\n+                contextAttrToFeature(feature, contextAttributes);\n+\n+                aggregation.setFeature(feature);\n+                listArcgisAggregatorDomain.add(aggregation);\n+\n+            } catch (JSONException e) {\n+                LOGGER.error(\n+                        \"[NGSIArcgisAggregator] aggregate - Error pharsing JSON BODY \" + contextElement.toString());\n+                throw new CygnusRuntimeError(e.getMessage());\n+            } catch (Exception e) {\n+                LOGGER.error(\"[NGSIArcgisAggregator] aggregate - Unexpected Error\" + e.getMessage()\n+                        + \"\\n contextElement: \" + contextElement.toString());\n+                throw new CygnusRuntimeError(e.getMessage());\n+            }\n+\n+        } // aggregate\n+\n+        /**\n+         * \n+         * @param feature\n+         * @param contextAttributes\n+         */\n+        protected void contextAttrToFeature(Feature feature, ArrayList<ContextAttribute> contextAttributes) {\n+            if (contextAttributes == null || contextAttributes.isEmpty()) {\n+                LOGGER.debug(\n+                        \"[NGSIArcgisAggregator-contextAttrToFeature] contextAttributes NULL or empty, ignoring it. \");\n+            } else {\n+                for (ContextAttribute contextAttribute : contextAttributes) {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator-contextAttrToFeature] Processing Attribute: \"\n+                            + contextAttribute.toString());\n+                    String attrName = contextAttribute.getName();\n+                    String attrType = contextAttribute.getType();\n+                    // get attribute value as is, quoted or not\n+                    JsonElement attrValue = contextAttribute.getValue();\n+\n+                    // TODO crop metadata values\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Atribute (name --> \" + attrName + \", type --> \"\n+                            + attrType + \", value --> \" + attrValue + \", metadata= \" + \"ignored \" + \")\");\n+\n+                    // Get Feature attributes\n+                    LOGGER.debug(\"Proccessing attribute value:  \" + attrName + \" --> \" + attrValue);\n+\n+                    jsonElementToFeatureAttr(attrName, attrType, attrValue, feature);\n+\n+                } // for\n+            } // if else\n+        }\n+    } // NGSIArcgisAggregator\n+\n+    /**\n+     * Extracts Feature attributes from JSON.\n+     * \n+     * @param attrName\n+     * @param attrType\n+     * @param attrValue\n+     * @param feature\n+     */\n+    protected void jsonElementToFeatureAttr(String attrName, String attrType, JsonElement attrValue, Feature feature) {\n+\n+        // Get Feature attributes\n+        LOGGER.debug(\"Proccessing attribute value:  \" + attrName + \" --> \" + attrValue);\n+\n+        attrType = attrType.trim().toLowerCase();\n+\n+        switch (attrType) {\n+\n+            case \"geo:json\":\n+                try {\n+                    JsonObject location = attrValue.getAsJsonObject();\n+                    if (location.get(\"type\").getAsString().equals(\"Point\")) {\n+                        JsonArray coordinates = location.get(\"coordinates\").getAsJsonArray();\n+                        double latitude = coordinates.get(0).getAsDouble();\n+                        double longitude = coordinates.get(1).getAsDouble();\n+\n+                        Point point = new Point(latitude, longitude);\n+                        feature.setGeometry(point);\n+\n+                    } else {\n+                        LOGGER.warn(\"Invalid geo:json type, only points allowed: \" + location.toString());\n+                    }\n+                } catch (Exception e) {\n+                    LOGGER.error(\"Invalid geo:json format, (sikipped): \" + attrValue.toString() + \" - Error: \"\n+                            + e.getMessage());\n+                }\n+                break;\n+            case \"boolean\":\n+                if (attrValue.isJsonPrimitive() && attrValue.getAsJsonPrimitive().isBoolean()) {\n+                    feature.addAttribute(attrName, attrValue.getAsBoolean());\n+                } else {\n+                    String strValue = attrValue.getAsString().toLowerCase().trim();\n+                    boolean result = \"true\".equals(strValue) || \"1\".equals(strValue);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczMDIyOA=="}, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 612}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTQ0Nzk3OnYy", "diffSide": "RIGHT", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMToyMDozOVrOGKkLlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMzo1MDo0NVrOGMkOnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczMTczNA==", "bodyText": "Is it necesary that this class receives the logger object as a parametter? This inner class seems to be used only by the outer class, so it has acces to the outer class object.\nWould it be possible that this inner class usses the outer Logger object?", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r413731734", "createdAt": "2020-04-23T11:20:39Z", "author": {"login": "IvanHdzC"}, "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "diffHunk": "@@ -0,0 +1,789 @@\n+/**\n+ * Copyright 2014-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+\n+package com.telefonica.iot.cygnus.sinks;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.commons.lang.exception.ExceptionUtils;\n+import org.apache.flume.Context;\n+import org.apache.flume.EventDeliveryException;\n+import org.json.JSONException;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Point;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.ArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.NGSIArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextAttribute;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextElement;\n+import com.telefonica.iot.cygnus.errors.CygnusBadConfiguration;\n+import com.telefonica.iot.cygnus.errors.CygnusBadContextData;\n+import com.telefonica.iot.cygnus.errors.CygnusCappingError;\n+import com.telefonica.iot.cygnus.errors.CygnusExpiratingError;\n+import com.telefonica.iot.cygnus.errors.CygnusPersistenceError;\n+import com.telefonica.iot.cygnus.errors.CygnusRuntimeError;\n+import com.telefonica.iot.cygnus.interceptors.NGSIEvent;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+import com.telefonica.iot.cygnus.utils.NGSIConstants;\n+\n+import jodd.util.URLDecoder;\n+\n+/**\n+ *\n+ * @author dmartinez\n+ * \n+ *         Detailed documentation can be found at:\n+ *         https://github.com/telefonicaid/fiware-cygnus/blob/master/doc/flume_extensions_catalogue/ngsi_arcgis_sink.md\n+ */\n+public class NGSIArcgisFeatureTableSink extends NGSISink {\n+\n+    private static final String DEFAULT_ARCGIS_SERVICE_URL = \"localhost\";\n+    private static final String DEFAULT_GETTOKEN_URL = \"localhost\";\n+    private static final String DEFAULT_USER_NAME = \"root\";\n+    private static final String DEFAULT_PASSWORD = \"\";\n+    private static final int DEFAULT_MAX_BATCH_SIZE = 10;\n+    private static final int DEFAULT_BATCH_TIMEOUT_SECS = 60;\n+    private static final String ARCGIS_INSTANCE_NAME = \"arcgis\";\n+\n+    private static final CygnusLogger LOGGER = new CygnusLogger(NGSIArcgisFeatureTableSink.class);\n+    private String arcgisServicesUrl;\n+    private String getTokenUrl;\n+    private String userName;\n+    private String password;\n+    private int maxBatchSize;\n+    private long timeoutSecs;\n+    private static volatile Map<String, NGSIArcgisFeatureTable> arcgisPersistenceBackend;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public NGSIArcgisFeatureTableSink() {\n+        super();\n+    } // NGSIArcgisFeatureTableSink\n+\n+    /**\n+     * Gets the Argis services url. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The services url\n+     */\n+    protected String getrAcgisServicesUrl() {\n+        return arcgisServicesUrl;\n+    } // getrAcgisServicesUrl\n+\n+    /**\n+     * Gets getToken's service url.\n+     * \n+     * @return\n+     */\n+    public String getGetTokenUrl() {\n+        return getTokenUrl;\n+    }\n+\n+    /**\n+     * Sets getToken service url.\n+     * \n+     * @param getTokenUrl\n+     */\n+    public void setGetTokenUrl(String getTokenUrl) {\n+        this.getTokenUrl = getTokenUrl;\n+    }\n+\n+    /**\n+     * Gets the username. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The username\n+     */\n+    protected String getUsername() {\n+        return userName;\n+    } // getUsername\n+\n+    /**\n+     * Gets the password. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The password\n+     */\n+    protected String getPassword() {\n+        return password;\n+    } // getPassword\n+\n+    /**\n+     * \n+     */\n+    protected int featuresBatched() {\n+        int total = 0;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table != null) {\n+                total += table.featuresBatched();\n+            }\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Returns the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The persistence backend\n+     * @throws CygnusRuntimeError\n+     */\n+    protected ArcgisFeatureTable getPersistenceBackend(String featureServiceUrl) throws CygnusRuntimeError {\n+\n+        if (arcgisPersistenceBackend.containsKey(featureServiceUrl)) {\n+            return arcgisPersistenceBackend.get(featureServiceUrl);\n+        } else {\n+            LOGGER.debug(\"Creating new persistenceBackend for Feature table: \" + featureServiceUrl);\n+            LOGGER.debug(\"Token url: \" + getGetTokenUrl());\n+            LOGGER.debug(\"User name: \" + getUsername());\n+            LOGGER.debug(\"Passwd: \" + getPassword());\n+            try {\n+                NGSIArcgisFeatureTable newTable = new NGSIArcgisFeatureTable(featureServiceUrl, getUsername(),\n+                        getPassword(), getGetTokenUrl(), timeoutSecs, LOGGER);\n+                newTable.setBatchAction(ArcgisFeatureTable.ADD_UPDATE_ACTION);\n+                newTable.setBatchSize(maxBatchSize);\n+\n+                if (newTable.hasError()) {\n+                    throw new CygnusRuntimeError(\"[\" + this.getName() + \"Error creating Persistence backend: \"\n+                            + newTable.getErrorCode() + \" - \" + newTable.getErrorDesc());\n+                } else {\n+                    arcgisPersistenceBackend.put(featureServiceUrl, newTable);\n+                    return newTable;\n+                }\n+            } catch (Throwable e) {\n+                String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+                LOGGER.debug(stackTrace);\n+                throw new CygnusRuntimeError(\"Error creating new persistence Backend. \", e.getClass().getName(),\n+                        e.getMessage());\n+            }\n+        }\n+    } // getPersistenceBackend\n+\n+    /**\n+     * Sets the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @param persistenceBackend\n+     */\n+    protected void setPersistenceBackend(String featureServiceUrl, NGSIArcgisFeatureTable persistenceBackend) {\n+        arcgisPersistenceBackend.put(featureServiceUrl, persistenceBackend);\n+    } // setPersistenceBackend\n+\n+    @Override\n+    public void configure(Context context) {\n+        arcgisServicesUrl = context.getString(\"arcgis_service_url\", DEFAULT_ARCGIS_SERVICE_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_service_url=\" + arcgisServicesUrl + \")\");\n+\n+        getTokenUrl = context.getString(\"arcgis_gettoken_url\", DEFAULT_GETTOKEN_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_fearcgis_gettoken_urlature_table_url=\"\n+                + getTokenUrl + \")\");\n+\n+        userName = context.getString(\"arcgis_username\", DEFAULT_USER_NAME);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_username=\" + userName + \")\");\n+        // FIXME: Password should be read encrypted and decoded here\n+        password = context.getString(\"arcgis_password\", DEFAULT_PASSWORD);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_password=\" + password + \")\");\n+\n+        maxBatchSize = context.getInteger(\"arcgis_maxBatchSize\", DEFAULT_MAX_BATCH_SIZE);\n+        if (maxBatchSize <= 0 || maxBatchSize > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_maxBatchSize=\" + maxBatchSize + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_maxBatchSize=\" + maxBatchSize + \")\");\n+        }\n+\n+        timeoutSecs = context.getInteger(\"arcgis_timeoutSecs\", DEFAULT_BATCH_TIMEOUT_SECS);\n+        if (timeoutSecs <= 0 || timeoutSecs > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_timeoutSecs=\" + timeoutSecs + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_timeoutSecs=\" + maxBatchSize + \")\");\n+        }\n+\n+        super.configure(context);\n+    } // configure\n+\n+    @Override\n+    public void start() {\n+        try {\n+            createPersistenceBackend();\n+            LOGGER.debug(\"[\" + this.getName() + \"] Arcgis persistence backend created\");\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error while creating the Arcgis persistence backend. Details=\" + e.getMessage());\n+        } // try catch\n+\n+        super.start();\n+    } // start\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (arcgisPersistenceBackend != null) {\n+            for (Map.Entry<String, NGSIArcgisFeatureTable> backend : arcgisPersistenceBackend.entrySet()) {\n+                backend.getValue().flushBatch();\n+            }\n+            arcgisPersistenceBackend.clear();\n+        }\n+    } // stop\n+\n+    /**\n+     * Initialices a lazy singleton to share among instances on JVM.\n+     */\n+    private static synchronized void createPersistenceBackend() {\n+        if (arcgisPersistenceBackend == null) {\n+            arcgisPersistenceBackend = new ConcurrentHashMap<String, NGSIArcgisFeatureTable>();\n+        }\n+    }\n+\n+    @Override\n+    void persistBatch(NGSIBatch batch)\n+            throws CygnusBadConfiguration, CygnusPersistenceError, CygnusRuntimeError, CygnusBadContextData {\n+        if (batch == null) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Null batch, nothing to do\");\n+            return;\n+        } // if\n+\n+        try {\n+            // Iterate on the destinations\n+            batch.startIterator();\n+\n+            while (batch.hasNext()) {\n+                String destination = batch.getNextDestination();\n+                LOGGER.debug(\n+                        \"[\" + this.getName() + \"] Processing sub-batch regarding the \" + destination + \" destination\");\n+\n+                // Get the events within the current sub-batch\n+                ArrayList<NGSIEvent> events = batch.getNextEvents();\n+\n+                // Get an aggregator for this destination and initialize it\n+                NGSIArcgisAggregator aggregator = new NGSIArcgisAggregator(getrAcgisServicesUrl(), enableNameMappings);\n+                // aggregator.setService(events.get(0).getServiceForNaming(enableNameMappings));\n+                // aggregator.setServicePathForData(events.get(0).getServicePathForData());\n+                // aggregator.setServicePathForNaming(events.get(0).getServicePathForNaming(enableGrouping,\n+                // enableNameMappings));\n+                // aggregator.setEntityForNaming(events.get(0).getEntityForNaming(enableGrouping, enableNameMappings,\n+                // enableEncoding));\n+                // aggregator.setEntityType(events.get(0).getEntityTypeForNaming(enableGrouping, enableNameMappings));\n+                // aggregator.setAttribute(events.get(0).getAttributeForNaming(enableNameMappings));\n+                // aggregator.setDbName(buildDbName(aggregator.getService()));\n+                // aggregator.setTableName(buildTableName(aggregator.getServicePathForNaming(),\n+                // aggregator.getEntityForNaming(), aggregator.getEntityType(), aggregator.getAttribute()));\n+                // aggregator.setAttrNativeTypes(attrNativeTypes);\n+                // aggregator.setAttrMetadataStore(false);\n+                aggregator.initialize(events.get(0));\n+                for (NGSIEvent event : events) {\n+                    aggregator.aggregate(event);\n+                } // for\n+\n+                // Persist the aggregation\n+                persistAggregation(aggregator);\n+                batch.setNextPersisted(true);\n+\n+            } // while\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistBatch\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see com.telefonica.iot.cygnus.sinks.NGSISink#process()\n+     */\n+    @Override\n+    public Status process() throws EventDeliveryException {\n+        checkTimeouts();\n+        Status status = null;\n+        try {\n+            status = super.process();\n+        } catch (Throwable e) {\n+            LOGGER.error(e.getMessage() + \"Stack trace: \" + Arrays.toString(e.getStackTrace()));\n+        }\n+        return status;\n+    }\n+\n+    /**\n+     * Flush if timeout.\n+     */\n+    protected void checkTimeouts() {\n+        boolean timeoutFound = false;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table.hasTimeout()) {\n+                timeoutFound = true;\n+                LOGGER.info(\"[\" + this.getName() + \"] Feature table Timeout, flushing batch. \" + entry.getKey());\n+                table.flushBatch();\n+            }\n+        }\n+        if (!timeoutFound) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] No Feature table Timeouts found. Features in batch: \"\n+                    + featuresBatched());\n+        }\n+    }\n+\n+    @Override\n+    public void capRecords(NGSIBatch batch, long maxRecords) throws CygnusCappingError {\n+        // no capping\n+        LOGGER.warn(\"[\" + this.getName() + \"] Skipping capping records, just persisting it.\");\n+        try {\n+            persistBatch(batch);\n+        } catch (CygnusBadConfiguration | CygnusPersistenceError | CygnusRuntimeError | CygnusBadContextData e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error capping Records: \" + e);\n+            throw new CygnusCappingError(e.getMessage());\n+        }\n+    } // capRecords\n+\n+    @Override\n+    public void expirateRecords(long expirationTime) throws CygnusExpiratingError {\n+        LOGGER.debug(\"[\" + this.getName() + \"] Expirating records (time=\" + expirationTime + \")\");\n+\n+    } // expirateRecords\n+\n+    /**\n+     * Persist Aggregation.\n+     * \n+     * @param aggregator\n+     * @throws CygnusRuntimeError\n+     */\n+    public void persistAggregation(NGSIArcgisAggregator aggregator) throws CygnusRuntimeError {\n+        try {\n+            List<ArcgisAggregatorDomain> aggregationList = aggregator.getListArcgisAggregatorDomain();\n+            LOGGER.debug(\"[\" + this.getName() + \"] persisting aggregation, \"\n+                    + aggregator.getListArcgisAggregatorDomain().size() + \" features.\");\n+            for (ArcgisAggregatorDomain aggregation : aggregationList) {\n+                String featureTableUrl = aggregation.getFeatureTableUrl();\n+\n+                boolean isNewFeatureTable = !arcgisPersistenceBackend.containsKey(featureTableUrl);\n+                LOGGER.debug(\"[\" + this.getName() + \"] persistAggregation - Feature table: \" + featureTableUrl\n+                        + \" is new: \" + isNewFeatureTable);\n+                ArcgisFeatureTable featureTable = getPersistenceBackend(featureTableUrl);\n+\n+                // If it's a new one, sets uniqueField value\n+                if (isNewFeatureTable) {\n+                    LOGGER.debug(\"[\" + this.getName() + \"] Created new backend for \" + featureTableUrl\n+                            + \" with uniqueField: \" + aggregation.getUniqueField());\n+                    featureTable.setUniqueField(aggregation.getUniqueField());\n+                }\n+\n+                featureTable.addToBatch(aggregation.getFeature());\n+            }\n+        } catch (CygnusRuntimeError e) {\n+            String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+            LOGGER.debug(\" PersistAggregation Error: \" + stackTrace);\n+            throw (e);\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getClass().getSimpleName() + \" - \"\n+                    + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistAggregation\n+\n+    /**\n+     * @author dmartinez\n+     *\n+     */\n+    public class NGSIArcgisAggregator {\n+\n+        private List<ArcgisAggregatorDomain> listArcgisAggregatorDomain = new ArrayList<ArcgisAggregatorDomain>();\n+        private boolean enableNameMappings = true;\n+        private String argisServiceUrl = \"\";\n+\n+        private NGSIArcgisAggregator() {\n+        } // ArcgisAggregator\n+\n+        /**\n+         * Constructor.\n+         * \n+         * @param argisServiceUrl\n+         * @param enableNameMappings\n+         */\n+        public NGSIArcgisAggregator(String argisServiceUrl, boolean enableNameMappings) {\n+            this();\n+            this.enableNameMappings = enableNameMappings;\n+            this.argisServiceUrl = argisServiceUrl;\n+        } // ArcgisAggregator\n+\n+        /**\n+         * \n+         * @param event\n+         */\n+        public void initialize(NGSIEvent event) {\n+        } // initialize\n+\n+        /**\n+         * @return the listArcgisAggregatorDomain\n+         */\n+        public List<ArcgisAggregatorDomain> getListArcgisAggregatorDomain() {\n+            return listArcgisAggregatorDomain;\n+        }\n+\n+        /**\n+         * Determines if input sitring is quoted or not.\n+         * \n+         * @param string\n+         * @return boolean\n+         */\n+\n+        /**\n+         * \n+         * @param event\n+         * @throws CygnusRuntimeError\n+         */\n+        public void aggregate(NGSIEvent event) throws CygnusRuntimeError {\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - ContextElement ->\" + event.getContextElement());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate -  MappedCE ->\" + event.getMappedCE());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - OriginalCE ->\" + event.getOriginalCE());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - enableNameMappings status -> \" + enableNameMappings);\n+\n+            ContextElement contextElement = null;\n+            try {\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - creating new aggregation object.\");\n+                ArcgisAggregatorDomain aggregation = new ArcgisAggregatorDomain(LOGGER);\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - aggregation created\");\n+                Feature feature = aggregation.getFeature();\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Feature getted\");\n+                String service = \"\";\n+                String subService = \"\";\n+                String featureTableUrl = \"\";\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Selecting context\");\n+                // get the contextElement\n+                if (!enableNameMappings) {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - no mappings\");\n+                    contextElement = event.getContextElement();\n+                } else {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - mappings\");\n+                    contextElement = event.getMappedCE();\n+                }\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Selected context ->\" + contextElement);\n+\n+                // get the getRecvTimeTs headers\n+                Map<String, String> headers = event.getHeaders();\n+\n+                for (Entry<String, String> entry : headers.entrySet()) {\n+                    LOGGER.debug(\"Header entry key --> \" + entry.getKey().toString() + \", value --> \"\n+                            + entry.getValue().toString());\n+                    if (entry.getKey() != null\n+                            && NGSIConstants.FLUME_HEADER_MAPPED_SERVICE.equals(entry.getKey().toString())) {\n+                        service = entry.getValue().toString();\n+                    } else if (entry.getKey() != null\n+                            && NGSIConstants.FLUME_HEADER_MAPPED_SERVICE_PATH.equals(entry.getKey().toString())) {\n+                        subService = entry.getValue().toString();\n+                    }\n+                } // for\n+                \n+                // Compose full url\n+                featureTableUrl = argisServiceUrl + \"/\" + service + \"/\" + subService;\n+                featureTableUrl = featureTableUrl.replaceAll(\"([^:])\\\\/\\\\/\", \"$1/\");\n+                aggregation.setFeatureTableUrl(featureTableUrl);\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - featureTableUrl ->\" + featureTableUrl);\n+\n+                // iterate on all this context element attributes, if there are\n+                // attributes\n+                ArrayList<ContextAttribute> contextAttributes = contextElement.getAttributes();\n+\n+                String entityId = contextElement.getId();\n+                String entityType = contextElement.getType();\n+\n+                // Set unique filed and it's value.\n+                aggregation.setUniqueField(entityType);\n+                feature.addAttribute(entityType, entityId);\n+\n+                contextAttrToFeature(feature, contextAttributes);\n+\n+                aggregation.setFeature(feature);\n+                listArcgisAggregatorDomain.add(aggregation);\n+\n+            } catch (JSONException e) {\n+                LOGGER.error(\n+                        \"[NGSIArcgisAggregator] aggregate - Error pharsing JSON BODY \" + contextElement.toString());\n+                throw new CygnusRuntimeError(e.getMessage());\n+            } catch (Exception e) {\n+                LOGGER.error(\"[NGSIArcgisAggregator] aggregate - Unexpected Error\" + e.getMessage()\n+                        + \"\\n contextElement: \" + contextElement.toString());\n+                throw new CygnusRuntimeError(e.getMessage());\n+            }\n+\n+        } // aggregate\n+\n+        /**\n+         * \n+         * @param feature\n+         * @param contextAttributes\n+         */\n+        protected void contextAttrToFeature(Feature feature, ArrayList<ContextAttribute> contextAttributes) {\n+            if (contextAttributes == null || contextAttributes.isEmpty()) {\n+                LOGGER.debug(\n+                        \"[NGSIArcgisAggregator-contextAttrToFeature] contextAttributes NULL or empty, ignoring it. \");\n+            } else {\n+                for (ContextAttribute contextAttribute : contextAttributes) {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator-contextAttrToFeature] Processing Attribute: \"\n+                            + contextAttribute.toString());\n+                    String attrName = contextAttribute.getName();\n+                    String attrType = contextAttribute.getType();\n+                    // get attribute value as is, quoted or not\n+                    JsonElement attrValue = contextAttribute.getValue();\n+\n+                    // TODO crop metadata values\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Atribute (name --> \" + attrName + \", type --> \"\n+                            + attrType + \", value --> \" + attrValue + \", metadata= \" + \"ignored \" + \")\");\n+\n+                    // Get Feature attributes\n+                    LOGGER.debug(\"Proccessing attribute value:  \" + attrName + \" --> \" + attrValue);\n+\n+                    jsonElementToFeatureAttr(attrName, attrType, attrValue, feature);\n+\n+                } // for\n+            } // if else\n+        }\n+    } // NGSIArcgisAggregator\n+\n+    /**\n+     * Extracts Feature attributes from JSON.\n+     * \n+     * @param attrName\n+     * @param attrType\n+     * @param attrValue\n+     * @param feature\n+     */\n+    protected void jsonElementToFeatureAttr(String attrName, String attrType, JsonElement attrValue, Feature feature) {\n+\n+        // Get Feature attributes\n+        LOGGER.debug(\"Proccessing attribute value:  \" + attrName + \" --> \" + attrValue);\n+\n+        attrType = attrType.trim().toLowerCase();\n+\n+        switch (attrType) {\n+\n+            case \"geo:json\":\n+                try {\n+                    JsonObject location = attrValue.getAsJsonObject();\n+                    if (location.get(\"type\").getAsString().equals(\"Point\")) {\n+                        JsonArray coordinates = location.get(\"coordinates\").getAsJsonArray();\n+                        double latitude = coordinates.get(0).getAsDouble();\n+                        double longitude = coordinates.get(1).getAsDouble();\n+\n+                        Point point = new Point(latitude, longitude);\n+                        feature.setGeometry(point);\n+\n+                    } else {\n+                        LOGGER.warn(\"Invalid geo:json type, only points allowed: \" + location.toString());\n+                    }\n+                } catch (Exception e) {\n+                    LOGGER.error(\"Invalid geo:json format, (sikipped): \" + attrValue.toString() + \" - Error: \"\n+                            + e.getMessage());\n+                }\n+                break;\n+            case \"boolean\":\n+                if (attrValue.isJsonPrimitive() && attrValue.getAsJsonPrimitive().isBoolean()) {\n+                    feature.addAttribute(attrName, attrValue.getAsBoolean());\n+                } else {\n+                    String strValue = attrValue.getAsString().toLowerCase().trim();\n+                    boolean result = \"true\".equals(strValue) || \"1\".equals(strValue);\n+                    feature.addAttribute(attrName, result);\n+                }\n+                break;\n+            case \"datetime\":\n+                String dateStr = attrValue.toString();\n+                feature.addAttribute(attrName, parseFiwareDate(dateStr));\n+                break;\n+\n+            default:\n+                // Verify if it is a string (it is into quotation marks)\n+                if (isQuoted(attrValue.toString())) {\n+                    // Insert unquoted\n+                    String strValue = URLDecoder.decode(unquote(attrValue.toString()));\n+                    feature.getAttributes().put(attrName, strValue);\n+                } else {\n+                    try {\n+                        // Try to insert as Integer\n+                        feature.addAttribute(attrName, Integer.parseInt(attrValue.toString()));\n+                    } catch (NumberFormatException e2) {\n+                        try {\n+                            // Try to insert as Double\n+                            feature.addAttribute(attrName, Double.parseDouble(attrValue.toString()));\n+                        } catch (NumberFormatException e3) {\n+                            // If all fails, insert as String\n+                            LOGGER.warn(\n+                                    \"[NGSIArcgisAggregator] Unquoted String attribute: \" + attrName + \":\" + attrValue);\n+                            String strValue = URLDecoder.decode(attrValue.toString());\n+                            feature.addAttribute(attrName, strValue);\n+                        }\n+                    }\n+                }\n+\n+        }\n+\n+    }\n+\n+    /**\n+     * Try to convert Fiware DateTime String to Date object, If it can't, input string will be returned.\n+     * \n+     * @param dateStr\n+     * @return Date Object, or String.\n+     */\n+    private Object parseFiwareDate(String dateStr) {\n+\n+        // Normalize String date\n+        dateStr = unquote(dateStr);\n+        dateStr = dateStr.replaceAll(\"Z[\\\\s]*$\", \"+00:00\");\n+        dateStr = dateStr.replaceAll(\"([+-]{1}[0-9]{1,2})[\\\\s\\\\t\\\\r\\\\n]*$\", \"$1:00\");\n+\n+        DateFormat dateFormatter = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSXXX\");\n+        try {\n+            Date date = dateFormatter.parse(dateStr);\n+            return date;\n+        } catch (ParseException e) {\n+            LOGGER.error(\"[NGSIArcgisAggregator] Unexpected DateTime format: \" + dateStr);\n+            return dateStr;\n+        }\n+    }\n+\n+    /**\n+     * Determines if input sitring is quoted or not.\n+     * \n+     * @param string\n+     * @return boolean\n+     */\n+\n+    private boolean isQuoted(String string) {\n+        return string.matches(\"^[\\\\s]*\\\\\\\"(.*)\\\\\\\"[\\\\s]*$\");\n+    }\n+\n+    /**\n+     * Unquote input string.\n+     * \n+     * @param Unquoted\n+     *            string\n+     * @return\n+     */\n+    private String unquote(String string) {\n+        return string.replaceAll(\"^[\\\\s]*\\\\\\\"(.*)\\\\\\\"[\\\\s]*$\", \"$1\");\n+    }\n+\n+    /**\n+     * \n+     * @author PMO Santander Smart City \u2013 Ayuntamiento de Santander\n+     *\n+     */\n+    public class ArcgisAggregatorDomain {\n+        private CygnusLogger LOGGER = null;\n+\n+        // string containing the data aggregation\n+        private Feature feature;\n+\n+        private String featureTableUrl;\n+\n+        private String uniqueField;\n+\n+        /**\n+           * \n+           */\n+        ArcgisAggregatorDomain(CygnusLogger logger) throws CygnusRuntimeError {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 712}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgyOTY2MA==", "bodyText": "Logger parameter removed.", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r415829660", "createdAt": "2020-04-27T13:50:45Z", "author": {"login": "pmo-sdr"}, "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "diffHunk": "@@ -0,0 +1,789 @@\n+/**\n+ * Copyright 2014-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+\n+package com.telefonica.iot.cygnus.sinks;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.commons.lang.exception.ExceptionUtils;\n+import org.apache.flume.Context;\n+import org.apache.flume.EventDeliveryException;\n+import org.json.JSONException;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Point;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.ArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.NGSIArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextAttribute;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextElement;\n+import com.telefonica.iot.cygnus.errors.CygnusBadConfiguration;\n+import com.telefonica.iot.cygnus.errors.CygnusBadContextData;\n+import com.telefonica.iot.cygnus.errors.CygnusCappingError;\n+import com.telefonica.iot.cygnus.errors.CygnusExpiratingError;\n+import com.telefonica.iot.cygnus.errors.CygnusPersistenceError;\n+import com.telefonica.iot.cygnus.errors.CygnusRuntimeError;\n+import com.telefonica.iot.cygnus.interceptors.NGSIEvent;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+import com.telefonica.iot.cygnus.utils.NGSIConstants;\n+\n+import jodd.util.URLDecoder;\n+\n+/**\n+ *\n+ * @author dmartinez\n+ * \n+ *         Detailed documentation can be found at:\n+ *         https://github.com/telefonicaid/fiware-cygnus/blob/master/doc/flume_extensions_catalogue/ngsi_arcgis_sink.md\n+ */\n+public class NGSIArcgisFeatureTableSink extends NGSISink {\n+\n+    private static final String DEFAULT_ARCGIS_SERVICE_URL = \"localhost\";\n+    private static final String DEFAULT_GETTOKEN_URL = \"localhost\";\n+    private static final String DEFAULT_USER_NAME = \"root\";\n+    private static final String DEFAULT_PASSWORD = \"\";\n+    private static final int DEFAULT_MAX_BATCH_SIZE = 10;\n+    private static final int DEFAULT_BATCH_TIMEOUT_SECS = 60;\n+    private static final String ARCGIS_INSTANCE_NAME = \"arcgis\";\n+\n+    private static final CygnusLogger LOGGER = new CygnusLogger(NGSIArcgisFeatureTableSink.class);\n+    private String arcgisServicesUrl;\n+    private String getTokenUrl;\n+    private String userName;\n+    private String password;\n+    private int maxBatchSize;\n+    private long timeoutSecs;\n+    private static volatile Map<String, NGSIArcgisFeatureTable> arcgisPersistenceBackend;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public NGSIArcgisFeatureTableSink() {\n+        super();\n+    } // NGSIArcgisFeatureTableSink\n+\n+    /**\n+     * Gets the Argis services url. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The services url\n+     */\n+    protected String getrAcgisServicesUrl() {\n+        return arcgisServicesUrl;\n+    } // getrAcgisServicesUrl\n+\n+    /**\n+     * Gets getToken's service url.\n+     * \n+     * @return\n+     */\n+    public String getGetTokenUrl() {\n+        return getTokenUrl;\n+    }\n+\n+    /**\n+     * Sets getToken service url.\n+     * \n+     * @param getTokenUrl\n+     */\n+    public void setGetTokenUrl(String getTokenUrl) {\n+        this.getTokenUrl = getTokenUrl;\n+    }\n+\n+    /**\n+     * Gets the username. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The username\n+     */\n+    protected String getUsername() {\n+        return userName;\n+    } // getUsername\n+\n+    /**\n+     * Gets the password. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The password\n+     */\n+    protected String getPassword() {\n+        return password;\n+    } // getPassword\n+\n+    /**\n+     * \n+     */\n+    protected int featuresBatched() {\n+        int total = 0;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table != null) {\n+                total += table.featuresBatched();\n+            }\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Returns the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The persistence backend\n+     * @throws CygnusRuntimeError\n+     */\n+    protected ArcgisFeatureTable getPersistenceBackend(String featureServiceUrl) throws CygnusRuntimeError {\n+\n+        if (arcgisPersistenceBackend.containsKey(featureServiceUrl)) {\n+            return arcgisPersistenceBackend.get(featureServiceUrl);\n+        } else {\n+            LOGGER.debug(\"Creating new persistenceBackend for Feature table: \" + featureServiceUrl);\n+            LOGGER.debug(\"Token url: \" + getGetTokenUrl());\n+            LOGGER.debug(\"User name: \" + getUsername());\n+            LOGGER.debug(\"Passwd: \" + getPassword());\n+            try {\n+                NGSIArcgisFeatureTable newTable = new NGSIArcgisFeatureTable(featureServiceUrl, getUsername(),\n+                        getPassword(), getGetTokenUrl(), timeoutSecs, LOGGER);\n+                newTable.setBatchAction(ArcgisFeatureTable.ADD_UPDATE_ACTION);\n+                newTable.setBatchSize(maxBatchSize);\n+\n+                if (newTable.hasError()) {\n+                    throw new CygnusRuntimeError(\"[\" + this.getName() + \"Error creating Persistence backend: \"\n+                            + newTable.getErrorCode() + \" - \" + newTable.getErrorDesc());\n+                } else {\n+                    arcgisPersistenceBackend.put(featureServiceUrl, newTable);\n+                    return newTable;\n+                }\n+            } catch (Throwable e) {\n+                String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+                LOGGER.debug(stackTrace);\n+                throw new CygnusRuntimeError(\"Error creating new persistence Backend. \", e.getClass().getName(),\n+                        e.getMessage());\n+            }\n+        }\n+    } // getPersistenceBackend\n+\n+    /**\n+     * Sets the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @param persistenceBackend\n+     */\n+    protected void setPersistenceBackend(String featureServiceUrl, NGSIArcgisFeatureTable persistenceBackend) {\n+        arcgisPersistenceBackend.put(featureServiceUrl, persistenceBackend);\n+    } // setPersistenceBackend\n+\n+    @Override\n+    public void configure(Context context) {\n+        arcgisServicesUrl = context.getString(\"arcgis_service_url\", DEFAULT_ARCGIS_SERVICE_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_service_url=\" + arcgisServicesUrl + \")\");\n+\n+        getTokenUrl = context.getString(\"arcgis_gettoken_url\", DEFAULT_GETTOKEN_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_fearcgis_gettoken_urlature_table_url=\"\n+                + getTokenUrl + \")\");\n+\n+        userName = context.getString(\"arcgis_username\", DEFAULT_USER_NAME);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_username=\" + userName + \")\");\n+        // FIXME: Password should be read encrypted and decoded here\n+        password = context.getString(\"arcgis_password\", DEFAULT_PASSWORD);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_password=\" + password + \")\");\n+\n+        maxBatchSize = context.getInteger(\"arcgis_maxBatchSize\", DEFAULT_MAX_BATCH_SIZE);\n+        if (maxBatchSize <= 0 || maxBatchSize > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_maxBatchSize=\" + maxBatchSize + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_maxBatchSize=\" + maxBatchSize + \")\");\n+        }\n+\n+        timeoutSecs = context.getInteger(\"arcgis_timeoutSecs\", DEFAULT_BATCH_TIMEOUT_SECS);\n+        if (timeoutSecs <= 0 || timeoutSecs > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_timeoutSecs=\" + timeoutSecs + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_timeoutSecs=\" + maxBatchSize + \")\");\n+        }\n+\n+        super.configure(context);\n+    } // configure\n+\n+    @Override\n+    public void start() {\n+        try {\n+            createPersistenceBackend();\n+            LOGGER.debug(\"[\" + this.getName() + \"] Arcgis persistence backend created\");\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error while creating the Arcgis persistence backend. Details=\" + e.getMessage());\n+        } // try catch\n+\n+        super.start();\n+    } // start\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (arcgisPersistenceBackend != null) {\n+            for (Map.Entry<String, NGSIArcgisFeatureTable> backend : arcgisPersistenceBackend.entrySet()) {\n+                backend.getValue().flushBatch();\n+            }\n+            arcgisPersistenceBackend.clear();\n+        }\n+    } // stop\n+\n+    /**\n+     * Initialices a lazy singleton to share among instances on JVM.\n+     */\n+    private static synchronized void createPersistenceBackend() {\n+        if (arcgisPersistenceBackend == null) {\n+            arcgisPersistenceBackend = new ConcurrentHashMap<String, NGSIArcgisFeatureTable>();\n+        }\n+    }\n+\n+    @Override\n+    void persistBatch(NGSIBatch batch)\n+            throws CygnusBadConfiguration, CygnusPersistenceError, CygnusRuntimeError, CygnusBadContextData {\n+        if (batch == null) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Null batch, nothing to do\");\n+            return;\n+        } // if\n+\n+        try {\n+            // Iterate on the destinations\n+            batch.startIterator();\n+\n+            while (batch.hasNext()) {\n+                String destination = batch.getNextDestination();\n+                LOGGER.debug(\n+                        \"[\" + this.getName() + \"] Processing sub-batch regarding the \" + destination + \" destination\");\n+\n+                // Get the events within the current sub-batch\n+                ArrayList<NGSIEvent> events = batch.getNextEvents();\n+\n+                // Get an aggregator for this destination and initialize it\n+                NGSIArcgisAggregator aggregator = new NGSIArcgisAggregator(getrAcgisServicesUrl(), enableNameMappings);\n+                // aggregator.setService(events.get(0).getServiceForNaming(enableNameMappings));\n+                // aggregator.setServicePathForData(events.get(0).getServicePathForData());\n+                // aggregator.setServicePathForNaming(events.get(0).getServicePathForNaming(enableGrouping,\n+                // enableNameMappings));\n+                // aggregator.setEntityForNaming(events.get(0).getEntityForNaming(enableGrouping, enableNameMappings,\n+                // enableEncoding));\n+                // aggregator.setEntityType(events.get(0).getEntityTypeForNaming(enableGrouping, enableNameMappings));\n+                // aggregator.setAttribute(events.get(0).getAttributeForNaming(enableNameMappings));\n+                // aggregator.setDbName(buildDbName(aggregator.getService()));\n+                // aggregator.setTableName(buildTableName(aggregator.getServicePathForNaming(),\n+                // aggregator.getEntityForNaming(), aggregator.getEntityType(), aggregator.getAttribute()));\n+                // aggregator.setAttrNativeTypes(attrNativeTypes);\n+                // aggregator.setAttrMetadataStore(false);\n+                aggregator.initialize(events.get(0));\n+                for (NGSIEvent event : events) {\n+                    aggregator.aggregate(event);\n+                } // for\n+\n+                // Persist the aggregation\n+                persistAggregation(aggregator);\n+                batch.setNextPersisted(true);\n+\n+            } // while\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistBatch\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see com.telefonica.iot.cygnus.sinks.NGSISink#process()\n+     */\n+    @Override\n+    public Status process() throws EventDeliveryException {\n+        checkTimeouts();\n+        Status status = null;\n+        try {\n+            status = super.process();\n+        } catch (Throwable e) {\n+            LOGGER.error(e.getMessage() + \"Stack trace: \" + Arrays.toString(e.getStackTrace()));\n+        }\n+        return status;\n+    }\n+\n+    /**\n+     * Flush if timeout.\n+     */\n+    protected void checkTimeouts() {\n+        boolean timeoutFound = false;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table.hasTimeout()) {\n+                timeoutFound = true;\n+                LOGGER.info(\"[\" + this.getName() + \"] Feature table Timeout, flushing batch. \" + entry.getKey());\n+                table.flushBatch();\n+            }\n+        }\n+        if (!timeoutFound) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] No Feature table Timeouts found. Features in batch: \"\n+                    + featuresBatched());\n+        }\n+    }\n+\n+    @Override\n+    public void capRecords(NGSIBatch batch, long maxRecords) throws CygnusCappingError {\n+        // no capping\n+        LOGGER.warn(\"[\" + this.getName() + \"] Skipping capping records, just persisting it.\");\n+        try {\n+            persistBatch(batch);\n+        } catch (CygnusBadConfiguration | CygnusPersistenceError | CygnusRuntimeError | CygnusBadContextData e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error capping Records: \" + e);\n+            throw new CygnusCappingError(e.getMessage());\n+        }\n+    } // capRecords\n+\n+    @Override\n+    public void expirateRecords(long expirationTime) throws CygnusExpiratingError {\n+        LOGGER.debug(\"[\" + this.getName() + \"] Expirating records (time=\" + expirationTime + \")\");\n+\n+    } // expirateRecords\n+\n+    /**\n+     * Persist Aggregation.\n+     * \n+     * @param aggregator\n+     * @throws CygnusRuntimeError\n+     */\n+    public void persistAggregation(NGSIArcgisAggregator aggregator) throws CygnusRuntimeError {\n+        try {\n+            List<ArcgisAggregatorDomain> aggregationList = aggregator.getListArcgisAggregatorDomain();\n+            LOGGER.debug(\"[\" + this.getName() + \"] persisting aggregation, \"\n+                    + aggregator.getListArcgisAggregatorDomain().size() + \" features.\");\n+            for (ArcgisAggregatorDomain aggregation : aggregationList) {\n+                String featureTableUrl = aggregation.getFeatureTableUrl();\n+\n+                boolean isNewFeatureTable = !arcgisPersistenceBackend.containsKey(featureTableUrl);\n+                LOGGER.debug(\"[\" + this.getName() + \"] persistAggregation - Feature table: \" + featureTableUrl\n+                        + \" is new: \" + isNewFeatureTable);\n+                ArcgisFeatureTable featureTable = getPersistenceBackend(featureTableUrl);\n+\n+                // If it's a new one, sets uniqueField value\n+                if (isNewFeatureTable) {\n+                    LOGGER.debug(\"[\" + this.getName() + \"] Created new backend for \" + featureTableUrl\n+                            + \" with uniqueField: \" + aggregation.getUniqueField());\n+                    featureTable.setUniqueField(aggregation.getUniqueField());\n+                }\n+\n+                featureTable.addToBatch(aggregation.getFeature());\n+            }\n+        } catch (CygnusRuntimeError e) {\n+            String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+            LOGGER.debug(\" PersistAggregation Error: \" + stackTrace);\n+            throw (e);\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getClass().getSimpleName() + \" - \"\n+                    + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistAggregation\n+\n+    /**\n+     * @author dmartinez\n+     *\n+     */\n+    public class NGSIArcgisAggregator {\n+\n+        private List<ArcgisAggregatorDomain> listArcgisAggregatorDomain = new ArrayList<ArcgisAggregatorDomain>();\n+        private boolean enableNameMappings = true;\n+        private String argisServiceUrl = \"\";\n+\n+        private NGSIArcgisAggregator() {\n+        } // ArcgisAggregator\n+\n+        /**\n+         * Constructor.\n+         * \n+         * @param argisServiceUrl\n+         * @param enableNameMappings\n+         */\n+        public NGSIArcgisAggregator(String argisServiceUrl, boolean enableNameMappings) {\n+            this();\n+            this.enableNameMappings = enableNameMappings;\n+            this.argisServiceUrl = argisServiceUrl;\n+        } // ArcgisAggregator\n+\n+        /**\n+         * \n+         * @param event\n+         */\n+        public void initialize(NGSIEvent event) {\n+        } // initialize\n+\n+        /**\n+         * @return the listArcgisAggregatorDomain\n+         */\n+        public List<ArcgisAggregatorDomain> getListArcgisAggregatorDomain() {\n+            return listArcgisAggregatorDomain;\n+        }\n+\n+        /**\n+         * Determines if input sitring is quoted or not.\n+         * \n+         * @param string\n+         * @return boolean\n+         */\n+\n+        /**\n+         * \n+         * @param event\n+         * @throws CygnusRuntimeError\n+         */\n+        public void aggregate(NGSIEvent event) throws CygnusRuntimeError {\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - ContextElement ->\" + event.getContextElement());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate -  MappedCE ->\" + event.getMappedCE());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - OriginalCE ->\" + event.getOriginalCE());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - enableNameMappings status -> \" + enableNameMappings);\n+\n+            ContextElement contextElement = null;\n+            try {\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - creating new aggregation object.\");\n+                ArcgisAggregatorDomain aggregation = new ArcgisAggregatorDomain(LOGGER);\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - aggregation created\");\n+                Feature feature = aggregation.getFeature();\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Feature getted\");\n+                String service = \"\";\n+                String subService = \"\";\n+                String featureTableUrl = \"\";\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Selecting context\");\n+                // get the contextElement\n+                if (!enableNameMappings) {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - no mappings\");\n+                    contextElement = event.getContextElement();\n+                } else {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - mappings\");\n+                    contextElement = event.getMappedCE();\n+                }\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Selected context ->\" + contextElement);\n+\n+                // get the getRecvTimeTs headers\n+                Map<String, String> headers = event.getHeaders();\n+\n+                for (Entry<String, String> entry : headers.entrySet()) {\n+                    LOGGER.debug(\"Header entry key --> \" + entry.getKey().toString() + \", value --> \"\n+                            + entry.getValue().toString());\n+                    if (entry.getKey() != null\n+                            && NGSIConstants.FLUME_HEADER_MAPPED_SERVICE.equals(entry.getKey().toString())) {\n+                        service = entry.getValue().toString();\n+                    } else if (entry.getKey() != null\n+                            && NGSIConstants.FLUME_HEADER_MAPPED_SERVICE_PATH.equals(entry.getKey().toString())) {\n+                        subService = entry.getValue().toString();\n+                    }\n+                } // for\n+                \n+                // Compose full url\n+                featureTableUrl = argisServiceUrl + \"/\" + service + \"/\" + subService;\n+                featureTableUrl = featureTableUrl.replaceAll(\"([^:])\\\\/\\\\/\", \"$1/\");\n+                aggregation.setFeatureTableUrl(featureTableUrl);\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - featureTableUrl ->\" + featureTableUrl);\n+\n+                // iterate on all this context element attributes, if there are\n+                // attributes\n+                ArrayList<ContextAttribute> contextAttributes = contextElement.getAttributes();\n+\n+                String entityId = contextElement.getId();\n+                String entityType = contextElement.getType();\n+\n+                // Set unique filed and it's value.\n+                aggregation.setUniqueField(entityType);\n+                feature.addAttribute(entityType, entityId);\n+\n+                contextAttrToFeature(feature, contextAttributes);\n+\n+                aggregation.setFeature(feature);\n+                listArcgisAggregatorDomain.add(aggregation);\n+\n+            } catch (JSONException e) {\n+                LOGGER.error(\n+                        \"[NGSIArcgisAggregator] aggregate - Error pharsing JSON BODY \" + contextElement.toString());\n+                throw new CygnusRuntimeError(e.getMessage());\n+            } catch (Exception e) {\n+                LOGGER.error(\"[NGSIArcgisAggregator] aggregate - Unexpected Error\" + e.getMessage()\n+                        + \"\\n contextElement: \" + contextElement.toString());\n+                throw new CygnusRuntimeError(e.getMessage());\n+            }\n+\n+        } // aggregate\n+\n+        /**\n+         * \n+         * @param feature\n+         * @param contextAttributes\n+         */\n+        protected void contextAttrToFeature(Feature feature, ArrayList<ContextAttribute> contextAttributes) {\n+            if (contextAttributes == null || contextAttributes.isEmpty()) {\n+                LOGGER.debug(\n+                        \"[NGSIArcgisAggregator-contextAttrToFeature] contextAttributes NULL or empty, ignoring it. \");\n+            } else {\n+                for (ContextAttribute contextAttribute : contextAttributes) {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator-contextAttrToFeature] Processing Attribute: \"\n+                            + contextAttribute.toString());\n+                    String attrName = contextAttribute.getName();\n+                    String attrType = contextAttribute.getType();\n+                    // get attribute value as is, quoted or not\n+                    JsonElement attrValue = contextAttribute.getValue();\n+\n+                    // TODO crop metadata values\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Atribute (name --> \" + attrName + \", type --> \"\n+                            + attrType + \", value --> \" + attrValue + \", metadata= \" + \"ignored \" + \")\");\n+\n+                    // Get Feature attributes\n+                    LOGGER.debug(\"Proccessing attribute value:  \" + attrName + \" --> \" + attrValue);\n+\n+                    jsonElementToFeatureAttr(attrName, attrType, attrValue, feature);\n+\n+                } // for\n+            } // if else\n+        }\n+    } // NGSIArcgisAggregator\n+\n+    /**\n+     * Extracts Feature attributes from JSON.\n+     * \n+     * @param attrName\n+     * @param attrType\n+     * @param attrValue\n+     * @param feature\n+     */\n+    protected void jsonElementToFeatureAttr(String attrName, String attrType, JsonElement attrValue, Feature feature) {\n+\n+        // Get Feature attributes\n+        LOGGER.debug(\"Proccessing attribute value:  \" + attrName + \" --> \" + attrValue);\n+\n+        attrType = attrType.trim().toLowerCase();\n+\n+        switch (attrType) {\n+\n+            case \"geo:json\":\n+                try {\n+                    JsonObject location = attrValue.getAsJsonObject();\n+                    if (location.get(\"type\").getAsString().equals(\"Point\")) {\n+                        JsonArray coordinates = location.get(\"coordinates\").getAsJsonArray();\n+                        double latitude = coordinates.get(0).getAsDouble();\n+                        double longitude = coordinates.get(1).getAsDouble();\n+\n+                        Point point = new Point(latitude, longitude);\n+                        feature.setGeometry(point);\n+\n+                    } else {\n+                        LOGGER.warn(\"Invalid geo:json type, only points allowed: \" + location.toString());\n+                    }\n+                } catch (Exception e) {\n+                    LOGGER.error(\"Invalid geo:json format, (sikipped): \" + attrValue.toString() + \" - Error: \"\n+                            + e.getMessage());\n+                }\n+                break;\n+            case \"boolean\":\n+                if (attrValue.isJsonPrimitive() && attrValue.getAsJsonPrimitive().isBoolean()) {\n+                    feature.addAttribute(attrName, attrValue.getAsBoolean());\n+                } else {\n+                    String strValue = attrValue.getAsString().toLowerCase().trim();\n+                    boolean result = \"true\".equals(strValue) || \"1\".equals(strValue);\n+                    feature.addAttribute(attrName, result);\n+                }\n+                break;\n+            case \"datetime\":\n+                String dateStr = attrValue.toString();\n+                feature.addAttribute(attrName, parseFiwareDate(dateStr));\n+                break;\n+\n+            default:\n+                // Verify if it is a string (it is into quotation marks)\n+                if (isQuoted(attrValue.toString())) {\n+                    // Insert unquoted\n+                    String strValue = URLDecoder.decode(unquote(attrValue.toString()));\n+                    feature.getAttributes().put(attrName, strValue);\n+                } else {\n+                    try {\n+                        // Try to insert as Integer\n+                        feature.addAttribute(attrName, Integer.parseInt(attrValue.toString()));\n+                    } catch (NumberFormatException e2) {\n+                        try {\n+                            // Try to insert as Double\n+                            feature.addAttribute(attrName, Double.parseDouble(attrValue.toString()));\n+                        } catch (NumberFormatException e3) {\n+                            // If all fails, insert as String\n+                            LOGGER.warn(\n+                                    \"[NGSIArcgisAggregator] Unquoted String attribute: \" + attrName + \":\" + attrValue);\n+                            String strValue = URLDecoder.decode(attrValue.toString());\n+                            feature.addAttribute(attrName, strValue);\n+                        }\n+                    }\n+                }\n+\n+        }\n+\n+    }\n+\n+    /**\n+     * Try to convert Fiware DateTime String to Date object, If it can't, input string will be returned.\n+     * \n+     * @param dateStr\n+     * @return Date Object, or String.\n+     */\n+    private Object parseFiwareDate(String dateStr) {\n+\n+        // Normalize String date\n+        dateStr = unquote(dateStr);\n+        dateStr = dateStr.replaceAll(\"Z[\\\\s]*$\", \"+00:00\");\n+        dateStr = dateStr.replaceAll(\"([+-]{1}[0-9]{1,2})[\\\\s\\\\t\\\\r\\\\n]*$\", \"$1:00\");\n+\n+        DateFormat dateFormatter = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSXXX\");\n+        try {\n+            Date date = dateFormatter.parse(dateStr);\n+            return date;\n+        } catch (ParseException e) {\n+            LOGGER.error(\"[NGSIArcgisAggregator] Unexpected DateTime format: \" + dateStr);\n+            return dateStr;\n+        }\n+    }\n+\n+    /**\n+     * Determines if input sitring is quoted or not.\n+     * \n+     * @param string\n+     * @return boolean\n+     */\n+\n+    private boolean isQuoted(String string) {\n+        return string.matches(\"^[\\\\s]*\\\\\\\"(.*)\\\\\\\"[\\\\s]*$\");\n+    }\n+\n+    /**\n+     * Unquote input string.\n+     * \n+     * @param Unquoted\n+     *            string\n+     * @return\n+     */\n+    private String unquote(String string) {\n+        return string.replaceAll(\"^[\\\\s]*\\\\\\\"(.*)\\\\\\\"[\\\\s]*$\", \"$1\");\n+    }\n+\n+    /**\n+     * \n+     * @author PMO Santander Smart City \u2013 Ayuntamiento de Santander\n+     *\n+     */\n+    public class ArcgisAggregatorDomain {\n+        private CygnusLogger LOGGER = null;\n+\n+        // string containing the data aggregation\n+        private Feature feature;\n+\n+        private String featureTableUrl;\n+\n+        private String uniqueField;\n+\n+        /**\n+           * \n+           */\n+        ArcgisAggregatorDomain(CygnusLogger logger) throws CygnusRuntimeError {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczMTczNA=="}, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 712}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTQ1MzQ0OnYy", "diffSide": "RIGHT", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMToyMTo1MlrOGKkOsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMToyMTo1MlrOGKkOsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczMjUzMQ==", "bodyText": "This would be better as an enum, don't you think?", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r413732531", "createdAt": "2020-04-23T11:21:52Z", "author": {"login": "IvanHdzC"}, "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "diffHunk": "@@ -0,0 +1,789 @@\n+/**\n+ * Copyright 2014-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+\n+package com.telefonica.iot.cygnus.sinks;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.commons.lang.exception.ExceptionUtils;\n+import org.apache.flume.Context;\n+import org.apache.flume.EventDeliveryException;\n+import org.json.JSONException;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Point;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.ArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.NGSIArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextAttribute;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextElement;\n+import com.telefonica.iot.cygnus.errors.CygnusBadConfiguration;\n+import com.telefonica.iot.cygnus.errors.CygnusBadContextData;\n+import com.telefonica.iot.cygnus.errors.CygnusCappingError;\n+import com.telefonica.iot.cygnus.errors.CygnusExpiratingError;\n+import com.telefonica.iot.cygnus.errors.CygnusPersistenceError;\n+import com.telefonica.iot.cygnus.errors.CygnusRuntimeError;\n+import com.telefonica.iot.cygnus.interceptors.NGSIEvent;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+import com.telefonica.iot.cygnus.utils.NGSIConstants;\n+\n+import jodd.util.URLDecoder;\n+\n+/**\n+ *\n+ * @author dmartinez\n+ * \n+ *         Detailed documentation can be found at:\n+ *         https://github.com/telefonicaid/fiware-cygnus/blob/master/doc/flume_extensions_catalogue/ngsi_arcgis_sink.md\n+ */\n+public class NGSIArcgisFeatureTableSink extends NGSISink {\n+\n+    private static final String DEFAULT_ARCGIS_SERVICE_URL = \"localhost\";\n+    private static final String DEFAULT_GETTOKEN_URL = \"localhost\";\n+    private static final String DEFAULT_USER_NAME = \"root\";\n+    private static final String DEFAULT_PASSWORD = \"\";\n+    private static final int DEFAULT_MAX_BATCH_SIZE = 10;\n+    private static final int DEFAULT_BATCH_TIMEOUT_SECS = 60;\n+    private static final String ARCGIS_INSTANCE_NAME = \"arcgis\";\n+\n+    private static final CygnusLogger LOGGER = new CygnusLogger(NGSIArcgisFeatureTableSink.class);\n+    private String arcgisServicesUrl;\n+    private String getTokenUrl;\n+    private String userName;\n+    private String password;\n+    private int maxBatchSize;\n+    private long timeoutSecs;\n+    private static volatile Map<String, NGSIArcgisFeatureTable> arcgisPersistenceBackend;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public NGSIArcgisFeatureTableSink() {\n+        super();\n+    } // NGSIArcgisFeatureTableSink\n+\n+    /**\n+     * Gets the Argis services url. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The services url\n+     */\n+    protected String getrAcgisServicesUrl() {\n+        return arcgisServicesUrl;\n+    } // getrAcgisServicesUrl\n+\n+    /**\n+     * Gets getToken's service url.\n+     * \n+     * @return\n+     */\n+    public String getGetTokenUrl() {\n+        return getTokenUrl;\n+    }\n+\n+    /**\n+     * Sets getToken service url.\n+     * \n+     * @param getTokenUrl\n+     */\n+    public void setGetTokenUrl(String getTokenUrl) {\n+        this.getTokenUrl = getTokenUrl;\n+    }\n+\n+    /**\n+     * Gets the username. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The username\n+     */\n+    protected String getUsername() {\n+        return userName;\n+    } // getUsername\n+\n+    /**\n+     * Gets the password. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The password\n+     */\n+    protected String getPassword() {\n+        return password;\n+    } // getPassword\n+\n+    /**\n+     * \n+     */\n+    protected int featuresBatched() {\n+        int total = 0;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table != null) {\n+                total += table.featuresBatched();\n+            }\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Returns the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The persistence backend\n+     * @throws CygnusRuntimeError\n+     */\n+    protected ArcgisFeatureTable getPersistenceBackend(String featureServiceUrl) throws CygnusRuntimeError {\n+\n+        if (arcgisPersistenceBackend.containsKey(featureServiceUrl)) {\n+            return arcgisPersistenceBackend.get(featureServiceUrl);\n+        } else {\n+            LOGGER.debug(\"Creating new persistenceBackend for Feature table: \" + featureServiceUrl);\n+            LOGGER.debug(\"Token url: \" + getGetTokenUrl());\n+            LOGGER.debug(\"User name: \" + getUsername());\n+            LOGGER.debug(\"Passwd: \" + getPassword());\n+            try {\n+                NGSIArcgisFeatureTable newTable = new NGSIArcgisFeatureTable(featureServiceUrl, getUsername(),\n+                        getPassword(), getGetTokenUrl(), timeoutSecs, LOGGER);\n+                newTable.setBatchAction(ArcgisFeatureTable.ADD_UPDATE_ACTION);\n+                newTable.setBatchSize(maxBatchSize);\n+\n+                if (newTable.hasError()) {\n+                    throw new CygnusRuntimeError(\"[\" + this.getName() + \"Error creating Persistence backend: \"\n+                            + newTable.getErrorCode() + \" - \" + newTable.getErrorDesc());\n+                } else {\n+                    arcgisPersistenceBackend.put(featureServiceUrl, newTable);\n+                    return newTable;\n+                }\n+            } catch (Throwable e) {\n+                String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+                LOGGER.debug(stackTrace);\n+                throw new CygnusRuntimeError(\"Error creating new persistence Backend. \", e.getClass().getName(),\n+                        e.getMessage());\n+            }\n+        }\n+    } // getPersistenceBackend\n+\n+    /**\n+     * Sets the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @param persistenceBackend\n+     */\n+    protected void setPersistenceBackend(String featureServiceUrl, NGSIArcgisFeatureTable persistenceBackend) {\n+        arcgisPersistenceBackend.put(featureServiceUrl, persistenceBackend);\n+    } // setPersistenceBackend\n+\n+    @Override\n+    public void configure(Context context) {\n+        arcgisServicesUrl = context.getString(\"arcgis_service_url\", DEFAULT_ARCGIS_SERVICE_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_service_url=\" + arcgisServicesUrl + \")\");\n+\n+        getTokenUrl = context.getString(\"arcgis_gettoken_url\", DEFAULT_GETTOKEN_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_fearcgis_gettoken_urlature_table_url=\"\n+                + getTokenUrl + \")\");\n+\n+        userName = context.getString(\"arcgis_username\", DEFAULT_USER_NAME);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_username=\" + userName + \")\");\n+        // FIXME: Password should be read encrypted and decoded here\n+        password = context.getString(\"arcgis_password\", DEFAULT_PASSWORD);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_password=\" + password + \")\");\n+\n+        maxBatchSize = context.getInteger(\"arcgis_maxBatchSize\", DEFAULT_MAX_BATCH_SIZE);\n+        if (maxBatchSize <= 0 || maxBatchSize > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_maxBatchSize=\" + maxBatchSize + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_maxBatchSize=\" + maxBatchSize + \")\");\n+        }\n+\n+        timeoutSecs = context.getInteger(\"arcgis_timeoutSecs\", DEFAULT_BATCH_TIMEOUT_SECS);\n+        if (timeoutSecs <= 0 || timeoutSecs > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_timeoutSecs=\" + timeoutSecs + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_timeoutSecs=\" + maxBatchSize + \")\");\n+        }\n+\n+        super.configure(context);\n+    } // configure\n+\n+    @Override\n+    public void start() {\n+        try {\n+            createPersistenceBackend();\n+            LOGGER.debug(\"[\" + this.getName() + \"] Arcgis persistence backend created\");\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error while creating the Arcgis persistence backend. Details=\" + e.getMessage());\n+        } // try catch\n+\n+        super.start();\n+    } // start\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (arcgisPersistenceBackend != null) {\n+            for (Map.Entry<String, NGSIArcgisFeatureTable> backend : arcgisPersistenceBackend.entrySet()) {\n+                backend.getValue().flushBatch();\n+            }\n+            arcgisPersistenceBackend.clear();\n+        }\n+    } // stop\n+\n+    /**\n+     * Initialices a lazy singleton to share among instances on JVM.\n+     */\n+    private static synchronized void createPersistenceBackend() {\n+        if (arcgisPersistenceBackend == null) {\n+            arcgisPersistenceBackend = new ConcurrentHashMap<String, NGSIArcgisFeatureTable>();\n+        }\n+    }\n+\n+    @Override\n+    void persistBatch(NGSIBatch batch)\n+            throws CygnusBadConfiguration, CygnusPersistenceError, CygnusRuntimeError, CygnusBadContextData {\n+        if (batch == null) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Null batch, nothing to do\");\n+            return;\n+        } // if\n+\n+        try {\n+            // Iterate on the destinations\n+            batch.startIterator();\n+\n+            while (batch.hasNext()) {\n+                String destination = batch.getNextDestination();\n+                LOGGER.debug(\n+                        \"[\" + this.getName() + \"] Processing sub-batch regarding the \" + destination + \" destination\");\n+\n+                // Get the events within the current sub-batch\n+                ArrayList<NGSIEvent> events = batch.getNextEvents();\n+\n+                // Get an aggregator for this destination and initialize it\n+                NGSIArcgisAggregator aggregator = new NGSIArcgisAggregator(getrAcgisServicesUrl(), enableNameMappings);\n+                // aggregator.setService(events.get(0).getServiceForNaming(enableNameMappings));\n+                // aggregator.setServicePathForData(events.get(0).getServicePathForData());\n+                // aggregator.setServicePathForNaming(events.get(0).getServicePathForNaming(enableGrouping,\n+                // enableNameMappings));\n+                // aggregator.setEntityForNaming(events.get(0).getEntityForNaming(enableGrouping, enableNameMappings,\n+                // enableEncoding));\n+                // aggregator.setEntityType(events.get(0).getEntityTypeForNaming(enableGrouping, enableNameMappings));\n+                // aggregator.setAttribute(events.get(0).getAttributeForNaming(enableNameMappings));\n+                // aggregator.setDbName(buildDbName(aggregator.getService()));\n+                // aggregator.setTableName(buildTableName(aggregator.getServicePathForNaming(),\n+                // aggregator.getEntityForNaming(), aggregator.getEntityType(), aggregator.getAttribute()));\n+                // aggregator.setAttrNativeTypes(attrNativeTypes);\n+                // aggregator.setAttrMetadataStore(false);\n+                aggregator.initialize(events.get(0));\n+                for (NGSIEvent event : events) {\n+                    aggregator.aggregate(event);\n+                } // for\n+\n+                // Persist the aggregation\n+                persistAggregation(aggregator);\n+                batch.setNextPersisted(true);\n+\n+            } // while\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistBatch\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see com.telefonica.iot.cygnus.sinks.NGSISink#process()\n+     */\n+    @Override\n+    public Status process() throws EventDeliveryException {\n+        checkTimeouts();\n+        Status status = null;\n+        try {\n+            status = super.process();\n+        } catch (Throwable e) {\n+            LOGGER.error(e.getMessage() + \"Stack trace: \" + Arrays.toString(e.getStackTrace()));\n+        }\n+        return status;\n+    }\n+\n+    /**\n+     * Flush if timeout.\n+     */\n+    protected void checkTimeouts() {\n+        boolean timeoutFound = false;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table.hasTimeout()) {\n+                timeoutFound = true;\n+                LOGGER.info(\"[\" + this.getName() + \"] Feature table Timeout, flushing batch. \" + entry.getKey());\n+                table.flushBatch();\n+            }\n+        }\n+        if (!timeoutFound) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] No Feature table Timeouts found. Features in batch: \"\n+                    + featuresBatched());\n+        }\n+    }\n+\n+    @Override\n+    public void capRecords(NGSIBatch batch, long maxRecords) throws CygnusCappingError {\n+        // no capping\n+        LOGGER.warn(\"[\" + this.getName() + \"] Skipping capping records, just persisting it.\");\n+        try {\n+            persistBatch(batch);\n+        } catch (CygnusBadConfiguration | CygnusPersistenceError | CygnusRuntimeError | CygnusBadContextData e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error capping Records: \" + e);\n+            throw new CygnusCappingError(e.getMessage());\n+        }\n+    } // capRecords\n+\n+    @Override\n+    public void expirateRecords(long expirationTime) throws CygnusExpiratingError {\n+        LOGGER.debug(\"[\" + this.getName() + \"] Expirating records (time=\" + expirationTime + \")\");\n+\n+    } // expirateRecords\n+\n+    /**\n+     * Persist Aggregation.\n+     * \n+     * @param aggregator\n+     * @throws CygnusRuntimeError\n+     */\n+    public void persistAggregation(NGSIArcgisAggregator aggregator) throws CygnusRuntimeError {\n+        try {\n+            List<ArcgisAggregatorDomain> aggregationList = aggregator.getListArcgisAggregatorDomain();\n+            LOGGER.debug(\"[\" + this.getName() + \"] persisting aggregation, \"\n+                    + aggregator.getListArcgisAggregatorDomain().size() + \" features.\");\n+            for (ArcgisAggregatorDomain aggregation : aggregationList) {\n+                String featureTableUrl = aggregation.getFeatureTableUrl();\n+\n+                boolean isNewFeatureTable = !arcgisPersistenceBackend.containsKey(featureTableUrl);\n+                LOGGER.debug(\"[\" + this.getName() + \"] persistAggregation - Feature table: \" + featureTableUrl\n+                        + \" is new: \" + isNewFeatureTable);\n+                ArcgisFeatureTable featureTable = getPersistenceBackend(featureTableUrl);\n+\n+                // If it's a new one, sets uniqueField value\n+                if (isNewFeatureTable) {\n+                    LOGGER.debug(\"[\" + this.getName() + \"] Created new backend for \" + featureTableUrl\n+                            + \" with uniqueField: \" + aggregation.getUniqueField());\n+                    featureTable.setUniqueField(aggregation.getUniqueField());\n+                }\n+\n+                featureTable.addToBatch(aggregation.getFeature());\n+            }\n+        } catch (CygnusRuntimeError e) {\n+            String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+            LOGGER.debug(\" PersistAggregation Error: \" + stackTrace);\n+            throw (e);\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getClass().getSimpleName() + \" - \"\n+                    + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistAggregation\n+\n+    /**\n+     * @author dmartinez\n+     *\n+     */\n+    public class NGSIArcgisAggregator {\n+\n+        private List<ArcgisAggregatorDomain> listArcgisAggregatorDomain = new ArrayList<ArcgisAggregatorDomain>();\n+        private boolean enableNameMappings = true;\n+        private String argisServiceUrl = \"\";\n+\n+        private NGSIArcgisAggregator() {\n+        } // ArcgisAggregator\n+\n+        /**\n+         * Constructor.\n+         * \n+         * @param argisServiceUrl\n+         * @param enableNameMappings\n+         */\n+        public NGSIArcgisAggregator(String argisServiceUrl, boolean enableNameMappings) {\n+            this();\n+            this.enableNameMappings = enableNameMappings;\n+            this.argisServiceUrl = argisServiceUrl;\n+        } // ArcgisAggregator\n+\n+        /**\n+         * \n+         * @param event\n+         */\n+        public void initialize(NGSIEvent event) {\n+        } // initialize\n+\n+        /**\n+         * @return the listArcgisAggregatorDomain\n+         */\n+        public List<ArcgisAggregatorDomain> getListArcgisAggregatorDomain() {\n+            return listArcgisAggregatorDomain;\n+        }\n+\n+        /**\n+         * Determines if input sitring is quoted or not.\n+         * \n+         * @param string\n+         * @return boolean\n+         */\n+\n+        /**\n+         * \n+         * @param event\n+         * @throws CygnusRuntimeError\n+         */\n+        public void aggregate(NGSIEvent event) throws CygnusRuntimeError {\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - ContextElement ->\" + event.getContextElement());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate -  MappedCE ->\" + event.getMappedCE());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - OriginalCE ->\" + event.getOriginalCE());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - enableNameMappings status -> \" + enableNameMappings);\n+\n+            ContextElement contextElement = null;\n+            try {\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - creating new aggregation object.\");\n+                ArcgisAggregatorDomain aggregation = new ArcgisAggregatorDomain(LOGGER);\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - aggregation created\");\n+                Feature feature = aggregation.getFeature();\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Feature getted\");\n+                String service = \"\";\n+                String subService = \"\";\n+                String featureTableUrl = \"\";\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Selecting context\");\n+                // get the contextElement\n+                if (!enableNameMappings) {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - no mappings\");\n+                    contextElement = event.getContextElement();\n+                } else {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - mappings\");\n+                    contextElement = event.getMappedCE();\n+                }\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Selected context ->\" + contextElement);\n+\n+                // get the getRecvTimeTs headers\n+                Map<String, String> headers = event.getHeaders();\n+\n+                for (Entry<String, String> entry : headers.entrySet()) {\n+                    LOGGER.debug(\"Header entry key --> \" + entry.getKey().toString() + \", value --> \"\n+                            + entry.getValue().toString());\n+                    if (entry.getKey() != null\n+                            && NGSIConstants.FLUME_HEADER_MAPPED_SERVICE.equals(entry.getKey().toString())) {\n+                        service = entry.getValue().toString();\n+                    } else if (entry.getKey() != null\n+                            && NGSIConstants.FLUME_HEADER_MAPPED_SERVICE_PATH.equals(entry.getKey().toString())) {\n+                        subService = entry.getValue().toString();\n+                    }\n+                } // for\n+                \n+                // Compose full url\n+                featureTableUrl = argisServiceUrl + \"/\" + service + \"/\" + subService;\n+                featureTableUrl = featureTableUrl.replaceAll(\"([^:])\\\\/\\\\/\", \"$1/\");\n+                aggregation.setFeatureTableUrl(featureTableUrl);\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - featureTableUrl ->\" + featureTableUrl);\n+\n+                // iterate on all this context element attributes, if there are\n+                // attributes\n+                ArrayList<ContextAttribute> contextAttributes = contextElement.getAttributes();\n+\n+                String entityId = contextElement.getId();\n+                String entityType = contextElement.getType();\n+\n+                // Set unique filed and it's value.\n+                aggregation.setUniqueField(entityType);\n+                feature.addAttribute(entityType, entityId);\n+\n+                contextAttrToFeature(feature, contextAttributes);\n+\n+                aggregation.setFeature(feature);\n+                listArcgisAggregatorDomain.add(aggregation);\n+\n+            } catch (JSONException e) {\n+                LOGGER.error(\n+                        \"[NGSIArcgisAggregator] aggregate - Error pharsing JSON BODY \" + contextElement.toString());\n+                throw new CygnusRuntimeError(e.getMessage());\n+            } catch (Exception e) {\n+                LOGGER.error(\"[NGSIArcgisAggregator] aggregate - Unexpected Error\" + e.getMessage()\n+                        + \"\\n contextElement: \" + contextElement.toString());\n+                throw new CygnusRuntimeError(e.getMessage());\n+            }\n+\n+        } // aggregate\n+\n+        /**\n+         * \n+         * @param feature\n+         * @param contextAttributes\n+         */\n+        protected void contextAttrToFeature(Feature feature, ArrayList<ContextAttribute> contextAttributes) {\n+            if (contextAttributes == null || contextAttributes.isEmpty()) {\n+                LOGGER.debug(\n+                        \"[NGSIArcgisAggregator-contextAttrToFeature] contextAttributes NULL or empty, ignoring it. \");\n+            } else {\n+                for (ContextAttribute contextAttribute : contextAttributes) {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator-contextAttrToFeature] Processing Attribute: \"\n+                            + contextAttribute.toString());\n+                    String attrName = contextAttribute.getName();\n+                    String attrType = contextAttribute.getType();\n+                    // get attribute value as is, quoted or not\n+                    JsonElement attrValue = contextAttribute.getValue();\n+\n+                    // TODO crop metadata values\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Atribute (name --> \" + attrName + \", type --> \"\n+                            + attrType + \", value --> \" + attrValue + \", metadata= \" + \"ignored \" + \")\");\n+\n+                    // Get Feature attributes\n+                    LOGGER.debug(\"Proccessing attribute value:  \" + attrName + \" --> \" + attrValue);\n+\n+                    jsonElementToFeatureAttr(attrName, attrType, attrValue, feature);\n+\n+                } // for\n+            } // if else\n+        }\n+    } // NGSIArcgisAggregator\n+\n+    /**\n+     * Extracts Feature attributes from JSON.\n+     * \n+     * @param attrName\n+     * @param attrType\n+     * @param attrValue\n+     * @param feature\n+     */\n+    protected void jsonElementToFeatureAttr(String attrName, String attrType, JsonElement attrValue, Feature feature) {\n+\n+        // Get Feature attributes\n+        LOGGER.debug(\"Proccessing attribute value:  \" + attrName + \" --> \" + attrValue);\n+\n+        attrType = attrType.trim().toLowerCase();\n+\n+        switch (attrType) {\n+\n+            case \"geo:json\":\n+                try {\n+                    JsonObject location = attrValue.getAsJsonObject();\n+                    if (location.get(\"type\").getAsString().equals(\"Point\")) {\n+                        JsonArray coordinates = location.get(\"coordinates\").getAsJsonArray();\n+                        double latitude = coordinates.get(0).getAsDouble();\n+                        double longitude = coordinates.get(1).getAsDouble();\n+\n+                        Point point = new Point(latitude, longitude);\n+                        feature.setGeometry(point);\n+\n+                    } else {\n+                        LOGGER.warn(\"Invalid geo:json type, only points allowed: \" + location.toString());\n+                    }\n+                } catch (Exception e) {\n+                    LOGGER.error(\"Invalid geo:json format, (sikipped): \" + attrValue.toString() + \" - Error: \"\n+                            + e.getMessage());\n+                }\n+                break;\n+            case \"boolean\":", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 607}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTUxMjQ4OnYy", "diffSide": "RIGHT", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMTozNzowNFrOGKkw1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwOToyNzoxMVrOGLO4KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc0MTI3MQ==", "bodyText": "This seems to be kind of tricky. Maybe this will be throwing a lot of exceptions and it would affect the performance.\nThis also applies for Feature class attToMap method.\nCan this be done using native gson validations?\n                if (attrValue.isJsonPrimitive()){\n                    if (attrValue.getAsJsonPrimitive().isNumber()))\n                    try {\n                        feature.addAttribute(attrName, attrValue.getAsInt());\n                    }\n\n                ...", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r413741271", "createdAt": "2020-04-23T11:37:04Z", "author": {"login": "IvanHdzC"}, "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "diffHunk": "@@ -0,0 +1,789 @@\n+/**\n+ * Copyright 2014-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+\n+package com.telefonica.iot.cygnus.sinks;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.commons.lang.exception.ExceptionUtils;\n+import org.apache.flume.Context;\n+import org.apache.flume.EventDeliveryException;\n+import org.json.JSONException;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Point;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.ArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.NGSIArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextAttribute;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextElement;\n+import com.telefonica.iot.cygnus.errors.CygnusBadConfiguration;\n+import com.telefonica.iot.cygnus.errors.CygnusBadContextData;\n+import com.telefonica.iot.cygnus.errors.CygnusCappingError;\n+import com.telefonica.iot.cygnus.errors.CygnusExpiratingError;\n+import com.telefonica.iot.cygnus.errors.CygnusPersistenceError;\n+import com.telefonica.iot.cygnus.errors.CygnusRuntimeError;\n+import com.telefonica.iot.cygnus.interceptors.NGSIEvent;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+import com.telefonica.iot.cygnus.utils.NGSIConstants;\n+\n+import jodd.util.URLDecoder;\n+\n+/**\n+ *\n+ * @author dmartinez\n+ * \n+ *         Detailed documentation can be found at:\n+ *         https://github.com/telefonicaid/fiware-cygnus/blob/master/doc/flume_extensions_catalogue/ngsi_arcgis_sink.md\n+ */\n+public class NGSIArcgisFeatureTableSink extends NGSISink {\n+\n+    private static final String DEFAULT_ARCGIS_SERVICE_URL = \"localhost\";\n+    private static final String DEFAULT_GETTOKEN_URL = \"localhost\";\n+    private static final String DEFAULT_USER_NAME = \"root\";\n+    private static final String DEFAULT_PASSWORD = \"\";\n+    private static final int DEFAULT_MAX_BATCH_SIZE = 10;\n+    private static final int DEFAULT_BATCH_TIMEOUT_SECS = 60;\n+    private static final String ARCGIS_INSTANCE_NAME = \"arcgis\";\n+\n+    private static final CygnusLogger LOGGER = new CygnusLogger(NGSIArcgisFeatureTableSink.class);\n+    private String arcgisServicesUrl;\n+    private String getTokenUrl;\n+    private String userName;\n+    private String password;\n+    private int maxBatchSize;\n+    private long timeoutSecs;\n+    private static volatile Map<String, NGSIArcgisFeatureTable> arcgisPersistenceBackend;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public NGSIArcgisFeatureTableSink() {\n+        super();\n+    } // NGSIArcgisFeatureTableSink\n+\n+    /**\n+     * Gets the Argis services url. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The services url\n+     */\n+    protected String getrAcgisServicesUrl() {\n+        return arcgisServicesUrl;\n+    } // getrAcgisServicesUrl\n+\n+    /**\n+     * Gets getToken's service url.\n+     * \n+     * @return\n+     */\n+    public String getGetTokenUrl() {\n+        return getTokenUrl;\n+    }\n+\n+    /**\n+     * Sets getToken service url.\n+     * \n+     * @param getTokenUrl\n+     */\n+    public void setGetTokenUrl(String getTokenUrl) {\n+        this.getTokenUrl = getTokenUrl;\n+    }\n+\n+    /**\n+     * Gets the username. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The username\n+     */\n+    protected String getUsername() {\n+        return userName;\n+    } // getUsername\n+\n+    /**\n+     * Gets the password. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The password\n+     */\n+    protected String getPassword() {\n+        return password;\n+    } // getPassword\n+\n+    /**\n+     * \n+     */\n+    protected int featuresBatched() {\n+        int total = 0;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table != null) {\n+                total += table.featuresBatched();\n+            }\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Returns the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The persistence backend\n+     * @throws CygnusRuntimeError\n+     */\n+    protected ArcgisFeatureTable getPersistenceBackend(String featureServiceUrl) throws CygnusRuntimeError {\n+\n+        if (arcgisPersistenceBackend.containsKey(featureServiceUrl)) {\n+            return arcgisPersistenceBackend.get(featureServiceUrl);\n+        } else {\n+            LOGGER.debug(\"Creating new persistenceBackend for Feature table: \" + featureServiceUrl);\n+            LOGGER.debug(\"Token url: \" + getGetTokenUrl());\n+            LOGGER.debug(\"User name: \" + getUsername());\n+            LOGGER.debug(\"Passwd: \" + getPassword());\n+            try {\n+                NGSIArcgisFeatureTable newTable = new NGSIArcgisFeatureTable(featureServiceUrl, getUsername(),\n+                        getPassword(), getGetTokenUrl(), timeoutSecs, LOGGER);\n+                newTable.setBatchAction(ArcgisFeatureTable.ADD_UPDATE_ACTION);\n+                newTable.setBatchSize(maxBatchSize);\n+\n+                if (newTable.hasError()) {\n+                    throw new CygnusRuntimeError(\"[\" + this.getName() + \"Error creating Persistence backend: \"\n+                            + newTable.getErrorCode() + \" - \" + newTable.getErrorDesc());\n+                } else {\n+                    arcgisPersistenceBackend.put(featureServiceUrl, newTable);\n+                    return newTable;\n+                }\n+            } catch (Throwable e) {\n+                String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+                LOGGER.debug(stackTrace);\n+                throw new CygnusRuntimeError(\"Error creating new persistence Backend. \", e.getClass().getName(),\n+                        e.getMessage());\n+            }\n+        }\n+    } // getPersistenceBackend\n+\n+    /**\n+     * Sets the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @param persistenceBackend\n+     */\n+    protected void setPersistenceBackend(String featureServiceUrl, NGSIArcgisFeatureTable persistenceBackend) {\n+        arcgisPersistenceBackend.put(featureServiceUrl, persistenceBackend);\n+    } // setPersistenceBackend\n+\n+    @Override\n+    public void configure(Context context) {\n+        arcgisServicesUrl = context.getString(\"arcgis_service_url\", DEFAULT_ARCGIS_SERVICE_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_service_url=\" + arcgisServicesUrl + \")\");\n+\n+        getTokenUrl = context.getString(\"arcgis_gettoken_url\", DEFAULT_GETTOKEN_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_fearcgis_gettoken_urlature_table_url=\"\n+                + getTokenUrl + \")\");\n+\n+        userName = context.getString(\"arcgis_username\", DEFAULT_USER_NAME);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_username=\" + userName + \")\");\n+        // FIXME: Password should be read encrypted and decoded here\n+        password = context.getString(\"arcgis_password\", DEFAULT_PASSWORD);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_password=\" + password + \")\");\n+\n+        maxBatchSize = context.getInteger(\"arcgis_maxBatchSize\", DEFAULT_MAX_BATCH_SIZE);\n+        if (maxBatchSize <= 0 || maxBatchSize > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_maxBatchSize=\" + maxBatchSize + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_maxBatchSize=\" + maxBatchSize + \")\");\n+        }\n+\n+        timeoutSecs = context.getInteger(\"arcgis_timeoutSecs\", DEFAULT_BATCH_TIMEOUT_SECS);\n+        if (timeoutSecs <= 0 || timeoutSecs > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_timeoutSecs=\" + timeoutSecs + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_timeoutSecs=\" + maxBatchSize + \")\");\n+        }\n+\n+        super.configure(context);\n+    } // configure\n+\n+    @Override\n+    public void start() {\n+        try {\n+            createPersistenceBackend();\n+            LOGGER.debug(\"[\" + this.getName() + \"] Arcgis persistence backend created\");\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error while creating the Arcgis persistence backend. Details=\" + e.getMessage());\n+        } // try catch\n+\n+        super.start();\n+    } // start\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (arcgisPersistenceBackend != null) {\n+            for (Map.Entry<String, NGSIArcgisFeatureTable> backend : arcgisPersistenceBackend.entrySet()) {\n+                backend.getValue().flushBatch();\n+            }\n+            arcgisPersistenceBackend.clear();\n+        }\n+    } // stop\n+\n+    /**\n+     * Initialices a lazy singleton to share among instances on JVM.\n+     */\n+    private static synchronized void createPersistenceBackend() {\n+        if (arcgisPersistenceBackend == null) {\n+            arcgisPersistenceBackend = new ConcurrentHashMap<String, NGSIArcgisFeatureTable>();\n+        }\n+    }\n+\n+    @Override\n+    void persistBatch(NGSIBatch batch)\n+            throws CygnusBadConfiguration, CygnusPersistenceError, CygnusRuntimeError, CygnusBadContextData {\n+        if (batch == null) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Null batch, nothing to do\");\n+            return;\n+        } // if\n+\n+        try {\n+            // Iterate on the destinations\n+            batch.startIterator();\n+\n+            while (batch.hasNext()) {\n+                String destination = batch.getNextDestination();\n+                LOGGER.debug(\n+                        \"[\" + this.getName() + \"] Processing sub-batch regarding the \" + destination + \" destination\");\n+\n+                // Get the events within the current sub-batch\n+                ArrayList<NGSIEvent> events = batch.getNextEvents();\n+\n+                // Get an aggregator for this destination and initialize it\n+                NGSIArcgisAggregator aggregator = new NGSIArcgisAggregator(getrAcgisServicesUrl(), enableNameMappings);\n+                // aggregator.setService(events.get(0).getServiceForNaming(enableNameMappings));\n+                // aggregator.setServicePathForData(events.get(0).getServicePathForData());\n+                // aggregator.setServicePathForNaming(events.get(0).getServicePathForNaming(enableGrouping,\n+                // enableNameMappings));\n+                // aggregator.setEntityForNaming(events.get(0).getEntityForNaming(enableGrouping, enableNameMappings,\n+                // enableEncoding));\n+                // aggregator.setEntityType(events.get(0).getEntityTypeForNaming(enableGrouping, enableNameMappings));\n+                // aggregator.setAttribute(events.get(0).getAttributeForNaming(enableNameMappings));\n+                // aggregator.setDbName(buildDbName(aggregator.getService()));\n+                // aggregator.setTableName(buildTableName(aggregator.getServicePathForNaming(),\n+                // aggregator.getEntityForNaming(), aggregator.getEntityType(), aggregator.getAttribute()));\n+                // aggregator.setAttrNativeTypes(attrNativeTypes);\n+                // aggregator.setAttrMetadataStore(false);\n+                aggregator.initialize(events.get(0));\n+                for (NGSIEvent event : events) {\n+                    aggregator.aggregate(event);\n+                } // for\n+\n+                // Persist the aggregation\n+                persistAggregation(aggregator);\n+                batch.setNextPersisted(true);\n+\n+            } // while\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistBatch\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see com.telefonica.iot.cygnus.sinks.NGSISink#process()\n+     */\n+    @Override\n+    public Status process() throws EventDeliveryException {\n+        checkTimeouts();\n+        Status status = null;\n+        try {\n+            status = super.process();\n+        } catch (Throwable e) {\n+            LOGGER.error(e.getMessage() + \"Stack trace: \" + Arrays.toString(e.getStackTrace()));\n+        }\n+        return status;\n+    }\n+\n+    /**\n+     * Flush if timeout.\n+     */\n+    protected void checkTimeouts() {\n+        boolean timeoutFound = false;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table.hasTimeout()) {\n+                timeoutFound = true;\n+                LOGGER.info(\"[\" + this.getName() + \"] Feature table Timeout, flushing batch. \" + entry.getKey());\n+                table.flushBatch();\n+            }\n+        }\n+        if (!timeoutFound) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] No Feature table Timeouts found. Features in batch: \"\n+                    + featuresBatched());\n+        }\n+    }\n+\n+    @Override\n+    public void capRecords(NGSIBatch batch, long maxRecords) throws CygnusCappingError {\n+        // no capping\n+        LOGGER.warn(\"[\" + this.getName() + \"] Skipping capping records, just persisting it.\");\n+        try {\n+            persistBatch(batch);\n+        } catch (CygnusBadConfiguration | CygnusPersistenceError | CygnusRuntimeError | CygnusBadContextData e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error capping Records: \" + e);\n+            throw new CygnusCappingError(e.getMessage());\n+        }\n+    } // capRecords\n+\n+    @Override\n+    public void expirateRecords(long expirationTime) throws CygnusExpiratingError {\n+        LOGGER.debug(\"[\" + this.getName() + \"] Expirating records (time=\" + expirationTime + \")\");\n+\n+    } // expirateRecords\n+\n+    /**\n+     * Persist Aggregation.\n+     * \n+     * @param aggregator\n+     * @throws CygnusRuntimeError\n+     */\n+    public void persistAggregation(NGSIArcgisAggregator aggregator) throws CygnusRuntimeError {\n+        try {\n+            List<ArcgisAggregatorDomain> aggregationList = aggregator.getListArcgisAggregatorDomain();\n+            LOGGER.debug(\"[\" + this.getName() + \"] persisting aggregation, \"\n+                    + aggregator.getListArcgisAggregatorDomain().size() + \" features.\");\n+            for (ArcgisAggregatorDomain aggregation : aggregationList) {\n+                String featureTableUrl = aggregation.getFeatureTableUrl();\n+\n+                boolean isNewFeatureTable = !arcgisPersistenceBackend.containsKey(featureTableUrl);\n+                LOGGER.debug(\"[\" + this.getName() + \"] persistAggregation - Feature table: \" + featureTableUrl\n+                        + \" is new: \" + isNewFeatureTable);\n+                ArcgisFeatureTable featureTable = getPersistenceBackend(featureTableUrl);\n+\n+                // If it's a new one, sets uniqueField value\n+                if (isNewFeatureTable) {\n+                    LOGGER.debug(\"[\" + this.getName() + \"] Created new backend for \" + featureTableUrl\n+                            + \" with uniqueField: \" + aggregation.getUniqueField());\n+                    featureTable.setUniqueField(aggregation.getUniqueField());\n+                }\n+\n+                featureTable.addToBatch(aggregation.getFeature());\n+            }\n+        } catch (CygnusRuntimeError e) {\n+            String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+            LOGGER.debug(\" PersistAggregation Error: \" + stackTrace);\n+            throw (e);\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getClass().getSimpleName() + \" - \"\n+                    + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistAggregation\n+\n+    /**\n+     * @author dmartinez\n+     *\n+     */\n+    public class NGSIArcgisAggregator {\n+\n+        private List<ArcgisAggregatorDomain> listArcgisAggregatorDomain = new ArrayList<ArcgisAggregatorDomain>();\n+        private boolean enableNameMappings = true;\n+        private String argisServiceUrl = \"\";\n+\n+        private NGSIArcgisAggregator() {\n+        } // ArcgisAggregator\n+\n+        /**\n+         * Constructor.\n+         * \n+         * @param argisServiceUrl\n+         * @param enableNameMappings\n+         */\n+        public NGSIArcgisAggregator(String argisServiceUrl, boolean enableNameMappings) {\n+            this();\n+            this.enableNameMappings = enableNameMappings;\n+            this.argisServiceUrl = argisServiceUrl;\n+        } // ArcgisAggregator\n+\n+        /**\n+         * \n+         * @param event\n+         */\n+        public void initialize(NGSIEvent event) {\n+        } // initialize\n+\n+        /**\n+         * @return the listArcgisAggregatorDomain\n+         */\n+        public List<ArcgisAggregatorDomain> getListArcgisAggregatorDomain() {\n+            return listArcgisAggregatorDomain;\n+        }\n+\n+        /**\n+         * Determines if input sitring is quoted or not.\n+         * \n+         * @param string\n+         * @return boolean\n+         */\n+\n+        /**\n+         * \n+         * @param event\n+         * @throws CygnusRuntimeError\n+         */\n+        public void aggregate(NGSIEvent event) throws CygnusRuntimeError {\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - ContextElement ->\" + event.getContextElement());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate -  MappedCE ->\" + event.getMappedCE());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - OriginalCE ->\" + event.getOriginalCE());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - enableNameMappings status -> \" + enableNameMappings);\n+\n+            ContextElement contextElement = null;\n+            try {\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - creating new aggregation object.\");\n+                ArcgisAggregatorDomain aggregation = new ArcgisAggregatorDomain(LOGGER);\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - aggregation created\");\n+                Feature feature = aggregation.getFeature();\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Feature getted\");\n+                String service = \"\";\n+                String subService = \"\";\n+                String featureTableUrl = \"\";\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Selecting context\");\n+                // get the contextElement\n+                if (!enableNameMappings) {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - no mappings\");\n+                    contextElement = event.getContextElement();\n+                } else {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - mappings\");\n+                    contextElement = event.getMappedCE();\n+                }\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Selected context ->\" + contextElement);\n+\n+                // get the getRecvTimeTs headers\n+                Map<String, String> headers = event.getHeaders();\n+\n+                for (Entry<String, String> entry : headers.entrySet()) {\n+                    LOGGER.debug(\"Header entry key --> \" + entry.getKey().toString() + \", value --> \"\n+                            + entry.getValue().toString());\n+                    if (entry.getKey() != null\n+                            && NGSIConstants.FLUME_HEADER_MAPPED_SERVICE.equals(entry.getKey().toString())) {\n+                        service = entry.getValue().toString();\n+                    } else if (entry.getKey() != null\n+                            && NGSIConstants.FLUME_HEADER_MAPPED_SERVICE_PATH.equals(entry.getKey().toString())) {\n+                        subService = entry.getValue().toString();\n+                    }\n+                } // for\n+                \n+                // Compose full url\n+                featureTableUrl = argisServiceUrl + \"/\" + service + \"/\" + subService;\n+                featureTableUrl = featureTableUrl.replaceAll(\"([^:])\\\\/\\\\/\", \"$1/\");\n+                aggregation.setFeatureTableUrl(featureTableUrl);\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - featureTableUrl ->\" + featureTableUrl);\n+\n+                // iterate on all this context element attributes, if there are\n+                // attributes\n+                ArrayList<ContextAttribute> contextAttributes = contextElement.getAttributes();\n+\n+                String entityId = contextElement.getId();\n+                String entityType = contextElement.getType();\n+\n+                // Set unique filed and it's value.\n+                aggregation.setUniqueField(entityType);\n+                feature.addAttribute(entityType, entityId);\n+\n+                contextAttrToFeature(feature, contextAttributes);\n+\n+                aggregation.setFeature(feature);\n+                listArcgisAggregatorDomain.add(aggregation);\n+\n+            } catch (JSONException e) {\n+                LOGGER.error(\n+                        \"[NGSIArcgisAggregator] aggregate - Error pharsing JSON BODY \" + contextElement.toString());\n+                throw new CygnusRuntimeError(e.getMessage());\n+            } catch (Exception e) {\n+                LOGGER.error(\"[NGSIArcgisAggregator] aggregate - Unexpected Error\" + e.getMessage()\n+                        + \"\\n contextElement: \" + contextElement.toString());\n+                throw new CygnusRuntimeError(e.getMessage());\n+            }\n+\n+        } // aggregate\n+\n+        /**\n+         * \n+         * @param feature\n+         * @param contextAttributes\n+         */\n+        protected void contextAttrToFeature(Feature feature, ArrayList<ContextAttribute> contextAttributes) {\n+            if (contextAttributes == null || contextAttributes.isEmpty()) {\n+                LOGGER.debug(\n+                        \"[NGSIArcgisAggregator-contextAttrToFeature] contextAttributes NULL or empty, ignoring it. \");\n+            } else {\n+                for (ContextAttribute contextAttribute : contextAttributes) {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator-contextAttrToFeature] Processing Attribute: \"\n+                            + contextAttribute.toString());\n+                    String attrName = contextAttribute.getName();\n+                    String attrType = contextAttribute.getType();\n+                    // get attribute value as is, quoted or not\n+                    JsonElement attrValue = contextAttribute.getValue();\n+\n+                    // TODO crop metadata values\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Atribute (name --> \" + attrName + \", type --> \"\n+                            + attrType + \", value --> \" + attrValue + \", metadata= \" + \"ignored \" + \")\");\n+\n+                    // Get Feature attributes\n+                    LOGGER.debug(\"Proccessing attribute value:  \" + attrName + \" --> \" + attrValue);\n+\n+                    jsonElementToFeatureAttr(attrName, attrType, attrValue, feature);\n+\n+                } // for\n+            } // if else\n+        }\n+    } // NGSIArcgisAggregator\n+\n+    /**\n+     * Extracts Feature attributes from JSON.\n+     * \n+     * @param attrName\n+     * @param attrType\n+     * @param attrValue\n+     * @param feature\n+     */\n+    protected void jsonElementToFeatureAttr(String attrName, String attrType, JsonElement attrValue, Feature feature) {\n+\n+        // Get Feature attributes\n+        LOGGER.debug(\"Proccessing attribute value:  \" + attrName + \" --> \" + attrValue);\n+\n+        attrType = attrType.trim().toLowerCase();\n+\n+        switch (attrType) {\n+\n+            case \"geo:json\":\n+                try {\n+                    JsonObject location = attrValue.getAsJsonObject();\n+                    if (location.get(\"type\").getAsString().equals(\"Point\")) {\n+                        JsonArray coordinates = location.get(\"coordinates\").getAsJsonArray();\n+                        double latitude = coordinates.get(0).getAsDouble();\n+                        double longitude = coordinates.get(1).getAsDouble();\n+\n+                        Point point = new Point(latitude, longitude);\n+                        feature.setGeometry(point);\n+\n+                    } else {\n+                        LOGGER.warn(\"Invalid geo:json type, only points allowed: \" + location.toString());\n+                    }\n+                } catch (Exception e) {\n+                    LOGGER.error(\"Invalid geo:json format, (sikipped): \" + attrValue.toString() + \" - Error: \"\n+                            + e.getMessage());\n+                }\n+                break;\n+            case \"boolean\":\n+                if (attrValue.isJsonPrimitive() && attrValue.getAsJsonPrimitive().isBoolean()) {\n+                    feature.addAttribute(attrName, attrValue.getAsBoolean());\n+                } else {\n+                    String strValue = attrValue.getAsString().toLowerCase().trim();\n+                    boolean result = \"true\".equals(strValue) || \"1\".equals(strValue);\n+                    feature.addAttribute(attrName, result);\n+                }\n+                break;\n+            case \"datetime\":\n+                String dateStr = attrValue.toString();\n+                feature.addAttribute(attrName, parseFiwareDate(dateStr));\n+                break;\n+\n+            default:\n+                // Verify if it is a string (it is into quotation marks)\n+                if (isQuoted(attrValue.toString())) {\n+                    // Insert unquoted\n+                    String strValue = URLDecoder.decode(unquote(attrValue.toString()));\n+                    feature.getAttributes().put(attrName, strValue);\n+                } else {\n+                    try {\n+                        // Try to insert as Integer\n+                        feature.addAttribute(attrName, Integer.parseInt(attrValue.toString()));\n+                    } catch (NumberFormatException e2) {\n+                        try {\n+                            // Try to insert as Double\n+                            feature.addAttribute(attrName, Double.parseDouble(attrValue.toString()));\n+                        } catch (NumberFormatException e3) {\n+                            // If all fails, insert as String\n+                            LOGGER.warn(\n+                                    \"[NGSIArcgisAggregator] Unquoted String attribute: \" + attrName + \":\" + attrValue);\n+                            String strValue = URLDecoder.decode(attrValue.toString());\n+                            feature.addAttribute(attrName, strValue);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 640}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQzMTI3Mw==", "bodyText": "You still need the second try/catch block to control errors while parsing Double values.\nThe point is that JsonElement.isNumber() doesn't distinguish between integer and double values.\nisJsonPrimitive and isNumber were removed for performance reasons since they make any difference.", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r414431273", "createdAt": "2020-04-24T09:27:11Z", "author": {"login": "pmo-sdr"}, "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "diffHunk": "@@ -0,0 +1,789 @@\n+/**\n+ * Copyright 2014-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+\n+package com.telefonica.iot.cygnus.sinks;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.commons.lang.exception.ExceptionUtils;\n+import org.apache.flume.Context;\n+import org.apache.flume.EventDeliveryException;\n+import org.json.JSONException;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Point;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.ArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.NGSIArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextAttribute;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextElement;\n+import com.telefonica.iot.cygnus.errors.CygnusBadConfiguration;\n+import com.telefonica.iot.cygnus.errors.CygnusBadContextData;\n+import com.telefonica.iot.cygnus.errors.CygnusCappingError;\n+import com.telefonica.iot.cygnus.errors.CygnusExpiratingError;\n+import com.telefonica.iot.cygnus.errors.CygnusPersistenceError;\n+import com.telefonica.iot.cygnus.errors.CygnusRuntimeError;\n+import com.telefonica.iot.cygnus.interceptors.NGSIEvent;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+import com.telefonica.iot.cygnus.utils.NGSIConstants;\n+\n+import jodd.util.URLDecoder;\n+\n+/**\n+ *\n+ * @author dmartinez\n+ * \n+ *         Detailed documentation can be found at:\n+ *         https://github.com/telefonicaid/fiware-cygnus/blob/master/doc/flume_extensions_catalogue/ngsi_arcgis_sink.md\n+ */\n+public class NGSIArcgisFeatureTableSink extends NGSISink {\n+\n+    private static final String DEFAULT_ARCGIS_SERVICE_URL = \"localhost\";\n+    private static final String DEFAULT_GETTOKEN_URL = \"localhost\";\n+    private static final String DEFAULT_USER_NAME = \"root\";\n+    private static final String DEFAULT_PASSWORD = \"\";\n+    private static final int DEFAULT_MAX_BATCH_SIZE = 10;\n+    private static final int DEFAULT_BATCH_TIMEOUT_SECS = 60;\n+    private static final String ARCGIS_INSTANCE_NAME = \"arcgis\";\n+\n+    private static final CygnusLogger LOGGER = new CygnusLogger(NGSIArcgisFeatureTableSink.class);\n+    private String arcgisServicesUrl;\n+    private String getTokenUrl;\n+    private String userName;\n+    private String password;\n+    private int maxBatchSize;\n+    private long timeoutSecs;\n+    private static volatile Map<String, NGSIArcgisFeatureTable> arcgisPersistenceBackend;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public NGSIArcgisFeatureTableSink() {\n+        super();\n+    } // NGSIArcgisFeatureTableSink\n+\n+    /**\n+     * Gets the Argis services url. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The services url\n+     */\n+    protected String getrAcgisServicesUrl() {\n+        return arcgisServicesUrl;\n+    } // getrAcgisServicesUrl\n+\n+    /**\n+     * Gets getToken's service url.\n+     * \n+     * @return\n+     */\n+    public String getGetTokenUrl() {\n+        return getTokenUrl;\n+    }\n+\n+    /**\n+     * Sets getToken service url.\n+     * \n+     * @param getTokenUrl\n+     */\n+    public void setGetTokenUrl(String getTokenUrl) {\n+        this.getTokenUrl = getTokenUrl;\n+    }\n+\n+    /**\n+     * Gets the username. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The username\n+     */\n+    protected String getUsername() {\n+        return userName;\n+    } // getUsername\n+\n+    /**\n+     * Gets the password. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The password\n+     */\n+    protected String getPassword() {\n+        return password;\n+    } // getPassword\n+\n+    /**\n+     * \n+     */\n+    protected int featuresBatched() {\n+        int total = 0;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table != null) {\n+                total += table.featuresBatched();\n+            }\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Returns the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The persistence backend\n+     * @throws CygnusRuntimeError\n+     */\n+    protected ArcgisFeatureTable getPersistenceBackend(String featureServiceUrl) throws CygnusRuntimeError {\n+\n+        if (arcgisPersistenceBackend.containsKey(featureServiceUrl)) {\n+            return arcgisPersistenceBackend.get(featureServiceUrl);\n+        } else {\n+            LOGGER.debug(\"Creating new persistenceBackend for Feature table: \" + featureServiceUrl);\n+            LOGGER.debug(\"Token url: \" + getGetTokenUrl());\n+            LOGGER.debug(\"User name: \" + getUsername());\n+            LOGGER.debug(\"Passwd: \" + getPassword());\n+            try {\n+                NGSIArcgisFeatureTable newTable = new NGSIArcgisFeatureTable(featureServiceUrl, getUsername(),\n+                        getPassword(), getGetTokenUrl(), timeoutSecs, LOGGER);\n+                newTable.setBatchAction(ArcgisFeatureTable.ADD_UPDATE_ACTION);\n+                newTable.setBatchSize(maxBatchSize);\n+\n+                if (newTable.hasError()) {\n+                    throw new CygnusRuntimeError(\"[\" + this.getName() + \"Error creating Persistence backend: \"\n+                            + newTable.getErrorCode() + \" - \" + newTable.getErrorDesc());\n+                } else {\n+                    arcgisPersistenceBackend.put(featureServiceUrl, newTable);\n+                    return newTable;\n+                }\n+            } catch (Throwable e) {\n+                String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+                LOGGER.debug(stackTrace);\n+                throw new CygnusRuntimeError(\"Error creating new persistence Backend. \", e.getClass().getName(),\n+                        e.getMessage());\n+            }\n+        }\n+    } // getPersistenceBackend\n+\n+    /**\n+     * Sets the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @param persistenceBackend\n+     */\n+    protected void setPersistenceBackend(String featureServiceUrl, NGSIArcgisFeatureTable persistenceBackend) {\n+        arcgisPersistenceBackend.put(featureServiceUrl, persistenceBackend);\n+    } // setPersistenceBackend\n+\n+    @Override\n+    public void configure(Context context) {\n+        arcgisServicesUrl = context.getString(\"arcgis_service_url\", DEFAULT_ARCGIS_SERVICE_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_service_url=\" + arcgisServicesUrl + \")\");\n+\n+        getTokenUrl = context.getString(\"arcgis_gettoken_url\", DEFAULT_GETTOKEN_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_fearcgis_gettoken_urlature_table_url=\"\n+                + getTokenUrl + \")\");\n+\n+        userName = context.getString(\"arcgis_username\", DEFAULT_USER_NAME);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_username=\" + userName + \")\");\n+        // FIXME: Password should be read encrypted and decoded here\n+        password = context.getString(\"arcgis_password\", DEFAULT_PASSWORD);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_password=\" + password + \")\");\n+\n+        maxBatchSize = context.getInteger(\"arcgis_maxBatchSize\", DEFAULT_MAX_BATCH_SIZE);\n+        if (maxBatchSize <= 0 || maxBatchSize > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_maxBatchSize=\" + maxBatchSize + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_maxBatchSize=\" + maxBatchSize + \")\");\n+        }\n+\n+        timeoutSecs = context.getInteger(\"arcgis_timeoutSecs\", DEFAULT_BATCH_TIMEOUT_SECS);\n+        if (timeoutSecs <= 0 || timeoutSecs > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_timeoutSecs=\" + timeoutSecs + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_timeoutSecs=\" + maxBatchSize + \")\");\n+        }\n+\n+        super.configure(context);\n+    } // configure\n+\n+    @Override\n+    public void start() {\n+        try {\n+            createPersistenceBackend();\n+            LOGGER.debug(\"[\" + this.getName() + \"] Arcgis persistence backend created\");\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error while creating the Arcgis persistence backend. Details=\" + e.getMessage());\n+        } // try catch\n+\n+        super.start();\n+    } // start\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (arcgisPersistenceBackend != null) {\n+            for (Map.Entry<String, NGSIArcgisFeatureTable> backend : arcgisPersistenceBackend.entrySet()) {\n+                backend.getValue().flushBatch();\n+            }\n+            arcgisPersistenceBackend.clear();\n+        }\n+    } // stop\n+\n+    /**\n+     * Initialices a lazy singleton to share among instances on JVM.\n+     */\n+    private static synchronized void createPersistenceBackend() {\n+        if (arcgisPersistenceBackend == null) {\n+            arcgisPersistenceBackend = new ConcurrentHashMap<String, NGSIArcgisFeatureTable>();\n+        }\n+    }\n+\n+    @Override\n+    void persistBatch(NGSIBatch batch)\n+            throws CygnusBadConfiguration, CygnusPersistenceError, CygnusRuntimeError, CygnusBadContextData {\n+        if (batch == null) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Null batch, nothing to do\");\n+            return;\n+        } // if\n+\n+        try {\n+            // Iterate on the destinations\n+            batch.startIterator();\n+\n+            while (batch.hasNext()) {\n+                String destination = batch.getNextDestination();\n+                LOGGER.debug(\n+                        \"[\" + this.getName() + \"] Processing sub-batch regarding the \" + destination + \" destination\");\n+\n+                // Get the events within the current sub-batch\n+                ArrayList<NGSIEvent> events = batch.getNextEvents();\n+\n+                // Get an aggregator for this destination and initialize it\n+                NGSIArcgisAggregator aggregator = new NGSIArcgisAggregator(getrAcgisServicesUrl(), enableNameMappings);\n+                // aggregator.setService(events.get(0).getServiceForNaming(enableNameMappings));\n+                // aggregator.setServicePathForData(events.get(0).getServicePathForData());\n+                // aggregator.setServicePathForNaming(events.get(0).getServicePathForNaming(enableGrouping,\n+                // enableNameMappings));\n+                // aggregator.setEntityForNaming(events.get(0).getEntityForNaming(enableGrouping, enableNameMappings,\n+                // enableEncoding));\n+                // aggregator.setEntityType(events.get(0).getEntityTypeForNaming(enableGrouping, enableNameMappings));\n+                // aggregator.setAttribute(events.get(0).getAttributeForNaming(enableNameMappings));\n+                // aggregator.setDbName(buildDbName(aggregator.getService()));\n+                // aggregator.setTableName(buildTableName(aggregator.getServicePathForNaming(),\n+                // aggregator.getEntityForNaming(), aggregator.getEntityType(), aggregator.getAttribute()));\n+                // aggregator.setAttrNativeTypes(attrNativeTypes);\n+                // aggregator.setAttrMetadataStore(false);\n+                aggregator.initialize(events.get(0));\n+                for (NGSIEvent event : events) {\n+                    aggregator.aggregate(event);\n+                } // for\n+\n+                // Persist the aggregation\n+                persistAggregation(aggregator);\n+                batch.setNextPersisted(true);\n+\n+            } // while\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistBatch\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see com.telefonica.iot.cygnus.sinks.NGSISink#process()\n+     */\n+    @Override\n+    public Status process() throws EventDeliveryException {\n+        checkTimeouts();\n+        Status status = null;\n+        try {\n+            status = super.process();\n+        } catch (Throwable e) {\n+            LOGGER.error(e.getMessage() + \"Stack trace: \" + Arrays.toString(e.getStackTrace()));\n+        }\n+        return status;\n+    }\n+\n+    /**\n+     * Flush if timeout.\n+     */\n+    protected void checkTimeouts() {\n+        boolean timeoutFound = false;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table.hasTimeout()) {\n+                timeoutFound = true;\n+                LOGGER.info(\"[\" + this.getName() + \"] Feature table Timeout, flushing batch. \" + entry.getKey());\n+                table.flushBatch();\n+            }\n+        }\n+        if (!timeoutFound) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] No Feature table Timeouts found. Features in batch: \"\n+                    + featuresBatched());\n+        }\n+    }\n+\n+    @Override\n+    public void capRecords(NGSIBatch batch, long maxRecords) throws CygnusCappingError {\n+        // no capping\n+        LOGGER.warn(\"[\" + this.getName() + \"] Skipping capping records, just persisting it.\");\n+        try {\n+            persistBatch(batch);\n+        } catch (CygnusBadConfiguration | CygnusPersistenceError | CygnusRuntimeError | CygnusBadContextData e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error capping Records: \" + e);\n+            throw new CygnusCappingError(e.getMessage());\n+        }\n+    } // capRecords\n+\n+    @Override\n+    public void expirateRecords(long expirationTime) throws CygnusExpiratingError {\n+        LOGGER.debug(\"[\" + this.getName() + \"] Expirating records (time=\" + expirationTime + \")\");\n+\n+    } // expirateRecords\n+\n+    /**\n+     * Persist Aggregation.\n+     * \n+     * @param aggregator\n+     * @throws CygnusRuntimeError\n+     */\n+    public void persistAggregation(NGSIArcgisAggregator aggregator) throws CygnusRuntimeError {\n+        try {\n+            List<ArcgisAggregatorDomain> aggregationList = aggregator.getListArcgisAggregatorDomain();\n+            LOGGER.debug(\"[\" + this.getName() + \"] persisting aggregation, \"\n+                    + aggregator.getListArcgisAggregatorDomain().size() + \" features.\");\n+            for (ArcgisAggregatorDomain aggregation : aggregationList) {\n+                String featureTableUrl = aggregation.getFeatureTableUrl();\n+\n+                boolean isNewFeatureTable = !arcgisPersistenceBackend.containsKey(featureTableUrl);\n+                LOGGER.debug(\"[\" + this.getName() + \"] persistAggregation - Feature table: \" + featureTableUrl\n+                        + \" is new: \" + isNewFeatureTable);\n+                ArcgisFeatureTable featureTable = getPersistenceBackend(featureTableUrl);\n+\n+                // If it's a new one, sets uniqueField value\n+                if (isNewFeatureTable) {\n+                    LOGGER.debug(\"[\" + this.getName() + \"] Created new backend for \" + featureTableUrl\n+                            + \" with uniqueField: \" + aggregation.getUniqueField());\n+                    featureTable.setUniqueField(aggregation.getUniqueField());\n+                }\n+\n+                featureTable.addToBatch(aggregation.getFeature());\n+            }\n+        } catch (CygnusRuntimeError e) {\n+            String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+            LOGGER.debug(\" PersistAggregation Error: \" + stackTrace);\n+            throw (e);\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getClass().getSimpleName() + \" - \"\n+                    + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistAggregation\n+\n+    /**\n+     * @author dmartinez\n+     *\n+     */\n+    public class NGSIArcgisAggregator {\n+\n+        private List<ArcgisAggregatorDomain> listArcgisAggregatorDomain = new ArrayList<ArcgisAggregatorDomain>();\n+        private boolean enableNameMappings = true;\n+        private String argisServiceUrl = \"\";\n+\n+        private NGSIArcgisAggregator() {\n+        } // ArcgisAggregator\n+\n+        /**\n+         * Constructor.\n+         * \n+         * @param argisServiceUrl\n+         * @param enableNameMappings\n+         */\n+        public NGSIArcgisAggregator(String argisServiceUrl, boolean enableNameMappings) {\n+            this();\n+            this.enableNameMappings = enableNameMappings;\n+            this.argisServiceUrl = argisServiceUrl;\n+        } // ArcgisAggregator\n+\n+        /**\n+         * \n+         * @param event\n+         */\n+        public void initialize(NGSIEvent event) {\n+        } // initialize\n+\n+        /**\n+         * @return the listArcgisAggregatorDomain\n+         */\n+        public List<ArcgisAggregatorDomain> getListArcgisAggregatorDomain() {\n+            return listArcgisAggregatorDomain;\n+        }\n+\n+        /**\n+         * Determines if input sitring is quoted or not.\n+         * \n+         * @param string\n+         * @return boolean\n+         */\n+\n+        /**\n+         * \n+         * @param event\n+         * @throws CygnusRuntimeError\n+         */\n+        public void aggregate(NGSIEvent event) throws CygnusRuntimeError {\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - ContextElement ->\" + event.getContextElement());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate -  MappedCE ->\" + event.getMappedCE());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - OriginalCE ->\" + event.getOriginalCE());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - enableNameMappings status -> \" + enableNameMappings);\n+\n+            ContextElement contextElement = null;\n+            try {\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - creating new aggregation object.\");\n+                ArcgisAggregatorDomain aggregation = new ArcgisAggregatorDomain(LOGGER);\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - aggregation created\");\n+                Feature feature = aggregation.getFeature();\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Feature getted\");\n+                String service = \"\";\n+                String subService = \"\";\n+                String featureTableUrl = \"\";\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Selecting context\");\n+                // get the contextElement\n+                if (!enableNameMappings) {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - no mappings\");\n+                    contextElement = event.getContextElement();\n+                } else {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - mappings\");\n+                    contextElement = event.getMappedCE();\n+                }\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Selected context ->\" + contextElement);\n+\n+                // get the getRecvTimeTs headers\n+                Map<String, String> headers = event.getHeaders();\n+\n+                for (Entry<String, String> entry : headers.entrySet()) {\n+                    LOGGER.debug(\"Header entry key --> \" + entry.getKey().toString() + \", value --> \"\n+                            + entry.getValue().toString());\n+                    if (entry.getKey() != null\n+                            && NGSIConstants.FLUME_HEADER_MAPPED_SERVICE.equals(entry.getKey().toString())) {\n+                        service = entry.getValue().toString();\n+                    } else if (entry.getKey() != null\n+                            && NGSIConstants.FLUME_HEADER_MAPPED_SERVICE_PATH.equals(entry.getKey().toString())) {\n+                        subService = entry.getValue().toString();\n+                    }\n+                } // for\n+                \n+                // Compose full url\n+                featureTableUrl = argisServiceUrl + \"/\" + service + \"/\" + subService;\n+                featureTableUrl = featureTableUrl.replaceAll(\"([^:])\\\\/\\\\/\", \"$1/\");\n+                aggregation.setFeatureTableUrl(featureTableUrl);\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - featureTableUrl ->\" + featureTableUrl);\n+\n+                // iterate on all this context element attributes, if there are\n+                // attributes\n+                ArrayList<ContextAttribute> contextAttributes = contextElement.getAttributes();\n+\n+                String entityId = contextElement.getId();\n+                String entityType = contextElement.getType();\n+\n+                // Set unique filed and it's value.\n+                aggregation.setUniqueField(entityType);\n+                feature.addAttribute(entityType, entityId);\n+\n+                contextAttrToFeature(feature, contextAttributes);\n+\n+                aggregation.setFeature(feature);\n+                listArcgisAggregatorDomain.add(aggregation);\n+\n+            } catch (JSONException e) {\n+                LOGGER.error(\n+                        \"[NGSIArcgisAggregator] aggregate - Error pharsing JSON BODY \" + contextElement.toString());\n+                throw new CygnusRuntimeError(e.getMessage());\n+            } catch (Exception e) {\n+                LOGGER.error(\"[NGSIArcgisAggregator] aggregate - Unexpected Error\" + e.getMessage()\n+                        + \"\\n contextElement: \" + contextElement.toString());\n+                throw new CygnusRuntimeError(e.getMessage());\n+            }\n+\n+        } // aggregate\n+\n+        /**\n+         * \n+         * @param feature\n+         * @param contextAttributes\n+         */\n+        protected void contextAttrToFeature(Feature feature, ArrayList<ContextAttribute> contextAttributes) {\n+            if (contextAttributes == null || contextAttributes.isEmpty()) {\n+                LOGGER.debug(\n+                        \"[NGSIArcgisAggregator-contextAttrToFeature] contextAttributes NULL or empty, ignoring it. \");\n+            } else {\n+                for (ContextAttribute contextAttribute : contextAttributes) {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator-contextAttrToFeature] Processing Attribute: \"\n+                            + contextAttribute.toString());\n+                    String attrName = contextAttribute.getName();\n+                    String attrType = contextAttribute.getType();\n+                    // get attribute value as is, quoted or not\n+                    JsonElement attrValue = contextAttribute.getValue();\n+\n+                    // TODO crop metadata values\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Atribute (name --> \" + attrName + \", type --> \"\n+                            + attrType + \", value --> \" + attrValue + \", metadata= \" + \"ignored \" + \")\");\n+\n+                    // Get Feature attributes\n+                    LOGGER.debug(\"Proccessing attribute value:  \" + attrName + \" --> \" + attrValue);\n+\n+                    jsonElementToFeatureAttr(attrName, attrType, attrValue, feature);\n+\n+                } // for\n+            } // if else\n+        }\n+    } // NGSIArcgisAggregator\n+\n+    /**\n+     * Extracts Feature attributes from JSON.\n+     * \n+     * @param attrName\n+     * @param attrType\n+     * @param attrValue\n+     * @param feature\n+     */\n+    protected void jsonElementToFeatureAttr(String attrName, String attrType, JsonElement attrValue, Feature feature) {\n+\n+        // Get Feature attributes\n+        LOGGER.debug(\"Proccessing attribute value:  \" + attrName + \" --> \" + attrValue);\n+\n+        attrType = attrType.trim().toLowerCase();\n+\n+        switch (attrType) {\n+\n+            case \"geo:json\":\n+                try {\n+                    JsonObject location = attrValue.getAsJsonObject();\n+                    if (location.get(\"type\").getAsString().equals(\"Point\")) {\n+                        JsonArray coordinates = location.get(\"coordinates\").getAsJsonArray();\n+                        double latitude = coordinates.get(0).getAsDouble();\n+                        double longitude = coordinates.get(1).getAsDouble();\n+\n+                        Point point = new Point(latitude, longitude);\n+                        feature.setGeometry(point);\n+\n+                    } else {\n+                        LOGGER.warn(\"Invalid geo:json type, only points allowed: \" + location.toString());\n+                    }\n+                } catch (Exception e) {\n+                    LOGGER.error(\"Invalid geo:json format, (sikipped): \" + attrValue.toString() + \" - Error: \"\n+                            + e.getMessage());\n+                }\n+                break;\n+            case \"boolean\":\n+                if (attrValue.isJsonPrimitive() && attrValue.getAsJsonPrimitive().isBoolean()) {\n+                    feature.addAttribute(attrName, attrValue.getAsBoolean());\n+                } else {\n+                    String strValue = attrValue.getAsString().toLowerCase().trim();\n+                    boolean result = \"true\".equals(strValue) || \"1\".equals(strValue);\n+                    feature.addAttribute(attrName, result);\n+                }\n+                break;\n+            case \"datetime\":\n+                String dateStr = attrValue.toString();\n+                feature.addAttribute(attrName, parseFiwareDate(dateStr));\n+                break;\n+\n+            default:\n+                // Verify if it is a string (it is into quotation marks)\n+                if (isQuoted(attrValue.toString())) {\n+                    // Insert unquoted\n+                    String strValue = URLDecoder.decode(unquote(attrValue.toString()));\n+                    feature.getAttributes().put(attrName, strValue);\n+                } else {\n+                    try {\n+                        // Try to insert as Integer\n+                        feature.addAttribute(attrName, Integer.parseInt(attrValue.toString()));\n+                    } catch (NumberFormatException e2) {\n+                        try {\n+                            // Try to insert as Double\n+                            feature.addAttribute(attrName, Double.parseDouble(attrValue.toString()));\n+                        } catch (NumberFormatException e3) {\n+                            // If all fails, insert as String\n+                            LOGGER.warn(\n+                                    \"[NGSIArcgisAggregator] Unquoted String attribute: \" + attrName + \":\" + attrValue);\n+                            String strValue = URLDecoder.decode(attrValue.toString());\n+                            feature.addAttribute(attrName, strValue);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc0MTI3MQ=="}, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 640}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTk3MzQzOnYy", "diffSide": "RIGHT", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/backends/arcgis/restutils/RestFeatureTable.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMzo1MTozN1rOGKpGDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMzo0OTozNVrOGMkK2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgxMjIzOA==", "bodyText": "It would be better to declare this Strings as constants. This applies to a lot of Strings on this class. At least the ones that are added into the collection.", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r413812238", "createdAt": "2020-04-23T13:51:37Z", "author": {"login": "IvanHdzC"}, "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/backends/arcgis/restutils/RestFeatureTable.java", "diffHunk": "@@ -0,0 +1,590 @@\n+/**\n+ * \n+ */\n+package com.telefonica.iot.cygnus.backends.arcgis.restutils;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.log4j.Logger;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.telefonica.iot.cygnus.backends.arcgis.baselogger.BaseLoggerInterface;\n+import com.telefonica.iot.cygnus.backends.arcgis.exceptions.ArcgisException;\n+import com.telefonica.iot.cygnus.backends.arcgis.http.HttpResponse;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Credential;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Field;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.pagination.ResultPage;\n+\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.CredentialRestApi;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.RestFeatureTable;\n+\n+/**\n+ * @author dmartinez\n+ *\n+ */\n+public class RestFeatureTable extends CredentialRestApi {\n+\n+    static final Logger LOGGER = Logger.getLogger(RestFeatureTable.class);\n+\n+    protected URL serviceUrl;\n+\n+    // Table info\n+    private String uniqueIdField = \"\";\n+    private Map<String, Field> tableAttributes = new HashMap<String, Field>();\n+    private Map<String, Boolean> uniqueAttributes = new HashMap<String, Boolean>();\n+\n+    /**\n+     * \n+     * @param serviceUrl\n+     * @param credential\n+     * @param referer\n+     * @param expirationMins\n+     */\n+    private RestFeatureTable(URL serviceUrl, Credential credential) {\n+        super((URL) null, credential, serviceUrl.toString());\n+        this.serviceUrl = serviceUrl;\n+    }\n+\n+    private RestFeatureTable(URL serviceUrl, Credential credential,\n+            BaseLoggerInterface parentLogger) {\n+        this(serviceUrl, credential);\n+        this.parentLogger = parentLogger;\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param url\n+     * @param credential\n+     * @throws MalformedURLException\n+     */\n+    public RestFeatureTable(String url, Credential credential, String tokenGenUrl)\n+            throws ArcgisException {\n+        super(tokenGenUrl, credential, url);\n+\n+        try {\n+            this.serviceUrl = new URL(url);\n+        } catch (MalformedURLException e) {\n+            logDebug(\"Error parsing url \" + url);\n+            throw new ArcgisException(\"Error parsing url \" + url);\n+        }\n+    }\n+\n+    /**\n+     * \n+     * @param url\n+     * @param credential\n+     * @param tokenGenUrl\n+     * @param parentLogger\n+     * @throws ArcgisException\n+     */\n+    public RestFeatureTable(String url, Credential credential, String tokenGenUrl,\n+            BaseLoggerInterface parentLogger) throws ArcgisException {\n+        this(url, credential, tokenGenUrl);\n+        this.parentLogger = parentLogger;\n+    }\n+\n+    /**\n+     * Constructor\n+     * \n+     * @param url\n+     * @param credential\n+     * @throws MalformedURLException\n+     */\n+    // public RestFeatureTable (URL url, Credential credential, URL tokenGenUrl){\n+    // super(tokenGenUrl, credential, url.toString());\n+    // this.serviceUrl = url;\n+    // }\n+\n+    /**\n+     * @return the tableAttributes\n+     */\n+    public Map<String, Field> getTableAttributes() {\n+        return tableAttributes;\n+    }\n+\n+    /**\n+     * @param tableAttributes\n+     *            the tableAttributes to set\n+     */\n+    public void setTableAttributes(Map<String, Field> tableAttributes) {\n+        this.tableAttributes = tableAttributes;\n+    }\n+\n+    /**\n+     * @return the uniqueAttributes\n+     */\n+    public Map<String, Boolean> getUniqueAttributes() {\n+        return uniqueAttributes;\n+    }\n+\n+    /**\n+     * @param uniqueAttributes\n+     *            the uniqueAttributes to set\n+     */\n+    public void setUniqueAttributes(Map<String, Boolean> uniqueAttributes) {\n+        this.uniqueAttributes = uniqueAttributes;\n+    }\n+\n+    /**\n+     * @return the uniqueIdField\n+     */\n+    public String getUniqueIdField() {\n+        return uniqueIdField;\n+    }\n+\n+    /**\n+     * @return the uniqueIdField\n+     */\n+    public boolean hasUniqueIdField() {\n+        return this.tableAttributes.containsKey(uniqueIdField);\n+    }\n+\n+    /**\n+     * \n+     * @param whereClause\n+     * @return\n+     * @throws ArcgisException\n+     */\n+    public List<Feature> getFeatureList(String whereClause) throws ArcgisException {\n+        List<Feature> resultList = new ArrayList<Feature>();\n+        ResultPage<Feature> page;\n+        int pageOffset = 0;\n+\n+        do {\n+            page = getFeatureList(whereClause, pageOffset, getCredential().getToken());\n+            pageOffset += page.getItemsSize();\n+            resultList.addAll(page.asItemsList());\n+        } while (page.hasNext());\n+\n+        return resultList;\n+    }\n+\n+    /**\n+     * \n+     * @param whereClause\n+     * @param token\n+     * @return\n+     * @throws ArcgisException\n+     */\n+    public ResultPage<Feature> getFeatureList(String whereClause, int pageOffset, String token)\n+            throws ArcgisException {\n+\n+        logDebug(\"getFeatureList - Connecting Feature table: \" + serviceUrl);\n+\n+        String responseJSON = null;\n+\n+        Map<String, String> params = new LinkedHashMap<String, String>();\n+        params.put(\"outSR\", \"{\\\"wkid\\\":4326}\");\n+        params.put(\"outFields\", \"*\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgyODY5OQ==", "bodyText": "Fixed Stdri@042bbab", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r415828699", "createdAt": "2020-04-27T13:49:35Z", "author": {"login": "pmo-sdr"}, "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/backends/arcgis/restutils/RestFeatureTable.java", "diffHunk": "@@ -0,0 +1,590 @@\n+/**\n+ * \n+ */\n+package com.telefonica.iot.cygnus.backends.arcgis.restutils;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.log4j.Logger;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.telefonica.iot.cygnus.backends.arcgis.baselogger.BaseLoggerInterface;\n+import com.telefonica.iot.cygnus.backends.arcgis.exceptions.ArcgisException;\n+import com.telefonica.iot.cygnus.backends.arcgis.http.HttpResponse;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Credential;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Field;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.pagination.ResultPage;\n+\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.CredentialRestApi;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.RestFeatureTable;\n+\n+/**\n+ * @author dmartinez\n+ *\n+ */\n+public class RestFeatureTable extends CredentialRestApi {\n+\n+    static final Logger LOGGER = Logger.getLogger(RestFeatureTable.class);\n+\n+    protected URL serviceUrl;\n+\n+    // Table info\n+    private String uniqueIdField = \"\";\n+    private Map<String, Field> tableAttributes = new HashMap<String, Field>();\n+    private Map<String, Boolean> uniqueAttributes = new HashMap<String, Boolean>();\n+\n+    /**\n+     * \n+     * @param serviceUrl\n+     * @param credential\n+     * @param referer\n+     * @param expirationMins\n+     */\n+    private RestFeatureTable(URL serviceUrl, Credential credential) {\n+        super((URL) null, credential, serviceUrl.toString());\n+        this.serviceUrl = serviceUrl;\n+    }\n+\n+    private RestFeatureTable(URL serviceUrl, Credential credential,\n+            BaseLoggerInterface parentLogger) {\n+        this(serviceUrl, credential);\n+        this.parentLogger = parentLogger;\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param url\n+     * @param credential\n+     * @throws MalformedURLException\n+     */\n+    public RestFeatureTable(String url, Credential credential, String tokenGenUrl)\n+            throws ArcgisException {\n+        super(tokenGenUrl, credential, url);\n+\n+        try {\n+            this.serviceUrl = new URL(url);\n+        } catch (MalformedURLException e) {\n+            logDebug(\"Error parsing url \" + url);\n+            throw new ArcgisException(\"Error parsing url \" + url);\n+        }\n+    }\n+\n+    /**\n+     * \n+     * @param url\n+     * @param credential\n+     * @param tokenGenUrl\n+     * @param parentLogger\n+     * @throws ArcgisException\n+     */\n+    public RestFeatureTable(String url, Credential credential, String tokenGenUrl,\n+            BaseLoggerInterface parentLogger) throws ArcgisException {\n+        this(url, credential, tokenGenUrl);\n+        this.parentLogger = parentLogger;\n+    }\n+\n+    /**\n+     * Constructor\n+     * \n+     * @param url\n+     * @param credential\n+     * @throws MalformedURLException\n+     */\n+    // public RestFeatureTable (URL url, Credential credential, URL tokenGenUrl){\n+    // super(tokenGenUrl, credential, url.toString());\n+    // this.serviceUrl = url;\n+    // }\n+\n+    /**\n+     * @return the tableAttributes\n+     */\n+    public Map<String, Field> getTableAttributes() {\n+        return tableAttributes;\n+    }\n+\n+    /**\n+     * @param tableAttributes\n+     *            the tableAttributes to set\n+     */\n+    public void setTableAttributes(Map<String, Field> tableAttributes) {\n+        this.tableAttributes = tableAttributes;\n+    }\n+\n+    /**\n+     * @return the uniqueAttributes\n+     */\n+    public Map<String, Boolean> getUniqueAttributes() {\n+        return uniqueAttributes;\n+    }\n+\n+    /**\n+     * @param uniqueAttributes\n+     *            the uniqueAttributes to set\n+     */\n+    public void setUniqueAttributes(Map<String, Boolean> uniqueAttributes) {\n+        this.uniqueAttributes = uniqueAttributes;\n+    }\n+\n+    /**\n+     * @return the uniqueIdField\n+     */\n+    public String getUniqueIdField() {\n+        return uniqueIdField;\n+    }\n+\n+    /**\n+     * @return the uniqueIdField\n+     */\n+    public boolean hasUniqueIdField() {\n+        return this.tableAttributes.containsKey(uniqueIdField);\n+    }\n+\n+    /**\n+     * \n+     * @param whereClause\n+     * @return\n+     * @throws ArcgisException\n+     */\n+    public List<Feature> getFeatureList(String whereClause) throws ArcgisException {\n+        List<Feature> resultList = new ArrayList<Feature>();\n+        ResultPage<Feature> page;\n+        int pageOffset = 0;\n+\n+        do {\n+            page = getFeatureList(whereClause, pageOffset, getCredential().getToken());\n+            pageOffset += page.getItemsSize();\n+            resultList.addAll(page.asItemsList());\n+        } while (page.hasNext());\n+\n+        return resultList;\n+    }\n+\n+    /**\n+     * \n+     * @param whereClause\n+     * @param token\n+     * @return\n+     * @throws ArcgisException\n+     */\n+    public ResultPage<Feature> getFeatureList(String whereClause, int pageOffset, String token)\n+            throws ArcgisException {\n+\n+        logDebug(\"getFeatureList - Connecting Feature table: \" + serviceUrl);\n+\n+        String responseJSON = null;\n+\n+        Map<String, String> params = new LinkedHashMap<String, String>();\n+        params.put(\"outSR\", \"{\\\"wkid\\\":4326}\");\n+        params.put(\"outFields\", \"*\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgxMjIzOA=="}, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTk5Njg3OnYy", "diffSide": "RIGHT", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/backends/arcgis/restutils/RestAuthentication.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMzo1NjoyMlrOGKpUqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwOToyMToxMVrOGLOpLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgxNTk3OA==", "bodyText": "It would be better to declare this Strings as constants.", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r413815978", "createdAt": "2020-04-23T13:56:22Z", "author": {"login": "IvanHdzC"}, "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/backends/arcgis/restutils/RestAuthentication.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package com.telefonica.iot.cygnus.backends.arcgis.restutils;\n+\n+import java.net.URL;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.telefonica.iot.cygnus.backends.arcgis.exceptions.ArcgisException;\n+import com.telefonica.iot.cygnus.backends.arcgis.http.HttpResponse;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Credential;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.UserCredential;\n+\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.RestApi;\n+\n+/**\n+ * \n+ * @author dmartinez\n+ *\n+ */\n+public class RestAuthentication extends RestApi {\n+\n+    private static final String REQUEST_FORMAT_PARAMETER = \"pjson\";\n+    private static final String APP_RESPONSE_EXPIRES_TAG = \"expires_in\";\n+    private static final String ONLINE_RESPONSE_EXPIRES_TAG = \"expires\";\n+    private static final String ONLINE_RESPONSE_TOKEN_TAG = \"token\";\n+    private static final String APP_RESPONSE_TOKEN_TAG = \"access_token\";\n+\n+    /**\n+     * Extracts token from Json response.\n+     * \n+     * @param tokenJson\n+     * @return\n+     * @throws ArcGisException\n+     */\n+    public static String tokenFromJson(String tokenJson, String tokenTag) throws ArcgisException {\n+        String result = null;\n+        if (\"\".equals(tokenTag)) {\n+            tokenTag = ONLINE_RESPONSE_TOKEN_TAG;\n+        }\n+\n+        JsonParser parser = new JsonParser();\n+        JsonObject json = parser.parse(tokenJson).getAsJsonObject();\n+        JsonElement node = json.get(tokenTag);\n+\n+        if (node != null) {\n+            result = node.getAsString();\n+            JsonElement expirationElement = json.get(ONLINE_RESPONSE_EXPIRES_TAG);\n+\n+            if (expirationElement == null) {\n+                expirationElement = json.get(APP_RESPONSE_EXPIRES_TAG);\n+                System.out.println(\"Expiration: \" + expirationElement.getAsLong());\n+            } else {\n+                long expiration = expirationElement.getAsLong();\n+                Instant expirationInstant = Instant.ofEpochMilli(expiration);\n+                if (expirationInstant.isBefore(Instant.now())) {\n+                    // token is expired.\n+                    System.out.println(\"Token expired at \" + expirationInstant);\n+                    return null;\n+                }\n+            }\n+        } else {\n+            String errorDesc = \"Invalid token response format.\";\n+            if (json.get(\"error\") != null) {\n+                errorDesc = json.get(\"error\").toString();\n+            }\n+            throw new ArcgisException(errorDesc);\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * \n+     * @param tokenJson\n+     * @param expirationTag\n+     * @return\n+     * @throws ArcgisException\n+     */\n+    public static LocalDateTime expirationFromJson(String tokenJson, String expirationTag)\n+            throws ArcgisException {\n+        LocalDateTime result = null;\n+        if (\"\".equals(expirationTag)) {\n+            expirationTag = ONLINE_RESPONSE_EXPIRES_TAG;\n+        }\n+\n+        JsonParser parser = new JsonParser();\n+        JsonObject json = parser.parse(tokenJson).getAsJsonObject();\n+        JsonElement node = json.get(expirationTag);\n+\n+        if (node != null) {\n+            JsonElement expirationElement = json.get(ONLINE_RESPONSE_EXPIRES_TAG);\n+\n+            if (expirationElement == null) {\n+                expirationElement = json.get(APP_RESPONSE_EXPIRES_TAG);\n+            }\n+\n+            long expiration = expirationElement.getAsLong();\n+\n+            result = LocalDateTime.ofInstant(Instant.ofEpochMilli(expiration),\n+                    ZoneId.systemDefault());\n+        } else {\n+            String errorDesc = \"Invalid token response format.\";\n+            if (json.get(\"error\") != null) {\n+                errorDesc = json.get(\"error\").toString();\n+            }\n+            throw new ArcgisException(errorDesc);\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Request a token for a non OAuth token authentication.\n+     * \n+     * @param cred\n+     * @param tokenGenUrl\n+     * @param referer\n+     * @param expirationMins\n+     * @return token\n+     * @throws ArcGisException\n+     */\n+    public static Credential createUserToken(String user, String password, URL tokenGenUrl,\n+            String referer, Integer expirationMins) throws ArcgisException {\n+        String tokenJSON = null;\n+        try {\n+            Map<String, String> bodyParams = new LinkedHashMap<String, String>();\n+            bodyParams.put(\"username\", user);\n+            bodyParams.put(\"password\", password);\n+            bodyParams.put(\"referer\", referer);\n+            bodyParams.put(\"username\", user);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQyNzQzOQ==", "bodyText": "We agree. It's done.", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r414427439", "createdAt": "2020-04-24T09:21:11Z", "author": {"login": "pmo-sdr"}, "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/backends/arcgis/restutils/RestAuthentication.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package com.telefonica.iot.cygnus.backends.arcgis.restutils;\n+\n+import java.net.URL;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.telefonica.iot.cygnus.backends.arcgis.exceptions.ArcgisException;\n+import com.telefonica.iot.cygnus.backends.arcgis.http.HttpResponse;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Credential;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.UserCredential;\n+\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.RestApi;\n+\n+/**\n+ * \n+ * @author dmartinez\n+ *\n+ */\n+public class RestAuthentication extends RestApi {\n+\n+    private static final String REQUEST_FORMAT_PARAMETER = \"pjson\";\n+    private static final String APP_RESPONSE_EXPIRES_TAG = \"expires_in\";\n+    private static final String ONLINE_RESPONSE_EXPIRES_TAG = \"expires\";\n+    private static final String ONLINE_RESPONSE_TOKEN_TAG = \"token\";\n+    private static final String APP_RESPONSE_TOKEN_TAG = \"access_token\";\n+\n+    /**\n+     * Extracts token from Json response.\n+     * \n+     * @param tokenJson\n+     * @return\n+     * @throws ArcGisException\n+     */\n+    public static String tokenFromJson(String tokenJson, String tokenTag) throws ArcgisException {\n+        String result = null;\n+        if (\"\".equals(tokenTag)) {\n+            tokenTag = ONLINE_RESPONSE_TOKEN_TAG;\n+        }\n+\n+        JsonParser parser = new JsonParser();\n+        JsonObject json = parser.parse(tokenJson).getAsJsonObject();\n+        JsonElement node = json.get(tokenTag);\n+\n+        if (node != null) {\n+            result = node.getAsString();\n+            JsonElement expirationElement = json.get(ONLINE_RESPONSE_EXPIRES_TAG);\n+\n+            if (expirationElement == null) {\n+                expirationElement = json.get(APP_RESPONSE_EXPIRES_TAG);\n+                System.out.println(\"Expiration: \" + expirationElement.getAsLong());\n+            } else {\n+                long expiration = expirationElement.getAsLong();\n+                Instant expirationInstant = Instant.ofEpochMilli(expiration);\n+                if (expirationInstant.isBefore(Instant.now())) {\n+                    // token is expired.\n+                    System.out.println(\"Token expired at \" + expirationInstant);\n+                    return null;\n+                }\n+            }\n+        } else {\n+            String errorDesc = \"Invalid token response format.\";\n+            if (json.get(\"error\") != null) {\n+                errorDesc = json.get(\"error\").toString();\n+            }\n+            throw new ArcgisException(errorDesc);\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * \n+     * @param tokenJson\n+     * @param expirationTag\n+     * @return\n+     * @throws ArcgisException\n+     */\n+    public static LocalDateTime expirationFromJson(String tokenJson, String expirationTag)\n+            throws ArcgisException {\n+        LocalDateTime result = null;\n+        if (\"\".equals(expirationTag)) {\n+            expirationTag = ONLINE_RESPONSE_EXPIRES_TAG;\n+        }\n+\n+        JsonParser parser = new JsonParser();\n+        JsonObject json = parser.parse(tokenJson).getAsJsonObject();\n+        JsonElement node = json.get(expirationTag);\n+\n+        if (node != null) {\n+            JsonElement expirationElement = json.get(ONLINE_RESPONSE_EXPIRES_TAG);\n+\n+            if (expirationElement == null) {\n+                expirationElement = json.get(APP_RESPONSE_EXPIRES_TAG);\n+            }\n+\n+            long expiration = expirationElement.getAsLong();\n+\n+            result = LocalDateTime.ofInstant(Instant.ofEpochMilli(expiration),\n+                    ZoneId.systemDefault());\n+        } else {\n+            String errorDesc = \"Invalid token response format.\";\n+            if (json.get(\"error\") != null) {\n+                errorDesc = json.get(\"error\").toString();\n+            }\n+            throw new ArcgisException(errorDesc);\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Request a token for a non OAuth token authentication.\n+     * \n+     * @param cred\n+     * @param tokenGenUrl\n+     * @param referer\n+     * @param expirationMins\n+     * @return token\n+     * @throws ArcGisException\n+     */\n+    public static Credential createUserToken(String user, String password, URL tokenGenUrl,\n+            String referer, Integer expirationMins) throws ArcgisException {\n+        String tokenJSON = null;\n+        try {\n+            Map<String, String> bodyParams = new LinkedHashMap<String, String>();\n+            bodyParams.put(\"username\", user);\n+            bodyParams.put(\"password\", password);\n+            bodyParams.put(\"referer\", referer);\n+            bodyParams.put(\"username\", user);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgxNTk3OA=="}, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MjA1MDM3OnYy", "diffSide": "RIGHT", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/backends/arcgis/restutils/NGSIArcgisFeatureTable.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNDowNTozOFrOGKp0WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwODozNjo0MVrOGMXdGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgyNDA4OQ==", "bodyText": "Is there any particular reason for you not to use the singleton logger on the project?", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r413824089", "createdAt": "2020-04-23T14:05:38Z", "author": {"login": "IvanHdzC"}, "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/backends/arcgis/restutils/NGSIArcgisFeatureTable.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/**\n+ * Copyright 2015-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+package com.telefonica.iot.cygnus.backends.arcgis.restutils;\n+\n+import java.util.Date;\n+\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+\n+/**\n+ * \n+ * @author PMO Santander Smart City \u2013 Ayuntamiento de Santander\n+ *\n+ */\n+public class NGSIArcgisFeatureTable extends ArcgisFeatureTable {\n+\n+    private static final String CLASS_NAME = \"NGSIArcgisFeatureTable\";\n+    private CygnusLogger cygnusLogger;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYyMDM3Nw==", "bodyText": "This model was designed to be a PDI (kettle) plugin, and BasseLogger was the way to make logs work both Cygnus and PDI. Finally we make an specific project for cygnus, and changed logs to work Cygnus-like.", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r415620377", "createdAt": "2020-04-27T08:36:41Z", "author": {"login": "pmo-sdr"}, "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/backends/arcgis/restutils/NGSIArcgisFeatureTable.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/**\n+ * Copyright 2015-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+package com.telefonica.iot.cygnus.backends.arcgis.restutils;\n+\n+import java.util.Date;\n+\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+\n+/**\n+ * \n+ * @author PMO Santander Smart City \u2013 Ayuntamiento de Santander\n+ *\n+ */\n+public class NGSIArcgisFeatureTable extends ArcgisFeatureTable {\n+\n+    private static final String CLASS_NAME = \"NGSIArcgisFeatureTable\";\n+    private CygnusLogger cygnusLogger;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgyNDA4OQ=="}, "originalCommit": {"oid": "a322017a039928c29edce071f799e5e6addcd4ea"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NjI5NTEwOnYy", "diffSide": "RIGHT", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/backends/arcgis/baselogger/BaseLogger.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwOTo1ODo1MFrOGLQG5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwODoxODo0NVrOGMWsIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ1MTQyOA==", "bodyText": "@dmartinezgomez can you elaborate a little bit more about your BaseLgger class. Sorry, I'm confused, about this. I understood that you modiffied the way Cygnus logs, but this is a completely new logger.", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r414451428", "createdAt": "2020-04-24T09:58:50Z", "author": {"login": "IvanHdzC"}, "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/backends/arcgis/baselogger/BaseLogger.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/**\n+ * \n+ */\n+package com.telefonica.iot.cygnus.backends.arcgis.baselogger;\n+\n+import org.apache.log4j.Logger;\n+\n+/**\n+ * @author dmartinez\n+ *\n+ */\n+public class BaseLogger implements BaseLoggerInterface {\n+\n+    static final Logger LOGGER = Logger.getLogger(BaseLogger.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5317436d0087f9869ddf1ec086871c0fa29bf76"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYwNzg0Mg==", "bodyText": "This model was designed to be a PDI (kettle) plugin, and BasseLogger was the way to make logs work both Cygnus and PDI.  Finally we make an specific project for cygnus, and changed logs to work Cygnus-like.", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r415607842", "createdAt": "2020-04-27T08:18:45Z", "author": {"login": "pmo-sdr"}, "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/backends/arcgis/baselogger/BaseLogger.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/**\n+ * \n+ */\n+package com.telefonica.iot.cygnus.backends.arcgis.baselogger;\n+\n+import org.apache.log4j.Logger;\n+\n+/**\n+ * @author dmartinez\n+ *\n+ */\n+public class BaseLogger implements BaseLoggerInterface {\n+\n+    static final Logger LOGGER = Logger.getLogger(BaseLogger.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ1MTQyOA=="}, "originalCommit": {"oid": "e5317436d0087f9869ddf1ec086871c0fa29bf76"}, "originalPosition": 14}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2457, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}