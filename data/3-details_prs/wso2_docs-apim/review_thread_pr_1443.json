{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxMjc1ODIz", "number": 1443, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQwODozNjoxNFrOEJl2dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQwODo0OTo1MVrOEJmKhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NDkyNzkwOnYy", "diffSide": "RIGHT", "path": "en/docs/learn/api-security/graphql-query-analysis/graphql-query-analysis.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQwODozNjoxNFrOGqKRFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQwODozNjoxNFrOGqKRFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg2MTU4OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In order to implement this **Fine Grained Access Control-Static Query Analyser**, we introduce two new alternative fields \n          \n          \n            \n            In order to implement **Fine Grained Access Control-Static Query Analyser**, two optional fields have been introduced", "url": "https://github.com/wso2/docs-apim/pull/1443#discussion_r446861588", "createdAt": "2020-06-29T08:36:14Z", "author": {"login": "fazlan-nazeem"}, "path": "en/docs/learn/api-security/graphql-query-analysis/graphql-query-analysis.md", "diffHunk": "@@ -0,0 +1,49 @@\n+GraphQL is an open-source data query & manipulation language for APIs. It provides a common interface between the client \n+and the server for data fetching and manipulations.\n+\n+With GraphQL queries, the client which requests data has more flexibility compared to REST where it can request any \n+amount of data it wishes. This flexibility comes at a cost since now the GraphQL service might have to do complex \n+operations to serve each type of query it receives. To overcome this hardship, the query needs to be analysed before \n+execution. Without any protection to the backend, we\u2019ll be vulnerable to DoS attacks (due to excessive load to the \n+server, database or network), which are caused by the execution of malicious and complex queries that are passed either\n+intentionally or unintentionally. \n+\n+Since clients have the possibility to request very complex queries, servers must be ready to handle them properly. \n+**WSO2 API-Manager introduces Static Query Analyser to Secure GraphQL APIs** to address such issues.\n+\n+### Static Query Analyser\n+\n+Through the static query analyzer, we analyse the query and based on the previously set limitations/policy and block \n+complex queries before it reaches the backend. Given below is the basic outline of the policies which are to be defined \n+within the policy definition.\n+\n+   - [Query Depth Limitation]({{base_path}}/learn/api-security/graphql-query-analysis/query-depth-limitation)\n+    \n+   - [Query Complexity Limitation]({{base_path}}/learn/api-security/graphql-query-analysis/query-complexity-limitation)\n+\n+\n+In order to implement this **Fine Grained Access Control-Static Query Analyser**, we introduce two new alternative fields ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a79f1f7831bc0fc7206f58a62fd2000052c1938e"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NDkzNDE1OnYy", "diffSide": "RIGHT", "path": "en/docs/learn/api-security/graphql-query-analysis/graphql-query-analysis.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQwODozNzo1MlrOGqKUrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQwODozNzo1MlrOGqKUrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg2MjUxMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            So Through the Subscription Policy UI in the admin portal, we can set the GraphQL Max Depth value and GraphQL Max Complexity \n          \n          \n            \n            Through the Subscription Policy UI in the admin portal, GraphQL Max Depth value and GraphQL Max Complexity values can be set", "url": "https://github.com/wso2/docs-apim/pull/1443#discussion_r446862511", "createdAt": "2020-06-29T08:37:52Z", "author": {"login": "fazlan-nazeem"}, "path": "en/docs/learn/api-security/graphql-query-analysis/graphql-query-analysis.md", "diffHunk": "@@ -0,0 +1,49 @@\n+GraphQL is an open-source data query & manipulation language for APIs. It provides a common interface between the client \n+and the server for data fetching and manipulations.\n+\n+With GraphQL queries, the client which requests data has more flexibility compared to REST where it can request any \n+amount of data it wishes. This flexibility comes at a cost since now the GraphQL service might have to do complex \n+operations to serve each type of query it receives. To overcome this hardship, the query needs to be analysed before \n+execution. Without any protection to the backend, we\u2019ll be vulnerable to DoS attacks (due to excessive load to the \n+server, database or network), which are caused by the execution of malicious and complex queries that are passed either\n+intentionally or unintentionally. \n+\n+Since clients have the possibility to request very complex queries, servers must be ready to handle them properly. \n+**WSO2 API-Manager introduces Static Query Analyser to Secure GraphQL APIs** to address such issues.\n+\n+### Static Query Analyser\n+\n+Through the static query analyzer, we analyse the query and based on the previously set limitations/policy and block \n+complex queries before it reaches the backend. Given below is the basic outline of the policies which are to be defined \n+within the policy definition.\n+\n+   - [Query Depth Limitation]({{base_path}}/learn/api-security/graphql-query-analysis/query-depth-limitation)\n+    \n+   - [Query Complexity Limitation]({{base_path}}/learn/api-security/graphql-query-analysis/query-complexity-limitation)\n+\n+\n+In order to implement this **Fine Grained Access Control-Static Query Analyser**, we introduce two new alternative fields \n+to the Subscription Policy: **GraphQL Max Depth** and  **GraphQL Max Complexity**.\n+\n+So Through the Subscription Policy UI in the admin portal, we can set the GraphQL Max Depth value and GraphQL Max Complexity ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a79f1f7831bc0fc7206f58a62fd2000052c1938e"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NDkzOTUwOnYy", "diffSide": "RIGHT", "path": "en/docs/learn/api-security/graphql-query-analysis/graphql-query-analysis.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQwODozOToxM1rOGqKX4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQwODozOToxM1rOGqKX4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg2MzMyOQ==", "bodyText": "Once done, the corresponding subscription plan can be chosen via the business plans to engage these validations to an API.", "url": "https://github.com/wso2/docs-apim/pull/1443#discussion_r446863329", "createdAt": "2020-06-29T08:39:13Z", "author": {"login": "fazlan-nazeem"}, "path": "en/docs/learn/api-security/graphql-query-analysis/graphql-query-analysis.md", "diffHunk": "@@ -0,0 +1,49 @@\n+GraphQL is an open-source data query & manipulation language for APIs. It provides a common interface between the client \n+and the server for data fetching and manipulations.\n+\n+With GraphQL queries, the client which requests data has more flexibility compared to REST where it can request any \n+amount of data it wishes. This flexibility comes at a cost since now the GraphQL service might have to do complex \n+operations to serve each type of query it receives. To overcome this hardship, the query needs to be analysed before \n+execution. Without any protection to the backend, we\u2019ll be vulnerable to DoS attacks (due to excessive load to the \n+server, database or network), which are caused by the execution of malicious and complex queries that are passed either\n+intentionally or unintentionally. \n+\n+Since clients have the possibility to request very complex queries, servers must be ready to handle them properly. \n+**WSO2 API-Manager introduces Static Query Analyser to Secure GraphQL APIs** to address such issues.\n+\n+### Static Query Analyser\n+\n+Through the static query analyzer, we analyse the query and based on the previously set limitations/policy and block \n+complex queries before it reaches the backend. Given below is the basic outline of the policies which are to be defined \n+within the policy definition.\n+\n+   - [Query Depth Limitation]({{base_path}}/learn/api-security/graphql-query-analysis/query-depth-limitation)\n+    \n+   - [Query Complexity Limitation]({{base_path}}/learn/api-security/graphql-query-analysis/query-complexity-limitation)\n+\n+\n+In order to implement this **Fine Grained Access Control-Static Query Analyser**, we introduce two new alternative fields \n+to the Subscription Policy: **GraphQL Max Depth** and  **GraphQL Max Complexity**.\n+\n+So Through the Subscription Policy UI in the admin portal, we can set the GraphQL Max Depth value and GraphQL Max Complexity \n+values. Selecting Business Plans, you can allocate the GraphQL Max Depth and GraphQL Max Complexity values for your APIs.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a79f1f7831bc0fc7206f58a62fd2000052c1938e"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NDk1MTkzOnYy", "diffSide": "RIGHT", "path": "en/docs/learn/api-security/graphql-query-analysis/query-depth-limitation.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQwODo0MjoyN1rOGqKfhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQwODo0MjoyN1rOGqKfhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg2NTI4NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You have now **successfully blocked a requested GraphQL query** using the **Max Depth** value that you assigned before.\n          \n          \n            \n            You have now successfully blocked a GraphQL API query using the **Max Depth** value that you assigned before.", "url": "https://github.com/wso2/docs-apim/pull/1443#discussion_r446865284", "createdAt": "2020-06-29T08:42:27Z", "author": {"login": "fazlan-nazeem"}, "path": "en/docs/learn/api-security/graphql-query-analysis/query-depth-limitation.md", "diffHunk": "@@ -0,0 +1,109 @@\n+Since GraphQL schemas often have circular relationships, the depth can grow till no end. \n+this means a client could craft a query like this:\n+\n+  [![GraphQL Depth Limitation]({{base_path}}/assets/img/learn/graphql-depth-limitation.png)]({{base_path}}/assets/img/learn/graphql-depth-limitation.png)\n+\n+\n+This relationship allows a bad actor to construct an expensive nested query. WSO2 API-Manager introduces GraphQL **Query \n+Depth Limitation** to avoid such cyclic relationships.\n+\n+The request allowed or rejected based on the depth of the requested query, and the maximum depth value which has been \n+configured to the corresponding subscription policy of the API.\n+\n+For example, assume an API configured with the  GraphQL **Max Depth value of 5**. The **depth value of the following \n+requested query is 7**. Therefore, the request query will be **rejected** from the Gateway before reaching the backend.\n+\n+  ```\n+        query{\t\t\t\t\t\t\t            # depth 0\n+            allFilms{\t\t\t\t\t\t        # depth 1\n+                id\t\t\t\t\t\t\t        # depth 2\n+                Species{\n+                    id\t\t\t\t\t\t        # depth 3\n+                    films{\n+                        title\t\t\t\t\t    # depth 4\n+                        planets{\n+                            id\t\t\t\t\t    # depth 5\n+                            residents{\n+                                eyeColor\t\t\t# depth 6\n+                                films{\n+                                    director\t\t# depth 7\n+                                    producers\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        # depth value of query : 7\n+\n+\n+  ```\n+\n+Let's see how **GraphQL Query Depth Limitation** can be managed with your GraphQL API.\n+\n+### Adding a new Subscription policy with GraphQL Max Depth value\n+\n+1.  Sign in to the Admin Portal using the URL `https://localhost:9443/admin` and your admin credentials \n+(admin/admin by default).\n+2.  Click **Subscription Policies** under the **Rate Limiting Policies** section to see the set of existing \n+subscription policies.\n+3.  To add a new Subscription Policy, click **Add Policy** .\n+[![Add new Subscription Policy]({{base_path}}/assets/img/learn/add-new-subscription-policy-graphql-query-complexity.png)]({{base_path}}/assets/img/learn/add-new-subscription-policy-graphql-query-complexity.png)\n+4.  Fill in the required details\u00a0and click **Save** .\n+\n+### Design a GraphQL API\n+\n+To design a GraphQL API, see [Create a GraphQL API]({{base_path}}/learn/design-api/create-api/create-a-graphql-api).\n+\n+<html>\n+<div class=\"admonition note\">\n+<p class=\"admonition-title\">Note</p>\n+<p>\n+Instead of giving Business Plans of GraphQL API related details in \n+<a href=\"{{base_path}}/learn/design-api/create-api/create-a-graphql-api\">Create a GraphQL API</a>, \n+Use Business Plans that you create in the previous steps.\n+</p>\n+</div> \n+</html>\n+\n+### Invoke a GraphQL API\n+\n+To invoke a GraphQL API, see \n+[Invoke a GraphQL API]({{base_path}}/learn/consume-api/invoke-apis/invoke-apis-using-tools/invoke-an-graphql-api-using-the-integrated-graphql-console).\n+\n+To perform **GraphQL Query Depth Limitation**: \n+\n+Enter the following sample query. Then click on execute button as follows.\n+\n+   ```\n+        query{\t\t\t\t\t\t\t\n+            allFilms{\t\t\t\t\t\t\n+                id\t\t\t\t\t\t\t\n+                species{\n+                    id\t\t\t\t\t\t\n+                    films{\n+                        title\t\t\t\t\t\n+                        planets{\n+                            id\t\t\t\t\t\n+                            residents{\n+                                eyeColor\t\t\t\n+                                films{\n+                                    director\t\t\n+                                    producers\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+   ```\n+\n+   [![GraphQL Depth Limitation]({{base_path}}/assets/img/learn/graphql-depth-limitation-query.png)]({{base_path}}/assets/img/learn/graphql-depth-limitation-query.png)\n+\n+You have now **successfully blocked a requested GraphQL query** using the **Max Depth** value that you assigned before.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a79f1f7831bc0fc7206f58a62fd2000052c1938e"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NDk1Nzc5OnYy", "diffSide": "RIGHT", "path": "en/docs/learn/api-security/graphql-query-analysis/query-depth-limitation.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQwODo0NDowMVrOGqKjGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQwODo0NDowMVrOGqKjGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg2NjIwMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Since GraphQL schemas often have circular relationships, the depth can grow till no end. \n          \n          \n            \n            Since GraphQL schemas often have circular relationships, the depth can grow without bounds.", "url": "https://github.com/wso2/docs-apim/pull/1443#discussion_r446866202", "createdAt": "2020-06-29T08:44:01Z", "author": {"login": "fazlan-nazeem"}, "path": "en/docs/learn/api-security/graphql-query-analysis/query-depth-limitation.md", "diffHunk": "@@ -0,0 +1,109 @@\n+Since GraphQL schemas often have circular relationships, the depth can grow till no end. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a79f1f7831bc0fc7206f58a62fd2000052c1938e"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NDk1OTEwOnYy", "diffSide": "RIGHT", "path": "en/docs/learn/api-security/graphql-query-analysis/query-depth-limitation.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQwODo0NDoyMVrOGqKj4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQwODo0NDoyMVrOGqKj4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg2NjQwMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            this means a client could craft a query like this:\n          \n          \n            \n            this means a client could craft a query as follows:", "url": "https://github.com/wso2/docs-apim/pull/1443#discussion_r446866402", "createdAt": "2020-06-29T08:44:21Z", "author": {"login": "fazlan-nazeem"}, "path": "en/docs/learn/api-security/graphql-query-analysis/query-depth-limitation.md", "diffHunk": "@@ -0,0 +1,109 @@\n+Since GraphQL schemas often have circular relationships, the depth can grow till no end. \n+this means a client could craft a query like this:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a79f1f7831bc0fc7206f58a62fd2000052c1938e"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NDk2ODI5OnYy", "diffSide": "RIGHT", "path": "en/docs/learn/api-security/graphql-query-analysis/query-complexity-limitation.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQwODo0Njo0NlrOGqKpew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQwODo0Njo0NlrOGqKpew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg2NzgzNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If there is, no arguments provides in your requested query, can calculate complexity value simply \n          \n          \n            \n            If there are, no arguments provides in your requested query, can calculate complexity value simply by", "url": "https://github.com/wso2/docs-apim/pull/1443#discussion_r446867835", "createdAt": "2020-06-29T08:46:46Z", "author": {"login": "fazlan-nazeem"}, "path": "en/docs/learn/api-security/graphql-query-analysis/query-complexity-limitation.md", "diffHunk": "@@ -0,0 +1,156 @@\n+Often, limiting the depth of a query only is not sufficient to protect a GraphQL service from complex queries. \n+This is due to some fields in a GraphQL schema being more costly to compute than others. WSO2 API-Manager introduces \n+**\u201cQuery Complexity Limitation\u201d** to address such cases. \n+\n+With this strategy, a request allowed or rejected based on the complexity of the query, and the configured max complexity \n+value of the subscription policy for the corresponding API.\n+\n+Here we introduced the **complexity values for each of the Fields** in the schema. That **describes the \n+computation cost of resolving the particular field**. \n+\n+<html>\n+<div class=\"admonition note\">\n+<p class=\"admonition-title\">Note</p>\n+<p>\n+If the field needs to call an expensive service to resolve itself, \n+then the **complexity should be at a high level** but if the field is easy to resolve and not an expensive operation, \n+the **complexity should be at a low level**. If **no complexity defined** for a field, **by default it will get a value of 1.** \n+</p>\n+</div> \n+</html>\n+\n+In run time, we calculate the requested query complexity value. When it exceeds the max complexity, \n+then the query will be **rejected.**\n+\n+Here is a simple example in which you can understand how to calculate query complexity values before request the query.\n+\n+If there is, no arguments provides in your requested query, can calculate complexity value simply ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a79f1f7831bc0fc7206f58a62fd2000052c1938e"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NDk2OTg5OnYy", "diffSide": "RIGHT", "path": "en/docs/learn/api-security/graphql-query-analysis/query-complexity-limitation.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQwODo0NzoxNVrOGqKqdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQwODo0NzoxNVrOGqKqdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg2ODA4Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            With arguments, you can calculate complexity values as follows.\n          \n          \n            \n            With arguments, complexity can be calculated values as follows.", "url": "https://github.com/wso2/docs-apim/pull/1443#discussion_r446868086", "createdAt": "2020-06-29T08:47:15Z", "author": {"login": "fazlan-nazeem"}, "path": "en/docs/learn/api-security/graphql-query-analysis/query-complexity-limitation.md", "diffHunk": "@@ -0,0 +1,156 @@\n+Often, limiting the depth of a query only is not sufficient to protect a GraphQL service from complex queries. \n+This is due to some fields in a GraphQL schema being more costly to compute than others. WSO2 API-Manager introduces \n+**\u201cQuery Complexity Limitation\u201d** to address such cases. \n+\n+With this strategy, a request allowed or rejected based on the complexity of the query, and the configured max complexity \n+value of the subscription policy for the corresponding API.\n+\n+Here we introduced the **complexity values for each of the Fields** in the schema. That **describes the \n+computation cost of resolving the particular field**. \n+\n+<html>\n+<div class=\"admonition note\">\n+<p class=\"admonition-title\">Note</p>\n+<p>\n+If the field needs to call an expensive service to resolve itself, \n+then the **complexity should be at a high level** but if the field is easy to resolve and not an expensive operation, \n+the **complexity should be at a low level**. If **no complexity defined** for a field, **by default it will get a value of 1.** \n+</p>\n+</div> \n+</html>\n+\n+In run time, we calculate the requested query complexity value. When it exceeds the max complexity, \n+then the query will be **rejected.**\n+\n+Here is a simple example in which you can understand how to calculate query complexity values before request the query.\n+\n+If there is, no arguments provides in your requested query, can calculate complexity value simply \n+adding all the complexity values.\n+\n+   ```\n+      query {\n+       \t   allFilms{                   # complexity 1\n+         \t\tid                     # complexity 3\n+        \t\ttitle                  # complexity 1\n+         \t\tplanets {              # complexity 2\n+           \t\t\tclimate            # complexity 1\n+         \t\t}\n+       \t   }\n+      }\n+      \n+      # total complexity = 1 + 2 + 1 + 3 + 1 = 8\n+\n+   ```\n+\n+With arguments, you can calculate complexity values as follows.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a79f1f7831bc0fc7206f58a62fd2000052c1938e"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NDk3MzIwOnYy", "diffSide": "RIGHT", "path": "en/docs/learn/api-security/graphql-query-analysis/query-complexity-limitation.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQwODo0ODoxMFrOGqKseQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQwODo0ODoxMFrOGqKseQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg2ODYwMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In run time, we calculate the requested query complexity value. When it exceeds the max complexity, \n          \n          \n            \n            In run time, requested query complexity value will be calculated and blocked if it exceeds the max complexity,", "url": "https://github.com/wso2/docs-apim/pull/1443#discussion_r446868601", "createdAt": "2020-06-29T08:48:10Z", "author": {"login": "fazlan-nazeem"}, "path": "en/docs/learn/api-security/graphql-query-analysis/query-complexity-limitation.md", "diffHunk": "@@ -0,0 +1,156 @@\n+Often, limiting the depth of a query only is not sufficient to protect a GraphQL service from complex queries. \n+This is due to some fields in a GraphQL schema being more costly to compute than others. WSO2 API-Manager introduces \n+**\u201cQuery Complexity Limitation\u201d** to address such cases. \n+\n+With this strategy, a request allowed or rejected based on the complexity of the query, and the configured max complexity \n+value of the subscription policy for the corresponding API.\n+\n+Here we introduced the **complexity values for each of the Fields** in the schema. That **describes the \n+computation cost of resolving the particular field**. \n+\n+<html>\n+<div class=\"admonition note\">\n+<p class=\"admonition-title\">Note</p>\n+<p>\n+If the field needs to call an expensive service to resolve itself, \n+then the **complexity should be at a high level** but if the field is easy to resolve and not an expensive operation, \n+the **complexity should be at a low level**. If **no complexity defined** for a field, **by default it will get a value of 1.** \n+</p>\n+</div> \n+</html>\n+\n+In run time, we calculate the requested query complexity value. When it exceeds the max complexity, ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a79f1f7831bc0fc7206f58a62fd2000052c1938e"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NDk3OTI1OnYy", "diffSide": "RIGHT", "path": "en/docs/learn/api-security/graphql-query-analysis/query-complexity-limitation.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQwODo0OTo1MVrOGqKwLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQwODo0OTo1MVrOGqKwLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg2OTU0OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Here is a simple example in which you can understand how to calculate query complexity values before request the query.\n          \n          \n            \n            Following is a simple example which can be used to understand how the calculation happens.", "url": "https://github.com/wso2/docs-apim/pull/1443#discussion_r446869548", "createdAt": "2020-06-29T08:49:51Z", "author": {"login": "fazlan-nazeem"}, "path": "en/docs/learn/api-security/graphql-query-analysis/query-complexity-limitation.md", "diffHunk": "@@ -0,0 +1,156 @@\n+Often, limiting the depth of a query only is not sufficient to protect a GraphQL service from complex queries. \n+This is due to some fields in a GraphQL schema being more costly to compute than others. WSO2 API-Manager introduces \n+**\u201cQuery Complexity Limitation\u201d** to address such cases. \n+\n+With this strategy, a request allowed or rejected based on the complexity of the query, and the configured max complexity \n+value of the subscription policy for the corresponding API.\n+\n+Here we introduced the **complexity values for each of the Fields** in the schema. That **describes the \n+computation cost of resolving the particular field**. \n+\n+<html>\n+<div class=\"admonition note\">\n+<p class=\"admonition-title\">Note</p>\n+<p>\n+If the field needs to call an expensive service to resolve itself, \n+then the **complexity should be at a high level** but if the field is easy to resolve and not an expensive operation, \n+the **complexity should be at a low level**. If **no complexity defined** for a field, **by default it will get a value of 1.** \n+</p>\n+</div> \n+</html>\n+\n+In run time, we calculate the requested query complexity value. When it exceeds the max complexity, \n+then the query will be **rejected.**\n+\n+Here is a simple example in which you can understand how to calculate query complexity values before request the query.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a79f1f7831bc0fc7206f58a62fd2000052c1938e"}, "originalPosition": 25}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1625, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}