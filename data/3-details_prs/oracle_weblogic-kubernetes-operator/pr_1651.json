{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE4MzYxMzQx", "number": 1651, "title": "Implement assertion that only maxUnavailable pods are replaced at a time", "bodyText": "Implemented assertion that only maxUnavailable pods are replaced in a rolling restart fashion\nMoved some of the pod assertion methods directly calling Kubernertes primitive to a intermediary Pod class.", "createdAt": "2020-05-15T03:54:57Z", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651", "merged": true, "mergeCommit": {"oid": "25109fb651b75e921e406b109ff95642d84bbb43"}, "closed": true, "closedAt": "2020-05-21T18:20:01Z", "author": {"login": "sankarpn"}, "timelineItems": {"totalCount": 45, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABchV9TegH2gAyNDE4MzYxMzQxOjViMmFlODE5YjRiYTc4MTVhMWM5YTA2MTNhNDM5NjhlZTY2MDI2YTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcjg7AvgFqTQxNjMzNzA1MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5b2ae819b4ba7815a1c9a0613a43968ee66026a7", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5b2ae819b4ba7815a1c9a0613a43968ee66026a7", "committedDate": "2020-05-14T23:20:33Z", "message": "adding assertion to check pods in a given namespace are rolling restarted"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f99f66b94714286f7bd1fb968f4da2c18279664", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/2f99f66b94714286f7bd1fb968f4da2c18279664", "committedDate": "2020-05-14T23:39:06Z", "message": "Fix the parameter orders"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5da038e34e5a89a37a783fab0f213367406d8bd6", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5da038e34e5a89a37a783fab0f213367406d8bd6", "committedDate": "2020-05-15T00:11:42Z", "message": "Fix the pod terminating method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d749f9abb2223e66352fec9eff1c8386e3f3eb9", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5d749f9abb2223e66352fec9eff1c8386e3f3eb9", "committedDate": "2020-05-15T00:55:52Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e098f82282919b4ddabf87c2f31f20fc7929e64c", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e098f82282919b4ddabf87c2f31f20fc7929e64c", "committedDate": "2020-05-15T01:23:01Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c96ff7ae2ed6fa1723916bd8f2303e70d8acabdc", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c96ff7ae2ed6fa1723916bd8f2303e70d8acabdc", "committedDate": "2020-05-15T02:20:19Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d6ee593171202a8d1d2689ba41a3e1659460ba5", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/6d6ee593171202a8d1d2689ba41a3e1659460ba5", "committedDate": "2020-05-15T02:49:51Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2941c09c0b2a392c48a1c10cb3165253230ee5d", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a2941c09c0b2a392c48a1c10cb3165253230ee5d", "committedDate": "2020-05-15T02:52:51Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bbb114894538f078370bfa1cd7c8a84057f666ac", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/bbb114894538f078370bfa1cd7c8a84057f666ac", "committedDate": "2020-05-15T03:11:10Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "300fddbd9f22bc1761eb8f069e24a456baaf3962", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/300fddbd9f22bc1761eb8f069e24a456baaf3962", "committedDate": "2020-05-15T04:02:44Z", "message": "Fix the javadocs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b", "committedDate": "2020-05-15T04:53:11Z", "message": "wip"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyNjg0MTg2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#pullrequestreview-412684186", "createdAt": "2020-05-15T14:11:07Z", "commit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNDoxMTowOFrOGWGiXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNDoxMTowOFrOGWGiXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgyODk1Nw==", "bodyText": "I could be wrong, but I suspect there may be multiple issues with this assertion, some of it functional, some of it due to incompleteness.  All of the following should be double checked with Ryan, Lenny, and Anthony:\n\n\nSeems to assume a single cluster and no non-clustered servers. Consequently, this test seems to assume that only one server can go down a time.  This is incorrect when there are multiple clusters, unmanaged servers, a replica count change, or a deleted cluster.\n\n\nSeems to dynamically obtain a list of servers when checking if only one server is 'down'.  IMO, it'd be better to get the list of servers at the beginning of a test before any changes are made to initiate the roll (otherwise, it won't catch if two servers in the cluster 'disappear' at the same time).  This 'original list' should be then compared to what's expected by the domain resource in terms of replicas, restartVersions, and image in order to determine the expected behavior for the roll.\n\n\nNote that this may get a little tricky when 'replicas' changes at the same time as everything else.  When replicas increases, the number of 'not ready' can be higher than 1 since the replicas are allowed to start in parallel.   When replicas decreases I assume (but am not sure) the roll is expected to defer terminating the servers until after it's completed the roll of the previous servers, and then only terminate them one at a time.   Similar issues may be seen when a cluster is deleted (the roll doesn't apply in that case I assume) or a new cluster is added (multiple servers can start at once).\n\n\nSeems to use 'Terminating' as a criteria when checking if a single server is down. For any particular domain it should check the admin server is ready - if not, then the admin server should be the only cycling server.  Then it should check that all other servers are 'ready' except one for their particular cluster as compared to the list of pods obtained at the beginning of the test (except in the case of varying replicas).\n\n\nDoes not seem to verify that admin server always is 'ahead' of other servers (first to roll and reach target state, and only one that should be down until this occurs)?\n\n\nDoes not verify that rolls are expected to occur 'in order' within a given cluster.\n\n\nAt the conclusion of the test, does not check if all servers have (a) reached their target domain/cluster/server restartVersion and (b) reached their target image.  (This should be done in addition to checking for  'ready' state.)", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r425828957", "createdAt": "2020-05-15T14:11:08Z", "author": {"login": "tbarnes-us"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);\n+      for (V1Pod item : listPods.getItems()) {\n+        logger.info(item.getMetadata().getName());\n+        podNames.add(item.getMetadata().getName());\n+      }\n+    }\n+\n+    // check the pods termination status in concurrent thread\n+    ExecutorService executorService = Executors.newFixedThreadPool(podNames.size());\n+    ArrayList<Future<Boolean>> threads = new ArrayList<Future<Boolean>>();\n+    for (var podName : podNames) {\n+      // check for pod termination status and return true if pod is terminating\n+      threads.add(executorService.submit(() -> {\n+        retry\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for pod {0} in namespace {1} to terminate\"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                    podName,\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(onlyGivenPodTerminating(podName, domainUid, namespace));\n+        return true;\n+      }));\n+      // wait for the callable to finish running and check if all pods were terminating\n+      for (var future : threads) {\n+        if (!future.get(10, MINUTES)) {\n+          return false;\n+        }\n+      }\n+    }\n+    executorService.shutdownNow();\n+\n+    // wait for pods to become ready\n+    for (var podName : podNames) {\n+      logger.info(\"Wait for pod {0} to be ready in namespace {1}\", podName, namespace);\n+      retry\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                  + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                  podName,\n+                  namespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> podReady(namespace, domainUid, podName),\n+              String.format(\n+                  \"pod %s is not ready in namespace %s\", podName, namespace)));\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Return true if the given pod is the only one terminating.\n+   *\n+   * @param podName name of pod to check for termination status\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which the pod is running\n+   * @return true if given pod is terminating otherwise false\n+   * @throws Exception when more than one pod is terminating or cluster query fails\n+   */\n+  private static Callable<Boolean> onlyGivenPodTerminating(String podName, String domainUid, String namespace)\n+      throws Exception {\n+    return () -> {\n+      String labelSelectors = String.format(\"weblogic.serverName\", domainUid);\n+      V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+      if (listPods.getItems().isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 122}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMTIzMDUy", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#pullrequestreview-413123052", "createdAt": "2020-05-17T02:56:12Z", "commit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QwMjo1NjoxMlrOGWd4BQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QwMzowMjo0MVrOGWd5Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTMzMw==", "bodyText": "up to ten minutes", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211333", "createdAt": "2020-05-17T02:56:12Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTM2NQ==", "bodyText": "method name seems wrong, something like verifyRollingRestartOccurred maybe?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211365", "createdAt": "2020-05-17T02:57:03Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTQyNg==", "bodyText": "but your logic below seems to wait longer than ten minutes", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211426", "createdAt": "2020-05-17T02:58:12Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTMzMw=="}, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTQ2NA==", "bodyText": "something seems wrong here - what it you call this too late?\nseems like this needs to be some kind of \"watcher\" than can be started before you initiate the roll, and collect a future/promise/whatever from it afterwards/later", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211464", "createdAt": "2020-05-17T02:59:22Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTQ3Mw==", "bodyText": "how do you know you found all of the expected pods? again, there is a timing issue here", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211473", "createdAt": "2020-05-17T02:59:46Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTUyOQ==", "bodyText": "check that all of the pods are in termination status in a set of concurrent threads", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211529", "createdAt": "2020-05-17T03:00:18Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);\n+      for (V1Pod item : listPods.getItems()) {\n+        logger.info(item.getMetadata().getName());\n+        podNames.add(item.getMetadata().getName());\n+      }\n+    }\n+\n+    // check the pods termination status in concurrent thread", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTU0Nw==", "bodyText": "again, not sure this is a good idea when you are running under maven/failsafe plugin", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211547", "createdAt": "2020-05-17T03:00:39Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);\n+      for (V1Pod item : listPods.getItems()) {\n+        logger.info(item.getMetadata().getName());\n+        podNames.add(item.getMetadata().getName());\n+      }\n+    }\n+\n+    // check the pods termination status in concurrent thread\n+    ExecutorService executorService = Executors.newFixedThreadPool(podNames.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTU5NA==", "bodyText": "you could just use the kubernetes get pods api and set watch = true .....", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211594", "createdAt": "2020-05-17T03:01:29Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);\n+      for (V1Pod item : listPods.getItems()) {\n+        logger.info(item.getMetadata().getName());\n+        podNames.add(item.getMetadata().getName());\n+      }\n+    }\n+\n+    // check the pods termination status in concurrent thread\n+    ExecutorService executorService = Executors.newFixedThreadPool(podNames.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTU0Nw=="}, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTYxMA==", "bodyText": "do you need to wait for them to be ready, or just running?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211610", "createdAt": "2020-05-17T03:02:03Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);\n+      for (V1Pod item : listPods.getItems()) {\n+        logger.info(item.getMetadata().getName());\n+        podNames.add(item.getMetadata().getName());\n+      }\n+    }\n+\n+    // check the pods termination status in concurrent thread\n+    ExecutorService executorService = Executors.newFixedThreadPool(podNames.size());\n+    ArrayList<Future<Boolean>> threads = new ArrayList<Future<Boolean>>();\n+    for (var podName : podNames) {\n+      // check for pod termination status and return true if pod is terminating\n+      threads.add(executorService.submit(() -> {\n+        retry\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for pod {0} in namespace {1} to terminate\"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                    podName,\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(onlyGivenPodTerminating(podName, domainUid, namespace));\n+        return true;\n+      }));\n+      // wait for the callable to finish running and check if all pods were terminating\n+      for (var future : threads) {\n+        if (!future.get(10, MINUTES)) {\n+          return false;\n+        }\n+      }\n+    }\n+    executorService.shutdownNow();\n+\n+    // wait for pods to become ready\n+    for (var podName : podNames) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTYzNQ==", "bodyText": "this will wait another ten minutes right?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211635", "createdAt": "2020-05-17T03:02:41Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);\n+      for (V1Pod item : listPods.getItems()) {\n+        logger.info(item.getMetadata().getName());\n+        podNames.add(item.getMetadata().getName());\n+      }\n+    }\n+\n+    // check the pods termination status in concurrent thread\n+    ExecutorService executorService = Executors.newFixedThreadPool(podNames.size());\n+    ArrayList<Future<Boolean>> threads = new ArrayList<Future<Boolean>>();\n+    for (var podName : podNames) {\n+      // check for pod termination status and return true if pod is terminating\n+      threads.add(executorService.submit(() -> {\n+        retry\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for pod {0} in namespace {1} to terminate\"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                    podName,\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(onlyGivenPodTerminating(podName, domainUid, namespace));\n+        return true;\n+      }));\n+      // wait for the callable to finish running and check if all pods were terminating\n+      for (var future : threads) {\n+        if (!future.get(10, MINUTES)) {\n+          return false;\n+        }\n+      }\n+    }\n+    executorService.shutdownNow();\n+\n+    // wait for pods to become ready\n+    for (var podName : podNames) {\n+      logger.info(\"Wait for pod {0} to be ready in namespace {1}\", podName, namespace);\n+      retry", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 92}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29ddbf8fe8e094b921c2699adf43ea4f9653cf03", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/29ddbf8fe8e094b921c2699adf43ea4f9653cf03", "committedDate": "2020-05-18T19:26:54Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into assertrollingrestart"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc3e0cd84e6deff648b908aff24921a2700dbfbb", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/cc3e0cd84e6deff648b908aff24921a2700dbfbb", "committedDate": "2020-05-18T20:06:53Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into assertrollingrestart"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c355db5e3e0088c61265dae28af332647459c63c", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c355db5e3e0088c61265dae28af332647459c63c", "committedDate": "2020-05-18T20:56:38Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "044ce2a9b3d9d4a2299b14699fb1744609ca25ee", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/044ce2a9b3d9d4a2299b14699fb1744609ca25ee", "committedDate": "2020-05-18T21:36:20Z", "message": "changed the logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f6ded5a2e0781c3477b7151b3f52660d9a473cb", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8f6ded5a2e0781c3477b7151b3f52660d9a473cb", "committedDate": "2020-05-18T22:06:32Z", "message": "p# Please enter the commit message for your changes. Lines starting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7ca17a9333e96d196fbaf17e16130c0cbb349c6", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e7ca17a9333e96d196fbaf17e16130c0cbb349c6", "committedDate": "2020-05-18T22:32:37Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "611b96cc93b5568fbfd6f7116e5a07a51b6e769d", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/611b96cc93b5568fbfd6f7116e5a07a51b6e769d", "committedDate": "2020-05-18T23:25:57Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5290039fc17219398c90156cf94f9b5447d4335c", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5290039fc17219398c90156cf94f9b5447d4335c", "committedDate": "2020-05-19T15:41:11Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "804cec5f35f49820b867c1e84e298114c7ce0669", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/804cec5f35f49820b867c1e84e298114c7ce0669", "committedDate": "2020-05-19T15:52:10Z", "message": "refactor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NjQwOTU2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#pullrequestreview-414640956", "createdAt": "2020-05-19T16:52:49Z", "commit": {"oid": "804cec5f35f49820b867c1e84e298114c7ce0669"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNjo1Mjo1MFrOGXpokw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNjo1Mjo1MFrOGXpokw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ1MjU2Mw==", "bodyText": "You assume the pods will be terminated in a specific order. This needs to match how operator does the termination.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r427452563", "createdAt": "2020-05-19T16:52:50Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check pods are restarted in the same order as in the pods list.\n+   * @param pods names of the pods in a list\n+   * @param namespace name of the namespace in which to check for pods rolling restart\n+   * @return true if pods are restarted in rolling fashion\n+   */\n+  public static boolean verifyRollingRestartOccurred(ArrayList<String> pods, String namespace) {\n+\n+    // check the pods list is not empty\n+    if (pods.isEmpty()) {\n+      logger.severe(\"The pods list is empty\");\n+      return false;\n+    }\n+\n+    // reusable condition factory\n+    ConditionFactory retry\n+        = with().pollInterval(5, SECONDS).atMost(5, MINUTES).await();\n+\n+    // check pods are terminated and started.\n+    for (var pod : pods) {\n+      retry\n+          .conditionEvaluationListener(condition -> logger.info(\"Waiting for pod {0} to be \"\n+          + \"terminating in namespace {1} \"\n+          + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+          pod,\n+          namespace,\n+          condition.getElapsedTimeInMS(),\n+          condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> onlyGivenPodTerminating(pods, pod, namespace),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "804cec5f35f49820b867c1e84e298114c7ce0669"}, "originalPosition": 47}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "971efd49234fbbbb4a935d8fe3f479fd23865e49", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/971efd49234fbbbb4a935d8fe3f479fd23865e49", "committedDate": "2020-05-19T19:01:10Z", "message": "wip"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0ODAzNDM3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#pullrequestreview-414803437", "createdAt": "2020-05-19T20:36:38Z", "commit": {"oid": "971efd49234fbbbb4a935d8fe3f479fd23865e49"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDozNjozOVrOGXxqSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDozNjozOVrOGXxqSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4NDA3NQ==", "bodyText": "print the pod names that are terminating", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r427584075", "createdAt": "2020-05-19T20:36:39Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check pods are restarted in the same order as in the pods list.\n+   * @param pods names of the pods in a list\n+   * @param namespace name of the namespace in which to check for pods rolling restart\n+   * @return true if pods are restarted in rolling fashion\n+   */\n+  public static boolean verifyRollingRestartOccurred(ArrayList<String> pods, String namespace) {\n+\n+    // check the pods list is not empty\n+    if (pods.isEmpty()) {\n+      logger.severe(\"The pods list is empty\");\n+      return false;\n+    }\n+\n+    // reusable condition factory\n+    ConditionFactory retry\n+        = with().pollInterval(5, SECONDS).atMost(5, MINUTES).await();\n+\n+    // check pods are terminated and started.\n+    for (var pod : pods) {\n+      retry\n+          .conditionEvaluationListener(condition -> logger.info(\"Waiting for pod {0} to be \"\n+          + \"terminating in namespace {1} \"\n+          + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+          pod,\n+          namespace,\n+          condition.getElapsedTimeInMS(),\n+          condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> onlyGivenPodTerminating(pods, pod, namespace),\n+              String.format(\"pod %s didn't terminate in namespace %s\", pod, namespace)));\n+\n+      retry\n+          .conditionEvaluationListener(condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+          + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+          pod,\n+          namespace,\n+          condition.getElapsedTimeInMS(),\n+          condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> podReady(namespace, null, pod),\n+              String.format(\"pod %s is not ready in namespace %s\", pod, namespace)));\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Return true if the given pod is the only one terminating from the list of pods.\n+   *\n+   * @param pods names of the pods in a list\n+   * @param podName name of pod to check for termination status\n+   * @param namespace name of the namespace in which the pod terminating status to be checked\n+   * @return true if given pod is the only pod terminating\n+   * @throws Exception when more than one pod is terminating or cluster query fails\n+   */\n+  public static Callable<Boolean> onlyGivenPodTerminating(ArrayList<String> pods, String podName, String namespace)\n+      throws Exception {\n+    return () -> {\n+      int terminatingPods = 0;\n+      boolean givenPodTerminating = false;\n+      for (var pod : pods) {\n+        if (Kubernetes.isPodTerminating(namespace, null, pod)) {\n+          terminatingPods++;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "971efd49234fbbbb4a935d8fe3f479fd23865e49"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0ODA2OTU4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#pullrequestreview-414806958", "createdAt": "2020-05-19T20:41:56Z", "commit": {"oid": "971efd49234fbbbb4a935d8fe3f479fd23865e49"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDo0MTo1NlrOGXx1cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDo0MTo1NlrOGXx1cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4NjkzMQ==", "bodyText": "get the pods list before patching domain", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r427586931", "createdAt": "2020-05-19T20:41:56Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -372,6 +374,16 @@ public void testCreateMiiConfigMapDomain() {\n         \"patchDomainCustomResource(restartVersion)  failed \");\n     assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n \n+    ArrayList<String> pods = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "971efd49234fbbbb4a935d8fe3f479fd23865e49"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0ODExNjk0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#pullrequestreview-414811694", "createdAt": "2020-05-19T20:49:03Z", "commit": {"oid": "971efd49234fbbbb4a935d8fe3f479fd23865e49"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDo0OTowM1rOGXyEjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDo0OTowM1rOGXyEjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU5MDc5Ng==", "bodyText": "Check only one pod is restarted at a time in the same order as in the pods list ...", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r427590796", "createdAt": "2020-05-19T20:49:03Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check pods are restarted in the same order as in the pods list.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "971efd49234fbbbb4a935d8fe3f479fd23865e49"}, "originalPosition": 20}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5", "committedDate": "2020-05-19T21:14:57Z", "message": "Address review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1NDc0ODM3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#pullrequestreview-415474837", "createdAt": "2020-05-20T15:47:49Z", "commit": {"oid": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNTo0Nzo1MFrOGYSUyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNTo0Nzo1MFrOGYSUyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExOTI0Mw==", "bodyText": "I have a use case where I want to verify there I want to see the rolling restart should shutdown 2 servers simultaneously where the maxUnavailable attribute is set to 2.  In this case what will be my pod list?  Say I have 1 admin and 3 managed servers ( ms1,ms2, and ms3 ) Here  I should see ms1 and ms2 can both go to terminating state simultaneously while ms3 will be re-stated after both ms1 and ms2 are up", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428119243", "createdAt": "2020-05-20T15:47:50Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check only one pod is restarted at a time in the same order as in the pods list.\n+   * This assertion method needs to be called right after the domain is patched to ensure\n+   * it doesn't miss any of the pods restart.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1NDg1MDM0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#pullrequestreview-415485034", "createdAt": "2020-05-20T15:58:57Z", "commit": {"oid": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNTo1ODo1N1rOGYSziA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNTo1ODo1N1rOGYSziA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyNzExMg==", "bodyText": "Type of argument can just be List", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428127112", "createdAt": "2020-05-20T15:58:57Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -157,9 +160,20 @@\n    * @return true if the pod is terminating otherwise false\n    */\n   public static Callable<Boolean> podTerminating(String podName, String domainUid, String namespace) {\n-    return () -> Kubernetes.isPodTerminating(namespace, domainUid, podName);\n+    return Pod.podTerminating(namespace, domainUid, podName);\n   }\n \n+  /**\n+   * Check pods are restarted in the same order as in the pods list.\n+   * @param pods names of the pods in a list\n+   * @param namespace name of the namespace in which to check for pods rolling restart\n+   * @return true if pods are restarted in rolling fashion\n+   */\n+  public static boolean verifyRollingRestartOccurred(ArrayList<String> pods, String namespace) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1NDg3MTQ4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#pullrequestreview-415487148", "createdAt": "2020-05-20T16:01:11Z", "commit": {"oid": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNjowMToxMVrOGYS5zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNjowMToxMVrOGYS5zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyODcxOA==", "bodyText": "As an alternative, you can check that the pod's metadata.deletionTimestamp is set. If this field has a value, then the pod has been marked for deletion. It will either then be in it's terminating phase or soon will be.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428128718", "createdAt": "2020-05-20T16:01:11Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -154,27 +153,30 @@ public static boolean isPodReady(String namespace, String domainUid, String podN\n   }\n \n   /**\n-   * Checks if a pod exists in a given namespace and in Terminating state.\n+   * Check if a pod exists in a given namespace and is terminating.\n    * @param namespace in which to check for the pod\n    * @param domainUid the label the pod is decorated with\n    * @param podName name of the pod to check for\n-   * @return true if pod is in Terminating state otherwise false\n+   * @return true if pod is terminating otherwise false\n    * @throws ApiException when there is error in querying the cluster\n    */\n-  public static boolean isPodTerminating(String namespace, String domainUid, String podName) throws ApiException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1NDkxNjQw", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#pullrequestreview-415491640", "createdAt": "2020-05-20T16:06:16Z", "commit": {"oid": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNjowNjoxNlrOGYTHhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNjowNjoxNlrOGYTHhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzMjIzMQ==", "bodyText": "On this statement: \"This assertion method needs to be called right after the domain is patched to ensure it doesn't miss any of the pods restart.\"...  This seems likely to intermittently fail. I think it would be better to collect the current V1PodList in advance of starting the roll and using that as the input.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428132231", "createdAt": "2020-05-20T16:06:16Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check only one pod is restarted at a time in the same order as in the pods list.\n+   * This assertion method needs to be called right after the domain is patched to ensure\n+   * it doesn't miss any of the pods restart.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1NDkzNDM0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#pullrequestreview-415493434", "createdAt": "2020-05-20T16:08:24Z", "commit": {"oid": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNjowODoyNFrOGYTNBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNjowODoyNFrOGYTNBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzMzYzNg==", "bodyText": "Not sure if I've read this correctly, but even though WebLogic terminates and restarts slowly, I'd like the code to be defensive to the condition that you missed detecting the termination. It would be enough to find that the \"new\" Pod has a creation timestamp later than when the roll started.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428133636", "createdAt": "2020-05-20T16:08:24Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check only one pod is restarted at a time in the same order as in the pods list.\n+   * This assertion method needs to be called right after the domain is patched to ensure\n+   * it doesn't miss any of the pods restart.\n+   * @param pods names of the pods in a list\n+   * @param namespace name of the namespace in which to check for pods rolling restart\n+   * @return true if pods are restarted in rolling fashion\n+   */\n+  public static boolean verifyRollingRestartOccurred(ArrayList<String> pods, String namespace) {\n+\n+    // check the pods list is not empty\n+    if (pods.isEmpty()) {\n+      logger.severe(\"The pods list is empty\");\n+      return false;\n+    }\n+\n+    // reusable condition factory\n+    ConditionFactory retry\n+        = with().pollInterval(5, SECONDS).atMost(5, MINUTES).await();\n+\n+    // check pods are terminated and started.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5"}, "originalPosition": 39}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c6726ea3c42a88bb4cb8357eb3a51fe53e6e540", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8c6726ea3c42a88bb4cb8357eb3a51fe53e6e540", "committedDate": "2020-05-20T20:18:18Z", "message": "Addressing review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d00dccaad2ef0eb830ca163da9026de51085e8f3", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d00dccaad2ef0eb830ca163da9026de51085e8f3", "committedDate": "2020-05-20T20:19:05Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into assertrollingrestart"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "014a7cf057a2098e8f09a0db73efaac79dcdaaa9", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/014a7cf057a2098e8f09a0db73efaac79dcdaaa9", "committedDate": "2020-05-20T21:04:08Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9eb968d8047674f1a4e7618b7b011825a59d8cf2", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9eb968d8047674f1a4e7618b7b011825a59d8cf2", "committedDate": "2020-05-20T21:09:54Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62f0f87c96c2a950ff7c4675bc194527baf8e76d", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/62f0f87c96c2a950ff7c4675bc194527baf8e76d", "committedDate": "2020-05-20T21:18:59Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ccd405d6eebb15da9e87d1fdada88192a31eca3e", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/ccd405d6eebb15da9e87d1fdada88192a31eca3e", "committedDate": "2020-05-20T21:24:02Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c63f887ad26cdff57bb45a2cfde4b853f3127fc3", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c63f887ad26cdff57bb45a2cfde4b853f3127fc3", "committedDate": "2020-05-20T21:40:50Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "214e8f1555af22802e5b15b8ce6a8c82d8fb917a", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/214e8f1555af22802e5b15b8ce6a8c82d8fb917a", "committedDate": "2020-05-20T22:15:02Z", "message": "null check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44ca6bf7fdd5f41763cad0e72ee7f031f6fc724c", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/44ca6bf7fdd5f41763cad0e72ee7f031f6fc724c", "committedDate": "2020-05-20T22:37:47Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2a5c593daa9995cacff6410c44cf4b6a5a5aa4a", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b2a5c593daa9995cacff6410c44cf4b6a5a5aa4a", "committedDate": "2020-05-21T16:03:38Z", "message": "Merge branch 'develop' into assertrollingrestart"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2MzM1MjI0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#pullrequestreview-416335224", "createdAt": "2020-05-21T17:12:29Z", "commit": {"oid": "b2a5c593daa9995cacff6410c44cf4b6a5a5aa4a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2MzM3MDUx", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#pullrequestreview-416337051", "createdAt": "2020-05-21T17:14:51Z", "commit": {"oid": "b2a5c593daa9995cacff6410c44cf4b6a5a5aa4a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4803, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}