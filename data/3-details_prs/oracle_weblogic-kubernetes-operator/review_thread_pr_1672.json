{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIxNzQ5NTQy", "number": 1672, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxODoxMzozMlrOD_CI2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMToyODoyOVrOEASA6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDIxOTEyOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSessionMigration.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxODoxMzozMlrOGZf2jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMzo0MDoyOVrOGZl_4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM4OTQ1NA==", "bodyText": "Provide the javadoc descrbing the usecase detail", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1672#discussion_r429389454", "createdAt": "2020-05-22T18:13:32Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSessionMigration.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import com.google.common.primitives.Ints;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownManagedServerUsingServerStartPolicy;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+/**\n+ * Verify that when the primary server is down, another server takes on its clients\n+ * to become the new primary server and HTTP session state is migrated to the new primary server.\n+ */\n+@DisplayName(\"Test the HTTP session replication features of WebLogic\")\n+@IntegrationTest\n+class ItSessionMigration implements LoggedTest {\n+\n+  // constants for creating domain image using model in image\n+  private static final String SESSMIGR_MODEL_FILE = \"model.sessmigr.yaml\";\n+  private static final String SESSMIGR_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String SESSMIGR_APP_NAME = \"sessmigr-app\";\n+  private static final String SESSMIGR_APP_WAR_NAME = \"sessmigr-war\";\n+  private static final int SESSION_STATE = 4;\n+  private static Map<String, String> httpAttrMap;\n+\n+  // constants for Operator and WebLogic domain\n+  private static String domainUid = \"sessmigr-domain-1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int replicaCount = 2;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  /**\n+   * Install Operator, create a custom image using model in image with model files\n+   * and create a one cluster domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a unique Operator namespace\n+    logger.info(\"Get a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify Operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName);\n+\n+    // map to save HTTP response data\n+    httpAttrMap = new HashMap<String, String>();\n+    httpAttrMap.put(\"sessioncreatetime\", \"(.*)sessioncreatetime>(.*)</sessioncreatetime(.*)\");\n+    httpAttrMap.put(\"sessionid\", \"(.*)sessionid>(.*)</sessionid(.*)\");\n+    httpAttrMap.put(\"primary\", \"(.*)primary>(.*)</primary(.*)\");\n+    httpAttrMap.put(\"secondary\", \"(.*)secondary>(.*)</secondary(.*)\");\n+    httpAttrMap.put(\"count\", \"(.*)countattribute>(.*)</countattribute(.*)\");\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"getOrigServerAndSessionInfo\")\n+  @DisplayName(\"Stop the primary server, verify that a new primary server is picked and HTTP session state is migrated\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21fa3422bc43ccacf4b3f58af78a757484035650"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5MDE0Nw==", "bodyText": "Added", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1672#discussion_r429490147", "createdAt": "2020-05-22T23:40:29Z", "author": {"login": "hzhao-github"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSessionMigration.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import com.google.common.primitives.Ints;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownManagedServerUsingServerStartPolicy;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+/**\n+ * Verify that when the primary server is down, another server takes on its clients\n+ * to become the new primary server and HTTP session state is migrated to the new primary server.\n+ */\n+@DisplayName(\"Test the HTTP session replication features of WebLogic\")\n+@IntegrationTest\n+class ItSessionMigration implements LoggedTest {\n+\n+  // constants for creating domain image using model in image\n+  private static final String SESSMIGR_MODEL_FILE = \"model.sessmigr.yaml\";\n+  private static final String SESSMIGR_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String SESSMIGR_APP_NAME = \"sessmigr-app\";\n+  private static final String SESSMIGR_APP_WAR_NAME = \"sessmigr-war\";\n+  private static final int SESSION_STATE = 4;\n+  private static Map<String, String> httpAttrMap;\n+\n+  // constants for Operator and WebLogic domain\n+  private static String domainUid = \"sessmigr-domain-1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int replicaCount = 2;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  /**\n+   * Install Operator, create a custom image using model in image with model files\n+   * and create a one cluster domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a unique Operator namespace\n+    logger.info(\"Get a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify Operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName);\n+\n+    // map to save HTTP response data\n+    httpAttrMap = new HashMap<String, String>();\n+    httpAttrMap.put(\"sessioncreatetime\", \"(.*)sessioncreatetime>(.*)</sessioncreatetime(.*)\");\n+    httpAttrMap.put(\"sessionid\", \"(.*)sessionid>(.*)</sessionid(.*)\");\n+    httpAttrMap.put(\"primary\", \"(.*)primary>(.*)</primary(.*)\");\n+    httpAttrMap.put(\"secondary\", \"(.*)secondary>(.*)</secondary(.*)\");\n+    httpAttrMap.put(\"count\", \"(.*)countattribute>(.*)</countattribute(.*)\");\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"getOrigServerAndSessionInfo\")\n+  @DisplayName(\"Stop the primary server, verify that a new primary server is picked and HTTP session state is migrated\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM4OTQ1NA=="}, "originalCommit": {"oid": "21fa3422bc43ccacf4b3f58af78a757484035650"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDIyMjY2OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSessionMigration.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxODoxNTowNVrOGZf43w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMzo0MDozN1rOGZl_7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM5MDA0Nw==", "bodyText": "remove extra : after \" primary server changes to\"", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1672#discussion_r429390047", "createdAt": "2020-05-22T18:15:05Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSessionMigration.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import com.google.common.primitives.Ints;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownManagedServerUsingServerStartPolicy;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+/**\n+ * Verify that when the primary server is down, another server takes on its clients\n+ * to become the new primary server and HTTP session state is migrated to the new primary server.\n+ */\n+@DisplayName(\"Test the HTTP session replication features of WebLogic\")\n+@IntegrationTest\n+class ItSessionMigration implements LoggedTest {\n+\n+  // constants for creating domain image using model in image\n+  private static final String SESSMIGR_MODEL_FILE = \"model.sessmigr.yaml\";\n+  private static final String SESSMIGR_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String SESSMIGR_APP_NAME = \"sessmigr-app\";\n+  private static final String SESSMIGR_APP_WAR_NAME = \"sessmigr-war\";\n+  private static final int SESSION_STATE = 4;\n+  private static Map<String, String> httpAttrMap;\n+\n+  // constants for Operator and WebLogic domain\n+  private static String domainUid = \"sessmigr-domain-1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int replicaCount = 2;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  /**\n+   * Install Operator, create a custom image using model in image with model files\n+   * and create a one cluster domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a unique Operator namespace\n+    logger.info(\"Get a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify Operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName);\n+\n+    // map to save HTTP response data\n+    httpAttrMap = new HashMap<String, String>();\n+    httpAttrMap.put(\"sessioncreatetime\", \"(.*)sessioncreatetime>(.*)</sessioncreatetime(.*)\");\n+    httpAttrMap.put(\"sessionid\", \"(.*)sessionid>(.*)</sessionid(.*)\");\n+    httpAttrMap.put(\"primary\", \"(.*)primary>(.*)</primary(.*)\");\n+    httpAttrMap.put(\"secondary\", \"(.*)secondary>(.*)</secondary(.*)\");\n+    httpAttrMap.put(\"count\", \"(.*)countattribute>(.*)</countattribute(.*)\");\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"getOrigServerAndSessionInfo\")\n+  @DisplayName(\"Stop the primary server, verify that a new primary server is picked and HTTP session state is migrated\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testSessionMigration(String origPrimaryServerName,\n+                                   String origSecondaryServerName,\n+                                   String origSessionCreateTime) {\n+    final String sessionCreateTimeAttr = \"sessioncreatetime\";\n+    final String primaryServerAttr = \"primary\";\n+    final String countAttr = \"count\";\n+    final String webServiceGetUrl = SESSMIGR_APP_WAR_NAME + \"/?getCounter\";\n+\n+    logger.info(\"Got the primary server: {0}, the secondary server: {1} \"\n+        + \"and session create time: {2} from the factory method getOrigServerAndSessionInfo\",\n+            origPrimaryServerName, origSecondaryServerName, origSessionCreateTime);\n+\n+    // stop the primary server by changing ServerStartPolicy to NEVER and patching domain\n+    logger.info(\"Shut down the primary server: {0}\", origPrimaryServerName);\n+    shutdownServerUsingServerStartPolicy(origPrimaryServerName);\n+\n+    // get HTTP response data from web service deployed on the cluster\n+    Map<String, String> httpDataInfo =\n+        processHttpRequest(domainUid + \"-\" + origSecondaryServerName,\n+            webServiceGetUrl, \" -b \");\n+    String primaryServerName = httpDataInfo.get(primaryServerAttr);\n+    String sessionCreateTime = httpDataInfo.get(sessionCreateTimeAttr);\n+    String countStr = httpDataInfo.get(countAttr);\n+\n+    // verify that the HTTP response data are not null\n+    assertAll(\"Check that WebLogic server and session vars is not null or empty\",\n+        () -> assertNotNull(primaryServerName,\"Primary server name shouldn\u2019t be null\"),\n+        () -> assertNotNull(sessionCreateTime,\"Session create time shouldn\u2019t be null\"),\n+        () -> assertNotNull(countStr,\"Session state shouldn\u2019t be null\")\n+    );\n+\n+    int count = Optional.ofNullable(countStr).map(Ints::tryParse).orElse(0);\n+\n+    logger.info(\"After patching the domain, the primary server changes to : {0} \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21fa3422bc43ccacf4b3f58af78a757484035650"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5MDE1OA==", "bodyText": "removed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1672#discussion_r429490158", "createdAt": "2020-05-22T23:40:37Z", "author": {"login": "hzhao-github"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSessionMigration.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import com.google.common.primitives.Ints;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownManagedServerUsingServerStartPolicy;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+/**\n+ * Verify that when the primary server is down, another server takes on its clients\n+ * to become the new primary server and HTTP session state is migrated to the new primary server.\n+ */\n+@DisplayName(\"Test the HTTP session replication features of WebLogic\")\n+@IntegrationTest\n+class ItSessionMigration implements LoggedTest {\n+\n+  // constants for creating domain image using model in image\n+  private static final String SESSMIGR_MODEL_FILE = \"model.sessmigr.yaml\";\n+  private static final String SESSMIGR_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String SESSMIGR_APP_NAME = \"sessmigr-app\";\n+  private static final String SESSMIGR_APP_WAR_NAME = \"sessmigr-war\";\n+  private static final int SESSION_STATE = 4;\n+  private static Map<String, String> httpAttrMap;\n+\n+  // constants for Operator and WebLogic domain\n+  private static String domainUid = \"sessmigr-domain-1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int replicaCount = 2;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  /**\n+   * Install Operator, create a custom image using model in image with model files\n+   * and create a one cluster domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a unique Operator namespace\n+    logger.info(\"Get a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify Operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName);\n+\n+    // map to save HTTP response data\n+    httpAttrMap = new HashMap<String, String>();\n+    httpAttrMap.put(\"sessioncreatetime\", \"(.*)sessioncreatetime>(.*)</sessioncreatetime(.*)\");\n+    httpAttrMap.put(\"sessionid\", \"(.*)sessionid>(.*)</sessionid(.*)\");\n+    httpAttrMap.put(\"primary\", \"(.*)primary>(.*)</primary(.*)\");\n+    httpAttrMap.put(\"secondary\", \"(.*)secondary>(.*)</secondary(.*)\");\n+    httpAttrMap.put(\"count\", \"(.*)countattribute>(.*)</countattribute(.*)\");\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"getOrigServerAndSessionInfo\")\n+  @DisplayName(\"Stop the primary server, verify that a new primary server is picked and HTTP session state is migrated\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testSessionMigration(String origPrimaryServerName,\n+                                   String origSecondaryServerName,\n+                                   String origSessionCreateTime) {\n+    final String sessionCreateTimeAttr = \"sessioncreatetime\";\n+    final String primaryServerAttr = \"primary\";\n+    final String countAttr = \"count\";\n+    final String webServiceGetUrl = SESSMIGR_APP_WAR_NAME + \"/?getCounter\";\n+\n+    logger.info(\"Got the primary server: {0}, the secondary server: {1} \"\n+        + \"and session create time: {2} from the factory method getOrigServerAndSessionInfo\",\n+            origPrimaryServerName, origSecondaryServerName, origSessionCreateTime);\n+\n+    // stop the primary server by changing ServerStartPolicy to NEVER and patching domain\n+    logger.info(\"Shut down the primary server: {0}\", origPrimaryServerName);\n+    shutdownServerUsingServerStartPolicy(origPrimaryServerName);\n+\n+    // get HTTP response data from web service deployed on the cluster\n+    Map<String, String> httpDataInfo =\n+        processHttpRequest(domainUid + \"-\" + origSecondaryServerName,\n+            webServiceGetUrl, \" -b \");\n+    String primaryServerName = httpDataInfo.get(primaryServerAttr);\n+    String sessionCreateTime = httpDataInfo.get(sessionCreateTimeAttr);\n+    String countStr = httpDataInfo.get(countAttr);\n+\n+    // verify that the HTTP response data are not null\n+    assertAll(\"Check that WebLogic server and session vars is not null or empty\",\n+        () -> assertNotNull(primaryServerName,\"Primary server name shouldn\u2019t be null\"),\n+        () -> assertNotNull(sessionCreateTime,\"Session create time shouldn\u2019t be null\"),\n+        () -> assertNotNull(countStr,\"Session state shouldn\u2019t be null\")\n+    );\n+\n+    int count = Optional.ofNullable(countStr).map(Ints::tryParse).orElse(0);\n+\n+    logger.info(\"After patching the domain, the primary server changes to : {0} \"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM5MDA0Nw=="}, "originalCommit": {"oid": "21fa3422bc43ccacf4b3f58af78a757484035650"}, "originalPosition": 183}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDIyNTcxOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSessionMigration.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxODoxNjoyNVrOGZf7Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMzo0MDo0NVrOGZmADg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM5MDU5NA==", "bodyText": "change the method name to getOriginalServerAndSessionInfo", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1672#discussion_r429390594", "createdAt": "2020-05-22T18:16:25Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSessionMigration.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import com.google.common.primitives.Ints;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownManagedServerUsingServerStartPolicy;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+/**\n+ * Verify that when the primary server is down, another server takes on its clients\n+ * to become the new primary server and HTTP session state is migrated to the new primary server.\n+ */\n+@DisplayName(\"Test the HTTP session replication features of WebLogic\")\n+@IntegrationTest\n+class ItSessionMigration implements LoggedTest {\n+\n+  // constants for creating domain image using model in image\n+  private static final String SESSMIGR_MODEL_FILE = \"model.sessmigr.yaml\";\n+  private static final String SESSMIGR_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String SESSMIGR_APP_NAME = \"sessmigr-app\";\n+  private static final String SESSMIGR_APP_WAR_NAME = \"sessmigr-war\";\n+  private static final int SESSION_STATE = 4;\n+  private static Map<String, String> httpAttrMap;\n+\n+  // constants for Operator and WebLogic domain\n+  private static String domainUid = \"sessmigr-domain-1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int replicaCount = 2;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  /**\n+   * Install Operator, create a custom image using model in image with model files\n+   * and create a one cluster domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a unique Operator namespace\n+    logger.info(\"Get a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify Operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName);\n+\n+    // map to save HTTP response data\n+    httpAttrMap = new HashMap<String, String>();\n+    httpAttrMap.put(\"sessioncreatetime\", \"(.*)sessioncreatetime>(.*)</sessioncreatetime(.*)\");\n+    httpAttrMap.put(\"sessionid\", \"(.*)sessionid>(.*)</sessionid(.*)\");\n+    httpAttrMap.put(\"primary\", \"(.*)primary>(.*)</primary(.*)\");\n+    httpAttrMap.put(\"secondary\", \"(.*)secondary>(.*)</secondary(.*)\");\n+    httpAttrMap.put(\"count\", \"(.*)countattribute>(.*)</countattribute(.*)\");\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"getOrigServerAndSessionInfo\")\n+  @DisplayName(\"Stop the primary server, verify that a new primary server is picked and HTTP session state is migrated\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testSessionMigration(String origPrimaryServerName,\n+                                   String origSecondaryServerName,\n+                                   String origSessionCreateTime) {\n+    final String sessionCreateTimeAttr = \"sessioncreatetime\";\n+    final String primaryServerAttr = \"primary\";\n+    final String countAttr = \"count\";\n+    final String webServiceGetUrl = SESSMIGR_APP_WAR_NAME + \"/?getCounter\";\n+\n+    logger.info(\"Got the primary server: {0}, the secondary server: {1} \"\n+        + \"and session create time: {2} from the factory method getOrigServerAndSessionInfo\",\n+            origPrimaryServerName, origSecondaryServerName, origSessionCreateTime);\n+\n+    // stop the primary server by changing ServerStartPolicy to NEVER and patching domain\n+    logger.info(\"Shut down the primary server: {0}\", origPrimaryServerName);\n+    shutdownServerUsingServerStartPolicy(origPrimaryServerName);\n+\n+    // get HTTP response data from web service deployed on the cluster\n+    Map<String, String> httpDataInfo =\n+        processHttpRequest(domainUid + \"-\" + origSecondaryServerName,\n+            webServiceGetUrl, \" -b \");\n+    String primaryServerName = httpDataInfo.get(primaryServerAttr);\n+    String sessionCreateTime = httpDataInfo.get(sessionCreateTimeAttr);\n+    String countStr = httpDataInfo.get(countAttr);\n+\n+    // verify that the HTTP response data are not null\n+    assertAll(\"Check that WebLogic server and session vars is not null or empty\",\n+        () -> assertNotNull(primaryServerName,\"Primary server name shouldn\u2019t be null\"),\n+        () -> assertNotNull(sessionCreateTime,\"Session create time shouldn\u2019t be null\"),\n+        () -> assertNotNull(countStr,\"Session state shouldn\u2019t be null\")\n+    );\n+\n+    int count = Optional.ofNullable(countStr).map(Ints::tryParse).orElse(0);\n+\n+    logger.info(\"After patching the domain, the primary server changes to : {0} \"\n+        + \", session create time: {1} and session state: {2}\",\n+            primaryServerName, sessionCreateTime, countStr);\n+\n+    // verify that a new primary server is picked and HTTP session state is migrated\n+    assertAll(\"Check that WebLogic server and session vars is not null or empty\",\n+        () -> assertNotEquals(origPrimaryServerName, primaryServerName,\n+            \"After the primary server stopped, another server should become the new primary server\"),\n+        () -> assertEquals(origSessionCreateTime, sessionCreateTime,\n+            \"After the primary server stopped, HTTP session state should be migrated to the new primary server\"),\n+        () -> assertEquals(count, SESSION_STATE,\n+            \"After the primary server stopped, HTTP session state should be migrated to the new primary server\")\n+    );\n+\n+    logger.info(\"SUCCESS --- testSessionMigration \\nThe new primary server is : {0}, it was : {1}. \"\n+        + \"\\nThe session state was set to {2}, it is migrated to the new primary server.\",\n+            primaryServerName, origPrimaryServerName, SESSION_STATE);\n+  }\n+\n+  /**\n+   * A factory method generates a stream of String and referred\n+   * by the parameterized test method testSessionMigration.\n+   *\n+   * @return a stream of Arguments that contains primary and secondary server names and session create time\n+   */\n+  static Stream<Arguments> getOrigServerAndSessionInfo() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21fa3422bc43ccacf4b3f58af78a757484035650"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5MDE5MA==", "bodyText": "changed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1672#discussion_r429490190", "createdAt": "2020-05-22T23:40:45Z", "author": {"login": "hzhao-github"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSessionMigration.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import com.google.common.primitives.Ints;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownManagedServerUsingServerStartPolicy;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+/**\n+ * Verify that when the primary server is down, another server takes on its clients\n+ * to become the new primary server and HTTP session state is migrated to the new primary server.\n+ */\n+@DisplayName(\"Test the HTTP session replication features of WebLogic\")\n+@IntegrationTest\n+class ItSessionMigration implements LoggedTest {\n+\n+  // constants for creating domain image using model in image\n+  private static final String SESSMIGR_MODEL_FILE = \"model.sessmigr.yaml\";\n+  private static final String SESSMIGR_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String SESSMIGR_APP_NAME = \"sessmigr-app\";\n+  private static final String SESSMIGR_APP_WAR_NAME = \"sessmigr-war\";\n+  private static final int SESSION_STATE = 4;\n+  private static Map<String, String> httpAttrMap;\n+\n+  // constants for Operator and WebLogic domain\n+  private static String domainUid = \"sessmigr-domain-1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int replicaCount = 2;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  /**\n+   * Install Operator, create a custom image using model in image with model files\n+   * and create a one cluster domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a unique Operator namespace\n+    logger.info(\"Get a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify Operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName);\n+\n+    // map to save HTTP response data\n+    httpAttrMap = new HashMap<String, String>();\n+    httpAttrMap.put(\"sessioncreatetime\", \"(.*)sessioncreatetime>(.*)</sessioncreatetime(.*)\");\n+    httpAttrMap.put(\"sessionid\", \"(.*)sessionid>(.*)</sessionid(.*)\");\n+    httpAttrMap.put(\"primary\", \"(.*)primary>(.*)</primary(.*)\");\n+    httpAttrMap.put(\"secondary\", \"(.*)secondary>(.*)</secondary(.*)\");\n+    httpAttrMap.put(\"count\", \"(.*)countattribute>(.*)</countattribute(.*)\");\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"getOrigServerAndSessionInfo\")\n+  @DisplayName(\"Stop the primary server, verify that a new primary server is picked and HTTP session state is migrated\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testSessionMigration(String origPrimaryServerName,\n+                                   String origSecondaryServerName,\n+                                   String origSessionCreateTime) {\n+    final String sessionCreateTimeAttr = \"sessioncreatetime\";\n+    final String primaryServerAttr = \"primary\";\n+    final String countAttr = \"count\";\n+    final String webServiceGetUrl = SESSMIGR_APP_WAR_NAME + \"/?getCounter\";\n+\n+    logger.info(\"Got the primary server: {0}, the secondary server: {1} \"\n+        + \"and session create time: {2} from the factory method getOrigServerAndSessionInfo\",\n+            origPrimaryServerName, origSecondaryServerName, origSessionCreateTime);\n+\n+    // stop the primary server by changing ServerStartPolicy to NEVER and patching domain\n+    logger.info(\"Shut down the primary server: {0}\", origPrimaryServerName);\n+    shutdownServerUsingServerStartPolicy(origPrimaryServerName);\n+\n+    // get HTTP response data from web service deployed on the cluster\n+    Map<String, String> httpDataInfo =\n+        processHttpRequest(domainUid + \"-\" + origSecondaryServerName,\n+            webServiceGetUrl, \" -b \");\n+    String primaryServerName = httpDataInfo.get(primaryServerAttr);\n+    String sessionCreateTime = httpDataInfo.get(sessionCreateTimeAttr);\n+    String countStr = httpDataInfo.get(countAttr);\n+\n+    // verify that the HTTP response data are not null\n+    assertAll(\"Check that WebLogic server and session vars is not null or empty\",\n+        () -> assertNotNull(primaryServerName,\"Primary server name shouldn\u2019t be null\"),\n+        () -> assertNotNull(sessionCreateTime,\"Session create time shouldn\u2019t be null\"),\n+        () -> assertNotNull(countStr,\"Session state shouldn\u2019t be null\")\n+    );\n+\n+    int count = Optional.ofNullable(countStr).map(Ints::tryParse).orElse(0);\n+\n+    logger.info(\"After patching the domain, the primary server changes to : {0} \"\n+        + \", session create time: {1} and session state: {2}\",\n+            primaryServerName, sessionCreateTime, countStr);\n+\n+    // verify that a new primary server is picked and HTTP session state is migrated\n+    assertAll(\"Check that WebLogic server and session vars is not null or empty\",\n+        () -> assertNotEquals(origPrimaryServerName, primaryServerName,\n+            \"After the primary server stopped, another server should become the new primary server\"),\n+        () -> assertEquals(origSessionCreateTime, sessionCreateTime,\n+            \"After the primary server stopped, HTTP session state should be migrated to the new primary server\"),\n+        () -> assertEquals(count, SESSION_STATE,\n+            \"After the primary server stopped, HTTP session state should be migrated to the new primary server\")\n+    );\n+\n+    logger.info(\"SUCCESS --- testSessionMigration \\nThe new primary server is : {0}, it was : {1}. \"\n+        + \"\\nThe session state was set to {2}, it is migrated to the new primary server.\",\n+            primaryServerName, origPrimaryServerName, SESSION_STATE);\n+  }\n+\n+  /**\n+   * A factory method generates a stream of String and referred\n+   * by the parameterized test method testSessionMigration.\n+   *\n+   * @return a stream of Arguments that contains primary and secondary server names and session create time\n+   */\n+  static Stream<Arguments> getOrigServerAndSessionInfo() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM5MDU5NA=="}, "originalCommit": {"oid": "21fa3422bc43ccacf4b3f58af78a757484035650"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3OTE3ODU5OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSessionMigration.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwMjo1MjowMVrOGaNHBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxODoxMTowOVrOGaqYQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEzMDk0OA==", "bodyText": "parameter name should be origSessionCreateTime", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1672#discussion_r430130948", "createdAt": "2020-05-26T02:52:01Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSessionMigration.java", "diffHunk": "@@ -0,0 +1,460 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import com.google.common.primitives.Ints;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownManagedServerUsingServerStartPolicy;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+/**\n+ * Verify that when the primary server is down, another server takes on its clients\n+ * to become the new primary server and HTTP session state is migrated to the new primary server.\n+ */\n+@DisplayName(\"Test the HTTP session replication features of WebLogic\")\n+@IntegrationTest\n+class ItSessionMigration implements LoggedTest {\n+\n+  // constants for creating domain image using model in image\n+  private static final String SESSMIGR_MODEL_FILE = \"model.sessmigr.yaml\";\n+  private static final String SESSMIGR_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String SESSMIGR_APP_NAME = \"sessmigr-app\";\n+  private static final String SESSMIGR_APP_WAR_NAME = \"sessmigr-war\";\n+  private static final int SESSION_STATE = 4;\n+  private static Map<String, String> httpAttrMap;\n+\n+  // constants for Operator and WebLogic domain\n+  private static String domainUid = \"sessmigr-domain-1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int replicaCount = 2;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  /**\n+   * Install Operator, create a custom image using model in image with model files\n+   * and create a one cluster domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a unique Operator namespace\n+    logger.info(\"Get a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify Operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName);\n+\n+    // map to save HTTP response data\n+    httpAttrMap = new HashMap<String, String>();\n+    httpAttrMap.put(\"sessioncreatetime\", \"(.*)sessioncreatetime>(.*)</sessioncreatetime(.*)\");\n+    httpAttrMap.put(\"sessionid\", \"(.*)sessionid>(.*)</sessionid(.*)\");\n+    httpAttrMap.put(\"primary\", \"(.*)primary>(.*)</primary(.*)\");\n+    httpAttrMap.put(\"secondary\", \"(.*)secondary>(.*)</secondary(.*)\");\n+    httpAttrMap.put(\"count\", \"(.*)countattribute>(.*)</countattribute(.*)\");\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+  }\n+\n+  /**\n+   * Get the primary and secondary server name and session create time from the factory method,\n+   * getOriginalServerAndSessionInfo. Stop the primary server by changing ServerStartPolicy to NEVER\n+   * and patching domain. Send a HTTP request to get http session state (count number), primary server\n+   * and session create time. Verify that a new primary server is picked and HTTP session state is migrated.\n+   *\n+   * @param origPrimaryServerName the primary server name from the factory method\n+   *                              getOriginalServerAndSessionInfo when the domain is created\n+   * @param origSecondaryServerName the secondary server name from the factory method\n+   *                                getOriginalServerAndSessionInfo when the domain is created\n+   * @param origPrimaryServerName the session create time from the factory method", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3bca3a20c670de047f499b383699d8f26c0c705c"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYxMDQ5OQ==", "bodyText": "copy/paste error :( thx. fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1672#discussion_r430610499", "createdAt": "2020-05-26T18:11:09Z", "author": {"login": "hzhao-github"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSessionMigration.java", "diffHunk": "@@ -0,0 +1,460 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import com.google.common.primitives.Ints;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownManagedServerUsingServerStartPolicy;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+/**\n+ * Verify that when the primary server is down, another server takes on its clients\n+ * to become the new primary server and HTTP session state is migrated to the new primary server.\n+ */\n+@DisplayName(\"Test the HTTP session replication features of WebLogic\")\n+@IntegrationTest\n+class ItSessionMigration implements LoggedTest {\n+\n+  // constants for creating domain image using model in image\n+  private static final String SESSMIGR_MODEL_FILE = \"model.sessmigr.yaml\";\n+  private static final String SESSMIGR_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String SESSMIGR_APP_NAME = \"sessmigr-app\";\n+  private static final String SESSMIGR_APP_WAR_NAME = \"sessmigr-war\";\n+  private static final int SESSION_STATE = 4;\n+  private static Map<String, String> httpAttrMap;\n+\n+  // constants for Operator and WebLogic domain\n+  private static String domainUid = \"sessmigr-domain-1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int replicaCount = 2;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  /**\n+   * Install Operator, create a custom image using model in image with model files\n+   * and create a one cluster domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a unique Operator namespace\n+    logger.info(\"Get a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify Operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName);\n+\n+    // map to save HTTP response data\n+    httpAttrMap = new HashMap<String, String>();\n+    httpAttrMap.put(\"sessioncreatetime\", \"(.*)sessioncreatetime>(.*)</sessioncreatetime(.*)\");\n+    httpAttrMap.put(\"sessionid\", \"(.*)sessionid>(.*)</sessionid(.*)\");\n+    httpAttrMap.put(\"primary\", \"(.*)primary>(.*)</primary(.*)\");\n+    httpAttrMap.put(\"secondary\", \"(.*)secondary>(.*)</secondary(.*)\");\n+    httpAttrMap.put(\"count\", \"(.*)countattribute>(.*)</countattribute(.*)\");\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+  }\n+\n+  /**\n+   * Get the primary and secondary server name and session create time from the factory method,\n+   * getOriginalServerAndSessionInfo. Stop the primary server by changing ServerStartPolicy to NEVER\n+   * and patching domain. Send a HTTP request to get http session state (count number), primary server\n+   * and session create time. Verify that a new primary server is picked and HTTP session state is migrated.\n+   *\n+   * @param origPrimaryServerName the primary server name from the factory method\n+   *                              getOriginalServerAndSessionInfo when the domain is created\n+   * @param origSecondaryServerName the secondary server name from the factory method\n+   *                                getOriginalServerAndSessionInfo when the domain is created\n+   * @param origPrimaryServerName the session create time from the factory method", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEzMDk0OA=="}, "originalCommit": {"oid": "3bca3a20c670de047f499b383699d8f26c0c705c"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3OTE5MTY5OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSessionMigration.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwMzowMTo1NFrOGaNO-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxODowNzoyNFrOGaqP8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEzMjk4Ng==", "bodyText": "is the request sent to cluster url or specific server?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1672#discussion_r430132986", "createdAt": "2020-05-26T03:01:54Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSessionMigration.java", "diffHunk": "@@ -0,0 +1,460 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import com.google.common.primitives.Ints;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownManagedServerUsingServerStartPolicy;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+/**\n+ * Verify that when the primary server is down, another server takes on its clients\n+ * to become the new primary server and HTTP session state is migrated to the new primary server.\n+ */\n+@DisplayName(\"Test the HTTP session replication features of WebLogic\")\n+@IntegrationTest\n+class ItSessionMigration implements LoggedTest {\n+\n+  // constants for creating domain image using model in image\n+  private static final String SESSMIGR_MODEL_FILE = \"model.sessmigr.yaml\";\n+  private static final String SESSMIGR_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String SESSMIGR_APP_NAME = \"sessmigr-app\";\n+  private static final String SESSMIGR_APP_WAR_NAME = \"sessmigr-war\";\n+  private static final int SESSION_STATE = 4;\n+  private static Map<String, String> httpAttrMap;\n+\n+  // constants for Operator and WebLogic domain\n+  private static String domainUid = \"sessmigr-domain-1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int replicaCount = 2;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  /**\n+   * Install Operator, create a custom image using model in image with model files\n+   * and create a one cluster domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a unique Operator namespace\n+    logger.info(\"Get a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify Operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName);\n+\n+    // map to save HTTP response data\n+    httpAttrMap = new HashMap<String, String>();\n+    httpAttrMap.put(\"sessioncreatetime\", \"(.*)sessioncreatetime>(.*)</sessioncreatetime(.*)\");\n+    httpAttrMap.put(\"sessionid\", \"(.*)sessionid>(.*)</sessionid(.*)\");\n+    httpAttrMap.put(\"primary\", \"(.*)primary>(.*)</primary(.*)\");\n+    httpAttrMap.put(\"secondary\", \"(.*)secondary>(.*)</secondary(.*)\");\n+    httpAttrMap.put(\"count\", \"(.*)countattribute>(.*)</countattribute(.*)\");\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+  }\n+\n+  /**\n+   * Get the primary and secondary server name and session create time from the factory method,\n+   * getOriginalServerAndSessionInfo. Stop the primary server by changing ServerStartPolicy to NEVER\n+   * and patching domain. Send a HTTP request to get http session state (count number), primary server\n+   * and session create time. Verify that a new primary server is picked and HTTP session state is migrated.\n+   *\n+   * @param origPrimaryServerName the primary server name from the factory method\n+   *                              getOriginalServerAndSessionInfo when the domain is created\n+   * @param origSecondaryServerName the secondary server name from the factory method\n+   *                                getOriginalServerAndSessionInfo when the domain is created\n+   * @param origPrimaryServerName the session create time from the factory method\n+   *                              getOriginalServerAndSessionInfo when the domain is created\n+   */\n+  @ParameterizedTest\n+  @MethodSource(\"getOriginalServerAndSessionInfo\")\n+  @DisplayName(\"Stop the primary server, verify that a new primary server is picked and HTTP session state is migrated\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testSessionMigration(String origPrimaryServerName,\n+                                   String origSecondaryServerName,\n+                                   String origSessionCreateTime) {\n+    final String sessionCreateTimeAttr = \"sessioncreatetime\";\n+    final String primaryServerAttr = \"primary\";\n+    final String countAttr = \"count\";\n+    final String webServiceGetUrl = SESSMIGR_APP_WAR_NAME + \"/?getCounter\";\n+\n+    logger.info(\"Got the primary server {0}, the secondary server {1} \"\n+        + \"and session create time {2} from the factory method getOriginalServerAndSessionInfo\",\n+            origPrimaryServerName, origSecondaryServerName, origSessionCreateTime);\n+\n+    // stop the primary server by changing ServerStartPolicy to NEVER and patching domain\n+    logger.info(\"Shut down the primary server {0}\", origPrimaryServerName);\n+    shutdownServerUsingServerStartPolicy(origPrimaryServerName);\n+\n+    // get HTTP response data from web service deployed on the cluster\n+    Map<String, String> httpDataInfo =\n+        processHttpRequest(domainUid + \"-\" + origSecondaryServerName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3bca3a20c670de047f499b383699d8f26c0c705c"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYwODM2OA==", "bodyText": "Sent to the Managed server but the webapp is deployed on the cluster", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1672#discussion_r430608368", "createdAt": "2020-05-26T18:07:24Z", "author": {"login": "hzhao-github"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSessionMigration.java", "diffHunk": "@@ -0,0 +1,460 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import com.google.common.primitives.Ints;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownManagedServerUsingServerStartPolicy;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+/**\n+ * Verify that when the primary server is down, another server takes on its clients\n+ * to become the new primary server and HTTP session state is migrated to the new primary server.\n+ */\n+@DisplayName(\"Test the HTTP session replication features of WebLogic\")\n+@IntegrationTest\n+class ItSessionMigration implements LoggedTest {\n+\n+  // constants for creating domain image using model in image\n+  private static final String SESSMIGR_MODEL_FILE = \"model.sessmigr.yaml\";\n+  private static final String SESSMIGR_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String SESSMIGR_APP_NAME = \"sessmigr-app\";\n+  private static final String SESSMIGR_APP_WAR_NAME = \"sessmigr-war\";\n+  private static final int SESSION_STATE = 4;\n+  private static Map<String, String> httpAttrMap;\n+\n+  // constants for Operator and WebLogic domain\n+  private static String domainUid = \"sessmigr-domain-1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int replicaCount = 2;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  /**\n+   * Install Operator, create a custom image using model in image with model files\n+   * and create a one cluster domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a unique Operator namespace\n+    logger.info(\"Get a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify Operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName);\n+\n+    // map to save HTTP response data\n+    httpAttrMap = new HashMap<String, String>();\n+    httpAttrMap.put(\"sessioncreatetime\", \"(.*)sessioncreatetime>(.*)</sessioncreatetime(.*)\");\n+    httpAttrMap.put(\"sessionid\", \"(.*)sessionid>(.*)</sessionid(.*)\");\n+    httpAttrMap.put(\"primary\", \"(.*)primary>(.*)</primary(.*)\");\n+    httpAttrMap.put(\"secondary\", \"(.*)secondary>(.*)</secondary(.*)\");\n+    httpAttrMap.put(\"count\", \"(.*)countattribute>(.*)</countattribute(.*)\");\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+  }\n+\n+  /**\n+   * Get the primary and secondary server name and session create time from the factory method,\n+   * getOriginalServerAndSessionInfo. Stop the primary server by changing ServerStartPolicy to NEVER\n+   * and patching domain. Send a HTTP request to get http session state (count number), primary server\n+   * and session create time. Verify that a new primary server is picked and HTTP session state is migrated.\n+   *\n+   * @param origPrimaryServerName the primary server name from the factory method\n+   *                              getOriginalServerAndSessionInfo when the domain is created\n+   * @param origSecondaryServerName the secondary server name from the factory method\n+   *                                getOriginalServerAndSessionInfo when the domain is created\n+   * @param origPrimaryServerName the session create time from the factory method\n+   *                              getOriginalServerAndSessionInfo when the domain is created\n+   */\n+  @ParameterizedTest\n+  @MethodSource(\"getOriginalServerAndSessionInfo\")\n+  @DisplayName(\"Stop the primary server, verify that a new primary server is picked and HTTP session state is migrated\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testSessionMigration(String origPrimaryServerName,\n+                                   String origSecondaryServerName,\n+                                   String origSessionCreateTime) {\n+    final String sessionCreateTimeAttr = \"sessioncreatetime\";\n+    final String primaryServerAttr = \"primary\";\n+    final String countAttr = \"count\";\n+    final String webServiceGetUrl = SESSMIGR_APP_WAR_NAME + \"/?getCounter\";\n+\n+    logger.info(\"Got the primary server {0}, the secondary server {1} \"\n+        + \"and session create time {2} from the factory method getOriginalServerAndSessionInfo\",\n+            origPrimaryServerName, origSecondaryServerName, origSessionCreateTime);\n+\n+    // stop the primary server by changing ServerStartPolicy to NEVER and patching domain\n+    logger.info(\"Shut down the primary server {0}\", origPrimaryServerName);\n+    shutdownServerUsingServerStartPolicy(origPrimaryServerName);\n+\n+    // get HTTP response data from web service deployed on the cluster\n+    Map<String, String> httpDataInfo =\n+        processHttpRequest(domainUid + \"-\" + origSecondaryServerName,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEzMjk4Ng=="}, "originalCommit": {"oid": "3bca3a20c670de047f499b383699d8f26c0c705c"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3OTE5MjI4OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSessionMigration.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwMzowMjoyNFrOGaNPWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxODoxMToxNlrOGaqYfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEzMzA4Mw==", "bodyText": "does not exist?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1672#discussion_r430133083", "createdAt": "2020-05-26T03:02:24Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSessionMigration.java", "diffHunk": "@@ -0,0 +1,460 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import com.google.common.primitives.Ints;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownManagedServerUsingServerStartPolicy;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+/**\n+ * Verify that when the primary server is down, another server takes on its clients\n+ * to become the new primary server and HTTP session state is migrated to the new primary server.\n+ */\n+@DisplayName(\"Test the HTTP session replication features of WebLogic\")\n+@IntegrationTest\n+class ItSessionMigration implements LoggedTest {\n+\n+  // constants for creating domain image using model in image\n+  private static final String SESSMIGR_MODEL_FILE = \"model.sessmigr.yaml\";\n+  private static final String SESSMIGR_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String SESSMIGR_APP_NAME = \"sessmigr-app\";\n+  private static final String SESSMIGR_APP_WAR_NAME = \"sessmigr-war\";\n+  private static final int SESSION_STATE = 4;\n+  private static Map<String, String> httpAttrMap;\n+\n+  // constants for Operator and WebLogic domain\n+  private static String domainUid = \"sessmigr-domain-1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int replicaCount = 2;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  /**\n+   * Install Operator, create a custom image using model in image with model files\n+   * and create a one cluster domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a unique Operator namespace\n+    logger.info(\"Get a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify Operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName);\n+\n+    // map to save HTTP response data\n+    httpAttrMap = new HashMap<String, String>();\n+    httpAttrMap.put(\"sessioncreatetime\", \"(.*)sessioncreatetime>(.*)</sessioncreatetime(.*)\");\n+    httpAttrMap.put(\"sessionid\", \"(.*)sessionid>(.*)</sessionid(.*)\");\n+    httpAttrMap.put(\"primary\", \"(.*)primary>(.*)</primary(.*)\");\n+    httpAttrMap.put(\"secondary\", \"(.*)secondary>(.*)</secondary(.*)\");\n+    httpAttrMap.put(\"count\", \"(.*)countattribute>(.*)</countattribute(.*)\");\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+  }\n+\n+  /**\n+   * Get the primary and secondary server name and session create time from the factory method,\n+   * getOriginalServerAndSessionInfo. Stop the primary server by changing ServerStartPolicy to NEVER\n+   * and patching domain. Send a HTTP request to get http session state (count number), primary server\n+   * and session create time. Verify that a new primary server is picked and HTTP session state is migrated.\n+   *\n+   * @param origPrimaryServerName the primary server name from the factory method\n+   *                              getOriginalServerAndSessionInfo when the domain is created\n+   * @param origSecondaryServerName the secondary server name from the factory method\n+   *                                getOriginalServerAndSessionInfo when the domain is created\n+   * @param origPrimaryServerName the session create time from the factory method\n+   *                              getOriginalServerAndSessionInfo when the domain is created\n+   */\n+  @ParameterizedTest\n+  @MethodSource(\"getOriginalServerAndSessionInfo\")\n+  @DisplayName(\"Stop the primary server, verify that a new primary server is picked and HTTP session state is migrated\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testSessionMigration(String origPrimaryServerName,\n+                                   String origSecondaryServerName,\n+                                   String origSessionCreateTime) {\n+    final String sessionCreateTimeAttr = \"sessioncreatetime\";\n+    final String primaryServerAttr = \"primary\";\n+    final String countAttr = \"count\";\n+    final String webServiceGetUrl = SESSMIGR_APP_WAR_NAME + \"/?getCounter\";\n+\n+    logger.info(\"Got the primary server {0}, the secondary server {1} \"\n+        + \"and session create time {2} from the factory method getOriginalServerAndSessionInfo\",\n+            origPrimaryServerName, origSecondaryServerName, origSessionCreateTime);\n+\n+    // stop the primary server by changing ServerStartPolicy to NEVER and patching domain\n+    logger.info(\"Shut down the primary server {0}\", origPrimaryServerName);\n+    shutdownServerUsingServerStartPolicy(origPrimaryServerName);\n+\n+    // get HTTP response data from web service deployed on the cluster\n+    Map<String, String> httpDataInfo =\n+        processHttpRequest(domainUid + \"-\" + origSecondaryServerName,\n+            webServiceGetUrl, \" -b \");\n+    String primaryServerName = httpDataInfo.get(primaryServerAttr);\n+    String sessionCreateTime = httpDataInfo.get(sessionCreateTimeAttr);\n+    String countStr = httpDataInfo.get(countAttr);\n+\n+    // verify that the HTTP response data are not null\n+    assertAll(\"Check that WebLogic server and session vars is not null or empty\",\n+        () -> assertNotNull(primaryServerName,\"Primary server name shouldn\u2019t be null\"),\n+        () -> assertNotNull(sessionCreateTime,\"Session create time shouldn\u2019t be null\"),\n+        () -> assertNotNull(countStr,\"Session state shouldn\u2019t be null\")\n+    );\n+\n+    int count = Optional.ofNullable(countStr).map(Ints::tryParse).orElse(0);\n+\n+    logger.info(\"After patching the domain, the primary server changes to {0} \"\n+        + \", session create time {1} and session state {2}\",\n+            primaryServerName, sessionCreateTime, countStr);\n+\n+    // verify that a new primary server is picked and HTTP session state is migrated\n+    assertAll(\"Check that WebLogic server and session vars is not null or empty\",\n+        () -> assertNotEquals(origPrimaryServerName, primaryServerName,\n+            \"After the primary server stopped, another server should become the new primary server\"),\n+        () -> assertEquals(origSessionCreateTime, sessionCreateTime,\n+            \"After the primary server stopped, HTTP session state should be migrated to the new primary server\"),\n+        () -> assertEquals(count, SESSION_STATE,\n+            \"After the primary server stopped, HTTP session state should be migrated to the new primary server\")\n+    );\n+\n+    logger.info(\"SUCCESS --- testSessionMigration \\nThe new primary server is {0}, it was {1}. \"\n+        + \"\\nThe session state was set to {2}, it is migrated to the new primary server.\",\n+            primaryServerName, origPrimaryServerName, SESSION_STATE);\n+  }\n+\n+  /**\n+   * A factory method generates a stream of String and referred by the parameterized test method testSessionMigration\n+   * It sends a HTTP request to set http session state (count number) and return the primary server,\n+   * the secondary server and session create time to the parameterized test method.\n+   *\n+   * @return a stream of Arguments that contains primary and secondary server names and session create time\n+   */\n+  static Stream<Arguments> getOriginalServerAndSessionInfo() {\n+    final String primaryServerAttr = \"primary\";\n+    final String secondaryServerAttr = \"secondary\";\n+    final String sessionCreateTimeAttr = \"sessioncreatetime\";\n+    final String webServiceSetUrl = SESSMIGR_APP_WAR_NAME + \"/?setCounter=\" + SESSION_STATE;\n+    final String serverName = managedServerPrefix + \"1\";\n+\n+    // send a HTTP request to set http session state(count number) and save HTTP session info\n+    logger.info(\"Process HTTP request with web service URL {0} in the pod {1} \",\n+        webServiceSetUrl, serverName);\n+    Map<String, String> httpAttrInfo =\n+        processHttpRequest(serverName, webServiceSetUrl, \" -D \");\n+\n+    // get HTTP response data\n+    String primaryServerName = httpAttrInfo.get(primaryServerAttr);\n+    String secondaryServerName = httpAttrInfo.get(secondaryServerAttr);\n+    String sessionCreateTime = httpAttrInfo.get(sessionCreateTimeAttr);\n+\n+    // verify that the HTTP response data are not null\n+    assertAll(\"Check that WebLogic server and session vars is not null or empty\",\n+        () -> assertNotNull(primaryServerName,\"Primary server name shouldn\u2019t be null\"),\n+        () -> assertNotNull(secondaryServerName,\"Second server name shouldn\u2019t be null\"),\n+        () -> assertNotNull(sessionCreateTime,\"Session create time shouldn\u2019t be null\")\n+    );\n+\n+    logger.info(\"HTTP response returns the primary server {0} \"\n+        + \"the secondary server {1} and session create time {2}\",\n+            primaryServerName, secondaryServerName, sessionCreateTime);\n+\n+    return Stream.of(arguments(primaryServerName, secondaryServerName, sessionCreateTime));\n+  }\n+\n+  private static String createAndVerifyDomainImage() {\n+    // create image with model files\n+    logger.info(\"Create image with model file and verify\");\n+    String miiImage =\n+        createMiiImageAndVerify(SESSMIGR_IMAGE_NAME, SESSMIGR_MODEL_FILE, SESSMIGR_APP_NAME);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Create docker registry secret in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+        String.format(\"create Docker Registry Secret failed for %s\", REPO_SECRET_NAME));\n+\n+    return miiImage;\n+  }\n+\n+  private static void createAndVerifyDomain(String miiImage) {\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(adminSecretName, domainNamespace,\n+        \"weblogic\", \"welcome1\"),\n+        String.format(\"create secret for admin credentials failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(encryptionSecretName, domainNamespace,\n+        \"weblogicenc\", \"weblogicenc\"),\n+        String.format(\"create encryption secret failed for %s\", encryptionSecretName));\n+\n+    // create domain and verify\n+    logger.info(\"Create model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainCrAndVerify(adminSecretName, REPO_SECRET_NAME, encryptionSecretName, miiImage);\n+\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin server pod is ready\n+    logger.info(\"Checking that admin server pod {0} is ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin service exists in the domain namespace\n+    logger.info(\"Checking that admin service {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // check for managed server pods existence in the domain namespace\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = managedServerPrefix + i;\n+\n+      // check that the managed server pod exists\n+      logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodExists(managedServerPodName, domainUid, domainNamespace);\n+\n+      // check that the managed server pod is ready\n+      logger.info(\"Checking that managed server pod {0} is ready in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodReady(managedServerPodName, domainUid, domainNamespace);\n+\n+      // check that the managed server service exists in the domain namespace\n+      logger.info(\"Checking that managed server service {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkServiceExists(managedServerPodName, domainNamespace);\n+    }\n+  }\n+\n+  private static void createDomainCrAndVerify(String adminSecretName,\n+                                              String repoSecretName,\n+                                              String encryptionSecretName,\n+                                              String miiImage) {\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(repoSecretName))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))\n+                .introspectorJobActiveDeadlineSeconds(300L)));\n+\n+    // create domain using model in image\n+    logger.info(\"Create model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainAndVerify(domain, domainNamespace);\n+  }\n+\n+  private void shutdownServerUsingServerStartPolicy(String msName) {\n+    logger.info(\"Shutdown the server {0}\", msName);\n+    final String podName = domainUid + \"-\" + msName;\n+\n+    // shutdown a server by changing the it's serverStartPolicy property.\n+    boolean serverStopped = assertDoesNotThrow(() ->\n+        shutdownManagedServerUsingServerStartPolicy(domainUid, domainNamespace, msName));\n+    assertTrue(serverStopped,\n+        String.format(\"Failed to shutdown server %s \", msName));\n+\n+    // check that the managed server pod shutdown successfylly\n+    logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3bca3a20c670de047f499b383699d8f26c0c705c"}, "originalPosition": 389}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYxMDU1Ng==", "bodyText": "copy/paste error :( thx. fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1672#discussion_r430610556", "createdAt": "2020-05-26T18:11:16Z", "author": {"login": "hzhao-github"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSessionMigration.java", "diffHunk": "@@ -0,0 +1,460 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import com.google.common.primitives.Ints;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownManagedServerUsingServerStartPolicy;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+/**\n+ * Verify that when the primary server is down, another server takes on its clients\n+ * to become the new primary server and HTTP session state is migrated to the new primary server.\n+ */\n+@DisplayName(\"Test the HTTP session replication features of WebLogic\")\n+@IntegrationTest\n+class ItSessionMigration implements LoggedTest {\n+\n+  // constants for creating domain image using model in image\n+  private static final String SESSMIGR_MODEL_FILE = \"model.sessmigr.yaml\";\n+  private static final String SESSMIGR_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String SESSMIGR_APP_NAME = \"sessmigr-app\";\n+  private static final String SESSMIGR_APP_WAR_NAME = \"sessmigr-war\";\n+  private static final int SESSION_STATE = 4;\n+  private static Map<String, String> httpAttrMap;\n+\n+  // constants for Operator and WebLogic domain\n+  private static String domainUid = \"sessmigr-domain-1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int replicaCount = 2;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  /**\n+   * Install Operator, create a custom image using model in image with model files\n+   * and create a one cluster domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a unique Operator namespace\n+    logger.info(\"Get a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify Operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName);\n+\n+    // map to save HTTP response data\n+    httpAttrMap = new HashMap<String, String>();\n+    httpAttrMap.put(\"sessioncreatetime\", \"(.*)sessioncreatetime>(.*)</sessioncreatetime(.*)\");\n+    httpAttrMap.put(\"sessionid\", \"(.*)sessionid>(.*)</sessionid(.*)\");\n+    httpAttrMap.put(\"primary\", \"(.*)primary>(.*)</primary(.*)\");\n+    httpAttrMap.put(\"secondary\", \"(.*)secondary>(.*)</secondary(.*)\");\n+    httpAttrMap.put(\"count\", \"(.*)countattribute>(.*)</countattribute(.*)\");\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+  }\n+\n+  /**\n+   * Get the primary and secondary server name and session create time from the factory method,\n+   * getOriginalServerAndSessionInfo. Stop the primary server by changing ServerStartPolicy to NEVER\n+   * and patching domain. Send a HTTP request to get http session state (count number), primary server\n+   * and session create time. Verify that a new primary server is picked and HTTP session state is migrated.\n+   *\n+   * @param origPrimaryServerName the primary server name from the factory method\n+   *                              getOriginalServerAndSessionInfo when the domain is created\n+   * @param origSecondaryServerName the secondary server name from the factory method\n+   *                                getOriginalServerAndSessionInfo when the domain is created\n+   * @param origPrimaryServerName the session create time from the factory method\n+   *                              getOriginalServerAndSessionInfo when the domain is created\n+   */\n+  @ParameterizedTest\n+  @MethodSource(\"getOriginalServerAndSessionInfo\")\n+  @DisplayName(\"Stop the primary server, verify that a new primary server is picked and HTTP session state is migrated\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testSessionMigration(String origPrimaryServerName,\n+                                   String origSecondaryServerName,\n+                                   String origSessionCreateTime) {\n+    final String sessionCreateTimeAttr = \"sessioncreatetime\";\n+    final String primaryServerAttr = \"primary\";\n+    final String countAttr = \"count\";\n+    final String webServiceGetUrl = SESSMIGR_APP_WAR_NAME + \"/?getCounter\";\n+\n+    logger.info(\"Got the primary server {0}, the secondary server {1} \"\n+        + \"and session create time {2} from the factory method getOriginalServerAndSessionInfo\",\n+            origPrimaryServerName, origSecondaryServerName, origSessionCreateTime);\n+\n+    // stop the primary server by changing ServerStartPolicy to NEVER and patching domain\n+    logger.info(\"Shut down the primary server {0}\", origPrimaryServerName);\n+    shutdownServerUsingServerStartPolicy(origPrimaryServerName);\n+\n+    // get HTTP response data from web service deployed on the cluster\n+    Map<String, String> httpDataInfo =\n+        processHttpRequest(domainUid + \"-\" + origSecondaryServerName,\n+            webServiceGetUrl, \" -b \");\n+    String primaryServerName = httpDataInfo.get(primaryServerAttr);\n+    String sessionCreateTime = httpDataInfo.get(sessionCreateTimeAttr);\n+    String countStr = httpDataInfo.get(countAttr);\n+\n+    // verify that the HTTP response data are not null\n+    assertAll(\"Check that WebLogic server and session vars is not null or empty\",\n+        () -> assertNotNull(primaryServerName,\"Primary server name shouldn\u2019t be null\"),\n+        () -> assertNotNull(sessionCreateTime,\"Session create time shouldn\u2019t be null\"),\n+        () -> assertNotNull(countStr,\"Session state shouldn\u2019t be null\")\n+    );\n+\n+    int count = Optional.ofNullable(countStr).map(Ints::tryParse).orElse(0);\n+\n+    logger.info(\"After patching the domain, the primary server changes to {0} \"\n+        + \", session create time {1} and session state {2}\",\n+            primaryServerName, sessionCreateTime, countStr);\n+\n+    // verify that a new primary server is picked and HTTP session state is migrated\n+    assertAll(\"Check that WebLogic server and session vars is not null or empty\",\n+        () -> assertNotEquals(origPrimaryServerName, primaryServerName,\n+            \"After the primary server stopped, another server should become the new primary server\"),\n+        () -> assertEquals(origSessionCreateTime, sessionCreateTime,\n+            \"After the primary server stopped, HTTP session state should be migrated to the new primary server\"),\n+        () -> assertEquals(count, SESSION_STATE,\n+            \"After the primary server stopped, HTTP session state should be migrated to the new primary server\")\n+    );\n+\n+    logger.info(\"SUCCESS --- testSessionMigration \\nThe new primary server is {0}, it was {1}. \"\n+        + \"\\nThe session state was set to {2}, it is migrated to the new primary server.\",\n+            primaryServerName, origPrimaryServerName, SESSION_STATE);\n+  }\n+\n+  /**\n+   * A factory method generates a stream of String and referred by the parameterized test method testSessionMigration\n+   * It sends a HTTP request to set http session state (count number) and return the primary server,\n+   * the secondary server and session create time to the parameterized test method.\n+   *\n+   * @return a stream of Arguments that contains primary and secondary server names and session create time\n+   */\n+  static Stream<Arguments> getOriginalServerAndSessionInfo() {\n+    final String primaryServerAttr = \"primary\";\n+    final String secondaryServerAttr = \"secondary\";\n+    final String sessionCreateTimeAttr = \"sessioncreatetime\";\n+    final String webServiceSetUrl = SESSMIGR_APP_WAR_NAME + \"/?setCounter=\" + SESSION_STATE;\n+    final String serverName = managedServerPrefix + \"1\";\n+\n+    // send a HTTP request to set http session state(count number) and save HTTP session info\n+    logger.info(\"Process HTTP request with web service URL {0} in the pod {1} \",\n+        webServiceSetUrl, serverName);\n+    Map<String, String> httpAttrInfo =\n+        processHttpRequest(serverName, webServiceSetUrl, \" -D \");\n+\n+    // get HTTP response data\n+    String primaryServerName = httpAttrInfo.get(primaryServerAttr);\n+    String secondaryServerName = httpAttrInfo.get(secondaryServerAttr);\n+    String sessionCreateTime = httpAttrInfo.get(sessionCreateTimeAttr);\n+\n+    // verify that the HTTP response data are not null\n+    assertAll(\"Check that WebLogic server and session vars is not null or empty\",\n+        () -> assertNotNull(primaryServerName,\"Primary server name shouldn\u2019t be null\"),\n+        () -> assertNotNull(secondaryServerName,\"Second server name shouldn\u2019t be null\"),\n+        () -> assertNotNull(sessionCreateTime,\"Session create time shouldn\u2019t be null\")\n+    );\n+\n+    logger.info(\"HTTP response returns the primary server {0} \"\n+        + \"the secondary server {1} and session create time {2}\",\n+            primaryServerName, secondaryServerName, sessionCreateTime);\n+\n+    return Stream.of(arguments(primaryServerName, secondaryServerName, sessionCreateTime));\n+  }\n+\n+  private static String createAndVerifyDomainImage() {\n+    // create image with model files\n+    logger.info(\"Create image with model file and verify\");\n+    String miiImage =\n+        createMiiImageAndVerify(SESSMIGR_IMAGE_NAME, SESSMIGR_MODEL_FILE, SESSMIGR_APP_NAME);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Create docker registry secret in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+        String.format(\"create Docker Registry Secret failed for %s\", REPO_SECRET_NAME));\n+\n+    return miiImage;\n+  }\n+\n+  private static void createAndVerifyDomain(String miiImage) {\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(adminSecretName, domainNamespace,\n+        \"weblogic\", \"welcome1\"),\n+        String.format(\"create secret for admin credentials failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(encryptionSecretName, domainNamespace,\n+        \"weblogicenc\", \"weblogicenc\"),\n+        String.format(\"create encryption secret failed for %s\", encryptionSecretName));\n+\n+    // create domain and verify\n+    logger.info(\"Create model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainCrAndVerify(adminSecretName, REPO_SECRET_NAME, encryptionSecretName, miiImage);\n+\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin server pod is ready\n+    logger.info(\"Checking that admin server pod {0} is ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin service exists in the domain namespace\n+    logger.info(\"Checking that admin service {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // check for managed server pods existence in the domain namespace\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = managedServerPrefix + i;\n+\n+      // check that the managed server pod exists\n+      logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodExists(managedServerPodName, domainUid, domainNamespace);\n+\n+      // check that the managed server pod is ready\n+      logger.info(\"Checking that managed server pod {0} is ready in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodReady(managedServerPodName, domainUid, domainNamespace);\n+\n+      // check that the managed server service exists in the domain namespace\n+      logger.info(\"Checking that managed server service {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkServiceExists(managedServerPodName, domainNamespace);\n+    }\n+  }\n+\n+  private static void createDomainCrAndVerify(String adminSecretName,\n+                                              String repoSecretName,\n+                                              String encryptionSecretName,\n+                                              String miiImage) {\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(repoSecretName))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))\n+                .introspectorJobActiveDeadlineSeconds(300L)));\n+\n+    // create domain using model in image\n+    logger.info(\"Create model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainAndVerify(domain, domainNamespace);\n+  }\n+\n+  private void shutdownServerUsingServerStartPolicy(String msName) {\n+    logger.info(\"Shutdown the server {0}\", msName);\n+    final String podName = domainUid + \"-\" + msName;\n+\n+    // shutdown a server by changing the it's serverStartPolicy property.\n+    boolean serverStopped = assertDoesNotThrow(() ->\n+        shutdownManagedServerUsingServerStartPolicy(domainUid, domainNamespace, msName));\n+    assertTrue(serverStopped,\n+        String.format(\"Failed to shutdown server %s \", msName));\n+\n+    // check that the managed server pod shutdown successfylly\n+    logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEzMzA4Mw=="}, "originalCommit": {"oid": "3bca3a20c670de047f499b383699d8f26c0c705c"}, "originalPosition": 389}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3OTIwNjMwOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSessionMigration.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwMzoxMzo0M1rOGaNYHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMzowNDo1MVrOGazLUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEzNTMyNg==", "bodyText": "why is this a parameterized test? what are the different parameters we are testing with?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1672#discussion_r430135326", "createdAt": "2020-05-26T03:13:43Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSessionMigration.java", "diffHunk": "@@ -0,0 +1,460 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import com.google.common.primitives.Ints;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownManagedServerUsingServerStartPolicy;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+/**\n+ * Verify that when the primary server is down, another server takes on its clients\n+ * to become the new primary server and HTTP session state is migrated to the new primary server.\n+ */\n+@DisplayName(\"Test the HTTP session replication features of WebLogic\")\n+@IntegrationTest\n+class ItSessionMigration implements LoggedTest {\n+\n+  // constants for creating domain image using model in image\n+  private static final String SESSMIGR_MODEL_FILE = \"model.sessmigr.yaml\";\n+  private static final String SESSMIGR_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String SESSMIGR_APP_NAME = \"sessmigr-app\";\n+  private static final String SESSMIGR_APP_WAR_NAME = \"sessmigr-war\";\n+  private static final int SESSION_STATE = 4;\n+  private static Map<String, String> httpAttrMap;\n+\n+  // constants for Operator and WebLogic domain\n+  private static String domainUid = \"sessmigr-domain-1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int replicaCount = 2;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  /**\n+   * Install Operator, create a custom image using model in image with model files\n+   * and create a one cluster domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a unique Operator namespace\n+    logger.info(\"Get a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify Operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName);\n+\n+    // map to save HTTP response data\n+    httpAttrMap = new HashMap<String, String>();\n+    httpAttrMap.put(\"sessioncreatetime\", \"(.*)sessioncreatetime>(.*)</sessioncreatetime(.*)\");\n+    httpAttrMap.put(\"sessionid\", \"(.*)sessionid>(.*)</sessionid(.*)\");\n+    httpAttrMap.put(\"primary\", \"(.*)primary>(.*)</primary(.*)\");\n+    httpAttrMap.put(\"secondary\", \"(.*)secondary>(.*)</secondary(.*)\");\n+    httpAttrMap.put(\"count\", \"(.*)countattribute>(.*)</countattribute(.*)\");\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+  }\n+\n+  /**\n+   * Get the primary and secondary server name and session create time from the factory method,\n+   * getOriginalServerAndSessionInfo. Stop the primary server by changing ServerStartPolicy to NEVER\n+   * and patching domain. Send a HTTP request to get http session state (count number), primary server\n+   * and session create time. Verify that a new primary server is picked and HTTP session state is migrated.\n+   *\n+   * @param origPrimaryServerName the primary server name from the factory method\n+   *                              getOriginalServerAndSessionInfo when the domain is created\n+   * @param origSecondaryServerName the secondary server name from the factory method\n+   *                                getOriginalServerAndSessionInfo when the domain is created\n+   * @param origPrimaryServerName the session create time from the factory method\n+   *                              getOriginalServerAndSessionInfo when the domain is created\n+   */\n+  @ParameterizedTest", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3bca3a20c670de047f499b383699d8f26c0c705c"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1NDY0Mg==", "bodyText": "changed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1672#discussion_r430754642", "createdAt": "2020-05-26T23:04:51Z", "author": {"login": "hzhao-github"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSessionMigration.java", "diffHunk": "@@ -0,0 +1,460 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import com.google.common.primitives.Ints;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownManagedServerUsingServerStartPolicy;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+/**\n+ * Verify that when the primary server is down, another server takes on its clients\n+ * to become the new primary server and HTTP session state is migrated to the new primary server.\n+ */\n+@DisplayName(\"Test the HTTP session replication features of WebLogic\")\n+@IntegrationTest\n+class ItSessionMigration implements LoggedTest {\n+\n+  // constants for creating domain image using model in image\n+  private static final String SESSMIGR_MODEL_FILE = \"model.sessmigr.yaml\";\n+  private static final String SESSMIGR_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String SESSMIGR_APP_NAME = \"sessmigr-app\";\n+  private static final String SESSMIGR_APP_WAR_NAME = \"sessmigr-war\";\n+  private static final int SESSION_STATE = 4;\n+  private static Map<String, String> httpAttrMap;\n+\n+  // constants for Operator and WebLogic domain\n+  private static String domainUid = \"sessmigr-domain-1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int replicaCount = 2;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  /**\n+   * Install Operator, create a custom image using model in image with model files\n+   * and create a one cluster domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a unique Operator namespace\n+    logger.info(\"Get a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify Operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName);\n+\n+    // map to save HTTP response data\n+    httpAttrMap = new HashMap<String, String>();\n+    httpAttrMap.put(\"sessioncreatetime\", \"(.*)sessioncreatetime>(.*)</sessioncreatetime(.*)\");\n+    httpAttrMap.put(\"sessionid\", \"(.*)sessionid>(.*)</sessionid(.*)\");\n+    httpAttrMap.put(\"primary\", \"(.*)primary>(.*)</primary(.*)\");\n+    httpAttrMap.put(\"secondary\", \"(.*)secondary>(.*)</secondary(.*)\");\n+    httpAttrMap.put(\"count\", \"(.*)countattribute>(.*)</countattribute(.*)\");\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+  }\n+\n+  /**\n+   * Get the primary and secondary server name and session create time from the factory method,\n+   * getOriginalServerAndSessionInfo. Stop the primary server by changing ServerStartPolicy to NEVER\n+   * and patching domain. Send a HTTP request to get http session state (count number), primary server\n+   * and session create time. Verify that a new primary server is picked and HTTP session state is migrated.\n+   *\n+   * @param origPrimaryServerName the primary server name from the factory method\n+   *                              getOriginalServerAndSessionInfo when the domain is created\n+   * @param origSecondaryServerName the secondary server name from the factory method\n+   *                                getOriginalServerAndSessionInfo when the domain is created\n+   * @param origPrimaryServerName the session create time from the factory method\n+   *                              getOriginalServerAndSessionInfo when the domain is created\n+   */\n+  @ParameterizedTest", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEzNTMyNg=="}, "originalCommit": {"oid": "3bca3a20c670de047f499b383699d8f26c0c705c"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzMwMDQ1OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSessionMigration.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMToyNjo0M1rOGbdwBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwNDoxNTo1NVrOGc2mzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ1MjE2NA==", "bodyText": "change method name to sendRequestAndGetSessionInfo() or similar to indicate what the method is doing", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1672#discussion_r431452164", "createdAt": "2020-05-27T21:26:43Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSessionMigration.java", "diffHunk": "@@ -0,0 +1,462 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import com.google.common.primitives.Ints;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownManagedServerUsingServerStartPolicy;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Verify that when the primary server is down, another server takes on its clients\n+ * to become the new primary server and HTTP session state is migrated to the new primary server.\n+ */\n+@DisplayName(\"Test the HTTP session replication features of WebLogic\")\n+@IntegrationTest\n+class ItSessionMigration implements LoggedTest {\n+\n+  // constants for creating domain image using model in image\n+  private static final String SESSMIGR_MODEL_FILE = \"model.sessmigr.yaml\";\n+  private static final String SESSMIGR_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String SESSMIGR_APP_NAME = \"sessmigr-app\";\n+  private static final String SESSMIGR_APP_WAR_NAME = \"sessmigr-war\";\n+  private static final int SESSION_STATE = 4;\n+  private static Map<String, String> httpAttrMap;\n+\n+  // constants for operator and WebLogic domain\n+  private static String domainUid = \"sessmigr-domain-1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int replicaCount = 2;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  /**\n+   * Install operator, create a custom image using model in image with model files\n+   * and create a one cluster domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName);\n+\n+    // map to save HTTP response data\n+    httpAttrMap = new HashMap<String, String>();\n+    httpAttrMap.put(\"sessioncreatetime\", \"(.*)sessioncreatetime>(.*)</sessioncreatetime(.*)\");\n+    httpAttrMap.put(\"sessionid\", \"(.*)sessionid>(.*)</sessionid(.*)\");\n+    httpAttrMap.put(\"primary\", \"(.*)primary>(.*)</primary(.*)\");\n+    httpAttrMap.put(\"secondary\", \"(.*)secondary>(.*)</secondary(.*)\");\n+    httpAttrMap.put(\"count\", \"(.*)countattribute>(.*)</countattribute(.*)\");\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+  }\n+\n+  /**\n+   * The test sends a HTTP request to set http session state(count number), get the primary and secondary server name,\n+   * session create time and session state and from the util method and save HTTP session info,\n+   * then stop the primary server by changing ServerStartPolicy to NEVER and patching domain.\n+   * Send another HTTP request to get http session state (count number), primary server and\n+   * session create time. Verify that a new primary server is selected and HTTP session state is migrated.\n+   */\n+  @Test\n+  @DisplayName(\"Stop the primary server, verify that a new primary server is picked and HTTP session state is migrated\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testSessionMigration() {\n+    final String primaryServerAttr = \"primary\";\n+    final String secondaryServerAttr = \"secondary\";\n+    final String sessionCreateTimeAttr = \"sessioncreatetime\";\n+    final String countAttr = \"count\";\n+    final String webServiceSetUrl = SESSMIGR_APP_WAR_NAME + \"/?setCounter=\" + SESSION_STATE;\n+    final String webServiceGetUrl = SESSMIGR_APP_WAR_NAME + \"/?getCounter\";\n+    String serverName = managedServerPrefix + \"1\";\n+\n+    // send a HTTP request to set http session state(count number) and save HTTP session info\n+    // before shutting down the primary server\n+    Map<String, String> httpDataInfo =\n+        getServerAndSessionInfoAndVerify(serverName, webServiceSetUrl, \" -D \");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83b1b0632910a67a59c80305aeb14c8df5fc55e6"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwNzk4Mg==", "bodyText": "changed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1672#discussion_r432907982", "createdAt": "2020-05-31T04:15:55Z", "author": {"login": "hzhao-github"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSessionMigration.java", "diffHunk": "@@ -0,0 +1,462 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import com.google.common.primitives.Ints;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownManagedServerUsingServerStartPolicy;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Verify that when the primary server is down, another server takes on its clients\n+ * to become the new primary server and HTTP session state is migrated to the new primary server.\n+ */\n+@DisplayName(\"Test the HTTP session replication features of WebLogic\")\n+@IntegrationTest\n+class ItSessionMigration implements LoggedTest {\n+\n+  // constants for creating domain image using model in image\n+  private static final String SESSMIGR_MODEL_FILE = \"model.sessmigr.yaml\";\n+  private static final String SESSMIGR_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String SESSMIGR_APP_NAME = \"sessmigr-app\";\n+  private static final String SESSMIGR_APP_WAR_NAME = \"sessmigr-war\";\n+  private static final int SESSION_STATE = 4;\n+  private static Map<String, String> httpAttrMap;\n+\n+  // constants for operator and WebLogic domain\n+  private static String domainUid = \"sessmigr-domain-1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int replicaCount = 2;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  /**\n+   * Install operator, create a custom image using model in image with model files\n+   * and create a one cluster domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName);\n+\n+    // map to save HTTP response data\n+    httpAttrMap = new HashMap<String, String>();\n+    httpAttrMap.put(\"sessioncreatetime\", \"(.*)sessioncreatetime>(.*)</sessioncreatetime(.*)\");\n+    httpAttrMap.put(\"sessionid\", \"(.*)sessionid>(.*)</sessionid(.*)\");\n+    httpAttrMap.put(\"primary\", \"(.*)primary>(.*)</primary(.*)\");\n+    httpAttrMap.put(\"secondary\", \"(.*)secondary>(.*)</secondary(.*)\");\n+    httpAttrMap.put(\"count\", \"(.*)countattribute>(.*)</countattribute(.*)\");\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+  }\n+\n+  /**\n+   * The test sends a HTTP request to set http session state(count number), get the primary and secondary server name,\n+   * session create time and session state and from the util method and save HTTP session info,\n+   * then stop the primary server by changing ServerStartPolicy to NEVER and patching domain.\n+   * Send another HTTP request to get http session state (count number), primary server and\n+   * session create time. Verify that a new primary server is selected and HTTP session state is migrated.\n+   */\n+  @Test\n+  @DisplayName(\"Stop the primary server, verify that a new primary server is picked and HTTP session state is migrated\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testSessionMigration() {\n+    final String primaryServerAttr = \"primary\";\n+    final String secondaryServerAttr = \"secondary\";\n+    final String sessionCreateTimeAttr = \"sessioncreatetime\";\n+    final String countAttr = \"count\";\n+    final String webServiceSetUrl = SESSMIGR_APP_WAR_NAME + \"/?setCounter=\" + SESSION_STATE;\n+    final String webServiceGetUrl = SESSMIGR_APP_WAR_NAME + \"/?getCounter\";\n+    String serverName = managedServerPrefix + \"1\";\n+\n+    // send a HTTP request to set http session state(count number) and save HTTP session info\n+    // before shutting down the primary server\n+    Map<String, String> httpDataInfo =\n+        getServerAndSessionInfoAndVerify(serverName, webServiceSetUrl, \" -D \");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ1MjE2NA=="}, "originalCommit": {"oid": "83b1b0632910a67a59c80305aeb14c8df5fc55e6"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzMwNjAwOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSessionMigration.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMToyODoyOVrOGbdzbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMTozNjozM1rOGbeB3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ1MzAzOA==", "bodyText": "just a question - if you use node port and cluster url for app, you don't need to exec into the pod to curl?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1672#discussion_r431453038", "createdAt": "2020-05-27T21:28:29Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSessionMigration.java", "diffHunk": "@@ -0,0 +1,462 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import com.google.common.primitives.Ints;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownManagedServerUsingServerStartPolicy;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Verify that when the primary server is down, another server takes on its clients\n+ * to become the new primary server and HTTP session state is migrated to the new primary server.\n+ */\n+@DisplayName(\"Test the HTTP session replication features of WebLogic\")\n+@IntegrationTest\n+class ItSessionMigration implements LoggedTest {\n+\n+  // constants for creating domain image using model in image\n+  private static final String SESSMIGR_MODEL_FILE = \"model.sessmigr.yaml\";\n+  private static final String SESSMIGR_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String SESSMIGR_APP_NAME = \"sessmigr-app\";\n+  private static final String SESSMIGR_APP_WAR_NAME = \"sessmigr-war\";\n+  private static final int SESSION_STATE = 4;\n+  private static Map<String, String> httpAttrMap;\n+\n+  // constants for operator and WebLogic domain\n+  private static String domainUid = \"sessmigr-domain-1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int replicaCount = 2;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  /**\n+   * Install operator, create a custom image using model in image with model files\n+   * and create a one cluster domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName);\n+\n+    // map to save HTTP response data\n+    httpAttrMap = new HashMap<String, String>();\n+    httpAttrMap.put(\"sessioncreatetime\", \"(.*)sessioncreatetime>(.*)</sessioncreatetime(.*)\");\n+    httpAttrMap.put(\"sessionid\", \"(.*)sessionid>(.*)</sessionid(.*)\");\n+    httpAttrMap.put(\"primary\", \"(.*)primary>(.*)</primary(.*)\");\n+    httpAttrMap.put(\"secondary\", \"(.*)secondary>(.*)</secondary(.*)\");\n+    httpAttrMap.put(\"count\", \"(.*)countattribute>(.*)</countattribute(.*)\");\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+  }\n+\n+  /**\n+   * The test sends a HTTP request to set http session state(count number), get the primary and secondary server name,\n+   * session create time and session state and from the util method and save HTTP session info,\n+   * then stop the primary server by changing ServerStartPolicy to NEVER and patching domain.\n+   * Send another HTTP request to get http session state (count number), primary server and\n+   * session create time. Verify that a new primary server is selected and HTTP session state is migrated.\n+   */\n+  @Test\n+  @DisplayName(\"Stop the primary server, verify that a new primary server is picked and HTTP session state is migrated\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testSessionMigration() {\n+    final String primaryServerAttr = \"primary\";\n+    final String secondaryServerAttr = \"secondary\";\n+    final String sessionCreateTimeAttr = \"sessioncreatetime\";\n+    final String countAttr = \"count\";\n+    final String webServiceSetUrl = SESSMIGR_APP_WAR_NAME + \"/?setCounter=\" + SESSION_STATE;\n+    final String webServiceGetUrl = SESSMIGR_APP_WAR_NAME + \"/?getCounter\";\n+    String serverName = managedServerPrefix + \"1\";\n+\n+    // send a HTTP request to set http session state(count number) and save HTTP session info\n+    // before shutting down the primary server\n+    Map<String, String> httpDataInfo =\n+        getServerAndSessionInfoAndVerify(serverName, webServiceSetUrl, \" -D \");\n+    // get server and session info from web service deployed on the cluster\n+    String origPrimaryServerName = httpDataInfo.get(primaryServerAttr);\n+    String origSecondaryServerName = httpDataInfo.get(secondaryServerAttr);\n+    String origSessionCreateTime = httpDataInfo.get(sessionCreateTimeAttr);\n+    logger.info(\"Got the primary server {0}, the secondary server {1} \"\n+        + \"and session create time {2} before shutting down the primary server\",\n+            origPrimaryServerName, origSecondaryServerName, origSessionCreateTime);\n+\n+    // stop the primary server by changing ServerStartPolicy to NEVER and patching domain\n+    logger.info(\"Shut down the primary server {0}\", origPrimaryServerName);\n+    shutdownServerUsingServerStartPolicy(origPrimaryServerName);\n+\n+    // send a HTTP request to get server and session info after shutting down the primary server\n+    serverName = domainUid + \"-\" + origSecondaryServerName;\n+    httpDataInfo =\n+      getServerAndSessionInfoAndVerify(serverName, webServiceGetUrl, \" -b \");\n+    // get server and session info from web service deployed on the cluster\n+    String primaryServerName = httpDataInfo.get(primaryServerAttr);\n+    String sessionCreateTime = httpDataInfo.get(sessionCreateTimeAttr);\n+    String countStr = httpDataInfo.get(countAttr);\n+    int count = Optional.ofNullable(countStr).map(Ints::tryParse).orElse(0);\n+    logger.info(\"After patching the domain, the primary server changes to {0} \"\n+        + \", session create time {1} and session state {2}\",\n+            primaryServerName, sessionCreateTime, countStr);\n+\n+    // verify that a new primary server is picked and HTTP session state is migrated\n+    assertAll(\"Check that WebLogic server and session vars is not null or empty\",\n+        () -> assertNotEquals(origPrimaryServerName, primaryServerName,\n+            \"After the primary server stopped, another server should become the new primary server\"),\n+        () -> assertEquals(origSessionCreateTime, sessionCreateTime,\n+            \"After the primary server stopped, HTTP session state should be migrated to the new primary server\"),\n+        () -> assertEquals(count, SESSION_STATE,\n+            \"After the primary server stopped, HTTP session state should be migrated to the new primary server\")\n+    );\n+\n+    logger.info(\"SUCCESS --- testSessionMigration \\nThe new primary server is {0}, it was {1}. \"\n+        + \"\\nThe session state was set to {2}, it is migrated to the new primary server.\",\n+            primaryServerName, origPrimaryServerName, SESSION_STATE);\n+  }\n+\n+  /**\n+   * An util method referred by the test method testSessionMigration. It sends a HTTP request\n+   * to set or get http session state (count number) and return the primary server,\n+   * the secondary server, session create time and session state(count number).\n+   *\n+   * @param serverName server name in the cluster on which the web app is running\n+   * @param webServiceUrl fully qualified URL to the server on which the web app is running\n+   * @param headerOption option to save or use HTTP session info\n+   *\n+   * @return map that contains primary and secondary server names, session create time and session state\n+   */\n+  private Map<String, String> getServerAndSessionInfoAndVerify(String serverName,\n+                                                               String webServiceUrl,\n+                                                               String headerOption) {\n+    final String primaryServerAttr = \"primary\";\n+    final String secondaryServerAttr = \"secondary\";\n+    final String sessionCreateTimeAttr = \"sessioncreatetime\";\n+    final String countAttr = \"count\";\n+\n+    // send a HTTP request to set http session state(count number) and save HTTP session info\n+    logger.info(\"Process HTTP request with web service URL {0} in the pod {1} \",\n+        webServiceUrl, serverName);\n+    Map<String, String> httpAttrInfo =\n+        processHttpRequest(serverName, webServiceUrl, headerOption);\n+\n+    // get HTTP response data\n+    String primaryServerName = httpAttrInfo.get(primaryServerAttr);\n+    String secondaryServerName = httpAttrInfo.get(secondaryServerAttr);\n+    String sessionCreateTime = httpAttrInfo.get(sessionCreateTimeAttr);\n+    String countStr = httpAttrInfo.get(countAttr);\n+\n+    // verify that the HTTP response data are not null\n+    assertAll(\"Check that WebLogic server and session vars is not null or empty\",\n+        () -> assertNotNull(primaryServerName,\"Primary server name shouldn\u2019t be null\"),\n+        () -> assertNotNull(secondaryServerName,\"Second server name shouldn\u2019t be null\"),\n+        () -> assertNotNull(sessionCreateTime,\"Session create time shouldn\u2019t be null\"),\n+        () -> assertNotNull(countStr,\"Session state shouldn\u2019t be null\")\n+    );\n+\n+    // map to save server and session info\n+    Map<String, String> httpDataInfo = new HashMap<String, String>();\n+    httpDataInfo.put(primaryServerAttr, primaryServerName);\n+    httpDataInfo.put(secondaryServerAttr, secondaryServerName);\n+    httpDataInfo.put(sessionCreateTimeAttr, sessionCreateTime);\n+    httpDataInfo.put(countAttr, countStr);\n+\n+    return httpDataInfo;\n+  }\n+\n+  private static String createAndVerifyDomainImage() {\n+    // create image with model files\n+    logger.info(\"Create image with model file and verify\");\n+    String miiImage =\n+        createMiiImageAndVerify(SESSMIGR_IMAGE_NAME, SESSMIGR_MODEL_FILE, SESSMIGR_APP_NAME);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Create docker registry secret in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+        String.format(\"create Docker Registry Secret failed for %s\", REPO_SECRET_NAME));\n+\n+    return miiImage;\n+  }\n+\n+  private static void createAndVerifyDomain(String miiImage) {\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(adminSecretName, domainNamespace,\n+        \"weblogic\", \"welcome1\"),\n+        String.format(\"create secret for admin credentials failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(encryptionSecretName, domainNamespace,\n+        \"weblogicenc\", \"weblogicenc\"),\n+        String.format(\"create encryption secret failed for %s\", encryptionSecretName));\n+\n+    // create domain and verify\n+    logger.info(\"Create model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainCrAndVerify(adminSecretName, REPO_SECRET_NAME, encryptionSecretName, miiImage);\n+\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin server pod is ready\n+    logger.info(\"Checking that admin server pod {0} is ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin service exists in the domain namespace\n+    logger.info(\"Checking that admin service {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // check for managed server pods existence in the domain namespace\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = managedServerPrefix + i;\n+\n+      // check that the managed server pod exists\n+      logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodExists(managedServerPodName, domainUid, domainNamespace);\n+\n+      // check that the managed server pod is ready\n+      logger.info(\"Checking that managed server pod {0} is ready in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodReady(managedServerPodName, domainUid, domainNamespace);\n+\n+      // check that the managed server service exists in the domain namespace\n+      logger.info(\"Checking that managed server service {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkServiceExists(managedServerPodName, domainNamespace);\n+    }\n+  }\n+\n+  private static void createDomainCrAndVerify(String adminSecretName,\n+                                              String repoSecretName,\n+                                              String encryptionSecretName,\n+                                              String miiImage) {\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(repoSecretName))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))\n+                .introspectorJobActiveDeadlineSeconds(300L)));\n+\n+    // create domain using model in image\n+    logger.info(\"Create model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainAndVerify(domain, domainNamespace);\n+  }\n+\n+  private void shutdownServerUsingServerStartPolicy(String msName) {\n+    final String podName = domainUid + \"-\" + msName;\n+\n+    // shutdown a server by changing the it's serverStartPolicy property.\n+    logger.info(\"Shutdown the server {0}\", msName);\n+    boolean serverStopped = assertDoesNotThrow(() ->\n+        shutdownManagedServerUsingServerStartPolicy(domainUid, domainNamespace, msName));\n+    assertTrue(serverStopped,\n+        String.format(\"Failed to shutdown server %s \", msName));\n+\n+    // check that the managed server pod shutdown successfylly\n+    logger.info(\"Check that managed server pod {0} stopped in namespace {1}\",\n+        podName, domainNamespace);\n+    checkPodDoesNotExist(podName, domainUid, domainNamespace);\n+  }\n+\n+  private static String buildCurlCommand(String podName,\n+                                         String curlUrlPath,\n+                                         String headerOption) {\n+    logger.info(\"Build a curl command with pod name {0}, curl URL path {1} and HTTP header option {2}\",\n+        podName, curlUrlPath, headerOption);\n+    final String httpHeaderFile = \"/u01/oracle/header\";\n+\n+    StringBuffer curlCmd = new StringBuffer(\"curl --silent --show-error http://\");\n+    curlCmd.append(podName)\n+        .append(\":\")\n+        .append(managedServerPort)\n+        .append(\"/\")\n+        .append(curlUrlPath)\n+        .append(headerOption)\n+        .append(httpHeaderFile);\n+\n+    return curlCmd.toString();\n+  }\n+\n+  private static Map<String, String> processHttpRequest(String serverName,\n+                                                        String curlUrlPath,\n+                                                        String headerOption) {\n+    String[] httpAttrArray =\n+        {\"sessioncreatetime\", \"sessionid\", \"primary\", \"secondary\", \"count\"};\n+    Map<String, String> httpAttrInfo = new HashMap<String, String>();\n+\n+    // build curl command\n+    String curlCmd = buildCurlCommand(serverName, curlUrlPath, headerOption);\n+    logger.info(\"Command to set HTTP request and get HTTP response {0} \", curlCmd);\n+\n+    // set HTTP request and get HTTP response\n+    ExecResult execResult = assertDoesNotThrow(\n+        () -> execCommand(domainNamespace, adminServerPodName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83b1b0632910a67a59c80305aeb14c8df5fc55e6"}, "originalPosition": 426}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ1NjczNQ==", "bodyText": "good point. I wanted to use cluster node port but I can't find cluster node port, it's not enabled in our framework. I wanted to add cluster node port but not sure the right way", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1672#discussion_r431456735", "createdAt": "2020-05-27T21:36:33Z", "author": {"login": "hzhao-github"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSessionMigration.java", "diffHunk": "@@ -0,0 +1,462 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import com.google.common.primitives.Ints;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownManagedServerUsingServerStartPolicy;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Verify that when the primary server is down, another server takes on its clients\n+ * to become the new primary server and HTTP session state is migrated to the new primary server.\n+ */\n+@DisplayName(\"Test the HTTP session replication features of WebLogic\")\n+@IntegrationTest\n+class ItSessionMigration implements LoggedTest {\n+\n+  // constants for creating domain image using model in image\n+  private static final String SESSMIGR_MODEL_FILE = \"model.sessmigr.yaml\";\n+  private static final String SESSMIGR_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String SESSMIGR_APP_NAME = \"sessmigr-app\";\n+  private static final String SESSMIGR_APP_WAR_NAME = \"sessmigr-war\";\n+  private static final int SESSION_STATE = 4;\n+  private static Map<String, String> httpAttrMap;\n+\n+  // constants for operator and WebLogic domain\n+  private static String domainUid = \"sessmigr-domain-1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int replicaCount = 2;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  /**\n+   * Install operator, create a custom image using model in image with model files\n+   * and create a one cluster domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName);\n+\n+    // map to save HTTP response data\n+    httpAttrMap = new HashMap<String, String>();\n+    httpAttrMap.put(\"sessioncreatetime\", \"(.*)sessioncreatetime>(.*)</sessioncreatetime(.*)\");\n+    httpAttrMap.put(\"sessionid\", \"(.*)sessionid>(.*)</sessionid(.*)\");\n+    httpAttrMap.put(\"primary\", \"(.*)primary>(.*)</primary(.*)\");\n+    httpAttrMap.put(\"secondary\", \"(.*)secondary>(.*)</secondary(.*)\");\n+    httpAttrMap.put(\"count\", \"(.*)countattribute>(.*)</countattribute(.*)\");\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+  }\n+\n+  /**\n+   * The test sends a HTTP request to set http session state(count number), get the primary and secondary server name,\n+   * session create time and session state and from the util method and save HTTP session info,\n+   * then stop the primary server by changing ServerStartPolicy to NEVER and patching domain.\n+   * Send another HTTP request to get http session state (count number), primary server and\n+   * session create time. Verify that a new primary server is selected and HTTP session state is migrated.\n+   */\n+  @Test\n+  @DisplayName(\"Stop the primary server, verify that a new primary server is picked and HTTP session state is migrated\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testSessionMigration() {\n+    final String primaryServerAttr = \"primary\";\n+    final String secondaryServerAttr = \"secondary\";\n+    final String sessionCreateTimeAttr = \"sessioncreatetime\";\n+    final String countAttr = \"count\";\n+    final String webServiceSetUrl = SESSMIGR_APP_WAR_NAME + \"/?setCounter=\" + SESSION_STATE;\n+    final String webServiceGetUrl = SESSMIGR_APP_WAR_NAME + \"/?getCounter\";\n+    String serverName = managedServerPrefix + \"1\";\n+\n+    // send a HTTP request to set http session state(count number) and save HTTP session info\n+    // before shutting down the primary server\n+    Map<String, String> httpDataInfo =\n+        getServerAndSessionInfoAndVerify(serverName, webServiceSetUrl, \" -D \");\n+    // get server and session info from web service deployed on the cluster\n+    String origPrimaryServerName = httpDataInfo.get(primaryServerAttr);\n+    String origSecondaryServerName = httpDataInfo.get(secondaryServerAttr);\n+    String origSessionCreateTime = httpDataInfo.get(sessionCreateTimeAttr);\n+    logger.info(\"Got the primary server {0}, the secondary server {1} \"\n+        + \"and session create time {2} before shutting down the primary server\",\n+            origPrimaryServerName, origSecondaryServerName, origSessionCreateTime);\n+\n+    // stop the primary server by changing ServerStartPolicy to NEVER and patching domain\n+    logger.info(\"Shut down the primary server {0}\", origPrimaryServerName);\n+    shutdownServerUsingServerStartPolicy(origPrimaryServerName);\n+\n+    // send a HTTP request to get server and session info after shutting down the primary server\n+    serverName = domainUid + \"-\" + origSecondaryServerName;\n+    httpDataInfo =\n+      getServerAndSessionInfoAndVerify(serverName, webServiceGetUrl, \" -b \");\n+    // get server and session info from web service deployed on the cluster\n+    String primaryServerName = httpDataInfo.get(primaryServerAttr);\n+    String sessionCreateTime = httpDataInfo.get(sessionCreateTimeAttr);\n+    String countStr = httpDataInfo.get(countAttr);\n+    int count = Optional.ofNullable(countStr).map(Ints::tryParse).orElse(0);\n+    logger.info(\"After patching the domain, the primary server changes to {0} \"\n+        + \", session create time {1} and session state {2}\",\n+            primaryServerName, sessionCreateTime, countStr);\n+\n+    // verify that a new primary server is picked and HTTP session state is migrated\n+    assertAll(\"Check that WebLogic server and session vars is not null or empty\",\n+        () -> assertNotEquals(origPrimaryServerName, primaryServerName,\n+            \"After the primary server stopped, another server should become the new primary server\"),\n+        () -> assertEquals(origSessionCreateTime, sessionCreateTime,\n+            \"After the primary server stopped, HTTP session state should be migrated to the new primary server\"),\n+        () -> assertEquals(count, SESSION_STATE,\n+            \"After the primary server stopped, HTTP session state should be migrated to the new primary server\")\n+    );\n+\n+    logger.info(\"SUCCESS --- testSessionMigration \\nThe new primary server is {0}, it was {1}. \"\n+        + \"\\nThe session state was set to {2}, it is migrated to the new primary server.\",\n+            primaryServerName, origPrimaryServerName, SESSION_STATE);\n+  }\n+\n+  /**\n+   * An util method referred by the test method testSessionMigration. It sends a HTTP request\n+   * to set or get http session state (count number) and return the primary server,\n+   * the secondary server, session create time and session state(count number).\n+   *\n+   * @param serverName server name in the cluster on which the web app is running\n+   * @param webServiceUrl fully qualified URL to the server on which the web app is running\n+   * @param headerOption option to save or use HTTP session info\n+   *\n+   * @return map that contains primary and secondary server names, session create time and session state\n+   */\n+  private Map<String, String> getServerAndSessionInfoAndVerify(String serverName,\n+                                                               String webServiceUrl,\n+                                                               String headerOption) {\n+    final String primaryServerAttr = \"primary\";\n+    final String secondaryServerAttr = \"secondary\";\n+    final String sessionCreateTimeAttr = \"sessioncreatetime\";\n+    final String countAttr = \"count\";\n+\n+    // send a HTTP request to set http session state(count number) and save HTTP session info\n+    logger.info(\"Process HTTP request with web service URL {0} in the pod {1} \",\n+        webServiceUrl, serverName);\n+    Map<String, String> httpAttrInfo =\n+        processHttpRequest(serverName, webServiceUrl, headerOption);\n+\n+    // get HTTP response data\n+    String primaryServerName = httpAttrInfo.get(primaryServerAttr);\n+    String secondaryServerName = httpAttrInfo.get(secondaryServerAttr);\n+    String sessionCreateTime = httpAttrInfo.get(sessionCreateTimeAttr);\n+    String countStr = httpAttrInfo.get(countAttr);\n+\n+    // verify that the HTTP response data are not null\n+    assertAll(\"Check that WebLogic server and session vars is not null or empty\",\n+        () -> assertNotNull(primaryServerName,\"Primary server name shouldn\u2019t be null\"),\n+        () -> assertNotNull(secondaryServerName,\"Second server name shouldn\u2019t be null\"),\n+        () -> assertNotNull(sessionCreateTime,\"Session create time shouldn\u2019t be null\"),\n+        () -> assertNotNull(countStr,\"Session state shouldn\u2019t be null\")\n+    );\n+\n+    // map to save server and session info\n+    Map<String, String> httpDataInfo = new HashMap<String, String>();\n+    httpDataInfo.put(primaryServerAttr, primaryServerName);\n+    httpDataInfo.put(secondaryServerAttr, secondaryServerName);\n+    httpDataInfo.put(sessionCreateTimeAttr, sessionCreateTime);\n+    httpDataInfo.put(countAttr, countStr);\n+\n+    return httpDataInfo;\n+  }\n+\n+  private static String createAndVerifyDomainImage() {\n+    // create image with model files\n+    logger.info(\"Create image with model file and verify\");\n+    String miiImage =\n+        createMiiImageAndVerify(SESSMIGR_IMAGE_NAME, SESSMIGR_MODEL_FILE, SESSMIGR_APP_NAME);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Create docker registry secret in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+        String.format(\"create Docker Registry Secret failed for %s\", REPO_SECRET_NAME));\n+\n+    return miiImage;\n+  }\n+\n+  private static void createAndVerifyDomain(String miiImage) {\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(adminSecretName, domainNamespace,\n+        \"weblogic\", \"welcome1\"),\n+        String.format(\"create secret for admin credentials failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(encryptionSecretName, domainNamespace,\n+        \"weblogicenc\", \"weblogicenc\"),\n+        String.format(\"create encryption secret failed for %s\", encryptionSecretName));\n+\n+    // create domain and verify\n+    logger.info(\"Create model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainCrAndVerify(adminSecretName, REPO_SECRET_NAME, encryptionSecretName, miiImage);\n+\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin server pod is ready\n+    logger.info(\"Checking that admin server pod {0} is ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin service exists in the domain namespace\n+    logger.info(\"Checking that admin service {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // check for managed server pods existence in the domain namespace\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = managedServerPrefix + i;\n+\n+      // check that the managed server pod exists\n+      logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodExists(managedServerPodName, domainUid, domainNamespace);\n+\n+      // check that the managed server pod is ready\n+      logger.info(\"Checking that managed server pod {0} is ready in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodReady(managedServerPodName, domainUid, domainNamespace);\n+\n+      // check that the managed server service exists in the domain namespace\n+      logger.info(\"Checking that managed server service {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkServiceExists(managedServerPodName, domainNamespace);\n+    }\n+  }\n+\n+  private static void createDomainCrAndVerify(String adminSecretName,\n+                                              String repoSecretName,\n+                                              String encryptionSecretName,\n+                                              String miiImage) {\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(repoSecretName))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))\n+                .introspectorJobActiveDeadlineSeconds(300L)));\n+\n+    // create domain using model in image\n+    logger.info(\"Create model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainAndVerify(domain, domainNamespace);\n+  }\n+\n+  private void shutdownServerUsingServerStartPolicy(String msName) {\n+    final String podName = domainUid + \"-\" + msName;\n+\n+    // shutdown a server by changing the it's serverStartPolicy property.\n+    logger.info(\"Shutdown the server {0}\", msName);\n+    boolean serverStopped = assertDoesNotThrow(() ->\n+        shutdownManagedServerUsingServerStartPolicy(domainUid, domainNamespace, msName));\n+    assertTrue(serverStopped,\n+        String.format(\"Failed to shutdown server %s \", msName));\n+\n+    // check that the managed server pod shutdown successfylly\n+    logger.info(\"Check that managed server pod {0} stopped in namespace {1}\",\n+        podName, domainNamespace);\n+    checkPodDoesNotExist(podName, domainUid, domainNamespace);\n+  }\n+\n+  private static String buildCurlCommand(String podName,\n+                                         String curlUrlPath,\n+                                         String headerOption) {\n+    logger.info(\"Build a curl command with pod name {0}, curl URL path {1} and HTTP header option {2}\",\n+        podName, curlUrlPath, headerOption);\n+    final String httpHeaderFile = \"/u01/oracle/header\";\n+\n+    StringBuffer curlCmd = new StringBuffer(\"curl --silent --show-error http://\");\n+    curlCmd.append(podName)\n+        .append(\":\")\n+        .append(managedServerPort)\n+        .append(\"/\")\n+        .append(curlUrlPath)\n+        .append(headerOption)\n+        .append(httpHeaderFile);\n+\n+    return curlCmd.toString();\n+  }\n+\n+  private static Map<String, String> processHttpRequest(String serverName,\n+                                                        String curlUrlPath,\n+                                                        String headerOption) {\n+    String[] httpAttrArray =\n+        {\"sessioncreatetime\", \"sessionid\", \"primary\", \"secondary\", \"count\"};\n+    Map<String, String> httpAttrInfo = new HashMap<String, String>();\n+\n+    // build curl command\n+    String curlCmd = buildCurlCommand(serverName, curlUrlPath, headerOption);\n+    logger.info(\"Command to set HTTP request and get HTTP response {0} \", curlCmd);\n+\n+    // set HTTP request and get HTTP response\n+    ExecResult execResult = assertDoesNotThrow(\n+        () -> execCommand(domainNamespace, adminServerPodName,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ1MzAzOA=="}, "originalCommit": {"oid": "83b1b0632910a67a59c80305aeb14c8df5fc55e6"}, "originalPosition": 426}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4605, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}