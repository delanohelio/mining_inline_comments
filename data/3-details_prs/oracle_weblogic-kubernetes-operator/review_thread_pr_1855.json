{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0MjI5NzQ3", "number": 1855, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMjo0ODozMlrOEXnISA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMjo1Njo1OVrOEXnVIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTkzODAwOnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/PodHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMjo0ODozMlrOG_fuyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMzoxNjoyM1rOG_gy_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzMzM1Mw==", "bodyText": "Missing Javadoc @param for clusterName", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1855#discussion_r469233353", "createdAt": "2020-08-12T12:48:32Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/PodHelper.java", "diffHunk": "@@ -85,6 +86,59 @@ public static boolean isReady(V1Pod pod) {\n     return ready;\n   }\n \n+  /**\n+   * Get list of scheduled pods.\n+   * @param info Domain presence info\n+   * @return list containing scheduled pods", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "beeb8e00547288ae23f5df1eb41222f080ccdee7"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI1MDgxNQ==", "bodyText": "Fixed.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1855#discussion_r469250815", "createdAt": "2020-08-12T13:16:23Z", "author": {"login": "ankedia"}, "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/PodHelper.java", "diffHunk": "@@ -85,6 +86,59 @@ public static boolean isReady(V1Pod pod) {\n     return ready;\n   }\n \n+  /**\n+   * Get list of scheduled pods.\n+   * @param info Domain presence info\n+   * @return list containing scheduled pods", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzMzM1Mw=="}, "originalCommit": {"oid": "beeb8e00547288ae23f5df1eb41222f080ccdee7"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTk0MzEzOnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/PodHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMjo0OTo1NVrOG_fx8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMjo0OTo1NVrOG_fx8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzNDE2MQ==", "bodyText": "I'll verify below, but it's surprising that you have a method to list scheduled pods. I would think that you would be interested in unscheduled pods.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1855#discussion_r469234161", "createdAt": "2020-08-12T12:49:55Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/PodHelper.java", "diffHunk": "@@ -85,6 +86,59 @@ public static boolean isReady(V1Pod pod) {\n     return ready;\n   }\n \n+  /**\n+   * Get list of scheduled pods.\n+   * @param info Domain presence info\n+   * @return list containing scheduled pods\n+   */\n+  public static List<String> getScheduledPods(DomainPresenceInfo info, String clusterName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "beeb8e00547288ae23f5df1eb41222f080ccdee7"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTk0NzY5OnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/PodHelper.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMjo1MTowNFrOG_f0wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMzoxNjo0NVrOG_gz0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzNDg4MA==", "bodyText": "Fix variable name", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1855#discussion_r469234880", "createdAt": "2020-08-12T12:51:04Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/PodHelper.java", "diffHunk": "@@ -85,6 +86,59 @@ public static boolean isReady(V1Pod pod) {\n     return ready;\n   }\n \n+  /**\n+   * Get list of scheduled pods.\n+   * @param info Domain presence info\n+   * @return list containing scheduled pods\n+   */\n+  public static List<String> getScheduledPods(DomainPresenceInfo info, String clusterName) {\n+    // These are presently scheduled servers\n+    List<String> scheduledServers = new ArrayList<>();\n+    for (Map.Entry<String, ServerKubernetesObjects> entry : info.getServers().entrySet()) {\n+      V1Pod pod = entry.getValue().getPod().get();\n+      if (pod != null && !PodHelper.isDeleting(pod) && PodHelper.getScheduledStatus(pod)) {\n+        String wlsClusterName = pod.getMetadata().getLabels().get(CLUSTERNAME_LABEL);\n+        if ((wlsClusterName == null) || (wlsClusterName.contains(clusterName))) {\n+          scheduledServers.add(entry.getKey());\n+        }\n+      }\n+    }\n+    return scheduledServers;\n+  }\n+\n+  /**\n+   * Get list of ready pods.\n+   * @param info Domain presence info\n+   * @return list containing ready pods\n+   */\n+  public static List<String> getReadyPods(DomainPresenceInfo info, String clusterName) {\n+    // These are presently Ready servers\n+    List<String> readyServers = new ArrayList<>();\n+    for (Map.Entry<String, ServerKubernetesObjects> entry : info.getServers().entrySet()) {\n+      V1Pod pod = entry.getValue().getPod().get();\n+      if (pod != null && !PodHelper.isDeleting(pod) && PodHelper.getReadyStatus(pod)) {\n+        String wlsClusterName = pod.getMetadata().getLabels().get(CLUSTERNAME_LABEL);\n+        if ((wlsClusterName == null) || (wlsClusterName.contains(clusterName))) {\n+          readyServers.add(entry.getKey());\n+        }\n+      }\n+    }\n+    return readyServers;\n+  }\n+\n+  /**\n+   * get if pod is in scheduled state.\n+   * @param pod pod\n+   * @return true, if pod is scheduled\n+   */\n+  public static boolean getScheduledStatus(V1Pod pod) {\n+    V1PodSpec status = pod.getSpec();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "beeb8e00547288ae23f5df1eb41222f080ccdee7"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI1MTAyNg==", "bodyText": "Fixed.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1855#discussion_r469251026", "createdAt": "2020-08-12T13:16:45Z", "author": {"login": "ankedia"}, "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/PodHelper.java", "diffHunk": "@@ -85,6 +86,59 @@ public static boolean isReady(V1Pod pod) {\n     return ready;\n   }\n \n+  /**\n+   * Get list of scheduled pods.\n+   * @param info Domain presence info\n+   * @return list containing scheduled pods\n+   */\n+  public static List<String> getScheduledPods(DomainPresenceInfo info, String clusterName) {\n+    // These are presently scheduled servers\n+    List<String> scheduledServers = new ArrayList<>();\n+    for (Map.Entry<String, ServerKubernetesObjects> entry : info.getServers().entrySet()) {\n+      V1Pod pod = entry.getValue().getPod().get();\n+      if (pod != null && !PodHelper.isDeleting(pod) && PodHelper.getScheduledStatus(pod)) {\n+        String wlsClusterName = pod.getMetadata().getLabels().get(CLUSTERNAME_LABEL);\n+        if ((wlsClusterName == null) || (wlsClusterName.contains(clusterName))) {\n+          scheduledServers.add(entry.getKey());\n+        }\n+      }\n+    }\n+    return scheduledServers;\n+  }\n+\n+  /**\n+   * Get list of ready pods.\n+   * @param info Domain presence info\n+   * @return list containing ready pods\n+   */\n+  public static List<String> getReadyPods(DomainPresenceInfo info, String clusterName) {\n+    // These are presently Ready servers\n+    List<String> readyServers = new ArrayList<>();\n+    for (Map.Entry<String, ServerKubernetesObjects> entry : info.getServers().entrySet()) {\n+      V1Pod pod = entry.getValue().getPod().get();\n+      if (pod != null && !PodHelper.isDeleting(pod) && PodHelper.getReadyStatus(pod)) {\n+        String wlsClusterName = pod.getMetadata().getLabels().get(CLUSTERNAME_LABEL);\n+        if ((wlsClusterName == null) || (wlsClusterName.contains(clusterName))) {\n+          readyServers.add(entry.getKey());\n+        }\n+      }\n+    }\n+    return readyServers;\n+  }\n+\n+  /**\n+   * get if pod is in scheduled state.\n+   * @param pod pod\n+   * @return true, if pod is scheduled\n+   */\n+  public static boolean getScheduledStatus(V1Pod pod) {\n+    V1PodSpec status = pod.getSpec();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzNDg4MA=="}, "originalCommit": {"oid": "beeb8e00547288ae23f5df1eb41222f080ccdee7"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTk2NTkyOnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServerUpIteratorStep.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMjo1NTo0M1rOG_f_iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMzozNzoyOVrOG_hqYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzNzY0MA==", "bodyText": "What do you think about switching this to test PodHelper.unscheduledPodsExist() rather than comparing the count of scheduled pods to an expected number?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1855#discussion_r469237640", "createdAt": "2020-08-12T12:55:43Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServerUpIteratorStep.java", "diffHunk": "@@ -142,19 +154,53 @@ private boolean isServerInCluster(ServerStartupInfo ssi) {\n \n   static class StartManagedServersStep extends Step {\n     final Collection<StepAndPacket> startDetails;\n+    final Queue<StepAndPacket> startDetailsQueue = new ConcurrentLinkedQueue<>();\n+    final String clusterName;\n+    int numStarted = 0;\n+    int maxConcurrency = 0;\n \n-    StartManagedServersStep(Collection<StepAndPacket> startDetails, Step next) {\n+    StartManagedServersStep(String clusterName, Collection<StepAndPacket> startDetails, Step next) {\n       super(next);\n+      this.clusterName = clusterName;\n       this.startDetails = startDetails;\n+      startDetails.forEach(this::add);\n     }\n \n-    Collection<StepAndPacket> getStartDetails() {\n-      return startDetails;\n+    void add(StepAndPacket serverToStart) {\n+      startDetailsQueue.add(new StepAndPacket(serverToStart.step, serverToStart.packet));\n+      this.maxConcurrency = Optional.ofNullable(\n+              (Integer) serverToStart.packet.get(ProcessingConstants.MAX_CONCURRENCY)).orElse(0);\n     }\n \n     @Override\n     public NextAction apply(Packet packet) {\n-      return doForkJoin(new ManagedServerUpAfterStep(getNext()), packet, startDetails);\n+\n+      if (startDetailsQueue.isEmpty()) {\n+        return doNext(new ManagedServerUpAfterStep(getNext()), packet);\n+      } else if (isServiceOnlyOrShuttingDown()) {\n+        Collection<StepAndPacket> servers = Collections.singletonList(startDetailsQueue.poll());\n+        return doForkJoin(this, packet, servers);\n+      } else if (serverAvailableToStart(packet.getSpi(DomainPresenceInfo.class))) {\n+        this.numStarted++;\n+        return doForkJoin(this, packet, Collections.singletonList(startDetailsQueue.poll()));\n+      } else {\n+        return doDelay(this, packet, 100, TimeUnit.MILLISECONDS);\n+      }\n+    }\n+\n+    private boolean isServiceOnlyOrShuttingDown() {\n+      return Optional.ofNullable(startDetailsQueue.peek().step)\n+              .map(step -> step.getNext() instanceof ServerDownStep).orElse(false);\n+    }\n+\n+    private boolean serverAvailableToStart(DomainPresenceInfo info) {\n+      return ((this.numStarted < PodHelper.getScheduledPods(info, clusterName).size())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "beeb8e00547288ae23f5df1eb41222f080ccdee7"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI2NDk5Mw==", "bodyText": "I believe the reason I went with current count based approach is because we can only schedule/start n number pods in parallel based on value of maxConcurrency. Previously the code was creating maxConcurrency number of fibers and fibers used to wait until pod becomes ready. With current approach, I don't make the fibers wait until pod is ready but start servers (create fibers) only if all previous pods are scheduled and if it matches the criteria for maxConcurrency. I think it's possible to test  PodHelper.unscheduledPodsExist() but we need to check for number of ready pods before deciding to start a new server (start a new fiber). I can try the approach you suggested and test it out for different use-case scenarios.  Please let me know.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1855#discussion_r469264993", "createdAt": "2020-08-12T13:37:29Z", "author": {"login": "ankedia"}, "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServerUpIteratorStep.java", "diffHunk": "@@ -142,19 +154,53 @@ private boolean isServerInCluster(ServerStartupInfo ssi) {\n \n   static class StartManagedServersStep extends Step {\n     final Collection<StepAndPacket> startDetails;\n+    final Queue<StepAndPacket> startDetailsQueue = new ConcurrentLinkedQueue<>();\n+    final String clusterName;\n+    int numStarted = 0;\n+    int maxConcurrency = 0;\n \n-    StartManagedServersStep(Collection<StepAndPacket> startDetails, Step next) {\n+    StartManagedServersStep(String clusterName, Collection<StepAndPacket> startDetails, Step next) {\n       super(next);\n+      this.clusterName = clusterName;\n       this.startDetails = startDetails;\n+      startDetails.forEach(this::add);\n     }\n \n-    Collection<StepAndPacket> getStartDetails() {\n-      return startDetails;\n+    void add(StepAndPacket serverToStart) {\n+      startDetailsQueue.add(new StepAndPacket(serverToStart.step, serverToStart.packet));\n+      this.maxConcurrency = Optional.ofNullable(\n+              (Integer) serverToStart.packet.get(ProcessingConstants.MAX_CONCURRENCY)).orElse(0);\n     }\n \n     @Override\n     public NextAction apply(Packet packet) {\n-      return doForkJoin(new ManagedServerUpAfterStep(getNext()), packet, startDetails);\n+\n+      if (startDetailsQueue.isEmpty()) {\n+        return doNext(new ManagedServerUpAfterStep(getNext()), packet);\n+      } else if (isServiceOnlyOrShuttingDown()) {\n+        Collection<StepAndPacket> servers = Collections.singletonList(startDetailsQueue.poll());\n+        return doForkJoin(this, packet, servers);\n+      } else if (serverAvailableToStart(packet.getSpi(DomainPresenceInfo.class))) {\n+        this.numStarted++;\n+        return doForkJoin(this, packet, Collections.singletonList(startDetailsQueue.poll()));\n+      } else {\n+        return doDelay(this, packet, 100, TimeUnit.MILLISECONDS);\n+      }\n+    }\n+\n+    private boolean isServiceOnlyOrShuttingDown() {\n+      return Optional.ofNullable(startDetailsQueue.peek().step)\n+              .map(step -> step.getNext() instanceof ServerDownStep).orElse(false);\n+    }\n+\n+    private boolean serverAvailableToStart(DomainPresenceInfo info) {\n+      return ((this.numStarted < PodHelper.getScheduledPods(info, clusterName).size())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzNzY0MA=="}, "originalCommit": {"oid": "beeb8e00547288ae23f5df1eb41222f080ccdee7"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTk2Nzc1OnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServerUpIteratorStep.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMjo1NjowOFrOG_gAjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNTo1MzoyMlrOG_nx9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzNzkwMw==", "bodyText": "What is the concurrency of this code? Will multiple threads ever be running here?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1855#discussion_r469237903", "createdAt": "2020-08-12T12:56:08Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServerUpIteratorStep.java", "diffHunk": "@@ -142,19 +154,53 @@ private boolean isServerInCluster(ServerStartupInfo ssi) {\n \n   static class StartManagedServersStep extends Step {\n     final Collection<StepAndPacket> startDetails;\n+    final Queue<StepAndPacket> startDetailsQueue = new ConcurrentLinkedQueue<>();\n+    final String clusterName;\n+    int numStarted = 0;\n+    int maxConcurrency = 0;\n \n-    StartManagedServersStep(Collection<StepAndPacket> startDetails, Step next) {\n+    StartManagedServersStep(String clusterName, Collection<StepAndPacket> startDetails, Step next) {\n       super(next);\n+      this.clusterName = clusterName;\n       this.startDetails = startDetails;\n+      startDetails.forEach(this::add);\n     }\n \n-    Collection<StepAndPacket> getStartDetails() {\n-      return startDetails;\n+    void add(StepAndPacket serverToStart) {\n+      startDetailsQueue.add(new StepAndPacket(serverToStart.step, serverToStart.packet));\n+      this.maxConcurrency = Optional.ofNullable(\n+              (Integer) serverToStart.packet.get(ProcessingConstants.MAX_CONCURRENCY)).orElse(0);\n     }\n \n     @Override\n     public NextAction apply(Packet packet) {\n-      return doForkJoin(new ManagedServerUpAfterStep(getNext()), packet, startDetails);\n+\n+      if (startDetailsQueue.isEmpty()) {\n+        return doNext(new ManagedServerUpAfterStep(getNext()), packet);\n+      } else if (isServiceOnlyOrShuttingDown()) {\n+        Collection<StepAndPacket> servers = Collections.singletonList(startDetailsQueue.poll());\n+        return doForkJoin(this, packet, servers);\n+      } else if (serverAvailableToStart(packet.getSpi(DomainPresenceInfo.class))) {\n+        this.numStarted++;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "beeb8e00547288ae23f5df1eb41222f080ccdee7"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI1MzIyOA==", "bodyText": "It's one thread per cluster and one thread for non-clustered servers. It'll be single threaded for one cluster and 2 threads for 2 cluster case. If domain also have non-clustered (standalone) servers, it'll create a separate fiber for those servers.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1855#discussion_r469253228", "createdAt": "2020-08-12T13:20:04Z", "author": {"login": "ankedia"}, "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServerUpIteratorStep.java", "diffHunk": "@@ -142,19 +154,53 @@ private boolean isServerInCluster(ServerStartupInfo ssi) {\n \n   static class StartManagedServersStep extends Step {\n     final Collection<StepAndPacket> startDetails;\n+    final Queue<StepAndPacket> startDetailsQueue = new ConcurrentLinkedQueue<>();\n+    final String clusterName;\n+    int numStarted = 0;\n+    int maxConcurrency = 0;\n \n-    StartManagedServersStep(Collection<StepAndPacket> startDetails, Step next) {\n+    StartManagedServersStep(String clusterName, Collection<StepAndPacket> startDetails, Step next) {\n       super(next);\n+      this.clusterName = clusterName;\n       this.startDetails = startDetails;\n+      startDetails.forEach(this::add);\n     }\n \n-    Collection<StepAndPacket> getStartDetails() {\n-      return startDetails;\n+    void add(StepAndPacket serverToStart) {\n+      startDetailsQueue.add(new StepAndPacket(serverToStart.step, serverToStart.packet));\n+      this.maxConcurrency = Optional.ofNullable(\n+              (Integer) serverToStart.packet.get(ProcessingConstants.MAX_CONCURRENCY)).orElse(0);\n     }\n \n     @Override\n     public NextAction apply(Packet packet) {\n-      return doForkJoin(new ManagedServerUpAfterStep(getNext()), packet, startDetails);\n+\n+      if (startDetailsQueue.isEmpty()) {\n+        return doNext(new ManagedServerUpAfterStep(getNext()), packet);\n+      } else if (isServiceOnlyOrShuttingDown()) {\n+        Collection<StepAndPacket> servers = Collections.singletonList(startDetailsQueue.poll());\n+        return doForkJoin(this, packet, servers);\n+      } else if (serverAvailableToStart(packet.getSpi(DomainPresenceInfo.class))) {\n+        this.numStarted++;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzNzkwMw=="}, "originalCommit": {"oid": "beeb8e00547288ae23f5df1eb41222f080ccdee7"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI5ODUzOQ==", "bodyText": "Let me be clearer in my question. Do I need to worry about the concurrency of updating the numStarted variable? I can't really tell from your answer.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1855#discussion_r469298539", "createdAt": "2020-08-12T14:24:15Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServerUpIteratorStep.java", "diffHunk": "@@ -142,19 +154,53 @@ private boolean isServerInCluster(ServerStartupInfo ssi) {\n \n   static class StartManagedServersStep extends Step {\n     final Collection<StepAndPacket> startDetails;\n+    final Queue<StepAndPacket> startDetailsQueue = new ConcurrentLinkedQueue<>();\n+    final String clusterName;\n+    int numStarted = 0;\n+    int maxConcurrency = 0;\n \n-    StartManagedServersStep(Collection<StepAndPacket> startDetails, Step next) {\n+    StartManagedServersStep(String clusterName, Collection<StepAndPacket> startDetails, Step next) {\n       super(next);\n+      this.clusterName = clusterName;\n       this.startDetails = startDetails;\n+      startDetails.forEach(this::add);\n     }\n \n-    Collection<StepAndPacket> getStartDetails() {\n-      return startDetails;\n+    void add(StepAndPacket serverToStart) {\n+      startDetailsQueue.add(new StepAndPacket(serverToStart.step, serverToStart.packet));\n+      this.maxConcurrency = Optional.ofNullable(\n+              (Integer) serverToStart.packet.get(ProcessingConstants.MAX_CONCURRENCY)).orElse(0);\n     }\n \n     @Override\n     public NextAction apply(Packet packet) {\n-      return doForkJoin(new ManagedServerUpAfterStep(getNext()), packet, startDetails);\n+\n+      if (startDetailsQueue.isEmpty()) {\n+        return doNext(new ManagedServerUpAfterStep(getNext()), packet);\n+      } else if (isServiceOnlyOrShuttingDown()) {\n+        Collection<StepAndPacket> servers = Collections.singletonList(startDetailsQueue.poll());\n+        return doForkJoin(this, packet, servers);\n+      } else if (serverAvailableToStart(packet.getSpi(DomainPresenceInfo.class))) {\n+        this.numStarted++;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzNzkwMw=="}, "originalCommit": {"oid": "beeb8e00547288ae23f5df1eb41222f080ccdee7"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM2NTIzNw==", "bodyText": "Sorry for not being clear in my previous answer. In 2 cluster scenario, 2 threads could reading/updating in parallel but overall concurrency will be low. I have changed numStarted to AtomicInteger as we discussed and made numConcurrency  final by setting it in constructor. Please let me know if I missed anything. Thanks.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1855#discussion_r469365237", "createdAt": "2020-08-12T15:53:22Z", "author": {"login": "ankedia"}, "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServerUpIteratorStep.java", "diffHunk": "@@ -142,19 +154,53 @@ private boolean isServerInCluster(ServerStartupInfo ssi) {\n \n   static class StartManagedServersStep extends Step {\n     final Collection<StepAndPacket> startDetails;\n+    final Queue<StepAndPacket> startDetailsQueue = new ConcurrentLinkedQueue<>();\n+    final String clusterName;\n+    int numStarted = 0;\n+    int maxConcurrency = 0;\n \n-    StartManagedServersStep(Collection<StepAndPacket> startDetails, Step next) {\n+    StartManagedServersStep(String clusterName, Collection<StepAndPacket> startDetails, Step next) {\n       super(next);\n+      this.clusterName = clusterName;\n       this.startDetails = startDetails;\n+      startDetails.forEach(this::add);\n     }\n \n-    Collection<StepAndPacket> getStartDetails() {\n-      return startDetails;\n+    void add(StepAndPacket serverToStart) {\n+      startDetailsQueue.add(new StepAndPacket(serverToStart.step, serverToStart.packet));\n+      this.maxConcurrency = Optional.ofNullable(\n+              (Integer) serverToStart.packet.get(ProcessingConstants.MAX_CONCURRENCY)).orElse(0);\n     }\n \n     @Override\n     public NextAction apply(Packet packet) {\n-      return doForkJoin(new ManagedServerUpAfterStep(getNext()), packet, startDetails);\n+\n+      if (startDetailsQueue.isEmpty()) {\n+        return doNext(new ManagedServerUpAfterStep(getNext()), packet);\n+      } else if (isServiceOnlyOrShuttingDown()) {\n+        Collection<StepAndPacket> servers = Collections.singletonList(startDetailsQueue.poll());\n+        return doForkJoin(this, packet, servers);\n+      } else if (serverAvailableToStart(packet.getSpi(DomainPresenceInfo.class))) {\n+        this.numStarted++;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzNzkwMw=="}, "originalCommit": {"oid": "beeb8e00547288ae23f5df1eb41222f080ccdee7"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTk3MDkxOnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServerUpIteratorStep.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMjo1Njo1OVrOG_gCkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMzo0NTo0M1rOG_iBNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzODQxOA==", "bodyText": "Similarly, it seems like you ought to be checking for the number of unready pods.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1855#discussion_r469238418", "createdAt": "2020-08-12T12:56:59Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServerUpIteratorStep.java", "diffHunk": "@@ -142,19 +154,53 @@ private boolean isServerInCluster(ServerStartupInfo ssi) {\n \n   static class StartManagedServersStep extends Step {\n     final Collection<StepAndPacket> startDetails;\n+    final Queue<StepAndPacket> startDetailsQueue = new ConcurrentLinkedQueue<>();\n+    final String clusterName;\n+    int numStarted = 0;\n+    int maxConcurrency = 0;\n \n-    StartManagedServersStep(Collection<StepAndPacket> startDetails, Step next) {\n+    StartManagedServersStep(String clusterName, Collection<StepAndPacket> startDetails, Step next) {\n       super(next);\n+      this.clusterName = clusterName;\n       this.startDetails = startDetails;\n+      startDetails.forEach(this::add);\n     }\n \n-    Collection<StepAndPacket> getStartDetails() {\n-      return startDetails;\n+    void add(StepAndPacket serverToStart) {\n+      startDetailsQueue.add(new StepAndPacket(serverToStart.step, serverToStart.packet));\n+      this.maxConcurrency = Optional.ofNullable(\n+              (Integer) serverToStart.packet.get(ProcessingConstants.MAX_CONCURRENCY)).orElse(0);\n     }\n \n     @Override\n     public NextAction apply(Packet packet) {\n-      return doForkJoin(new ManagedServerUpAfterStep(getNext()), packet, startDetails);\n+\n+      if (startDetailsQueue.isEmpty()) {\n+        return doNext(new ManagedServerUpAfterStep(getNext()), packet);\n+      } else if (isServiceOnlyOrShuttingDown()) {\n+        Collection<StepAndPacket> servers = Collections.singletonList(startDetailsQueue.poll());\n+        return doForkJoin(this, packet, servers);\n+      } else if (serverAvailableToStart(packet.getSpi(DomainPresenceInfo.class))) {\n+        this.numStarted++;\n+        return doForkJoin(this, packet, Collections.singletonList(startDetailsQueue.poll()));\n+      } else {\n+        return doDelay(this, packet, 100, TimeUnit.MILLISECONDS);\n+      }\n+    }\n+\n+    private boolean isServiceOnlyOrShuttingDown() {\n+      return Optional.ofNullable(startDetailsQueue.peek().step)\n+              .map(step -> step.getNext() instanceof ServerDownStep).orElse(false);\n+    }\n+\n+    private boolean serverAvailableToStart(DomainPresenceInfo info) {\n+      return ((this.numStarted < PodHelper.getScheduledPods(info, clusterName).size())\n+              && (canStartConcurrently(PodHelper.getReadyPods(info, clusterName).size())));\n+    }\n+\n+    private boolean canStartConcurrently(int numReady) {\n+      return ((this.maxConcurrency > 0) && (this.numStarted < (this.maxConcurrency + numReady - 1)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "beeb8e00547288ae23f5df1eb41222f080ccdee7"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI3MDgzOA==", "bodyText": "Please see above comment about creating fibers based on value of maxConcurrency. I think we can't wait for all previous pods to be ready and need to check for number of ready pods in order to decide whether to create a new fiber/thread or not.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1855#discussion_r469270838", "createdAt": "2020-08-12T13:45:43Z", "author": {"login": "ankedia"}, "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServerUpIteratorStep.java", "diffHunk": "@@ -142,19 +154,53 @@ private boolean isServerInCluster(ServerStartupInfo ssi) {\n \n   static class StartManagedServersStep extends Step {\n     final Collection<StepAndPacket> startDetails;\n+    final Queue<StepAndPacket> startDetailsQueue = new ConcurrentLinkedQueue<>();\n+    final String clusterName;\n+    int numStarted = 0;\n+    int maxConcurrency = 0;\n \n-    StartManagedServersStep(Collection<StepAndPacket> startDetails, Step next) {\n+    StartManagedServersStep(String clusterName, Collection<StepAndPacket> startDetails, Step next) {\n       super(next);\n+      this.clusterName = clusterName;\n       this.startDetails = startDetails;\n+      startDetails.forEach(this::add);\n     }\n \n-    Collection<StepAndPacket> getStartDetails() {\n-      return startDetails;\n+    void add(StepAndPacket serverToStart) {\n+      startDetailsQueue.add(new StepAndPacket(serverToStart.step, serverToStart.packet));\n+      this.maxConcurrency = Optional.ofNullable(\n+              (Integer) serverToStart.packet.get(ProcessingConstants.MAX_CONCURRENCY)).orElse(0);\n     }\n \n     @Override\n     public NextAction apply(Packet packet) {\n-      return doForkJoin(new ManagedServerUpAfterStep(getNext()), packet, startDetails);\n+\n+      if (startDetailsQueue.isEmpty()) {\n+        return doNext(new ManagedServerUpAfterStep(getNext()), packet);\n+      } else if (isServiceOnlyOrShuttingDown()) {\n+        Collection<StepAndPacket> servers = Collections.singletonList(startDetailsQueue.poll());\n+        return doForkJoin(this, packet, servers);\n+      } else if (serverAvailableToStart(packet.getSpi(DomainPresenceInfo.class))) {\n+        this.numStarted++;\n+        return doForkJoin(this, packet, Collections.singletonList(startDetailsQueue.poll()));\n+      } else {\n+        return doDelay(this, packet, 100, TimeUnit.MILLISECONDS);\n+      }\n+    }\n+\n+    private boolean isServiceOnlyOrShuttingDown() {\n+      return Optional.ofNullable(startDetailsQueue.peek().step)\n+              .map(step -> step.getNext() instanceof ServerDownStep).orElse(false);\n+    }\n+\n+    private boolean serverAvailableToStart(DomainPresenceInfo info) {\n+      return ((this.numStarted < PodHelper.getScheduledPods(info, clusterName).size())\n+              && (canStartConcurrently(PodHelper.getReadyPods(info, clusterName).size())));\n+    }\n+\n+    private boolean canStartConcurrently(int numReady) {\n+      return ((this.maxConcurrency > 0) && (this.numStarted < (this.maxConcurrency + numReady - 1)))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzODQxOA=="}, "originalCommit": {"oid": "beeb8e00547288ae23f5df1eb41222f080ccdee7"}, "originalPosition": 115}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4179, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}