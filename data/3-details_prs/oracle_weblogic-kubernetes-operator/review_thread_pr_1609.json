{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwNDA0ODQ5", "number": 1609, "reviewThreads": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMDozOTo0MlrOD3b1Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMDo1Mjo0NlrOD3b-NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDU0MjMwOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMDozOTo0MlrOGNsH1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNTozMTowMFrOGOusWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwNzU3Mw==", "bodyText": "desired state of the ...", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r417007573", "createdAt": "2020-04-29T00:39:42Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -187,4 +187,18 @@ public static boolean doesImageExist(String searchString) {\n   public static boolean isHelmReleaseDeployed(String releaseName, String namespace) {\n     return Helm.isReleaseDeployed(releaseName, namespace);\n   }\n+\n+  /**\n+   * Check if a persistent volume is in a given state.\n+   *\n+   * @param name name of the persistent volume\n+   * @param state state of the persistent volume to match", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5ODI2NA==", "bodyText": "Since I removed the pvc and pv creation this assertion is no loner needed.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r418098264", "createdAt": "2020-04-30T15:31:00Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -187,4 +187,18 @@ public static boolean doesImageExist(String searchString) {\n   public static boolean isHelmReleaseDeployed(String releaseName, String namespace) {\n     return Helm.isReleaseDeployed(releaseName, namespace);\n   }\n+\n+  /**\n+   * Check if a persistent volume is in a given state.\n+   *\n+   * @param name name of the persistent volume\n+   * @param state state of the persistent volume to match", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwNzU3Mw=="}, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDU0MjcxOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMDo0MDowMlrOGNsIJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNTozMToxNFrOGOutCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwNzY1Mg==", "bodyText": "feels like an enum would make sense for the state arg", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r417007652", "createdAt": "2020-04-29T00:40:02Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -187,4 +187,18 @@ public static boolean doesImageExist(String searchString) {\n   public static boolean isHelmReleaseDeployed(String releaseName, String namespace) {\n     return Helm.isReleaseDeployed(releaseName, namespace);\n   }\n+\n+  /**\n+   * Check if a persistent volume is in a given state.\n+   *\n+   * @param name name of the persistent volume\n+   * @param state state of the persistent volume to match\n+   * @return true if state matches otherwise false\n+   */\n+  public static Callable<Boolean> isPersistentVolumeInState(String name, String state) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5ODQ0Mg==", "bodyText": "see my above comment", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r418098442", "createdAt": "2020-04-30T15:31:14Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -187,4 +187,18 @@ public static boolean doesImageExist(String searchString) {\n   public static boolean isHelmReleaseDeployed(String releaseName, String namespace) {\n     return Helm.isReleaseDeployed(releaseName, namespace);\n   }\n+\n+  /**\n+   * Check if a persistent volume is in a given state.\n+   *\n+   * @param name name of the persistent volume\n+   * @param state state of the persistent volume to match\n+   * @return true if state matches otherwise false\n+   */\n+  public static Callable<Boolean> isPersistentVolumeInState(String name, String state) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwNzY1Mg=="}, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDU0MzI4OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMDo0MDoyNFrOGNsIew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNTozMTo1MFrOGOuuxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwNzczOQ==", "bodyText": "desired state...", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r417007739", "createdAt": "2020-04-29T00:40:24Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -300,6 +303,25 @@ public static void listServices(String namespace, String labelSelectors) throws\n     }\n   }\n \n+  /**\n+   * Check if a persistent volume is in a given state.\n+   *\n+   * @param name name of the persistent volume\n+   * @param state state of the persistent volume to match", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5ODg4NA==", "bodyText": "the method is removed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r418098884", "createdAt": "2020-04-30T15:31:50Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -300,6 +303,25 @@ public static void listServices(String namespace, String labelSelectors) throws\n     }\n   }\n \n+  /**\n+   * Check if a persistent volume is in a given state.\n+   *\n+   * @param name name of the persistent volume\n+   * @param state state of the persistent volume to match", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwNzczOQ=="}, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDU1MjMwOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMDo0NDo1N1rOGNsNaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNTozMzowM1rOGOux0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwOTAwMQ==", "bodyText": "not sure if this is reliable\nspec.volumeName and spec.storageClassName might be better\nand/or get the pv and check its claim name matches", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r417009001", "createdAt": "2020-04-29T00:44:57Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "diffHunk": "@@ -55,75 +83,142 @@ public static void collectLogs(Object itInstance, List namespaces) {\n    *\n    * @param namespace in which to query cluster for artifacts\n    * @param resultDir existing directory to write log files\n-   * @throws IOException when writing to log files fail\n-   * @throws ApiException when Kubernetes cluster query fails\n    */\n-  public static void generateLog(String namespace, Path resultDir) throws IOException, ApiException {\n+  public static void collectLogs(String namespace, String resultDir) {\n     logger.info(\"Collecting logs in namespace : {0}\", namespace);\n \n     // get service accounts\n-    writeToFile(Kubernetes.listServiceAccounts(namespace), resultDir.toString(), namespace + \"_sa.log\");\n+    try {\n+      writeToFile(Kubernetes.listServiceAccounts(namespace), resultDir, namespace + \"_sa.log\");\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+    }\n \n     // get namespaces\n-    for (var ns: Kubernetes.listNamespacesAsObjects().getItems()) {\n-      if (namespace.equals(ns.getMetadata().getName())) {\n-        writeToFile(ns, resultDir.toString(), namespace + \"_ns.log\");\n+    try {\n+      for (var ns : Kubernetes.listNamespacesAsObjects().getItems()) {\n+        if (namespace.equals(ns.getMetadata().getName())) {\n+          writeToFile(ns, resultDir, namespace + \"_ns.log\");\n+        }\n       }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n     }\n \n     // get pvc\n-    writeToFile(Kubernetes.listPersistentVolumeClaims(namespace), resultDir.toString(), namespace + \"_pvc.log\");\n-\n-    // get pv based on the weblogic.domainUID in pvc\n-    for (var pvc : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n-      if (pvc.getMetadata() != null\n-          && pvc.getMetadata().getLabels() != null\n-          && pvc.getMetadata().getLabels().get(\"weblogic.domainUID\") != null) {\n-        String label = pvc.getMetadata().getLabels().get(\"weblogic.domainUID\");\n-        writeToFile(Kubernetes.listPersistentVolumes(\n-            String.format(\"weblogic.domainUID in (%s)\", label)), resultDir.toString(), label + \"_pv.log\");\n+    try {\n+      writeToFile(Kubernetes.listPersistentVolumeClaims(namespace), resultDir, namespace + \"_pvc.log\");\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+    }\n+\n+    // get pv configuration and pv files based on the weblogic.domainUid label in pvc\n+    try {\n+      for (var pvc : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n+        String label = Optional.ofNullable(pvc)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5OTY2NA==", "bodyText": "changed the implementation to match storageclass, volume name and claim name to find the PV used by the test in that namespace.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r418099664", "createdAt": "2020-04-30T15:33:03Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "diffHunk": "@@ -55,75 +83,142 @@ public static void collectLogs(Object itInstance, List namespaces) {\n    *\n    * @param namespace in which to query cluster for artifacts\n    * @param resultDir existing directory to write log files\n-   * @throws IOException when writing to log files fail\n-   * @throws ApiException when Kubernetes cluster query fails\n    */\n-  public static void generateLog(String namespace, Path resultDir) throws IOException, ApiException {\n+  public static void collectLogs(String namespace, String resultDir) {\n     logger.info(\"Collecting logs in namespace : {0}\", namespace);\n \n     // get service accounts\n-    writeToFile(Kubernetes.listServiceAccounts(namespace), resultDir.toString(), namespace + \"_sa.log\");\n+    try {\n+      writeToFile(Kubernetes.listServiceAccounts(namespace), resultDir, namespace + \"_sa.log\");\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+    }\n \n     // get namespaces\n-    for (var ns: Kubernetes.listNamespacesAsObjects().getItems()) {\n-      if (namespace.equals(ns.getMetadata().getName())) {\n-        writeToFile(ns, resultDir.toString(), namespace + \"_ns.log\");\n+    try {\n+      for (var ns : Kubernetes.listNamespacesAsObjects().getItems()) {\n+        if (namespace.equals(ns.getMetadata().getName())) {\n+          writeToFile(ns, resultDir, namespace + \"_ns.log\");\n+        }\n       }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n     }\n \n     // get pvc\n-    writeToFile(Kubernetes.listPersistentVolumeClaims(namespace), resultDir.toString(), namespace + \"_pvc.log\");\n-\n-    // get pv based on the weblogic.domainUID in pvc\n-    for (var pvc : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n-      if (pvc.getMetadata() != null\n-          && pvc.getMetadata().getLabels() != null\n-          && pvc.getMetadata().getLabels().get(\"weblogic.domainUID\") != null) {\n-        String label = pvc.getMetadata().getLabels().get(\"weblogic.domainUID\");\n-        writeToFile(Kubernetes.listPersistentVolumes(\n-            String.format(\"weblogic.domainUID in (%s)\", label)), resultDir.toString(), label + \"_pv.log\");\n+    try {\n+      writeToFile(Kubernetes.listPersistentVolumeClaims(namespace), resultDir, namespace + \"_pvc.log\");\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+    }\n+\n+    // get pv configuration and pv files based on the weblogic.domainUid label in pvc\n+    try {\n+      for (var pvc : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n+        String label = Optional.ofNullable(pvc)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwOTAwMQ=="}, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDU1MzgxOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMDo0NjowMVrOGNsOVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNTozMzoxM1rOGOuyMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwOTIzNg==", "bodyText": "let's improve the file names to make it easier for someone looking at them to know what they are, e.g. namespace.list.service-accounts.log  and so on..\nnamespace, get/list/whatever, type, name", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r417009236", "createdAt": "2020-04-29T00:46:01Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "diffHunk": "@@ -55,75 +83,142 @@ public static void collectLogs(Object itInstance, List namespaces) {\n    *\n    * @param namespace in which to query cluster for artifacts\n    * @param resultDir existing directory to write log files\n-   * @throws IOException when writing to log files fail\n-   * @throws ApiException when Kubernetes cluster query fails\n    */\n-  public static void generateLog(String namespace, Path resultDir) throws IOException, ApiException {\n+  public static void collectLogs(String namespace, String resultDir) {\n     logger.info(\"Collecting logs in namespace : {0}\", namespace);\n \n     // get service accounts\n-    writeToFile(Kubernetes.listServiceAccounts(namespace), resultDir.toString(), namespace + \"_sa.log\");\n+    try {\n+      writeToFile(Kubernetes.listServiceAccounts(namespace), resultDir, namespace + \"_sa.log\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5OTc2Mg==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r418099762", "createdAt": "2020-04-30T15:33:13Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "diffHunk": "@@ -55,75 +83,142 @@ public static void collectLogs(Object itInstance, List namespaces) {\n    *\n    * @param namespace in which to query cluster for artifacts\n    * @param resultDir existing directory to write log files\n-   * @throws IOException when writing to log files fail\n-   * @throws ApiException when Kubernetes cluster query fails\n    */\n-  public static void generateLog(String namespace, Path resultDir) throws IOException, ApiException {\n+  public static void collectLogs(String namespace, String resultDir) {\n     logger.info(\"Collecting logs in namespace : {0}\", namespace);\n \n     // get service accounts\n-    writeToFile(Kubernetes.listServiceAccounts(namespace), resultDir.toString(), namespace + \"_sa.log\");\n+    try {\n+      writeToFile(Kubernetes.listServiceAccounts(namespace), resultDir, namespace + \"_sa.log\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwOTIzNg=="}, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDU1NjM2OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMDo0NzozMFrOGNsPzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNTozNjo1NVrOGOu8OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwOTYxNA==", "bodyText": "include namespace, name, in the log message", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r417009614", "createdAt": "2020-04-29T00:47:30Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "diffHunk": "@@ -55,75 +83,142 @@ public static void collectLogs(Object itInstance, List namespaces) {\n    *\n    * @param namespace in which to query cluster for artifacts\n    * @param resultDir existing directory to write log files\n-   * @throws IOException when writing to log files fail\n-   * @throws ApiException when Kubernetes cluster query fails\n    */\n-  public static void generateLog(String namespace, Path resultDir) throws IOException, ApiException {\n+  public static void collectLogs(String namespace, String resultDir) {\n     logger.info(\"Collecting logs in namespace : {0}\", namespace);\n \n     // get service accounts\n-    writeToFile(Kubernetes.listServiceAccounts(namespace), resultDir.toString(), namespace + \"_sa.log\");\n+    try {\n+      writeToFile(Kubernetes.listServiceAccounts(namespace), resultDir, namespace + \"_sa.log\");\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+    }\n \n     // get namespaces\n-    for (var ns: Kubernetes.listNamespacesAsObjects().getItems()) {\n-      if (namespace.equals(ns.getMetadata().getName())) {\n-        writeToFile(ns, resultDir.toString(), namespace + \"_ns.log\");\n+    try {\n+      for (var ns : Kubernetes.listNamespacesAsObjects().getItems()) {\n+        if (namespace.equals(ns.getMetadata().getName())) {\n+          writeToFile(ns, resultDir, namespace + \"_ns.log\");\n+        }\n       }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n     }\n \n     // get pvc\n-    writeToFile(Kubernetes.listPersistentVolumeClaims(namespace), resultDir.toString(), namespace + \"_pvc.log\");\n-\n-    // get pv based on the weblogic.domainUID in pvc\n-    for (var pvc : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n-      if (pvc.getMetadata() != null\n-          && pvc.getMetadata().getLabels() != null\n-          && pvc.getMetadata().getLabels().get(\"weblogic.domainUID\") != null) {\n-        String label = pvc.getMetadata().getLabels().get(\"weblogic.domainUID\");\n-        writeToFile(Kubernetes.listPersistentVolumes(\n-            String.format(\"weblogic.domainUID in (%s)\", label)), resultDir.toString(), label + \"_pv.log\");\n+    try {\n+      writeToFile(Kubernetes.listPersistentVolumeClaims(namespace), resultDir, namespace + \"_pvc.log\");\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+    }\n+\n+    // get pv configuration and pv files based on the weblogic.domainUid label in pvc\n+    try {\n+      for (var pvc : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n+        String label = Optional.ofNullable(pvc)\n+            .map(metadata -> metadata.getMetadata())\n+            .map(labels -> labels.getLabels())\n+            .map(labels -> labels.get(\"weblogic.domainUid\")).get();\n+\n+        // get the persistent volumes based on label weblogic.domainUid\n+        V1PersistentVolumeList pvList = Kubernetes\n+            .listPersistentVolumes(String.format(\"weblogic.domainUid = %s\", label));\n+        // write the persistent volume configurations to log\n+        writeToFile(pvList, resultDir, label + \"_pv.log\");\n+\n+        // dump files stored in persistent volumes to\n+        // RESULT_DIR/PVC_NAME/PV_NAME location\n+        for (var pv : pvList.getItems()) {\n+          String claimName = pvc.getMetadata().getName();\n+          String pvName = pv.getMetadata().getName();\n+          String hostPath = pv.getSpec().getHostPath().getPath();\n+          try {\n+            copyFromPV(namespace, hostPath,\n+                Files.createDirectories(\n+                    Paths.get(resultDir, claimName, pvName)));\n+          } catch (ApiException apex) {\n+            logger.warning(apex.getResponseBody());\n+          } catch (Exception ex) {\n+            ex.printStackTrace();\n+            logger.warning(ex.getMessage());\n+          }\n+        }\n+        logger.info(\"Done archiving the persistent volumes\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEwMjMyOA==", "bodyText": "The copyDirectoryFromPod method  will print messages about the copy. The above logging is removed to be consistent with other write methods.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r418102328", "createdAt": "2020-04-30T15:36:55Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "diffHunk": "@@ -55,75 +83,142 @@ public static void collectLogs(Object itInstance, List namespaces) {\n    *\n    * @param namespace in which to query cluster for artifacts\n    * @param resultDir existing directory to write log files\n-   * @throws IOException when writing to log files fail\n-   * @throws ApiException when Kubernetes cluster query fails\n    */\n-  public static void generateLog(String namespace, Path resultDir) throws IOException, ApiException {\n+  public static void collectLogs(String namespace, String resultDir) {\n     logger.info(\"Collecting logs in namespace : {0}\", namespace);\n \n     // get service accounts\n-    writeToFile(Kubernetes.listServiceAccounts(namespace), resultDir.toString(), namespace + \"_sa.log\");\n+    try {\n+      writeToFile(Kubernetes.listServiceAccounts(namespace), resultDir, namespace + \"_sa.log\");\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+    }\n \n     // get namespaces\n-    for (var ns: Kubernetes.listNamespacesAsObjects().getItems()) {\n-      if (namespace.equals(ns.getMetadata().getName())) {\n-        writeToFile(ns, resultDir.toString(), namespace + \"_ns.log\");\n+    try {\n+      for (var ns : Kubernetes.listNamespacesAsObjects().getItems()) {\n+        if (namespace.equals(ns.getMetadata().getName())) {\n+          writeToFile(ns, resultDir, namespace + \"_ns.log\");\n+        }\n       }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n     }\n \n     // get pvc\n-    writeToFile(Kubernetes.listPersistentVolumeClaims(namespace), resultDir.toString(), namespace + \"_pvc.log\");\n-\n-    // get pv based on the weblogic.domainUID in pvc\n-    for (var pvc : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n-      if (pvc.getMetadata() != null\n-          && pvc.getMetadata().getLabels() != null\n-          && pvc.getMetadata().getLabels().get(\"weblogic.domainUID\") != null) {\n-        String label = pvc.getMetadata().getLabels().get(\"weblogic.domainUID\");\n-        writeToFile(Kubernetes.listPersistentVolumes(\n-            String.format(\"weblogic.domainUID in (%s)\", label)), resultDir.toString(), label + \"_pv.log\");\n+    try {\n+      writeToFile(Kubernetes.listPersistentVolumeClaims(namespace), resultDir, namespace + \"_pvc.log\");\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+    }\n+\n+    // get pv configuration and pv files based on the weblogic.domainUid label in pvc\n+    try {\n+      for (var pvc : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n+        String label = Optional.ofNullable(pvc)\n+            .map(metadata -> metadata.getMetadata())\n+            .map(labels -> labels.getLabels())\n+            .map(labels -> labels.get(\"weblogic.domainUid\")).get();\n+\n+        // get the persistent volumes based on label weblogic.domainUid\n+        V1PersistentVolumeList pvList = Kubernetes\n+            .listPersistentVolumes(String.format(\"weblogic.domainUid = %s\", label));\n+        // write the persistent volume configurations to log\n+        writeToFile(pvList, resultDir, label + \"_pv.log\");\n+\n+        // dump files stored in persistent volumes to\n+        // RESULT_DIR/PVC_NAME/PV_NAME location\n+        for (var pv : pvList.getItems()) {\n+          String claimName = pvc.getMetadata().getName();\n+          String pvName = pv.getMetadata().getName();\n+          String hostPath = pv.getSpec().getHostPath().getPath();\n+          try {\n+            copyFromPV(namespace, hostPath,\n+                Files.createDirectories(\n+                    Paths.get(resultDir, claimName, pvName)));\n+          } catch (ApiException apex) {\n+            logger.warning(apex.getResponseBody());\n+          } catch (Exception ex) {\n+            ex.printStackTrace();\n+            logger.warning(ex.getMessage());\n+          }\n+        }\n+        logger.info(\"Done archiving the persistent volumes\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwOTYxNA=="}, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDU1ODI2OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMDo0ODo1MlrOGNsQ6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNTozODo0MFrOGOvA2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwOTg5OQ==", "bodyText": "pv's are not namespaced - explain what the namespace param is for more clearly", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r417009899", "createdAt": "2020-04-29T00:48:52Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "diffHunk": "@@ -137,4 +232,162 @@ private static void writeToFile(Object obj, String resultDir, String fileName) t\n     }\n   }\n \n-}\n+  /**\n+   * Copy files from persistent volume to local folder.\n+   * @param namespace name of the namespace", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEwMzUxNA==", "bodyText": "modified the descriptions to be more clear.\nFor the record\nThe namespace is used for creating the temporary pod not for pv.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r418103514", "createdAt": "2020-04-30T15:38:40Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "diffHunk": "@@ -137,4 +232,162 @@ private static void writeToFile(Object obj, String resultDir, String fileName) t\n     }\n   }\n \n-}\n+  /**\n+   * Copy files from persistent volume to local folder.\n+   * @param namespace name of the namespace", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwOTg5OQ=="}, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 260}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDU2MDExOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMDo0OTo0MVrOGNsR8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNTo0MjozOFrOGOvLeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxMDE2Mg==", "bodyText": "what does hostPath mean in this context?  there is a storage provider in k8s called HostPath -- are you talking about that? if not, pick a better/different name to avoid confusion", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r417010162", "createdAt": "2020-04-29T00:49:41Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "diffHunk": "@@ -137,4 +232,162 @@ private static void writeToFile(Object obj, String resultDir, String fileName) t\n     }\n   }\n \n-}\n+  /**\n+   * Copy files from persistent volume to local folder.\n+   * @param namespace name of the namespace\n+   * @param hostPath the persistent volume host path", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 261}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEwNjIzMg==", "bodyText": "The hostPath object from persistent volume configuration of ineterest.\nI thought of creating the one-off pod with a new pvc and pv based on the hostPath object from the PV that needs to be archived.\nNow I removed that new pv and pvc creation and using the pv/pvc from the test to be used in the one-off pod.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r418106232", "createdAt": "2020-04-30T15:42:38Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "diffHunk": "@@ -137,4 +232,162 @@ private static void writeToFile(Object obj, String resultDir, String fileName) t\n     }\n   }\n \n-}\n+  /**\n+   * Copy files from persistent volume to local folder.\n+   * @param namespace name of the namespace\n+   * @param hostPath the persistent volume host path", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxMDE2Mg=="}, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 261}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDU2MDU5OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMDo1MDowNFrOGNsSOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNTo0ODoxM1rOGOvaiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxMDIzNQ==", "bodyText": "why do you need ns? why not just use default?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r417010235", "createdAt": "2020-04-29T00:50:04Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "diffHunk": "@@ -137,4 +232,162 @@ private static void writeToFile(Object obj, String resultDir, String fileName) t\n     }\n   }\n \n-}\n+  /**\n+   * Copy files from persistent volume to local folder.\n+   * @param namespace name of the namespace\n+   * @param hostPath the persistent volume host path\n+   * @param destinationPath destination folder to copy the files to\n+   * @throws ApiException when pod interaction fails\n+   */\n+  private static void copyFromPV(String namespace, String hostPath, Path destinationPath) throws ApiException {\n+    V1Pod pvPod = null;\n+    try {\n+      // create a temporary pod to get access to the interested persistent volume\n+      pvPod = setupPVPod(namespace, hostPath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 269}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODExMDA4OQ==", "bodyText": "I am creating the one-off pod in the same namespace the test used, also to create the one-off pod with a namespace appended to its name.\nSo even if there is a problem in one-off pod deletion, when the test runs the cleanup util everything in that test namespace gets wiped out.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r418110089", "createdAt": "2020-04-30T15:48:13Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "diffHunk": "@@ -137,4 +232,162 @@ private static void writeToFile(Object obj, String resultDir, String fileName) t\n     }\n   }\n \n-}\n+  /**\n+   * Copy files from persistent volume to local folder.\n+   * @param namespace name of the namespace\n+   * @param hostPath the persistent volume host path\n+   * @param destinationPath destination folder to copy the files to\n+   * @throws ApiException when pod interaction fails\n+   */\n+  private static void copyFromPV(String namespace, String hostPath, Path destinationPath) throws ApiException {\n+    V1Pod pvPod = null;\n+    try {\n+      // create a temporary pod to get access to the interested persistent volume\n+      pvPod = setupPVPod(namespace, hostPath);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxMDIzNQ=="}, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 269}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDU2MTI2OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMDo1MDoyN1rOGNsSmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNTo0ODoyMlrOGOva8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxMDMzMQ==", "bodyText": "you are not creating a PV right?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r417010331", "createdAt": "2020-04-29T00:50:27Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "diffHunk": "@@ -137,4 +232,162 @@ private static void writeToFile(Object obj, String resultDir, String fileName) t\n     }\n   }\n \n-}\n+  /**\n+   * Copy files from persistent volume to local folder.\n+   * @param namespace name of the namespace\n+   * @param hostPath the persistent volume host path\n+   * @param destinationPath destination folder to copy the files to\n+   * @throws ApiException when pod interaction fails\n+   */\n+  private static void copyFromPV(String namespace, String hostPath, Path destinationPath) throws ApiException {\n+    V1Pod pvPod = null;\n+    try {\n+      // create a temporary pod to get access to the interested persistent volume\n+      pvPod = setupPVPod(namespace, hostPath);\n+      copyDirectoryFromPod(pvPod, hostPath, destinationPath);\n+    } finally {\n+      // remove the temporary pod\n+      if (pvPod != null) {\n+        cleanupPVPod(namespace);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Creates temporary pod with persistent volume claim and persistent volume using host path.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODExMDE5Mg==", "bodyText": "removed the pv creation", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r418110192", "createdAt": "2020-04-30T15:48:22Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "diffHunk": "@@ -137,4 +232,162 @@ private static void writeToFile(Object obj, String resultDir, String fileName) t\n     }\n   }\n \n-}\n+  /**\n+   * Copy files from persistent volume to local folder.\n+   * @param namespace name of the namespace\n+   * @param hostPath the persistent volume host path\n+   * @param destinationPath destination folder to copy the files to\n+   * @throws ApiException when pod interaction fails\n+   */\n+  private static void copyFromPV(String namespace, String hostPath, Path destinationPath) throws ApiException {\n+    V1Pod pvPod = null;\n+    try {\n+      // create a temporary pod to get access to the interested persistent volume\n+      pvPod = setupPVPod(namespace, hostPath);\n+      copyDirectoryFromPod(pvPod, hostPath, destinationPath);\n+    } finally {\n+      // remove the temporary pod\n+      if (pvPod != null) {\n+        cleanupPVPod(namespace);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Creates temporary pod with persistent volume claim and persistent volume using host path.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxMDMzMQ=="}, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 280}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDU2MTQwOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMDo1MDozM1rOGNsSsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNjozNDo0M1rOGOxR6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxMDM1NQ==", "bodyText": "what namespace?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r417010355", "createdAt": "2020-04-29T00:50:33Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "diffHunk": "@@ -137,4 +232,162 @@ private static void writeToFile(Object obj, String resultDir, String fileName) t\n     }\n   }\n \n-}\n+  /**\n+   * Copy files from persistent volume to local folder.\n+   * @param namespace name of the namespace\n+   * @param hostPath the persistent volume host path\n+   * @param destinationPath destination folder to copy the files to\n+   * @throws ApiException when pod interaction fails\n+   */\n+  private static void copyFromPV(String namespace, String hostPath, Path destinationPath) throws ApiException {\n+    V1Pod pvPod = null;\n+    try {\n+      // create a temporary pod to get access to the interested persistent volume\n+      pvPod = setupPVPod(namespace, hostPath);\n+      copyDirectoryFromPod(pvPod, hostPath, destinationPath);\n+    } finally {\n+      // remove the temporary pod\n+      if (pvPod != null) {\n+        cleanupPVPod(namespace);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Creates temporary pod with persistent volume claim and persistent volume using host path.\n+   *\n+   * @param namespace name of the namespace", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 282}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE0MDY0OQ==", "bodyText": "modified the description to give more details", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r418140649", "createdAt": "2020-04-30T16:34:43Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "diffHunk": "@@ -137,4 +232,162 @@ private static void writeToFile(Object obj, String resultDir, String fileName) t\n     }\n   }\n \n-}\n+  /**\n+   * Copy files from persistent volume to local folder.\n+   * @param namespace name of the namespace\n+   * @param hostPath the persistent volume host path\n+   * @param destinationPath destination folder to copy the files to\n+   * @throws ApiException when pod interaction fails\n+   */\n+  private static void copyFromPV(String namespace, String hostPath, Path destinationPath) throws ApiException {\n+    V1Pod pvPod = null;\n+    try {\n+      // create a temporary pod to get access to the interested persistent volume\n+      pvPod = setupPVPod(namespace, hostPath);\n+      copyDirectoryFromPod(pvPod, hostPath, destinationPath);\n+    } finally {\n+      // remove the temporary pod\n+      if (pvPod != null) {\n+        cleanupPVPod(namespace);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Creates temporary pod with persistent volume claim and persistent volume using host path.\n+   *\n+   * @param namespace name of the namespace", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxMDM1NQ=="}, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 282}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDU2MTQ1OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMDo1MDozN1rOGNsSwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNjozNDo1NFrOGOxSSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxMDM3MA==", "bodyText": "same", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r417010370", "createdAt": "2020-04-29T00:50:37Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "diffHunk": "@@ -137,4 +232,162 @@ private static void writeToFile(Object obj, String resultDir, String fileName) t\n     }\n   }\n \n-}\n+  /**\n+   * Copy files from persistent volume to local folder.\n+   * @param namespace name of the namespace\n+   * @param hostPath the persistent volume host path\n+   * @param destinationPath destination folder to copy the files to\n+   * @throws ApiException when pod interaction fails\n+   */\n+  private static void copyFromPV(String namespace, String hostPath, Path destinationPath) throws ApiException {\n+    V1Pod pvPod = null;\n+    try {\n+      // create a temporary pod to get access to the interested persistent volume\n+      pvPod = setupPVPod(namespace, hostPath);\n+      copyDirectoryFromPod(pvPod, hostPath, destinationPath);\n+    } finally {\n+      // remove the temporary pod\n+      if (pvPod != null) {\n+        cleanupPVPod(namespace);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Creates temporary pod with persistent volume claim and persistent volume using host path.\n+   *\n+   * @param namespace name of the namespace\n+   * @param hostPath host path from ineterested persistent volume", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 283}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE0MDc0NQ==", "bodyText": "modified the description", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r418140745", "createdAt": "2020-04-30T16:34:54Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "diffHunk": "@@ -137,4 +232,162 @@ private static void writeToFile(Object obj, String resultDir, String fileName) t\n     }\n   }\n \n-}\n+  /**\n+   * Copy files from persistent volume to local folder.\n+   * @param namespace name of the namespace\n+   * @param hostPath the persistent volume host path\n+   * @param destinationPath destination folder to copy the files to\n+   * @throws ApiException when pod interaction fails\n+   */\n+  private static void copyFromPV(String namespace, String hostPath, Path destinationPath) throws ApiException {\n+    V1Pod pvPod = null;\n+    try {\n+      // create a temporary pod to get access to the interested persistent volume\n+      pvPod = setupPVPod(namespace, hostPath);\n+      copyDirectoryFromPod(pvPod, hostPath, destinationPath);\n+    } finally {\n+      // remove the temporary pod\n+      if (pvPod != null) {\n+        cleanupPVPod(namespace);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Creates temporary pod with persistent volume claim and persistent volume using host path.\n+   *\n+   * @param namespace name of the namespace\n+   * @param hostPath host path from ineterested persistent volume", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxMDM3MA=="}, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 283}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDU2MjQzOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMDo1MTowOVrOGNsTUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNjo0MDozNFrOGOxfzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxMDUxNQ==", "bodyText": "i am lost here - why are you creating a PV?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r417010515", "createdAt": "2020-04-29T00:51:09Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "diffHunk": "@@ -137,4 +232,162 @@ private static void writeToFile(Object obj, String resultDir, String fileName) t\n     }\n   }\n \n-}\n+  /**\n+   * Copy files from persistent volume to local folder.\n+   * @param namespace name of the namespace\n+   * @param hostPath the persistent volume host path\n+   * @param destinationPath destination folder to copy the files to\n+   * @throws ApiException when pod interaction fails\n+   */\n+  private static void copyFromPV(String namespace, String hostPath, Path destinationPath) throws ApiException {\n+    V1Pod pvPod = null;\n+    try {\n+      // create a temporary pod to get access to the interested persistent volume\n+      pvPod = setupPVPod(namespace, hostPath);\n+      copyDirectoryFromPod(pvPod, hostPath, destinationPath);\n+    } finally {\n+      // remove the temporary pod\n+      if (pvPod != null) {\n+        cleanupPVPod(namespace);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Creates temporary pod with persistent volume claim and persistent volume using host path.\n+   *\n+   * @param namespace name of the namespace\n+   * @param hostPath host path from ineterested persistent volume\n+   * @return V1Pod pod object\n+   * @throws ApiException when create pod fails\n+   */\n+  private static V1Pod setupPVPod(String namespace, String hostPath) throws ApiException {\n+\n+    ConditionFactory withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(5, SECONDS)\n+        .atMost(1, MINUTES).await();\n+\n+    // create a pvc and pv to get access to the host path of the target pv\n+    final String pvcName = \"pv-pod-pvc-\" + namespace;\n+    final String pvName = \"pv-pod-pv-\" + namespace;\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 297}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxMDc1OQ==", "bodyText": "i don't understand what this method is doing. javadoc says it is copying from a pv, so the pv must already exist, right?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r417010759", "createdAt": "2020-04-29T00:51:52Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "diffHunk": "@@ -137,4 +232,162 @@ private static void writeToFile(Object obj, String resultDir, String fileName) t\n     }\n   }\n \n-}\n+  /**\n+   * Copy files from persistent volume to local folder.\n+   * @param namespace name of the namespace\n+   * @param hostPath the persistent volume host path\n+   * @param destinationPath destination folder to copy the files to\n+   * @throws ApiException when pod interaction fails\n+   */\n+  private static void copyFromPV(String namespace, String hostPath, Path destinationPath) throws ApiException {\n+    V1Pod pvPod = null;\n+    try {\n+      // create a temporary pod to get access to the interested persistent volume\n+      pvPod = setupPVPod(namespace, hostPath);\n+      copyDirectoryFromPod(pvPod, hostPath, destinationPath);\n+    } finally {\n+      // remove the temporary pod\n+      if (pvPod != null) {\n+        cleanupPVPod(namespace);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Creates temporary pod with persistent volume claim and persistent volume using host path.\n+   *\n+   * @param namespace name of the namespace\n+   * @param hostPath host path from ineterested persistent volume\n+   * @return V1Pod pod object\n+   * @throws ApiException when create pod fails\n+   */\n+  private static V1Pod setupPVPod(String namespace, String hostPath) throws ApiException {\n+\n+    ConditionFactory withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(5, SECONDS)\n+        .atMost(1, MINUTES).await();\n+\n+    // create a pvc and pv to get access to the host path of the target pv\n+    final String pvcName = \"pv-pod-pvc-\" + namespace;\n+    final String pvName = \"pv-pod-pv-\" + namespace;\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxMDUxNQ=="}, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 297}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE0NDIwNw==", "bodyText": "The initial implementation was to create a new one-off pod with its own pvc and pv (using the hostPath location from the pv used by the test, where the contents need to be archived are located)\nNow I changed the code such that the one-off pod will use the existing pvc/pv used by the test. Mount it under /shared in one-off pod and copy it.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r418144207", "createdAt": "2020-04-30T16:40:34Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "diffHunk": "@@ -137,4 +232,162 @@ private static void writeToFile(Object obj, String resultDir, String fileName) t\n     }\n   }\n \n-}\n+  /**\n+   * Copy files from persistent volume to local folder.\n+   * @param namespace name of the namespace\n+   * @param hostPath the persistent volume host path\n+   * @param destinationPath destination folder to copy the files to\n+   * @throws ApiException when pod interaction fails\n+   */\n+  private static void copyFromPV(String namespace, String hostPath, Path destinationPath) throws ApiException {\n+    V1Pod pvPod = null;\n+    try {\n+      // create a temporary pod to get access to the interested persistent volume\n+      pvPod = setupPVPod(namespace, hostPath);\n+      copyDirectoryFromPod(pvPod, hostPath, destinationPath);\n+    } finally {\n+      // remove the temporary pod\n+      if (pvPod != null) {\n+        cleanupPVPod(namespace);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Creates temporary pod with persistent volume claim and persistent volume using host path.\n+   *\n+   * @param namespace name of the namespace\n+   * @param hostPath host path from ineterested persistent volume\n+   * @return V1Pod pod object\n+   * @throws ApiException when create pod fails\n+   */\n+  private static V1Pod setupPVPod(String namespace, String hostPath) throws ApiException {\n+\n+    ConditionFactory withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(5, SECONDS)\n+        .atMost(1, MINUTES).await();\n+\n+    // create a pvc and pv to get access to the host path of the target pv\n+    final String pvcName = \"pv-pod-pvc-\" + namespace;\n+    final String pvName = \"pv-pod-pv-\" + namespace;\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxMDUxNQ=="}, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 297}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDU2NDgzOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMDo1MjoxNFrOGNsUmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNjo0MTo1MVrOGOxi_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxMDg0Mw==", "bodyText": "don't use nginx... use oraclelinux:7-slim", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r417010843", "createdAt": "2020-04-29T00:52:14Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "diffHunk": "@@ -137,4 +232,162 @@ private static void writeToFile(Object obj, String resultDir, String fileName) t\n     }\n   }\n \n-}\n+  /**\n+   * Copy files from persistent volume to local folder.\n+   * @param namespace name of the namespace\n+   * @param hostPath the persistent volume host path\n+   * @param destinationPath destination folder to copy the files to\n+   * @throws ApiException when pod interaction fails\n+   */\n+  private static void copyFromPV(String namespace, String hostPath, Path destinationPath) throws ApiException {\n+    V1Pod pvPod = null;\n+    try {\n+      // create a temporary pod to get access to the interested persistent volume\n+      pvPod = setupPVPod(namespace, hostPath);\n+      copyDirectoryFromPod(pvPod, hostPath, destinationPath);\n+    } finally {\n+      // remove the temporary pod\n+      if (pvPod != null) {\n+        cleanupPVPod(namespace);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Creates temporary pod with persistent volume claim and persistent volume using host path.\n+   *\n+   * @param namespace name of the namespace\n+   * @param hostPath host path from ineterested persistent volume\n+   * @return V1Pod pod object\n+   * @throws ApiException when create pod fails\n+   */\n+  private static V1Pod setupPVPod(String namespace, String hostPath) throws ApiException {\n+\n+    ConditionFactory withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(5, SECONDS)\n+        .atMost(1, MINUTES).await();\n+\n+    // create a pvc and pv to get access to the host path of the target pv\n+    final String pvcName = \"pv-pod-pvc-\" + namespace;\n+    final String pvName = \"pv-pod-pv-\" + namespace;\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(namespace + \"-weblogic-domain-storage-class\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"2Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Recycle\")\n+            .hostPath(new V1HostPathVolumeSource().path(hostPath)))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvName)\n+            .build());\n+    TestActions.createPersistentVolume(v1pv);\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .volumeName(pvName)\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(namespace + \"-weblogic-domain-storage-class\")\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"2Gi\"))))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvcName)\n+            .withNamespace(namespace)\n+            .build());\n+    TestActions.createPersistentVolumeClaim(v1pvc);\n+\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pv to be bound, \"\n+                + \"(elapsed time {0} , remaining time {1}\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(isPersistentVolumeInState(pvName, \"Bound\"));\n+\n+    final String podName = \"pv-pod-\" + namespace;\n+    V1Pod podBody = new V1Pod()\n+        .spec(new V1PodSpec()\n+            .containers(Arrays.asList(\n+                new V1Container()\n+                    .name(\"pv-container\")\n+                    .image(\"nginx\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 336}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE0NTAyMA==", "bodyText": "The copy api needs tar utility in the one-off pod, oraclelinux:7-slim doesn't have it. Instead using a oraclelinux:latest image", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r418145020", "createdAt": "2020-04-30T16:41:51Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "diffHunk": "@@ -137,4 +232,162 @@ private static void writeToFile(Object obj, String resultDir, String fileName) t\n     }\n   }\n \n-}\n+  /**\n+   * Copy files from persistent volume to local folder.\n+   * @param namespace name of the namespace\n+   * @param hostPath the persistent volume host path\n+   * @param destinationPath destination folder to copy the files to\n+   * @throws ApiException when pod interaction fails\n+   */\n+  private static void copyFromPV(String namespace, String hostPath, Path destinationPath) throws ApiException {\n+    V1Pod pvPod = null;\n+    try {\n+      // create a temporary pod to get access to the interested persistent volume\n+      pvPod = setupPVPod(namespace, hostPath);\n+      copyDirectoryFromPod(pvPod, hostPath, destinationPath);\n+    } finally {\n+      // remove the temporary pod\n+      if (pvPod != null) {\n+        cleanupPVPod(namespace);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Creates temporary pod with persistent volume claim and persistent volume using host path.\n+   *\n+   * @param namespace name of the namespace\n+   * @param hostPath host path from ineterested persistent volume\n+   * @return V1Pod pod object\n+   * @throws ApiException when create pod fails\n+   */\n+  private static V1Pod setupPVPod(String namespace, String hostPath) throws ApiException {\n+\n+    ConditionFactory withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(5, SECONDS)\n+        .atMost(1, MINUTES).await();\n+\n+    // create a pvc and pv to get access to the host path of the target pv\n+    final String pvcName = \"pv-pod-pvc-\" + namespace;\n+    final String pvName = \"pv-pod-pv-\" + namespace;\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(namespace + \"-weblogic-domain-storage-class\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"2Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Recycle\")\n+            .hostPath(new V1HostPathVolumeSource().path(hostPath)))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvName)\n+            .build());\n+    TestActions.createPersistentVolume(v1pv);\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .volumeName(pvName)\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(namespace + \"-weblogic-domain-storage-class\")\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"2Gi\"))))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvcName)\n+            .withNamespace(namespace)\n+            .build());\n+    TestActions.createPersistentVolumeClaim(v1pvc);\n+\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pv to be bound, \"\n+                + \"(elapsed time {0} , remaining time {1}\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(isPersistentVolumeInState(pvName, \"Bound\"));\n+\n+    final String podName = \"pv-pod-\" + namespace;\n+    V1Pod podBody = new V1Pod()\n+        .spec(new V1PodSpec()\n+            .containers(Arrays.asList(\n+                new V1Container()\n+                    .name(\"pv-container\")\n+                    .image(\"nginx\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxMDg0Mw=="}, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 336}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDU2NTEzOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMDo1MjozMVrOGNsUyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNjo0MjoyOFrOGOxkTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxMDg5MQ==", "bodyText": "what?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r417010891", "createdAt": "2020-04-29T00:52:31Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "diffHunk": "@@ -137,4 +232,162 @@ private static void writeToFile(Object obj, String resultDir, String fileName) t\n     }\n   }\n \n-}\n+  /**\n+   * Copy files from persistent volume to local folder.\n+   * @param namespace name of the namespace\n+   * @param hostPath the persistent volume host path\n+   * @param destinationPath destination folder to copy the files to\n+   * @throws ApiException when pod interaction fails\n+   */\n+  private static void copyFromPV(String namespace, String hostPath, Path destinationPath) throws ApiException {\n+    V1Pod pvPod = null;\n+    try {\n+      // create a temporary pod to get access to the interested persistent volume\n+      pvPod = setupPVPod(namespace, hostPath);\n+      copyDirectoryFromPod(pvPod, hostPath, destinationPath);\n+    } finally {\n+      // remove the temporary pod\n+      if (pvPod != null) {\n+        cleanupPVPod(namespace);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Creates temporary pod with persistent volume claim and persistent volume using host path.\n+   *\n+   * @param namespace name of the namespace\n+   * @param hostPath host path from ineterested persistent volume\n+   * @return V1Pod pod object\n+   * @throws ApiException when create pod fails\n+   */\n+  private static V1Pod setupPVPod(String namespace, String hostPath) throws ApiException {\n+\n+    ConditionFactory withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(5, SECONDS)\n+        .atMost(1, MINUTES).await();\n+\n+    // create a pvc and pv to get access to the host path of the target pv\n+    final String pvcName = \"pv-pod-pvc-\" + namespace;\n+    final String pvName = \"pv-pod-pv-\" + namespace;\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(namespace + \"-weblogic-domain-storage-class\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"2Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Recycle\")\n+            .hostPath(new V1HostPathVolumeSource().path(hostPath)))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvName)\n+            .build());\n+    TestActions.createPersistentVolume(v1pv);\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .volumeName(pvName)\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(namespace + \"-weblogic-domain-storage-class\")\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"2Gi\"))))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvcName)\n+            .withNamespace(namespace)\n+            .build());\n+    TestActions.createPersistentVolumeClaim(v1pvc);\n+\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pv to be bound, \"\n+                + \"(elapsed time {0} , remaining time {1}\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(isPersistentVolumeInState(pvName, \"Bound\"));\n+\n+    final String podName = \"pv-pod-\" + namespace;\n+    V1Pod podBody = new V1Pod()\n+        .spec(new V1PodSpec()\n+            .containers(Arrays.asList(\n+                new V1Container()\n+                    .name(\"pv-container\")\n+                    .image(\"nginx\")\n+                    .imagePullPolicy(\"IfNotPresent\")\n+                    .volumeMounts(Arrays.asList(\n+                        new V1VolumeMount()\n+                            .name(pvName)\n+                            .mountPath(\"/shared\")))))\n+            .volumes(Arrays.asList(\n+                new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(\n+                        new V1PersistentVolumeClaimVolumeSource()\n+                            .claimName(pvcName)))))\n+        .metadata(new V1ObjectMeta().name(podName))\n+        .apiVersion(\"v1\")\n+        .kind(\"Pod\");\n+    V1Pod pvPod = Kubernetes.createPod(namespace, podBody);\n+\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for {0} to be ready in namespace {1}, \"\n+                + \"(elapsed time {2} , remaining time {3}\",\n+                podName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(podReady(podName, null, namespace));\n+    return pvPod;\n+  }\n+\n+  /**\n+   * Delete the temporary pv pod.\n+   * @param namespace name", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 367}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE0NTM1Nw==", "bodyText": "modified the description, the namespace is where the one-off pod running.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r418145357", "createdAt": "2020-04-30T16:42:28Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "diffHunk": "@@ -137,4 +232,162 @@ private static void writeToFile(Object obj, String resultDir, String fileName) t\n     }\n   }\n \n-}\n+  /**\n+   * Copy files from persistent volume to local folder.\n+   * @param namespace name of the namespace\n+   * @param hostPath the persistent volume host path\n+   * @param destinationPath destination folder to copy the files to\n+   * @throws ApiException when pod interaction fails\n+   */\n+  private static void copyFromPV(String namespace, String hostPath, Path destinationPath) throws ApiException {\n+    V1Pod pvPod = null;\n+    try {\n+      // create a temporary pod to get access to the interested persistent volume\n+      pvPod = setupPVPod(namespace, hostPath);\n+      copyDirectoryFromPod(pvPod, hostPath, destinationPath);\n+    } finally {\n+      // remove the temporary pod\n+      if (pvPod != null) {\n+        cleanupPVPod(namespace);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Creates temporary pod with persistent volume claim and persistent volume using host path.\n+   *\n+   * @param namespace name of the namespace\n+   * @param hostPath host path from ineterested persistent volume\n+   * @return V1Pod pod object\n+   * @throws ApiException when create pod fails\n+   */\n+  private static V1Pod setupPVPod(String namespace, String hostPath) throws ApiException {\n+\n+    ConditionFactory withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(5, SECONDS)\n+        .atMost(1, MINUTES).await();\n+\n+    // create a pvc and pv to get access to the host path of the target pv\n+    final String pvcName = \"pv-pod-pvc-\" + namespace;\n+    final String pvName = \"pv-pod-pv-\" + namespace;\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(namespace + \"-weblogic-domain-storage-class\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"2Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Recycle\")\n+            .hostPath(new V1HostPathVolumeSource().path(hostPath)))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvName)\n+            .build());\n+    TestActions.createPersistentVolume(v1pv);\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .volumeName(pvName)\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(namespace + \"-weblogic-domain-storage-class\")\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"2Gi\"))))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvcName)\n+            .withNamespace(namespace)\n+            .build());\n+    TestActions.createPersistentVolumeClaim(v1pvc);\n+\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pv to be bound, \"\n+                + \"(elapsed time {0} , remaining time {1}\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(isPersistentVolumeInState(pvName, \"Bound\"));\n+\n+    final String podName = \"pv-pod-\" + namespace;\n+    V1Pod podBody = new V1Pod()\n+        .spec(new V1PodSpec()\n+            .containers(Arrays.asList(\n+                new V1Container()\n+                    .name(\"pv-container\")\n+                    .image(\"nginx\")\n+                    .imagePullPolicy(\"IfNotPresent\")\n+                    .volumeMounts(Arrays.asList(\n+                        new V1VolumeMount()\n+                            .name(pvName)\n+                            .mountPath(\"/shared\")))))\n+            .volumes(Arrays.asList(\n+                new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(\n+                        new V1PersistentVolumeClaimVolumeSource()\n+                            .claimName(pvcName)))))\n+        .metadata(new V1ObjectMeta().name(podName))\n+        .apiVersion(\"v1\")\n+        .kind(\"Pod\");\n+    V1Pod pvPod = Kubernetes.createPod(namespace, podBody);\n+\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for {0} to be ready in namespace {1}, \"\n+                + \"(elapsed time {2} , remaining time {3}\",\n+                podName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(podReady(podName, null, namespace));\n+    return pvPod;\n+  }\n+\n+  /**\n+   * Delete the temporary pv pod.\n+   * @param namespace name", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxMDg5MQ=="}, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 367}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDU2NTY0OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMDo1Mjo0NlrOGNsVFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNjo0MjozNlrOGOxklA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxMDk2Ng==", "bodyText": "fix wording", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r417010966", "createdAt": "2020-04-29T00:52:46Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "diffHunk": "@@ -137,4 +232,162 @@ private static void writeToFile(Object obj, String resultDir, String fileName) t\n     }\n   }\n \n-}\n+  /**\n+   * Copy files from persistent volume to local folder.\n+   * @param namespace name of the namespace\n+   * @param hostPath the persistent volume host path\n+   * @param destinationPath destination folder to copy the files to\n+   * @throws ApiException when pod interaction fails\n+   */\n+  private static void copyFromPV(String namespace, String hostPath, Path destinationPath) throws ApiException {\n+    V1Pod pvPod = null;\n+    try {\n+      // create a temporary pod to get access to the interested persistent volume\n+      pvPod = setupPVPod(namespace, hostPath);\n+      copyDirectoryFromPod(pvPod, hostPath, destinationPath);\n+    } finally {\n+      // remove the temporary pod\n+      if (pvPod != null) {\n+        cleanupPVPod(namespace);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Creates temporary pod with persistent volume claim and persistent volume using host path.\n+   *\n+   * @param namespace name of the namespace\n+   * @param hostPath host path from ineterested persistent volume\n+   * @return V1Pod pod object\n+   * @throws ApiException when create pod fails\n+   */\n+  private static V1Pod setupPVPod(String namespace, String hostPath) throws ApiException {\n+\n+    ConditionFactory withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(5, SECONDS)\n+        .atMost(1, MINUTES).await();\n+\n+    // create a pvc and pv to get access to the host path of the target pv\n+    final String pvcName = \"pv-pod-pvc-\" + namespace;\n+    final String pvName = \"pv-pod-pv-\" + namespace;\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(namespace + \"-weblogic-domain-storage-class\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"2Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Recycle\")\n+            .hostPath(new V1HostPathVolumeSource().path(hostPath)))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvName)\n+            .build());\n+    TestActions.createPersistentVolume(v1pv);\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .volumeName(pvName)\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(namespace + \"-weblogic-domain-storage-class\")\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"2Gi\"))))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvcName)\n+            .withNamespace(namespace)\n+            .build());\n+    TestActions.createPersistentVolumeClaim(v1pvc);\n+\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pv to be bound, \"\n+                + \"(elapsed time {0} , remaining time {1}\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(isPersistentVolumeInState(pvName, \"Bound\"));\n+\n+    final String podName = \"pv-pod-\" + namespace;\n+    V1Pod podBody = new V1Pod()\n+        .spec(new V1PodSpec()\n+            .containers(Arrays.asList(\n+                new V1Container()\n+                    .name(\"pv-container\")\n+                    .image(\"nginx\")\n+                    .imagePullPolicy(\"IfNotPresent\")\n+                    .volumeMounts(Arrays.asList(\n+                        new V1VolumeMount()\n+                            .name(pvName)\n+                            .mountPath(\"/shared\")))))\n+            .volumes(Arrays.asList(\n+                new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(\n+                        new V1PersistentVolumeClaimVolumeSource()\n+                            .claimName(pvcName)))))\n+        .metadata(new V1ObjectMeta().name(podName))\n+        .apiVersion(\"v1\")\n+        .kind(\"Pod\");\n+    V1Pod pvPod = Kubernetes.createPod(namespace, podBody);\n+\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for {0} to be ready in namespace {1}, \"\n+                + \"(elapsed time {2} , remaining time {3}\",\n+                podName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(podReady(podName, null, namespace));\n+    return pvPod;\n+  }\n+\n+  /**\n+   * Delete the temporary pv pod.\n+   * @param namespace name\n+   * @throws ApiException when pod deletion fails\n+   */\n+  private static void cleanupPVPod(String namespace) throws ApiException {\n+    Kubernetes.deletePod(\"pv-pod-\" + namespace, namespace);\n+    Kubernetes.deletePvc(\"pv-pod-pvc-\" + namespace, namespace);\n+    Kubernetes.deletePv(\"pv-pod-pv-\" + namespace);\n+  }\n+\n+  // there is currently a bug in the copy API which leaves i/o stream left open", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 376}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE0NTQyOA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1609#discussion_r418145428", "createdAt": "2020-04-30T16:42:36Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/LoggingUtil.java", "diffHunk": "@@ -137,4 +232,162 @@ private static void writeToFile(Object obj, String resultDir, String fileName) t\n     }\n   }\n \n-}\n+  /**\n+   * Copy files from persistent volume to local folder.\n+   * @param namespace name of the namespace\n+   * @param hostPath the persistent volume host path\n+   * @param destinationPath destination folder to copy the files to\n+   * @throws ApiException when pod interaction fails\n+   */\n+  private static void copyFromPV(String namespace, String hostPath, Path destinationPath) throws ApiException {\n+    V1Pod pvPod = null;\n+    try {\n+      // create a temporary pod to get access to the interested persistent volume\n+      pvPod = setupPVPod(namespace, hostPath);\n+      copyDirectoryFromPod(pvPod, hostPath, destinationPath);\n+    } finally {\n+      // remove the temporary pod\n+      if (pvPod != null) {\n+        cleanupPVPod(namespace);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Creates temporary pod with persistent volume claim and persistent volume using host path.\n+   *\n+   * @param namespace name of the namespace\n+   * @param hostPath host path from ineterested persistent volume\n+   * @return V1Pod pod object\n+   * @throws ApiException when create pod fails\n+   */\n+  private static V1Pod setupPVPod(String namespace, String hostPath) throws ApiException {\n+\n+    ConditionFactory withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(5, SECONDS)\n+        .atMost(1, MINUTES).await();\n+\n+    // create a pvc and pv to get access to the host path of the target pv\n+    final String pvcName = \"pv-pod-pvc-\" + namespace;\n+    final String pvName = \"pv-pod-pv-\" + namespace;\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(namespace + \"-weblogic-domain-storage-class\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"2Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Recycle\")\n+            .hostPath(new V1HostPathVolumeSource().path(hostPath)))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvName)\n+            .build());\n+    TestActions.createPersistentVolume(v1pv);\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .volumeName(pvName)\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(namespace + \"-weblogic-domain-storage-class\")\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"2Gi\"))))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvcName)\n+            .withNamespace(namespace)\n+            .build());\n+    TestActions.createPersistentVolumeClaim(v1pvc);\n+\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pv to be bound, \"\n+                + \"(elapsed time {0} , remaining time {1}\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(isPersistentVolumeInState(pvName, \"Bound\"));\n+\n+    final String podName = \"pv-pod-\" + namespace;\n+    V1Pod podBody = new V1Pod()\n+        .spec(new V1PodSpec()\n+            .containers(Arrays.asList(\n+                new V1Container()\n+                    .name(\"pv-container\")\n+                    .image(\"nginx\")\n+                    .imagePullPolicy(\"IfNotPresent\")\n+                    .volumeMounts(Arrays.asList(\n+                        new V1VolumeMount()\n+                            .name(pvName)\n+                            .mountPath(\"/shared\")))))\n+            .volumes(Arrays.asList(\n+                new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(\n+                        new V1PersistentVolumeClaimVolumeSource()\n+                            .claimName(pvcName)))))\n+        .metadata(new V1ObjectMeta().name(podName))\n+        .apiVersion(\"v1\")\n+        .kind(\"Pod\");\n+    V1Pod pvPod = Kubernetes.createPod(namespace, podBody);\n+\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for {0} to be ready in namespace {1}, \"\n+                + \"(elapsed time {2} , remaining time {3}\",\n+                podName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(podReady(podName, null, namespace));\n+    return pvPod;\n+  }\n+\n+  /**\n+   * Delete the temporary pv pod.\n+   * @param namespace name\n+   * @throws ApiException when pod deletion fails\n+   */\n+  private static void cleanupPVPod(String namespace) throws ApiException {\n+    Kubernetes.deletePod(\"pv-pod-\" + namespace, namespace);\n+    Kubernetes.deletePvc(\"pv-pod-pvc-\" + namespace, namespace);\n+    Kubernetes.deletePv(\"pv-pod-pv-\" + namespace);\n+  }\n+\n+  // there is currently a bug in the copy API which leaves i/o stream left open", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxMDk2Ng=="}, "originalCommit": {"oid": "5811d1c715bee09827f987c5458bad1c640004fd"}, "originalPosition": 376}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4495, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}