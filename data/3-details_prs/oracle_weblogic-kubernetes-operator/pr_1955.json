{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk0MjY2Njc5", "number": 1955, "title": "OWLS-84562 - added tests for Namespace management enhancements", "bodyText": "Jenkins : https://build.weblogick8s.org:8443/job/weblogic-kubernetes-operator-kind-new/2210/\nAdded tests to cover [https://jira.****/jira/browse/OWLS-82046]  (#1860)\nthe tests don't cover Dedicated method, it is covered by other testclass\nTestcases:\n\n\nCreate operator managing domain namespaces by SelectLabels\na. create namespace with specified label, make sure domain is started and operator can scale it\nb. verify that domain with namespace with different label is not started/managed by operator, verify that as soon as namespace will be assigned the label, managed by operator, domain will be started and managed by operator.\nc. verify that SelectLabel override domainNamespaces option from values and domain is not started even domainNamespace option is specified.\nd. verify that domain in default namespace is not started\ne. verify that operator can add/remove namespaces by upgrading helm chart and switch to different select method (RegExp)\nf. verify that another operator (using List for domainNamespaces selection ) failed to share same namespace\n\n\nCreate operator managing domain namespaces by Expression searching for namespaces name starting with xoxoxo\na. create two namespace with namespaces staring with xoxoxo, make sure domains are started and operator can scale it\nb. verify that domain with namespace with different name is not started/managed by operator\nc. verify that RegExp override domainNamespaces option from values and domain is not started even domainNamespace option is specified.\nd. verify that domain in default namespace is not started\ne. verify that operator can add/remove namespaces by upgrading helm chart and switch to different select method (SelectLabels)\nf. verify that another operator (using List for domainNamespaces selection ) failed to share same namespace\n\n\nCreate namespace before operator with setting enableRoleClusterBinding=false, and SelectLabel using that namespace, verify that domain can't be started , upgrade operator with reuse values, verify domain is started after upgrade.", "createdAt": "2020-09-28T16:32:55Z", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955", "merged": true, "mergeCommit": {"oid": "5dded553374b7aff15ad21b1063663b7a050a576"}, "closed": true, "closedAt": "2020-10-08T16:23:57Z", "author": {"login": "marinakog"}, "timelineItems": {"totalCount": 41, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdLZTD_gH2gAyNDk0MjY2Njc5OjE0MGQyYjk2YjAyZTczNzYyN2NiNGI2OTQwYzI0ZWYyYjhmMWJjNWQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdQj-UPAFqTUwNDk0ODg2Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "140d2b96b02e737627cb4b6940c24ef2b8f1bc5d", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/140d2b96b02e737627cb4b6940c24ef2b8f1bc5d", "committedDate": "2020-09-22T14:58:51Z", "message": "added tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a641085a7dbb7d33f586ffe41409219ea574ef79", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a641085a7dbb7d33f586ffe41409219ea574ef79", "committedDate": "2020-09-22T14:59:30Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into managens"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "106db1547aa2087e8aa0edd31f4723c7e85bf06d", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/106db1547aa2087e8aa0edd31f4723c7e85bf06d", "committedDate": "2020-09-22T15:09:06Z", "message": "updated test loc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ce5b1e907d00dd7f2c6fa4ee1677377a4eb074b", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/6ce5b1e907d00dd7f2c6fa4ee1677377a4eb074b", "committedDate": "2020-09-22T17:17:19Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into managens"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c75e53f1e83d6df31a8a411a9b0e8de496d0f41e", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c75e53f1e83d6df31a8a411a9b0e8de496d0f41e", "committedDate": "2020-09-22T18:50:26Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into managens"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a64a661ab14b9af43b7ecfd6444c7f385af2a19", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/4a64a661ab14b9af43b7ecfd6444c7f385af2a19", "committedDate": "2020-09-24T16:55:31Z", "message": "more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b30234afdddf271de6f56ba7113843e8d1d8033", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/2b30234afdddf271de6f56ba7113843e8d1d8033", "committedDate": "2020-09-24T16:55:44Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into managens"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5811c9115a07f804b693238e025fd8dda364f5f", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c5811c9115a07f804b693238e025fd8dda364f5f", "committedDate": "2020-09-24T18:00:47Z", "message": "fixed default secrests management"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9eeec3cd88f8d970e5a4f593d67ab5994f77be1f", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9eeec3cd88f8d970e5a4f593d67ab5994f77be1f", "committedDate": "2020-09-24T18:08:49Z", "message": "fixed test logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e72063524c0ed00c324f809d0938460420d7f566", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e72063524c0ed00c324f809d0938460420d7f566", "committedDate": "2020-09-25T21:11:37Z", "message": " corrected java docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5471cd4b007ab6ad1d18fb9fb588b4e4149ee54c", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5471cd4b007ab6ad1d18fb9fb588b4e4149ee54c", "committedDate": "2020-09-26T15:23:57Z", "message": "fixed domainns"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f87ed1c756d7ab13857594d319d50f223ea6dbd1", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f87ed1c756d7ab13857594d319d50f223ea6dbd1", "committedDate": "2020-09-26T17:46:20Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into managens"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae34821a7a98dcecbb7718e1d7ebd9a149786230", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/ae34821a7a98dcecbb7718e1d7ebd9a149786230", "committedDate": "2020-09-27T15:43:41Z", "message": "fixed secret creation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "141fec060b1432c2f9b141aae1dad39e515dd823", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/141fec060b1432c2f9b141aae1dad39e515dd823", "committedDate": "2020-09-28T16:00:45Z", "message": "fixed secret dependencies"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6de215c5dd50e54cb61c58f26a69926d832be98", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e6de215c5dd50e54cb61c58f26a69926d832be98", "committedDate": "2020-09-28T16:01:21Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into managens"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "504769d961f4eade6c06e75d4d102a7b763191cc", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/504769d961f4eade6c06e75d4d102a7b763191cc", "committedDate": "2020-09-28T17:03:19Z", "message": "fixed default domain crd dependencies"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4371dc02289a36bb4018e0861ce6dc7e0d03d0f9", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/4371dc02289a36bb4018e0861ce6dc7e0d03d0f9", "committedDate": "2020-09-30T19:14:45Z", "message": "fixed check pod creation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03995b8e37d3efd21554a1ef40278c78f35d6059", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/03995b8e37d3efd21554a1ef40278c78f35d6059", "committedDate": "2020-09-30T19:23:06Z", "message": "style"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65739531a71c1d18e48d8bbd88520f896dc8f99c", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/65739531a71c1d18e48d8bbd88520f896dc8f99c", "committedDate": "2020-09-30T23:12:47Z", "message": "added rbac test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1bd13437830539e3356da4f154e9bfa2ea319ed", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b1bd13437830539e3356da4f154e9bfa2ea319ed", "committedDate": "2020-09-30T23:47:05Z", "message": "added rbac test, corrected ns label"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce3511363ac30d7d102bc5efb65a2012d81da2bc", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/ce3511363ac30d7d102bc5efb65a2012d81da2bc", "committedDate": "2020-09-30T23:47:19Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into managens"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/2f7e78cece4496d7be6e42ec72deec2f2648b5d3", "committedDate": "2020-10-01T22:58:52Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into managens"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMzMyODEy", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#pullrequestreview-501332812", "createdAt": "2020-10-02T17:50:29Z", "commit": {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNzo1MDoyOVrOHb2ZFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxODowNjo0NlrOHb222Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2NDc1Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static String opNamespace = null;\n          \n          \n            \n              private static String op1Namespace = null;", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498964757", "createdAt": "2020-10-02T17:50:29Z", "author": {"login": "sankarpn"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2NTE5MA==", "bodyText": "can you use an array instead of defining so many variables of same type?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498965190", "createdAt": "2020-10-02T17:51:30Z", "author": {"login": "sankarpn"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2NTYyNQ==", "bodyText": "please use an array and loop to assign ns", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498965625", "createdAt": "2020-10-02T17:52:29Z", "author": {"login": "sankarpn"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2NTkyMQ==", "bodyText": "isn't this already available in the registry?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498965921", "createdAt": "2020-10-02T17:53:07Z", "author": {"login": "sankarpn"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2NjQ5MA==", "bodyText": "use arrays and loops", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498966490", "createdAt": "2020-10-02T17:54:13Z", "author": {"login": "sankarpn"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2NjczNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Deploy two custom domain resources in the two different namespaces with names starting with test\n          \n          \n            \n               * Deploy two custom domain resources in two different namespaces with names starting with test", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498966737", "createdAt": "2020-10-02T17:54:46Z", "author": {"login": "sankarpn"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2ODI0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                createSecretWithUsernamePassword(adminSecretName, domainNamespace, \"weblogic\", \"welcome1\");\n          \n          \n            \n                createSecretWithUsernamePassword(adminSecretName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498968244", "createdAt": "2020-10-02T17:58:01Z", "author": {"login": "sankarpn"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace domain3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domain1Namespace;\n+    String manageByExp2NS = \"test-\" +  domain2Namespace;\n+    String manageByExpDomain1Uid = \"test-\" + domain1Uid;\n+    String manageByExpDomain2Uid = \"test-\" + domain2Uid;\n+    String manageByLabelNS = \"weblogic1\" + domain1Namespace;\n+    String manageByLabelDomainUid = \"weblogic1\" + domain1Uid;\n+    String domain3NS = \"atest-\" +  domain1Namespace;\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(domain3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3Namespace);\n+    checkDomainNotStartedInDefaultNS(\"RegExp\");\n+    //verify that operator can't start domain if namespace does not start from test\n+    createSecrets(domain3NS);\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domain1Namespace;\n+    String manageByLabelDomain2NS = domain2Namespace;\n+    String manageByExpDomainUid = \"weblogic2\" + domain2Namespace;\n+    String manageByExpDomainNS = \"weblogic2\" + domain2Namespace;\n+    String manageByLabelDomain1Uid = domain1Uid;\n+    String manageByLabelDomain2Uid = domain2Uid;\n+    installAndVerifyOperatorCanManageDomainByLabelSelector(manageByLabelDomain1NS, manageByLabelDomain2NS,\n+        manageByLabelDomain1Uid, manageByLabelDomain2Uid);\n+    addExtraDomainByAddingLabelToNS(labels1, manageByLabelDomain2NS, manageByLabelDomain2Uid);\n+    checkDomainNotStartedInDefaultNS(\"SelectLabel\");\n+    checkSecondOperatorFailedToShareSameNS(manageByLabelDomain1NS);\n+    switchNSManagementToRegExpUsingUpgradeOperator(manageByLabelDomain1NS, manageByExpDomainNS,\n+        manageByLabelDomain1Uid, manageByExpDomainUid);\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domain1Namespace + \"test4\";\n+    String manageByLabelDomainUid = domain1Uid + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams4 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op4Namespace, \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(op4Namespace, \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams4);\n+\n+    assertTrue(upgradeAndVerifyOperator(op4Namespace, opParams));\n+    assertTrue(startDomain(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op4Namespace, manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespace, opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void switchNSManagementToRegExpUsingUpgradeOperator(String manageByLabelNS,\n+                                                              String manageByExpNS,\n+                                                              String manageByLabelDomainUid,\n+                                                              String manageByExpDomainUid) {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpNS);\n+    assertTrue(startDomain(manageByExpNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespace,manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespace, manageByLabelDomainUid, manageByLabelNS),\n+        \"Operator can still manage domain \"\n+        + manageByLabelDomainUid + \" in the namespace \" + manageByLabelNS);\n+  }\n+\n+  private void addExtraDomainByAddingLabelToNS(Map<String, String> labels, String domainNS, String domainUid) {\n+    deleteDomainCrd(domainNS, domainUid);\n+\n+    //switch to the label1, managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNS, labels);\n+    assertTrue(startDomain(domainNS, domainUid));\n+    checkOperatorCanScaleDomain(opNamespace, domainUid);\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {\n+    //clean up domain resources in namespace and set namespace to label , managed by operator\n+    logger.info(\"deleting domain custom resource {0}\", domainUid);\n+    assertTrue(deleteDomainCustomResource(domainUid, domainNS));\n+\n+    // wait until domain was deleted\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNS,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainDoesNotExist(domainUid, DOMAIN_VERSION, domainNS));\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByLabelSelector(String manageByLabelDomain1NS,\n+                                                                      String manageByLabelDomain2NS,\n+                                                                      String manageByLabelDomain1Uid,\n+                                                                      String manageByLabelDomain2Uid) {\n+    // install and verify operator set to manage domains based on LabelSelector strategy,\n+    // domainNamespaces set to domain4 will be ignored\n+    opHelmParams1 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        opNamespace, \"LabelSelector\",\n+        OPERATOR_RELEASE_NAME, true, manageByLabelDomain1NS);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByLabelDomain1NS);\n+    assertTrue(startDomain(manageByLabelDomain1NS, manageByLabelDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByLabelDomain1NS);\n+\n+    checkOperatorCanScaleDomain(opNamespace, manageByLabelDomain1Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain4 will not start\n+    createSecrets(domain4Namespace);\n+    checkPodNotCreated(domain4Uid + adminServerPrefix, domain4Uid, domain4Namespace);\n+\n+    //verify that domain2 in namespace with no label2 will not start\n+    createSecrets(manageByLabelDomain2NS);\n+    checkPodNotCreated(manageByLabelDomain2Uid + adminServerPrefix, manageByLabelDomain2Uid, manageByLabelDomain2NS);\n+  }\n+\n+  private boolean isOperatorFailedToScaleDomain(String opNamespace, String domainUid, String domainNamespace) {\n+    try {\n+      //check operator can't manage domainNamespace by trying to scale domain\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      String managedServerPodNamePrefix = domainUid + \"-managed-server\";\n+      String opServiceAccount = OPERATOR_RELEASE_NAME + \"-sa\";\n+      scaleAndVerifyCluster(\"cluster-1\", domainUid, domainNamespace,\n+          managedServerPodNamePrefix, 2, 1,\n+          true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+          false, \"\", \"scaleDown\", 1, \"\", \"\", null, null);\n+      return false;\n+\n+    } catch (ConditionTimeoutException ex) {\n+      logger.info(\"Received expected error \" + ex.getMessage());\n+      return true;\n+    }\n+  }\n+\n+  private static void setLabelToNamespace(String domainNS, Map<String, String> labels) {\n+    //add label to domain namespace\n+    V1Namespace namespaceObject1 = assertDoesNotThrow(() -> Kubernetes.getNamespaceAsObject(domainNS));\n+    assertNotNull(namespaceObject1, \"Can't find namespace with name \" + domainNS);\n+    namespaceObject1.getMetadata().setLabels(labels);\n+    assertDoesNotThrow(() -> Kubernetes.replaceNamespace(namespaceObject1));\n+  }\n+\n+  private void checkOperatorCanScaleDomain(String opNamespace, String domainUid) {\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    assertTrue(scaleClusterWithRestApi(domainUid, clusterName, 3,\n+        externalRestHttpsPort, opNamespace, OPERATOR_RELEASE_NAME + \"-sa\"),\n+        \"Domain \" + domainUid + \" scaling operation failed\");\n+  }\n+\n+  private void checkSecondOperatorFailedToShareSameNS(String domainNamespace) {\n+    // try to install another operator sharing same domain namespace via different domainNsSelectionStrategy\n+    try {\n+      HelmParams opHelmParams3 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+          op3Namespace, \"List\",\n+          null, true, domainNamespace);\n+      assertNull(opHelmParams3, \"Operator helm chart sharing same NS with other operator did not fail\");\n+    } catch (org.opentest4j.AssertionFailedError ex) {\n+      //expecting to fail\n+      logger.info(\"Helm installation failed as expected \" + ex.getMessage());\n+    }\n+  }\n+\n+  private void checkDomainNotStartedInDefaultNS(String domainNsSelectionStrategy) {\n+    //verify operator can't start domain in the default namespace when domainNsSelectionStrategy not List\n+    // and selector does not match default\n+    checkPodNotCreated(\"defaultuid\" + adminServerPrefix, \"defaultuid\", \"default\");\n+\n+    logger.info(\"Delete defaultuid custom resource in namespace {0}\", \"default\");\n+    deleteDomainCustomResource(\"defaultuid\", \"default\");\n+    logger.info(\"Deleted Domain Custom Resource \" + \"defaultuid\");\n+  }\n+\n+  private void switchNSManagementToLabelSelectUsingUpgradeOperator(String manageByLabelNS,\n+                                                                   String manageByExpNS,\n+                                                                   String manageByLabelDomainUid,\n+                                                                   String manageByExpDomainUid) {\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(op2Namespace, \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams2)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(op2Namespace, opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(startDomain(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op2Namespace,manageByLabelDomainUid);\n+    //check operator can't manage anymore manageByExpNS\n+    assertTrue(isOperatorFailedToScaleDomain(op2Namespace, manageByExpDomainUid,\n+        manageByExpNS), \"Operator can still manage domain \"\n+        + manageByExpNS + \" in the namespace \" + manageByExpNS);\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByNSRegExp(String manageByExp1NS,\n+                                                                 String manageByExp2NS,\n+                                                                 String manageByExpDomain1Uid,\n+                                                                 String manageByExpDomain2Uid) {\n+    // install and verify operator with domainNsSelectStrategy=RegExp to manage domains with namespaces names,\n+    // starting from test\n+    opHelmParams2 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op2Namespace, \"RegExp\", \"^test\", true, domain3Namespace);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByExp1NS);\n+    assertTrue(startDomain(manageByExp1NS, manageByExpDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByExp1NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain1Uid);\n+\n+    logger.info(\"Installing and verifying domain2\");\n+    createSecrets(manageByExp2NS);\n+    assertTrue(startDomain(manageByExp2NS, manageByExpDomain2Uid),\n+        \"operator can start or verify domain in namespace \" + manageByExp2NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain2Uid);\n+  }\n+\n+\n+  private boolean startDomain(String domainNamespace, String domainUid) {\n+\n+    // create and verify the domain\n+    logger.info(\"Creating and verifying model in image domain\");\n+    try {\n+      Domain domain = createDomainCRD(domainNamespace, domainUid);\n+      createVerifyDomain(domainNamespace, domainUid, miiImage, domain);\n+      return true;\n+    } catch (Exception ex) {\n+      logger.info(\"Failed to createVerifyDomain \" + ex.getMessage());\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Create a model in image domain crd.\n+   */\n+  private Domain createDomainCRD(String domainNamespace, String domainUid) {\n+\n+    // construct a list of oracle.weblogic.domain.Cluster objects to be used in the domain custom resource\n+    List<Cluster> clusters = new ArrayList<>();\n+    clusters.add(new Cluster()\n+        .clusterName(clusterName)\n+        .replicas(replicaCount)\n+        .serverStartState(\"RUNNING\"));\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new oracle.weblogic.domain.AdminService()\n+                    .addChannelsItem(new oracle.weblogic.domain.Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))))\n+            .clusters(clusters)\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(WLS_DOMAIN_TYPE)\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+    return domain;\n+  }\n+\n+  private static void createSecrets(String domainNamespace) {\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Creating docker registry secret in namespace {0}\", domainNamespace);\n+    if (!domainNamespace.equals(\"default\")) {\n+      createDockerRegistrySecret(domainNamespace);\n+    }\n+\n+    // create secret for admin credentials\n+    logger.info(\"Creating secret for admin credentials\");\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \"weblogic\", \"welcome1\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3"}, "originalPosition": 639}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2ODg1OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Install WebLogic operator and wait up to two minutes until the operator pod is ready.\n          \n          \n            \n               * Install WebLogic operator and wait up to two minutes for the operator pod to be ready.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498968859", "createdAt": "2020-10-02T17:59:15Z", "author": {"login": "sankarpn"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace domain3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domain1Namespace;\n+    String manageByExp2NS = \"test-\" +  domain2Namespace;\n+    String manageByExpDomain1Uid = \"test-\" + domain1Uid;\n+    String manageByExpDomain2Uid = \"test-\" + domain2Uid;\n+    String manageByLabelNS = \"weblogic1\" + domain1Namespace;\n+    String manageByLabelDomainUid = \"weblogic1\" + domain1Uid;\n+    String domain3NS = \"atest-\" +  domain1Namespace;\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(domain3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3Namespace);\n+    checkDomainNotStartedInDefaultNS(\"RegExp\");\n+    //verify that operator can't start domain if namespace does not start from test\n+    createSecrets(domain3NS);\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domain1Namespace;\n+    String manageByLabelDomain2NS = domain2Namespace;\n+    String manageByExpDomainUid = \"weblogic2\" + domain2Namespace;\n+    String manageByExpDomainNS = \"weblogic2\" + domain2Namespace;\n+    String manageByLabelDomain1Uid = domain1Uid;\n+    String manageByLabelDomain2Uid = domain2Uid;\n+    installAndVerifyOperatorCanManageDomainByLabelSelector(manageByLabelDomain1NS, manageByLabelDomain2NS,\n+        manageByLabelDomain1Uid, manageByLabelDomain2Uid);\n+    addExtraDomainByAddingLabelToNS(labels1, manageByLabelDomain2NS, manageByLabelDomain2Uid);\n+    checkDomainNotStartedInDefaultNS(\"SelectLabel\");\n+    checkSecondOperatorFailedToShareSameNS(manageByLabelDomain1NS);\n+    switchNSManagementToRegExpUsingUpgradeOperator(manageByLabelDomain1NS, manageByExpDomainNS,\n+        manageByLabelDomain1Uid, manageByExpDomainUid);\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domain1Namespace + \"test4\";\n+    String manageByLabelDomainUid = domain1Uid + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams4 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op4Namespace, \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(op4Namespace, \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams4);\n+\n+    assertTrue(upgradeAndVerifyOperator(op4Namespace, opParams));\n+    assertTrue(startDomain(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op4Namespace, manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespace, opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void switchNSManagementToRegExpUsingUpgradeOperator(String manageByLabelNS,\n+                                                              String manageByExpNS,\n+                                                              String manageByLabelDomainUid,\n+                                                              String manageByExpDomainUid) {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpNS);\n+    assertTrue(startDomain(manageByExpNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespace,manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespace, manageByLabelDomainUid, manageByLabelNS),\n+        \"Operator can still manage domain \"\n+        + manageByLabelDomainUid + \" in the namespace \" + manageByLabelNS);\n+  }\n+\n+  private void addExtraDomainByAddingLabelToNS(Map<String, String> labels, String domainNS, String domainUid) {\n+    deleteDomainCrd(domainNS, domainUid);\n+\n+    //switch to the label1, managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNS, labels);\n+    assertTrue(startDomain(domainNS, domainUid));\n+    checkOperatorCanScaleDomain(opNamespace, domainUid);\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {\n+    //clean up domain resources in namespace and set namespace to label , managed by operator\n+    logger.info(\"deleting domain custom resource {0}\", domainUid);\n+    assertTrue(deleteDomainCustomResource(domainUid, domainNS));\n+\n+    // wait until domain was deleted\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNS,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainDoesNotExist(domainUid, DOMAIN_VERSION, domainNS));\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByLabelSelector(String manageByLabelDomain1NS,\n+                                                                      String manageByLabelDomain2NS,\n+                                                                      String manageByLabelDomain1Uid,\n+                                                                      String manageByLabelDomain2Uid) {\n+    // install and verify operator set to manage domains based on LabelSelector strategy,\n+    // domainNamespaces set to domain4 will be ignored\n+    opHelmParams1 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        opNamespace, \"LabelSelector\",\n+        OPERATOR_RELEASE_NAME, true, manageByLabelDomain1NS);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByLabelDomain1NS);\n+    assertTrue(startDomain(manageByLabelDomain1NS, manageByLabelDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByLabelDomain1NS);\n+\n+    checkOperatorCanScaleDomain(opNamespace, manageByLabelDomain1Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain4 will not start\n+    createSecrets(domain4Namespace);\n+    checkPodNotCreated(domain4Uid + adminServerPrefix, domain4Uid, domain4Namespace);\n+\n+    //verify that domain2 in namespace with no label2 will not start\n+    createSecrets(manageByLabelDomain2NS);\n+    checkPodNotCreated(manageByLabelDomain2Uid + adminServerPrefix, manageByLabelDomain2Uid, manageByLabelDomain2NS);\n+  }\n+\n+  private boolean isOperatorFailedToScaleDomain(String opNamespace, String domainUid, String domainNamespace) {\n+    try {\n+      //check operator can't manage domainNamespace by trying to scale domain\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      String managedServerPodNamePrefix = domainUid + \"-managed-server\";\n+      String opServiceAccount = OPERATOR_RELEASE_NAME + \"-sa\";\n+      scaleAndVerifyCluster(\"cluster-1\", domainUid, domainNamespace,\n+          managedServerPodNamePrefix, 2, 1,\n+          true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+          false, \"\", \"scaleDown\", 1, \"\", \"\", null, null);\n+      return false;\n+\n+    } catch (ConditionTimeoutException ex) {\n+      logger.info(\"Received expected error \" + ex.getMessage());\n+      return true;\n+    }\n+  }\n+\n+  private static void setLabelToNamespace(String domainNS, Map<String, String> labels) {\n+    //add label to domain namespace\n+    V1Namespace namespaceObject1 = assertDoesNotThrow(() -> Kubernetes.getNamespaceAsObject(domainNS));\n+    assertNotNull(namespaceObject1, \"Can't find namespace with name \" + domainNS);\n+    namespaceObject1.getMetadata().setLabels(labels);\n+    assertDoesNotThrow(() -> Kubernetes.replaceNamespace(namespaceObject1));\n+  }\n+\n+  private void checkOperatorCanScaleDomain(String opNamespace, String domainUid) {\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    assertTrue(scaleClusterWithRestApi(domainUid, clusterName, 3,\n+        externalRestHttpsPort, opNamespace, OPERATOR_RELEASE_NAME + \"-sa\"),\n+        \"Domain \" + domainUid + \" scaling operation failed\");\n+  }\n+\n+  private void checkSecondOperatorFailedToShareSameNS(String domainNamespace) {\n+    // try to install another operator sharing same domain namespace via different domainNsSelectionStrategy\n+    try {\n+      HelmParams opHelmParams3 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+          op3Namespace, \"List\",\n+          null, true, domainNamespace);\n+      assertNull(opHelmParams3, \"Operator helm chart sharing same NS with other operator did not fail\");\n+    } catch (org.opentest4j.AssertionFailedError ex) {\n+      //expecting to fail\n+      logger.info(\"Helm installation failed as expected \" + ex.getMessage());\n+    }\n+  }\n+\n+  private void checkDomainNotStartedInDefaultNS(String domainNsSelectionStrategy) {\n+    //verify operator can't start domain in the default namespace when domainNsSelectionStrategy not List\n+    // and selector does not match default\n+    checkPodNotCreated(\"defaultuid\" + adminServerPrefix, \"defaultuid\", \"default\");\n+\n+    logger.info(\"Delete defaultuid custom resource in namespace {0}\", \"default\");\n+    deleteDomainCustomResource(\"defaultuid\", \"default\");\n+    logger.info(\"Deleted Domain Custom Resource \" + \"defaultuid\");\n+  }\n+\n+  private void switchNSManagementToLabelSelectUsingUpgradeOperator(String manageByLabelNS,\n+                                                                   String manageByExpNS,\n+                                                                   String manageByLabelDomainUid,\n+                                                                   String manageByExpDomainUid) {\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(op2Namespace, \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams2)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(op2Namespace, opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(startDomain(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op2Namespace,manageByLabelDomainUid);\n+    //check operator can't manage anymore manageByExpNS\n+    assertTrue(isOperatorFailedToScaleDomain(op2Namespace, manageByExpDomainUid,\n+        manageByExpNS), \"Operator can still manage domain \"\n+        + manageByExpNS + \" in the namespace \" + manageByExpNS);\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByNSRegExp(String manageByExp1NS,\n+                                                                 String manageByExp2NS,\n+                                                                 String manageByExpDomain1Uid,\n+                                                                 String manageByExpDomain2Uid) {\n+    // install and verify operator with domainNsSelectStrategy=RegExp to manage domains with namespaces names,\n+    // starting from test\n+    opHelmParams2 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op2Namespace, \"RegExp\", \"^test\", true, domain3Namespace);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByExp1NS);\n+    assertTrue(startDomain(manageByExp1NS, manageByExpDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByExp1NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain1Uid);\n+\n+    logger.info(\"Installing and verifying domain2\");\n+    createSecrets(manageByExp2NS);\n+    assertTrue(startDomain(manageByExp2NS, manageByExpDomain2Uid),\n+        \"operator can start or verify domain in namespace \" + manageByExp2NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain2Uid);\n+  }\n+\n+\n+  private boolean startDomain(String domainNamespace, String domainUid) {\n+\n+    // create and verify the domain\n+    logger.info(\"Creating and verifying model in image domain\");\n+    try {\n+      Domain domain = createDomainCRD(domainNamespace, domainUid);\n+      createVerifyDomain(domainNamespace, domainUid, miiImage, domain);\n+      return true;\n+    } catch (Exception ex) {\n+      logger.info(\"Failed to createVerifyDomain \" + ex.getMessage());\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Create a model in image domain crd.\n+   */\n+  private Domain createDomainCRD(String domainNamespace, String domainUid) {\n+\n+    // construct a list of oracle.weblogic.domain.Cluster objects to be used in the domain custom resource\n+    List<Cluster> clusters = new ArrayList<>();\n+    clusters.add(new Cluster()\n+        .clusterName(clusterName)\n+        .replicas(replicaCount)\n+        .serverStartState(\"RUNNING\"));\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new oracle.weblogic.domain.AdminService()\n+                    .addChannelsItem(new oracle.weblogic.domain.Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))))\n+            .clusters(clusters)\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(WLS_DOMAIN_TYPE)\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+    return domain;\n+  }\n+\n+  private static void createSecrets(String domainNamespace) {\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Creating docker registry secret in namespace {0}\", domainNamespace);\n+    if (!domainNamespace.equals(\"default\")) {\n+      createDockerRegistrySecret(domainNamespace);\n+    }\n+\n+    // create secret for admin credentials\n+    logger.info(\"Creating secret for admin credentials\");\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Creating encryption secret\");\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \"weblogicenc\", \"weblogicenc\");\n+  }\n+\n+  private static void deleteSecrets(String domainNamespace) {\n+    logger.info(\"Deleting docker registry secret in namespace {0}\", domainNamespace);\n+    if (!domainNamespace.equals(\"default\")) {\n+      deleteSecret(OCR_SECRET_NAME, domainNamespace);\n+    }\n+\n+    // delete secret for admin credentials\n+    logger.info(\"Deleting secret for admin credentials\");\n+    deleteSecret(adminSecretName, domainNamespace);\n+\n+    // delete encryption secret\n+    logger.info(\"Deleting encryption secret\");\n+    deleteSecret(encryptionSecretName, domainNamespace);\n+  }\n+\n+  private void createVerifyDomain(String domainNamespace, String domainUid, String miiImage, Domain domain) {\n+    // create domain\n+    logger.info(\"Creating model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainAndVerify(domain, domainNamespace);\n+    String adminServerPodName = domainUid + adminServerPrefix;\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check for managed server pods existence in the domain namespace\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = domainUid + managedServerPrefix + i;\n+\n+      // check that the managed server pod exists\n+      logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  /**\n+   * Install WebLogic operator and wait up to two minutes until the operator pod is ready.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3"}, "originalPosition": 684}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2OTA1Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @param operNamespace the operator namespace in which the operator will be installed\n          \n          \n            \n               * @param operNamespace the namespace in which the operator is installed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498969057", "createdAt": "2020-10-02T17:59:42Z", "author": {"login": "sankarpn"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace domain3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domain1Namespace;\n+    String manageByExp2NS = \"test-\" +  domain2Namespace;\n+    String manageByExpDomain1Uid = \"test-\" + domain1Uid;\n+    String manageByExpDomain2Uid = \"test-\" + domain2Uid;\n+    String manageByLabelNS = \"weblogic1\" + domain1Namespace;\n+    String manageByLabelDomainUid = \"weblogic1\" + domain1Uid;\n+    String domain3NS = \"atest-\" +  domain1Namespace;\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(domain3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3Namespace);\n+    checkDomainNotStartedInDefaultNS(\"RegExp\");\n+    //verify that operator can't start domain if namespace does not start from test\n+    createSecrets(domain3NS);\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domain1Namespace;\n+    String manageByLabelDomain2NS = domain2Namespace;\n+    String manageByExpDomainUid = \"weblogic2\" + domain2Namespace;\n+    String manageByExpDomainNS = \"weblogic2\" + domain2Namespace;\n+    String manageByLabelDomain1Uid = domain1Uid;\n+    String manageByLabelDomain2Uid = domain2Uid;\n+    installAndVerifyOperatorCanManageDomainByLabelSelector(manageByLabelDomain1NS, manageByLabelDomain2NS,\n+        manageByLabelDomain1Uid, manageByLabelDomain2Uid);\n+    addExtraDomainByAddingLabelToNS(labels1, manageByLabelDomain2NS, manageByLabelDomain2Uid);\n+    checkDomainNotStartedInDefaultNS(\"SelectLabel\");\n+    checkSecondOperatorFailedToShareSameNS(manageByLabelDomain1NS);\n+    switchNSManagementToRegExpUsingUpgradeOperator(manageByLabelDomain1NS, manageByExpDomainNS,\n+        manageByLabelDomain1Uid, manageByExpDomainUid);\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domain1Namespace + \"test4\";\n+    String manageByLabelDomainUid = domain1Uid + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams4 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op4Namespace, \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(op4Namespace, \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams4);\n+\n+    assertTrue(upgradeAndVerifyOperator(op4Namespace, opParams));\n+    assertTrue(startDomain(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op4Namespace, manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespace, opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void switchNSManagementToRegExpUsingUpgradeOperator(String manageByLabelNS,\n+                                                              String manageByExpNS,\n+                                                              String manageByLabelDomainUid,\n+                                                              String manageByExpDomainUid) {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpNS);\n+    assertTrue(startDomain(manageByExpNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespace,manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespace, manageByLabelDomainUid, manageByLabelNS),\n+        \"Operator can still manage domain \"\n+        + manageByLabelDomainUid + \" in the namespace \" + manageByLabelNS);\n+  }\n+\n+  private void addExtraDomainByAddingLabelToNS(Map<String, String> labels, String domainNS, String domainUid) {\n+    deleteDomainCrd(domainNS, domainUid);\n+\n+    //switch to the label1, managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNS, labels);\n+    assertTrue(startDomain(domainNS, domainUid));\n+    checkOperatorCanScaleDomain(opNamespace, domainUid);\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {\n+    //clean up domain resources in namespace and set namespace to label , managed by operator\n+    logger.info(\"deleting domain custom resource {0}\", domainUid);\n+    assertTrue(deleteDomainCustomResource(domainUid, domainNS));\n+\n+    // wait until domain was deleted\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNS,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainDoesNotExist(domainUid, DOMAIN_VERSION, domainNS));\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByLabelSelector(String manageByLabelDomain1NS,\n+                                                                      String manageByLabelDomain2NS,\n+                                                                      String manageByLabelDomain1Uid,\n+                                                                      String manageByLabelDomain2Uid) {\n+    // install and verify operator set to manage domains based on LabelSelector strategy,\n+    // domainNamespaces set to domain4 will be ignored\n+    opHelmParams1 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        opNamespace, \"LabelSelector\",\n+        OPERATOR_RELEASE_NAME, true, manageByLabelDomain1NS);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByLabelDomain1NS);\n+    assertTrue(startDomain(manageByLabelDomain1NS, manageByLabelDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByLabelDomain1NS);\n+\n+    checkOperatorCanScaleDomain(opNamespace, manageByLabelDomain1Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain4 will not start\n+    createSecrets(domain4Namespace);\n+    checkPodNotCreated(domain4Uid + adminServerPrefix, domain4Uid, domain4Namespace);\n+\n+    //verify that domain2 in namespace with no label2 will not start\n+    createSecrets(manageByLabelDomain2NS);\n+    checkPodNotCreated(manageByLabelDomain2Uid + adminServerPrefix, manageByLabelDomain2Uid, manageByLabelDomain2NS);\n+  }\n+\n+  private boolean isOperatorFailedToScaleDomain(String opNamespace, String domainUid, String domainNamespace) {\n+    try {\n+      //check operator can't manage domainNamespace by trying to scale domain\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      String managedServerPodNamePrefix = domainUid + \"-managed-server\";\n+      String opServiceAccount = OPERATOR_RELEASE_NAME + \"-sa\";\n+      scaleAndVerifyCluster(\"cluster-1\", domainUid, domainNamespace,\n+          managedServerPodNamePrefix, 2, 1,\n+          true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+          false, \"\", \"scaleDown\", 1, \"\", \"\", null, null);\n+      return false;\n+\n+    } catch (ConditionTimeoutException ex) {\n+      logger.info(\"Received expected error \" + ex.getMessage());\n+      return true;\n+    }\n+  }\n+\n+  private static void setLabelToNamespace(String domainNS, Map<String, String> labels) {\n+    //add label to domain namespace\n+    V1Namespace namespaceObject1 = assertDoesNotThrow(() -> Kubernetes.getNamespaceAsObject(domainNS));\n+    assertNotNull(namespaceObject1, \"Can't find namespace with name \" + domainNS);\n+    namespaceObject1.getMetadata().setLabels(labels);\n+    assertDoesNotThrow(() -> Kubernetes.replaceNamespace(namespaceObject1));\n+  }\n+\n+  private void checkOperatorCanScaleDomain(String opNamespace, String domainUid) {\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    assertTrue(scaleClusterWithRestApi(domainUid, clusterName, 3,\n+        externalRestHttpsPort, opNamespace, OPERATOR_RELEASE_NAME + \"-sa\"),\n+        \"Domain \" + domainUid + \" scaling operation failed\");\n+  }\n+\n+  private void checkSecondOperatorFailedToShareSameNS(String domainNamespace) {\n+    // try to install another operator sharing same domain namespace via different domainNsSelectionStrategy\n+    try {\n+      HelmParams opHelmParams3 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+          op3Namespace, \"List\",\n+          null, true, domainNamespace);\n+      assertNull(opHelmParams3, \"Operator helm chart sharing same NS with other operator did not fail\");\n+    } catch (org.opentest4j.AssertionFailedError ex) {\n+      //expecting to fail\n+      logger.info(\"Helm installation failed as expected \" + ex.getMessage());\n+    }\n+  }\n+\n+  private void checkDomainNotStartedInDefaultNS(String domainNsSelectionStrategy) {\n+    //verify operator can't start domain in the default namespace when domainNsSelectionStrategy not List\n+    // and selector does not match default\n+    checkPodNotCreated(\"defaultuid\" + adminServerPrefix, \"defaultuid\", \"default\");\n+\n+    logger.info(\"Delete defaultuid custom resource in namespace {0}\", \"default\");\n+    deleteDomainCustomResource(\"defaultuid\", \"default\");\n+    logger.info(\"Deleted Domain Custom Resource \" + \"defaultuid\");\n+  }\n+\n+  private void switchNSManagementToLabelSelectUsingUpgradeOperator(String manageByLabelNS,\n+                                                                   String manageByExpNS,\n+                                                                   String manageByLabelDomainUid,\n+                                                                   String manageByExpDomainUid) {\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(op2Namespace, \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams2)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(op2Namespace, opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(startDomain(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op2Namespace,manageByLabelDomainUid);\n+    //check operator can't manage anymore manageByExpNS\n+    assertTrue(isOperatorFailedToScaleDomain(op2Namespace, manageByExpDomainUid,\n+        manageByExpNS), \"Operator can still manage domain \"\n+        + manageByExpNS + \" in the namespace \" + manageByExpNS);\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByNSRegExp(String manageByExp1NS,\n+                                                                 String manageByExp2NS,\n+                                                                 String manageByExpDomain1Uid,\n+                                                                 String manageByExpDomain2Uid) {\n+    // install and verify operator with domainNsSelectStrategy=RegExp to manage domains with namespaces names,\n+    // starting from test\n+    opHelmParams2 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op2Namespace, \"RegExp\", \"^test\", true, domain3Namespace);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByExp1NS);\n+    assertTrue(startDomain(manageByExp1NS, manageByExpDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByExp1NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain1Uid);\n+\n+    logger.info(\"Installing and verifying domain2\");\n+    createSecrets(manageByExp2NS);\n+    assertTrue(startDomain(manageByExp2NS, manageByExpDomain2Uid),\n+        \"operator can start or verify domain in namespace \" + manageByExp2NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain2Uid);\n+  }\n+\n+\n+  private boolean startDomain(String domainNamespace, String domainUid) {\n+\n+    // create and verify the domain\n+    logger.info(\"Creating and verifying model in image domain\");\n+    try {\n+      Domain domain = createDomainCRD(domainNamespace, domainUid);\n+      createVerifyDomain(domainNamespace, domainUid, miiImage, domain);\n+      return true;\n+    } catch (Exception ex) {\n+      logger.info(\"Failed to createVerifyDomain \" + ex.getMessage());\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Create a model in image domain crd.\n+   */\n+  private Domain createDomainCRD(String domainNamespace, String domainUid) {\n+\n+    // construct a list of oracle.weblogic.domain.Cluster objects to be used in the domain custom resource\n+    List<Cluster> clusters = new ArrayList<>();\n+    clusters.add(new Cluster()\n+        .clusterName(clusterName)\n+        .replicas(replicaCount)\n+        .serverStartState(\"RUNNING\"));\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new oracle.weblogic.domain.AdminService()\n+                    .addChannelsItem(new oracle.weblogic.domain.Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))))\n+            .clusters(clusters)\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(WLS_DOMAIN_TYPE)\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+    return domain;\n+  }\n+\n+  private static void createSecrets(String domainNamespace) {\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Creating docker registry secret in namespace {0}\", domainNamespace);\n+    if (!domainNamespace.equals(\"default\")) {\n+      createDockerRegistrySecret(domainNamespace);\n+    }\n+\n+    // create secret for admin credentials\n+    logger.info(\"Creating secret for admin credentials\");\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Creating encryption secret\");\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \"weblogicenc\", \"weblogicenc\");\n+  }\n+\n+  private static void deleteSecrets(String domainNamespace) {\n+    logger.info(\"Deleting docker registry secret in namespace {0}\", domainNamespace);\n+    if (!domainNamespace.equals(\"default\")) {\n+      deleteSecret(OCR_SECRET_NAME, domainNamespace);\n+    }\n+\n+    // delete secret for admin credentials\n+    logger.info(\"Deleting secret for admin credentials\");\n+    deleteSecret(adminSecretName, domainNamespace);\n+\n+    // delete encryption secret\n+    logger.info(\"Deleting encryption secret\");\n+    deleteSecret(encryptionSecretName, domainNamespace);\n+  }\n+\n+  private void createVerifyDomain(String domainNamespace, String domainUid, String miiImage, Domain domain) {\n+    // create domain\n+    logger.info(\"Creating model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainAndVerify(domain, domainNamespace);\n+    String adminServerPodName = domainUid + adminServerPrefix;\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check for managed server pods existence in the domain namespace\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = domainUid + managedServerPrefix + i;\n+\n+      // check that the managed server pod exists\n+      logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  /**\n+   * Install WebLogic operator and wait up to two minutes until the operator pod is ready.\n+   *\n+   * @param operNamespace the operator namespace in which the operator will be installed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3"}, "originalPosition": 686}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2OTMyMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @param domainNamespace the list of the domain namespaces which will be managed by the operator\n          \n          \n            \n               * @param domainNamespace the list of the domain namespaces managed by the operator", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498969320", "createdAt": "2020-10-02T18:00:15Z", "author": {"login": "sankarpn"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace domain3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domain1Namespace;\n+    String manageByExp2NS = \"test-\" +  domain2Namespace;\n+    String manageByExpDomain1Uid = \"test-\" + domain1Uid;\n+    String manageByExpDomain2Uid = \"test-\" + domain2Uid;\n+    String manageByLabelNS = \"weblogic1\" + domain1Namespace;\n+    String manageByLabelDomainUid = \"weblogic1\" + domain1Uid;\n+    String domain3NS = \"atest-\" +  domain1Namespace;\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(domain3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3Namespace);\n+    checkDomainNotStartedInDefaultNS(\"RegExp\");\n+    //verify that operator can't start domain if namespace does not start from test\n+    createSecrets(domain3NS);\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domain1Namespace;\n+    String manageByLabelDomain2NS = domain2Namespace;\n+    String manageByExpDomainUid = \"weblogic2\" + domain2Namespace;\n+    String manageByExpDomainNS = \"weblogic2\" + domain2Namespace;\n+    String manageByLabelDomain1Uid = domain1Uid;\n+    String manageByLabelDomain2Uid = domain2Uid;\n+    installAndVerifyOperatorCanManageDomainByLabelSelector(manageByLabelDomain1NS, manageByLabelDomain2NS,\n+        manageByLabelDomain1Uid, manageByLabelDomain2Uid);\n+    addExtraDomainByAddingLabelToNS(labels1, manageByLabelDomain2NS, manageByLabelDomain2Uid);\n+    checkDomainNotStartedInDefaultNS(\"SelectLabel\");\n+    checkSecondOperatorFailedToShareSameNS(manageByLabelDomain1NS);\n+    switchNSManagementToRegExpUsingUpgradeOperator(manageByLabelDomain1NS, manageByExpDomainNS,\n+        manageByLabelDomain1Uid, manageByExpDomainUid);\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domain1Namespace + \"test4\";\n+    String manageByLabelDomainUid = domain1Uid + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams4 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op4Namespace, \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(op4Namespace, \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams4);\n+\n+    assertTrue(upgradeAndVerifyOperator(op4Namespace, opParams));\n+    assertTrue(startDomain(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op4Namespace, manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespace, opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void switchNSManagementToRegExpUsingUpgradeOperator(String manageByLabelNS,\n+                                                              String manageByExpNS,\n+                                                              String manageByLabelDomainUid,\n+                                                              String manageByExpDomainUid) {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpNS);\n+    assertTrue(startDomain(manageByExpNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespace,manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespace, manageByLabelDomainUid, manageByLabelNS),\n+        \"Operator can still manage domain \"\n+        + manageByLabelDomainUid + \" in the namespace \" + manageByLabelNS);\n+  }\n+\n+  private void addExtraDomainByAddingLabelToNS(Map<String, String> labels, String domainNS, String domainUid) {\n+    deleteDomainCrd(domainNS, domainUid);\n+\n+    //switch to the label1, managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNS, labels);\n+    assertTrue(startDomain(domainNS, domainUid));\n+    checkOperatorCanScaleDomain(opNamespace, domainUid);\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {\n+    //clean up domain resources in namespace and set namespace to label , managed by operator\n+    logger.info(\"deleting domain custom resource {0}\", domainUid);\n+    assertTrue(deleteDomainCustomResource(domainUid, domainNS));\n+\n+    // wait until domain was deleted\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNS,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainDoesNotExist(domainUid, DOMAIN_VERSION, domainNS));\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByLabelSelector(String manageByLabelDomain1NS,\n+                                                                      String manageByLabelDomain2NS,\n+                                                                      String manageByLabelDomain1Uid,\n+                                                                      String manageByLabelDomain2Uid) {\n+    // install and verify operator set to manage domains based on LabelSelector strategy,\n+    // domainNamespaces set to domain4 will be ignored\n+    opHelmParams1 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        opNamespace, \"LabelSelector\",\n+        OPERATOR_RELEASE_NAME, true, manageByLabelDomain1NS);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByLabelDomain1NS);\n+    assertTrue(startDomain(manageByLabelDomain1NS, manageByLabelDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByLabelDomain1NS);\n+\n+    checkOperatorCanScaleDomain(opNamespace, manageByLabelDomain1Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain4 will not start\n+    createSecrets(domain4Namespace);\n+    checkPodNotCreated(domain4Uid + adminServerPrefix, domain4Uid, domain4Namespace);\n+\n+    //verify that domain2 in namespace with no label2 will not start\n+    createSecrets(manageByLabelDomain2NS);\n+    checkPodNotCreated(manageByLabelDomain2Uid + adminServerPrefix, manageByLabelDomain2Uid, manageByLabelDomain2NS);\n+  }\n+\n+  private boolean isOperatorFailedToScaleDomain(String opNamespace, String domainUid, String domainNamespace) {\n+    try {\n+      //check operator can't manage domainNamespace by trying to scale domain\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      String managedServerPodNamePrefix = domainUid + \"-managed-server\";\n+      String opServiceAccount = OPERATOR_RELEASE_NAME + \"-sa\";\n+      scaleAndVerifyCluster(\"cluster-1\", domainUid, domainNamespace,\n+          managedServerPodNamePrefix, 2, 1,\n+          true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+          false, \"\", \"scaleDown\", 1, \"\", \"\", null, null);\n+      return false;\n+\n+    } catch (ConditionTimeoutException ex) {\n+      logger.info(\"Received expected error \" + ex.getMessage());\n+      return true;\n+    }\n+  }\n+\n+  private static void setLabelToNamespace(String domainNS, Map<String, String> labels) {\n+    //add label to domain namespace\n+    V1Namespace namespaceObject1 = assertDoesNotThrow(() -> Kubernetes.getNamespaceAsObject(domainNS));\n+    assertNotNull(namespaceObject1, \"Can't find namespace with name \" + domainNS);\n+    namespaceObject1.getMetadata().setLabels(labels);\n+    assertDoesNotThrow(() -> Kubernetes.replaceNamespace(namespaceObject1));\n+  }\n+\n+  private void checkOperatorCanScaleDomain(String opNamespace, String domainUid) {\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    assertTrue(scaleClusterWithRestApi(domainUid, clusterName, 3,\n+        externalRestHttpsPort, opNamespace, OPERATOR_RELEASE_NAME + \"-sa\"),\n+        \"Domain \" + domainUid + \" scaling operation failed\");\n+  }\n+\n+  private void checkSecondOperatorFailedToShareSameNS(String domainNamespace) {\n+    // try to install another operator sharing same domain namespace via different domainNsSelectionStrategy\n+    try {\n+      HelmParams opHelmParams3 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+          op3Namespace, \"List\",\n+          null, true, domainNamespace);\n+      assertNull(opHelmParams3, \"Operator helm chart sharing same NS with other operator did not fail\");\n+    } catch (org.opentest4j.AssertionFailedError ex) {\n+      //expecting to fail\n+      logger.info(\"Helm installation failed as expected \" + ex.getMessage());\n+    }\n+  }\n+\n+  private void checkDomainNotStartedInDefaultNS(String domainNsSelectionStrategy) {\n+    //verify operator can't start domain in the default namespace when domainNsSelectionStrategy not List\n+    // and selector does not match default\n+    checkPodNotCreated(\"defaultuid\" + adminServerPrefix, \"defaultuid\", \"default\");\n+\n+    logger.info(\"Delete defaultuid custom resource in namespace {0}\", \"default\");\n+    deleteDomainCustomResource(\"defaultuid\", \"default\");\n+    logger.info(\"Deleted Domain Custom Resource \" + \"defaultuid\");\n+  }\n+\n+  private void switchNSManagementToLabelSelectUsingUpgradeOperator(String manageByLabelNS,\n+                                                                   String manageByExpNS,\n+                                                                   String manageByLabelDomainUid,\n+                                                                   String manageByExpDomainUid) {\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(op2Namespace, \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams2)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(op2Namespace, opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(startDomain(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op2Namespace,manageByLabelDomainUid);\n+    //check operator can't manage anymore manageByExpNS\n+    assertTrue(isOperatorFailedToScaleDomain(op2Namespace, manageByExpDomainUid,\n+        manageByExpNS), \"Operator can still manage domain \"\n+        + manageByExpNS + \" in the namespace \" + manageByExpNS);\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByNSRegExp(String manageByExp1NS,\n+                                                                 String manageByExp2NS,\n+                                                                 String manageByExpDomain1Uid,\n+                                                                 String manageByExpDomain2Uid) {\n+    // install and verify operator with domainNsSelectStrategy=RegExp to manage domains with namespaces names,\n+    // starting from test\n+    opHelmParams2 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op2Namespace, \"RegExp\", \"^test\", true, domain3Namespace);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByExp1NS);\n+    assertTrue(startDomain(manageByExp1NS, manageByExpDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByExp1NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain1Uid);\n+\n+    logger.info(\"Installing and verifying domain2\");\n+    createSecrets(manageByExp2NS);\n+    assertTrue(startDomain(manageByExp2NS, manageByExpDomain2Uid),\n+        \"operator can start or verify domain in namespace \" + manageByExp2NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain2Uid);\n+  }\n+\n+\n+  private boolean startDomain(String domainNamespace, String domainUid) {\n+\n+    // create and verify the domain\n+    logger.info(\"Creating and verifying model in image domain\");\n+    try {\n+      Domain domain = createDomainCRD(domainNamespace, domainUid);\n+      createVerifyDomain(domainNamespace, domainUid, miiImage, domain);\n+      return true;\n+    } catch (Exception ex) {\n+      logger.info(\"Failed to createVerifyDomain \" + ex.getMessage());\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Create a model in image domain crd.\n+   */\n+  private Domain createDomainCRD(String domainNamespace, String domainUid) {\n+\n+    // construct a list of oracle.weblogic.domain.Cluster objects to be used in the domain custom resource\n+    List<Cluster> clusters = new ArrayList<>();\n+    clusters.add(new Cluster()\n+        .clusterName(clusterName)\n+        .replicas(replicaCount)\n+        .serverStartState(\"RUNNING\"));\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new oracle.weblogic.domain.AdminService()\n+                    .addChannelsItem(new oracle.weblogic.domain.Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))))\n+            .clusters(clusters)\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(WLS_DOMAIN_TYPE)\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+    return domain;\n+  }\n+\n+  private static void createSecrets(String domainNamespace) {\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Creating docker registry secret in namespace {0}\", domainNamespace);\n+    if (!domainNamespace.equals(\"default\")) {\n+      createDockerRegistrySecret(domainNamespace);\n+    }\n+\n+    // create secret for admin credentials\n+    logger.info(\"Creating secret for admin credentials\");\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Creating encryption secret\");\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \"weblogicenc\", \"weblogicenc\");\n+  }\n+\n+  private static void deleteSecrets(String domainNamespace) {\n+    logger.info(\"Deleting docker registry secret in namespace {0}\", domainNamespace);\n+    if (!domainNamespace.equals(\"default\")) {\n+      deleteSecret(OCR_SECRET_NAME, domainNamespace);\n+    }\n+\n+    // delete secret for admin credentials\n+    logger.info(\"Deleting secret for admin credentials\");\n+    deleteSecret(adminSecretName, domainNamespace);\n+\n+    // delete encryption secret\n+    logger.info(\"Deleting encryption secret\");\n+    deleteSecret(encryptionSecretName, domainNamespace);\n+  }\n+\n+  private void createVerifyDomain(String domainNamespace, String domainUid, String miiImage, Domain domain) {\n+    // create domain\n+    logger.info(\"Creating model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainAndVerify(domain, domainNamespace);\n+    String adminServerPodName = domainUid + adminServerPrefix;\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check for managed server pods existence in the domain namespace\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = domainUid + managedServerPrefix + i;\n+\n+      // check that the managed server pod exists\n+      logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  /**\n+   * Install WebLogic operator and wait up to two minutes until the operator pod is ready.\n+   *\n+   * @param operNamespace the operator namespace in which the operator will be installed\n+   * @param opReleaseName the operator release name\n+   * @param enableClusterRoleBinding operator cluster role binding\n+   * @param domainNamespace the list of the domain namespaces which will be managed by the operator", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3"}, "originalPosition": 689}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2OTYwMg==", "bodyText": "You can define a class level logger and use it in all the methods", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498969602", "createdAt": "2020-10-02T18:00:51Z", "author": {"login": "sankarpn"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace domain3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domain1Namespace;\n+    String manageByExp2NS = \"test-\" +  domain2Namespace;\n+    String manageByExpDomain1Uid = \"test-\" + domain1Uid;\n+    String manageByExpDomain2Uid = \"test-\" + domain2Uid;\n+    String manageByLabelNS = \"weblogic1\" + domain1Namespace;\n+    String manageByLabelDomainUid = \"weblogic1\" + domain1Uid;\n+    String domain3NS = \"atest-\" +  domain1Namespace;\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(domain3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3Namespace);\n+    checkDomainNotStartedInDefaultNS(\"RegExp\");\n+    //verify that operator can't start domain if namespace does not start from test\n+    createSecrets(domain3NS);\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domain1Namespace;\n+    String manageByLabelDomain2NS = domain2Namespace;\n+    String manageByExpDomainUid = \"weblogic2\" + domain2Namespace;\n+    String manageByExpDomainNS = \"weblogic2\" + domain2Namespace;\n+    String manageByLabelDomain1Uid = domain1Uid;\n+    String manageByLabelDomain2Uid = domain2Uid;\n+    installAndVerifyOperatorCanManageDomainByLabelSelector(manageByLabelDomain1NS, manageByLabelDomain2NS,\n+        manageByLabelDomain1Uid, manageByLabelDomain2Uid);\n+    addExtraDomainByAddingLabelToNS(labels1, manageByLabelDomain2NS, manageByLabelDomain2Uid);\n+    checkDomainNotStartedInDefaultNS(\"SelectLabel\");\n+    checkSecondOperatorFailedToShareSameNS(manageByLabelDomain1NS);\n+    switchNSManagementToRegExpUsingUpgradeOperator(manageByLabelDomain1NS, manageByExpDomainNS,\n+        manageByLabelDomain1Uid, manageByExpDomainUid);\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domain1Namespace + \"test4\";\n+    String manageByLabelDomainUid = domain1Uid + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams4 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op4Namespace, \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(op4Namespace, \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams4);\n+\n+    assertTrue(upgradeAndVerifyOperator(op4Namespace, opParams));\n+    assertTrue(startDomain(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op4Namespace, manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespace, opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void switchNSManagementToRegExpUsingUpgradeOperator(String manageByLabelNS,\n+                                                              String manageByExpNS,\n+                                                              String manageByLabelDomainUid,\n+                                                              String manageByExpDomainUid) {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpNS);\n+    assertTrue(startDomain(manageByExpNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespace,manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespace, manageByLabelDomainUid, manageByLabelNS),\n+        \"Operator can still manage domain \"\n+        + manageByLabelDomainUid + \" in the namespace \" + manageByLabelNS);\n+  }\n+\n+  private void addExtraDomainByAddingLabelToNS(Map<String, String> labels, String domainNS, String domainUid) {\n+    deleteDomainCrd(domainNS, domainUid);\n+\n+    //switch to the label1, managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNS, labels);\n+    assertTrue(startDomain(domainNS, domainUid));\n+    checkOperatorCanScaleDomain(opNamespace, domainUid);\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {\n+    //clean up domain resources in namespace and set namespace to label , managed by operator\n+    logger.info(\"deleting domain custom resource {0}\", domainUid);\n+    assertTrue(deleteDomainCustomResource(domainUid, domainNS));\n+\n+    // wait until domain was deleted\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNS,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainDoesNotExist(domainUid, DOMAIN_VERSION, domainNS));\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByLabelSelector(String manageByLabelDomain1NS,\n+                                                                      String manageByLabelDomain2NS,\n+                                                                      String manageByLabelDomain1Uid,\n+                                                                      String manageByLabelDomain2Uid) {\n+    // install and verify operator set to manage domains based on LabelSelector strategy,\n+    // domainNamespaces set to domain4 will be ignored\n+    opHelmParams1 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        opNamespace, \"LabelSelector\",\n+        OPERATOR_RELEASE_NAME, true, manageByLabelDomain1NS);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByLabelDomain1NS);\n+    assertTrue(startDomain(manageByLabelDomain1NS, manageByLabelDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByLabelDomain1NS);\n+\n+    checkOperatorCanScaleDomain(opNamespace, manageByLabelDomain1Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain4 will not start\n+    createSecrets(domain4Namespace);\n+    checkPodNotCreated(domain4Uid + adminServerPrefix, domain4Uid, domain4Namespace);\n+\n+    //verify that domain2 in namespace with no label2 will not start\n+    createSecrets(manageByLabelDomain2NS);\n+    checkPodNotCreated(manageByLabelDomain2Uid + adminServerPrefix, manageByLabelDomain2Uid, manageByLabelDomain2NS);\n+  }\n+\n+  private boolean isOperatorFailedToScaleDomain(String opNamespace, String domainUid, String domainNamespace) {\n+    try {\n+      //check operator can't manage domainNamespace by trying to scale domain\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      String managedServerPodNamePrefix = domainUid + \"-managed-server\";\n+      String opServiceAccount = OPERATOR_RELEASE_NAME + \"-sa\";\n+      scaleAndVerifyCluster(\"cluster-1\", domainUid, domainNamespace,\n+          managedServerPodNamePrefix, 2, 1,\n+          true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+          false, \"\", \"scaleDown\", 1, \"\", \"\", null, null);\n+      return false;\n+\n+    } catch (ConditionTimeoutException ex) {\n+      logger.info(\"Received expected error \" + ex.getMessage());\n+      return true;\n+    }\n+  }\n+\n+  private static void setLabelToNamespace(String domainNS, Map<String, String> labels) {\n+    //add label to domain namespace\n+    V1Namespace namespaceObject1 = assertDoesNotThrow(() -> Kubernetes.getNamespaceAsObject(domainNS));\n+    assertNotNull(namespaceObject1, \"Can't find namespace with name \" + domainNS);\n+    namespaceObject1.getMetadata().setLabels(labels);\n+    assertDoesNotThrow(() -> Kubernetes.replaceNamespace(namespaceObject1));\n+  }\n+\n+  private void checkOperatorCanScaleDomain(String opNamespace, String domainUid) {\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    assertTrue(scaleClusterWithRestApi(domainUid, clusterName, 3,\n+        externalRestHttpsPort, opNamespace, OPERATOR_RELEASE_NAME + \"-sa\"),\n+        \"Domain \" + domainUid + \" scaling operation failed\");\n+  }\n+\n+  private void checkSecondOperatorFailedToShareSameNS(String domainNamespace) {\n+    // try to install another operator sharing same domain namespace via different domainNsSelectionStrategy\n+    try {\n+      HelmParams opHelmParams3 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+          op3Namespace, \"List\",\n+          null, true, domainNamespace);\n+      assertNull(opHelmParams3, \"Operator helm chart sharing same NS with other operator did not fail\");\n+    } catch (org.opentest4j.AssertionFailedError ex) {\n+      //expecting to fail\n+      logger.info(\"Helm installation failed as expected \" + ex.getMessage());\n+    }\n+  }\n+\n+  private void checkDomainNotStartedInDefaultNS(String domainNsSelectionStrategy) {\n+    //verify operator can't start domain in the default namespace when domainNsSelectionStrategy not List\n+    // and selector does not match default\n+    checkPodNotCreated(\"defaultuid\" + adminServerPrefix, \"defaultuid\", \"default\");\n+\n+    logger.info(\"Delete defaultuid custom resource in namespace {0}\", \"default\");\n+    deleteDomainCustomResource(\"defaultuid\", \"default\");\n+    logger.info(\"Deleted Domain Custom Resource \" + \"defaultuid\");\n+  }\n+\n+  private void switchNSManagementToLabelSelectUsingUpgradeOperator(String manageByLabelNS,\n+                                                                   String manageByExpNS,\n+                                                                   String manageByLabelDomainUid,\n+                                                                   String manageByExpDomainUid) {\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(op2Namespace, \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams2)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(op2Namespace, opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(startDomain(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op2Namespace,manageByLabelDomainUid);\n+    //check operator can't manage anymore manageByExpNS\n+    assertTrue(isOperatorFailedToScaleDomain(op2Namespace, manageByExpDomainUid,\n+        manageByExpNS), \"Operator can still manage domain \"\n+        + manageByExpNS + \" in the namespace \" + manageByExpNS);\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByNSRegExp(String manageByExp1NS,\n+                                                                 String manageByExp2NS,\n+                                                                 String manageByExpDomain1Uid,\n+                                                                 String manageByExpDomain2Uid) {\n+    // install and verify operator with domainNsSelectStrategy=RegExp to manage domains with namespaces names,\n+    // starting from test\n+    opHelmParams2 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op2Namespace, \"RegExp\", \"^test\", true, domain3Namespace);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByExp1NS);\n+    assertTrue(startDomain(manageByExp1NS, manageByExpDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByExp1NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain1Uid);\n+\n+    logger.info(\"Installing and verifying domain2\");\n+    createSecrets(manageByExp2NS);\n+    assertTrue(startDomain(manageByExp2NS, manageByExpDomain2Uid),\n+        \"operator can start or verify domain in namespace \" + manageByExp2NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain2Uid);\n+  }\n+\n+\n+  private boolean startDomain(String domainNamespace, String domainUid) {\n+\n+    // create and verify the domain\n+    logger.info(\"Creating and verifying model in image domain\");\n+    try {\n+      Domain domain = createDomainCRD(domainNamespace, domainUid);\n+      createVerifyDomain(domainNamespace, domainUid, miiImage, domain);\n+      return true;\n+    } catch (Exception ex) {\n+      logger.info(\"Failed to createVerifyDomain \" + ex.getMessage());\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Create a model in image domain crd.\n+   */\n+  private Domain createDomainCRD(String domainNamespace, String domainUid) {\n+\n+    // construct a list of oracle.weblogic.domain.Cluster objects to be used in the domain custom resource\n+    List<Cluster> clusters = new ArrayList<>();\n+    clusters.add(new Cluster()\n+        .clusterName(clusterName)\n+        .replicas(replicaCount)\n+        .serverStartState(\"RUNNING\"));\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new oracle.weblogic.domain.AdminService()\n+                    .addChannelsItem(new oracle.weblogic.domain.Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))))\n+            .clusters(clusters)\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(WLS_DOMAIN_TYPE)\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+    return domain;\n+  }\n+\n+  private static void createSecrets(String domainNamespace) {\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Creating docker registry secret in namespace {0}\", domainNamespace);\n+    if (!domainNamespace.equals(\"default\")) {\n+      createDockerRegistrySecret(domainNamespace);\n+    }\n+\n+    // create secret for admin credentials\n+    logger.info(\"Creating secret for admin credentials\");\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Creating encryption secret\");\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \"weblogicenc\", \"weblogicenc\");\n+  }\n+\n+  private static void deleteSecrets(String domainNamespace) {\n+    logger.info(\"Deleting docker registry secret in namespace {0}\", domainNamespace);\n+    if (!domainNamespace.equals(\"default\")) {\n+      deleteSecret(OCR_SECRET_NAME, domainNamespace);\n+    }\n+\n+    // delete secret for admin credentials\n+    logger.info(\"Deleting secret for admin credentials\");\n+    deleteSecret(adminSecretName, domainNamespace);\n+\n+    // delete encryption secret\n+    logger.info(\"Deleting encryption secret\");\n+    deleteSecret(encryptionSecretName, domainNamespace);\n+  }\n+\n+  private void createVerifyDomain(String domainNamespace, String domainUid, String miiImage, Domain domain) {\n+    // create domain\n+    logger.info(\"Creating model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainAndVerify(domain, domainNamespace);\n+    String adminServerPodName = domainUid + adminServerPrefix;\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check for managed server pods existence in the domain namespace\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = domainUid + managedServerPrefix + i;\n+\n+      // check that the managed server pod exists\n+      logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  /**\n+   * Install WebLogic operator and wait up to two minutes until the operator pod is ready.\n+   *\n+   * @param operNamespace the operator namespace in which the operator will be installed\n+   * @param opReleaseName the operator release name\n+   * @param enableClusterRoleBinding operator cluster role binding\n+   * @param domainNamespace the list of the domain namespaces which will be managed by the operator\n+   * @return the operator Helm installation parameters\n+   */\n+  private static HelmParams installOperatorHelmChart(String opReleaseName, String operNamespace,\n+                                                     String domainNsSelectionStrategy,\n+                                                     String domainNsSelector,\n+                                                     boolean enableClusterRoleBinding,\n+                                                     String... domainNamespace) {\n+    LoggingFacade logger = getLogger();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3"}, "originalPosition": 697}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3MDkzOQ==", "bodyText": "incomplete sentence", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498970939", "createdAt": "2020-10-02T18:03:39Z", "author": {"login": "sankarpn"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -703,6 +704,34 @@ public static boolean createNamespace(String name) throws ApiException {\n     return true;\n   }\n \n+  // --------------------------- namespaces -----------------------------------\n+  /**\n+   * Create a Kubernetes namespace.\n+   *\n+   * @param name the name of the namespace\n+   * @param labels list of labels for the namespace\n+   * @return true on success, false otherwise\n+   * @throws ApiException if Kubernetes client API call", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3MTQ4OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * List namespaces in the Kubernetes cluster.\n          \n          \n            \n               * List namespaces in the Kubernetes cluster matching the label selector.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498971488", "createdAt": "2020-10-02T18:04:49Z", "author": {"login": "sankarpn"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -760,6 +789,15 @@ public static void replaceNamespace(V1Namespace ns) throws ApiException {\n    * @throws ApiException if Kubernetes client API call fails\n    */\n   public static List<String> listNamespaces() throws ApiException {\n+    return listNamespaces(null);\n+  }\n+\n+  /**\n+   * List namespaces in the Kubernetes cluster.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3MTcyOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * return namespace by provided name in the Kubernetes cluster as V1Namespace object.\n          \n          \n            \n               * Return namespace object for the given name from the Kubernetes cluster as V1Namespace object.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498971728", "createdAt": "2020-10-02T18:05:17Z", "author": {"login": "sankarpn"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -813,6 +851,39 @@ public static V1NamespaceList listNamespacesAsObjects() throws ApiException {\n     return namespaceList;\n   }\n \n+  /**\n+   * return namespace by provided name in the Kubernetes cluster as V1Namespace object.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3MjM3Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @return V1Namespace of Namespace in the Kubernetes cluster\n          \n          \n            \n               * @return V1Namespace  Namespace object from the Kubernetes cluster", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498972377", "createdAt": "2020-10-02T18:06:46Z", "author": {"login": "sankarpn"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -813,6 +851,39 @@ public static V1NamespaceList listNamespacesAsObjects() throws ApiException {\n     return namespaceList;\n   }\n \n+  /**\n+   * return namespace by provided name in the Kubernetes cluster as V1Namespace object.\n+   * @name name of namespace.\n+   * @return V1Namespace of Namespace in the Kubernetes cluster", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3"}, "originalPosition": 75}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMzUyMzI0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#pullrequestreview-502352324", "createdAt": "2020-10-05T19:24:07Z", "commit": {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxOToyNDowN1rOHcqmMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxOTo0Mzo0N1rOHcrNmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyMDA4Mw==", "bodyText": "move this method to CommonTestUtils", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r499820083", "createdAt": "2020-10-05T19:24:07Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace domain3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domain1Namespace;\n+    String manageByExp2NS = \"test-\" +  domain2Namespace;\n+    String manageByExpDomain1Uid = \"test-\" + domain1Uid;\n+    String manageByExpDomain2Uid = \"test-\" + domain2Uid;\n+    String manageByLabelNS = \"weblogic1\" + domain1Namespace;\n+    String manageByLabelDomainUid = \"weblogic1\" + domain1Uid;\n+    String domain3NS = \"atest-\" +  domain1Namespace;\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(domain3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3Namespace);\n+    checkDomainNotStartedInDefaultNS(\"RegExp\");\n+    //verify that operator can't start domain if namespace does not start from test\n+    createSecrets(domain3NS);\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domain1Namespace;\n+    String manageByLabelDomain2NS = domain2Namespace;\n+    String manageByExpDomainUid = \"weblogic2\" + domain2Namespace;\n+    String manageByExpDomainNS = \"weblogic2\" + domain2Namespace;\n+    String manageByLabelDomain1Uid = domain1Uid;\n+    String manageByLabelDomain2Uid = domain2Uid;\n+    installAndVerifyOperatorCanManageDomainByLabelSelector(manageByLabelDomain1NS, manageByLabelDomain2NS,\n+        manageByLabelDomain1Uid, manageByLabelDomain2Uid);\n+    addExtraDomainByAddingLabelToNS(labels1, manageByLabelDomain2NS, manageByLabelDomain2Uid);\n+    checkDomainNotStartedInDefaultNS(\"SelectLabel\");\n+    checkSecondOperatorFailedToShareSameNS(manageByLabelDomain1NS);\n+    switchNSManagementToRegExpUsingUpgradeOperator(manageByLabelDomain1NS, manageByExpDomainNS,\n+        manageByLabelDomain1Uid, manageByExpDomainUid);\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domain1Namespace + \"test4\";\n+    String manageByLabelDomainUid = domain1Uid + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams4 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op4Namespace, \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(op4Namespace, \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams4);\n+\n+    assertTrue(upgradeAndVerifyOperator(op4Namespace, opParams));\n+    assertTrue(startDomain(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op4Namespace, manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespace, opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void switchNSManagementToRegExpUsingUpgradeOperator(String manageByLabelNS,\n+                                                              String manageByExpNS,\n+                                                              String manageByLabelDomainUid,\n+                                                              String manageByExpDomainUid) {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpNS);\n+    assertTrue(startDomain(manageByExpNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespace,manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespace, manageByLabelDomainUid, manageByLabelNS),\n+        \"Operator can still manage domain \"\n+        + manageByLabelDomainUid + \" in the namespace \" + manageByLabelNS);\n+  }\n+\n+  private void addExtraDomainByAddingLabelToNS(Map<String, String> labels, String domainNS, String domainUid) {\n+    deleteDomainCrd(domainNS, domainUid);\n+\n+    //switch to the label1, managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNS, labels);\n+    assertTrue(startDomain(domainNS, domainUid));\n+    checkOperatorCanScaleDomain(opNamespace, domainUid);\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {\n+    //clean up domain resources in namespace and set namespace to label , managed by operator\n+    logger.info(\"deleting domain custom resource {0}\", domainUid);\n+    assertTrue(deleteDomainCustomResource(domainUid, domainNS));\n+\n+    // wait until domain was deleted\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNS,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainDoesNotExist(domainUid, DOMAIN_VERSION, domainNS));\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByLabelSelector(String manageByLabelDomain1NS,\n+                                                                      String manageByLabelDomain2NS,\n+                                                                      String manageByLabelDomain1Uid,\n+                                                                      String manageByLabelDomain2Uid) {\n+    // install and verify operator set to manage domains based on LabelSelector strategy,\n+    // domainNamespaces set to domain4 will be ignored\n+    opHelmParams1 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        opNamespace, \"LabelSelector\",\n+        OPERATOR_RELEASE_NAME, true, manageByLabelDomain1NS);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByLabelDomain1NS);\n+    assertTrue(startDomain(manageByLabelDomain1NS, manageByLabelDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByLabelDomain1NS);\n+\n+    checkOperatorCanScaleDomain(opNamespace, manageByLabelDomain1Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain4 will not start\n+    createSecrets(domain4Namespace);\n+    checkPodNotCreated(domain4Uid + adminServerPrefix, domain4Uid, domain4Namespace);\n+\n+    //verify that domain2 in namespace with no label2 will not start\n+    createSecrets(manageByLabelDomain2NS);\n+    checkPodNotCreated(manageByLabelDomain2Uid + adminServerPrefix, manageByLabelDomain2Uid, manageByLabelDomain2NS);\n+  }\n+\n+  private boolean isOperatorFailedToScaleDomain(String opNamespace, String domainUid, String domainNamespace) {\n+    try {\n+      //check operator can't manage domainNamespace by trying to scale domain\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      String managedServerPodNamePrefix = domainUid + \"-managed-server\";\n+      String opServiceAccount = OPERATOR_RELEASE_NAME + \"-sa\";\n+      scaleAndVerifyCluster(\"cluster-1\", domainUid, domainNamespace,\n+          managedServerPodNamePrefix, 2, 1,\n+          true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+          false, \"\", \"scaleDown\", 1, \"\", \"\", null, null);\n+      return false;\n+\n+    } catch (ConditionTimeoutException ex) {\n+      logger.info(\"Received expected error \" + ex.getMessage());\n+      return true;\n+    }\n+  }\n+\n+  private static void setLabelToNamespace(String domainNS, Map<String, String> labels) {\n+    //add label to domain namespace\n+    V1Namespace namespaceObject1 = assertDoesNotThrow(() -> Kubernetes.getNamespaceAsObject(domainNS));\n+    assertNotNull(namespaceObject1, \"Can't find namespace with name \" + domainNS);\n+    namespaceObject1.getMetadata().setLabels(labels);\n+    assertDoesNotThrow(() -> Kubernetes.replaceNamespace(namespaceObject1));\n+  }\n+\n+  private void checkOperatorCanScaleDomain(String opNamespace, String domainUid) {\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    assertTrue(scaleClusterWithRestApi(domainUid, clusterName, 3,\n+        externalRestHttpsPort, opNamespace, OPERATOR_RELEASE_NAME + \"-sa\"),\n+        \"Domain \" + domainUid + \" scaling operation failed\");\n+  }\n+\n+  private void checkSecondOperatorFailedToShareSameNS(String domainNamespace) {\n+    // try to install another operator sharing same domain namespace via different domainNsSelectionStrategy\n+    try {\n+      HelmParams opHelmParams3 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+          op3Namespace, \"List\",\n+          null, true, domainNamespace);\n+      assertNull(opHelmParams3, \"Operator helm chart sharing same NS with other operator did not fail\");\n+    } catch (org.opentest4j.AssertionFailedError ex) {\n+      //expecting to fail\n+      logger.info(\"Helm installation failed as expected \" + ex.getMessage());\n+    }\n+  }\n+\n+  private void checkDomainNotStartedInDefaultNS(String domainNsSelectionStrategy) {\n+    //verify operator can't start domain in the default namespace when domainNsSelectionStrategy not List\n+    // and selector does not match default\n+    checkPodNotCreated(\"defaultuid\" + adminServerPrefix, \"defaultuid\", \"default\");\n+\n+    logger.info(\"Delete defaultuid custom resource in namespace {0}\", \"default\");\n+    deleteDomainCustomResource(\"defaultuid\", \"default\");\n+    logger.info(\"Deleted Domain Custom Resource \" + \"defaultuid\");\n+  }\n+\n+  private void switchNSManagementToLabelSelectUsingUpgradeOperator(String manageByLabelNS,\n+                                                                   String manageByExpNS,\n+                                                                   String manageByLabelDomainUid,\n+                                                                   String manageByExpDomainUid) {\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(op2Namespace, \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams2)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(op2Namespace, opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(startDomain(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op2Namespace,manageByLabelDomainUid);\n+    //check operator can't manage anymore manageByExpNS\n+    assertTrue(isOperatorFailedToScaleDomain(op2Namespace, manageByExpDomainUid,\n+        manageByExpNS), \"Operator can still manage domain \"\n+        + manageByExpNS + \" in the namespace \" + manageByExpNS);\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByNSRegExp(String manageByExp1NS,\n+                                                                 String manageByExp2NS,\n+                                                                 String manageByExpDomain1Uid,\n+                                                                 String manageByExpDomain2Uid) {\n+    // install and verify operator with domainNsSelectStrategy=RegExp to manage domains with namespaces names,\n+    // starting from test\n+    opHelmParams2 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op2Namespace, \"RegExp\", \"^test\", true, domain3Namespace);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByExp1NS);\n+    assertTrue(startDomain(manageByExp1NS, manageByExpDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByExp1NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain1Uid);\n+\n+    logger.info(\"Installing and verifying domain2\");\n+    createSecrets(manageByExp2NS);\n+    assertTrue(startDomain(manageByExp2NS, manageByExpDomain2Uid),\n+        \"operator can start or verify domain in namespace \" + manageByExp2NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain2Uid);\n+  }\n+\n+\n+  private boolean startDomain(String domainNamespace, String domainUid) {\n+\n+    // create and verify the domain\n+    logger.info(\"Creating and verifying model in image domain\");\n+    try {\n+      Domain domain = createDomainCRD(domainNamespace, domainUid);\n+      createVerifyDomain(domainNamespace, domainUid, miiImage, domain);\n+      return true;\n+    } catch (Exception ex) {\n+      logger.info(\"Failed to createVerifyDomain \" + ex.getMessage());\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Create a model in image domain crd.\n+   */\n+  private Domain createDomainCRD(String domainNamespace, String domainUid) {\n+\n+    // construct a list of oracle.weblogic.domain.Cluster objects to be used in the domain custom resource\n+    List<Cluster> clusters = new ArrayList<>();\n+    clusters.add(new Cluster()\n+        .clusterName(clusterName)\n+        .replicas(replicaCount)\n+        .serverStartState(\"RUNNING\"));\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new oracle.weblogic.domain.AdminService()\n+                    .addChannelsItem(new oracle.weblogic.domain.Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))))\n+            .clusters(clusters)\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(WLS_DOMAIN_TYPE)\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+    return domain;\n+  }\n+\n+  private static void createSecrets(String domainNamespace) {\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Creating docker registry secret in namespace {0}\", domainNamespace);\n+    if (!domainNamespace.equals(\"default\")) {\n+      createDockerRegistrySecret(domainNamespace);\n+    }\n+\n+    // create secret for admin credentials\n+    logger.info(\"Creating secret for admin credentials\");\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Creating encryption secret\");\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \"weblogicenc\", \"weblogicenc\");\n+  }\n+\n+  private static void deleteSecrets(String domainNamespace) {\n+    logger.info(\"Deleting docker registry secret in namespace {0}\", domainNamespace);\n+    if (!domainNamespace.equals(\"default\")) {\n+      deleteSecret(OCR_SECRET_NAME, domainNamespace);\n+    }\n+\n+    // delete secret for admin credentials\n+    logger.info(\"Deleting secret for admin credentials\");\n+    deleteSecret(adminSecretName, domainNamespace);\n+\n+    // delete encryption secret\n+    logger.info(\"Deleting encryption secret\");\n+    deleteSecret(encryptionSecretName, domainNamespace);\n+  }\n+\n+  private void createVerifyDomain(String domainNamespace, String domainUid, String miiImage, Domain domain) {\n+    // create domain\n+    logger.info(\"Creating model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainAndVerify(domain, domainNamespace);\n+    String adminServerPodName = domainUid + adminServerPrefix;\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check for managed server pods existence in the domain namespace\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = domainUid + managedServerPrefix + i;\n+\n+      // check that the managed server pod exists\n+      logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  /**\n+   * Install WebLogic operator and wait up to two minutes until the operator pod is ready.\n+   *\n+   * @param operNamespace the operator namespace in which the operator will be installed\n+   * @param opReleaseName the operator release name\n+   * @param enableClusterRoleBinding operator cluster role binding\n+   * @param domainNamespace the list of the domain namespaces which will be managed by the operator\n+   * @return the operator Helm installation parameters\n+   */\n+  private static HelmParams installOperatorHelmChart(String opReleaseName, String operNamespace,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3"}, "originalPosition": 692}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyMTg0NQ==", "bodyText": "domainNsSelectionStrategy is not used", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r499821845", "createdAt": "2020-10-05T19:27:29Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace domain3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domain1Namespace;\n+    String manageByExp2NS = \"test-\" +  domain2Namespace;\n+    String manageByExpDomain1Uid = \"test-\" + domain1Uid;\n+    String manageByExpDomain2Uid = \"test-\" + domain2Uid;\n+    String manageByLabelNS = \"weblogic1\" + domain1Namespace;\n+    String manageByLabelDomainUid = \"weblogic1\" + domain1Uid;\n+    String domain3NS = \"atest-\" +  domain1Namespace;\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(domain3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3Namespace);\n+    checkDomainNotStartedInDefaultNS(\"RegExp\");\n+    //verify that operator can't start domain if namespace does not start from test\n+    createSecrets(domain3NS);\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domain1Namespace;\n+    String manageByLabelDomain2NS = domain2Namespace;\n+    String manageByExpDomainUid = \"weblogic2\" + domain2Namespace;\n+    String manageByExpDomainNS = \"weblogic2\" + domain2Namespace;\n+    String manageByLabelDomain1Uid = domain1Uid;\n+    String manageByLabelDomain2Uid = domain2Uid;\n+    installAndVerifyOperatorCanManageDomainByLabelSelector(manageByLabelDomain1NS, manageByLabelDomain2NS,\n+        manageByLabelDomain1Uid, manageByLabelDomain2Uid);\n+    addExtraDomainByAddingLabelToNS(labels1, manageByLabelDomain2NS, manageByLabelDomain2Uid);\n+    checkDomainNotStartedInDefaultNS(\"SelectLabel\");\n+    checkSecondOperatorFailedToShareSameNS(manageByLabelDomain1NS);\n+    switchNSManagementToRegExpUsingUpgradeOperator(manageByLabelDomain1NS, manageByExpDomainNS,\n+        manageByLabelDomain1Uid, manageByExpDomainUid);\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domain1Namespace + \"test4\";\n+    String manageByLabelDomainUid = domain1Uid + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams4 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op4Namespace, \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(op4Namespace, \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams4);\n+\n+    assertTrue(upgradeAndVerifyOperator(op4Namespace, opParams));\n+    assertTrue(startDomain(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op4Namespace, manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespace, opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void switchNSManagementToRegExpUsingUpgradeOperator(String manageByLabelNS,\n+                                                              String manageByExpNS,\n+                                                              String manageByLabelDomainUid,\n+                                                              String manageByExpDomainUid) {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpNS);\n+    assertTrue(startDomain(manageByExpNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespace,manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespace, manageByLabelDomainUid, manageByLabelNS),\n+        \"Operator can still manage domain \"\n+        + manageByLabelDomainUid + \" in the namespace \" + manageByLabelNS);\n+  }\n+\n+  private void addExtraDomainByAddingLabelToNS(Map<String, String> labels, String domainNS, String domainUid) {\n+    deleteDomainCrd(domainNS, domainUid);\n+\n+    //switch to the label1, managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNS, labels);\n+    assertTrue(startDomain(domainNS, domainUid));\n+    checkOperatorCanScaleDomain(opNamespace, domainUid);\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {\n+    //clean up domain resources in namespace and set namespace to label , managed by operator\n+    logger.info(\"deleting domain custom resource {0}\", domainUid);\n+    assertTrue(deleteDomainCustomResource(domainUid, domainNS));\n+\n+    // wait until domain was deleted\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNS,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainDoesNotExist(domainUid, DOMAIN_VERSION, domainNS));\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByLabelSelector(String manageByLabelDomain1NS,\n+                                                                      String manageByLabelDomain2NS,\n+                                                                      String manageByLabelDomain1Uid,\n+                                                                      String manageByLabelDomain2Uid) {\n+    // install and verify operator set to manage domains based on LabelSelector strategy,\n+    // domainNamespaces set to domain4 will be ignored\n+    opHelmParams1 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        opNamespace, \"LabelSelector\",\n+        OPERATOR_RELEASE_NAME, true, manageByLabelDomain1NS);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByLabelDomain1NS);\n+    assertTrue(startDomain(manageByLabelDomain1NS, manageByLabelDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByLabelDomain1NS);\n+\n+    checkOperatorCanScaleDomain(opNamespace, manageByLabelDomain1Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain4 will not start\n+    createSecrets(domain4Namespace);\n+    checkPodNotCreated(domain4Uid + adminServerPrefix, domain4Uid, domain4Namespace);\n+\n+    //verify that domain2 in namespace with no label2 will not start\n+    createSecrets(manageByLabelDomain2NS);\n+    checkPodNotCreated(manageByLabelDomain2Uid + adminServerPrefix, manageByLabelDomain2Uid, manageByLabelDomain2NS);\n+  }\n+\n+  private boolean isOperatorFailedToScaleDomain(String opNamespace, String domainUid, String domainNamespace) {\n+    try {\n+      //check operator can't manage domainNamespace by trying to scale domain\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      String managedServerPodNamePrefix = domainUid + \"-managed-server\";\n+      String opServiceAccount = OPERATOR_RELEASE_NAME + \"-sa\";\n+      scaleAndVerifyCluster(\"cluster-1\", domainUid, domainNamespace,\n+          managedServerPodNamePrefix, 2, 1,\n+          true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+          false, \"\", \"scaleDown\", 1, \"\", \"\", null, null);\n+      return false;\n+\n+    } catch (ConditionTimeoutException ex) {\n+      logger.info(\"Received expected error \" + ex.getMessage());\n+      return true;\n+    }\n+  }\n+\n+  private static void setLabelToNamespace(String domainNS, Map<String, String> labels) {\n+    //add label to domain namespace\n+    V1Namespace namespaceObject1 = assertDoesNotThrow(() -> Kubernetes.getNamespaceAsObject(domainNS));\n+    assertNotNull(namespaceObject1, \"Can't find namespace with name \" + domainNS);\n+    namespaceObject1.getMetadata().setLabels(labels);\n+    assertDoesNotThrow(() -> Kubernetes.replaceNamespace(namespaceObject1));\n+  }\n+\n+  private void checkOperatorCanScaleDomain(String opNamespace, String domainUid) {\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    assertTrue(scaleClusterWithRestApi(domainUid, clusterName, 3,\n+        externalRestHttpsPort, opNamespace, OPERATOR_RELEASE_NAME + \"-sa\"),\n+        \"Domain \" + domainUid + \" scaling operation failed\");\n+  }\n+\n+  private void checkSecondOperatorFailedToShareSameNS(String domainNamespace) {\n+    // try to install another operator sharing same domain namespace via different domainNsSelectionStrategy\n+    try {\n+      HelmParams opHelmParams3 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+          op3Namespace, \"List\",\n+          null, true, domainNamespace);\n+      assertNull(opHelmParams3, \"Operator helm chart sharing same NS with other operator did not fail\");\n+    } catch (org.opentest4j.AssertionFailedError ex) {\n+      //expecting to fail\n+      logger.info(\"Helm installation failed as expected \" + ex.getMessage());\n+    }\n+  }\n+\n+  private void checkDomainNotStartedInDefaultNS(String domainNsSelectionStrategy) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3"}, "originalPosition": 502}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyMzU5NA==", "bodyText": "can u call this variable something else, its confusing as there is already a variable domain3Namespace", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r499823594", "createdAt": "2020-10-05T19:30:53Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace domain3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domain1Namespace;\n+    String manageByExp2NS = \"test-\" +  domain2Namespace;\n+    String manageByExpDomain1Uid = \"test-\" + domain1Uid;\n+    String manageByExpDomain2Uid = \"test-\" + domain2Uid;\n+    String manageByLabelNS = \"weblogic1\" + domain1Namespace;\n+    String manageByLabelDomainUid = \"weblogic1\" + domain1Uid;\n+    String domain3NS = \"atest-\" +  domain1Namespace;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyNjk2MA==", "bodyText": "change method name to createDomainCrAndVerifyDomainIsRunning or some such", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r499826960", "createdAt": "2020-10-05T19:37:17Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace domain3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domain1Namespace;\n+    String manageByExp2NS = \"test-\" +  domain2Namespace;\n+    String manageByExpDomain1Uid = \"test-\" + domain1Uid;\n+    String manageByExpDomain2Uid = \"test-\" + domain2Uid;\n+    String manageByLabelNS = \"weblogic1\" + domain1Namespace;\n+    String manageByLabelDomainUid = \"weblogic1\" + domain1Uid;\n+    String domain3NS = \"atest-\" +  domain1Namespace;\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(domain3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3Namespace);\n+    checkDomainNotStartedInDefaultNS(\"RegExp\");\n+    //verify that operator can't start domain if namespace does not start from test\n+    createSecrets(domain3NS);\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domain1Namespace;\n+    String manageByLabelDomain2NS = domain2Namespace;\n+    String manageByExpDomainUid = \"weblogic2\" + domain2Namespace;\n+    String manageByExpDomainNS = \"weblogic2\" + domain2Namespace;\n+    String manageByLabelDomain1Uid = domain1Uid;\n+    String manageByLabelDomain2Uid = domain2Uid;\n+    installAndVerifyOperatorCanManageDomainByLabelSelector(manageByLabelDomain1NS, manageByLabelDomain2NS,\n+        manageByLabelDomain1Uid, manageByLabelDomain2Uid);\n+    addExtraDomainByAddingLabelToNS(labels1, manageByLabelDomain2NS, manageByLabelDomain2Uid);\n+    checkDomainNotStartedInDefaultNS(\"SelectLabel\");\n+    checkSecondOperatorFailedToShareSameNS(manageByLabelDomain1NS);\n+    switchNSManagementToRegExpUsingUpgradeOperator(manageByLabelDomain1NS, manageByExpDomainNS,\n+        manageByLabelDomain1Uid, manageByExpDomainUid);\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domain1Namespace + \"test4\";\n+    String manageByLabelDomainUid = domain1Uid + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams4 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op4Namespace, \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(op4Namespace, \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams4);\n+\n+    assertTrue(upgradeAndVerifyOperator(op4Namespace, opParams));\n+    assertTrue(startDomain(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op4Namespace, manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespace, opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void switchNSManagementToRegExpUsingUpgradeOperator(String manageByLabelNS,\n+                                                              String manageByExpNS,\n+                                                              String manageByLabelDomainUid,\n+                                                              String manageByExpDomainUid) {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpNS);\n+    assertTrue(startDomain(manageByExpNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespace,manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespace, manageByLabelDomainUid, manageByLabelNS),\n+        \"Operator can still manage domain \"\n+        + manageByLabelDomainUid + \" in the namespace \" + manageByLabelNS);\n+  }\n+\n+  private void addExtraDomainByAddingLabelToNS(Map<String, String> labels, String domainNS, String domainUid) {\n+    deleteDomainCrd(domainNS, domainUid);\n+\n+    //switch to the label1, managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNS, labels);\n+    assertTrue(startDomain(domainNS, domainUid));\n+    checkOperatorCanScaleDomain(opNamespace, domainUid);\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {\n+    //clean up domain resources in namespace and set namespace to label , managed by operator\n+    logger.info(\"deleting domain custom resource {0}\", domainUid);\n+    assertTrue(deleteDomainCustomResource(domainUid, domainNS));\n+\n+    // wait until domain was deleted\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNS,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainDoesNotExist(domainUid, DOMAIN_VERSION, domainNS));\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByLabelSelector(String manageByLabelDomain1NS,\n+                                                                      String manageByLabelDomain2NS,\n+                                                                      String manageByLabelDomain1Uid,\n+                                                                      String manageByLabelDomain2Uid) {\n+    // install and verify operator set to manage domains based on LabelSelector strategy,\n+    // domainNamespaces set to domain4 will be ignored\n+    opHelmParams1 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        opNamespace, \"LabelSelector\",\n+        OPERATOR_RELEASE_NAME, true, manageByLabelDomain1NS);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByLabelDomain1NS);\n+    assertTrue(startDomain(manageByLabelDomain1NS, manageByLabelDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByLabelDomain1NS);\n+\n+    checkOperatorCanScaleDomain(opNamespace, manageByLabelDomain1Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain4 will not start\n+    createSecrets(domain4Namespace);\n+    checkPodNotCreated(domain4Uid + adminServerPrefix, domain4Uid, domain4Namespace);\n+\n+    //verify that domain2 in namespace with no label2 will not start\n+    createSecrets(manageByLabelDomain2NS);\n+    checkPodNotCreated(manageByLabelDomain2Uid + adminServerPrefix, manageByLabelDomain2Uid, manageByLabelDomain2NS);\n+  }\n+\n+  private boolean isOperatorFailedToScaleDomain(String opNamespace, String domainUid, String domainNamespace) {\n+    try {\n+      //check operator can't manage domainNamespace by trying to scale domain\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      String managedServerPodNamePrefix = domainUid + \"-managed-server\";\n+      String opServiceAccount = OPERATOR_RELEASE_NAME + \"-sa\";\n+      scaleAndVerifyCluster(\"cluster-1\", domainUid, domainNamespace,\n+          managedServerPodNamePrefix, 2, 1,\n+          true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+          false, \"\", \"scaleDown\", 1, \"\", \"\", null, null);\n+      return false;\n+\n+    } catch (ConditionTimeoutException ex) {\n+      logger.info(\"Received expected error \" + ex.getMessage());\n+      return true;\n+    }\n+  }\n+\n+  private static void setLabelToNamespace(String domainNS, Map<String, String> labels) {\n+    //add label to domain namespace\n+    V1Namespace namespaceObject1 = assertDoesNotThrow(() -> Kubernetes.getNamespaceAsObject(domainNS));\n+    assertNotNull(namespaceObject1, \"Can't find namespace with name \" + domainNS);\n+    namespaceObject1.getMetadata().setLabels(labels);\n+    assertDoesNotThrow(() -> Kubernetes.replaceNamespace(namespaceObject1));\n+  }\n+\n+  private void checkOperatorCanScaleDomain(String opNamespace, String domainUid) {\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    assertTrue(scaleClusterWithRestApi(domainUid, clusterName, 3,\n+        externalRestHttpsPort, opNamespace, OPERATOR_RELEASE_NAME + \"-sa\"),\n+        \"Domain \" + domainUid + \" scaling operation failed\");\n+  }\n+\n+  private void checkSecondOperatorFailedToShareSameNS(String domainNamespace) {\n+    // try to install another operator sharing same domain namespace via different domainNsSelectionStrategy\n+    try {\n+      HelmParams opHelmParams3 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+          op3Namespace, \"List\",\n+          null, true, domainNamespace);\n+      assertNull(opHelmParams3, \"Operator helm chart sharing same NS with other operator did not fail\");\n+    } catch (org.opentest4j.AssertionFailedError ex) {\n+      //expecting to fail\n+      logger.info(\"Helm installation failed as expected \" + ex.getMessage());\n+    }\n+  }\n+\n+  private void checkDomainNotStartedInDefaultNS(String domainNsSelectionStrategy) {\n+    //verify operator can't start domain in the default namespace when domainNsSelectionStrategy not List\n+    // and selector does not match default\n+    checkPodNotCreated(\"defaultuid\" + adminServerPrefix, \"defaultuid\", \"default\");\n+\n+    logger.info(\"Delete defaultuid custom resource in namespace {0}\", \"default\");\n+    deleteDomainCustomResource(\"defaultuid\", \"default\");\n+    logger.info(\"Deleted Domain Custom Resource \" + \"defaultuid\");\n+  }\n+\n+  private void switchNSManagementToLabelSelectUsingUpgradeOperator(String manageByLabelNS,\n+                                                                   String manageByExpNS,\n+                                                                   String manageByLabelDomainUid,\n+                                                                   String manageByExpDomainUid) {\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(op2Namespace, \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams2)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(op2Namespace, opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(startDomain(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op2Namespace,manageByLabelDomainUid);\n+    //check operator can't manage anymore manageByExpNS\n+    assertTrue(isOperatorFailedToScaleDomain(op2Namespace, manageByExpDomainUid,\n+        manageByExpNS), \"Operator can still manage domain \"\n+        + manageByExpNS + \" in the namespace \" + manageByExpNS);\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByNSRegExp(String manageByExp1NS,\n+                                                                 String manageByExp2NS,\n+                                                                 String manageByExpDomain1Uid,\n+                                                                 String manageByExpDomain2Uid) {\n+    // install and verify operator with domainNsSelectStrategy=RegExp to manage domains with namespaces names,\n+    // starting from test\n+    opHelmParams2 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op2Namespace, \"RegExp\", \"^test\", true, domain3Namespace);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByExp1NS);\n+    assertTrue(startDomain(manageByExp1NS, manageByExpDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByExp1NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain1Uid);\n+\n+    logger.info(\"Installing and verifying domain2\");\n+    createSecrets(manageByExp2NS);\n+    assertTrue(startDomain(manageByExp2NS, manageByExpDomain2Uid),\n+        \"operator can start or verify domain in namespace \" + manageByExp2NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain2Uid);\n+  }\n+\n+\n+  private boolean startDomain(String domainNamespace, String domainUid) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3"}, "originalPosition": 565}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyNzIzOQ==", "bodyText": "is catch really needed here?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r499827239", "createdAt": "2020-10-05T19:37:53Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace domain3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domain1Namespace;\n+    String manageByExp2NS = \"test-\" +  domain2Namespace;\n+    String manageByExpDomain1Uid = \"test-\" + domain1Uid;\n+    String manageByExpDomain2Uid = \"test-\" + domain2Uid;\n+    String manageByLabelNS = \"weblogic1\" + domain1Namespace;\n+    String manageByLabelDomainUid = \"weblogic1\" + domain1Uid;\n+    String domain3NS = \"atest-\" +  domain1Namespace;\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(domain3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3Namespace);\n+    checkDomainNotStartedInDefaultNS(\"RegExp\");\n+    //verify that operator can't start domain if namespace does not start from test\n+    createSecrets(domain3NS);\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domain1Namespace;\n+    String manageByLabelDomain2NS = domain2Namespace;\n+    String manageByExpDomainUid = \"weblogic2\" + domain2Namespace;\n+    String manageByExpDomainNS = \"weblogic2\" + domain2Namespace;\n+    String manageByLabelDomain1Uid = domain1Uid;\n+    String manageByLabelDomain2Uid = domain2Uid;\n+    installAndVerifyOperatorCanManageDomainByLabelSelector(manageByLabelDomain1NS, manageByLabelDomain2NS,\n+        manageByLabelDomain1Uid, manageByLabelDomain2Uid);\n+    addExtraDomainByAddingLabelToNS(labels1, manageByLabelDomain2NS, manageByLabelDomain2Uid);\n+    checkDomainNotStartedInDefaultNS(\"SelectLabel\");\n+    checkSecondOperatorFailedToShareSameNS(manageByLabelDomain1NS);\n+    switchNSManagementToRegExpUsingUpgradeOperator(manageByLabelDomain1NS, manageByExpDomainNS,\n+        manageByLabelDomain1Uid, manageByExpDomainUid);\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domain1Namespace + \"test4\";\n+    String manageByLabelDomainUid = domain1Uid + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams4 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op4Namespace, \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(op4Namespace, \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams4);\n+\n+    assertTrue(upgradeAndVerifyOperator(op4Namespace, opParams));\n+    assertTrue(startDomain(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op4Namespace, manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespace, opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void switchNSManagementToRegExpUsingUpgradeOperator(String manageByLabelNS,\n+                                                              String manageByExpNS,\n+                                                              String manageByLabelDomainUid,\n+                                                              String manageByExpDomainUid) {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpNS);\n+    assertTrue(startDomain(manageByExpNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespace,manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespace, manageByLabelDomainUid, manageByLabelNS),\n+        \"Operator can still manage domain \"\n+        + manageByLabelDomainUid + \" in the namespace \" + manageByLabelNS);\n+  }\n+\n+  private void addExtraDomainByAddingLabelToNS(Map<String, String> labels, String domainNS, String domainUid) {\n+    deleteDomainCrd(domainNS, domainUid);\n+\n+    //switch to the label1, managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNS, labels);\n+    assertTrue(startDomain(domainNS, domainUid));\n+    checkOperatorCanScaleDomain(opNamespace, domainUid);\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {\n+    //clean up domain resources in namespace and set namespace to label , managed by operator\n+    logger.info(\"deleting domain custom resource {0}\", domainUid);\n+    assertTrue(deleteDomainCustomResource(domainUid, domainNS));\n+\n+    // wait until domain was deleted\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNS,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainDoesNotExist(domainUid, DOMAIN_VERSION, domainNS));\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByLabelSelector(String manageByLabelDomain1NS,\n+                                                                      String manageByLabelDomain2NS,\n+                                                                      String manageByLabelDomain1Uid,\n+                                                                      String manageByLabelDomain2Uid) {\n+    // install and verify operator set to manage domains based on LabelSelector strategy,\n+    // domainNamespaces set to domain4 will be ignored\n+    opHelmParams1 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        opNamespace, \"LabelSelector\",\n+        OPERATOR_RELEASE_NAME, true, manageByLabelDomain1NS);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByLabelDomain1NS);\n+    assertTrue(startDomain(manageByLabelDomain1NS, manageByLabelDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByLabelDomain1NS);\n+\n+    checkOperatorCanScaleDomain(opNamespace, manageByLabelDomain1Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain4 will not start\n+    createSecrets(domain4Namespace);\n+    checkPodNotCreated(domain4Uid + adminServerPrefix, domain4Uid, domain4Namespace);\n+\n+    //verify that domain2 in namespace with no label2 will not start\n+    createSecrets(manageByLabelDomain2NS);\n+    checkPodNotCreated(manageByLabelDomain2Uid + adminServerPrefix, manageByLabelDomain2Uid, manageByLabelDomain2NS);\n+  }\n+\n+  private boolean isOperatorFailedToScaleDomain(String opNamespace, String domainUid, String domainNamespace) {\n+    try {\n+      //check operator can't manage domainNamespace by trying to scale domain\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      String managedServerPodNamePrefix = domainUid + \"-managed-server\";\n+      String opServiceAccount = OPERATOR_RELEASE_NAME + \"-sa\";\n+      scaleAndVerifyCluster(\"cluster-1\", domainUid, domainNamespace,\n+          managedServerPodNamePrefix, 2, 1,\n+          true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+          false, \"\", \"scaleDown\", 1, \"\", \"\", null, null);\n+      return false;\n+\n+    } catch (ConditionTimeoutException ex) {\n+      logger.info(\"Received expected error \" + ex.getMessage());\n+      return true;\n+    }\n+  }\n+\n+  private static void setLabelToNamespace(String domainNS, Map<String, String> labels) {\n+    //add label to domain namespace\n+    V1Namespace namespaceObject1 = assertDoesNotThrow(() -> Kubernetes.getNamespaceAsObject(domainNS));\n+    assertNotNull(namespaceObject1, \"Can't find namespace with name \" + domainNS);\n+    namespaceObject1.getMetadata().setLabels(labels);\n+    assertDoesNotThrow(() -> Kubernetes.replaceNamespace(namespaceObject1));\n+  }\n+\n+  private void checkOperatorCanScaleDomain(String opNamespace, String domainUid) {\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    assertTrue(scaleClusterWithRestApi(domainUid, clusterName, 3,\n+        externalRestHttpsPort, opNamespace, OPERATOR_RELEASE_NAME + \"-sa\"),\n+        \"Domain \" + domainUid + \" scaling operation failed\");\n+  }\n+\n+  private void checkSecondOperatorFailedToShareSameNS(String domainNamespace) {\n+    // try to install another operator sharing same domain namespace via different domainNsSelectionStrategy\n+    try {\n+      HelmParams opHelmParams3 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+          op3Namespace, \"List\",\n+          null, true, domainNamespace);\n+      assertNull(opHelmParams3, \"Operator helm chart sharing same NS with other operator did not fail\");\n+    } catch (org.opentest4j.AssertionFailedError ex) {\n+      //expecting to fail\n+      logger.info(\"Helm installation failed as expected \" + ex.getMessage());\n+    }\n+  }\n+\n+  private void checkDomainNotStartedInDefaultNS(String domainNsSelectionStrategy) {\n+    //verify operator can't start domain in the default namespace when domainNsSelectionStrategy not List\n+    // and selector does not match default\n+    checkPodNotCreated(\"defaultuid\" + adminServerPrefix, \"defaultuid\", \"default\");\n+\n+    logger.info(\"Delete defaultuid custom resource in namespace {0}\", \"default\");\n+    deleteDomainCustomResource(\"defaultuid\", \"default\");\n+    logger.info(\"Deleted Domain Custom Resource \" + \"defaultuid\");\n+  }\n+\n+  private void switchNSManagementToLabelSelectUsingUpgradeOperator(String manageByLabelNS,\n+                                                                   String manageByExpNS,\n+                                                                   String manageByLabelDomainUid,\n+                                                                   String manageByExpDomainUid) {\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(op2Namespace, \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams2)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(op2Namespace, opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(startDomain(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op2Namespace,manageByLabelDomainUid);\n+    //check operator can't manage anymore manageByExpNS\n+    assertTrue(isOperatorFailedToScaleDomain(op2Namespace, manageByExpDomainUid,\n+        manageByExpNS), \"Operator can still manage domain \"\n+        + manageByExpNS + \" in the namespace \" + manageByExpNS);\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByNSRegExp(String manageByExp1NS,\n+                                                                 String manageByExp2NS,\n+                                                                 String manageByExpDomain1Uid,\n+                                                                 String manageByExpDomain2Uid) {\n+    // install and verify operator with domainNsSelectStrategy=RegExp to manage domains with namespaces names,\n+    // starting from test\n+    opHelmParams2 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op2Namespace, \"RegExp\", \"^test\", true, domain3Namespace);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByExp1NS);\n+    assertTrue(startDomain(manageByExp1NS, manageByExpDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByExp1NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain1Uid);\n+\n+    logger.info(\"Installing and verifying domain2\");\n+    createSecrets(manageByExp2NS);\n+    assertTrue(startDomain(manageByExp2NS, manageByExpDomain2Uid),\n+        \"operator can start or verify domain in namespace \" + manageByExp2NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain2Uid);\n+  }\n+\n+\n+  private boolean startDomain(String domainNamespace, String domainUid) {\n+\n+    // create and verify the domain\n+    logger.info(\"Creating and verifying model in image domain\");\n+    try {\n+      Domain domain = createDomainCRD(domainNamespace, domainUid);\n+      createVerifyDomain(domainNamespace, domainUid, miiImage, domain);\n+      return true;\n+    } catch (Exception ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3"}, "originalPosition": 573}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyNzg2NQ==", "bodyText": "Update use case description for this step", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r499827865", "createdAt": "2020-10-05T19:39:07Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace domain3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domain1Namespace;\n+    String manageByExp2NS = \"test-\" +  domain2Namespace;\n+    String manageByExpDomain1Uid = \"test-\" + domain1Uid;\n+    String manageByExpDomain2Uid = \"test-\" + domain2Uid;\n+    String manageByLabelNS = \"weblogic1\" + domain1Namespace;\n+    String manageByLabelDomainUid = \"weblogic1\" + domain1Uid;\n+    String domain3NS = \"atest-\" +  domain1Namespace;\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(domain3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3Namespace);\n+    checkDomainNotStartedInDefaultNS(\"RegExp\");\n+    //verify that operator can't start domain if namespace does not start from test\n+    createSecrets(domain3NS);\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgzMDE2OA==", "bodyText": "this check can be moved outside of this method", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r499830168", "createdAt": "2020-10-05T19:43:47Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace domain3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domain1Namespace;\n+    String manageByExp2NS = \"test-\" +  domain2Namespace;\n+    String manageByExpDomain1Uid = \"test-\" + domain1Uid;\n+    String manageByExpDomain2Uid = \"test-\" + domain2Uid;\n+    String manageByLabelNS = \"weblogic1\" + domain1Namespace;\n+    String manageByLabelDomainUid = \"weblogic1\" + domain1Uid;\n+    String domain3NS = \"atest-\" +  domain1Namespace;\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(domain3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3Namespace);\n+    checkDomainNotStartedInDefaultNS(\"RegExp\");\n+    //verify that operator can't start domain if namespace does not start from test\n+    createSecrets(domain3NS);\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domain1Namespace;\n+    String manageByLabelDomain2NS = domain2Namespace;\n+    String manageByExpDomainUid = \"weblogic2\" + domain2Namespace;\n+    String manageByExpDomainNS = \"weblogic2\" + domain2Namespace;\n+    String manageByLabelDomain1Uid = domain1Uid;\n+    String manageByLabelDomain2Uid = domain2Uid;\n+    installAndVerifyOperatorCanManageDomainByLabelSelector(manageByLabelDomain1NS, manageByLabelDomain2NS,\n+        manageByLabelDomain1Uid, manageByLabelDomain2Uid);\n+    addExtraDomainByAddingLabelToNS(labels1, manageByLabelDomain2NS, manageByLabelDomain2Uid);\n+    checkDomainNotStartedInDefaultNS(\"SelectLabel\");\n+    checkSecondOperatorFailedToShareSameNS(manageByLabelDomain1NS);\n+    switchNSManagementToRegExpUsingUpgradeOperator(manageByLabelDomain1NS, manageByExpDomainNS,\n+        manageByLabelDomain1Uid, manageByExpDomainUid);\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domain1Namespace + \"test4\";\n+    String manageByLabelDomainUid = domain1Uid + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams4 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op4Namespace, \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(op4Namespace, \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams4);\n+\n+    assertTrue(upgradeAndVerifyOperator(op4Namespace, opParams));\n+    assertTrue(startDomain(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op4Namespace, manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespace, opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void switchNSManagementToRegExpUsingUpgradeOperator(String manageByLabelNS,\n+                                                              String manageByExpNS,\n+                                                              String manageByLabelDomainUid,\n+                                                              String manageByExpDomainUid) {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpNS);\n+    assertTrue(startDomain(manageByExpNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespace,manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespace, manageByLabelDomainUid, manageByLabelNS),\n+        \"Operator can still manage domain \"\n+        + manageByLabelDomainUid + \" in the namespace \" + manageByLabelNS);\n+  }\n+\n+  private void addExtraDomainByAddingLabelToNS(Map<String, String> labels, String domainNS, String domainUid) {\n+    deleteDomainCrd(domainNS, domainUid);\n+\n+    //switch to the label1, managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNS, labels);\n+    assertTrue(startDomain(domainNS, domainUid));\n+    checkOperatorCanScaleDomain(opNamespace, domainUid);\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {\n+    //clean up domain resources in namespace and set namespace to label , managed by operator\n+    logger.info(\"deleting domain custom resource {0}\", domainUid);\n+    assertTrue(deleteDomainCustomResource(domainUid, domainNS));\n+\n+    // wait until domain was deleted\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNS,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainDoesNotExist(domainUid, DOMAIN_VERSION, domainNS));\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByLabelSelector(String manageByLabelDomain1NS,\n+                                                                      String manageByLabelDomain2NS,\n+                                                                      String manageByLabelDomain1Uid,\n+                                                                      String manageByLabelDomain2Uid) {\n+    // install and verify operator set to manage domains based on LabelSelector strategy,\n+    // domainNamespaces set to domain4 will be ignored\n+    opHelmParams1 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        opNamespace, \"LabelSelector\",\n+        OPERATOR_RELEASE_NAME, true, manageByLabelDomain1NS);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByLabelDomain1NS);\n+    assertTrue(startDomain(manageByLabelDomain1NS, manageByLabelDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByLabelDomain1NS);\n+\n+    checkOperatorCanScaleDomain(opNamespace, manageByLabelDomain1Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain4 will not start\n+    createSecrets(domain4Namespace);\n+    checkPodNotCreated(domain4Uid + adminServerPrefix, domain4Uid, domain4Namespace);\n+\n+    //verify that domain2 in namespace with no label2 will not start\n+    createSecrets(manageByLabelDomain2NS);\n+    checkPodNotCreated(manageByLabelDomain2Uid + adminServerPrefix, manageByLabelDomain2Uid, manageByLabelDomain2NS);\n+  }\n+\n+  private boolean isOperatorFailedToScaleDomain(String opNamespace, String domainUid, String domainNamespace) {\n+    try {\n+      //check operator can't manage domainNamespace by trying to scale domain\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      String managedServerPodNamePrefix = domainUid + \"-managed-server\";\n+      String opServiceAccount = OPERATOR_RELEASE_NAME + \"-sa\";\n+      scaleAndVerifyCluster(\"cluster-1\", domainUid, domainNamespace,\n+          managedServerPodNamePrefix, 2, 1,\n+          true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+          false, \"\", \"scaleDown\", 1, \"\", \"\", null, null);\n+      return false;\n+\n+    } catch (ConditionTimeoutException ex) {\n+      logger.info(\"Received expected error \" + ex.getMessage());\n+      return true;\n+    }\n+  }\n+\n+  private static void setLabelToNamespace(String domainNS, Map<String, String> labels) {\n+    //add label to domain namespace\n+    V1Namespace namespaceObject1 = assertDoesNotThrow(() -> Kubernetes.getNamespaceAsObject(domainNS));\n+    assertNotNull(namespaceObject1, \"Can't find namespace with name \" + domainNS);\n+    namespaceObject1.getMetadata().setLabels(labels);\n+    assertDoesNotThrow(() -> Kubernetes.replaceNamespace(namespaceObject1));\n+  }\n+\n+  private void checkOperatorCanScaleDomain(String opNamespace, String domainUid) {\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    assertTrue(scaleClusterWithRestApi(domainUid, clusterName, 3,\n+        externalRestHttpsPort, opNamespace, OPERATOR_RELEASE_NAME + \"-sa\"),\n+        \"Domain \" + domainUid + \" scaling operation failed\");\n+  }\n+\n+  private void checkSecondOperatorFailedToShareSameNS(String domainNamespace) {\n+    // try to install another operator sharing same domain namespace via different domainNsSelectionStrategy\n+    try {\n+      HelmParams opHelmParams3 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+          op3Namespace, \"List\",\n+          null, true, domainNamespace);\n+      assertNull(opHelmParams3, \"Operator helm chart sharing same NS with other operator did not fail\");\n+    } catch (org.opentest4j.AssertionFailedError ex) {\n+      //expecting to fail\n+      logger.info(\"Helm installation failed as expected \" + ex.getMessage());\n+    }\n+  }\n+\n+  private void checkDomainNotStartedInDefaultNS(String domainNsSelectionStrategy) {\n+    //verify operator can't start domain in the default namespace when domainNsSelectionStrategy not List\n+    // and selector does not match default\n+    checkPodNotCreated(\"defaultuid\" + adminServerPrefix, \"defaultuid\", \"default\");\n+\n+    logger.info(\"Delete defaultuid custom resource in namespace {0}\", \"default\");\n+    deleteDomainCustomResource(\"defaultuid\", \"default\");\n+    logger.info(\"Deleted Domain Custom Resource \" + \"defaultuid\");\n+  }\n+\n+  private void switchNSManagementToLabelSelectUsingUpgradeOperator(String manageByLabelNS,\n+                                                                   String manageByExpNS,\n+                                                                   String manageByLabelDomainUid,\n+                                                                   String manageByExpDomainUid) {\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(op2Namespace, \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams2)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(op2Namespace, opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(startDomain(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op2Namespace,manageByLabelDomainUid);\n+    //check operator can't manage anymore manageByExpNS", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3"}, "originalPosition": 536}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a5e5b8d35657aec01673ea52353950b70bd7420", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5a5e5b8d35657aec01673ea52353950b70bd7420", "committedDate": "2020-10-05T22:52:06Z", "message": "addressed comments from review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a34bdad31d9f4be3aa6001827e0e2c4868082ed0", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a34bdad31d9f4be3aa6001827e0e2c4868082ed0", "committedDate": "2020-10-05T22:52:15Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into managens"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8094ec2c1840985cb91ad6d5881dc24b5f4bbe6", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e8094ec2c1840985cb91ad6d5881dc24b5f4bbe6", "committedDate": "2020-10-05T23:29:13Z", "message": "addressed comments from review1"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzMTI5MTI2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#pullrequestreview-503129126", "createdAt": "2020-10-06T16:05:20Z", "commit": {"oid": "e8094ec2c1840985cb91ad6d5881dc24b5f4bbe6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNjowNToyMFrOHdPNKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNjowNToyMFrOHdPNKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxOTg4Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Return Namespace object for the given name from the Kubernetes cluster as V1Namespace object..\n          \n          \n            \n               * Return Namespace object for the given name from the Kubernetes cluster as V1Namespace object.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500419882", "createdAt": "2020-10-06T16:05:20Z", "author": {"login": "sankarpn"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -813,6 +851,39 @@ public static V1NamespaceList listNamespacesAsObjects() throws ApiException {\n     return namespaceList;\n   }\n \n+  /**\n+   * Return Namespace object for the given name from the Kubernetes cluster as V1Namespace object..", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8094ec2c1840985cb91ad6d5881dc24b5f4bbe6"}, "originalPosition": 73}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2e726750020e9256617902446f7e472b92fb972", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d2e726750020e9256617902446f7e472b92fb972", "committedDate": "2020-10-06T17:25:02Z", "message": "addressed comments from review2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1586bbc49253812267c10dff605581af863931c5", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/1586bbc49253812267c10dff605581af863931c5", "committedDate": "2020-10-06T18:02:10Z", "message": "addressed comments from review3"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzMjI2OTg3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#pullrequestreview-503226987", "createdAt": "2020-10-06T18:03:55Z", "commit": {"oid": "1586bbc49253812267c10dff605581af863931c5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMzgxNTA0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#pullrequestreview-502381504", "createdAt": "2020-10-05T20:06:55Z", "commit": {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQyMDowNjo1NlrOHcr8XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxODoxMjowMlrOHdUDzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg0MjE0MA==", "bodyText": "use checkPodDoesNotExist in CommonTestUtils", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r499842140", "createdAt": "2020-10-05T20:06:56Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace domain3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domain1Namespace;\n+    String manageByExp2NS = \"test-\" +  domain2Namespace;\n+    String manageByExpDomain1Uid = \"test-\" + domain1Uid;\n+    String manageByExpDomain2Uid = \"test-\" + domain2Uid;\n+    String manageByLabelNS = \"weblogic1\" + domain1Namespace;\n+    String manageByLabelDomainUid = \"weblogic1\" + domain1Uid;\n+    String domain3NS = \"atest-\" +  domain1Namespace;\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(domain3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3Namespace);\n+    checkDomainNotStartedInDefaultNS(\"RegExp\");\n+    //verify that operator can't start domain if namespace does not start from test\n+    createSecrets(domain3NS);\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domain1Namespace;\n+    String manageByLabelDomain2NS = domain2Namespace;\n+    String manageByExpDomainUid = \"weblogic2\" + domain2Namespace;\n+    String manageByExpDomainNS = \"weblogic2\" + domain2Namespace;\n+    String manageByLabelDomain1Uid = domain1Uid;\n+    String manageByLabelDomain2Uid = domain2Uid;\n+    installAndVerifyOperatorCanManageDomainByLabelSelector(manageByLabelDomain1NS, manageByLabelDomain2NS,\n+        manageByLabelDomain1Uid, manageByLabelDomain2Uid);\n+    addExtraDomainByAddingLabelToNS(labels1, manageByLabelDomain2NS, manageByLabelDomain2Uid);\n+    checkDomainNotStartedInDefaultNS(\"SelectLabel\");\n+    checkSecondOperatorFailedToShareSameNS(manageByLabelDomain1NS);\n+    switchNSManagementToRegExpUsingUpgradeOperator(manageByLabelDomain1NS, manageByExpDomainNS,\n+        manageByLabelDomain1Uid, manageByExpDomainUid);\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domain1Namespace + \"test4\";\n+    String manageByLabelDomainUid = domain1Uid + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams4 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op4Namespace, \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(op4Namespace, \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams4);\n+\n+    assertTrue(upgradeAndVerifyOperator(op4Namespace, opParams));\n+    assertTrue(startDomain(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op4Namespace, manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespace, opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void switchNSManagementToRegExpUsingUpgradeOperator(String manageByLabelNS,\n+                                                              String manageByExpNS,\n+                                                              String manageByLabelDomainUid,\n+                                                              String manageByExpDomainUid) {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpNS);\n+    assertTrue(startDomain(manageByExpNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespace,manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespace, manageByLabelDomainUid, manageByLabelNS),\n+        \"Operator can still manage domain \"\n+        + manageByLabelDomainUid + \" in the namespace \" + manageByLabelNS);\n+  }\n+\n+  private void addExtraDomainByAddingLabelToNS(Map<String, String> labels, String domainNS, String domainUid) {\n+    deleteDomainCrd(domainNS, domainUid);\n+\n+    //switch to the label1, managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNS, labels);\n+    assertTrue(startDomain(domainNS, domainUid));\n+    checkOperatorCanScaleDomain(opNamespace, domainUid);\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {\n+    //clean up domain resources in namespace and set namespace to label , managed by operator\n+    logger.info(\"deleting domain custom resource {0}\", domainUid);\n+    assertTrue(deleteDomainCustomResource(domainUid, domainNS));\n+\n+    // wait until domain was deleted\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNS,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainDoesNotExist(domainUid, DOMAIN_VERSION, domainNS));\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByLabelSelector(String manageByLabelDomain1NS,\n+                                                                      String manageByLabelDomain2NS,\n+                                                                      String manageByLabelDomain1Uid,\n+                                                                      String manageByLabelDomain2Uid) {\n+    // install and verify operator set to manage domains based on LabelSelector strategy,\n+    // domainNamespaces set to domain4 will be ignored\n+    opHelmParams1 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        opNamespace, \"LabelSelector\",\n+        OPERATOR_RELEASE_NAME, true, manageByLabelDomain1NS);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByLabelDomain1NS);\n+    assertTrue(startDomain(manageByLabelDomain1NS, manageByLabelDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByLabelDomain1NS);\n+\n+    checkOperatorCanScaleDomain(opNamespace, manageByLabelDomain1Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain4 will not start\n+    createSecrets(domain4Namespace);\n+    checkPodNotCreated(domain4Uid + adminServerPrefix, domain4Uid, domain4Namespace);\n+\n+    //verify that domain2 in namespace with no label2 will not start\n+    createSecrets(manageByLabelDomain2NS);\n+    checkPodNotCreated(manageByLabelDomain2Uid + adminServerPrefix, manageByLabelDomain2Uid, manageByLabelDomain2NS);\n+  }\n+\n+  private boolean isOperatorFailedToScaleDomain(String opNamespace, String domainUid, String domainNamespace) {\n+    try {\n+      //check operator can't manage domainNamespace by trying to scale domain\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      String managedServerPodNamePrefix = domainUid + \"-managed-server\";\n+      String opServiceAccount = OPERATOR_RELEASE_NAME + \"-sa\";\n+      scaleAndVerifyCluster(\"cluster-1\", domainUid, domainNamespace,\n+          managedServerPodNamePrefix, 2, 1,\n+          true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+          false, \"\", \"scaleDown\", 1, \"\", \"\", null, null);\n+      return false;\n+\n+    } catch (ConditionTimeoutException ex) {\n+      logger.info(\"Received expected error \" + ex.getMessage());\n+      return true;\n+    }\n+  }\n+\n+  private static void setLabelToNamespace(String domainNS, Map<String, String> labels) {\n+    //add label to domain namespace\n+    V1Namespace namespaceObject1 = assertDoesNotThrow(() -> Kubernetes.getNamespaceAsObject(domainNS));\n+    assertNotNull(namespaceObject1, \"Can't find namespace with name \" + domainNS);\n+    namespaceObject1.getMetadata().setLabels(labels);\n+    assertDoesNotThrow(() -> Kubernetes.replaceNamespace(namespaceObject1));\n+  }\n+\n+  private void checkOperatorCanScaleDomain(String opNamespace, String domainUid) {\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    assertTrue(scaleClusterWithRestApi(domainUid, clusterName, 3,\n+        externalRestHttpsPort, opNamespace, OPERATOR_RELEASE_NAME + \"-sa\"),\n+        \"Domain \" + domainUid + \" scaling operation failed\");\n+  }\n+\n+  private void checkSecondOperatorFailedToShareSameNS(String domainNamespace) {\n+    // try to install another operator sharing same domain namespace via different domainNsSelectionStrategy\n+    try {\n+      HelmParams opHelmParams3 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+          op3Namespace, \"List\",\n+          null, true, domainNamespace);\n+      assertNull(opHelmParams3, \"Operator helm chart sharing same NS with other operator did not fail\");\n+    } catch (org.opentest4j.AssertionFailedError ex) {\n+      //expecting to fail\n+      logger.info(\"Helm installation failed as expected \" + ex.getMessage());\n+    }\n+  }\n+\n+  private void checkDomainNotStartedInDefaultNS(String domainNsSelectionStrategy) {\n+    //verify operator can't start domain in the default namespace when domainNsSelectionStrategy not List\n+    // and selector does not match default\n+    checkPodNotCreated(\"defaultuid\" + adminServerPrefix, \"defaultuid\", \"default\");\n+\n+    logger.info(\"Delete defaultuid custom resource in namespace {0}\", \"default\");\n+    deleteDomainCustomResource(\"defaultuid\", \"default\");\n+    logger.info(\"Deleted Domain Custom Resource \" + \"defaultuid\");\n+  }\n+\n+  private void switchNSManagementToLabelSelectUsingUpgradeOperator(String manageByLabelNS,\n+                                                                   String manageByExpNS,\n+                                                                   String manageByLabelDomainUid,\n+                                                                   String manageByExpDomainUid) {\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(op2Namespace, \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams2)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(op2Namespace, opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(startDomain(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op2Namespace,manageByLabelDomainUid);\n+    //check operator can't manage anymore manageByExpNS\n+    assertTrue(isOperatorFailedToScaleDomain(op2Namespace, manageByExpDomainUid,\n+        manageByExpNS), \"Operator can still manage domain \"\n+        + manageByExpNS + \" in the namespace \" + manageByExpNS);\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByNSRegExp(String manageByExp1NS,\n+                                                                 String manageByExp2NS,\n+                                                                 String manageByExpDomain1Uid,\n+                                                                 String manageByExpDomain2Uid) {\n+    // install and verify operator with domainNsSelectStrategy=RegExp to manage domains with namespaces names,\n+    // starting from test\n+    opHelmParams2 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op2Namespace, \"RegExp\", \"^test\", true, domain3Namespace);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByExp1NS);\n+    assertTrue(startDomain(manageByExp1NS, manageByExpDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByExp1NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain1Uid);\n+\n+    logger.info(\"Installing and verifying domain2\");\n+    createSecrets(manageByExp2NS);\n+    assertTrue(startDomain(manageByExp2NS, manageByExpDomain2Uid),\n+        \"operator can start or verify domain in namespace \" + manageByExp2NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain2Uid);\n+  }\n+\n+\n+  private boolean startDomain(String domainNamespace, String domainUid) {\n+\n+    // create and verify the domain\n+    logger.info(\"Creating and verifying model in image domain\");\n+    try {\n+      Domain domain = createDomainCRD(domainNamespace, domainUid);\n+      createVerifyDomain(domainNamespace, domainUid, miiImage, domain);\n+      return true;\n+    } catch (Exception ex) {\n+      logger.info(\"Failed to createVerifyDomain \" + ex.getMessage());\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Create a model in image domain crd.\n+   */\n+  private Domain createDomainCRD(String domainNamespace, String domainUid) {\n+\n+    // construct a list of oracle.weblogic.domain.Cluster objects to be used in the domain custom resource\n+    List<Cluster> clusters = new ArrayList<>();\n+    clusters.add(new Cluster()\n+        .clusterName(clusterName)\n+        .replicas(replicaCount)\n+        .serverStartState(\"RUNNING\"));\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new oracle.weblogic.domain.AdminService()\n+                    .addChannelsItem(new oracle.weblogic.domain.Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))))\n+            .clusters(clusters)\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(WLS_DOMAIN_TYPE)\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+    return domain;\n+  }\n+\n+  private static void createSecrets(String domainNamespace) {\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Creating docker registry secret in namespace {0}\", domainNamespace);\n+    if (!domainNamespace.equals(\"default\")) {\n+      createDockerRegistrySecret(domainNamespace);\n+    }\n+\n+    // create secret for admin credentials\n+    logger.info(\"Creating secret for admin credentials\");\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Creating encryption secret\");\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \"weblogicenc\", \"weblogicenc\");\n+  }\n+\n+  private static void deleteSecrets(String domainNamespace) {\n+    logger.info(\"Deleting docker registry secret in namespace {0}\", domainNamespace);\n+    if (!domainNamespace.equals(\"default\")) {\n+      deleteSecret(OCR_SECRET_NAME, domainNamespace);\n+    }\n+\n+    // delete secret for admin credentials\n+    logger.info(\"Deleting secret for admin credentials\");\n+    deleteSecret(adminSecretName, domainNamespace);\n+\n+    // delete encryption secret\n+    logger.info(\"Deleting encryption secret\");\n+    deleteSecret(encryptionSecretName, domainNamespace);\n+  }\n+\n+  private void createVerifyDomain(String domainNamespace, String domainUid, String miiImage, Domain domain) {\n+    // create domain\n+    logger.info(\"Creating model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainAndVerify(domain, domainNamespace);\n+    String adminServerPodName = domainUid + adminServerPrefix;\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check for managed server pods existence in the domain namespace\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = domainUid + managedServerPrefix + i;\n+\n+      // check that the managed server pod exists\n+      logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  /**\n+   * Install WebLogic operator and wait up to two minutes until the operator pod is ready.\n+   *\n+   * @param operNamespace the operator namespace in which the operator will be installed\n+   * @param opReleaseName the operator release name\n+   * @param enableClusterRoleBinding operator cluster role binding\n+   * @param domainNamespace the list of the domain namespaces which will be managed by the operator\n+   * @return the operator Helm installation parameters\n+   */\n+  private static HelmParams installOperatorHelmChart(String opReleaseName, String operNamespace,\n+                                                     String domainNsSelectionStrategy,\n+                                                     String domainNsSelector,\n+                                                     boolean enableClusterRoleBinding,\n+                                                     String... domainNamespace) {\n+    LoggingFacade logger = getLogger();\n+\n+    HelmParams opHelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(operNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Create a service account for the unique operNamespace\n+    logger.info(\"Creating service account\");\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(new V1ObjectMeta()\n+            .namespace(operNamespace)\n+            .name(opReleaseName + \"-sa\"))));\n+    logger.info(\"Created service account: {0}\", opReleaseName + \"-sa\");\n+\n+\n+    // get operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"operator image name can not be empty\");\n+    logger.info(\"operator image name {0}\", operatorImage);\n+\n+\n+    V1SecretList listSecrets = listSecrets(operNamespace);\n+    if (null != listSecrets) {\n+      for (V1Secret item : listSecrets.getItems()) {\n+        if (item.getMetadata().getName().equals(REPO_SECRET_NAME)) {\n+          break;\n+        }\n+      }\n+      // Create Docker registry secret in the operator namespace to pull the image from repository\n+      logger.info(\"Creating Docker registry secret in namespace {0}\", operNamespace);\n+      createDockerRegistrySecret(operNamespace);\n+    }\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // operator chart values to override\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams)\n+        .imagePullSecrets(secretNameMap)\n+        .domainNamespaces(java.util.Arrays.asList(domainNamespace))\n+        .enableClusterRoleBinding(enableClusterRoleBinding)\n+        .serviceAccount(opReleaseName + \"-sa\");\n+    if (domainNsSelectionStrategy != null) {\n+      opParams.domainNamespaceSelectionStrategy(domainNsSelectionStrategy);\n+      if (domainNsSelectionStrategy.equalsIgnoreCase(\"LabelSelector\")) {\n+        opParams.domainNamespaceLabelSelector(domainNsSelector);\n+      } else if (domainNsSelectionStrategy.equalsIgnoreCase(\"RegExp\")) {\n+        opParams.domainNamespaceRegExp(domainNsSelector);\n+      }\n+    }\n+\n+    // use default image in chart when repoUrl is set, otherwise use latest/current branch operator image\n+    if (opHelmParams.getRepoUrl() == null) {\n+      opParams.image(operatorImage);\n+    }\n+\n+    // create externalRestIdentitySecret\n+    assertTrue(createExternalRestIdentitySecret(operNamespace,\n+        DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME + operNamespace),\n+        \"failed to create external REST identity secret\");\n+    opParams\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(0)\n+        .externalRestIdentitySecret(DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME + operNamespace);\n+\n+\n+    // install operator\n+    logger.info(\"Installing operator in namespace {0}\", operNamespace);\n+\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Failed to install operator in namespace %s \", operNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", operNamespace);\n+\n+    // list Helm releases matching operator release name in operator namespace\n+    logger.info(\"Checking operator release {0} status in namespace {1}\",\n+        opReleaseName, operNamespace);\n+\n+    assertTrue(checkHelmReleaseStatus(opReleaseName, operNamespace, \"deployed\"),\n+        String.format(\"Operator release %s is not in %s status in namespace %s\",\n+            opReleaseName, \"deployed\", operNamespace));\n+    logger.info(\"Operator release {0} status is {1} in namespace {2}\",\n+        opReleaseName, \"deployed\", operNamespace);\n+\n+    // wait for the operator to be ready\n+    logger.info(\"Wait for the operator pod is ready in namespace {0}\", operNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                operNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> operatorIsReady(operNamespace),\n+            \"operatorIsReady failed with ApiException\"));\n+\n+\n+    logger.info(\"Wait for the operator external service in namespace {0}\", operNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator external service in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                operNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> operatorRestServiceRunning(operNamespace),\n+            \"operator external service is not running\"));\n+\n+    return opHelmParams;\n+  }\n+\n+  private void checkPodNotCreated(String podName, String domainUid, String domNamespace) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3"}, "originalPosition": 808}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5NTI5NA==", "bodyText": "this check is not needed, createOcirRepoSecret() takes care of that", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500495294", "createdAt": "2020-10-06T18:05:22Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonTestUtils.java", "diffHunk": "@@ -453,6 +454,133 @@ public static HelmParams installAndVerifyOperator(String opNamespace,\n     return opHelmParams;\n   }\n \n+  /**\n+   * Install WebLogic operator and wait up to two minutes until the operator pod is ready.\n+   *\n+   * @param operNamespace the operator namespace in which the operator will be installed\n+   * @param opReleaseName the operator release name\n+   * @param domainNsSelectionStrategy SelectLabel, RegExp or List\n+   * @param domainNsSelector the label or expression value to manage namespaces\n+   * @param enableClusterRoleBinding operator cluster role binding\n+   * @param domainNamespace the list of the domain namespaces which will be managed by the operator\n+   *                        (only in case of List selector)\n+   * @return the operator Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyOperator(String opReleaseName, String operNamespace,\n+                                                     String domainNsSelectionStrategy,\n+                                                     String domainNsSelector,\n+                                                     boolean enableClusterRoleBinding,\n+                                                     String... domainNamespace) {\n+\n+    HelmParams opHelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(operNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+    LoggingFacade logger = getLogger();\n+    // Create a service account for the unique operNamespace\n+    logger.info(\"Creating service account\");\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(new V1ObjectMeta()\n+            .namespace(operNamespace)\n+            .name(opReleaseName + \"-sa\"))));\n+    logger.info(\"Created service account: {0}\", opReleaseName + \"-sa\");\n+\n+\n+    // get operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"operator image name can not be empty\");\n+    logger.info(\"operator image name {0}\", operatorImage);\n+\n+\n+    V1SecretList listSecrets = oracle.weblogic.kubernetes.actions.TestActions.listSecrets(operNamespace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2e726750020e9256617902446f7e472b92fb972"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5Njg4OA==", "bodyText": "there is lot of duplicate code in this method and the existing installAndVerifyOperator() method, refactor the methods to avoid code duplication", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500496888", "createdAt": "2020-10-06T18:08:01Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonTestUtils.java", "diffHunk": "@@ -453,6 +454,133 @@ public static HelmParams installAndVerifyOperator(String opNamespace,\n     return opHelmParams;\n   }\n \n+  /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1586bbc49253812267c10dff605581af863931c5"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5NzgzMw==", "bodyText": "move this check outside of the method", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500497833", "createdAt": "2020-10-06T18:09:39Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,633 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String[] opNamespaces = new String[4];\n+\n+  // domain constants\n+  private static final String[] domainsUid = {\"managensdomain1\",\"managensdomain2\",\"managensdomain3\",\"managensdomain4\"};\n+  private static String[] domainNamespaces = new String[4];\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams[] opHelmParams = new HelmParams[3];\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    for (int i = 0; i < 4; i++) {\n+      // get a unique domain namespace\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      logger.info(\"Getting a unique namespace {0} for WebLogic domain {1}\", namespaces.get(i), i);\n+      domainNamespaces[i] = namespaces.get(i);\n+    }\n+    for (int i = 4; i < 8; i++) {\n+      // get a unique operator namespace\n+      logger.info(\"Getting a unique namespace for operator {0}\", (i - 4));\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces[(i - 4)] = namespaces.get(i);\n+    }\n+\n+    createSecrets(domainNamespaces[2]);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domainNamespaces[0], labels1);\n+    setLabelToNamespace(domainNamespaces[1], labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+    try {\n+      // Delete domain custom resource\n+      for (int i = 0; i < 4; i++) {\n+        logger.info(\"Delete domain1 custom resource in namespace {0}\", domainNamespaces[i]);\n+        deleteDomainCustomResource(domainsUid[i], domainNamespaces[i]);\n+        logger.info(\"Deleted Domain Custom Resource \" + domainsUid[i] + \" from \" + domainNamespaces[i]);\n+      }\n+      logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domainNamespaces[0]);\n+      deleteDomainCustomResource(domainsUid[0] + \"test\", \"test-\" + domainNamespaces[0]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[0] + \"test from test-\" + domainNamespaces[0]);\n+  \n+      logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(domainsUid[1] + \"test\", \"test-\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[1] + \"test from test-\" + domainNamespaces[1]);\n+  \n+      logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domainNamespaces[1]);\n+    } finally {\n+      deleteSecrets(\"default\");\n+      deleteSecrets(\"atest-\" + domainNamespaces[0]);\n+     \n+      deleteNamespace(\"atest-\" + domainNamespaces[0]);\n+      //delete operator\n+      for (HelmParams helmParam : opHelmParams) {\n+        uninstallOperator(helmParam);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= manageByExp3NS.\n+   * Deploy two custom domain resources in two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace manageByExp3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domainNamespaces[0];\n+    String manageByExp2NS = \"test-\" +  domainNamespaces[1];\n+    String manageByExpDomain1Uid = \"test-\" + domainsUid[0];\n+    String manageByExpDomain2Uid = \"test-\" + domainsUid[1];\n+    String manageByLabelNS = \"weblogic1\" + domainNamespaces[0];\n+    String manageByLabelDomainUid = \"weblogic1\" + domainsUid[0];\n+    String manageByExp3NS = \"atest-\" +  domainNamespaces[0];\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domainsUid[2] + adminServerPrefix, domainsUid[2], domainNamespaces[2]);\n+    checkDomainNotStartedInDefaultNS();\n+    //verify that operator can't start domain if namespace name does not start from test\n+    createSecrets(manageByExp3NS);\n+    checkPodNotCreated(domainsUid[2] + adminServerPrefix, domainsUid[2], manageByExp3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+    //check operator can't manage anymore manageByExp1NS\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespaces[1], manageByExpDomain1Uid,\n+        manageByExp1NS), \"Operator can still manage domain \"\n+        + manageByExp1NS + \" in the namespace \" + manageByExp1NS);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domainNamespaces[0];\n+    String manageByLabelDomain2NS = domainNamespaces[1];\n+    String manageByExpDomainUid = \"weblogic2\" + domainNamespaces[1];\n+    String manageByExpDomainNS = \"weblogic2\" + domainNamespaces[1];\n+    String manageByLabelDomain1Uid = domainsUid[0];\n+    String manageByLabelDomain2Uid = domainsUid[1];\n+    installAndVerifyOperatorCanManageDomainByLabelSelector(manageByLabelDomain1NS, manageByLabelDomain2NS,\n+        manageByLabelDomain1Uid, manageByLabelDomain2Uid);\n+    addExtraDomainByAddingLabelToNS(labels1, manageByLabelDomain2NS, manageByLabelDomain2Uid);\n+    checkDomainNotStartedInDefaultNS();\n+    checkSecondOperatorFailedToShareSameNS(manageByLabelDomain1NS);\n+    switchNSManagementToRegExpUsingUpgradeOperator(manageByLabelDomain1NS, manageByExpDomainNS,\n+        manageByLabelDomain1Uid, manageByExpDomainUid);\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domainNamespaces[0] + \"test4\";\n+    String manageByLabelDomainUid = domainsUid[0] + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams[2] = installAndVerifyOperator(OPERATOR_RELEASE_NAME,\n+        opNamespaces[3], \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[3], \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams[2]);\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespaces[3], opParams));\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[3], manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[0], \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams[0])\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespaces[0], opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void switchNSManagementToRegExpUsingUpgradeOperator(String manageByLabelNS,\n+                                                              String manageByExpNS,\n+                                                              String manageByLabelDomainUid,\n+                                                              String manageByExpDomainUid) {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[0], \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams[0])\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespaces[0], opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpNS);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByExpNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[0],manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespaces[0], manageByLabelDomainUid, manageByLabelNS),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1586bbc49253812267c10dff605581af863931c5"}, "originalPosition": 342}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5ODUyMg==", "bodyText": "leave blank line after this line for better code readability", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500498522", "createdAt": "2020-10-06T18:10:38Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,633 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String[] opNamespaces = new String[4];\n+\n+  // domain constants\n+  private static final String[] domainsUid = {\"managensdomain1\",\"managensdomain2\",\"managensdomain3\",\"managensdomain4\"};\n+  private static String[] domainNamespaces = new String[4];\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams[] opHelmParams = new HelmParams[3];\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    for (int i = 0; i < 4; i++) {\n+      // get a unique domain namespace\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      logger.info(\"Getting a unique namespace {0} for WebLogic domain {1}\", namespaces.get(i), i);\n+      domainNamespaces[i] = namespaces.get(i);\n+    }\n+    for (int i = 4; i < 8; i++) {\n+      // get a unique operator namespace\n+      logger.info(\"Getting a unique namespace for operator {0}\", (i - 4));\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces[(i - 4)] = namespaces.get(i);\n+    }\n+\n+    createSecrets(domainNamespaces[2]);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domainNamespaces[0], labels1);\n+    setLabelToNamespace(domainNamespaces[1], labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+    try {\n+      // Delete domain custom resource\n+      for (int i = 0; i < 4; i++) {\n+        logger.info(\"Delete domain1 custom resource in namespace {0}\", domainNamespaces[i]);\n+        deleteDomainCustomResource(domainsUid[i], domainNamespaces[i]);\n+        logger.info(\"Deleted Domain Custom Resource \" + domainsUid[i] + \" from \" + domainNamespaces[i]);\n+      }\n+      logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domainNamespaces[0]);\n+      deleteDomainCustomResource(domainsUid[0] + \"test\", \"test-\" + domainNamespaces[0]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[0] + \"test from test-\" + domainNamespaces[0]);\n+  \n+      logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(domainsUid[1] + \"test\", \"test-\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[1] + \"test from test-\" + domainNamespaces[1]);\n+  \n+      logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domainNamespaces[1]);\n+    } finally {\n+      deleteSecrets(\"default\");\n+      deleteSecrets(\"atest-\" + domainNamespaces[0]);\n+     \n+      deleteNamespace(\"atest-\" + domainNamespaces[0]);\n+      //delete operator\n+      for (HelmParams helmParam : opHelmParams) {\n+        uninstallOperator(helmParam);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= manageByExp3NS.\n+   * Deploy two custom domain resources in two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace manageByExp3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domainNamespaces[0];\n+    String manageByExp2NS = \"test-\" +  domainNamespaces[1];\n+    String manageByExpDomain1Uid = \"test-\" + domainsUid[0];\n+    String manageByExpDomain2Uid = \"test-\" + domainsUid[1];\n+    String manageByLabelNS = \"weblogic1\" + domainNamespaces[0];\n+    String manageByLabelDomainUid = \"weblogic1\" + domainsUid[0];\n+    String manageByExp3NS = \"atest-\" +  domainNamespaces[0];\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domainsUid[2] + adminServerPrefix, domainsUid[2], domainNamespaces[2]);\n+    checkDomainNotStartedInDefaultNS();\n+    //verify that operator can't start domain if namespace name does not start from test\n+    createSecrets(manageByExp3NS);\n+    checkPodNotCreated(domainsUid[2] + adminServerPrefix, domainsUid[2], manageByExp3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+    //check operator can't manage anymore manageByExp1NS\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespaces[1], manageByExpDomain1Uid,\n+        manageByExp1NS), \"Operator can still manage domain \"\n+        + manageByExp1NS + \" in the namespace \" + manageByExp1NS);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domainNamespaces[0];\n+    String manageByLabelDomain2NS = domainNamespaces[1];\n+    String manageByExpDomainUid = \"weblogic2\" + domainNamespaces[1];\n+    String manageByExpDomainNS = \"weblogic2\" + domainNamespaces[1];\n+    String manageByLabelDomain1Uid = domainsUid[0];\n+    String manageByLabelDomain2Uid = domainsUid[1];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1586bbc49253812267c10dff605581af863931c5"}, "originalPosition": 250}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5OTQwNw==", "bodyText": "failed to create domain custom resource or domain is not started in namespace", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500499407", "createdAt": "2020-10-06T18:12:02Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,633 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String[] opNamespaces = new String[4];\n+\n+  // domain constants\n+  private static final String[] domainsUid = {\"managensdomain1\",\"managensdomain2\",\"managensdomain3\",\"managensdomain4\"};\n+  private static String[] domainNamespaces = new String[4];\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams[] opHelmParams = new HelmParams[3];\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    for (int i = 0; i < 4; i++) {\n+      // get a unique domain namespace\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      logger.info(\"Getting a unique namespace {0} for WebLogic domain {1}\", namespaces.get(i), i);\n+      domainNamespaces[i] = namespaces.get(i);\n+    }\n+    for (int i = 4; i < 8; i++) {\n+      // get a unique operator namespace\n+      logger.info(\"Getting a unique namespace for operator {0}\", (i - 4));\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces[(i - 4)] = namespaces.get(i);\n+    }\n+\n+    createSecrets(domainNamespaces[2]);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domainNamespaces[0], labels1);\n+    setLabelToNamespace(domainNamespaces[1], labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+    try {\n+      // Delete domain custom resource\n+      for (int i = 0; i < 4; i++) {\n+        logger.info(\"Delete domain1 custom resource in namespace {0}\", domainNamespaces[i]);\n+        deleteDomainCustomResource(domainsUid[i], domainNamespaces[i]);\n+        logger.info(\"Deleted Domain Custom Resource \" + domainsUid[i] + \" from \" + domainNamespaces[i]);\n+      }\n+      logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domainNamespaces[0]);\n+      deleteDomainCustomResource(domainsUid[0] + \"test\", \"test-\" + domainNamespaces[0]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[0] + \"test from test-\" + domainNamespaces[0]);\n+  \n+      logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(domainsUid[1] + \"test\", \"test-\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[1] + \"test from test-\" + domainNamespaces[1]);\n+  \n+      logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domainNamespaces[1]);\n+    } finally {\n+      deleteSecrets(\"default\");\n+      deleteSecrets(\"atest-\" + domainNamespaces[0]);\n+     \n+      deleteNamespace(\"atest-\" + domainNamespaces[0]);\n+      //delete operator\n+      for (HelmParams helmParam : opHelmParams) {\n+        uninstallOperator(helmParam);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= manageByExp3NS.\n+   * Deploy two custom domain resources in two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace manageByExp3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domainNamespaces[0];\n+    String manageByExp2NS = \"test-\" +  domainNamespaces[1];\n+    String manageByExpDomain1Uid = \"test-\" + domainsUid[0];\n+    String manageByExpDomain2Uid = \"test-\" + domainsUid[1];\n+    String manageByLabelNS = \"weblogic1\" + domainNamespaces[0];\n+    String manageByLabelDomainUid = \"weblogic1\" + domainsUid[0];\n+    String manageByExp3NS = \"atest-\" +  domainNamespaces[0];\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domainsUid[2] + adminServerPrefix, domainsUid[2], domainNamespaces[2]);\n+    checkDomainNotStartedInDefaultNS();\n+    //verify that operator can't start domain if namespace name does not start from test\n+    createSecrets(manageByExp3NS);\n+    checkPodNotCreated(domainsUid[2] + adminServerPrefix, domainsUid[2], manageByExp3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+    //check operator can't manage anymore manageByExp1NS\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespaces[1], manageByExpDomain1Uid,\n+        manageByExp1NS), \"Operator can still manage domain \"\n+        + manageByExp1NS + \" in the namespace \" + manageByExp1NS);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domainNamespaces[0];\n+    String manageByLabelDomain2NS = domainNamespaces[1];\n+    String manageByExpDomainUid = \"weblogic2\" + domainNamespaces[1];\n+    String manageByExpDomainNS = \"weblogic2\" + domainNamespaces[1];\n+    String manageByLabelDomain1Uid = domainsUid[0];\n+    String manageByLabelDomain2Uid = domainsUid[1];\n+    installAndVerifyOperatorCanManageDomainByLabelSelector(manageByLabelDomain1NS, manageByLabelDomain2NS,\n+        manageByLabelDomain1Uid, manageByLabelDomain2Uid);\n+    addExtraDomainByAddingLabelToNS(labels1, manageByLabelDomain2NS, manageByLabelDomain2Uid);\n+    checkDomainNotStartedInDefaultNS();\n+    checkSecondOperatorFailedToShareSameNS(manageByLabelDomain1NS);\n+    switchNSManagementToRegExpUsingUpgradeOperator(manageByLabelDomain1NS, manageByExpDomainNS,\n+        manageByLabelDomain1Uid, manageByExpDomainUid);\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domainNamespaces[0] + \"test4\";\n+    String manageByLabelDomainUid = domainsUid[0] + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams[2] = installAndVerifyOperator(OPERATOR_RELEASE_NAME,\n+        opNamespaces[3], \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[3], \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams[2]);\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespaces[3], opParams));\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[3], manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[0], \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams[0])\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespaces[0], opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void switchNSManagementToRegExpUsingUpgradeOperator(String manageByLabelNS,\n+                                                              String manageByExpNS,\n+                                                              String manageByLabelDomainUid,\n+                                                              String manageByExpDomainUid) {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[0], \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams[0])\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespaces[0], opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpNS);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByExpNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[0],manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespaces[0], manageByLabelDomainUid, manageByLabelNS),\n+        \"Operator can still manage domain \"\n+        + manageByLabelDomainUid + \" in the namespace \" + manageByLabelNS);\n+  }\n+\n+  private void addExtraDomainByAddingLabelToNS(Map<String, String> labels, String domainNS, String domainUid) {\n+    deleteDomainCrd(domainNS, domainUid);\n+\n+    //switch to the label1, managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNS, labels);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(domainNS, domainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[0], domainUid);\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {\n+    //clean up domain resources in namespace and set namespace to label , managed by operator\n+    logger.info(\"deleting domain custom resource {0}\", domainUid);\n+    assertTrue(deleteDomainCustomResource(domainUid, domainNS));\n+\n+    // wait until domain was deleted\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNS,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainDoesNotExist(domainUid, DOMAIN_VERSION, domainNS));\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByLabelSelector(String manageByLabelDomain1NS,\n+                                                                      String manageByLabelDomain2NS,\n+                                                                      String manageByLabelDomain1Uid,\n+                                                                      String manageByLabelDomain2Uid) {\n+    // install and verify operator set to manage domains based on LabelSelector strategy,\n+    // domainNamespaces set to domain4 will be ignored\n+    opHelmParams[0] = installAndVerifyOperator(OPERATOR_RELEASE_NAME,\n+        opNamespaces[0], \"LabelSelector\",\n+        OPERATOR_RELEASE_NAME, true, manageByLabelDomain1NS);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByLabelDomain1NS);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByLabelDomain1NS, manageByLabelDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByLabelDomain1NS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1586bbc49253812267c10dff605581af863931c5"}, "originalPosition": 386}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03007f1f0bc9107972b0bb477856aae6435c3a1c", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/03007f1f0bc9107972b0bb477856aae6435c3a1c", "committedDate": "2020-10-07T15:58:54Z", "message": "addressed more comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e440194a2eaacca9c523301ec19abaffe746f117", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e440194a2eaacca9c523301ec19abaffe746f117", "committedDate": "2020-10-07T15:59:02Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into managens"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24e6cc6df8e149b5fb261a47a8525a040b78af14", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/24e6cc6df8e149b5fb261a47a8525a040b78af14", "committedDate": "2020-10-07T16:23:52Z", "message": "style"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38754c73d2b02ca1a5d55a8d09bd8d25652ff0d4", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/38754c73d2b02ca1a5d55a8d09bd8d25652ff0d4", "committedDate": "2020-10-07T17:26:23Z", "message": "removed commented out methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d2a2c89d138d506bd5a5a5c1d3894a09c55726f", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/4d2a2c89d138d506bd5a5a5c1d3894a09c55726f", "committedDate": "2020-10-07T17:50:08Z", "message": "resolve merge"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0Mzc4NjYw", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#pullrequestreview-504378660", "createdAt": "2020-10-08T01:55:02Z", "commit": {"oid": "4d2a2c89d138d506bd5a5a5c1d3894a09c55726f"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwMTo1NTowMlrOHeLUpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwMjowODo0OVrOHeLhbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQwNDgzNg==", "bodyText": "Method name MUST be  self explanatory and descriptive . Modify the method name to  testNameSpaceManageByRegularExpression()", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r501404836", "createdAt": "2020-10-08T01:55:02Z", "author": {"login": "anpanigr"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,614 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String[] opNamespaces = new String[4];\n+\n+  // domain constants\n+  private static final String[] domainsUid = {\"managensdomain1\",\"managensdomain2\",\"managensdomain3\",\"managensdomain4\"};\n+  private static String[] domainNamespaces = new String[4];\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams[] opHelmParams = new HelmParams[3];\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    for (int i = 0; i < 4; i++) {\n+      // get a unique domain namespace\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      logger.info(\"Getting a unique namespace {0} for WebLogic domain {1}\", namespaces.get(i), i);\n+      domainNamespaces[i] = namespaces.get(i);\n+    }\n+    for (int i = 4; i < 8; i++) {\n+      // get a unique operator namespace\n+      logger.info(\"Getting a unique namespace for operator {0}\", (i - 4));\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces[(i - 4)] = namespaces.get(i);\n+    }\n+\n+    createSecrets(domainNamespaces[2]);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domainNamespaces[0], labels1);\n+    setLabelToNamespace(domainNamespaces[1], labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+    try {\n+      // Delete domain custom resource\n+      for (int i = 0; i < 4; i++) {\n+        logger.info(\"Delete domain1 custom resource in namespace {0}\", domainNamespaces[i]);\n+        deleteDomainCustomResource(domainsUid[i], domainNamespaces[i]);\n+        logger.info(\"Deleted Domain Custom Resource \" + domainsUid[i] + \" from \" + domainNamespaces[i]);\n+      }\n+      logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domainNamespaces[0]);\n+      deleteDomainCustomResource(domainsUid[0] + \"test\", \"test-\" + domainNamespaces[0]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[0] + \"test from test-\" + domainNamespaces[0]);\n+  \n+      logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(domainsUid[1] + \"test\", \"test-\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[1] + \"test from test-\" + domainNamespaces[1]);\n+  \n+      logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domainNamespaces[1]);\n+    } finally {\n+      deleteSecrets(\"default\");\n+      deleteSecrets(\"atest-\" + domainNamespaces[0]);\n+     \n+      deleteNamespace(\"atest-\" + domainNamespaces[0]);\n+      //delete operator\n+      for (HelmParams helmParam : opHelmParams) {\n+        uninstallOperator(helmParam);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= manageByExp3NS.\n+   * Deploy two custom domain resources in two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace manageByExp3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d2a2c89d138d506bd5a5a5c1d3894a09c55726f"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQwNTQ2Mw==", "bodyText": "testNsManageByLabel --> testNameSpaceManagedByLabelSelector", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r501405463", "createdAt": "2020-10-08T01:57:16Z", "author": {"login": "anpanigr"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,614 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String[] opNamespaces = new String[4];\n+\n+  // domain constants\n+  private static final String[] domainsUid = {\"managensdomain1\",\"managensdomain2\",\"managensdomain3\",\"managensdomain4\"};\n+  private static String[] domainNamespaces = new String[4];\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams[] opHelmParams = new HelmParams[3];\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    for (int i = 0; i < 4; i++) {\n+      // get a unique domain namespace\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      logger.info(\"Getting a unique namespace {0} for WebLogic domain {1}\", namespaces.get(i), i);\n+      domainNamespaces[i] = namespaces.get(i);\n+    }\n+    for (int i = 4; i < 8; i++) {\n+      // get a unique operator namespace\n+      logger.info(\"Getting a unique namespace for operator {0}\", (i - 4));\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces[(i - 4)] = namespaces.get(i);\n+    }\n+\n+    createSecrets(domainNamespaces[2]);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domainNamespaces[0], labels1);\n+    setLabelToNamespace(domainNamespaces[1], labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+    try {\n+      // Delete domain custom resource\n+      for (int i = 0; i < 4; i++) {\n+        logger.info(\"Delete domain1 custom resource in namespace {0}\", domainNamespaces[i]);\n+        deleteDomainCustomResource(domainsUid[i], domainNamespaces[i]);\n+        logger.info(\"Deleted Domain Custom Resource \" + domainsUid[i] + \" from \" + domainNamespaces[i]);\n+      }\n+      logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domainNamespaces[0]);\n+      deleteDomainCustomResource(domainsUid[0] + \"test\", \"test-\" + domainNamespaces[0]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[0] + \"test from test-\" + domainNamespaces[0]);\n+  \n+      logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(domainsUid[1] + \"test\", \"test-\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[1] + \"test from test-\" + domainNamespaces[1]);\n+  \n+      logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domainNamespaces[1]);\n+    } finally {\n+      deleteSecrets(\"default\");\n+      deleteSecrets(\"atest-\" + domainNamespaces[0]);\n+     \n+      deleteNamespace(\"atest-\" + domainNamespaces[0]);\n+      //delete operator\n+      for (HelmParams helmParam : opHelmParams) {\n+        uninstallOperator(helmParam);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= manageByExp3NS.\n+   * Deploy two custom domain resources in two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace manageByExp3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domainNamespaces[0];\n+    String manageByExp2NS = \"test-\" +  domainNamespaces[1];\n+    String manageByExpDomain1Uid = \"test-\" + domainsUid[0];\n+    String manageByExpDomain2Uid = \"test-\" + domainsUid[1];\n+    String manageByExp3NS = \"atest-\" +  domainNamespaces[0];\n+\n+    Map<String,String> managedByExpDomains = new HashMap<>();\n+    managedByExpDomains.put(manageByExp1NS,manageByExpDomain1Uid);\n+    managedByExpDomains.put(manageByExp2NS,manageByExpDomain2Uid);\n+    Map<String,String> unmanagedByExpDomains = new HashMap<>();\n+    unmanagedByExpDomains.put(manageByExp3NS,manageByExp3NS);\n+    String manageByLabelNS = \"weblogic1\" + domainNamespaces[0];\n+    String manageByLabelDomainUid = \"weblogic1\" + domainsUid[0];\n+\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp3NS));\n+\n+    opHelmParams[1] = installAndVerifyOperatorCanManageDomainBySelector(managedByExpDomains,unmanagedByExpDomains,\n+        \"RegExp\",\"^test\",\n+        opNamespaces[1], null);\n+\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for default\n+    checkDomainNotStartedInDefaultNS();\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[1], \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams[1])\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespaces[1], opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[1],manageByLabelDomainUid);\n+\n+    //check operator can't manage anymore manageByExp1NS\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespaces[1], manageByExpDomain1Uid,\n+        manageByExp1NS), \"Operator can still manage domain \"\n+        + manageByExp1NS + \" in the namespace \" + manageByExp1NS);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d2a2c89d138d506bd5a5a5c1d3894a09c55726f"}, "originalPosition": 270}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQwNTk4MQ==", "bodyText": "testSwitchRbac--> TestNameSpaceWithEnableRac", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r501405981", "createdAt": "2020-10-08T01:59:25Z", "author": {"login": "anpanigr"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,614 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String[] opNamespaces = new String[4];\n+\n+  // domain constants\n+  private static final String[] domainsUid = {\"managensdomain1\",\"managensdomain2\",\"managensdomain3\",\"managensdomain4\"};\n+  private static String[] domainNamespaces = new String[4];\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams[] opHelmParams = new HelmParams[3];\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    for (int i = 0; i < 4; i++) {\n+      // get a unique domain namespace\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      logger.info(\"Getting a unique namespace {0} for WebLogic domain {1}\", namespaces.get(i), i);\n+      domainNamespaces[i] = namespaces.get(i);\n+    }\n+    for (int i = 4; i < 8; i++) {\n+      // get a unique operator namespace\n+      logger.info(\"Getting a unique namespace for operator {0}\", (i - 4));\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces[(i - 4)] = namespaces.get(i);\n+    }\n+\n+    createSecrets(domainNamespaces[2]);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domainNamespaces[0], labels1);\n+    setLabelToNamespace(domainNamespaces[1], labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+    try {\n+      // Delete domain custom resource\n+      for (int i = 0; i < 4; i++) {\n+        logger.info(\"Delete domain1 custom resource in namespace {0}\", domainNamespaces[i]);\n+        deleteDomainCustomResource(domainsUid[i], domainNamespaces[i]);\n+        logger.info(\"Deleted Domain Custom Resource \" + domainsUid[i] + \" from \" + domainNamespaces[i]);\n+      }\n+      logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domainNamespaces[0]);\n+      deleteDomainCustomResource(domainsUid[0] + \"test\", \"test-\" + domainNamespaces[0]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[0] + \"test from test-\" + domainNamespaces[0]);\n+  \n+      logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(domainsUid[1] + \"test\", \"test-\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[1] + \"test from test-\" + domainNamespaces[1]);\n+  \n+      logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domainNamespaces[1]);\n+    } finally {\n+      deleteSecrets(\"default\");\n+      deleteSecrets(\"atest-\" + domainNamespaces[0]);\n+     \n+      deleteNamespace(\"atest-\" + domainNamespaces[0]);\n+      //delete operator\n+      for (HelmParams helmParam : opHelmParams) {\n+        uninstallOperator(helmParam);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= manageByExp3NS.\n+   * Deploy two custom domain resources in two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace manageByExp3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domainNamespaces[0];\n+    String manageByExp2NS = \"test-\" +  domainNamespaces[1];\n+    String manageByExpDomain1Uid = \"test-\" + domainsUid[0];\n+    String manageByExpDomain2Uid = \"test-\" + domainsUid[1];\n+    String manageByExp3NS = \"atest-\" +  domainNamespaces[0];\n+\n+    Map<String,String> managedByExpDomains = new HashMap<>();\n+    managedByExpDomains.put(manageByExp1NS,manageByExpDomain1Uid);\n+    managedByExpDomains.put(manageByExp2NS,manageByExpDomain2Uid);\n+    Map<String,String> unmanagedByExpDomains = new HashMap<>();\n+    unmanagedByExpDomains.put(manageByExp3NS,manageByExp3NS);\n+    String manageByLabelNS = \"weblogic1\" + domainNamespaces[0];\n+    String manageByLabelDomainUid = \"weblogic1\" + domainsUid[0];\n+\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp3NS));\n+\n+    opHelmParams[1] = installAndVerifyOperatorCanManageDomainBySelector(managedByExpDomains,unmanagedByExpDomains,\n+        \"RegExp\",\"^test\",\n+        opNamespaces[1], null);\n+\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for default\n+    checkDomainNotStartedInDefaultNS();\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[1], \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams[1])\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespaces[1], opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[1],manageByLabelDomainUid);\n+\n+    //check operator can't manage anymore manageByExp1NS\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespaces[1], manageByExpDomain1Uid,\n+        manageByExp1NS), \"Operator can still manage domain \"\n+        + manageByExp1NS + \" in the namespace \" + manageByExp1NS);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    Map<String, String> managedByLabelDomains = new HashMap<>();\n+    managedByLabelDomains.put(domainNamespaces[0], domainsUid[0]);\n+    Map<String, String> unmanagedByLabelDomains = new HashMap<>();\n+    unmanagedByLabelDomains.put(domainNamespaces[1], domainsUid[1]);\n+    opHelmParams[0] = installAndVerifyOperatorCanManageDomainBySelector(managedByLabelDomains,unmanagedByLabelDomains,\n+        \"LabelSelector\",OPERATOR_RELEASE_NAME,\n+        opNamespaces[0], domainNamespaces[3]);\n+    assertNotNull(opHelmParams[0], \"Can't install or verify operator with SelectLabel namespace management\");\n+\n+    String manageByExpDomainUid = \"weblogic2\" + domainNamespaces[1];\n+    String manageByExpDomainNS = \"weblogic2\" + domainNamespaces[1];\n+\n+\n+    //switch namespace domainsNamespaces[1] to the label1,\n+    // managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNamespaces[1], labels1);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(domainNamespaces[1], domainsUid[1]),\n+        \"Failed to create domain CRD or \"\n+        + \"verify that domain \" + domainsUid[1]\n+        + \" is running in namespace \" + domainNamespaces[1]);\n+    checkOperatorCanScaleDomain(opNamespaces[0], domainsUid[1]);\n+\n+    //check that with specific Selector default namespace is not under operator management\n+    checkDomainNotStartedInDefaultNS();\n+\n+    //check that another operator with selector=List matching domain namespace,\n+    // managed by first operator fails to install\n+    checkSecondOperatorFailedToShareSameNS(domainNamespaces[0]);\n+\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpDomainNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[0], \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams[0])\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespaces[0], opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpDomainNS);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByExpDomainNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[0],manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespaces[0], domainsUid[0], domainNamespaces[0]),\n+        \"Operator can still manage domain \"\n+            + domainsUid[0] + \" in the namespace \" + domainNamespaces[0]);\n+\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d2a2c89d138d506bd5a5a5c1d3894a09c55726f"}, "originalPosition": 340}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQwNzU3Mg==", "bodyText": "Here we are not deleting Domain CRD which is a global resource created by Operator. Actually we are deleting Domain Resource ( domain ).  Modify the method name to  deleteDomainResource()", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r501407572", "createdAt": "2020-10-08T02:06:25Z", "author": {"login": "anpanigr"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,614 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String[] opNamespaces = new String[4];\n+\n+  // domain constants\n+  private static final String[] domainsUid = {\"managensdomain1\",\"managensdomain2\",\"managensdomain3\",\"managensdomain4\"};\n+  private static String[] domainNamespaces = new String[4];\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams[] opHelmParams = new HelmParams[3];\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    for (int i = 0; i < 4; i++) {\n+      // get a unique domain namespace\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      logger.info(\"Getting a unique namespace {0} for WebLogic domain {1}\", namespaces.get(i), i);\n+      domainNamespaces[i] = namespaces.get(i);\n+    }\n+    for (int i = 4; i < 8; i++) {\n+      // get a unique operator namespace\n+      logger.info(\"Getting a unique namespace for operator {0}\", (i - 4));\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces[(i - 4)] = namespaces.get(i);\n+    }\n+\n+    createSecrets(domainNamespaces[2]);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domainNamespaces[0], labels1);\n+    setLabelToNamespace(domainNamespaces[1], labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+    try {\n+      // Delete domain custom resource\n+      for (int i = 0; i < 4; i++) {\n+        logger.info(\"Delete domain1 custom resource in namespace {0}\", domainNamespaces[i]);\n+        deleteDomainCustomResource(domainsUid[i], domainNamespaces[i]);\n+        logger.info(\"Deleted Domain Custom Resource \" + domainsUid[i] + \" from \" + domainNamespaces[i]);\n+      }\n+      logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domainNamespaces[0]);\n+      deleteDomainCustomResource(domainsUid[0] + \"test\", \"test-\" + domainNamespaces[0]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[0] + \"test from test-\" + domainNamespaces[0]);\n+  \n+      logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(domainsUid[1] + \"test\", \"test-\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[1] + \"test from test-\" + domainNamespaces[1]);\n+  \n+      logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domainNamespaces[1]);\n+    } finally {\n+      deleteSecrets(\"default\");\n+      deleteSecrets(\"atest-\" + domainNamespaces[0]);\n+     \n+      deleteNamespace(\"atest-\" + domainNamespaces[0]);\n+      //delete operator\n+      for (HelmParams helmParam : opHelmParams) {\n+        uninstallOperator(helmParam);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= manageByExp3NS.\n+   * Deploy two custom domain resources in two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace manageByExp3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domainNamespaces[0];\n+    String manageByExp2NS = \"test-\" +  domainNamespaces[1];\n+    String manageByExpDomain1Uid = \"test-\" + domainsUid[0];\n+    String manageByExpDomain2Uid = \"test-\" + domainsUid[1];\n+    String manageByExp3NS = \"atest-\" +  domainNamespaces[0];\n+\n+    Map<String,String> managedByExpDomains = new HashMap<>();\n+    managedByExpDomains.put(manageByExp1NS,manageByExpDomain1Uid);\n+    managedByExpDomains.put(manageByExp2NS,manageByExpDomain2Uid);\n+    Map<String,String> unmanagedByExpDomains = new HashMap<>();\n+    unmanagedByExpDomains.put(manageByExp3NS,manageByExp3NS);\n+    String manageByLabelNS = \"weblogic1\" + domainNamespaces[0];\n+    String manageByLabelDomainUid = \"weblogic1\" + domainsUid[0];\n+\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp3NS));\n+\n+    opHelmParams[1] = installAndVerifyOperatorCanManageDomainBySelector(managedByExpDomains,unmanagedByExpDomains,\n+        \"RegExp\",\"^test\",\n+        opNamespaces[1], null);\n+\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for default\n+    checkDomainNotStartedInDefaultNS();\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[1], \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams[1])\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespaces[1], opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[1],manageByLabelDomainUid);\n+\n+    //check operator can't manage anymore manageByExp1NS\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespaces[1], manageByExpDomain1Uid,\n+        manageByExp1NS), \"Operator can still manage domain \"\n+        + manageByExp1NS + \" in the namespace \" + manageByExp1NS);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    Map<String, String> managedByLabelDomains = new HashMap<>();\n+    managedByLabelDomains.put(domainNamespaces[0], domainsUid[0]);\n+    Map<String, String> unmanagedByLabelDomains = new HashMap<>();\n+    unmanagedByLabelDomains.put(domainNamespaces[1], domainsUid[1]);\n+    opHelmParams[0] = installAndVerifyOperatorCanManageDomainBySelector(managedByLabelDomains,unmanagedByLabelDomains,\n+        \"LabelSelector\",OPERATOR_RELEASE_NAME,\n+        opNamespaces[0], domainNamespaces[3]);\n+    assertNotNull(opHelmParams[0], \"Can't install or verify operator with SelectLabel namespace management\");\n+\n+    String manageByExpDomainUid = \"weblogic2\" + domainNamespaces[1];\n+    String manageByExpDomainNS = \"weblogic2\" + domainNamespaces[1];\n+\n+\n+    //switch namespace domainsNamespaces[1] to the label1,\n+    // managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNamespaces[1], labels1);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(domainNamespaces[1], domainsUid[1]),\n+        \"Failed to create domain CRD or \"\n+        + \"verify that domain \" + domainsUid[1]\n+        + \" is running in namespace \" + domainNamespaces[1]);\n+    checkOperatorCanScaleDomain(opNamespaces[0], domainsUid[1]);\n+\n+    //check that with specific Selector default namespace is not under operator management\n+    checkDomainNotStartedInDefaultNS();\n+\n+    //check that another operator with selector=List matching domain namespace,\n+    // managed by first operator fails to install\n+    checkSecondOperatorFailedToShareSameNS(domainNamespaces[0]);\n+\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpDomainNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[0], \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams[0])\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespaces[0], opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpDomainNS);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByExpDomainNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[0],manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespaces[0], domainsUid[0], domainNamespaces[0]),\n+        \"Operator can still manage domain \"\n+            + domainsUid[0] + \" in the namespace \" + domainNamespaces[0]);\n+\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domainNamespaces[0] + \"test4\";\n+    String manageByLabelDomainUid = domainsUid[0] + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams[2] = installAndVerifyOperator(OPERATOR_RELEASE_NAME,\n+        opNamespaces[3], \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[3], \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams[2]);\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespaces[3], opParams));\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[3], manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[0], \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams[0])\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespaces[0], opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d2a2c89d138d506bd5a5a5c1d3894a09c55726f"}, "originalPosition": 384}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQwODExMQ==", "bodyText": "Again here we are creating Domain Resource not CRD. Modify the method name to createDomainResource()", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r501408111", "createdAt": "2020-10-08T02:08:49Z", "author": {"login": "anpanigr"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,614 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String[] opNamespaces = new String[4];\n+\n+  // domain constants\n+  private static final String[] domainsUid = {\"managensdomain1\",\"managensdomain2\",\"managensdomain3\",\"managensdomain4\"};\n+  private static String[] domainNamespaces = new String[4];\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams[] opHelmParams = new HelmParams[3];\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    for (int i = 0; i < 4; i++) {\n+      // get a unique domain namespace\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      logger.info(\"Getting a unique namespace {0} for WebLogic domain {1}\", namespaces.get(i), i);\n+      domainNamespaces[i] = namespaces.get(i);\n+    }\n+    for (int i = 4; i < 8; i++) {\n+      // get a unique operator namespace\n+      logger.info(\"Getting a unique namespace for operator {0}\", (i - 4));\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces[(i - 4)] = namespaces.get(i);\n+    }\n+\n+    createSecrets(domainNamespaces[2]);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domainNamespaces[0], labels1);\n+    setLabelToNamespace(domainNamespaces[1], labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+    try {\n+      // Delete domain custom resource\n+      for (int i = 0; i < 4; i++) {\n+        logger.info(\"Delete domain1 custom resource in namespace {0}\", domainNamespaces[i]);\n+        deleteDomainCustomResource(domainsUid[i], domainNamespaces[i]);\n+        logger.info(\"Deleted Domain Custom Resource \" + domainsUid[i] + \" from \" + domainNamespaces[i]);\n+      }\n+      logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domainNamespaces[0]);\n+      deleteDomainCustomResource(domainsUid[0] + \"test\", \"test-\" + domainNamespaces[0]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[0] + \"test from test-\" + domainNamespaces[0]);\n+  \n+      logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(domainsUid[1] + \"test\", \"test-\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[1] + \"test from test-\" + domainNamespaces[1]);\n+  \n+      logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domainNamespaces[1]);\n+    } finally {\n+      deleteSecrets(\"default\");\n+      deleteSecrets(\"atest-\" + domainNamespaces[0]);\n+     \n+      deleteNamespace(\"atest-\" + domainNamespaces[0]);\n+      //delete operator\n+      for (HelmParams helmParam : opHelmParams) {\n+        uninstallOperator(helmParam);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= manageByExp3NS.\n+   * Deploy two custom domain resources in two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace manageByExp3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domainNamespaces[0];\n+    String manageByExp2NS = \"test-\" +  domainNamespaces[1];\n+    String manageByExpDomain1Uid = \"test-\" + domainsUid[0];\n+    String manageByExpDomain2Uid = \"test-\" + domainsUid[1];\n+    String manageByExp3NS = \"atest-\" +  domainNamespaces[0];\n+\n+    Map<String,String> managedByExpDomains = new HashMap<>();\n+    managedByExpDomains.put(manageByExp1NS,manageByExpDomain1Uid);\n+    managedByExpDomains.put(manageByExp2NS,manageByExpDomain2Uid);\n+    Map<String,String> unmanagedByExpDomains = new HashMap<>();\n+    unmanagedByExpDomains.put(manageByExp3NS,manageByExp3NS);\n+    String manageByLabelNS = \"weblogic1\" + domainNamespaces[0];\n+    String manageByLabelDomainUid = \"weblogic1\" + domainsUid[0];\n+\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp3NS));\n+\n+    opHelmParams[1] = installAndVerifyOperatorCanManageDomainBySelector(managedByExpDomains,unmanagedByExpDomains,\n+        \"RegExp\",\"^test\",\n+        opNamespaces[1], null);\n+\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for default\n+    checkDomainNotStartedInDefaultNS();\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[1], \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams[1])\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespaces[1], opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[1],manageByLabelDomainUid);\n+\n+    //check operator can't manage anymore manageByExp1NS\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespaces[1], manageByExpDomain1Uid,\n+        manageByExp1NS), \"Operator can still manage domain \"\n+        + manageByExp1NS + \" in the namespace \" + manageByExp1NS);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    Map<String, String> managedByLabelDomains = new HashMap<>();\n+    managedByLabelDomains.put(domainNamespaces[0], domainsUid[0]);\n+    Map<String, String> unmanagedByLabelDomains = new HashMap<>();\n+    unmanagedByLabelDomains.put(domainNamespaces[1], domainsUid[1]);\n+    opHelmParams[0] = installAndVerifyOperatorCanManageDomainBySelector(managedByLabelDomains,unmanagedByLabelDomains,\n+        \"LabelSelector\",OPERATOR_RELEASE_NAME,\n+        opNamespaces[0], domainNamespaces[3]);\n+    assertNotNull(opHelmParams[0], \"Can't install or verify operator with SelectLabel namespace management\");\n+\n+    String manageByExpDomainUid = \"weblogic2\" + domainNamespaces[1];\n+    String manageByExpDomainNS = \"weblogic2\" + domainNamespaces[1];\n+\n+\n+    //switch namespace domainsNamespaces[1] to the label1,\n+    // managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNamespaces[1], labels1);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(domainNamespaces[1], domainsUid[1]),\n+        \"Failed to create domain CRD or \"\n+        + \"verify that domain \" + domainsUid[1]\n+        + \" is running in namespace \" + domainNamespaces[1]);\n+    checkOperatorCanScaleDomain(opNamespaces[0], domainsUid[1]);\n+\n+    //check that with specific Selector default namespace is not under operator management\n+    checkDomainNotStartedInDefaultNS();\n+\n+    //check that another operator with selector=List matching domain namespace,\n+    // managed by first operator fails to install\n+    checkSecondOperatorFailedToShareSameNS(domainNamespaces[0]);\n+\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpDomainNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[0], \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams[0])\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespaces[0], opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpDomainNS);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByExpDomainNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[0],manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespaces[0], domainsUid[0], domainNamespaces[0]),\n+        \"Operator can still manage domain \"\n+            + domainsUid[0] + \" in the namespace \" + domainNamespaces[0]);\n+\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domainNamespaces[0] + \"test4\";\n+    String manageByLabelDomainUid = domainsUid[0] + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams[2] = installAndVerifyOperator(OPERATOR_RELEASE_NAME,\n+        opNamespaces[3], \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[3], \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams[2]);\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespaces[3], opParams));\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[3], manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[0], \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams[0])\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespaces[0], opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {\n+    //clean up domain resources in namespace and set namespace to label , managed by operator\n+    logger.info(\"deleting domain custom resource {0}\", domainUid);\n+    assertTrue(deleteDomainCustomResource(domainUid, domainNS));\n+\n+    // wait until domain was deleted\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNS,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainDoesNotExist(domainUid, DOMAIN_VERSION, domainNS));\n+  }\n+\n+  private HelmParams installAndVerifyOperatorCanManageDomainBySelector(Map<String,String> managedDomains,\n+                                                                       Map<String,String> unmanagedDomains,\n+                                                                       String selector, String selectorValue,\n+                                                                       String opNamespace,\n+                                                                       String domainNamespacesValue) {\n+    // install and verify operator set to manage domains based on LabelSelector strategy,\n+    // domainNamespaces value expected to be ignored\n+    HelmParams opHelmParam = installAndVerifyOperator(OPERATOR_RELEASE_NAME,\n+        opNamespace, selector,\n+        selectorValue, true, domainNamespacesValue);\n+    managedDomains.forEach((domainNS, domainUid) -> {\n+          logger.info(\"Installing and verifying domain {0} in namespace {1}\", domainUid, domainNS);\n+          createSecrets(domainNS);\n+          assertTrue(createDomainCrdAndVerifyDomainIsRunning(domainNS, domainUid),\n+              \"can't start or verify domain in namespace \" + domainNS);\n+\n+          checkOperatorCanScaleDomain(opNamespace, domainUid);\n+        }\n+    );\n+    if (domainNamespacesValue != null) {\n+      //verify that domainNamespaces field will be ignored and domain will not start\n+      createSecrets(domainNamespacesValue);\n+      checkPodNotCreated(domainNamespacesValue + adminServerPrefix, domainNamespacesValue, domainNamespacesValue);\n+    }\n+    //verify that domains in namespaces not matching selector value will not start\n+    unmanagedDomains.forEach((domainNS, domainUid) -> {\n+      createSecrets(domainNS);\n+      checkPodNotCreated(domainUid + adminServerPrefix, domainUid, domainNS);\n+      deleteDomainCrd(domainNS, domainUid);\n+    }\n+    );\n+    return opHelmParam;\n+  }\n+\n+  private boolean isOperatorFailedToScaleDomain(String opNamespace, String domainUid, String domainNamespace) {\n+    try {\n+      //check operator can't manage domainNamespace by trying to scale domain\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      String managedServerPodNamePrefix = domainUid + \"-managed-server\";\n+      String opServiceAccount = OPERATOR_RELEASE_NAME + \"-sa\";\n+      scaleAndVerifyCluster(\"cluster-1\", domainUid, domainNamespace,\n+          managedServerPodNamePrefix, 2, 1,\n+          true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+          false, \"\", \"scaleDown\", 1, \"\", \"\", null, null);\n+      return false;\n+\n+    } catch (ConditionTimeoutException ex) {\n+      logger.info(\"Received expected error \" + ex.getMessage());\n+      return true;\n+    }\n+  }\n+\n+  private static void setLabelToNamespace(String domainNS, Map<String, String> labels) {\n+    //add label to domain namespace\n+    V1Namespace namespaceObject1 = assertDoesNotThrow(() -> Kubernetes.getNamespaceAsObject(domainNS));\n+    assertNotNull(namespaceObject1, \"Can't find namespace with name \" + domainNS);\n+    namespaceObject1.getMetadata().setLabels(labels);\n+    assertDoesNotThrow(() -> Kubernetes.replaceNamespace(namespaceObject1));\n+  }\n+\n+  private void checkOperatorCanScaleDomain(String opNamespace, String domainUid) {\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    assertTrue(scaleClusterWithRestApi(domainUid, clusterName, 3,\n+        externalRestHttpsPort, opNamespace, OPERATOR_RELEASE_NAME + \"-sa\"),\n+        \"Domain \" + domainUid + \" scaling operation failed\");\n+  }\n+\n+  private void checkSecondOperatorFailedToShareSameNS(String domainNamespace) {\n+    // try to install another operator sharing same domain namespace via different domainNsSelectionStrategy\n+    HelmParams opHelmParams = new HelmParams().releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespaces[2])\n+        .chartDir(OPERATOR_CHART_DIR);\n+    try {\n+      HelmParams opHelmParams2 = installAndVerifyOperator(OPERATOR_RELEASE_NAME,\n+          opNamespaces[2], \"List\",\n+          null, true, domainNamespace);\n+      assertNull(opHelmParams2, \"Operator helm chart sharing same NS with other operator did not fail\");\n+    } catch (org.opentest4j.AssertionFailedError ex) {\n+      //expecting to fail\n+      logger.info(\"Helm installation failed as expected \" + ex.getMessage());\n+      uninstallOperator(opHelmParams);\n+    }\n+  }\n+\n+  private void checkDomainNotStartedInDefaultNS() {\n+    //verify operator can't start domain in the default namespace when domainNsSelectionStrategy not List\n+    // and selector does not match default\n+    checkPodNotCreated(\"defaultuid\" + adminServerPrefix, \"defaultuid\", \"default\");\n+\n+    logger.info(\"Delete defaultuid custom resource in namespace {0}\", \"default\");\n+    deleteDomainCustomResource(\"defaultuid\", \"default\");\n+    logger.info(\"Deleted Domain Custom Resource \" + \"defaultuid\");\n+  }\n+\n+  private boolean createDomainCrdAndVerifyDomainIsRunning(String domainNamespace, String domainUid) {\n+\n+    // create and verify the domain\n+    logger.info(\"Creating and verifying model in image domain\");\n+    Domain domain = createDomainCRD(domainNamespace, domainUid);\n+    assertDoesNotThrow(() -> createVerifyDomain(domainNamespace, domainUid, miiImage, domain));\n+    return true;\n+  }\n+\n+  /**\n+   * Create a model in image domain crd.\n+   */\n+  private Domain createDomainCRD(String domainNamespace, String domainUid) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d2a2c89d138d506bd5a5a5c1d3894a09c55726f"}, "originalPosition": 507}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb240205c8e3ec6cad3f831aeaa75fcb65258fab", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/fb240205c8e3ec6cad3f831aeaa75fcb65258fab", "committedDate": "2020-10-08T15:35:52Z", "message": "addressed review comments5"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0OTM3NDEy", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#pullrequestreview-504937412", "createdAt": "2020-10-08T16:01:42Z", "commit": {"oid": "fb240205c8e3ec6cad3f831aeaa75fcb65258fab"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0OTQ4ODY3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#pullrequestreview-504948867", "createdAt": "2020-10-08T16:14:47Z", "commit": {"oid": "fb240205c8e3ec6cad3f831aeaa75fcb65258fab"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4197, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}