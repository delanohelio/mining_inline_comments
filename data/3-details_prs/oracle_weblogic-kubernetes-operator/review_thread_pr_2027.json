{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE1MTAyNTUx", "number": 2027, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMTo1NDoyOFrOE1MR9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzoyOTozMFrOE1OUAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MjExMTg4OnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/operator/StuckPodProcessing.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMTo1NDoyOFrOHtU7jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDoxMTozOVrOHtZ0Tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI5MDg5Mw==", "bodyText": "No issue... Reminder to myself to verify if 1 is the proper default for deletionGracePeriodSeconds if not set. I had thought that it defaulted to 30 seconds.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2027#discussion_r517290893", "createdAt": "2020-11-04T11:54:28Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/StuckPodProcessing.java", "diffHunk": "@@ -0,0 +1,132 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import javax.annotation.Nonnull;\n+\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.kubernetes.operator.calls.CallResponse;\n+import oracle.kubernetes.operator.helpers.CallBuilder;\n+import oracle.kubernetes.operator.helpers.PodHelper;\n+import oracle.kubernetes.operator.steps.DefaultResponseStep;\n+import oracle.kubernetes.operator.work.NextAction;\n+import oracle.kubernetes.operator.work.Packet;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.utils.SystemClock;\n+import org.joda.time.DateTime;\n+\n+public class StuckPodProcessing {\n+\n+\n+  private final MainDelegate mainDelegate;\n+\n+  public StuckPodProcessing(MainDelegate mainDelegate) {\n+    this.mainDelegate = mainDelegate;\n+  }\n+\n+  void checkStuckPods(String namespace) {\n+    Step step = new CallBuilder()\n+          .withLabelSelectors(LabelConstants.getCreatedbyOperatorSelector())\n+          .listPodAsync(namespace, new PodListProcessing(namespace, SystemClock.now()));\n+    mainDelegate.runSteps(step);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private List<V1Pod> getStuckPodList(Packet packet) {\n+    return (List<V1Pod>) packet.computeIfAbsent(\"STUCK_PODS\", k -> new ArrayList<>());\n+  }\n+\n+  class PodListProcessing extends DefaultResponseStep<V1PodList> {\n+\n+    private final DateTime now;\n+\n+    public PodListProcessing(String namespace, DateTime dateTime) {\n+      super(new PodActionsStep(namespace));\n+      now = dateTime;\n+    }\n+\n+    @Override\n+    public NextAction onSuccess(Packet packet, CallResponse<V1PodList> callResponse) {\n+      callResponse.getResult().getItems().stream()\n+            .filter(pod -> isStuck(pod, now))\n+            .forEach(pod -> addStuckPodToPacket(packet, pod));\n+      \n+      return doContinueListOrNext(callResponse, packet);\n+    }\n+\n+    private boolean isStuck(V1Pod pod, DateTime now)  {\n+      return getExpectedDeleteTime(pod).isBefore(now);\n+    }\n+\n+    private DateTime getExpectedDeleteTime(V1Pod pod) {\n+      return getDeletionTimeStamp(pod).plusSeconds((int) getDeletionGracePeriodSeconds(pod));\n+    }\n+\n+    private long getDeletionGracePeriodSeconds(V1Pod pod) {\n+      return Optional.of(pod).map(V1Pod::getMetadata).map(V1ObjectMeta::getDeletionGracePeriodSeconds).orElse(1L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c6b2c34734f351305eab2cf27558e6c2827a116"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3MDk1OA==", "bodyText": "This is not something we set, but what Kubernetes puts into the pod when it deletes it. My assumption is that it should always be set, and I need a default value here in case it isn't, just to help decide if the pod is stuck. I don't know what it would mean for Kubernetes to fail to set the value.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2027#discussion_r517370958", "createdAt": "2020-11-04T14:11:39Z", "author": {"login": "russgold"}, "path": "operator/src/main/java/oracle/kubernetes/operator/StuckPodProcessing.java", "diffHunk": "@@ -0,0 +1,132 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import javax.annotation.Nonnull;\n+\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.kubernetes.operator.calls.CallResponse;\n+import oracle.kubernetes.operator.helpers.CallBuilder;\n+import oracle.kubernetes.operator.helpers.PodHelper;\n+import oracle.kubernetes.operator.steps.DefaultResponseStep;\n+import oracle.kubernetes.operator.work.NextAction;\n+import oracle.kubernetes.operator.work.Packet;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.utils.SystemClock;\n+import org.joda.time.DateTime;\n+\n+public class StuckPodProcessing {\n+\n+\n+  private final MainDelegate mainDelegate;\n+\n+  public StuckPodProcessing(MainDelegate mainDelegate) {\n+    this.mainDelegate = mainDelegate;\n+  }\n+\n+  void checkStuckPods(String namespace) {\n+    Step step = new CallBuilder()\n+          .withLabelSelectors(LabelConstants.getCreatedbyOperatorSelector())\n+          .listPodAsync(namespace, new PodListProcessing(namespace, SystemClock.now()));\n+    mainDelegate.runSteps(step);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private List<V1Pod> getStuckPodList(Packet packet) {\n+    return (List<V1Pod>) packet.computeIfAbsent(\"STUCK_PODS\", k -> new ArrayList<>());\n+  }\n+\n+  class PodListProcessing extends DefaultResponseStep<V1PodList> {\n+\n+    private final DateTime now;\n+\n+    public PodListProcessing(String namespace, DateTime dateTime) {\n+      super(new PodActionsStep(namespace));\n+      now = dateTime;\n+    }\n+\n+    @Override\n+    public NextAction onSuccess(Packet packet, CallResponse<V1PodList> callResponse) {\n+      callResponse.getResult().getItems().stream()\n+            .filter(pod -> isStuck(pod, now))\n+            .forEach(pod -> addStuckPodToPacket(packet, pod));\n+      \n+      return doContinueListOrNext(callResponse, packet);\n+    }\n+\n+    private boolean isStuck(V1Pod pod, DateTime now)  {\n+      return getExpectedDeleteTime(pod).isBefore(now);\n+    }\n+\n+    private DateTime getExpectedDeleteTime(V1Pod pod) {\n+      return getDeletionTimeStamp(pod).plusSeconds((int) getDeletionGracePeriodSeconds(pod));\n+    }\n+\n+    private long getDeletionGracePeriodSeconds(V1Pod pod) {\n+      return Optional.of(pod).map(V1Pod::getMetadata).map(V1ObjectMeta::getDeletionGracePeriodSeconds).orElse(1L);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI5MDg5Mw=="}, "originalCommit": {"oid": "9c6b2c34734f351305eab2cf27558e6c2827a116"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MjEzMjIxOnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/operator/StuckPodProcessing.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMjowMDoyM1rOHtVH4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMjowMDoyM1rOHtVH4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI5NDA1MA==", "bodyText": "I'd like to make sure that we've thought through and verified the concurrency here. While we don't want to depend on watches, it's very likely that the deletion of a pod will trigger our pod watcher. The pod watcher would start a make-right for the associated domain.\nThat seems right. This flow here (reading existing resources) will generate \"recheck\" make-right calls, which won't interrupt a make-right flow for the given domain that may have been started because of the watch event following the deletion.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2027#discussion_r517294050", "createdAt": "2020-11-04T12:00:23Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/StuckPodProcessing.java", "diffHunk": "@@ -0,0 +1,132 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import javax.annotation.Nonnull;\n+\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.kubernetes.operator.calls.CallResponse;\n+import oracle.kubernetes.operator.helpers.CallBuilder;\n+import oracle.kubernetes.operator.helpers.PodHelper;\n+import oracle.kubernetes.operator.steps.DefaultResponseStep;\n+import oracle.kubernetes.operator.work.NextAction;\n+import oracle.kubernetes.operator.work.Packet;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.utils.SystemClock;\n+import org.joda.time.DateTime;\n+\n+public class StuckPodProcessing {\n+\n+\n+  private final MainDelegate mainDelegate;\n+\n+  public StuckPodProcessing(MainDelegate mainDelegate) {\n+    this.mainDelegate = mainDelegate;\n+  }\n+\n+  void checkStuckPods(String namespace) {\n+    Step step = new CallBuilder()\n+          .withLabelSelectors(LabelConstants.getCreatedbyOperatorSelector())\n+          .listPodAsync(namespace, new PodListProcessing(namespace, SystemClock.now()));\n+    mainDelegate.runSteps(step);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private List<V1Pod> getStuckPodList(Packet packet) {\n+    return (List<V1Pod>) packet.computeIfAbsent(\"STUCK_PODS\", k -> new ArrayList<>());\n+  }\n+\n+  class PodListProcessing extends DefaultResponseStep<V1PodList> {\n+\n+    private final DateTime now;\n+\n+    public PodListProcessing(String namespace, DateTime dateTime) {\n+      super(new PodActionsStep(namespace));\n+      now = dateTime;\n+    }\n+\n+    @Override\n+    public NextAction onSuccess(Packet packet, CallResponse<V1PodList> callResponse) {\n+      callResponse.getResult().getItems().stream()\n+            .filter(pod -> isStuck(pod, now))\n+            .forEach(pod -> addStuckPodToPacket(packet, pod));\n+      \n+      return doContinueListOrNext(callResponse, packet);\n+    }\n+\n+    private boolean isStuck(V1Pod pod, DateTime now)  {\n+      return getExpectedDeleteTime(pod).isBefore(now);\n+    }\n+\n+    private DateTime getExpectedDeleteTime(V1Pod pod) {\n+      return getDeletionTimeStamp(pod).plusSeconds((int) getDeletionGracePeriodSeconds(pod));\n+    }\n+\n+    private long getDeletionGracePeriodSeconds(V1Pod pod) {\n+      return Optional.of(pod).map(V1Pod::getMetadata).map(V1ObjectMeta::getDeletionGracePeriodSeconds).orElse(1L);\n+    }\n+\n+    private DateTime getDeletionTimeStamp(V1Pod pod) {\n+      return Optional.of(pod).map(V1Pod::getMetadata).map(V1ObjectMeta::getDeletionTimestamp).orElse(SystemClock.now());\n+    }\n+\n+    private void addStuckPodToPacket(Packet packet, V1Pod stuckPod) {\n+      getStuckPodList(packet).add(stuckPod);\n+    }\n+  }\n+\n+  class PodActionsStep extends Step {\n+\n+    private final String namespace;\n+\n+    public PodActionsStep(String namespace) {\n+      this.namespace = namespace;\n+    }\n+\n+    @Override\n+    public NextAction apply(Packet packet) {\n+      final List<V1Pod> stuckPodList = getStuckPodList(packet);\n+      if (stuckPodList.isEmpty()) {\n+        return doNext(packet);\n+      } else {\n+        Collection<StepAndPacket> startDetails = new ArrayList<>();\n+\n+        for (V1Pod pod : stuckPodList) {\n+          startDetails.add(new StepAndPacket(createForcedDeletePodStep(pod), packet.clone()));\n+        }\n+        return doForkJoin(readExistingNamespaces(), packet, startDetails);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c6b2c34734f351305eab2cf27558e6c2827a116"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MjE1NzUwOnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/operator/StuckPodProcessing.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMjowODowN1rOHtVW5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDoxMzo1MFrOHtZ6MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI5Nzg5NA==", "bodyText": "Does the DefaultResponseStep include typical retry behavior? We still have that issue where a delete will periodically fail because Kubernetes returns a V1Status rather than a V1Pod.\nThat's actually a little scary because this code might retry and accidentally interleave with make-right code triggered by the pod watcher that has already created a new pod.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2027#discussion_r517297894", "createdAt": "2020-11-04T12:08:07Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/StuckPodProcessing.java", "diffHunk": "@@ -0,0 +1,132 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import javax.annotation.Nonnull;\n+\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.kubernetes.operator.calls.CallResponse;\n+import oracle.kubernetes.operator.helpers.CallBuilder;\n+import oracle.kubernetes.operator.helpers.PodHelper;\n+import oracle.kubernetes.operator.steps.DefaultResponseStep;\n+import oracle.kubernetes.operator.work.NextAction;\n+import oracle.kubernetes.operator.work.Packet;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.utils.SystemClock;\n+import org.joda.time.DateTime;\n+\n+public class StuckPodProcessing {\n+\n+\n+  private final MainDelegate mainDelegate;\n+\n+  public StuckPodProcessing(MainDelegate mainDelegate) {\n+    this.mainDelegate = mainDelegate;\n+  }\n+\n+  void checkStuckPods(String namespace) {\n+    Step step = new CallBuilder()\n+          .withLabelSelectors(LabelConstants.getCreatedbyOperatorSelector())\n+          .listPodAsync(namespace, new PodListProcessing(namespace, SystemClock.now()));\n+    mainDelegate.runSteps(step);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private List<V1Pod> getStuckPodList(Packet packet) {\n+    return (List<V1Pod>) packet.computeIfAbsent(\"STUCK_PODS\", k -> new ArrayList<>());\n+  }\n+\n+  class PodListProcessing extends DefaultResponseStep<V1PodList> {\n+\n+    private final DateTime now;\n+\n+    public PodListProcessing(String namespace, DateTime dateTime) {\n+      super(new PodActionsStep(namespace));\n+      now = dateTime;\n+    }\n+\n+    @Override\n+    public NextAction onSuccess(Packet packet, CallResponse<V1PodList> callResponse) {\n+      callResponse.getResult().getItems().stream()\n+            .filter(pod -> isStuck(pod, now))\n+            .forEach(pod -> addStuckPodToPacket(packet, pod));\n+      \n+      return doContinueListOrNext(callResponse, packet);\n+    }\n+\n+    private boolean isStuck(V1Pod pod, DateTime now)  {\n+      return getExpectedDeleteTime(pod).isBefore(now);\n+    }\n+\n+    private DateTime getExpectedDeleteTime(V1Pod pod) {\n+      return getDeletionTimeStamp(pod).plusSeconds((int) getDeletionGracePeriodSeconds(pod));\n+    }\n+\n+    private long getDeletionGracePeriodSeconds(V1Pod pod) {\n+      return Optional.of(pod).map(V1Pod::getMetadata).map(V1ObjectMeta::getDeletionGracePeriodSeconds).orElse(1L);\n+    }\n+\n+    private DateTime getDeletionTimeStamp(V1Pod pod) {\n+      return Optional.of(pod).map(V1Pod::getMetadata).map(V1ObjectMeta::getDeletionTimestamp).orElse(SystemClock.now());\n+    }\n+\n+    private void addStuckPodToPacket(Packet packet, V1Pod stuckPod) {\n+      getStuckPodList(packet).add(stuckPod);\n+    }\n+  }\n+\n+  class PodActionsStep extends Step {\n+\n+    private final String namespace;\n+\n+    public PodActionsStep(String namespace) {\n+      this.namespace = namespace;\n+    }\n+\n+    @Override\n+    public NextAction apply(Packet packet) {\n+      final List<V1Pod> stuckPodList = getStuckPodList(packet);\n+      if (stuckPodList.isEmpty()) {\n+        return doNext(packet);\n+      } else {\n+        Collection<StepAndPacket> startDetails = new ArrayList<>();\n+\n+        for (V1Pod pod : stuckPodList) {\n+          startDetails.add(new StepAndPacket(createForcedDeletePodStep(pod), packet.clone()));\n+        }\n+        return doForkJoin(readExistingNamespaces(), packet, startDetails);\n+      }\n+    }\n+\n+    @Nonnull\n+    private Step readExistingNamespaces() {\n+      return mainDelegate.getDomainNamespaces().readExistingResources(namespace, mainDelegate.getDomainProcessor());\n+    }\n+\n+    private Step createForcedDeletePodStep(V1Pod pod) {\n+      return new CallBuilder()\n+            .withGracePeriodSeconds(0)\n+            .deletePodAsync(getName(pod), getNamespace(pod), getDomainUid(pod), null, new DefaultResponseStep<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c6b2c34734f351305eab2cf27558e6c2827a116"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3MjQ2NQ==", "bodyText": "I was not aware of that possibility - that seems a bit scary for it to be non-determinate in its behavior. In this case, since we are not specifying a conflict step, I presume that the retry is not happening.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2027#discussion_r517372465", "createdAt": "2020-11-04T14:13:50Z", "author": {"login": "russgold"}, "path": "operator/src/main/java/oracle/kubernetes/operator/StuckPodProcessing.java", "diffHunk": "@@ -0,0 +1,132 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import javax.annotation.Nonnull;\n+\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.kubernetes.operator.calls.CallResponse;\n+import oracle.kubernetes.operator.helpers.CallBuilder;\n+import oracle.kubernetes.operator.helpers.PodHelper;\n+import oracle.kubernetes.operator.steps.DefaultResponseStep;\n+import oracle.kubernetes.operator.work.NextAction;\n+import oracle.kubernetes.operator.work.Packet;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.utils.SystemClock;\n+import org.joda.time.DateTime;\n+\n+public class StuckPodProcessing {\n+\n+\n+  private final MainDelegate mainDelegate;\n+\n+  public StuckPodProcessing(MainDelegate mainDelegate) {\n+    this.mainDelegate = mainDelegate;\n+  }\n+\n+  void checkStuckPods(String namespace) {\n+    Step step = new CallBuilder()\n+          .withLabelSelectors(LabelConstants.getCreatedbyOperatorSelector())\n+          .listPodAsync(namespace, new PodListProcessing(namespace, SystemClock.now()));\n+    mainDelegate.runSteps(step);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private List<V1Pod> getStuckPodList(Packet packet) {\n+    return (List<V1Pod>) packet.computeIfAbsent(\"STUCK_PODS\", k -> new ArrayList<>());\n+  }\n+\n+  class PodListProcessing extends DefaultResponseStep<V1PodList> {\n+\n+    private final DateTime now;\n+\n+    public PodListProcessing(String namespace, DateTime dateTime) {\n+      super(new PodActionsStep(namespace));\n+      now = dateTime;\n+    }\n+\n+    @Override\n+    public NextAction onSuccess(Packet packet, CallResponse<V1PodList> callResponse) {\n+      callResponse.getResult().getItems().stream()\n+            .filter(pod -> isStuck(pod, now))\n+            .forEach(pod -> addStuckPodToPacket(packet, pod));\n+      \n+      return doContinueListOrNext(callResponse, packet);\n+    }\n+\n+    private boolean isStuck(V1Pod pod, DateTime now)  {\n+      return getExpectedDeleteTime(pod).isBefore(now);\n+    }\n+\n+    private DateTime getExpectedDeleteTime(V1Pod pod) {\n+      return getDeletionTimeStamp(pod).plusSeconds((int) getDeletionGracePeriodSeconds(pod));\n+    }\n+\n+    private long getDeletionGracePeriodSeconds(V1Pod pod) {\n+      return Optional.of(pod).map(V1Pod::getMetadata).map(V1ObjectMeta::getDeletionGracePeriodSeconds).orElse(1L);\n+    }\n+\n+    private DateTime getDeletionTimeStamp(V1Pod pod) {\n+      return Optional.of(pod).map(V1Pod::getMetadata).map(V1ObjectMeta::getDeletionTimestamp).orElse(SystemClock.now());\n+    }\n+\n+    private void addStuckPodToPacket(Packet packet, V1Pod stuckPod) {\n+      getStuckPodList(packet).add(stuckPod);\n+    }\n+  }\n+\n+  class PodActionsStep extends Step {\n+\n+    private final String namespace;\n+\n+    public PodActionsStep(String namespace) {\n+      this.namespace = namespace;\n+    }\n+\n+    @Override\n+    public NextAction apply(Packet packet) {\n+      final List<V1Pod> stuckPodList = getStuckPodList(packet);\n+      if (stuckPodList.isEmpty()) {\n+        return doNext(packet);\n+      } else {\n+        Collection<StepAndPacket> startDetails = new ArrayList<>();\n+\n+        for (V1Pod pod : stuckPodList) {\n+          startDetails.add(new StepAndPacket(createForcedDeletePodStep(pod), packet.clone()));\n+        }\n+        return doForkJoin(readExistingNamespaces(), packet, startDetails);\n+      }\n+    }\n+\n+    @Nonnull\n+    private Step readExistingNamespaces() {\n+      return mainDelegate.getDomainNamespaces().readExistingResources(namespace, mainDelegate.getDomainProcessor());\n+    }\n+\n+    private Step createForcedDeletePodStep(V1Pod pod) {\n+      return new CallBuilder()\n+            .withGracePeriodSeconds(0)\n+            .deletePodAsync(getName(pod), getNamespace(pod), getDomainUid(pod), null, new DefaultResponseStep<>());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI5Nzg5NA=="}, "originalCommit": {"oid": "9c6b2c34734f351305eab2cf27558e6c2827a116"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MjQ0NDgxOnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/operator/StuckPodProcessing.java", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzoyOTozMFrOHtYETw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNTo1ODoxNFrOHtem7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0MjI4Nw==", "bodyText": "The stuck check potentially involves two different machine clocks that might be out of sync - the operator's and the pod's. I just did some brief research, and it looks like k8s doesn't require strict clock synchronization although it's considered desirable (in addition, WL clusters have fairly tight needs).\nShould there be an additional grace after a detecting a potentially stuck delete in order to give K8S time to 'naturally' honor its timeout and perhaps to help account for a 'small' amount of potential clock drift?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2027#discussion_r517342287", "createdAt": "2020-11-04T13:29:30Z", "author": {"login": "tbarnes-us"}, "path": "operator/src/main/java/oracle/kubernetes/operator/StuckPodProcessing.java", "diffHunk": "@@ -0,0 +1,132 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import javax.annotation.Nonnull;\n+\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.kubernetes.operator.calls.CallResponse;\n+import oracle.kubernetes.operator.helpers.CallBuilder;\n+import oracle.kubernetes.operator.helpers.PodHelper;\n+import oracle.kubernetes.operator.steps.DefaultResponseStep;\n+import oracle.kubernetes.operator.work.NextAction;\n+import oracle.kubernetes.operator.work.Packet;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.utils.SystemClock;\n+import org.joda.time.DateTime;\n+\n+public class StuckPodProcessing {\n+\n+\n+  private final MainDelegate mainDelegate;\n+\n+  public StuckPodProcessing(MainDelegate mainDelegate) {\n+    this.mainDelegate = mainDelegate;\n+  }\n+\n+  void checkStuckPods(String namespace) {\n+    Step step = new CallBuilder()\n+          .withLabelSelectors(LabelConstants.getCreatedbyOperatorSelector())\n+          .listPodAsync(namespace, new PodListProcessing(namespace, SystemClock.now()));\n+    mainDelegate.runSteps(step);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private List<V1Pod> getStuckPodList(Packet packet) {\n+    return (List<V1Pod>) packet.computeIfAbsent(\"STUCK_PODS\", k -> new ArrayList<>());\n+  }\n+\n+  class PodListProcessing extends DefaultResponseStep<V1PodList> {\n+\n+    private final DateTime now;\n+\n+    public PodListProcessing(String namespace, DateTime dateTime) {\n+      super(new PodActionsStep(namespace));\n+      now = dateTime;\n+    }\n+\n+    @Override\n+    public NextAction onSuccess(Packet packet, CallResponse<V1PodList> callResponse) {\n+      callResponse.getResult().getItems().stream()\n+            .filter(pod -> isStuck(pod, now))\n+            .forEach(pod -> addStuckPodToPacket(packet, pod));\n+      \n+      return doContinueListOrNext(callResponse, packet);\n+    }\n+\n+    private boolean isStuck(V1Pod pod, DateTime now)  {\n+      return getExpectedDeleteTime(pod).isBefore(now);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c6b2c34734f351305eab2cf27558e6c2827a116"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3MzAzMw==", "bodyText": "That seems a reasonable precaution - how much drift should we be concerned about?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2027#discussion_r517373033", "createdAt": "2020-11-04T14:14:35Z", "author": {"login": "russgold"}, "path": "operator/src/main/java/oracle/kubernetes/operator/StuckPodProcessing.java", "diffHunk": "@@ -0,0 +1,132 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import javax.annotation.Nonnull;\n+\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.kubernetes.operator.calls.CallResponse;\n+import oracle.kubernetes.operator.helpers.CallBuilder;\n+import oracle.kubernetes.operator.helpers.PodHelper;\n+import oracle.kubernetes.operator.steps.DefaultResponseStep;\n+import oracle.kubernetes.operator.work.NextAction;\n+import oracle.kubernetes.operator.work.Packet;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.utils.SystemClock;\n+import org.joda.time.DateTime;\n+\n+public class StuckPodProcessing {\n+\n+\n+  private final MainDelegate mainDelegate;\n+\n+  public StuckPodProcessing(MainDelegate mainDelegate) {\n+    this.mainDelegate = mainDelegate;\n+  }\n+\n+  void checkStuckPods(String namespace) {\n+    Step step = new CallBuilder()\n+          .withLabelSelectors(LabelConstants.getCreatedbyOperatorSelector())\n+          .listPodAsync(namespace, new PodListProcessing(namespace, SystemClock.now()));\n+    mainDelegate.runSteps(step);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private List<V1Pod> getStuckPodList(Packet packet) {\n+    return (List<V1Pod>) packet.computeIfAbsent(\"STUCK_PODS\", k -> new ArrayList<>());\n+  }\n+\n+  class PodListProcessing extends DefaultResponseStep<V1PodList> {\n+\n+    private final DateTime now;\n+\n+    public PodListProcessing(String namespace, DateTime dateTime) {\n+      super(new PodActionsStep(namespace));\n+      now = dateTime;\n+    }\n+\n+    @Override\n+    public NextAction onSuccess(Packet packet, CallResponse<V1PodList> callResponse) {\n+      callResponse.getResult().getItems().stream()\n+            .filter(pod -> isStuck(pod, now))\n+            .forEach(pod -> addStuckPodToPacket(packet, pod));\n+      \n+      return doContinueListOrNext(callResponse, packet);\n+    }\n+\n+    private boolean isStuck(V1Pod pod, DateTime now)  {\n+      return getExpectedDeleteTime(pod).isBefore(now);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0MjI4Nw=="}, "originalCommit": {"oid": "9c6b2c34734f351305eab2cf27558e6c2827a116"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQwNzM5MA==", "bodyText": "Tough question. Off the top my head, maybe account for a few seconds of drift -- I've seen much worse on occasion, but, in general, WL clusters themselves dislike a drift any higher than that in my experience.   Plus perhaps account for a few extra seconds to give k8s time to handle the delete 'naturally'.  So that would total 10 seconds? And perhaps have an associated configurable?\n@rjeberhard Thoughts?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2027#discussion_r517407390", "createdAt": "2020-11-04T15:00:55Z", "author": {"login": "tbarnes-us"}, "path": "operator/src/main/java/oracle/kubernetes/operator/StuckPodProcessing.java", "diffHunk": "@@ -0,0 +1,132 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import javax.annotation.Nonnull;\n+\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.kubernetes.operator.calls.CallResponse;\n+import oracle.kubernetes.operator.helpers.CallBuilder;\n+import oracle.kubernetes.operator.helpers.PodHelper;\n+import oracle.kubernetes.operator.steps.DefaultResponseStep;\n+import oracle.kubernetes.operator.work.NextAction;\n+import oracle.kubernetes.operator.work.Packet;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.utils.SystemClock;\n+import org.joda.time.DateTime;\n+\n+public class StuckPodProcessing {\n+\n+\n+  private final MainDelegate mainDelegate;\n+\n+  public StuckPodProcessing(MainDelegate mainDelegate) {\n+    this.mainDelegate = mainDelegate;\n+  }\n+\n+  void checkStuckPods(String namespace) {\n+    Step step = new CallBuilder()\n+          .withLabelSelectors(LabelConstants.getCreatedbyOperatorSelector())\n+          .listPodAsync(namespace, new PodListProcessing(namespace, SystemClock.now()));\n+    mainDelegate.runSteps(step);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private List<V1Pod> getStuckPodList(Packet packet) {\n+    return (List<V1Pod>) packet.computeIfAbsent(\"STUCK_PODS\", k -> new ArrayList<>());\n+  }\n+\n+  class PodListProcessing extends DefaultResponseStep<V1PodList> {\n+\n+    private final DateTime now;\n+\n+    public PodListProcessing(String namespace, DateTime dateTime) {\n+      super(new PodActionsStep(namespace));\n+      now = dateTime;\n+    }\n+\n+    @Override\n+    public NextAction onSuccess(Packet packet, CallResponse<V1PodList> callResponse) {\n+      callResponse.getResult().getItems().stream()\n+            .filter(pod -> isStuck(pod, now))\n+            .forEach(pod -> addStuckPodToPacket(packet, pod));\n+      \n+      return doContinueListOrNext(callResponse, packet);\n+    }\n+\n+    private boolean isStuck(V1Pod pod, DateTime now)  {\n+      return getExpectedDeleteTime(pod).isBefore(now);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0MjI4Nw=="}, "originalCommit": {"oid": "9c6b2c34734f351305eab2cf27558e6c2827a116"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQyNzE2NA==", "bodyText": "I keep any accounting for drift very small; perhaps just 1 or 2 seconds. It's subjective, but when I tested the solution it still \"felt\" like I waited a long time before the terminated pod was removed.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2027#discussion_r517427164", "createdAt": "2020-11-04T15:28:15Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/StuckPodProcessing.java", "diffHunk": "@@ -0,0 +1,132 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import javax.annotation.Nonnull;\n+\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.kubernetes.operator.calls.CallResponse;\n+import oracle.kubernetes.operator.helpers.CallBuilder;\n+import oracle.kubernetes.operator.helpers.PodHelper;\n+import oracle.kubernetes.operator.steps.DefaultResponseStep;\n+import oracle.kubernetes.operator.work.NextAction;\n+import oracle.kubernetes.operator.work.Packet;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.utils.SystemClock;\n+import org.joda.time.DateTime;\n+\n+public class StuckPodProcessing {\n+\n+\n+  private final MainDelegate mainDelegate;\n+\n+  public StuckPodProcessing(MainDelegate mainDelegate) {\n+    this.mainDelegate = mainDelegate;\n+  }\n+\n+  void checkStuckPods(String namespace) {\n+    Step step = new CallBuilder()\n+          .withLabelSelectors(LabelConstants.getCreatedbyOperatorSelector())\n+          .listPodAsync(namespace, new PodListProcessing(namespace, SystemClock.now()));\n+    mainDelegate.runSteps(step);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private List<V1Pod> getStuckPodList(Packet packet) {\n+    return (List<V1Pod>) packet.computeIfAbsent(\"STUCK_PODS\", k -> new ArrayList<>());\n+  }\n+\n+  class PodListProcessing extends DefaultResponseStep<V1PodList> {\n+\n+    private final DateTime now;\n+\n+    public PodListProcessing(String namespace, DateTime dateTime) {\n+      super(new PodActionsStep(namespace));\n+      now = dateTime;\n+    }\n+\n+    @Override\n+    public NextAction onSuccess(Packet packet, CallResponse<V1PodList> callResponse) {\n+      callResponse.getResult().getItems().stream()\n+            .filter(pod -> isStuck(pod, now))\n+            .forEach(pod -> addStuckPodToPacket(packet, pod));\n+      \n+      return doContinueListOrNext(callResponse, packet);\n+    }\n+\n+    private boolean isStuck(V1Pod pod, DateTime now)  {\n+      return getExpectedDeleteTime(pod).isBefore(now);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0MjI4Nw=="}, "originalCommit": {"oid": "9c6b2c34734f351305eab2cf27558e6c2827a116"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ0MzU1MQ==", "bodyText": "Actually, what's the harm? If we delete a pod that is going to be deleted anyway, it should still be fine, right?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2027#discussion_r517443551", "createdAt": "2020-11-04T15:50:17Z", "author": {"login": "russgold"}, "path": "operator/src/main/java/oracle/kubernetes/operator/StuckPodProcessing.java", "diffHunk": "@@ -0,0 +1,132 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import javax.annotation.Nonnull;\n+\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.kubernetes.operator.calls.CallResponse;\n+import oracle.kubernetes.operator.helpers.CallBuilder;\n+import oracle.kubernetes.operator.helpers.PodHelper;\n+import oracle.kubernetes.operator.steps.DefaultResponseStep;\n+import oracle.kubernetes.operator.work.NextAction;\n+import oracle.kubernetes.operator.work.Packet;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.utils.SystemClock;\n+import org.joda.time.DateTime;\n+\n+public class StuckPodProcessing {\n+\n+\n+  private final MainDelegate mainDelegate;\n+\n+  public StuckPodProcessing(MainDelegate mainDelegate) {\n+    this.mainDelegate = mainDelegate;\n+  }\n+\n+  void checkStuckPods(String namespace) {\n+    Step step = new CallBuilder()\n+          .withLabelSelectors(LabelConstants.getCreatedbyOperatorSelector())\n+          .listPodAsync(namespace, new PodListProcessing(namespace, SystemClock.now()));\n+    mainDelegate.runSteps(step);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private List<V1Pod> getStuckPodList(Packet packet) {\n+    return (List<V1Pod>) packet.computeIfAbsent(\"STUCK_PODS\", k -> new ArrayList<>());\n+  }\n+\n+  class PodListProcessing extends DefaultResponseStep<V1PodList> {\n+\n+    private final DateTime now;\n+\n+    public PodListProcessing(String namespace, DateTime dateTime) {\n+      super(new PodActionsStep(namespace));\n+      now = dateTime;\n+    }\n+\n+    @Override\n+    public NextAction onSuccess(Packet packet, CallResponse<V1PodList> callResponse) {\n+      callResponse.getResult().getItems().stream()\n+            .filter(pod -> isStuck(pod, now))\n+            .forEach(pod -> addStuckPodToPacket(packet, pod));\n+      \n+      return doContinueListOrNext(callResponse, packet);\n+    }\n+\n+    private boolean isStuck(V1Pod pod, DateTime now)  {\n+      return getExpectedDeleteTime(pod).isBefore(now);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0MjI4Nw=="}, "originalCommit": {"oid": "9c6b2c34734f351305eab2cf27558e6c2827a116"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ0NTc2MA==", "bodyText": "It's my understanding this change initiates a forced delete - so in-memory-replicated-state data loss is possible if the forced delete occurs too early  for the pod to perform its graceful shutdown", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2027#discussion_r517445760", "createdAt": "2020-11-04T15:53:19Z", "author": {"login": "tbarnes-us"}, "path": "operator/src/main/java/oracle/kubernetes/operator/StuckPodProcessing.java", "diffHunk": "@@ -0,0 +1,132 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import javax.annotation.Nonnull;\n+\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.kubernetes.operator.calls.CallResponse;\n+import oracle.kubernetes.operator.helpers.CallBuilder;\n+import oracle.kubernetes.operator.helpers.PodHelper;\n+import oracle.kubernetes.operator.steps.DefaultResponseStep;\n+import oracle.kubernetes.operator.work.NextAction;\n+import oracle.kubernetes.operator.work.Packet;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.utils.SystemClock;\n+import org.joda.time.DateTime;\n+\n+public class StuckPodProcessing {\n+\n+\n+  private final MainDelegate mainDelegate;\n+\n+  public StuckPodProcessing(MainDelegate mainDelegate) {\n+    this.mainDelegate = mainDelegate;\n+  }\n+\n+  void checkStuckPods(String namespace) {\n+    Step step = new CallBuilder()\n+          .withLabelSelectors(LabelConstants.getCreatedbyOperatorSelector())\n+          .listPodAsync(namespace, new PodListProcessing(namespace, SystemClock.now()));\n+    mainDelegate.runSteps(step);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private List<V1Pod> getStuckPodList(Packet packet) {\n+    return (List<V1Pod>) packet.computeIfAbsent(\"STUCK_PODS\", k -> new ArrayList<>());\n+  }\n+\n+  class PodListProcessing extends DefaultResponseStep<V1PodList> {\n+\n+    private final DateTime now;\n+\n+    public PodListProcessing(String namespace, DateTime dateTime) {\n+      super(new PodActionsStep(namespace));\n+      now = dateTime;\n+    }\n+\n+    @Override\n+    public NextAction onSuccess(Packet packet, CallResponse<V1PodList> callResponse) {\n+      callResponse.getResult().getItems().stream()\n+            .filter(pod -> isStuck(pod, now))\n+            .forEach(pod -> addStuckPodToPacket(packet, pod));\n+      \n+      return doContinueListOrNext(callResponse, packet);\n+    }\n+\n+    private boolean isStuck(V1Pod pod, DateTime now)  {\n+      return getExpectedDeleteTime(pod).isBefore(now);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0MjI4Nw=="}, "originalCommit": {"oid": "9c6b2c34734f351305eab2cf27558e6c2827a116"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ0NjY5Nw==", "bodyText": "The harm is that instead of catching only a pod that is \"stuck\" in the Terminating state that we could also detect pods that are in the process of shutting down normally and delete them before they've had a chance to complete normal shut down. This should only happen if the operator's pod is badly skewed from the master and the operator thinks the time is later than the master does.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2027#discussion_r517446697", "createdAt": "2020-11-04T15:54:32Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/StuckPodProcessing.java", "diffHunk": "@@ -0,0 +1,132 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import javax.annotation.Nonnull;\n+\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.kubernetes.operator.calls.CallResponse;\n+import oracle.kubernetes.operator.helpers.CallBuilder;\n+import oracle.kubernetes.operator.helpers.PodHelper;\n+import oracle.kubernetes.operator.steps.DefaultResponseStep;\n+import oracle.kubernetes.operator.work.NextAction;\n+import oracle.kubernetes.operator.work.Packet;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.utils.SystemClock;\n+import org.joda.time.DateTime;\n+\n+public class StuckPodProcessing {\n+\n+\n+  private final MainDelegate mainDelegate;\n+\n+  public StuckPodProcessing(MainDelegate mainDelegate) {\n+    this.mainDelegate = mainDelegate;\n+  }\n+\n+  void checkStuckPods(String namespace) {\n+    Step step = new CallBuilder()\n+          .withLabelSelectors(LabelConstants.getCreatedbyOperatorSelector())\n+          .listPodAsync(namespace, new PodListProcessing(namespace, SystemClock.now()));\n+    mainDelegate.runSteps(step);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private List<V1Pod> getStuckPodList(Packet packet) {\n+    return (List<V1Pod>) packet.computeIfAbsent(\"STUCK_PODS\", k -> new ArrayList<>());\n+  }\n+\n+  class PodListProcessing extends DefaultResponseStep<V1PodList> {\n+\n+    private final DateTime now;\n+\n+    public PodListProcessing(String namespace, DateTime dateTime) {\n+      super(new PodActionsStep(namespace));\n+      now = dateTime;\n+    }\n+\n+    @Override\n+    public NextAction onSuccess(Packet packet, CallResponse<V1PodList> callResponse) {\n+      callResponse.getResult().getItems().stream()\n+            .filter(pod -> isStuck(pod, now))\n+            .forEach(pod -> addStuckPodToPacket(packet, pod));\n+      \n+      return doContinueListOrNext(callResponse, packet);\n+    }\n+\n+    private boolean isStuck(V1Pod pod, DateTime now)  {\n+      return getExpectedDeleteTime(pod).isBefore(now);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0MjI4Nw=="}, "originalCommit": {"oid": "9c6b2c34734f351305eab2cf27558e6c2827a116"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ0OTQ1NQ==", "bodyText": "I wish that we could find a way to know that time at the master, but I've not been able to find it.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2027#discussion_r517449455", "createdAt": "2020-11-04T15:58:14Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/StuckPodProcessing.java", "diffHunk": "@@ -0,0 +1,132 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import javax.annotation.Nonnull;\n+\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.kubernetes.operator.calls.CallResponse;\n+import oracle.kubernetes.operator.helpers.CallBuilder;\n+import oracle.kubernetes.operator.helpers.PodHelper;\n+import oracle.kubernetes.operator.steps.DefaultResponseStep;\n+import oracle.kubernetes.operator.work.NextAction;\n+import oracle.kubernetes.operator.work.Packet;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.utils.SystemClock;\n+import org.joda.time.DateTime;\n+\n+public class StuckPodProcessing {\n+\n+\n+  private final MainDelegate mainDelegate;\n+\n+  public StuckPodProcessing(MainDelegate mainDelegate) {\n+    this.mainDelegate = mainDelegate;\n+  }\n+\n+  void checkStuckPods(String namespace) {\n+    Step step = new CallBuilder()\n+          .withLabelSelectors(LabelConstants.getCreatedbyOperatorSelector())\n+          .listPodAsync(namespace, new PodListProcessing(namespace, SystemClock.now()));\n+    mainDelegate.runSteps(step);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private List<V1Pod> getStuckPodList(Packet packet) {\n+    return (List<V1Pod>) packet.computeIfAbsent(\"STUCK_PODS\", k -> new ArrayList<>());\n+  }\n+\n+  class PodListProcessing extends DefaultResponseStep<V1PodList> {\n+\n+    private final DateTime now;\n+\n+    public PodListProcessing(String namespace, DateTime dateTime) {\n+      super(new PodActionsStep(namespace));\n+      now = dateTime;\n+    }\n+\n+    @Override\n+    public NextAction onSuccess(Packet packet, CallResponse<V1PodList> callResponse) {\n+      callResponse.getResult().getItems().stream()\n+            .filter(pod -> isStuck(pod, now))\n+            .forEach(pod -> addStuckPodToPacket(packet, pod));\n+      \n+      return doContinueListOrNext(callResponse, packet);\n+    }\n+\n+    private boolean isStuck(V1Pod pod, DateTime now)  {\n+      return getExpectedDeleteTime(pod).isBefore(now);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0MjI4Nw=="}, "originalCommit": {"oid": "9c6b2c34734f351305eab2cf27558e6c2827a116"}, "originalPosition": 66}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3893, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}