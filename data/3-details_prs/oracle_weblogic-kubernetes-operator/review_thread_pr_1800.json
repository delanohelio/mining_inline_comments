{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ4NDc3NzY3", "number": 1800, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMzozNjo0NFrOEOQusQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNjowMTowM1rOEPMnRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzg5NjE3OnYy", "diffSide": "LEFT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMzozNjo0NFrOGxT_1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNzowNDozNlrOGxc81g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM2MTA0Ng==", "bodyText": "fw.close() call is missing in the refactored code. Not sure if it is intentional.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1800#discussion_r454361046", "createdAt": "2020-07-14T13:36:44Z", "author": {"login": "doxiao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -764,236 +730,29 @@ private void createDomainOnPVUsingWdt(Path domainCreationScriptFile, Path modelF\n             .value(\"/shared/domains/\" + domainUid)); // domain location\n \n     logger.info(\"Running a Kubernetes job to create the domain\");\n-    createDomainJob(pvName, pvcName, domainScriptConfigMapName, namespace, jobCreationContainer);\n+    createDomainJob(image, isUseSecret, pvName, pvcName, domainScriptConfigMapName,\n+        namespace, jobCreationContainer);\n \n   }\n \n-  /**\n-   * Create configmap containing domain creation scripts.\n-   *\n-   * @param configMapName name of the configmap to create\n-   * @param files files to add in configmap\n-   * @param namespace name of the namespace in which to create configmap\n-   * @throws IOException when reading the domain script files fail\n-   * @throws ApiException if create configmap fails\n-   */\n-  private void createConfigMapForDomainCreation(String configMapName, List<Path> files, String namespace)\n-      throws ApiException, IOException {\n-    logger.info(\"Creating configmap {0}\", configMapName);\n-\n-    Path domainScriptsDir = Files.createDirectories(\n-        Paths.get(TestConstants.LOGS_DIR, this.getClass().getSimpleName(), namespace));\n-\n-    // add domain creation scripts and properties files to the configmap\n-    Map<String, String> data = new HashMap<>();\n-    for (Path file : files) {\n-      logger.info(\"Adding file {0} in configmap\", file);\n-      data.put(file.getFileName().toString(), Files.readString(file));\n-      logger.info(\"Making a copy of file {0} to {1} for diagnostic purposes\", file,\n-          domainScriptsDir.resolve(file.getFileName()));\n-      Files.copy(file, domainScriptsDir.resolve(file.getFileName()));\n-    }\n-    V1ObjectMeta meta = new V1ObjectMeta()\n-        .name(configMapName)\n-        .namespace(namespace);\n-    V1ConfigMap configMap = new V1ConfigMap()\n-        .data(data)\n-        .metadata(meta);\n-\n-    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n-        String.format(\"Failed to create configmap %s with files %s\", configMapName, files));\n-    assertTrue(cmCreated, String.format(\"Failed while creating ConfigMap %s\", configMapName));\n-  }\n-\n-  /**\n-   * Create a job to create a domain in persistent volume.\n-   *\n-   * @param pvName name of the persistent volume to create domain in\n-   * @param pvcName name of the persistent volume claim\n-   * @param domainScriptCM configmap holding domain creation script files\n-   * @param namespace name of the domain namespace in which the job is created\n-   * @param jobContainer V1Container with job commands to create domain\n-   */\n-  private void createDomainJob(String pvName,\n-                               String pvcName, String domainScriptCM, String namespace, V1Container jobContainer) {\n-    logger.info(\"Running Kubernetes job to create domain\");\n-\n-    V1Job jobBody = new V1Job()\n-        .metadata(\n-            new V1ObjectMeta()\n-                .name(\"create-domain-onpv-job-\" + pvName) // name of the create domain job\n-                .namespace(namespace))\n-        .spec(new V1JobSpec()\n-            .backoffLimit(0) // try only once\n-            .template(new V1PodTemplateSpec()\n-                .spec(new V1PodSpec()\n-                    .restartPolicy(\"Never\")\n-                    .initContainers(Arrays.asList(new V1Container()\n-                        .name(\"fix-pvc-owner\") // change the ownership of the pv to opc:opc\n-                        .image(image)\n-                        .addCommandItem(\"/bin/sh\")\n-                        .addArgsItem(\"-c\")\n-                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n-                        .volumeMounts(Arrays.asList(\n-                            new V1VolumeMount()\n-                                .name(pvName)\n-                                .mountPath(\"/shared\")))\n-                        .securityContext(new V1SecurityContext()\n-                            .runAsGroup(0L)\n-                            .runAsUser(0L))))\n-                    .containers(Arrays.asList(jobContainer  // container containing WLST or WDT details\n-                        .name(\"create-weblogic-domain-onpv-container\")\n-                        .image(image)\n-                        .imagePullPolicy(\"Always\")\n-                        .ports(Arrays.asList(new V1ContainerPort()\n-                            .containerPort(7001)))\n-                        .volumeMounts(Arrays.asList(\n-                            new V1VolumeMount()\n-                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n-                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n-                            new V1VolumeMount()\n-                                .name(pvName) // location to write domain\n-                                .mountPath(\"/shared\"))))) // mounted under /shared inside pod\n-                    .volumes(Arrays.asList(\n-                        new V1Volume()\n-                            .name(pvName)\n-                            .persistentVolumeClaim(\n-                                new V1PersistentVolumeClaimVolumeSource()\n-                                    .claimName(pvcName)),\n-                        new V1Volume()\n-                            .name(\"create-weblogic-domain-job-cm-volume\")\n-                            .configMap(\n-                                new V1ConfigMapVolumeSource()\n-                                    .name(domainScriptCM)))) //config map containing domain scripts\n-                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n-                        new V1LocalObjectReference()\n-                            .name(OCR_SECRET_NAME))\n-                        : null))));\n-    String jobName = assertDoesNotThrow(()\n-        -> createNamespacedJob(jobBody), \"Failed to create Job\");\n-\n-    logger.info(\"Checking if the domain creation job {0} completed in namespace {1}\",\n-        jobName, namespace);\n-    withStandardRetryPolicy\n-        .conditionEvaluationListener(\n-            condition -> logger.info(\"Waiting for job {0} to be completed in namespace {1} \"\n-                    + \"(elapsed time {2} ms, remaining time {3} ms)\",\n-                jobName,\n-                namespace,\n-                condition.getElapsedTimeInMS(),\n-                condition.getRemainingTimeInMS()))\n-        .until(jobCompleted(jobName, null, namespace));\n-\n-    // check job status and fail test if the job failed to create domain\n-    V1Job job = assertDoesNotThrow(() -> getJob(jobName, namespace),\n-        \"Getting the job failed\");\n-    if (job != null) {\n-      V1JobCondition jobCondition = job.getStatus().getConditions().stream().filter(\n-          v1JobCondition -> \"Failed\".equalsIgnoreCase(v1JobCondition.getType()))\n-          .findAny()\n-          .orElse(null);\n-      if (jobCondition != null) {\n-        logger.severe(\"Job {0} failed to create domain\", jobName);\n-        List<V1Pod> pods = assertDoesNotThrow(() -> listPods(\n-            namespace, \"job-name=\" + jobName).getItems(),\n-            \"Listing pods failed\");\n-        if (!pods.isEmpty()) {\n-          String podLog = assertDoesNotThrow(() -> getPodLog(pods.get(0).getMetadata().getName(), namespace),\n-              \"Failed to get pod log\");\n-          logger.severe(podLog);\n-          fail(\"Domain create job failed\");\n-        }\n-      }\n-    }\n-\n-  }\n-\n-  /**\n-   * Create a persistent volume.\n-   *\n-   * @param pvName name of the persistent volume to create\n-   * @param domainUid domain UID\n-   * @throws IOException when creating pv path fails\n-   */\n-  private void createPV(String pvName, String domainUid) {\n-    logger.info(\"creating persistent volume\");\n-\n-    Path pvHostPath = null;\n-    try {\n-      pvHostPath = Files.createDirectories(Paths.get(\n-          PV_ROOT, this.getClass().getSimpleName(), pvName));\n-      logger.info(\"Creating PV directory host path {0}\", pvHostPath);\n-      FileUtils.deleteDirectory(pvHostPath.toFile());\n-      Files.createDirectories(pvHostPath);\n-    } catch (IOException ioex) {\n-      logger.severe(ioex.getMessage());\n-      fail(\"Create persistent volume host path failed\");\n-    }\n-\n-    V1PersistentVolume v1pv = new V1PersistentVolume()\n-        .spec(new V1PersistentVolumeSpec()\n-            .addAccessModesItem(\"ReadWriteMany\")\n-            .storageClassName(\"weblogic-domain-storage-class\")\n-            .volumeMode(\"Filesystem\")\n-            .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n-            .persistentVolumeReclaimPolicy(\"Recycle\")\n-            .accessModes(Arrays.asList(\"ReadWriteMany\"))\n-            .hostPath(new V1HostPathVolumeSource()\n-                .path(pvHostPath.toString())))\n-        .metadata(new V1ObjectMeta()\n-            .name(pvName)\n-            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n-    boolean success = assertDoesNotThrow(() -> createPersistentVolume(v1pv),\n-        \"Failed to create persistent volume\");\n-    assertTrue(success, \"PersistentVolume creation failed\");\n-  }\n-\n-  /**\n-   * Create a persistent volume claim.\n-   *\n-   * @param pvName name of the persistent volume\n-   * @param pvcName name of the persistent volume to create\n-   * @param domainUid UID of the WebLogic domain\n-   * @param namespace name of the namespace in which to create the persistent volume claim\n-   */\n-  private void createPVC(String pvName, String pvcName, String domainUid, String namespace) {\n-    logger.info(\"creating persistent volume claim\");\n-\n-    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n-        .spec(new V1PersistentVolumeClaimSpec()\n-            .addAccessModesItem(\"ReadWriteMany\")\n-            .storageClassName(\"weblogic-domain-storage-class\")\n-            .volumeName(pvName)\n-            .resources(new V1ResourceRequirements()\n-                .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n-        .metadata(new V1ObjectMeta()\n-            .name(pvcName)\n-            .namespace(namespace)\n-            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n-\n-    boolean success = assertDoesNotThrow(() -> createPersistentVolumeClaim(v1pvc),\n-        \"Failed to create persistent volume claim\");\n-    assertTrue(success, \"PersistentVolumeClaim creation failed\");\n-  }\n-\n   /**\n    * Create secret for docker credentials.\n    *\n    * @param namespace name of the namespace in which to create secret\n    */\n   private void createOCRRepoSecret(String namespace) {\n-    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+    createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n         OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, namespace);\n   }\n \n   private File createScriptToKillServer() throws IOException {\n     File killServerScript = File.createTempFile(\"killserver\", \".sh\");\n     //deletes the file when VM terminates\n     killServerScript.deleteOnExit();\n-    FileWriter fw = new FileWriter(killServerScript);\n-    fw.write(\"#!/bin/bash\\n\");\n-    fw.write(\"kill -9 `jps | grep Server | awk '{print $1}'`\");\n-    fw.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac90905bdd7d92601159d500bf743ac09263941d"}, "originalPosition": 421}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUwNzczNA==", "bodyText": "Yes that is intentional. The try-with-resource will auto close the resource regardless of if there is a exception thrown or not.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1800#discussion_r454507734", "createdAt": "2020-07-14T17:04:36Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -764,236 +730,29 @@ private void createDomainOnPVUsingWdt(Path domainCreationScriptFile, Path modelF\n             .value(\"/shared/domains/\" + domainUid)); // domain location\n \n     logger.info(\"Running a Kubernetes job to create the domain\");\n-    createDomainJob(pvName, pvcName, domainScriptConfigMapName, namespace, jobCreationContainer);\n+    createDomainJob(image, isUseSecret, pvName, pvcName, domainScriptConfigMapName,\n+        namespace, jobCreationContainer);\n \n   }\n \n-  /**\n-   * Create configmap containing domain creation scripts.\n-   *\n-   * @param configMapName name of the configmap to create\n-   * @param files files to add in configmap\n-   * @param namespace name of the namespace in which to create configmap\n-   * @throws IOException when reading the domain script files fail\n-   * @throws ApiException if create configmap fails\n-   */\n-  private void createConfigMapForDomainCreation(String configMapName, List<Path> files, String namespace)\n-      throws ApiException, IOException {\n-    logger.info(\"Creating configmap {0}\", configMapName);\n-\n-    Path domainScriptsDir = Files.createDirectories(\n-        Paths.get(TestConstants.LOGS_DIR, this.getClass().getSimpleName(), namespace));\n-\n-    // add domain creation scripts and properties files to the configmap\n-    Map<String, String> data = new HashMap<>();\n-    for (Path file : files) {\n-      logger.info(\"Adding file {0} in configmap\", file);\n-      data.put(file.getFileName().toString(), Files.readString(file));\n-      logger.info(\"Making a copy of file {0} to {1} for diagnostic purposes\", file,\n-          domainScriptsDir.resolve(file.getFileName()));\n-      Files.copy(file, domainScriptsDir.resolve(file.getFileName()));\n-    }\n-    V1ObjectMeta meta = new V1ObjectMeta()\n-        .name(configMapName)\n-        .namespace(namespace);\n-    V1ConfigMap configMap = new V1ConfigMap()\n-        .data(data)\n-        .metadata(meta);\n-\n-    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n-        String.format(\"Failed to create configmap %s with files %s\", configMapName, files));\n-    assertTrue(cmCreated, String.format(\"Failed while creating ConfigMap %s\", configMapName));\n-  }\n-\n-  /**\n-   * Create a job to create a domain in persistent volume.\n-   *\n-   * @param pvName name of the persistent volume to create domain in\n-   * @param pvcName name of the persistent volume claim\n-   * @param domainScriptCM configmap holding domain creation script files\n-   * @param namespace name of the domain namespace in which the job is created\n-   * @param jobContainer V1Container with job commands to create domain\n-   */\n-  private void createDomainJob(String pvName,\n-                               String pvcName, String domainScriptCM, String namespace, V1Container jobContainer) {\n-    logger.info(\"Running Kubernetes job to create domain\");\n-\n-    V1Job jobBody = new V1Job()\n-        .metadata(\n-            new V1ObjectMeta()\n-                .name(\"create-domain-onpv-job-\" + pvName) // name of the create domain job\n-                .namespace(namespace))\n-        .spec(new V1JobSpec()\n-            .backoffLimit(0) // try only once\n-            .template(new V1PodTemplateSpec()\n-                .spec(new V1PodSpec()\n-                    .restartPolicy(\"Never\")\n-                    .initContainers(Arrays.asList(new V1Container()\n-                        .name(\"fix-pvc-owner\") // change the ownership of the pv to opc:opc\n-                        .image(image)\n-                        .addCommandItem(\"/bin/sh\")\n-                        .addArgsItem(\"-c\")\n-                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n-                        .volumeMounts(Arrays.asList(\n-                            new V1VolumeMount()\n-                                .name(pvName)\n-                                .mountPath(\"/shared\")))\n-                        .securityContext(new V1SecurityContext()\n-                            .runAsGroup(0L)\n-                            .runAsUser(0L))))\n-                    .containers(Arrays.asList(jobContainer  // container containing WLST or WDT details\n-                        .name(\"create-weblogic-domain-onpv-container\")\n-                        .image(image)\n-                        .imagePullPolicy(\"Always\")\n-                        .ports(Arrays.asList(new V1ContainerPort()\n-                            .containerPort(7001)))\n-                        .volumeMounts(Arrays.asList(\n-                            new V1VolumeMount()\n-                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n-                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n-                            new V1VolumeMount()\n-                                .name(pvName) // location to write domain\n-                                .mountPath(\"/shared\"))))) // mounted under /shared inside pod\n-                    .volumes(Arrays.asList(\n-                        new V1Volume()\n-                            .name(pvName)\n-                            .persistentVolumeClaim(\n-                                new V1PersistentVolumeClaimVolumeSource()\n-                                    .claimName(pvcName)),\n-                        new V1Volume()\n-                            .name(\"create-weblogic-domain-job-cm-volume\")\n-                            .configMap(\n-                                new V1ConfigMapVolumeSource()\n-                                    .name(domainScriptCM)))) //config map containing domain scripts\n-                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n-                        new V1LocalObjectReference()\n-                            .name(OCR_SECRET_NAME))\n-                        : null))));\n-    String jobName = assertDoesNotThrow(()\n-        -> createNamespacedJob(jobBody), \"Failed to create Job\");\n-\n-    logger.info(\"Checking if the domain creation job {0} completed in namespace {1}\",\n-        jobName, namespace);\n-    withStandardRetryPolicy\n-        .conditionEvaluationListener(\n-            condition -> logger.info(\"Waiting for job {0} to be completed in namespace {1} \"\n-                    + \"(elapsed time {2} ms, remaining time {3} ms)\",\n-                jobName,\n-                namespace,\n-                condition.getElapsedTimeInMS(),\n-                condition.getRemainingTimeInMS()))\n-        .until(jobCompleted(jobName, null, namespace));\n-\n-    // check job status and fail test if the job failed to create domain\n-    V1Job job = assertDoesNotThrow(() -> getJob(jobName, namespace),\n-        \"Getting the job failed\");\n-    if (job != null) {\n-      V1JobCondition jobCondition = job.getStatus().getConditions().stream().filter(\n-          v1JobCondition -> \"Failed\".equalsIgnoreCase(v1JobCondition.getType()))\n-          .findAny()\n-          .orElse(null);\n-      if (jobCondition != null) {\n-        logger.severe(\"Job {0} failed to create domain\", jobName);\n-        List<V1Pod> pods = assertDoesNotThrow(() -> listPods(\n-            namespace, \"job-name=\" + jobName).getItems(),\n-            \"Listing pods failed\");\n-        if (!pods.isEmpty()) {\n-          String podLog = assertDoesNotThrow(() -> getPodLog(pods.get(0).getMetadata().getName(), namespace),\n-              \"Failed to get pod log\");\n-          logger.severe(podLog);\n-          fail(\"Domain create job failed\");\n-        }\n-      }\n-    }\n-\n-  }\n-\n-  /**\n-   * Create a persistent volume.\n-   *\n-   * @param pvName name of the persistent volume to create\n-   * @param domainUid domain UID\n-   * @throws IOException when creating pv path fails\n-   */\n-  private void createPV(String pvName, String domainUid) {\n-    logger.info(\"creating persistent volume\");\n-\n-    Path pvHostPath = null;\n-    try {\n-      pvHostPath = Files.createDirectories(Paths.get(\n-          PV_ROOT, this.getClass().getSimpleName(), pvName));\n-      logger.info(\"Creating PV directory host path {0}\", pvHostPath);\n-      FileUtils.deleteDirectory(pvHostPath.toFile());\n-      Files.createDirectories(pvHostPath);\n-    } catch (IOException ioex) {\n-      logger.severe(ioex.getMessage());\n-      fail(\"Create persistent volume host path failed\");\n-    }\n-\n-    V1PersistentVolume v1pv = new V1PersistentVolume()\n-        .spec(new V1PersistentVolumeSpec()\n-            .addAccessModesItem(\"ReadWriteMany\")\n-            .storageClassName(\"weblogic-domain-storage-class\")\n-            .volumeMode(\"Filesystem\")\n-            .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n-            .persistentVolumeReclaimPolicy(\"Recycle\")\n-            .accessModes(Arrays.asList(\"ReadWriteMany\"))\n-            .hostPath(new V1HostPathVolumeSource()\n-                .path(pvHostPath.toString())))\n-        .metadata(new V1ObjectMeta()\n-            .name(pvName)\n-            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n-    boolean success = assertDoesNotThrow(() -> createPersistentVolume(v1pv),\n-        \"Failed to create persistent volume\");\n-    assertTrue(success, \"PersistentVolume creation failed\");\n-  }\n-\n-  /**\n-   * Create a persistent volume claim.\n-   *\n-   * @param pvName name of the persistent volume\n-   * @param pvcName name of the persistent volume to create\n-   * @param domainUid UID of the WebLogic domain\n-   * @param namespace name of the namespace in which to create the persistent volume claim\n-   */\n-  private void createPVC(String pvName, String pvcName, String domainUid, String namespace) {\n-    logger.info(\"creating persistent volume claim\");\n-\n-    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n-        .spec(new V1PersistentVolumeClaimSpec()\n-            .addAccessModesItem(\"ReadWriteMany\")\n-            .storageClassName(\"weblogic-domain-storage-class\")\n-            .volumeName(pvName)\n-            .resources(new V1ResourceRequirements()\n-                .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n-        .metadata(new V1ObjectMeta()\n-            .name(pvcName)\n-            .namespace(namespace)\n-            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n-\n-    boolean success = assertDoesNotThrow(() -> createPersistentVolumeClaim(v1pvc),\n-        \"Failed to create persistent volume claim\");\n-    assertTrue(success, \"PersistentVolumeClaim creation failed\");\n-  }\n-\n   /**\n    * Create secret for docker credentials.\n    *\n    * @param namespace name of the namespace in which to create secret\n    */\n   private void createOCRRepoSecret(String namespace) {\n-    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+    createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n         OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, namespace);\n   }\n \n   private File createScriptToKillServer() throws IOException {\n     File killServerScript = File.createTempFile(\"killserver\", \".sh\");\n     //deletes the file when VM terminates\n     killServerScript.deleteOnExit();\n-    FileWriter fw = new FileWriter(killServerScript);\n-    fw.write(\"#!/bin/bash\\n\");\n-    fw.write(\"kill -9 `jps | grep Server | awk '{print $1}'`\");\n-    fw.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM2MTA0Ng=="}, "originalCommit": {"oid": "ac90905bdd7d92601159d500bf743ac09263941d"}, "originalPosition": 421}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzkwMzg4OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonTestUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMzozODozN1rOGxUEsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxOToyMjo0MlrOGxh64Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM2MjI4OQ==", "bodyText": "typo: \"\u2026 the PV directories needs\" -> \"\u2026 the PV directories need\".", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1800#discussion_r454362289", "createdAt": "2020-07-14T13:38:37Z", "author": {"login": "doxiao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonTestUtils.java", "diffHunk": "@@ -1892,6 +1892,7 @@ public static void createPV(String pvName, String domainUid, String className) {\n     logger.info(\"creating persistent volume for pvName {0}, domainUid: {1}, className: {2}\",\n         pvName, domainUid, className);\n     Path pvHostPath = null;\n+    // when tests are running in local box the PV directories needs to exist", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac90905bdd7d92601159d500bf743ac09263941d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU4OTE1Mw==", "bodyText": "Fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1800#discussion_r454589153", "createdAt": "2020-07-14T19:22:42Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonTestUtils.java", "diffHunk": "@@ -1892,6 +1892,7 @@ public static void createPV(String pvName, String domainUid, String className) {\n     logger.info(\"creating persistent volume for pvName {0}, domainUid: {1}, className: {2}\",\n         pvName, domainUid, className);\n     Path pvHostPath = null;\n+    // when tests are running in local box the PV directories needs to exist", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM2MjI4OQ=="}, "originalCommit": {"oid": "ac90905bdd7d92601159d500bf743ac09263941d"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNDUwMjQzOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNTo0ODowNlrOGxZ41Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToxMjoxM1rOGxlhTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ1NzU1Nw==", "bodyText": "can the node port be specified as 0 so that it picks the available port?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1800#discussion_r454457557", "createdAt": "2020-07-14T15:48:06Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "diffHunk": "@@ -207,9 +182,9 @@ public void initAll(@Namespaces(2) List<String> namespaces) {\n     domainNamespace = namespaces.get(1);\n \n     //start two MySQL database instances\n-    mysqlDBPort1 = getNextFreePort(30000, 32767);\n+    mysqlDBPort1 = getNextFreePort(30020, 32767);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac90905bdd7d92601159d500bf743ac09263941d"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY0ODE0MA==", "bodyText": "Yes it can be 0. Got rid of the getNextFreePort method and opted for 0.\nFixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1800#discussion_r454648140", "createdAt": "2020-07-14T21:12:13Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "diffHunk": "@@ -207,9 +182,9 @@ public void initAll(@Namespaces(2) List<String> namespaces) {\n     domainNamespace = namespaces.get(1);\n \n     //start two MySQL database instances\n-    mysqlDBPort1 = getNextFreePort(30000, 32767);\n+    mysqlDBPort1 = getNextFreePort(30020, 32767);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ1NzU1Nw=="}, "originalCommit": {"oid": "ac90905bdd7d92601159d500bf743ac09263941d"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNDUwMzUwOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNTo0ODoyMlrOGxZ5hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToxMjoyM1rOGxlhmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ1NzczNQ==", "bodyText": "can the node port be specified as 0 so that it picks the available port?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1800#discussion_r454457735", "createdAt": "2020-07-14T15:48:22Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "diffHunk": "@@ -207,9 +182,9 @@ public void initAll(@Namespaces(2) List<String> namespaces) {\n     domainNamespace = namespaces.get(1);\n \n     //start two MySQL database instances\n-    mysqlDBPort1 = getNextFreePort(30000, 32767);\n+    mysqlDBPort1 = getNextFreePort(30020, 32767);\n     createMySQLDB(\"mysqldb-1\", \"root\", \"root123\", mysqlDBPort1, domainNamespace, null);\n-    mysqlDBPort2 = getNextFreePort(31000, 32767);\n+    mysqlDBPort2 = getNextFreePort(31020, 32767);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac90905bdd7d92601159d500bf743ac09263941d"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY0ODIxOQ==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1800#discussion_r454648219", "createdAt": "2020-07-14T21:12:23Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "diffHunk": "@@ -207,9 +182,9 @@ public void initAll(@Namespaces(2) List<String> namespaces) {\n     domainNamespace = namespaces.get(1);\n \n     //start two MySQL database instances\n-    mysqlDBPort1 = getNextFreePort(30000, 32767);\n+    mysqlDBPort1 = getNextFreePort(30020, 32767);\n     createMySQLDB(\"mysqldb-1\", \"root\", \"root123\", mysqlDBPort1, domainNamespace, null);\n-    mysqlDBPort2 = getNextFreePort(31000, 32767);\n+    mysqlDBPort2 = getNextFreePort(31020, 32767);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ1NzczNQ=="}, "originalCommit": {"oid": "ac90905bdd7d92601159d500bf743ac09263941d"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzcwNzU5OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/resources/apps/clusterview/src/java/oracle/weblogic/kubernetes/applications/clusterview/ConfigServlet.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNjowMTowM1rOGyxxkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNzozMjoyN1rOGy1RYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg5NzQ5MQ==", "bodyText": "catching the exception and just printing it, does the test fail on any exceptions and how?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1800#discussion_r455897491", "createdAt": "2020-07-16T16:01:03Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/resources/apps/clusterview/src/java/oracle/weblogic/kubernetes/applications/clusterview/ConfigServlet.java", "diffHunk": "@@ -178,16 +178,23 @@ private void testJdbcConnection(HttpServletRequest request, PrintWriter out) {\n \n     String dsName = request.getParameter(\"dsName\");\n     String serverName = request.getParameter(\"serverName\");\n-\n-    ServerRuntimeMBean serverRuntime = getServerRuntime(serverName);\n-    JDBCDataSourceRuntimeMBean[] jdbcDataSourceRuntimeMBeans = serverRuntime.getJDBCServiceRuntime().getJDBCDataSourceRuntimeMBeans();\n-    for (JDBCDataSourceRuntimeMBean jdbcDataSourceRuntimeMBean : jdbcDataSourceRuntimeMBeans) {\n-      if (jdbcDataSourceRuntimeMBean.getName().equals(dsName)) {\n-        String testPool = jdbcDataSourceRuntimeMBean.testPool();\n-        if (testPool == null) {\n-          out.println(\"Connection successful\");\n+    System.out.println(\"ITTESTS:>>>>Testing connection pool in datasource : \" + dsName + \" in server \" + serverName);\n+    try {\n+      ServerRuntimeMBean serverRuntime = getServerRuntime(serverName);\n+      JDBCDataSourceRuntimeMBean[] jdbcDataSourceRuntimeMBeans = serverRuntime.getJDBCServiceRuntime().getJDBCDataSourceRuntimeMBeans();\n+      System.out.println(\"ITTESTS:>>>>Getting datasource runtime mbeans\");\n+      for (JDBCDataSourceRuntimeMBean jdbcDataSourceRuntimeMBean : jdbcDataSourceRuntimeMBeans) {\n+        System.out.println(\"ITTESTS:>>>>Found JDBC datasource runtime mbean: \" + jdbcDataSourceRuntimeMBean.getName());\n+        if (jdbcDataSourceRuntimeMBean.getName().equals(dsName)) {\n+          System.out.println(\"ITTESTS:>>>>Testing connection pool for JDBC datasource runtime mbean: \" + jdbcDataSourceRuntimeMBean.getName());\n+          String testPool = jdbcDataSourceRuntimeMBean.testPool();\n+          if (testPool == null) {\n+            out.println(\"Connection successful\");\n+          }\n         }\n       }\n+    } catch (Exception ex) {\n+      ex.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03f33cd0acbd0fe903528208388e93a5b7aa91da"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk0OTUyMg==", "bodyText": "sometimes when the managed servers cannot communicate with each other the test jdbc connection pool is failing in looking up the server in domain runtime tree. So I would like to get a stacktrace to debug in case test fails, the test doesn't doesn't depend on any exception to pass/fail.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1800#discussion_r455949522", "createdAt": "2020-07-16T17:23:53Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/resources/apps/clusterview/src/java/oracle/weblogic/kubernetes/applications/clusterview/ConfigServlet.java", "diffHunk": "@@ -178,16 +178,23 @@ private void testJdbcConnection(HttpServletRequest request, PrintWriter out) {\n \n     String dsName = request.getParameter(\"dsName\");\n     String serverName = request.getParameter(\"serverName\");\n-\n-    ServerRuntimeMBean serverRuntime = getServerRuntime(serverName);\n-    JDBCDataSourceRuntimeMBean[] jdbcDataSourceRuntimeMBeans = serverRuntime.getJDBCServiceRuntime().getJDBCDataSourceRuntimeMBeans();\n-    for (JDBCDataSourceRuntimeMBean jdbcDataSourceRuntimeMBean : jdbcDataSourceRuntimeMBeans) {\n-      if (jdbcDataSourceRuntimeMBean.getName().equals(dsName)) {\n-        String testPool = jdbcDataSourceRuntimeMBean.testPool();\n-        if (testPool == null) {\n-          out.println(\"Connection successful\");\n+    System.out.println(\"ITTESTS:>>>>Testing connection pool in datasource : \" + dsName + \" in server \" + serverName);\n+    try {\n+      ServerRuntimeMBean serverRuntime = getServerRuntime(serverName);\n+      JDBCDataSourceRuntimeMBean[] jdbcDataSourceRuntimeMBeans = serverRuntime.getJDBCServiceRuntime().getJDBCDataSourceRuntimeMBeans();\n+      System.out.println(\"ITTESTS:>>>>Getting datasource runtime mbeans\");\n+      for (JDBCDataSourceRuntimeMBean jdbcDataSourceRuntimeMBean : jdbcDataSourceRuntimeMBeans) {\n+        System.out.println(\"ITTESTS:>>>>Found JDBC datasource runtime mbean: \" + jdbcDataSourceRuntimeMBean.getName());\n+        if (jdbcDataSourceRuntimeMBean.getName().equals(dsName)) {\n+          System.out.println(\"ITTESTS:>>>>Testing connection pool for JDBC datasource runtime mbean: \" + jdbcDataSourceRuntimeMBean.getName());\n+          String testPool = jdbcDataSourceRuntimeMBean.testPool();\n+          if (testPool == null) {\n+            out.println(\"Connection successful\");\n+          }\n         }\n       }\n+    } catch (Exception ex) {\n+      ex.printStackTrace();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg5NzQ5MQ=="}, "originalCommit": {"oid": "03f33cd0acbd0fe903528208388e93a5b7aa91da"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk1NDc4Ng==", "bodyText": "The test looks for the \"Connection successful\" string to pass.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1800#discussion_r455954786", "createdAt": "2020-07-16T17:32:27Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/resources/apps/clusterview/src/java/oracle/weblogic/kubernetes/applications/clusterview/ConfigServlet.java", "diffHunk": "@@ -178,16 +178,23 @@ private void testJdbcConnection(HttpServletRequest request, PrintWriter out) {\n \n     String dsName = request.getParameter(\"dsName\");\n     String serverName = request.getParameter(\"serverName\");\n-\n-    ServerRuntimeMBean serverRuntime = getServerRuntime(serverName);\n-    JDBCDataSourceRuntimeMBean[] jdbcDataSourceRuntimeMBeans = serverRuntime.getJDBCServiceRuntime().getJDBCDataSourceRuntimeMBeans();\n-    for (JDBCDataSourceRuntimeMBean jdbcDataSourceRuntimeMBean : jdbcDataSourceRuntimeMBeans) {\n-      if (jdbcDataSourceRuntimeMBean.getName().equals(dsName)) {\n-        String testPool = jdbcDataSourceRuntimeMBean.testPool();\n-        if (testPool == null) {\n-          out.println(\"Connection successful\");\n+    System.out.println(\"ITTESTS:>>>>Testing connection pool in datasource : \" + dsName + \" in server \" + serverName);\n+    try {\n+      ServerRuntimeMBean serverRuntime = getServerRuntime(serverName);\n+      JDBCDataSourceRuntimeMBean[] jdbcDataSourceRuntimeMBeans = serverRuntime.getJDBCServiceRuntime().getJDBCDataSourceRuntimeMBeans();\n+      System.out.println(\"ITTESTS:>>>>Getting datasource runtime mbeans\");\n+      for (JDBCDataSourceRuntimeMBean jdbcDataSourceRuntimeMBean : jdbcDataSourceRuntimeMBeans) {\n+        System.out.println(\"ITTESTS:>>>>Found JDBC datasource runtime mbean: \" + jdbcDataSourceRuntimeMBean.getName());\n+        if (jdbcDataSourceRuntimeMBean.getName().equals(dsName)) {\n+          System.out.println(\"ITTESTS:>>>>Testing connection pool for JDBC datasource runtime mbean: \" + jdbcDataSourceRuntimeMBean.getName());\n+          String testPool = jdbcDataSourceRuntimeMBean.testPool();\n+          if (testPool == null) {\n+            out.println(\"Connection successful\");\n+          }\n         }\n       }\n+    } catch (Exception ex) {\n+      ex.printStackTrace();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg5NzQ5MQ=="}, "originalCommit": {"oid": "03f33cd0acbd0fe903528208388e93a5b7aa91da"}, "originalPosition": 28}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4099, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}