{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4NjIwMjY5", "number": 1591, "title": "MII ConfigMap Override Usecase in Junit5  ( Ready for Review ) ", "bodyText": "This covers the following two e-2-e Usecase(s)\na.  Start a  Model-in-Image Domain with a predefined ConfigMap (with a sparse JDBC model file)\nin the configuration/model section of the domain resource.\nMake sure the DataSource Configuration is accessible thru Admin server REST URL\nb. Start a  Model-in-Image Domain without any pre-defined ConfigMap\nCreate a ConfigMap with a with a sparse JDBC model file\nPatch the  domain resource with the ConfigMap\nUpdate the Restart Version of the domain resource to trigger rolling re-start of the Domain\nMake sure the DataSource Configuration is accessible thru Admin server REST URL\nc. Add a dynamic cluster thru configMap Override and make sure managed server from new\ncluster is up after updating the restart version and replica on the spec level.\nd. Add a configured cluster through configMap Override and make sure the managed server from the new cluster is up running after updating the restart version and replica on the spec level.\ne. Add a cluster through the ConfigMap but make sure that the new server does not come up only updating the restart version on the spec level.\nIn addition to it, the PR has a new Assertion to compare the old PodCreationTimeStamp and new PodCreationTimeStamp to verify that the pod has been restarted.\nhttps://build.weblogick8s.org:8443/job/weblogic-kubernetes-operator-model-in-image-tests-10/65/  ( all tests passed )", "createdAt": "2020-04-24T15:32:08Z", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591", "merged": true, "mergeCommit": {"oid": "0f81630b724a26dd0a6525e99c3b9520cba3d194"}, "closed": true, "closedAt": "2020-05-14T13:31:23Z", "author": {"login": "anpanigr"}, "timelineItems": {"totalCount": 84, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcaLUjTgH2gAyNDA4NjIwMjY5Ojg2NTZjZTU0NjRiZTA1YmNkOWNlZmQ2YTRjN2UzNzg3YmMxZGVhNDE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABchMVlOgFqTQxMTczNzI2OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8656ce5464be05bcd9cefd6a4c7e3787bc1dea41", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8656ce5464be05bcd9cefd6a4c7e3787bc1dea41", "committedDate": "2020-04-22T16:59:31Z", "message": "Initial cut for ConfigMap test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01d320e51e040e5f4a463b21ab88de0617f87ca1", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/01d320e51e040e5f4a463b21ab88de0617f87ca1", "committedDate": "2020-04-22T17:00:17Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5da3bbed7ffa0e2f39816bd476c89aa83a6d509b", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5da3bbed7ffa0e2f39816bd476c89aa83a6d509b", "committedDate": "2020-04-23T14:30:34Z", "message": "Sync up develop branch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76aa1ec1c06157b82f46e6927cf0e68ed9de70b2", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/76aa1ec1c06157b82f46e6927cf0e68ed9de70b2", "committedDate": "2020-04-23T14:30:40Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b86874f327e757ee7a6899eed5cd27d36528358c", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b86874f327e757ee7a6899eed5cd27d36528358c", "committedDate": "2020-04-24T03:31:28Z", "message": "e2e usease with DataSource verification"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a77be5cb2b80eb04d0676959e4dfe51ae96be7a1", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a77be5cb2b80eb04d0676959e4dfe51ae96be7a1", "committedDate": "2020-04-24T14:19:42Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMDU0NzE2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-400054716", "createdAt": "2020-04-24T15:34:35Z", "commit": {"oid": "b86874f327e757ee7a6899eed5cd27d36528358c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNTozNDozNlrOGLdZyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNTozNDozNlrOGLdZyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY2OTI1OA==", "bodyText": "@IntegrationTEST annotation is missing.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414669258", "createdAt": "2020-04-24T15:34:36Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,587 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+class ItMiiConfigMap implements LoggedTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86874f327e757ee7a6899eed5cd27d36528358c"}, "originalPosition": 95}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMDU1NDcz", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-400055473", "createdAt": "2020-04-24T15:35:31Z", "commit": {"oid": "b86874f327e757ee7a6899eed5cd27d36528358c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNTozNTozMVrOGLdcPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNTozNTozMVrOGLdcPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY2OTg4Nw==", "bodyText": "Use \"@namespaces(1) List namespaces\" in method to get the namespaces for the test. Do not create namespaces in test.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414669887", "createdAt": "2020-04-24T15:35:31Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,587 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  private String domainUid = \"domain1\";\n+  private String repoSecretName = \"reposecret\";\n+  private String miiImage = null;\n+  private String repoRegistry = \"dummy\";\n+  private String repoUserName = \"dummy\";\n+  private String repoPassword = \"dummy\";\n+  private String repoEmail = \"dummy\";\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86874f327e757ee7a6899eed5cd27d36528358c"}, "originalPosition": 133}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32c8d28c09f372b6b1ad6bdbc8f6e6c706987183", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/32c8d28c09f372b6b1ad6bdbc8f6e6c706987183", "committedDate": "2020-04-24T16:07:07Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMDk0MjU3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-400094257", "createdAt": "2020-04-24T16:25:32Z", "commit": {"oid": "b86874f327e757ee7a6899eed5cd27d36528358c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjoyNTozMlrOGLfgEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjoyNTozMlrOGLfgEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwMzYzNQ==", "bodyText": "General comment:\nQuite a few of the methods in this code look like boilerplate that could be made common to many tests: check*, tear*, and much of init*.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414703635", "createdAt": "2020-04-24T16:25:32Z", "author": {"login": "tbarnes-us"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,587 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86874f327e757ee7a6899eed5cd27d36528358c"}, "originalPosition": 93}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMjI4MDg5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-400228089", "createdAt": "2020-04-24T19:50:43Z", "commit": {"oid": "b86874f327e757ee7a6899eed5cd27d36528358c"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxOTo1MDo0NFrOGLm1iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxOTo1NjoyOFrOGLnCFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyMzgxNg==", "bodyText": "no need to do this, since the extension will do this for you", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414823816", "createdAt": "2020-04-24T19:50:44Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,587 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  private String domainUid = \"domain1\";\n+  private String repoSecretName = \"reposecret\";\n+  private String miiImage = null;\n+  private String repoRegistry = \"dummy\";\n+  private String repoUserName = \"dummy\";\n+  private String repoPassword = \"dummy\";\n+  private String repoEmail = \"dummy\";\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = assertDoesNotThrow(() -> createUniqueNamespace(),\n+        \"Failed to create unique namespace due to ApiException\");\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = assertDoesNotThrow(() -> createUniqueNamespace(),\n+        \"Failed to create unique namespace due to ApiException\");\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    helmList(opHelmParams);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   *  Deploy a WebLogic domain with a defined configmap \n+   *  in configuration/model section of the domain resource.\n+   *  The configmap has a sparse wdt model file that define a JDBC \n+   *  datasource targeted to the cluster\n+   *  Once the WebLogic domain is up, verify the DataSource configuration \n+   *  using the RestAPI call thru adminserver public NodePort\n+  */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with a configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigMapDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (System.getenv(\"REPO_REGISTRY\") != null && System.getenv(\"REPO_USERNAME\") != null\n+        && System.getenv(\"REPO_PASSWORD\") != null && System.getenv(\"REPO_EMAIL\") != null) {\n+      repoRegistry = System.getenv(\"REPO_REGISTRY\");\n+      repoUserName = System.getenv(\"REPO_USERNAME\");\n+      repoPassword = System.getenv(\"REPO_PASSWORD\");\n+      repoEmail = System.getenv(\"REPO_EMAIL\");\n+\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(repoRegistry, repoUserName, repoPassword), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // create docker registry secret in the domain namespace to pull the image from OCIR\n+    JsonObject dockerConfigJsonObject = getDockerConfigJson(\n+        repoUserName, repoPassword, repoEmail, repoRegistry);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(repoSecretName)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", repoSecretName));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", repoSecretName));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap();\n+    adminSecretMap.put(\"username\", \"weblogic\");\n+    adminSecretMap.put(\"password\", \"welcome1\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(adminSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    Map<String, String> encryptionSecretMap = new HashMap();\n+    encryptionSecretMap.put(\"username\", \"weblogicenc\");\n+    encryptionSecretMap.put(\"password\", \"weblogicenc\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(encryptionSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(encryptionSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", encryptionSecretName));\n+\n+    // Create a ConfigMap with a sparse jdbc model file\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData  = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\",cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMetaBuilder()\n+        .withLabels(labels)\n+        .withName(configMapName)\n+        .withNamespace(domainNamespace)\n+        .build();\n+    V1ConfigMap configMap = new V1ConfigMapBuilder()\n+        .withData(data)\n+        .withMetadata(meta)\n+        .build();\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // add domain CR with a predefined configmap in configuration/model section\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(repoSecretName))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .configMap(configMapName)\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is running\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodRunning(adminServerPodName);\n+\n+    // check managed server pods are running\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodRunning(managedServerPrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null; \n+    try {\n+      String hostname = null;\n+      if (System.getenv(\"K8S_NODEPORT_HOST\") == null) {\n+        hostname = InetAddress.getLocalHost().getHostName();\n+      } else {\n+        hostname = System.getenv(\"K8S_NODEPORT_HOST\");\n+      }\n+         \n+      checkJdbc =  new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkJdbc.append(\"http://\" + hostname + \":30711\")\n+             .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+             .append(\" -o /dev/null\")\n+             .append(\" -w %{http_code});\")\n+             .append(\"echo ${status}\");      \n+      logger.info(\"CURL command {0}\", new String(checkJdbc));\n+      result = exec(new String(checkJdbc),true);\n+    } catch (java.net.UnknownHostException uhe) {\n+      logger.info(\"UnknownHostException is received {0}\", uhe);\n+      fail(\"Got UnknownHostException\");\n+    } catch (Exception ex) {\n+      logger.info(\"Unexpected exception  {0}\", ex);\n+      fail(\"Got unexpected exception\");\n+    }\n+    logger.info(\"Curl command returns {0}\", result.toString());\n+    assertEquals(\"200\",result.stdout(),\"Datasource configuration not found\");\n+    logger.info(\"Found the DataSource configuration \");\n+\n+  }\n+\n+  @AfterEach\n+  public void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  /**\n+   * Uninstall Operator, delete service account, domain namespace and\n+   * operator namespace.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86874f327e757ee7a6899eed5cd27d36528358c"}, "originalPosition": 451}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNDIwMw==", "bodyText": "remove commented out code please", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414824203", "createdAt": "2020-04-24T19:51:25Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,669 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDeleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podTerminating;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86874f327e757ee7a6899eed5cd27d36528358c"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNTA2NA==", "bodyText": "just check the uptime, as per ryan and dongbo's comments in standup", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414825064", "createdAt": "2020-04-24T19:52:55Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,669 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDeleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podTerminating;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  private String domainUid = \"domain1\";\n+  private String repoSecretName = \"reposecret\";\n+  private String miiImage = null;\n+  private String repoRegistry = \"dummy\";\n+  private String repoUserName = \"dummy\";\n+  private String repoPassword = \"dummy\";\n+  private String repoEmail = \"dummy\";\n+  private V1Patch patch = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = assertDoesNotThrow(() -> createUniqueNamespace(),\n+        \"Failed to create unique namespace due to ApiException\");\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = assertDoesNotThrow(() -> createUniqueNamespace(),\n+        \"Failed to create unique namespace due to ApiException\");\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    helmList(opHelmParams);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   *  Deploy a WebLogic domain with a defined configmap \n+   *  in configuration/model section of the domain resource.\n+   *  The configmap has a sparse wdt model file that define a JDBC \n+   *  datasource targeted to the cluster\n+  */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomainWithConfigMapOverride() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (System.getenv(\"REPO_REGISTRY\") != null && System.getenv(\"REPO_USERNAME\") != null\n+        && System.getenv(\"REPO_PASSWORD\") != null && System.getenv(\"REPO_EMAIL\") != null) {\n+      repoRegistry = System.getenv(\"REPO_REGISTRY\");\n+      repoUserName = System.getenv(\"REPO_USERNAME\");\n+      repoPassword = System.getenv(\"REPO_PASSWORD\");\n+      repoEmail = System.getenv(\"REPO_EMAIL\");\n+\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(repoRegistry, repoUserName, repoPassword), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // create docker registry secret in the domain namespace to pull the image from OCIR\n+    JsonObject dockerConfigJsonObject = getDockerConfigJson(\n+        repoUserName, repoPassword, repoEmail, repoRegistry);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(repoSecretName)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", repoSecretName));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", repoSecretName));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap();\n+    adminSecretMap.put(\"username\", \"weblogic\");\n+    adminSecretMap.put(\"password\", \"welcome1\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(adminSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    Map<String, String> encryptionSecretMap = new HashMap();\n+    encryptionSecretMap.put(\"username\", \"weblogicenc\");\n+    encryptionSecretMap.put(\"password\", \"weblogicenc\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(encryptionSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(encryptionSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", encryptionSecretName));\n+\n+    // add domain CR \n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(repoSecretName))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is running\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodRunning(adminServerPodName);\n+\n+    // check managed server pods are running\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managedserver pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodRunning(managedServerPrefix + i);\n+    }\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+    // Create a ConfigMap with a sparse jdbc model file\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    StringBuffer patchStr  = null;\n+\n+    cmData  = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\",cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMetaBuilder()\n+        .withLabels(labels)\n+        .withName(configMapName)\n+        .withNamespace(domainNamespace)\n+        .build();\n+    V1ConfigMap configMap = new V1ConfigMapBuilder()\n+        .withData(data)\n+        .withMetadata(meta)\n+        .build();\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    patchStr  = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+            .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+            .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+            .append(\" }]\");\n+    logger.log(Level.INFO, \"ConfigMap Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() -> \n+        patchDomainCustomResource(domainUid,domainNamespace,patch,\"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+\n+    patchStr  = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+            .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+            .append(\" \\\"value\\\": \\\"2\\\"\")\n+            .append(\" }]\");\n+    logger.log(Level.INFO, \"RestartVersion Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() -> \n+        patchDomainCustomResource(domainUid,domainNamespace,patch,\"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 60 secs for Introspector to kick off\");\n+    try { \n+      Thread.sleep(60000);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodDeleted(adminServerPodName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86874f327e757ee7a6899eed5cd27d36528358c"}, "originalPosition": 441}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNTM3OA==", "bodyText": "don't need this - the extension will do it", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414825378", "createdAt": "2020-04-24T19:53:23Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,669 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDeleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podTerminating;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  private String domainUid = \"domain1\";\n+  private String repoSecretName = \"reposecret\";\n+  private String miiImage = null;\n+  private String repoRegistry = \"dummy\";\n+  private String repoUserName = \"dummy\";\n+  private String repoPassword = \"dummy\";\n+  private String repoEmail = \"dummy\";\n+  private V1Patch patch = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = assertDoesNotThrow(() -> createUniqueNamespace(),\n+        \"Failed to create unique namespace due to ApiException\");\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = assertDoesNotThrow(() -> createUniqueNamespace(),\n+        \"Failed to create unique namespace due to ApiException\");\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    helmList(opHelmParams);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   *  Deploy a WebLogic domain with a defined configmap \n+   *  in configuration/model section of the domain resource.\n+   *  The configmap has a sparse wdt model file that define a JDBC \n+   *  datasource targeted to the cluster\n+  */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomainWithConfigMapOverride() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (System.getenv(\"REPO_REGISTRY\") != null && System.getenv(\"REPO_USERNAME\") != null\n+        && System.getenv(\"REPO_PASSWORD\") != null && System.getenv(\"REPO_EMAIL\") != null) {\n+      repoRegistry = System.getenv(\"REPO_REGISTRY\");\n+      repoUserName = System.getenv(\"REPO_USERNAME\");\n+      repoPassword = System.getenv(\"REPO_PASSWORD\");\n+      repoEmail = System.getenv(\"REPO_EMAIL\");\n+\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(repoRegistry, repoUserName, repoPassword), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // create docker registry secret in the domain namespace to pull the image from OCIR\n+    JsonObject dockerConfigJsonObject = getDockerConfigJson(\n+        repoUserName, repoPassword, repoEmail, repoRegistry);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(repoSecretName)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", repoSecretName));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", repoSecretName));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap();\n+    adminSecretMap.put(\"username\", \"weblogic\");\n+    adminSecretMap.put(\"password\", \"welcome1\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(adminSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    Map<String, String> encryptionSecretMap = new HashMap();\n+    encryptionSecretMap.put(\"username\", \"weblogicenc\");\n+    encryptionSecretMap.put(\"password\", \"weblogicenc\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(encryptionSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(encryptionSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", encryptionSecretName));\n+\n+    // add domain CR \n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(repoSecretName))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is running\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodRunning(adminServerPodName);\n+\n+    // check managed server pods are running\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managedserver pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodRunning(managedServerPrefix + i);\n+    }\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+    // Create a ConfigMap with a sparse jdbc model file\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    StringBuffer patchStr  = null;\n+\n+    cmData  = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\",cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMetaBuilder()\n+        .withLabels(labels)\n+        .withName(configMapName)\n+        .withNamespace(domainNamespace)\n+        .build();\n+    V1ConfigMap configMap = new V1ConfigMapBuilder()\n+        .withData(data)\n+        .withMetadata(meta)\n+        .build();\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    patchStr  = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+            .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+            .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+            .append(\" }]\");\n+    logger.log(Level.INFO, \"ConfigMap Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() -> \n+        patchDomainCustomResource(domainUid,domainNamespace,patch,\"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+\n+    patchStr  = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+            .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+            .append(\" \\\"value\\\": \\\"2\\\"\")\n+            .append(\" }]\");\n+    logger.log(Level.INFO, \"RestartVersion Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() -> \n+        patchDomainCustomResource(domainUid,domainNamespace,patch,\"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 60 secs for Introspector to kick off\");\n+    try { \n+      Thread.sleep(60000);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodDeleted(adminServerPodName);\n+    checkPodCreated(adminServerPodName);\n+    checkPodRunning(adminServerPodName);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server pods re-started sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in namespace {1}\",\n+                        managedServerPrefix + i, domainNamespace);\n+      checkPodDeleted(managedServerPrefix + i);\n+      checkPodRunning(managedServerPrefix + i);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null; \n+    try {\n+      String hostname = null;\n+      if (System.getenv(\"K8S_NODEPORT_HOST\") == null) {\n+        hostname = InetAddress.getLocalHost().getHostName();\n+      } else {\n+        hostname = System.getenv(\"K8S_NODEPORT_HOST\");\n+      }\n+      checkJdbc =  new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkJdbc.append(\"http://\" + hostname + \":30711\")\n+             .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+             .append(\" -o /dev/null\")\n+             .append(\" -w %{http_code});\")\n+             .append(\"echo ${status}\");      \n+      logger.info(\"CURL command {0}\", new String(checkJdbc));\n+      result = exec(new String(checkJdbc),true);\n+    } catch (java.net.UnknownHostException uhe) {\n+      logger.info(\"UnknownHostException is received {0}\", uhe);\n+      fail(\"Got UnknownHostException\");\n+    } catch (Exception ex) {\n+      logger.info(\"Unexpected exception  {0}\", ex);\n+      fail(\"Got unexpected exception\");\n+    }\n+    logger.info(\"Curl command returns {0}\", result.toString());\n+    assertEquals(\"200\",result.stdout(),\"Datasource configuration not found\");\n+    logger.info(\"Found the DataSource configuration \");\n+  }\n+\n+  @AfterEach\n+  public void tearDown() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86874f327e757ee7a6899eed5cd27d36528358c"}, "originalPosition": 484}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNTQ5MA==", "bodyText": "don't need this - extension will do it", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414825490", "createdAt": "2020-04-24T19:53:36Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,669 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDeleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podTerminating;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  private String domainUid = \"domain1\";\n+  private String repoSecretName = \"reposecret\";\n+  private String miiImage = null;\n+  private String repoRegistry = \"dummy\";\n+  private String repoUserName = \"dummy\";\n+  private String repoPassword = \"dummy\";\n+  private String repoEmail = \"dummy\";\n+  private V1Patch patch = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = assertDoesNotThrow(() -> createUniqueNamespace(),\n+        \"Failed to create unique namespace due to ApiException\");\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = assertDoesNotThrow(() -> createUniqueNamespace(),\n+        \"Failed to create unique namespace due to ApiException\");\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    helmList(opHelmParams);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   *  Deploy a WebLogic domain with a defined configmap \n+   *  in configuration/model section of the domain resource.\n+   *  The configmap has a sparse wdt model file that define a JDBC \n+   *  datasource targeted to the cluster\n+  */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomainWithConfigMapOverride() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (System.getenv(\"REPO_REGISTRY\") != null && System.getenv(\"REPO_USERNAME\") != null\n+        && System.getenv(\"REPO_PASSWORD\") != null && System.getenv(\"REPO_EMAIL\") != null) {\n+      repoRegistry = System.getenv(\"REPO_REGISTRY\");\n+      repoUserName = System.getenv(\"REPO_USERNAME\");\n+      repoPassword = System.getenv(\"REPO_PASSWORD\");\n+      repoEmail = System.getenv(\"REPO_EMAIL\");\n+\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(repoRegistry, repoUserName, repoPassword), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // create docker registry secret in the domain namespace to pull the image from OCIR\n+    JsonObject dockerConfigJsonObject = getDockerConfigJson(\n+        repoUserName, repoPassword, repoEmail, repoRegistry);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(repoSecretName)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", repoSecretName));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", repoSecretName));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap();\n+    adminSecretMap.put(\"username\", \"weblogic\");\n+    adminSecretMap.put(\"password\", \"welcome1\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(adminSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    Map<String, String> encryptionSecretMap = new HashMap();\n+    encryptionSecretMap.put(\"username\", \"weblogicenc\");\n+    encryptionSecretMap.put(\"password\", \"weblogicenc\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(encryptionSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(encryptionSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", encryptionSecretName));\n+\n+    // add domain CR \n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(repoSecretName))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is running\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodRunning(adminServerPodName);\n+\n+    // check managed server pods are running\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managedserver pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodRunning(managedServerPrefix + i);\n+    }\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+    // Create a ConfigMap with a sparse jdbc model file\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    StringBuffer patchStr  = null;\n+\n+    cmData  = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\",cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMetaBuilder()\n+        .withLabels(labels)\n+        .withName(configMapName)\n+        .withNamespace(domainNamespace)\n+        .build();\n+    V1ConfigMap configMap = new V1ConfigMapBuilder()\n+        .withData(data)\n+        .withMetadata(meta)\n+        .build();\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    patchStr  = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+            .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+            .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+            .append(\" }]\");\n+    logger.log(Level.INFO, \"ConfigMap Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() -> \n+        patchDomainCustomResource(domainUid,domainNamespace,patch,\"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+\n+    patchStr  = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+            .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+            .append(\" \\\"value\\\": \\\"2\\\"\")\n+            .append(\" }]\");\n+    logger.log(Level.INFO, \"RestartVersion Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() -> \n+        patchDomainCustomResource(domainUid,domainNamespace,patch,\"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 60 secs for Introspector to kick off\");\n+    try { \n+      Thread.sleep(60000);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodDeleted(adminServerPodName);\n+    checkPodCreated(adminServerPodName);\n+    checkPodRunning(adminServerPodName);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server pods re-started sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in namespace {1}\",\n+                        managedServerPrefix + i, domainNamespace);\n+      checkPodDeleted(managedServerPrefix + i);\n+      checkPodRunning(managedServerPrefix + i);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null; \n+    try {\n+      String hostname = null;\n+      if (System.getenv(\"K8S_NODEPORT_HOST\") == null) {\n+        hostname = InetAddress.getLocalHost().getHostName();\n+      } else {\n+        hostname = System.getenv(\"K8S_NODEPORT_HOST\");\n+      }\n+      checkJdbc =  new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkJdbc.append(\"http://\" + hostname + \":30711\")\n+             .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+             .append(\" -o /dev/null\")\n+             .append(\" -w %{http_code});\")\n+             .append(\"echo ${status}\");      \n+      logger.info(\"CURL command {0}\", new String(checkJdbc));\n+      result = exec(new String(checkJdbc),true);\n+    } catch (java.net.UnknownHostException uhe) {\n+      logger.info(\"UnknownHostException is received {0}\", uhe);\n+      fail(\"Got UnknownHostException\");\n+    } catch (Exception ex) {\n+      logger.info(\"Unexpected exception  {0}\", ex);\n+      fail(\"Got unexpected exception\");\n+    }\n+    logger.info(\"Curl command returns {0}\", result.toString());\n+    assertEquals(\"200\",result.stdout(),\"Datasource configuration not found\");\n+    logger.info(\"Found the DataSource configuration \");\n+  }\n+\n+  @AfterEach\n+  public void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  /**\n+   * Uninstall Operator, delete service account, domain namespace and\n+   * operator namespace.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86874f327e757ee7a6899eed5cd27d36528358c"}, "originalPosition": 504}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNjA3Nw==", "bodyText": "are these all common with the other file? consider refactoring", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414826077", "createdAt": "2020-04-24T19:54:42Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,669 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDeleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podTerminating;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  private String domainUid = \"domain1\";\n+  private String repoSecretName = \"reposecret\";\n+  private String miiImage = null;\n+  private String repoRegistry = \"dummy\";\n+  private String repoUserName = \"dummy\";\n+  private String repoPassword = \"dummy\";\n+  private String repoEmail = \"dummy\";\n+  private V1Patch patch = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = assertDoesNotThrow(() -> createUniqueNamespace(),\n+        \"Failed to create unique namespace due to ApiException\");\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = assertDoesNotThrow(() -> createUniqueNamespace(),\n+        \"Failed to create unique namespace due to ApiException\");\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    helmList(opHelmParams);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   *  Deploy a WebLogic domain with a defined configmap \n+   *  in configuration/model section of the domain resource.\n+   *  The configmap has a sparse wdt model file that define a JDBC \n+   *  datasource targeted to the cluster\n+  */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomainWithConfigMapOverride() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (System.getenv(\"REPO_REGISTRY\") != null && System.getenv(\"REPO_USERNAME\") != null\n+        && System.getenv(\"REPO_PASSWORD\") != null && System.getenv(\"REPO_EMAIL\") != null) {\n+      repoRegistry = System.getenv(\"REPO_REGISTRY\");\n+      repoUserName = System.getenv(\"REPO_USERNAME\");\n+      repoPassword = System.getenv(\"REPO_PASSWORD\");\n+      repoEmail = System.getenv(\"REPO_EMAIL\");\n+\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(repoRegistry, repoUserName, repoPassword), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // create docker registry secret in the domain namespace to pull the image from OCIR\n+    JsonObject dockerConfigJsonObject = getDockerConfigJson(\n+        repoUserName, repoPassword, repoEmail, repoRegistry);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(repoSecretName)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", repoSecretName));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", repoSecretName));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap();\n+    adminSecretMap.put(\"username\", \"weblogic\");\n+    adminSecretMap.put(\"password\", \"welcome1\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(adminSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    Map<String, String> encryptionSecretMap = new HashMap();\n+    encryptionSecretMap.put(\"username\", \"weblogicenc\");\n+    encryptionSecretMap.put(\"password\", \"weblogicenc\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(encryptionSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(encryptionSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", encryptionSecretName));\n+\n+    // add domain CR \n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(repoSecretName))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is running\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodRunning(adminServerPodName);\n+\n+    // check managed server pods are running\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managedserver pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodRunning(managedServerPrefix + i);\n+    }\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+    // Create a ConfigMap with a sparse jdbc model file\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    StringBuffer patchStr  = null;\n+\n+    cmData  = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\",cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMetaBuilder()\n+        .withLabels(labels)\n+        .withName(configMapName)\n+        .withNamespace(domainNamespace)\n+        .build();\n+    V1ConfigMap configMap = new V1ConfigMapBuilder()\n+        .withData(data)\n+        .withMetadata(meta)\n+        .build();\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    patchStr  = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+            .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+            .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+            .append(\" }]\");\n+    logger.log(Level.INFO, \"ConfigMap Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() -> \n+        patchDomainCustomResource(domainUid,domainNamespace,patch,\"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+\n+    patchStr  = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+            .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+            .append(\" \\\"value\\\": \\\"2\\\"\")\n+            .append(\" }]\");\n+    logger.log(Level.INFO, \"RestartVersion Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() -> \n+        patchDomainCustomResource(domainUid,domainNamespace,patch,\"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 60 secs for Introspector to kick off\");\n+    try { \n+      Thread.sleep(60000);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodDeleted(adminServerPodName);\n+    checkPodCreated(adminServerPodName);\n+    checkPodRunning(adminServerPodName);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server pods re-started sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in namespace {1}\",\n+                        managedServerPrefix + i, domainNamespace);\n+      checkPodDeleted(managedServerPrefix + i);\n+      checkPodRunning(managedServerPrefix + i);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null; \n+    try {\n+      String hostname = null;\n+      if (System.getenv(\"K8S_NODEPORT_HOST\") == null) {\n+        hostname = InetAddress.getLocalHost().getHostName();\n+      } else {\n+        hostname = System.getenv(\"K8S_NODEPORT_HOST\");\n+      }\n+      checkJdbc =  new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkJdbc.append(\"http://\" + hostname + \":30711\")\n+             .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+             .append(\" -o /dev/null\")\n+             .append(\" -w %{http_code});\")\n+             .append(\"echo ${status}\");      \n+      logger.info(\"CURL command {0}\", new String(checkJdbc));\n+      result = exec(new String(checkJdbc),true);\n+    } catch (java.net.UnknownHostException uhe) {\n+      logger.info(\"UnknownHostException is received {0}\", uhe);\n+      fail(\"Got UnknownHostException\");\n+    } catch (Exception ex) {\n+      logger.info(\"Unexpected exception  {0}\", ex);\n+      fail(\"Got unexpected exception\");\n+    }\n+    logger.info(\"Curl command returns {0}\", result.toString());\n+    assertEquals(\"200\",result.stdout(),\"Datasource configuration not found\");\n+    logger.info(\"Found the DataSource configuration \");\n+  }\n+\n+  @AfterEach\n+  public void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  /**\n+   * Uninstall Operator, delete service account, domain namespace and\n+   * operator namespace.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+    // uninstall operator release\n+    logger.info(\"Uninstall Operator in namespace {0}\", opNamespace);\n+    if (opHelmParams != null) {\n+      uninstallOperator(opHelmParams);\n+    }\n+    // Delete service account from unique opNamespace\n+    logger.info(\"Delete service account in namespace {0}\", opNamespace);\n+    if (serviceAccount != null) {\n+      assertDoesNotThrow(() -> deleteServiceAccount(serviceAccount.getMetadata().getName(),\n+              serviceAccount.getMetadata().getNamespace()),\n+              \"deleteServiceAccount failed with ApiException\");\n+    }\n+    // Delete domain namespaces\n+    logger.info(\"Deleting domain namespace {0}\", domainNamespace);\n+    if (domainNamespace != null) {\n+      assertDoesNotThrow(() -> deleteNamespace(domainNamespace),\n+          \"deleteNamespace failed with ApiException\");\n+      logger.info(\"Deleted namespace: \" + domainNamespace);\n+    }\n+\n+    // Delete opNamespace\n+    logger.info(\"Deleting Operator namespace {0}\", opNamespace);\n+    if (opNamespace != null) {\n+      assertDoesNotThrow(() -> deleteNamespace(opNamespace),\n+          \"deleteNamespace failed with ApiException\");\n+      logger.info(\"Deleted namespace: \" + opNamespace);\n+    }\n+\n+  }\n+\n+  private String createImageAndVerify() {\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+\n+    // build the model file list\n+    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    assertTrue(buildAppArchive(defaultAppParams()\n+        .srcDir(APP_NAME)), String.format(\"Failed to create app archive for %s\", APP_NAME));\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    final List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap<>();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    logger.info(\"Create image {0}:{1} using model directory {2}\",\n+        MII_IMAGE_NAME, imageTag, MODEL_DIR);\n+    boolean result = createMiiImage(\n+        defaultWitParams()\n+            .modelImageName(MII_IMAGE_NAME)\n+            .modelImageTag(imageTag)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(WDT_VERSION)\n+            .env(env)\n+            .redirect(true));\n+\n+    assertTrue(result, String.format(\"Failed to create the image %s using WebLogic Image Tool\", MII_IMAGE_NAME));\n+\n+    // check image exists\n+    assertTrue(dockerImageExists(MII_IMAGE_NAME, imageTag),\n+        String.format(\"Image %s doesn't exist\", MII_IMAGE_NAME + \":\" + imageTag));\n+\n+    return MII_IMAGE_NAME + \":\" + imageTag;\n+  }\n+\n+\n+  private void checkPodCreated(String podName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86874f327e757ee7a6899eed5cd27d36528358c"}, "originalPosition": 580}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNjE5OA==", "bodyText": "plural", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414826198", "createdAt": "2020-04-24T19:54:55Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -359,6 +360,16 @@ public static boolean deleteConfigMap(String name, String namespace) {\n     return ConfigMap.delete(name, namespace);\n   }\n \n+  /**\n+  * List Kubernetes Config Map in a namespace.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86874f327e757ee7a6899eed5cd27d36528358c"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNjQwNg==", "bodyText": "\"has been\" not \"is\"", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414826406", "createdAt": "2020-04-24T19:55:21Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -66,6 +65,20 @@\n     };\n   }\n \n+  /**\n+   * Check if a Kubernetes pod is deleted in the given namespace.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86874f327e757ee7a6899eed5cd27d36528358c"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNjQ5Mw==", "bodyText": "wasPodDeleted", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414826493", "createdAt": "2020-04-24T19:55:32Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -66,6 +65,20 @@\n     };\n   }\n \n+  /**\n+   * Check if a Kubernetes pod is deleted in the given namespace.\n+   *\n+   * @param podName   name of the pod to check for\n+   * @param domainUid UID of WebLogic domain in which the pod exists\n+   * @param namespace in which the pod does not exist\n+   * @return true if the pod does not exist in the namespace otherwise false\n+   */\n+  public static Callable<Boolean> podDeleted(String podName, String domainUid, String namespace) throws ApiException {\n+    return () -> {\n+      return Kubernetes.doesPodDeleted(namespace, domainUid, podName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86874f327e757ee7a6899eed5cd27d36528358c"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNzAzMA==", "bodyText": "wasPodDeleted is a better name, but this method does not actually test that a pod was deleted, it just just checks that the pod does not exist", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414827030", "createdAt": "2020-04-24T19:56:28Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -64,6 +64,29 @@ public static boolean doesPodExist(String namespace, String domainUid, String po\n     return podExist;\n   }\n \n+  /**\n+   * Checks if a pod does not exist in a given namespace in any state.\n+   * @param namespace in which to check for the pod existence\n+   * @param domainUid the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if pod does not exists otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean doesPodDeleted(String namespace, String domainUid, String podName) throws ApiException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86874f327e757ee7a6899eed5cd27d36528358c"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d98c87dd9be96a47c742c9e75dd05d4e46f20607", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d98c87dd9be96a47c742c9e75dd05d4e46f20607", "committedDate": "2020-04-25T13:49:31Z", "message": "addressed review comments. added new api to check the pod creation time stamp"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9219701f1b9950ac059774f9a65288b9f9071c2a", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9219701f1b9950ac059774f9a65288b9f9071c2a", "committedDate": "2020-04-25T13:49:51Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/80644934ba8a1b23761d3afc6a9f0ed3290db067", "committedDate": "2020-04-25T19:26:46Z", "message": "Modify the logic to check the pod creation time"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNDM3MDc2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-400437076", "createdAt": "2020-04-25T22:32:30Z", "commit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjozMjozMFrOGL7QUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjozMjozMFrOGL7QUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE1ODM1Mw==", "bodyText": "labelSelector in the format \"weblogic.domainUID in (%s)\" , can be null", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415158353", "createdAt": "2020-04-25T22:32:30Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -42,6 +45,40 @@\n // directly call the methods in the impl classes\n public class TestActions {\n \n+  // ----------------------   pod  ---------------------------------\n+  \n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod \n+   * @return creationTimestamp from metadata section of the Pod\n+   */\n+  public static String getPodCreationTime(String namespace, String labelSelector, String podName) {\n+    return Pod.getPodCreationTime(namespace,labelSelector,podName);\n+  }\n+ \n+  /**\n+   * Get the Pod object with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNDM3MDky", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-400437092", "createdAt": "2020-04-25T22:32:45Z", "commit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjozMjo0NVrOGL7Qcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjozMjo0NVrOGL7Qcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE1ODM4Nw==", "bodyText": "labelSelector in the format \"weblogic.domainUID in (%s)\", can be null", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415158387", "createdAt": "2020-04-25T22:32:45Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -42,6 +45,40 @@\n // directly call the methods in the impl classes\n public class TestActions {\n \n+  // ----------------------   pod  ---------------------------------\n+  \n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNDM3MTQy", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-400437142", "createdAt": "2020-04-25T22:33:28Z", "commit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjozMzoyOFrOGL7Q5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjozMzoyOFrOGL7Q5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE1ODUwMQ==", "bodyText": "white space between podName,namespace", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415158501", "createdAt": "2020-04-25T22:33:28Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -42,6 +45,40 @@\n // directly call the methods in the impl classes\n public class TestActions {\n \n+  // ----------------------   pod  ---------------------------------\n+  \n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod \n+   * @return creationTimestamp from metadata section of the Pod\n+   */\n+  public static String getPodCreationTime(String namespace, String labelSelector, String podName) {\n+    return Pod.getPodCreationTime(namespace,labelSelector,podName);\n+  }\n+ \n+  /**\n+   * Get the Pod object with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod \n+   * @return V1Pod pod object\n+   **/\n+  public static V1Pod getPod(String namespace, String labelSelector, String podName) {\n+    return Pod.getPod(namespace,labelSelector,podName);\n+  }\n+\n+  /**\n+   * Get a pod's log.\n+   * @param podName name of the Pod\n+   * @param namespace name of the Namespace\n+   * @return log as a String\n+   **/\n+  public static String getPodLog(String podName, String namespace) {\n+    return Pod.getPodLog(podName,namespace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNDM3MTcz", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-400437173", "createdAt": "2020-04-25T22:33:53Z", "commit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjozMzo1M1rOGL7ROQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjozMzo1M1rOGL7ROQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE1ODU4NQ==", "bodyText": "Namespace -> namespace", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415158585", "createdAt": "2020-04-25T22:33:53Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -42,6 +45,40 @@\n // directly call the methods in the impl classes\n public class TestActions {\n \n+  // ----------------------   pod  ---------------------------------\n+  \n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod \n+   * @return creationTimestamp from metadata section of the Pod\n+   */\n+  public static String getPodCreationTime(String namespace, String labelSelector, String podName) {\n+    return Pod.getPodCreationTime(namespace,labelSelector,podName);\n+  }\n+ \n+  /**\n+   * Get the Pod object with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod \n+   * @return V1Pod pod object\n+   **/\n+  public static V1Pod getPod(String namespace, String labelSelector, String podName) {\n+    return Pod.getPod(namespace,labelSelector,podName);\n+  }\n+\n+  /**\n+   * Get a pod's log.\n+   * @param podName name of the Pod\n+   * @param namespace name of the Namespace", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNDM3MTkw", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-400437190", "createdAt": "2020-04-25T22:34:08Z", "commit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjozNDowOFrOGL7RXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjozNDowOFrOGL7RXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE1ODYyMg==", "bodyText": "Pod -> pod", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415158622", "createdAt": "2020-04-25T22:34:08Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -42,6 +45,40 @@\n // directly call the methods in the impl classes\n public class TestActions {\n \n+  // ----------------------   pod  ---------------------------------\n+  \n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod \n+   * @return creationTimestamp from metadata section of the Pod\n+   */\n+  public static String getPodCreationTime(String namespace, String labelSelector, String podName) {\n+    return Pod.getPodCreationTime(namespace,labelSelector,podName);\n+  }\n+ \n+  /**\n+   * Get the Pod object with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod \n+   * @return V1Pod pod object\n+   **/\n+  public static V1Pod getPod(String namespace, String labelSelector, String podName) {\n+    return Pod.getPod(namespace,labelSelector,podName);\n+  }\n+\n+  /**\n+   * Get a pod's log.\n+   * @param podName name of the Pod", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNDM3NDA2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-400437406", "createdAt": "2020-04-25T22:37:34Z", "commit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjozNzozNFrOGL7Tfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjozNzozNFrOGL7Tfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE1OTE2Ng==", "bodyText": "Config Maps", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415159166", "createdAt": "2020-04-25T22:37:34Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -377,6 +414,16 @@ public static boolean deleteConfigMap(String name, String namespace) {\n     return ConfigMap.delete(name, namespace);\n   }\n \n+  /**\n+  * List Kubernetes Config Map(s) in a namespace.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNDM3NTE4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-400437518", "createdAt": "2020-04-25T22:39:20Z", "commit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjozOToyMFrOGL7Ujg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjozOToyMFrOGL7Ujg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE1OTQzOA==", "bodyText": "Map -> Maps", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415159438", "createdAt": "2020-04-25T22:39:20Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/ConfigMap.java", "diffHunk": "@@ -15,20 +16,35 @@\n    * @param configMap V1ConfigMap object containing config map configuration data\n    * @return true on success\n    * @throws ApiException if Kubernetes client API call fails\n-   */\n+  */\n   public static boolean create(V1ConfigMap configMap) throws ApiException {\n     return Kubernetes.createConfigMap(configMap);\n   }\n \n   /**\n-   /**\n    * Delete Kubernetes Config Map.\n    *\n    * @param name name of the Config Map\n    * @param namespace name of namespace\n    * @return true if successful, false otherwise\n-   */\n+  */\n   public static boolean delete(String name, String namespace) {\n     return Kubernetes.deleteConfigMap(name, namespace);\n   }\n+\n+  /**\n+   * List Kubernetes Config Map in a namesapce.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNDM3Nzg5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-400437789", "createdAt": "2020-04-25T22:43:24Z", "commit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjo0MzoyNFrOGL7XHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjo0MzoyNFrOGL7XHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MDA5NQ==", "bodyText": "follow consistent casing, List -> list", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415160095", "createdAt": "2020-04-25T22:43:24Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/ConfigMap.java", "diffHunk": "@@ -15,20 +16,35 @@\n    * @param configMap V1ConfigMap object containing config map configuration data\n    * @return true on success\n    * @throws ApiException if Kubernetes client API call fails\n-   */\n+  */\n   public static boolean create(V1ConfigMap configMap) throws ApiException {\n     return Kubernetes.createConfigMap(configMap);\n   }\n \n   /**\n-   /**\n    * Delete Kubernetes Config Map.\n    *\n    * @param name name of the Config Map\n    * @param namespace name of namespace\n    * @return true if successful, false otherwise\n-   */\n+  */\n   public static boolean delete(String name, String namespace) {\n     return Kubernetes.deleteConfigMap(name, namespace);\n   }\n+\n+  /**\n+   * List Kubernetes Config Map in a namesapce.\n+   *\n+   * @param namespace name of namespace\n+   * @return List of Config Maps in a namespace", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNDM4MTE3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-400438117", "createdAt": "2020-04-25T22:48:55Z", "commit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjo0ODo1NVrOGL7adg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjo0ODo1NVrOGL7adg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MDk1MA==", "bodyText": "Don't catch the exception here. Just return whatever Kubernetes.listConfigMaps(namespace) returns. The test needs to deal with the exception.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415160950", "createdAt": "2020-04-25T22:48:55Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/ConfigMap.java", "diffHunk": "@@ -15,20 +16,35 @@\n    * @param configMap V1ConfigMap object containing config map configuration data\n    * @return true on success\n    * @throws ApiException if Kubernetes client API call fails\n-   */\n+  */\n   public static boolean create(V1ConfigMap configMap) throws ApiException {\n     return Kubernetes.createConfigMap(configMap);\n   }\n \n   /**\n-   /**\n    * Delete Kubernetes Config Map.\n    *\n    * @param name name of the Config Map\n    * @param namespace name of namespace\n    * @return true if successful, false otherwise\n-   */\n+  */\n   public static boolean delete(String name, String namespace) {\n     return Kubernetes.deleteConfigMap(name, namespace);\n   }\n+\n+  /**\n+   * List Kubernetes Config Map in a namesapce.\n+   *\n+   * @param namespace name of namespace\n+   * @return List of Config Maps in a namespace\n+  */\n+  public static V1ConfigMapList list(String namespace) {\n+    V1ConfigMapList retConfigMapList = null;\n+    try {\n+      retConfigMapList = Kubernetes.listConfigMaps(namespace);\n+    } catch (ApiException api) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNDM4MTk4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-400438198", "createdAt": "2020-04-25T22:50:03Z", "commit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjo1MDowM1rOGL7bGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjo1MDowM1rOGL7bGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MTExNA==", "bodyText": "can you add some info here , Javadoc.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415161114", "createdAt": "2020-04-25T22:50:03Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,91 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+public class Pod {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "originalPosition": 11}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNDM4Mjc1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-400438275", "createdAt": "2020-04-25T22:51:04Z", "commit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjo1MTowNFrOGL7b0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjo1MTowNFrOGL7b0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MTI5Ng==", "bodyText": "Pod -> pod", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415161296", "createdAt": "2020-04-25T22:51:04Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,91 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+public class Pod {\n+\n+  /**\n+   * Delete Kubernetes Pod.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNDM4MzE4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-400438318", "createdAt": "2020-04-25T22:51:37Z", "commit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjo1MTozN1rOGL7cTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjo1MTozN1rOGL7cTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MTQyMQ==", "bodyText": "Pod(s) -> pods", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415161421", "createdAt": "2020-04-25T22:51:37Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,91 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+public class Pod {\n+\n+  /**\n+   * Delete Kubernetes Pod.\n+   *\n+   * @param name name of the pod\n+   * @param namespace name of namespace\n+   * @return true if successful, false otherwise\n+  */\n+  public static boolean deletePod(String name, String namespace) {\n+    return Kubernetes.deletePod(name, namespace);\n+  }\n+\n+  /**\n+   * List Kubernetes Pod(s) in a namesapce.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNDM4Mzkx", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-400438391", "createdAt": "2020-04-25T22:52:45Z", "commit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjo1Mjo0NlrOGL7c6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjo1Mjo0NlrOGL7c6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MTU3OQ==", "bodyText": "do not catch the exception here.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415161579", "createdAt": "2020-04-25T22:52:46Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,91 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+public class Pod {\n+\n+  /**\n+   * Delete Kubernetes Pod.\n+   *\n+   * @param name name of the pod\n+   * @param namespace name of namespace\n+   * @return true if successful, false otherwise\n+  */\n+  public static boolean deletePod(String name, String namespace) {\n+    return Kubernetes.deletePod(name, namespace);\n+  }\n+\n+  /**\n+   * List Kubernetes Pod(s) in a namesapce.\n+   *\n+   * @param namespace name of namespace\n+   * @param labelSelectors with which pods are decorated\n+   * @return V1PodList list of pods\n+  */\n+  public static V1PodList listPods(String namespace, String labelSelectors) {\n+    V1PodList retPodList = null;\n+    try {\n+      retPodList = Kubernetes.listPods(namespace,labelSelectors);\n+    } catch (ApiException api) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNDM4NDM4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-400438438", "createdAt": "2020-04-25T22:53:28Z", "commit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjo1MzoyOFrOGL7dZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjo1MzoyOFrOGL7dZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MTcwMw==", "bodyText": "do not catch the exception here.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415161703", "createdAt": "2020-04-25T22:53:28Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,91 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+public class Pod {\n+\n+  /**\n+   * Delete Kubernetes Pod.\n+   *\n+   * @param name name of the pod\n+   * @param namespace name of namespace\n+   * @return true if successful, false otherwise\n+  */\n+  public static boolean deletePod(String name, String namespace) {\n+    return Kubernetes.deletePod(name, namespace);\n+  }\n+\n+  /**\n+   * List Kubernetes Pod(s) in a namesapce.\n+   *\n+   * @param namespace name of namespace\n+   * @param labelSelectors with which pods are decorated\n+   * @return V1PodList list of pods\n+  */\n+  public static V1PodList listPods(String namespace, String labelSelectors) {\n+    V1PodList retPodList = null;\n+    try {\n+      retPodList = Kubernetes.listPods(namespace,labelSelectors);\n+    } catch (ApiException api) {\n+      return null;\n+    }\n+    return retPodList;\n+  }\n+\n+  /**\n+   * Get a pod's log.\n+   *  \n+   * @param podName name of the Pod\n+   * @param namespace name of the Namespace\n+   * @return log as a String\n+  */\n+  public static String getPodLog(String podName, String namespace) {\n+    try {\n+      return Kubernetes.getPodLog(podName,namespace);\n+    } catch (ApiException api) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNDM4NDU0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-400438454", "createdAt": "2020-04-25T22:53:45Z", "commit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjo1Mzo0NVrOGL7dmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjo1Mzo0NVrOGL7dmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MTc1Mw==", "bodyText": "Pod -> pod", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415161753", "createdAt": "2020-04-25T22:53:45Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,91 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+public class Pod {\n+\n+  /**\n+   * Delete Kubernetes Pod.\n+   *\n+   * @param name name of the pod\n+   * @param namespace name of namespace\n+   * @return true if successful, false otherwise\n+  */\n+  public static boolean deletePod(String name, String namespace) {\n+    return Kubernetes.deletePod(name, namespace);\n+  }\n+\n+  /**\n+   * List Kubernetes Pod(s) in a namesapce.\n+   *\n+   * @param namespace name of namespace\n+   * @param labelSelectors with which pods are decorated\n+   * @return V1PodList list of pods\n+  */\n+  public static V1PodList listPods(String namespace, String labelSelectors) {\n+    V1PodList retPodList = null;\n+    try {\n+      retPodList = Kubernetes.listPods(namespace,labelSelectors);\n+    } catch (ApiException api) {\n+      return null;\n+    }\n+    return retPodList;\n+  }\n+\n+  /**\n+   * Get a pod's log.\n+   *  \n+   * @param podName name of the Pod", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNDM4NDg4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-400438488", "createdAt": "2020-04-25T22:54:24Z", "commit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjo1NDoyNFrOGL7eAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjo1NDoyNFrOGL7eAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MTg1Ng==", "bodyText": "labelSelector in the format \"weblogic.domainUID in (%s)\", can be null", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415161856", "createdAt": "2020-04-25T22:54:24Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,91 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+public class Pod {\n+\n+  /**\n+   * Delete Kubernetes Pod.\n+   *\n+   * @param name name of the pod\n+   * @param namespace name of namespace\n+   * @return true if successful, false otherwise\n+  */\n+  public static boolean deletePod(String name, String namespace) {\n+    return Kubernetes.deletePod(name, namespace);\n+  }\n+\n+  /**\n+   * List Kubernetes Pod(s) in a namesapce.\n+   *\n+   * @param namespace name of namespace\n+   * @param labelSelectors with which pods are decorated\n+   * @return V1PodList list of pods\n+  */\n+  public static V1PodList listPods(String namespace, String labelSelectors) {\n+    V1PodList retPodList = null;\n+    try {\n+      retPodList = Kubernetes.listPods(namespace,labelSelectors);\n+    } catch (ApiException api) {\n+      return null;\n+    }\n+    return retPodList;\n+  }\n+\n+  /**\n+   * Get a pod's log.\n+   *  \n+   * @param podName name of the Pod\n+   * @param namespace name of the Namespace\n+   * @return log as a String\n+  */\n+  public static String getPodLog(String podName, String namespace) {\n+    try {\n+      return Kubernetes.getPodLog(podName,namespace);\n+    } catch (ApiException api) {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNDM4NTY3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-400438567", "createdAt": "2020-04-25T22:55:49Z", "commit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjo1NTo0OVrOGL7euA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjo1NTo0OVrOGL7euA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MjA0MA==", "bodyText": "do not catch the exception here.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415162040", "createdAt": "2020-04-25T22:55:49Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,91 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+public class Pod {\n+\n+  /**\n+   * Delete Kubernetes Pod.\n+   *\n+   * @param name name of the pod\n+   * @param namespace name of namespace\n+   * @return true if successful, false otherwise\n+  */\n+  public static boolean deletePod(String name, String namespace) {\n+    return Kubernetes.deletePod(name, namespace);\n+  }\n+\n+  /**\n+   * List Kubernetes Pod(s) in a namesapce.\n+   *\n+   * @param namespace name of namespace\n+   * @param labelSelectors with which pods are decorated\n+   * @return V1PodList list of pods\n+  */\n+  public static V1PodList listPods(String namespace, String labelSelectors) {\n+    V1PodList retPodList = null;\n+    try {\n+      retPodList = Kubernetes.listPods(namespace,labelSelectors);\n+    } catch (ApiException api) {\n+      return null;\n+    }\n+    return retPodList;\n+  }\n+\n+  /**\n+   * Get a pod's log.\n+   *  \n+   * @param podName name of the Pod\n+   * @param namespace name of the Namespace\n+   * @return log as a String\n+  */\n+  public static String getPodLog(String podName, String namespace) {\n+    try {\n+      return Kubernetes.getPodLog(podName,namespace);\n+    } catch (ApiException api) {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod \n+   * @return creationTimestamp from metadata section of the Pod\n+   */\n+  public static String getPodCreationTime(String namespace, String labelSelector, String podName) {\n+    try {\n+      return Kubernetes.getPodCreationTime(namespace,labelSelector,podName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNDM4NTc3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-400438577", "createdAt": "2020-04-25T22:55:55Z", "commit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjo1NTo1NVrOGL7ezw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjo1NTo1NVrOGL7ezw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MjA2Mw==", "bodyText": "do not catch the exception here.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415162063", "createdAt": "2020-04-25T22:55:55Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,91 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+public class Pod {\n+\n+  /**\n+   * Delete Kubernetes Pod.\n+   *\n+   * @param name name of the pod\n+   * @param namespace name of namespace\n+   * @return true if successful, false otherwise\n+  */\n+  public static boolean deletePod(String name, String namespace) {\n+    return Kubernetes.deletePod(name, namespace);\n+  }\n+\n+  /**\n+   * List Kubernetes Pod(s) in a namesapce.\n+   *\n+   * @param namespace name of namespace\n+   * @param labelSelectors with which pods are decorated\n+   * @return V1PodList list of pods\n+  */\n+  public static V1PodList listPods(String namespace, String labelSelectors) {\n+    V1PodList retPodList = null;\n+    try {\n+      retPodList = Kubernetes.listPods(namespace,labelSelectors);\n+    } catch (ApiException api) {\n+      return null;\n+    }\n+    return retPodList;\n+  }\n+\n+  /**\n+   * Get a pod's log.\n+   *  \n+   * @param podName name of the Pod\n+   * @param namespace name of the Namespace\n+   * @return log as a String\n+  */\n+  public static String getPodLog(String podName, String namespace) {\n+    try {\n+      return Kubernetes.getPodLog(podName,namespace);\n+    } catch (ApiException api) {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod \n+   * @return creationTimestamp from metadata section of the Pod\n+   */\n+  public static String getPodCreationTime(String namespace, String labelSelector, String podName) {\n+    try {\n+      return Kubernetes.getPodCreationTime(namespace,labelSelector,podName);\n+    } catch (ApiException api) {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Get the Pod object with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod \n+   * @return V1Pod pod object\n+   */\n+  public static V1Pod getPod(String namespace, String labelSelector, String podName) {\n+    try {\n+      V1PodList pods = Kubernetes.listPods(namespace, labelSelector);\n+      for (var pod : pods.getItems()) {\n+        if (podName.equals(pod.getMetadata().getName())) {\n+          return pod;\n+        }\n+      }\n+    } catch (ApiException api) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "originalPosition": 86}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNDM4NjI5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-400438629", "createdAt": "2020-04-25T22:56:32Z", "commit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjo1NjozMlrOGL7fYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjo1NjozMlrOGL7fYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MjIxMA==", "bodyText": "labelSelector in the format \"weblogic.domainUID in (%s)\", can be null", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415162210", "createdAt": "2020-04-25T22:56:32Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -257,6 +259,46 @@ public static V1DeploymentList listDeployments(String namespace) {\n   }\n \n   // --------------------------- pods -----------------------------------------\n+  \n+  /**\n+   * Returns the V1Pod object given the following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNDM4Njk5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-400438699", "createdAt": "2020-04-25T22:57:53Z", "commit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjo1Nzo1M1rOGL7gBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQyMjo1Nzo1M1rOGL7gBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MjM3NA==", "bodyText": "labelSelector in the format \"weblogic.domainUID in (%s)\", can be null", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415162374", "createdAt": "2020-04-25T22:57:53Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -257,6 +259,46 @@ public static V1DeploymentList listDeployments(String namespace) {\n   }\n \n   // --------------------------- pods -----------------------------------------\n+  \n+  /**\n+   * Returns the V1Pod object given the following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod to return\n+   * @return V1Pod object if found otherwise null\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static V1Pod getPod(String namespace, String labelSelector, String podName) throws ApiException {\n+    V1PodList pods = listPods(namespace, labelSelector);\n+    for (var pod : pods.getItems()) {\n+      if (podName.equals(pod.getMetadata().getName())) {\n+        return pod;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "originalPosition": 35}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2ee098d18c9d11c8c1e10443864e364c168c01e", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c2ee098d18c9d11c8c1e10443864e364c168c01e", "committedDate": "2020-04-26T19:51:18Z", "message": "Resolved more PR review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNTk3MjA4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-400597208", "createdAt": "2020-04-27T02:53:45Z", "commit": {"oid": "c2ee098d18c9d11c8c1e10443864e364c168c01e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwMjo1Mzo0NVrOGMOlJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwMzozMjowNFrOGMPPjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ3NDk4Mg==", "bodyText": "fix javadoc", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415474982", "createdAt": "2020-04-27T02:53:45Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,603 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2ee098d18c9d11c8c1e10443864e364c168c01e"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ3NzA2NA==", "bodyText": "no need to use builder, you can do\nV1ObjectMeta meta = new V1ObjectMeta()\n  .labels(labels)\n  .name(configMapName)\n  .namespace(domainNamespace);", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415477064", "createdAt": "2020-04-27T03:00:47Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,603 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   *  Deploy a WebLogic domain with a defined configmap \n+   *  in configuration/model section of the domain resource.\n+   *  The configmap has a sparse wdt model file that define a JDBC \n+   *  datasource targeted to the cluster\n+   *  Once the WebLogic domain is up, verify the DataSource configuration \n+   *  using the RestAPI call thru adminserver public NodePort\n+  */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with a configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap();\n+    adminSecretMap.put(\"username\", \"weblogic\");\n+    adminSecretMap.put(\"password\", \"welcome1\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(adminSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    Map<String, String> encryptionSecretMap = new HashMap();\n+    encryptionSecretMap.put(\"username\", \"weblogicenc\");\n+    encryptionSecretMap.put(\"password\", \"weblogicenc\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(encryptionSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(encryptionSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", encryptionSecretName));\n+\n+    // Create a ConfigMap with a sparse jdbc model file\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData  = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\",cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMetaBuilder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2ee098d18c9d11c8c1e10443864e364c168c01e"}, "originalPosition": 312}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ3NzUyMg==", "bodyText": "same here, no need for builder", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415477522", "createdAt": "2020-04-27T03:02:11Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,603 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   *  Deploy a WebLogic domain with a defined configmap \n+   *  in configuration/model section of the domain resource.\n+   *  The configmap has a sparse wdt model file that define a JDBC \n+   *  datasource targeted to the cluster\n+   *  Once the WebLogic domain is up, verify the DataSource configuration \n+   *  using the RestAPI call thru adminserver public NodePort\n+  */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with a configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap();\n+    adminSecretMap.put(\"username\", \"weblogic\");\n+    adminSecretMap.put(\"password\", \"welcome1\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(adminSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    Map<String, String> encryptionSecretMap = new HashMap();\n+    encryptionSecretMap.put(\"username\", \"weblogicenc\");\n+    encryptionSecretMap.put(\"password\", \"weblogicenc\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(encryptionSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(encryptionSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", encryptionSecretName));\n+\n+    // Create a ConfigMap with a sparse jdbc model file\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData  = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\",cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMetaBuilder()\n+        .withLabels(labels)\n+        .withName(configMapName)\n+        .withNamespace(domainNamespace)\n+        .build();\n+    V1ConfigMap configMap = new V1ConfigMapBuilder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2ee098d18c9d11c8c1e10443864e364c168c01e"}, "originalPosition": 317}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ3NzcwNQ==", "bodyText": "set '0'", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415477705", "createdAt": "2020-04-27T03:02:56Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,603 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   *  Deploy a WebLogic domain with a defined configmap \n+   *  in configuration/model section of the domain resource.\n+   *  The configmap has a sparse wdt model file that define a JDBC \n+   *  datasource targeted to the cluster\n+   *  Once the WebLogic domain is up, verify the DataSource configuration \n+   *  using the RestAPI call thru adminserver public NodePort\n+  */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with a configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap();\n+    adminSecretMap.put(\"username\", \"weblogic\");\n+    adminSecretMap.put(\"password\", \"welcome1\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(adminSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    Map<String, String> encryptionSecretMap = new HashMap();\n+    encryptionSecretMap.put(\"username\", \"weblogicenc\");\n+    encryptionSecretMap.put(\"password\", \"weblogicenc\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(encryptionSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(encryptionSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", encryptionSecretName));\n+\n+    // Create a ConfigMap with a sparse jdbc model file\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData  = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\",cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMetaBuilder()\n+        .withLabels(labels)\n+        .withName(configMapName)\n+        .withNamespace(domainNamespace)\n+        .build();\n+    V1ConfigMap configMap = new V1ConfigMapBuilder()\n+        .withData(data)\n+        .withMetadata(meta)\n+        .build();\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // Create the domain custom resource with a predefined configmap \n+    // in configuration/model section\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2ee098d18c9d11c8c1e10443864e364c168c01e"}, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ3Nzg2Nw==", "bodyText": "typo resource", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415477867", "createdAt": "2020-04-27T03:03:25Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,603 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   *  Deploy a WebLogic domain with a defined configmap \n+   *  in configuration/model section of the domain resource.\n+   *  The configmap has a sparse wdt model file that define a JDBC \n+   *  datasource targeted to the cluster\n+   *  Once the WebLogic domain is up, verify the DataSource configuration \n+   *  using the RestAPI call thru adminserver public NodePort\n+  */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with a configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap();\n+    adminSecretMap.put(\"username\", \"weblogic\");\n+    adminSecretMap.put(\"password\", \"welcome1\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(adminSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    Map<String, String> encryptionSecretMap = new HashMap();\n+    encryptionSecretMap.put(\"username\", \"weblogicenc\");\n+    encryptionSecretMap.put(\"password\", \"weblogicenc\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(encryptionSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(encryptionSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", encryptionSecretName));\n+\n+    // Create a ConfigMap with a sparse jdbc model file\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData  = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\",cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMetaBuilder()\n+        .withLabels(labels)\n+        .withName(configMapName)\n+        .withNamespace(domainNamespace)\n+        .build();\n+    V1ConfigMap configMap = new V1ConfigMapBuilder()\n+        .withData(data)\n+        .withMetadata(meta)\n+        .build();\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // Create the domain custom resource with a predefined configmap \n+    // in configuration/model section\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .configMap(configMapName)\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUID {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2ee098d18c9d11c8c1e10443864e364c168c01e"}, "originalPosition": 378}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ3OTUwNg==", "bodyText": "using hard coded node port does not work if the port is already in use.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415479506", "createdAt": "2020-04-27T03:09:16Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,603 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   *  Deploy a WebLogic domain with a defined configmap \n+   *  in configuration/model section of the domain resource.\n+   *  The configmap has a sparse wdt model file that define a JDBC \n+   *  datasource targeted to the cluster\n+   *  Once the WebLogic domain is up, verify the DataSource configuration \n+   *  using the RestAPI call thru adminserver public NodePort\n+  */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with a configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap();\n+    adminSecretMap.put(\"username\", \"weblogic\");\n+    adminSecretMap.put(\"password\", \"welcome1\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(adminSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    Map<String, String> encryptionSecretMap = new HashMap();\n+    encryptionSecretMap.put(\"username\", \"weblogicenc\");\n+    encryptionSecretMap.put(\"password\", \"weblogicenc\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(encryptionSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(encryptionSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", encryptionSecretName));\n+\n+    // Create a ConfigMap with a sparse jdbc model file\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData  = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\",cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMetaBuilder()\n+        .withLabels(labels)\n+        .withName(configMapName)\n+        .withNamespace(domainNamespace)\n+        .build();\n+    V1ConfigMap configMap = new V1ConfigMapBuilder()\n+        .withData(data)\n+        .withMetadata(meta)\n+        .build();\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // Create the domain custom resource with a predefined configmap \n+    // in configuration/model section\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ3NzcwNQ=="}, "originalCommit": {"oid": "c2ee098d18c9d11c8c1e10443864e364c168c01e"}, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ4MDU4NA==", "bodyText": "Add this to TestConstants.java and use K8S_NODEPORT_HOST in place of host name\n  public static final String K8S_NODEPORT_HOST = Optional.ofNullable(System.getenv(\"K8S_NODEPORT_HOST\"))\n      .orElse(InetAddress.getLocalHost().getHostName());", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415480584", "createdAt": "2020-04-27T03:13:11Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,603 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   *  Deploy a WebLogic domain with a defined configmap \n+   *  in configuration/model section of the domain resource.\n+   *  The configmap has a sparse wdt model file that define a JDBC \n+   *  datasource targeted to the cluster\n+   *  Once the WebLogic domain is up, verify the DataSource configuration \n+   *  using the RestAPI call thru adminserver public NodePort\n+  */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with a configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap();\n+    adminSecretMap.put(\"username\", \"weblogic\");\n+    adminSecretMap.put(\"password\", \"welcome1\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(adminSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    Map<String, String> encryptionSecretMap = new HashMap();\n+    encryptionSecretMap.put(\"username\", \"weblogicenc\");\n+    encryptionSecretMap.put(\"password\", \"weblogicenc\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(encryptionSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(encryptionSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", encryptionSecretName));\n+\n+    // Create a ConfigMap with a sparse jdbc model file\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData  = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\",cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMetaBuilder()\n+        .withLabels(labels)\n+        .withName(configMapName)\n+        .withNamespace(domainNamespace)\n+        .build();\n+    V1ConfigMap configMap = new V1ConfigMapBuilder()\n+        .withData(data)\n+        .withMetadata(meta)\n+        .build();\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // Create the domain custom resource with a predefined configmap \n+    // in configuration/model section\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .configMap(configMapName)\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUID {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is running\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodRunning(adminServerPodName);\n+\n+    // check managed server pods are running\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodRunning(managedServerPrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null; \n+    try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2ee098d18c9d11c8c1e10443864e364c168c01e"}, "originalPosition": 426}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ4MTkyMw==", "bodyText": "fix javadoc", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415481923", "createdAt": "2020-04-27T03:17:59Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,603 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2ee098d18c9d11c8c1e10443864e364c168c01e"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ4MjQ0NQ==", "bodyText": "change test method name to testCreateMiiDomainWithConfigMap", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415482445", "createdAt": "2020-04-27T03:19:42Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,603 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   *  Deploy a WebLogic domain with a defined configmap \n+   *  in configuration/model section of the domain resource.\n+   *  The configmap has a sparse wdt model file that define a JDBC \n+   *  datasource targeted to the cluster\n+   *  Once the WebLogic domain is up, verify the DataSource configuration \n+   *  using the RestAPI call thru adminserver public NodePort\n+  */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with a configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2ee098d18c9d11c8c1e10443864e364c168c01e"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ4NTgzNg==", "bodyText": "Same review comments as the above test, have not reviewed this test yet..", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415485836", "createdAt": "2020-04-27T03:32:04Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.wasPodDeleted;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2ee098d18c9d11c8c1e10443864e364c168c01e"}, "originalPosition": 113}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77c8bc0e0cec78d0ae266c6ccc8cfcbc76f050fa", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/77c8bc0e0cec78d0ae266c6ccc8cfcbc76f050fa", "committedDate": "2020-04-27T15:15:47Z", "message": "Resolution to more review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "119ce1ff79210ab5ed00673b535f9905fe6552df", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/119ce1ff79210ab5ed00673b535f9905fe6552df", "committedDate": "2020-04-27T23:45:46Z", "message": "Added support to get K8s Service Object"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b29862650ccb0fbfedcd068d5ae327f1247b13b", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8b29862650ccb0fbfedcd068d5ae327f1247b13b", "committedDate": "2020-04-27T23:45:57Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2f71763bc83235b773f4954bf004c2ca7365075", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c2f71763bc83235b773f4954bf004c2ca7365075", "committedDate": "2020-04-28T02:27:28Z", "message": "Modified the getService() logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdc0f5938843fe5d86793512b020a9df6ea40930", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/fdc0f5938843fe5d86793512b020a9df6ea40930", "committedDate": "2020-04-28T15:49:40Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "068ed5936bd1546c52428032f1b5f4d53452a30b", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/068ed5936bd1546c52428032f1b5f4d53452a30b", "committedDate": "2020-04-28T15:54:31Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45d24d6dc3397ec40ba5de363a06d929d8b66e52", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/45d24d6dc3397ec40ba5de363a06d929d8b66e52", "committedDate": "2020-04-29T00:25:02Z", "message": "Added support for getAdminNodePort and K8S_NODEPORT_HOST"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05a190cd33ce3a292be74ae9478bdb6be10a3e42", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/05a190cd33ce3a292be74ae9478bdb6be10a3e42", "committedDate": "2020-04-29T00:25:13Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5325aa4567f379a0ccb384cd0c25dd4e9a44d508", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5325aa4567f379a0ccb384cd0c25dd4e9a44d508", "committedDate": "2020-04-29T23:55:36Z", "message": "Code format using intelij"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "203a79a89e14b4e07a97c546e94d4db5b434500f", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/203a79a89e14b4e07a97c546e94d4db5b434500f", "committedDate": "2020-05-01T23:55:26Z", "message": "Sync up develop branch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84a42c35d64b9477e9d4d17ec12be742def63bb0", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/84a42c35d64b9477e9d4d17ec12be742def63bb0", "committedDate": "2020-05-04T15:03:42Z", "message": "Syncup develop branch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60faefa0a4d2f589f7a1573b7ab7c4a65e5d234b", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/60faefa0a4d2f589f7a1573b7ab7c4a65e5d234b", "committedDate": "2020-05-05T16:21:59Z", "message": "Uddate to javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3d897a07beb2df97f491e21d7023b22980df588d", "committedDate": "2020-05-05T17:12:25Z", "message": "Sync up develop branch"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MDE0MTEw", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-406014110", "createdAt": "2020-05-05T17:41:45Z", "commit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzo0MTo0NVrOGQ0hSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzo0MTo0NVrOGQ0hSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MDg4OQ==", "bodyText": "Sankar's changes are in, so we should remove this.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420290889", "createdAt": "2020-05-05T17:41:45Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,610 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Deploy a WebLogic domain with a defined ConfigMap.\n+   * in configuration/model section of the domain resource\n+   * The ConfigMap has a sparse wdt model file that define a JDBC DataSource \n+   * targeted to the cluster\n+   * Once the WebLogic domain is up, verify the DataSource configuration\n+   * using the RestAPI call thru adminserver's  public NodePort\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with a configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigMapDomain() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, \n+              REPO_SECRET_NAME, encryptionSecretName, \n+              replicaCount, configMapName);\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    try {\n+      checkJdbc = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkJdbc.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null \")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+      logger.info(\"CURL command {0}\", new String(checkJdbc));\n+      result = exec(new String(checkJdbc), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Caught unexpected exception {0}\", ex);\n+      fail(\"Got unexpected exception\" + ex);\n+    }\n+\n+    logger.info(\"Curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"Datasource configuration not found\");\n+    logger.info(\"Found the DataSource configuration \");\n+\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 389}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MDE1MTY1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-406015165", "createdAt": "2020-05-05T17:43:05Z", "commit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzo0MzowNVrOGQ0kgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzo0MzowNVrOGQ0kgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MTcxMw==", "bodyText": "409 means \"conflict\".  A change has been made since the last time you read the resource.  It's an optimistic locking  failure.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420291713", "createdAt": "2020-05-05T17:43:05Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,610 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Deploy a WebLogic domain with a defined ConfigMap.\n+   * in configuration/model section of the domain resource\n+   * The ConfigMap has a sparse wdt model file that define a JDBC DataSource \n+   * targeted to the cluster\n+   * Once the WebLogic domain is up, verify the DataSource configuration\n+   * using the RestAPI call thru adminserver's  public NodePort\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with a configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigMapDomain() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, \n+              REPO_SECRET_NAME, encryptionSecretName, \n+              replicaCount, configMapName);\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    try {\n+      checkJdbc = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkJdbc.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null \")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+      logger.info(\"CURL command {0}\", new String(checkJdbc));\n+      result = exec(new String(checkJdbc), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Caught unexpected exception {0}\", ex);\n+      fail(\"Got unexpected exception\" + ex);\n+    }\n+\n+    logger.info(\"Curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"Datasource configuration not found\");\n+    logger.info(\"Found the DataSource configuration \");\n+\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  private String createImageAndVerify() {\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageName = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? MII_IMAGE_NAME : REPO_NAME + MII_IMAGE_NAME;\n+    final String image = imageName + \":\" + imageTag;\n+\n+    // build the model file list\n+    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    assertTrue(buildAppArchive(defaultAppParams()\n+        .srcDir(APP_NAME)), String.format(\"Failed to create app archive for %s\", APP_NAME));\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    final List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap<>();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    logger.info(\"Create image {0} using model directory {1}\", image, MODEL_DIR);\n+    boolean result = createMiiImage(\n+        defaultWitParams()\n+            .modelImageName(imageName)\n+            .modelImageTag(imageTag)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(WDT_VERSION)\n+            .env(env)\n+            .redirect(true));\n+\n+    assertTrue(result, String.format(\"Failed to create the image %s using WebLogic Image Tool\", image));\n+\n+    /* Check image exists using docker images | grep image tag.\n+     * Tag name is unique as it contains date and timestamp.\n+     * This is a workaround for the issue on Jenkins machine\n+     * as docker images imagename:imagetag is not working and\n+     * the test fails even though the image exists.\n+     */\n+    assertTrue(doesImageExist(imageTag),\n+        String.format(\"Image %s doesn't exist\", image));\n+\n+    return image;\n+  }\n+\n+  private void createRepoSecret(String domNamespace) throws ApiException {\n+    V1Secret repoSecret = new V1Secret()\n+            .metadata(new V1ObjectMeta()\n+                    .name(REPO_SECRET_NAME)\n+                    .namespace(domNamespace))\n+            .type(\"kubernetes.io/dockerconfigjson\")\n+            .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = false;\n+    try {\n+      secretCreated = createSecret(repoSecret);\n+    } catch (ApiException e) {\n+      logger.info(\"Exception when calling CoreV1Api#createNamespacedSecret\");\n+      logger.info(\"Status code: \" + e.getCode());\n+      logger.info(\"Reason: \" + e.getResponseBody());\n+      logger.info(\"Response headers: \" + e.getResponseHeaders());\n+      //409 means that the secret already exists - it is not an error, so can proceed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 467}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MDE5MjM0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-406019234", "createdAt": "2020-05-05T17:48:36Z", "commit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MjMyOTE0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-406232914", "createdAt": "2020-05-05T23:57:07Z", "commit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMzo1NzowN1rOGQ_0KA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMDoyMzozNlrOGRARjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3NTk0NA==", "bodyText": "we already have a method to check if a pod exist doesPodExist() , why not use that and negate the results?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420475944", "createdAt": "2020-05-05T23:57:07Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -64,6 +64,29 @@ public static boolean doesPodExist(String namespace, String domainUid, String po\n     return podExist;\n   }\n \n+  /**\n+   * Checks if a pod does not exist in a given namespace in any state.\n+   * @param namespace in which to check for the pod existence\n+   * @param domainUid the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if pod does not exists otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean doesPodNotExist(String namespace, String domainUid, String podName) throws ApiException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3NzExMA==", "bodyText": "Can we not use this method for any server to get the service node port?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420477110", "createdAt": "2020-05-06T00:01:11Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1406,8 +1446,87 @@ public static V1ServiceList listServices(String namespace) {\n     }\n   }\n \n-  // --------------------------- jobs ---------------------------\n+  /**\n+   * Get V1Service object for the given service name, label and namespace.\n+   *\n+   * @param serviceName name of the service to look for\n+   * @param label  key value pair with which the service is decorated with\n+   * @param namespace namespace in which to check for the service\n+   * @return V1Service object if found otherwise null\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static V1Service getService(\n+      String serviceName, Map<String, String> label, String namespace)\n+      throws ApiException {\n+    String labelSelector = null;\n+    if (label != null) {\n+      String key = label.keySet().iterator().next().toString();\n+      String value = label.get(key).toString();\n+      labelSelector = String.format(\"%s in (%s)\", key, value);\n+      logger.info(labelSelector);\n+    }\n+    V1ServiceList v1ServiceList\n+        = coreV1Api.listServiceForAllNamespaces(\n+        Boolean.FALSE, // allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+        null, // continue to query when there is more results to return.\n+        null, // selector to restrict the list of returned objects by their fields\n+        labelSelector, // selector to restrict the list of returned objects by their labels.\n+        null, // maximum number of responses to return for a list call.\n+        Boolean.FALSE.toString(), // pretty print output.\n+        null, // shows changes that occur after that particular version of a resource.\n+        null, // Timeout for the list/watch call.\n+        Boolean.FALSE // Watch for changes to the described resources.\n+    );\n+    for (V1Service service : v1ServiceList.getItems()) {\n+      if (service.getMetadata().getName().equals(serviceName.trim())\n+          && service.getMetadata().getNamespace().equals(namespace.trim())) {\n+        logger.info(\"Service Name : \" + service.getMetadata().getName());\n+        logger.info(\"Service Namespace : \" + service.getMetadata().getNamespace());\n+        Map<String, String> labels = service.getMetadata().getLabels();\n+        if (labels != null) {\n+          for (Map.Entry<String, String> entry : labels.entrySet()) {\n+            logger.log(Level.INFO, \"Label Key: {0} Label Value: {1}\",\n+                new Object[]{entry.getKey(), entry.getValue()});\n+          }\n+        }\n+        return service;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Returns NodePort of a admin server service.\n+   *\n+   * @param serviceName name of admin server service\n+   * @param label key value pair with which the service is decorated with\n+   * @param namespace namespace in which to check for the service\n+   * @return AdminNodePort of the Kubernetes service if exits else -1\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static int getAdminServiceNodePort(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3Nzc5Mg==", "bodyText": "exits -> exists", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420477792", "createdAt": "2020-05-06T00:03:35Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1406,8 +1446,87 @@ public static V1ServiceList listServices(String namespace) {\n     }\n   }\n \n-  // --------------------------- jobs ---------------------------\n+  /**\n+   * Get V1Service object for the given service name, label and namespace.\n+   *\n+   * @param serviceName name of the service to look for\n+   * @param label  key value pair with which the service is decorated with\n+   * @param namespace namespace in which to check for the service\n+   * @return V1Service object if found otherwise null\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static V1Service getService(\n+      String serviceName, Map<String, String> label, String namespace)\n+      throws ApiException {\n+    String labelSelector = null;\n+    if (label != null) {\n+      String key = label.keySet().iterator().next().toString();\n+      String value = label.get(key).toString();\n+      labelSelector = String.format(\"%s in (%s)\", key, value);\n+      logger.info(labelSelector);\n+    }\n+    V1ServiceList v1ServiceList\n+        = coreV1Api.listServiceForAllNamespaces(\n+        Boolean.FALSE, // allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+        null, // continue to query when there is more results to return.\n+        null, // selector to restrict the list of returned objects by their fields\n+        labelSelector, // selector to restrict the list of returned objects by their labels.\n+        null, // maximum number of responses to return for a list call.\n+        Boolean.FALSE.toString(), // pretty print output.\n+        null, // shows changes that occur after that particular version of a resource.\n+        null, // Timeout for the list/watch call.\n+        Boolean.FALSE // Watch for changes to the described resources.\n+    );\n+    for (V1Service service : v1ServiceList.getItems()) {\n+      if (service.getMetadata().getName().equals(serviceName.trim())\n+          && service.getMetadata().getNamespace().equals(namespace.trim())) {\n+        logger.info(\"Service Name : \" + service.getMetadata().getName());\n+        logger.info(\"Service Namespace : \" + service.getMetadata().getNamespace());\n+        Map<String, String> labels = service.getMetadata().getLabels();\n+        if (labels != null) {\n+          for (Map.Entry<String, String> entry : labels.entrySet()) {\n+            logger.log(Level.INFO, \"Label Key: {0} Label Value: {1}\",\n+                new Object[]{entry.getKey(), entry.getValue()});\n+          }\n+        }\n+        return service;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Returns NodePort of a admin server service.\n+   *\n+   * @param serviceName name of admin server service\n+   * @param label key value pair with which the service is decorated with\n+   * @param namespace namespace in which to check for the service\n+   * @return AdminNodePort of the Kubernetes service if exits else -1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3ODQ4Ng==", "bodyText": "check for empty port list too.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420478486", "createdAt": "2020-05-06T00:05:56Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1406,8 +1446,87 @@ public static V1ServiceList listServices(String namespace) {\n     }\n   }\n \n-  // --------------------------- jobs ---------------------------\n+  /**\n+   * Get V1Service object for the given service name, label and namespace.\n+   *\n+   * @param serviceName name of the service to look for\n+   * @param label  key value pair with which the service is decorated with\n+   * @param namespace namespace in which to check for the service\n+   * @return V1Service object if found otherwise null\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static V1Service getService(\n+      String serviceName, Map<String, String> label, String namespace)\n+      throws ApiException {\n+    String labelSelector = null;\n+    if (label != null) {\n+      String key = label.keySet().iterator().next().toString();\n+      String value = label.get(key).toString();\n+      labelSelector = String.format(\"%s in (%s)\", key, value);\n+      logger.info(labelSelector);\n+    }\n+    V1ServiceList v1ServiceList\n+        = coreV1Api.listServiceForAllNamespaces(\n+        Boolean.FALSE, // allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+        null, // continue to query when there is more results to return.\n+        null, // selector to restrict the list of returned objects by their fields\n+        labelSelector, // selector to restrict the list of returned objects by their labels.\n+        null, // maximum number of responses to return for a list call.\n+        Boolean.FALSE.toString(), // pretty print output.\n+        null, // shows changes that occur after that particular version of a resource.\n+        null, // Timeout for the list/watch call.\n+        Boolean.FALSE // Watch for changes to the described resources.\n+    );\n+    for (V1Service service : v1ServiceList.getItems()) {\n+      if (service.getMetadata().getName().equals(serviceName.trim())\n+          && service.getMetadata().getNamespace().equals(namespace.trim())) {\n+        logger.info(\"Service Name : \" + service.getMetadata().getName());\n+        logger.info(\"Service Namespace : \" + service.getMetadata().getNamespace());\n+        Map<String, String> labels = service.getMetadata().getLabels();\n+        if (labels != null) {\n+          for (Map.Entry<String, String> entry : labels.entrySet()) {\n+            logger.log(Level.INFO, \"Label Key: {0} Label Value: {1}\",\n+                new Object[]{entry.getKey(), entry.getValue()});\n+          }\n+        }\n+        return service;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Returns NodePort of a admin server service.\n+   *\n+   * @param serviceName name of admin server service\n+   * @param label key value pair with which the service is decorated with\n+   * @param namespace namespace in which to check for the service\n+   * @return AdminNodePort of the Kubernetes service if exits else -1\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static int getAdminServiceNodePort(\n+      String serviceName,\n+      Map<String, String> label,\n+      String namespace) throws ApiException {\n \n+    V1Service service = getService(serviceName, label, namespace);\n+    if (service == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4MDgyMA==", "bodyText": "there is a name spaced list method for service. So you don't need to iterate through the service object to match the  namespace.\ncoreV1Api.listNamespacedService(......)", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420480820", "createdAt": "2020-05-06T00:14:16Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1406,8 +1446,87 @@ public static V1ServiceList listServices(String namespace) {\n     }\n   }\n \n-  // --------------------------- jobs ---------------------------\n+  /**\n+   * Get V1Service object for the given service name, label and namespace.\n+   *\n+   * @param serviceName name of the service to look for\n+   * @param label  key value pair with which the service is decorated with\n+   * @param namespace namespace in which to check for the service\n+   * @return V1Service object if found otherwise null\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static V1Service getService(\n+      String serviceName, Map<String, String> label, String namespace)\n+      throws ApiException {\n+    String labelSelector = null;\n+    if (label != null) {\n+      String key = label.keySet().iterator().next().toString();\n+      String value = label.get(key).toString();\n+      labelSelector = String.format(\"%s in (%s)\", key, value);\n+      logger.info(labelSelector);\n+    }\n+    V1ServiceList v1ServiceList", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4MjUwNQ==", "bodyText": "why are you throwing a null here instead of the original ApiException ?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420482505", "createdAt": "2020-05-06T00:20:10Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -454,7 +494,7 @@ public static V1PodList listPods(String namespace, String labelSelectors) throws\n           );\n     } catch (ApiException apex) {\n       logger.severe(apex.getResponseBody());\n-      throw apex;\n+      throw null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4Mjk5Mw==", "bodyText": "Get the creationTimestamp of a pod", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420482993", "createdAt": "2020-05-06T00:21:54Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -428,15 +430,53 @@ public static boolean deletePod(String name, String namespace) {\n     return true;\n   }\n \n+  /**\n+   * Returns the V1Pod object given the following parameters.\n+   *\n+   * @param namespace     in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName       name of the pod to return\n+   * @return V1Pod object if found otherwise null\n+   */\n+  public static V1Pod getPod(String namespace, String labelSelector, String podName) {\n+    V1PodList pods = listPods(namespace, labelSelector);\n+    for (var pod : pods.getItems()) {\n+      if (podName.equals(pod.getMetadata().getName())) {\n+        return pod;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4MzQ2OQ==", "bodyText": "Are there any reason you are returning a String instead of DateTime ?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420483469", "createdAt": "2020-05-06T00:23:36Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -428,15 +430,53 @@ public static boolean deletePod(String name, String namespace) {\n     return true;\n   }\n \n+  /**\n+   * Returns the V1Pod object given the following parameters.\n+   *\n+   * @param namespace     in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName       name of the pod to return\n+   * @return V1Pod object if found otherwise null\n+   */\n+  public static V1Pod getPod(String namespace, String labelSelector, String podName) {\n+    V1PodList pods = listPods(namespace, labelSelector);\n+    for (var pod : pods.getItems()) {\n+      if (podName.equals(pod.getMetadata().getName())) {\n+        return pod;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.\n+   *\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName  name of the pod\n+   * @return creationTimestamp from metadata section of the Pod\n+   */\n+  public static String getPodCreationTimestamp(String namespace, String labelSelector, String podName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 93}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MjY4MzIw", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-406268320", "createdAt": "2020-05-06T02:16:16Z", "commit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "state": "COMMENTED", "comments": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMjoxNjoxNlrOGRB7lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMjozMjo0OVrOGRCKlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMDYxNA==", "bodyText": "operator - no capital", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420510614", "createdAt": "2020-05-06T02:16:16Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,610 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMDc4NA==", "bodyText": "start sentence with capital", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420510784", "createdAt": "2020-05-06T02:16:59Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,610 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Deploy a WebLogic domain with a defined ConfigMap.\n+   * in configuration/model section of the domain resource", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMDg0Mg==", "bodyText": "actually this sentence makes no sense", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420510842", "createdAt": "2020-05-06T02:17:13Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,610 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Deploy a WebLogic domain with a defined ConfigMap.\n+   * in configuration/model section of the domain resource", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMDc4NA=="}, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMDg2Nw==", "bodyText": "WDT", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420510867", "createdAt": "2020-05-06T02:17:20Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,610 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Deploy a WebLogic domain with a defined ConfigMap.\n+   * in configuration/model section of the domain resource\n+   * The ConfigMap has a sparse wdt model file that define a JDBC DataSource ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMDk0Ng==", "bodyText": "remove extraneous space", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420510946", "createdAt": "2020-05-06T02:17:42Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,610 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Deploy a WebLogic domain with a defined ConfigMap.\n+   * in configuration/model section of the domain resource\n+   * The ConfigMap has a sparse wdt model file that define a JDBC DataSource \n+   * targeted to the cluster\n+   * Once the WebLogic domain is up, verify the DataSource configuration\n+   * using the RestAPI call thru adminserver's  public NodePort", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTA1Mw==", "bodyText": "OCIR -> registry\nyou don't know it is OCIR", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420511053", "createdAt": "2020-05-06T02:18:04Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,610 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Deploy a WebLogic domain with a defined ConfigMap.\n+   * in configuration/model section of the domain resource\n+   * The ConfigMap has a sparse wdt model file that define a JDBC DataSource \n+   * targeted to the cluster\n+   * Once the WebLogic domain is up, verify the DataSource configuration\n+   * using the RestAPI call thru adminserver's  public NodePort\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with a configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigMapDomain() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 255}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTA3MQ==", "bodyText": "ditto", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420511071", "createdAt": "2020-05-06T02:18:10Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,610 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Deploy a WebLogic domain with a defined ConfigMap.\n+   * in configuration/model section of the domain resource\n+   * The ConfigMap has a sparse wdt model file that define a JDBC DataSource \n+   * targeted to the cluster\n+   * Once the WebLogic domain is up, verify the DataSource configuration\n+   * using the RestAPI call thru adminserver's  public NodePort\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with a configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigMapDomain() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTI3Nw==", "bodyText": "pick a spelling and be consistent - curl, CURL, Curl ...", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420511277", "createdAt": "2020-05-06T02:19:04Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,610 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Deploy a WebLogic domain with a defined ConfigMap.\n+   * in configuration/model section of the domain resource\n+   * The ConfigMap has a sparse wdt model file that define a JDBC DataSource \n+   * targeted to the cluster\n+   * Once the WebLogic domain is up, verify the DataSource configuration\n+   * using the RestAPI call thru adminserver's  public NodePort\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with a configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigMapDomain() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, \n+              REPO_SECRET_NAME, encryptionSecretName, \n+              replicaCount, configMapName);\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    try {\n+      checkJdbc = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkJdbc.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null \")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+      logger.info(\"CURL command {0}\", new String(checkJdbc));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 369}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTM1OQ==", "bodyText": "same here - Datasource, DataSource", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420511359", "createdAt": "2020-05-06T02:19:27Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,610 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Deploy a WebLogic domain with a defined ConfigMap.\n+   * in configuration/model section of the domain resource\n+   * The ConfigMap has a sparse wdt model file that define a JDBC DataSource \n+   * targeted to the cluster\n+   * Once the WebLogic domain is up, verify the DataSource configuration\n+   * using the RestAPI call thru adminserver's  public NodePort\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with a configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigMapDomain() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, \n+              REPO_SECRET_NAME, encryptionSecretName, \n+              replicaCount, configMapName);\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    try {\n+      checkJdbc = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkJdbc.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null \")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+      logger.info(\"CURL command {0}\", new String(checkJdbc));\n+      result = exec(new String(checkJdbc), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Caught unexpected exception {0}\", ex);\n+      fail(\"Got unexpected exception\" + ex);\n+    }\n+\n+    logger.info(\"Curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"Datasource configuration not found\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 377}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTYzMw==", "bodyText": "missing asterisk\noperator - no capital", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420511633", "createdAt": "2020-05-06T02:20:41Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTcwMg==", "bodyText": "you are not creating it, it already exists", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420511702", "createdAt": "2020-05-06T02:20:58Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTgyMg==", "bodyText": "insert a blank line here", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420511822", "createdAt": "2020-05-06T02:21:31Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTg1OA==", "bodyText": "no cap", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420511858", "createdAt": "2020-05-06T02:21:40Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTkxNg==", "bodyText": "no cap", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420511916", "createdAt": "2020-05-06T02:21:52Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTk5Ng==", "bodyText": "cap", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420511996", "createdAt": "2020-05-06T02:22:12Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMjA2OQ==", "bodyText": "restart does not have a hyphen", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420512069", "createdAt": "2020-05-06T02:22:32Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+\n+  /**\n+   * Start a WebLogic domain with out any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse JDBC model file\n+   * Patch the domain resource with the ConfigMap which is targeted to cluster\n+   * Update the Restart Version of the domain resource\n+   * Verify rolling re-start of domain by comparing PodCreationTimestamp", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMjE2OA==", "bodyText": "you don't know if it is OCIR", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420512168", "createdAt": "2020-05-06T02:22:54Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+\n+  /**\n+   * Start a WebLogic domain with out any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse JDBC model file\n+   * Patch the domain resource with the ConfigMap which is targeted to cluster\n+   * Update the Restart Version of the domain resource\n+   * Verify rolling re-start of domain by comparing PodCreationTimestamp\n+   * before rolling re-start and after rolling re-start\n+   * Verify the DataSource configuration using the RestAPI call to admin server\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with no configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigOverrideDomain() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 263}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMjI2OQ==", "bodyText": "spelling curl, datasource, as before", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420512269", "createdAt": "2020-05-06T02:23:22Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+\n+  /**\n+   * Start a WebLogic domain with out any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse JDBC model file\n+   * Patch the domain resource with the ConfigMap which is targeted to cluster\n+   * Update the Restart Version of the domain resource\n+   * Verify rolling re-start of domain by comparing PodCreationTimestamp\n+   * before rolling re-start and after rolling re-start\n+   * Verify the DataSource configuration using the RestAPI call to admin server\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with no configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigOverrideDomain() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, \n+              REPO_SECRET_NAME, encryptionSecretName, \n+              replicaCount);\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+    String adminPodCreationTime = getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName);\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"ConfigMap Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"RestartVersion Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 2 minutes for Introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods re-started sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    String newAdminPodCreationTime = getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName);\n+    assertNotNull(newAdminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"NewAdminPodCreationTime {0} \", newAdminPodCreationTime);\n+    if (Long.parseLong(newAdminPodCreationTime) == Long.parseLong(adminPodCreationTime)) {\n+      logger.info(\"NewAdminPodCreationTime {0} BeforeAdminPodCreationTime ${1}\",\n+          newAdminPodCreationTime, adminPodCreationTime);\n+      fail(\"New pod creation time must be later than the original timestamp\");\n+    }\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    try {\n+      checkJdbc = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkJdbc.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null\")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+      logger.info(\"CURL command {0}\", new String(checkJdbc));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 439}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMjQyNg==", "bodyText": "i see this enough, that maybe it could be refactored", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420512426", "createdAt": "2020-05-06T02:23:48Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+\n+  /**\n+   * Start a WebLogic domain with out any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse JDBC model file\n+   * Patch the domain resource with the ConfigMap which is targeted to cluster\n+   * Update the Restart Version of the domain resource\n+   * Verify rolling re-start of domain by comparing PodCreationTimestamp\n+   * before rolling re-start and after rolling re-start\n+   * Verify the DataSource configuration using the RestAPI call to admin server\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with no configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigOverrideDomain() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, \n+              REPO_SECRET_NAME, encryptionSecretName, \n+              replicaCount);\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+    String adminPodCreationTime = getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName);\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"ConfigMap Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"RestartVersion Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 2 minutes for Introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods re-started sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    String newAdminPodCreationTime = getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName);\n+    assertNotNull(newAdminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"NewAdminPodCreationTime {0} \", newAdminPodCreationTime);\n+    if (Long.parseLong(newAdminPodCreationTime) == Long.parseLong(adminPodCreationTime)) {\n+      logger.info(\"NewAdminPodCreationTime {0} BeforeAdminPodCreationTime ${1}\",\n+          newAdminPodCreationTime, adminPodCreationTime);\n+      fail(\"New pod creation time must be later than the original timestamp\");\n+    }\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    try {\n+      checkJdbc = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkJdbc.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null\")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+      logger.info(\"CURL command {0}\", new String(checkJdbc));\n+      result = exec(new String(checkJdbc), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Caught unexpected exception {0}\", ex);\n+      fail(\"Got unexpected exception\" + ex);\n+    }\n+\n+    logger.info(\"Curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"Datasource configuration not found\");\n+    logger.info(\"Found the DataSource configuration \");\n+\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  private String createImageAndVerify() {\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 472}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMjc4OQ==", "bodyText": "no it doesn't - see comment in other class", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420512789", "createdAt": "2020-05-06T02:25:18Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+\n+  /**\n+   * Start a WebLogic domain with out any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse JDBC model file\n+   * Patch the domain resource with the ConfigMap which is targeted to cluster\n+   * Update the Restart Version of the domain resource\n+   * Verify rolling re-start of domain by comparing PodCreationTimestamp\n+   * before rolling re-start and after rolling re-start\n+   * Verify the DataSource configuration using the RestAPI call to admin server\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with no configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigOverrideDomain() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, \n+              REPO_SECRET_NAME, encryptionSecretName, \n+              replicaCount);\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+    String adminPodCreationTime = getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName);\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"ConfigMap Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"RestartVersion Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 2 minutes for Introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods re-started sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    String newAdminPodCreationTime = getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName);\n+    assertNotNull(newAdminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"NewAdminPodCreationTime {0} \", newAdminPodCreationTime);\n+    if (Long.parseLong(newAdminPodCreationTime) == Long.parseLong(adminPodCreationTime)) {\n+      logger.info(\"NewAdminPodCreationTime {0} BeforeAdminPodCreationTime ${1}\",\n+          newAdminPodCreationTime, adminPodCreationTime);\n+      fail(\"New pod creation time must be later than the original timestamp\");\n+    }\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    try {\n+      checkJdbc = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkJdbc.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null\")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+      logger.info(\"CURL command {0}\", new String(checkJdbc));\n+      result = exec(new String(checkJdbc), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Caught unexpected exception {0}\", ex);\n+      fail(\"Got unexpected exception\" + ex);\n+    }\n+\n+    logger.info(\"Curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"Datasource configuration not found\");\n+    logger.info(\"Found the DataSource configuration \");\n+\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  private String createImageAndVerify() {\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageName = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? MII_IMAGE_NAME : REPO_NAME + MII_IMAGE_NAME;\n+    final String image = imageName + \":\" + imageTag;\n+\n+    // build the model file list\n+    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    assertTrue(buildAppArchive(defaultAppParams()\n+        .srcDir(APP_NAME)), String.format(\"Failed to create app archive for %s\", APP_NAME));\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    final List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap<>();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    logger.info(\"Create image {0} using model directory {1}\", image, MODEL_DIR);\n+    boolean result = createMiiImage(\n+        defaultWitParams()\n+            .modelImageName(imageName)\n+            .modelImageTag(imageTag)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(WDT_VERSION)\n+            .env(env)\n+            .redirect(true));\n+\n+    assertTrue(result, String.format(\"Failed to create the image %s using WebLogic Image Tool\", image));\n+\n+    /* Check image exists using docker images | grep image tag.\n+     * Tag name is unique as it contains date and timestamp.\n+     * This is a workaround for the issue on Jenkins machine\n+     * as docker images imagename:imagetag is not working and\n+     * the test fails even though the image exists.\n+     */\n+    assertTrue(doesImageExist(imageTag),\n+        String.format(\"Image %s doesn't exist\", image));\n+\n+    return image;\n+  }\n+\n+  private void createRepoSecret(String domNamespace) throws ApiException {\n+    V1Secret repoSecret = new V1Secret()\n+            .metadata(new V1ObjectMeta()\n+                    .name(REPO_SECRET_NAME)\n+                    .namespace(domNamespace))\n+            .type(\"kubernetes.io/dockerconfigjson\")\n+            .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = false;\n+    try {\n+      secretCreated = createSecret(repoSecret);\n+    } catch (ApiException e) {\n+      logger.info(\"Exception when calling CoreV1Api#createNamespacedSecret\");\n+      logger.info(\"Status code: \" + e.getCode());\n+      logger.info(\"Reason: \" + e.getResponseBody());\n+      logger.info(\"Response headers: \" + e.getResponseHeaders());\n+      //409 means that the secret already exists - it is not an error, so can proceed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 537}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMjg2Nw==", "bodyText": "seems to be a lot of duplicated code in this class....", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420512867", "createdAt": "2020-05-06T02:25:38Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+\n+  /**\n+   * Start a WebLogic domain with out any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse JDBC model file\n+   * Patch the domain resource with the ConfigMap which is targeted to cluster\n+   * Update the Restart Version of the domain resource\n+   * Verify rolling re-start of domain by comparing PodCreationTimestamp\n+   * before rolling re-start and after rolling re-start\n+   * Verify the DataSource configuration using the RestAPI call to admin server\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with no configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigOverrideDomain() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, \n+              REPO_SECRET_NAME, encryptionSecretName, \n+              replicaCount);\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+    String adminPodCreationTime = getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName);\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"ConfigMap Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"RestartVersion Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 2 minutes for Introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods re-started sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    String newAdminPodCreationTime = getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName);\n+    assertNotNull(newAdminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"NewAdminPodCreationTime {0} \", newAdminPodCreationTime);\n+    if (Long.parseLong(newAdminPodCreationTime) == Long.parseLong(adminPodCreationTime)) {\n+      logger.info(\"NewAdminPodCreationTime {0} BeforeAdminPodCreationTime ${1}\",\n+          newAdminPodCreationTime, adminPodCreationTime);\n+      fail(\"New pod creation time must be later than the original timestamp\");\n+    }\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    try {\n+      checkJdbc = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkJdbc.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null\")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+      logger.info(\"CURL command {0}\", new String(checkJdbc));\n+      result = exec(new String(checkJdbc), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Caught unexpected exception {0}\", ex);\n+      fail(\"Got unexpected exception\" + ex);\n+    }\n+\n+    logger.info(\"Curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"Datasource configuration not found\");\n+    logger.info(\"Found the DataSource configuration \");\n+\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  private String createImageAndVerify() {\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageName = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? MII_IMAGE_NAME : REPO_NAME + MII_IMAGE_NAME;\n+    final String image = imageName + \":\" + imageTag;\n+\n+    // build the model file list\n+    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    assertTrue(buildAppArchive(defaultAppParams()\n+        .srcDir(APP_NAME)), String.format(\"Failed to create app archive for %s\", APP_NAME));\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    final List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap<>();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    logger.info(\"Create image {0} using model directory {1}\", image, MODEL_DIR);\n+    boolean result = createMiiImage(\n+        defaultWitParams()\n+            .modelImageName(imageName)\n+            .modelImageTag(imageTag)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(WDT_VERSION)\n+            .env(env)\n+            .redirect(true));\n+\n+    assertTrue(result, String.format(\"Failed to create the image %s using WebLogic Image Tool\", image));\n+\n+    /* Check image exists using docker images | grep image tag.\n+     * Tag name is unique as it contains date and timestamp.\n+     * This is a workaround for the issue on Jenkins machine\n+     * as docker images imagename:imagetag is not working and\n+     * the test fails even though the image exists.\n+     */\n+    assertTrue(doesImageExist(imageTag),\n+        String.format(\"Image %s doesn't exist\", image));\n+\n+    return image;\n+  }\n+\n+  private void createRepoSecret(String domNamespace) throws ApiException {\n+    V1Secret repoSecret = new V1Secret()\n+            .metadata(new V1ObjectMeta()\n+                    .name(REPO_SECRET_NAME)\n+                    .namespace(domNamespace))\n+            .type(\"kubernetes.io/dockerconfigjson\")\n+            .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = false;\n+    try {\n+      secretCreated = createSecret(repoSecret);\n+    } catch (ApiException e) {\n+      logger.info(\"Exception when calling CoreV1Api#createNamespacedSecret\");\n+      logger.info(\"Status code: \" + e.getCode());\n+      logger.info(\"Reason: \" + e.getResponseBody());\n+      logger.info(\"Response headers: \" + e.getResponseHeaders());\n+      //409 means that the secret already exists - it is not an error, so can proceed\n+      if (e.getCode() != 409) {\n+        throw e;\n+      } else {\n+        secretCreated = true;\n+      }\n+\n+    }\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s in namespace %s\",\n+            REPO_SECRET_NAME, domNamespace));\n+  }\n+\n+  private void createDomainSecret(String secretName, String username, String password, String domNamespace)\n+          throws ApiException {\n+    Map<String, String> secretMap = new HashMap();\n+    secretMap.put(\"username\", username);\n+    secretMap.put(\"password\", password);\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+            .metadata(new V1ObjectMeta()\n+                    .name(secretName)\n+                    .namespace(domNamespace))\n+            .stringData(secretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s in namespace %s\", secretName, domNamespace));\n+\n+  }\n+\n+  private void createDomainResource(String domainUid, String domNamespace, \n+          String adminSecretName, String repoSecretName, \n+          String encryptionSecretName, int replicaCount) {\n+    // create the domain CR\n+    Domain domain = new Domain()\n+            .apiVersion(API_VERSION)\n+            .kind(\"Domain\")\n+            .metadata(new V1ObjectMeta()\n+                    .name(domainUid)\n+                    .namespace(domNamespace))\n+            .spec(new DomainSpec()\n+                    .domainUid(domainUid)\n+                    .domainHomeSourceType(\"FromModel\")\n+                    .image(miiImage)\n+                    .addImagePullSecretsItem(new V1LocalObjectReference()\n+                            .name(repoSecretName))\n+                    .webLogicCredentialsSecret(new V1SecretReference()\n+                            .name(adminSecretName)\n+                            .namespace(domNamespace))\n+                    .includeServerOutInPodLog(true)\n+                    .serverStartPolicy(\"IF_NEEDED\")\n+                    .serverPod(new ServerPod()\n+                            .addEnvItem(new V1EnvVar()\n+                                    .name(\"JAVA_OPTIONS\")\n+                                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                            .addEnvItem(new V1EnvVar()\n+                                    .name(\"USER_MEM_ARGS\")\n+                                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+                    .adminServer(new AdminServer()\n+                            .serverStartState(\"RUNNING\")\n+                            .adminService(new AdminService()\n+                                    .addChannelsItem(new Channel()\n+                                            .channelName(\"default\")\n+                                            .nodePort(0))))\n+                    .addClustersItem(new Cluster()\n+                            .clusterName(\"cluster-1\")\n+                            .replicas(replicaCount)\n+                            .serverStartState(\"RUNNING\"))\n+                    .configuration(new Configuration()\n+                            .model(new Model()\n+                                    .domainType(\"WLS\")\n+                                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUid {0} in namespace {1}\",\n+            domainUid, domNamespace);\n+    boolean domCreated = assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+            String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+                    domainUid, domNamespace));\n+    assertTrue(domCreated, String.format(\"Create domain custom resource failed with ApiException \"\n+                    + \"for %s in namespace %s\", domainUid, domNamespace));\n+  }\n+\n+  private void checkPodCreated(String podName, String domainUid, String domNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podExists(podName, domainUid, domNamespace),\n+            String.format(\"podExists failed with ApiException for %s in namespace in %s\",\n+                podName, domNamespace)));\n+\n+  }\n+\n+  private void checkPodReady(String podName, String domainUid, String domNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podReady(podName, domainUid, domNamespace),\n+            String.format(\n+                \"pod %s is not ready in namespace %s\", podName, domNamespace)));\n+\n+  }\n+\n+  private void checkServiceCreated(String serviceName, String domNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for service {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                serviceName,\n+                domNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domNamespace),\n+            String.format(\n+                \"Service %s is not ready in namespace %s\", serviceName, domainNamespace)));\n+\n+  }\n+\n+  private void checkServerReadyStatusByExec(String podName, String namespace) {\n+    final V1Pod pod = assertDoesNotThrow(() -> oracle.weblogic.kubernetes.assertions.impl.Kubernetes\n+        .getPod(namespace, null, podName));\n+\n+    if (pod != null) {\n+      ExecResult execResult = assertDoesNotThrow(\n+          () -> execCommand(pod, null, true, READ_STATE_COMMAND));\n+      if (execResult.exitValue() == 0) {\n+        logger.info(\"execResult: \" + execResult);\n+        assertEquals(\"RUNNING\", execResult.stdout(),\n+            \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");\n+      } else {\n+        fail(\"Ready command failed with exit status code: \" + execResult.exitValue());\n+      }\n+    } else {\n+      fail(\"Did not find pod \" + podName + \" in namespace \" + namespace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 675}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMzA2Nw==", "bodyText": "please read this https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420513067", "createdAt": "2020-05-06T02:26:29Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+\n+  /**\n+   * Start a WebLogic domain with out any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse JDBC model file\n+   * Patch the domain resource with the ConfigMap which is targeted to cluster\n+   * Update the Restart Version of the domain resource\n+   * Verify rolling re-start of domain by comparing PodCreationTimestamp\n+   * before rolling re-start and after rolling re-start\n+   * Verify the DataSource configuration using the RestAPI call to admin server\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with no configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigOverrideDomain() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, \n+              REPO_SECRET_NAME, encryptionSecretName, \n+              replicaCount);\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+    String adminPodCreationTime = getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName);\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"ConfigMap Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"RestartVersion Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 2 minutes for Introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods re-started sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    String newAdminPodCreationTime = getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName);\n+    assertNotNull(newAdminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"NewAdminPodCreationTime {0} \", newAdminPodCreationTime);\n+    if (Long.parseLong(newAdminPodCreationTime) == Long.parseLong(adminPodCreationTime)) {\n+      logger.info(\"NewAdminPodCreationTime {0} BeforeAdminPodCreationTime ${1}\",\n+          newAdminPodCreationTime, adminPodCreationTime);\n+      fail(\"New pod creation time must be later than the original timestamp\");\n+    }\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    try {\n+      checkJdbc = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkJdbc.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null\")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+      logger.info(\"CURL command {0}\", new String(checkJdbc));\n+      result = exec(new String(checkJdbc), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Caught unexpected exception {0}\", ex);\n+      fail(\"Got unexpected exception\" + ex);\n+    }\n+\n+    logger.info(\"Curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"Datasource configuration not found\");\n+    logger.info(\"Found the DataSource configuration \");\n+\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  private String createImageAndVerify() {\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageName = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? MII_IMAGE_NAME : REPO_NAME + MII_IMAGE_NAME;\n+    final String image = imageName + \":\" + imageTag;\n+\n+    // build the model file list\n+    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    assertTrue(buildAppArchive(defaultAppParams()\n+        .srcDir(APP_NAME)), String.format(\"Failed to create app archive for %s\", APP_NAME));\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    final List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap<>();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    logger.info(\"Create image {0} using model directory {1}\", image, MODEL_DIR);\n+    boolean result = createMiiImage(\n+        defaultWitParams()\n+            .modelImageName(imageName)\n+            .modelImageTag(imageTag)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(WDT_VERSION)\n+            .env(env)\n+            .redirect(true));\n+\n+    assertTrue(result, String.format(\"Failed to create the image %s using WebLogic Image Tool\", image));\n+\n+    /* Check image exists using docker images | grep image tag.\n+     * Tag name is unique as it contains date and timestamp.\n+     * This is a workaround for the issue on Jenkins machine\n+     * as docker images imagename:imagetag is not working and\n+     * the test fails even though the image exists.\n+     */\n+    assertTrue(doesImageExist(imageTag),\n+        String.format(\"Image %s doesn't exist\", image));\n+\n+    return image;\n+  }\n+\n+  private void createRepoSecret(String domNamespace) throws ApiException {\n+    V1Secret repoSecret = new V1Secret()\n+            .metadata(new V1ObjectMeta()\n+                    .name(REPO_SECRET_NAME)\n+                    .namespace(domNamespace))\n+            .type(\"kubernetes.io/dockerconfigjson\")\n+            .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = false;\n+    try {\n+      secretCreated = createSecret(repoSecret);\n+    } catch (ApiException e) {\n+      logger.info(\"Exception when calling CoreV1Api#createNamespacedSecret\");\n+      logger.info(\"Status code: \" + e.getCode());\n+      logger.info(\"Reason: \" + e.getResponseBody());\n+      logger.info(\"Response headers: \" + e.getResponseHeaders());\n+      //409 means that the secret already exists - it is not an error, so can proceed\n+      if (e.getCode() != 409) {\n+        throw e;\n+      } else {\n+        secretCreated = true;\n+      }\n+\n+    }\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s in namespace %s\",\n+            REPO_SECRET_NAME, domNamespace));\n+  }\n+\n+  private void createDomainSecret(String secretName, String username, String password, String domNamespace)\n+          throws ApiException {\n+    Map<String, String> secretMap = new HashMap();\n+    secretMap.put(\"username\", username);\n+    secretMap.put(\"password\", password);\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+            .metadata(new V1ObjectMeta()\n+                    .name(secretName)\n+                    .namespace(domNamespace))\n+            .stringData(secretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s in namespace %s\", secretName, domNamespace));\n+\n+  }\n+\n+  private void createDomainResource(String domainUid, String domNamespace, \n+          String adminSecretName, String repoSecretName, \n+          String encryptionSecretName, int replicaCount) {\n+    // create the domain CR\n+    Domain domain = new Domain()\n+            .apiVersion(API_VERSION)\n+            .kind(\"Domain\")\n+            .metadata(new V1ObjectMeta()\n+                    .name(domainUid)\n+                    .namespace(domNamespace))\n+            .spec(new DomainSpec()\n+                    .domainUid(domainUid)\n+                    .domainHomeSourceType(\"FromModel\")\n+                    .image(miiImage)\n+                    .addImagePullSecretsItem(new V1LocalObjectReference()\n+                            .name(repoSecretName))\n+                    .webLogicCredentialsSecret(new V1SecretReference()\n+                            .name(adminSecretName)\n+                            .namespace(domNamespace))\n+                    .includeServerOutInPodLog(true)\n+                    .serverStartPolicy(\"IF_NEEDED\")\n+                    .serverPod(new ServerPod()\n+                            .addEnvItem(new V1EnvVar()\n+                                    .name(\"JAVA_OPTIONS\")\n+                                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                            .addEnvItem(new V1EnvVar()\n+                                    .name(\"USER_MEM_ARGS\")\n+                                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+                    .adminServer(new AdminServer()\n+                            .serverStartState(\"RUNNING\")\n+                            .adminService(new AdminService()\n+                                    .addChannelsItem(new Channel()\n+                                            .channelName(\"default\")\n+                                            .nodePort(0))))\n+                    .addClustersItem(new Cluster()\n+                            .clusterName(\"cluster-1\")\n+                            .replicas(replicaCount)\n+                            .serverStartState(\"RUNNING\"))\n+                    .configuration(new Configuration()\n+                            .model(new Model()\n+                                    .domainType(\"WLS\")\n+                                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUid {0} in namespace {1}\",\n+            domainUid, domNamespace);\n+    boolean domCreated = assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+            String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+                    domainUid, domNamespace));\n+    assertTrue(domCreated, String.format(\"Create domain custom resource failed with ApiException \"\n+                    + \"for %s in namespace %s\", domainUid, domNamespace));\n+  }\n+\n+  private void checkPodCreated(String podName, String domainUid, String domNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podExists(podName, domainUid, domNamespace),\n+            String.format(\"podExists failed with ApiException for %s in namespace in %s\",\n+                podName, domNamespace)));\n+\n+  }\n+\n+  private void checkPodReady(String podName, String domainUid, String domNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podReady(podName, domainUid, domNamespace),\n+            String.format(\n+                \"pod %s is not ready in namespace %s\", podName, domNamespace)));\n+\n+  }\n+\n+  private void checkServiceCreated(String serviceName, String domNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for service {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                serviceName,\n+                domNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domNamespace),\n+            String.format(\n+                \"Service %s is not ready in namespace %s\", serviceName, domainNamespace)));\n+\n+  }\n+\n+  private void checkServerReadyStatusByExec(String podName, String namespace) {\n+    final V1Pod pod = assertDoesNotThrow(() -> oracle.weblogic.kubernetes.assertions.impl.Kubernetes\n+        .getPod(namespace, null, podName));\n+\n+    if (pod != null) {\n+      ExecResult execResult = assertDoesNotThrow(\n+          () -> execCommand(pod, null, true, READ_STATE_COMMAND));\n+      if (execResult.exitValue() == 0) {\n+        logger.info(\"execResult: \" + execResult);\n+        assertEquals(\"RUNNING\", execResult.stdout(),\n+            \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");\n+      } else {\n+        fail(\"Ready command failed with exit status code: \" + execResult.exitValue());\n+      }\n+    } else {\n+      fail(\"Did not find pod \" + podName + \" in namespace \" + namespace);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMjg2Nw=="}, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 675}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMzQ3Ng==", "bodyText": "remove extraneous space", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420513476", "createdAt": "2020-05-06T02:28:21Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -405,6 +408,36 @@ public static boolean deleteService(String name, String namespace) {\n     return Service.delete(name, namespace);\n   }\n \n+  /**\n+   * Returns the V1Service object given the following parameters.\n+   *\n+   * @param serviceName name of the Service to return\n+   * @param label  a Map of key value pairs the service is decorated with", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMzYwNA==", "bodyText": "could use a link to the k8s doc here to explain this format", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420513604", "createdAt": "2020-05-06T02:29:00Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -551,11 +588,48 @@ public static JsonObject createDockerConfigJson(String username, String password\n    * @throws InterruptedException if any thread has interrupted the current thread\n    */\n   public static ExecResult execCommand(V1Pod pod, String containerName, boolean redirectToStdout,\n-      String... command)\n+                                       String... command)\n       throws IOException, ApiException, InterruptedException {\n     return Exec.exec(pod, containerName, redirectToStdout, command);\n   }\n \n+  // ----------------------   pod  ---------------------------------\n+\n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.\n+   *\n+   * @param namespace namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMzczOQ==", "bodyText": "the class does not", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420513739", "createdAt": "2020-05-06T02:29:29Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,91 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+public class Pod {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MTExNA=="}, "originalCommit": {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMzg5Mw==", "bodyText": "... which match the given labelSelector", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420513893", "createdAt": "2020-05-06T02:30:06Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,68 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+public class Pod {\n+\n+  /**\n+   * Delete Kubernetes Pod.\n+   *\n+   * @param name name of the pod\n+   * @param namespace name of namespace\n+   * @return true if successful, false otherwise\n+   */\n+  public static boolean deletePod(String name, String namespace) {\n+    return Kubernetes.deletePod(name, namespace);\n+  }\n+\n+  /**\n+   * List Kubernetes pods in a namespace.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxNDEwNw==", "bodyText": "this assumes a pod only has one container\nthere are likely going to be cases where we want to get the log from a specific container.\nconsider introducing an optional container parameter.\nif the pod only has one container, default to that one.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420514107", "createdAt": "2020-05-06T02:31:04Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,68 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+public class Pod {\n+\n+  /**\n+   * Delete Kubernetes Pod.\n+   *\n+   * @param name name of the pod\n+   * @param namespace name of namespace\n+   * @return true if successful, false otherwise\n+   */\n+  public static boolean deletePod(String name, String namespace) {\n+    return Kubernetes.deletePod(name, namespace);\n+  }\n+\n+  /**\n+   * List Kubernetes pods in a namespace.\n+   *\n+   * @param namespace name of namespace\n+   * @param labelSelectors with which pods are decorated\n+   * @return V1PodList list of pods\n+   */\n+  public static V1PodList listPods(String namespace, String labelSelectors) {\n+    return Kubernetes.listPods(namespace, labelSelectors);\n+  }\n+\n+  /**\n+   * Get a pod's log.\n+   *\n+   * @param podName name of the pod\n+   * @param namespace name of the namespace\n+   * @return log as a String\n+   */\n+  public static String getPodLog(String podName, String namespace) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxNDMzNQ==", "bodyText": "what does it even mean to throw a null :)", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420514335", "createdAt": "2020-05-06T02:32:17Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -454,7 +494,7 @@ public static V1PodList listPods(String namespace, String labelSelectors) throws\n           );\n     } catch (ApiException apex) {\n       logger.severe(apex.getResponseBody());\n-      throw apex;\n+      throw null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4MjUwNQ=="}, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxNDM5NA==", "bodyText": "does it mean you didn't throw at all?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420514394", "createdAt": "2020-05-06T02:32:32Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -454,7 +494,7 @@ public static V1PodList listPods(String namespace, String labelSelectors) throws\n           );\n     } catch (ApiException apex) {\n       logger.severe(apex.getResponseBody());\n-      throw apex;\n+      throw null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4MjUwNQ=="}, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxNDQ1Mw==", "bodyText": "if two nulls are thrown in an empty wood, and noone was there to see it.....", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420514453", "createdAt": "2020-05-06T02:32:49Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -454,7 +494,7 @@ public static V1PodList listPods(String namespace, String labelSelectors) throws\n           );\n     } catch (ApiException apex) {\n       logger.severe(apex.getResponseBody());\n-      throw apex;\n+      throw null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4MjUwNQ=="}, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 125}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MjkyODg1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-406292885", "createdAt": "2020-05-06T04:09:53Z", "commit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDowOTo1M1rOGRDaNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDowOTo1M1rOGRDaNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUzNDgzOQ==", "bodyText": "lets change this to logger.info(\"Assigning unique namespace for operator\");", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420534839", "createdAt": "2020-05-06T04:09:53Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,610 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 146}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MjkyOTMw", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-406292930", "createdAt": "2020-05-06T04:10:02Z", "commit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDoxMDowM1rOGRDaYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDoxMDowM1rOGRDaYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUzNDg4Mg==", "bodyText": "same here", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420534882", "createdAt": "2020-05-06T04:10:03Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,610 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 150}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MjkzNDcy", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-406293472", "createdAt": "2020-05-06T04:12:40Z", "commit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDoxMjo0MFrOGRDcbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDoxMjo0MFrOGRDcbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUzNTQwNg==", "bodyText": "now it should be operatorIsReady", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420535406", "createdAt": "2020-05-06T04:12:40Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,610 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 230}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2Mjk5MjAz", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-406299203", "createdAt": "2020-05-06T04:38:13Z", "commit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDozODoxM1rOGRDxqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDozODoxM1rOGRDxqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0MDg0Mg==", "bodyText": "can we add this to TestConstants.java ?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420540842", "createdAt": "2020-05-06T04:38:13Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 120}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2Mjk5MzI3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-406299327", "createdAt": "2020-05-06T04:38:35Z", "commit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDozODozNlrOGRDyBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDozODozNlrOGRDyBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0MDkzMw==", "bodyText": "same as above comment", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420540933", "createdAt": "2020-05-06T04:38:36Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 121}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MzAwNjc0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-406300674", "createdAt": "2020-05-06T04:43:53Z", "commit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDo0Mzo1M1rOGRD26g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDo0Mzo1M1rOGRD26g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0MjE4Ng==", "bodyText": "can you add some comments on why we are checking the creation time stamp for the pod ?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420542186", "createdAt": "2020-05-06T04:43:53Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+\n+  /**\n+   * Start a WebLogic domain with out any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse JDBC model file\n+   * Patch the domain resource with the ConfigMap which is targeted to cluster\n+   * Update the Restart Version of the domain resource\n+   * Verify rolling re-start of domain by comparing PodCreationTimestamp\n+   * before rolling re-start and after rolling re-start\n+   * Verify the DataSource configuration using the RestAPI call to admin server\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with no configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigOverrideDomain() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, \n+              REPO_SECRET_NAME, encryptionSecretName, \n+              replicaCount);\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+    String adminPodCreationTime = getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 366}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MzAyODM3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-406302837", "createdAt": "2020-05-06T04:52:59Z", "commit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDo1Mjo1OVrOGRD-9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDo1Mjo1OVrOGRD-9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0NDI0NA==", "bodyText": "We may have to add a new assertion methods to verify the creation time stamp is different for all pods which are restarted.  Lets create a JIRA for that task.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420544244", "createdAt": "2020-05-06T04:52:59Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+\n+  /**\n+   * Start a WebLogic domain with out any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse JDBC model file\n+   * Patch the domain resource with the ConfigMap which is targeted to cluster\n+   * Update the Restart Version of the domain resource\n+   * Verify rolling re-start of domain by comparing PodCreationTimestamp\n+   * before rolling re-start and after rolling re-start\n+   * Verify the DataSource configuration using the RestAPI call to admin server\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with no configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigOverrideDomain() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, \n+              REPO_SECRET_NAME, encryptionSecretName, \n+              replicaCount);\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+    String adminPodCreationTime = getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName);\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"ConfigMap Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"RestartVersion Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 2 minutes for Introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods re-started sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    String newAdminPodCreationTime = getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName);\n+    assertNotNull(newAdminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"NewAdminPodCreationTime {0} \", newAdminPodCreationTime);\n+    if (Long.parseLong(newAdminPodCreationTime) == Long.parseLong(adminPodCreationTime)) {\n+      logger.info(\"NewAdminPodCreationTime {0} BeforeAdminPodCreationTime ${1}\",\n+          newAdminPodCreationTime, adminPodCreationTime);\n+      fail(\"New pod creation time must be later than the original timestamp\");\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 428}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2NzY5Mzk0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-406769394", "createdAt": "2020-05-06T16:10:55Z", "commit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjoxMDo1NVrOGRakfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjoxMDo1NVrOGRakfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxNDMwMg==", "bodyText": "the .toString() conversion is redundant for the above 2 lines, its already a String", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420914302", "createdAt": "2020-05-06T16:10:55Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1406,8 +1446,87 @@ public static V1ServiceList listServices(String namespace) {\n     }\n   }\n \n-  // --------------------------- jobs ---------------------------\n+  /**\n+   * Get V1Service object for the given service name, label and namespace.\n+   *\n+   * @param serviceName name of the service to look for\n+   * @param label  key value pair with which the service is decorated with\n+   * @param namespace namespace in which to check for the service\n+   * @return V1Service object if found otherwise null\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static V1Service getService(\n+      String serviceName, Map<String, String> label, String namespace)\n+      throws ApiException {\n+    String labelSelector = null;\n+    if (label != null) {\n+      String key = label.keySet().iterator().next().toString();\n+      String value = label.get(key).toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d897a07beb2df97f491e21d7023b22980df588d"}, "originalPosition": 149}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cddad0e65d6ad15550f6296a84e63995fe5ab274", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/cddad0e65d6ad15550f6296a84e63995fe5ab274", "committedDate": "2020-05-06T21:28:33Z", "message": "Resolution to review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c90e0f51989d875abaf04e23a641121a02ca6260", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c90e0f51989d875abaf04e23a641121a02ca6260", "committedDate": "2020-05-06T21:28:44Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c1aa5c88249939ed8b7fd203e24216eb56a6b0f", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9c1aa5c88249939ed8b7fd203e24216eb56a6b0f", "committedDate": "2020-05-06T23:09:40Z", "message": "Added Usecases to add new Dynamic Cluster"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80422299b80e788dd44c9ec5ab147eeacdd5ee72", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/80422299b80e788dd44c9ec5ab147eeacdd5ee72", "committedDate": "2020-05-06T23:12:34Z", "message": "Merge conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64bc66ed172ee682da68cae20e6620929d6b234f", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/64bc66ed172ee682da68cae20e6620929d6b234f", "committedDate": "2020-05-07T17:08:45Z", "message": "Separate the AddCluster UseCase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6bf9f6959a67b568254d8040c5f3b7bcf58855ef", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/6bf9f6959a67b568254d8040c5f3b7bcf58855ef", "committedDate": "2020-05-07T21:19:39Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfd8357fa3f4320d2855e0f8d977aa905396052c", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/dfd8357fa3f4320d2855e0f8d977aa905396052c", "committedDate": "2020-05-08T15:15:38Z", "message": "Add new AddClusters usecase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1531bd1a764814d6f95e81a06228dd92946e157d", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/1531bd1a764814d6f95e81a06228dd92946e157d", "committedDate": "2020-05-08T15:40:16Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7b28ee59fdfc590640a1f053ad1711dbb591e81", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b7b28ee59fdfc590640a1f053ad1711dbb591e81", "committedDate": "2020-05-08T19:37:26Z", "message": "Modified the test method name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "531ff5b17226b182c872131bc077226e17f4bf16", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/531ff5b17226b182c872131bc077226e17f4bf16", "committedDate": "2020-05-08T21:41:14Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e0e8466aed39e6c746804d80530f704b250cfcc", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9e0e8466aed39e6c746804d80530f704b250cfcc", "committedDate": "2020-05-12T13:31:03Z", "message": "Added assetion to compare the PodCreationStartTime and add new usecases for adding new cluster with default replica count"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwMjEzNzEw", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-410213710", "createdAt": "2020-05-12T16:25:07Z", "commit": {"oid": "9e0e8466aed39e6c746804d80530f704b250cfcc"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNjoyNTowN1rOGUO2AA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNjo0OTowNlrOGUP0NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg2NzkwNA==", "bodyText": "More documentation please", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r423867904", "createdAt": "2020-05-12T16:25:07Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,1085 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e0e8466aed39e6c746804d80530f704b250cfcc"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg2ODI0Mg==", "bodyText": "same comment as above", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r423868242", "createdAt": "2020-05-12T16:25:35Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,1085 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e0e8466aed39e6c746804d80530f704b250cfcc"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg2OTk1MA==", "bodyText": "We should use descriptive names for model files.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r423869950", "createdAt": "2020-05-12T16:27:54Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,1085 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e0e8466aed39e6c746804d80530f704b250cfcc"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg3MDk1NA==", "bodyText": "can we change the domain name to someother name? all tests are using domain1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r423870954", "createdAt": "2020-05-12T16:29:21Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,1085 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e0e8466aed39e6c746804d80530f704b250cfcc"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg3ODczMQ==", "bodyText": "The assertion to check for a rolling restart in a cluster is under testing. I will replace this code with assertion in my PR.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r423878731", "createdAt": "2020-05-12T16:41:07Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,1085 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+        REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install operator\n+    logger.info(\"Installing operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching operator release name in operator namespace\n+    logger.info(\"Checking operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Start a WebLogic domain without any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the ConfigMap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from the newly added cluster are in running state.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to registry to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to registry\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName, \"weblogic\",\n+        \"welcome1\", domainNamespace),\n+        String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+        \"weblogicenc\", domainNamespace),\n+        String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    // no uppercase for the configmap name\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+\n+    logger.info(\"Snooze for 2 minutes for introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in ns {1}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e0e8466aed39e6c746804d80530f704b250cfcc"}, "originalPosition": 423}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4MzgyOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private void checkPodNotCreated(String podName, String domainUid, String domNamespace) {\n          \n          \n            \n              private void checkPodDoesNotExist(String podName, String domainUid, String domNamespace) {", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r423883829", "createdAt": "2020-05-12T16:49:06Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,1085 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+        REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install operator\n+    logger.info(\"Installing operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching operator release name in operator namespace\n+    logger.info(\"Checking operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Start a WebLogic domain without any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the ConfigMap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from the newly added cluster are in running state.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to registry to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to registry\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName, \"weblogic\",\n+        \"welcome1\", domainNamespace),\n+        String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+        \"weblogicenc\", domainNamespace),\n+        String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    // no uppercase for the configmap name\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+\n+    logger.info(\"Snooze for 2 minutes for introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods restarted sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    // The ServerNamePrefix for the new dynamic cluster is dynamic-server\n+    // Make sure the managed server from the new cluster is running\n+\n+    String newServerPodName = domainUid + \"-dynamic-server1\";\n+    checkPodCreated(newServerPodName, domainUid, domainNamespace);\n+    checkPodReady(newServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(newServerPodName, domainNamespace);\n+\n+    boolean isPodRestarted  =\n+        assertDoesNotThrow(() -> isPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime),\n+            String.format(\"Check if the admin Pod is restarted\"));\n+    assertTrue(isPodRestarted, \"Admin pod has not been restarted as expected\");\n+\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    try {\n+      checkCluster = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkCluster.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/tenant-monitoring/servers/dynamic-server1\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null\")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+      logger.info(\"curl command {0}\", new String(checkCluster));\n+      result = exec(new String(checkCluster), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Caught unexpected exception {0}\", ex);\n+      fail(\"Got unexpected exception\" + ex);\n+    }\n+\n+    logger.info(\"curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"Server configuration not found\");\n+    logger.info(\"Found the Server configuration \");\n+\n+  }\n+\n+  /**\n+   * Start a WebLogic domain without any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse model file to add a configured cluster.\n+   * Patch the domain resource with the ConfigMap.\n+   * Update the restart version of the domain resource to 3\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from the newly added cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Add a configured cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiConfiguredCluster() {\n+    // This test use the running mii domain created by previous test\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.config.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    // no uppercase for the configmap name\n+    String configMapName = \"configclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.config.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"3\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+\n+    logger.info(\"Snooze for 2 minutes for introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods restarted sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    // The ServerNamePrefix for the new configured cluster is config-server\n+    // Make sure the managed server from the new cluster is running\n+\n+    String newServerPodName = domainUid + \"-config-server1\";\n+    checkPodCreated(newServerPodName, domainUid, domainNamespace);\n+    checkPodReady(newServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(newServerPodName, domainNamespace);\n+\n+    boolean isPodRestarted  =\n+        assertDoesNotThrow(() -> isPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime),\n+            String.format(\"Check if the admin pod is restarted\"));\n+    assertTrue(isPodRestarted, \"Admin pod has not been restarted as expected\");\n+\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    try {\n+      checkCluster = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkCluster.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/tenant-monitoring/servers/config-server1\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null\")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+      logger.info(\"curl command {0}\", new String(checkCluster));\n+      result = exec(new String(checkCluster), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Caught unexpected exception {0}\", ex);\n+      fail(\"Got unexpected exception\" + ex);\n+    }\n+\n+    logger.info(\"curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"Server configuration not found\");\n+    logger.info(\"Found the Server configuration \");\n+  }\n+\n+  /**\n+   * Start a WebLogic domain without any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse model file to add a configured cluster.\n+   * Patch the domain resource with the ConfigMap.\n+   * Update the restart version of the domain resource to 3\n+   * Update the spec level replica count to zero(default) value\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from the newly added cluster are not in running state.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"Add a configured cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiClusteriWithNoReplica() {\n+    // This test use the running mii domain created by previous test\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.config.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    // no uppercase for the configmap name\n+    String configMapName = \"noreplicaconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.config.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 0\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"4\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+\n+    logger.info(\"Snooze for 2 minutes for introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods restarted sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    // The ServerNamePrefix for the new configured cluster is config-server\n+    // Make sure the managed server from the new cluster is not running\n+\n+    String newServerPodName = domainUid + \"-config-server1\";\n+    checkPodNotCreated(newServerPodName, domainUid, domainNamespace);\n+\n+    boolean isPodRestarted  =\n+        assertDoesNotThrow(() -> isPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime),\n+            String.format(\"Check if the admin pod is restarted\"));\n+    assertTrue(isPodRestarted, \"Admin pod has not been restarted as expected\");\n+\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    try {\n+      checkCluster = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkCluster.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/tenant-monitoring/servers/config-server1\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null\")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+      logger.info(\"curl command {0}\", new String(checkCluster));\n+      result = exec(new String(checkCluster), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Caught unexpected exception {0}\", ex);\n+      fail(\"Got unexpected exception\" + ex);\n+    }\n+\n+    logger.info(\"curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"Server configuration not found\");\n+    logger.info(\"Found the Server configuration \");\n+\n+  }\n+\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  private String createImageAndVerify() {\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageName = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? MII_IMAGE_NAME : REPO_NAME + MII_IMAGE_NAME;\n+    final String image = imageName + \":\" + imageTag;\n+\n+    // build the model file list\n+    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    assertTrue(buildAppArchive(defaultAppParams()\n+        .srcDir(APP_NAME)), String.format(\"Failed to create app archive for %s\", APP_NAME));\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    final List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap<>();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    logger.info(\"Create image {0} using model directory {1}\", image, MODEL_DIR);\n+    boolean result = createMiiImage(\n+        defaultWitParams()\n+            .modelImageName(imageName)\n+            .modelImageTag(imageTag)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(WDT_VERSION)\n+            .env(env)\n+            .redirect(true));\n+\n+    assertTrue(result, String.format(\"Failed to create the image %s using WebLogic Image Tool\", image));\n+\n+    /* Check image exists using docker images | grep image tag.\n+     * Tag name is unique as it contains date and timestamp.\n+     * This is a workaround for the issue on Jenkins machine\n+     * as docker images imagename:imagetag is not working and\n+     * the test fails even though the image exists.\n+     */\n+    assertTrue(doesImageExist(imageTag),\n+        String.format(\"Image %s doesn't exist\", image));\n+\n+    return image;\n+  }\n+\n+  private void createRepoSecret(String domNamespace) throws ApiException {\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(domNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = false;\n+    try {\n+      secretCreated = createSecret(repoSecret);\n+    } catch (ApiException e) {\n+      logger.info(\"Exception when calling CoreV1Api#createNamespacedSecret\");\n+      logger.info(\"Status code: \" + e.getCode());\n+      logger.info(\"Reason: \" + e.getResponseBody());\n+      logger.info(\"Response headers: \" + e.getResponseHeaders());\n+      //409 means that the secret already exists - it is not an error, so can proceed\n+      if (e.getCode() != 409) {\n+        throw e;\n+      } else {\n+        secretCreated = true;\n+      }\n+\n+    }\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s in namespace %s\",\n+        REPO_SECRET_NAME, domNamespace));\n+  }\n+\n+  private void createDomainSecret(String secretName, String username, String password, String domNamespace)\n+      throws ApiException {\n+    Map<String, String> secretMap = new HashMap();\n+    secretMap.put(\"username\", username);\n+    secretMap.put(\"password\", password);\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(secretName)\n+            .namespace(domNamespace))\n+        .stringData(secretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s in namespace %s\", secretName, domNamespace));\n+\n+  }\n+\n+  private void createDomainResource(String domainUid, String domNamespace,\n+                                    String adminSecretName, String repoSecretName,\n+                                    String encryptionSecretName, int replicaCount) {\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(repoSecretName))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domNamespace);\n+    boolean domCreated = assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domNamespace));\n+    assertTrue(domCreated, String.format(\"Create domain custom resource failed with ApiException \"\n+        + \"for %s in namespace %s\", domainUid, domNamespace));\n+  }\n+\n+  private void checkPodNotCreated(String podName, String domainUid, String domNamespace) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e0e8466aed39e6c746804d80530f704b250cfcc"}, "originalPosition": 1005}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25df1a402f99dff4936c6cbe52dfbbd7f56a3180", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/25df1a402f99dff4936c6cbe52dfbbd7f56a3180", "committedDate": "2020-05-12T17:57:13Z", "message": "Modified @DisplayName annotation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNDA2NTEx", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-410406511", "createdAt": "2020-05-12T20:42:57Z", "commit": {"oid": "25df1a402f99dff4936c6cbe52dfbbd7f56a3180"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMDo0Mjo1N1rOGUYMUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMDo0Mjo1N1rOGUYMUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyMTA3NQ==", "bodyText": "This is the pattern that changed.  Now, instead of the test for REPO_USERNAME guarding the docker login and docker push, it just guards the docker login. The docker push needs to happen if REPO_NAME is not-empty.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r424021075", "createdAt": "2020-05-12T20:42:57Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,1084 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+        REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install operator\n+    logger.info(\"Installing operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching operator release name in operator namespace\n+    logger.info(\"Checking operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Start a WebLogic domain without any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the ConfigMap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from the newly added cluster are in running state.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to registry to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25df1a402f99dff4936c6cbe52dfbbd7f56a3180"}, "originalPosition": 265}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "115abf36729391a48cef17ccb3dc52ac31da6fcb", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/115abf36729391a48cef17ccb3dc52ac31da6fcb", "committedDate": "2020-05-13T01:36:07Z", "message": "Sync up develop branch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2ed6cf30fbeadf43e77dc896ddd9f57f4a9fd43", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a2ed6cf30fbeadf43e77dc896ddd9f57f4a9fd43", "committedDate": "2020-05-13T01:36:44Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMDAxNTQz", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-411001543", "createdAt": "2020-05-13T14:47:01Z", "commit": {"oid": "a2ed6cf30fbeadf43e77dc896ddd9f57f4a9fd43"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNDo0NzowMVrOGU1PQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNTowOTo1N1rOGU2VoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ5Njk2MQ==", "bodyText": "make this a ToDo comment", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r424496961", "createdAt": "2020-05-13T14:47:01Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,998 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"miiaddcluster\";\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+  }\n+\n+  /**\n+   * Start a WebLogic domain without any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the ConfigMap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from the newly added cluster are in running state.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 2 minutes for introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods restarted sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+    // The ServerNamePrefix for the new dynamic cluster is dynamic-server\n+    // Make sure the managed server from the new cluster is running\n+    //\n+    String newServerPodName = domainUid + \"-dynamic-server1\";\n+    checkPodCreated(newServerPodName, domainUid, domainNamespace);\n+    checkPodReady(newServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(newServerPodName, domainNamespace);\n+\n+    boolean isPodRestarted  =\n+        assertDoesNotThrow(() -> isPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime),\n+            String.format(\"Check if the admin pod is restarted\"));\n+    assertTrue(isPodRestarted, \"Admin pod has not been restarted as expected\");\n+\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    try {\n+      checkCluster = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkCluster.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/tenant-monitoring/servers/dynamic-server1\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null\")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+      logger.info(\"curl command {0}\", new String(checkCluster));\n+      result = exec(new String(checkCluster), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Caught unexpected exception {0}\", ex);\n+      fail(\"Got unexpected exception\" + ex);\n+    }\n+\n+    logger.info(\"curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"Server configuration not found\");\n+    logger.info(\"Found the server configuration \");\n+\n+  }\n+\n+  /**\n+   * Start a WebLogic domain without any pre-defined configmap.\n+   * Create a configmap with a sparse model file to add a configured cluster.\n+   * Patch the domain resource with the ConfigMap.\n+   * Update the restart version of the domain resource to 3\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from the newly added cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Add a configured cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiConfiguredCluster() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+ \n+    // This test uses the WebLogic domain created by previous test\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.config.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"configclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.config.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"3\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 2 minutes for introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2ed6cf30fbeadf43e77dc896ddd9f57f4a9fd43"}, "originalPosition": 573}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUxMzgzNg==", "bodyText": "why hard sleep of 2 minutes?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r424513836", "createdAt": "2020-05-13T15:08:25Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,998 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"miiaddcluster\";\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+  }\n+\n+  /**\n+   * Start a WebLogic domain without any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the ConfigMap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from the newly added cluster are in running state.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 2 minutes for introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2ed6cf30fbeadf43e77dc896ddd9f57f4a9fd43"}, "originalPosition": 381}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUxNDk3Nw==", "bodyText": "this code is duplicated in all test methods, can be refactored..next PR is fine for this change", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r424514977", "createdAt": "2020-05-13T15:09:57Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,998 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"miiaddcluster\";\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+  }\n+\n+  /**\n+   * Start a WebLogic domain without any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the ConfigMap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from the newly added cluster are in running state.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 2 minutes for introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods restarted sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+    // The ServerNamePrefix for the new dynamic cluster is dynamic-server\n+    // Make sure the managed server from the new cluster is running\n+    //\n+    String newServerPodName = domainUid + \"-dynamic-server1\";\n+    checkPodCreated(newServerPodName, domainUid, domainNamespace);\n+    checkPodReady(newServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(newServerPodName, domainNamespace);\n+\n+    boolean isPodRestarted  =\n+        assertDoesNotThrow(() -> isPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime),\n+            String.format(\"Check if the admin pod is restarted\"));\n+    assertTrue(isPodRestarted, \"Admin pod has not been restarted as expected\");\n+\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    try {\n+      checkCluster = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2ed6cf30fbeadf43e77dc896ddd9f57f4a9fd43"}, "originalPosition": 419}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMDg4NTYy", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-411088562", "createdAt": "2020-05-13T16:17:34Z", "commit": {"oid": "a2ed6cf30fbeadf43e77dc896ddd9f57f4a9fd43"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNjoxNzozNFrOGU5YPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNjoxNzozNFrOGU5YPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU2NDc5Nw==", "bodyText": "This is what I think you should do for these tests,\n\ncreate the domain resource in beforeAll method\nverify the domain and cluster(if any existing) is running in beforeEach method\nTests should be just adding new cluster/patch/verify rolling restart etc.. no need for ordering, tests can run in an order...lot of code can be moved to beforeAll and beforeEach methods.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r424564797", "createdAt": "2020-05-13T16:17:34Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,998 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"miiaddcluster\";\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+  }\n+\n+  /**\n+   * Start a WebLogic domain without any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the ConfigMap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from the newly added cluster are in running state.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2ed6cf30fbeadf43e77dc896ddd9f57f4a9fd43"}, "originalPosition": 233}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5668feebdef576cd7e4f4f751114fe1e5176e313", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5668feebdef576cd7e4f4f751114fe1e5176e313", "committedDate": "2020-05-13T18:02:56Z", "message": "Resolved more review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMjI5NDEz", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-411229413", "createdAt": "2020-05-13T19:22:17Z", "commit": {"oid": "5668feebdef576cd7e4f4f751114fe1e5176e313"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOToyMjoxN1rOGVAL6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOToyODo1MVrOGVAZ8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3NjMyOQ==", "bodyText": "move BeforeAll method to the beginning", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r424676329", "createdAt": "2020-05-13T19:22:17Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,933 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5668feebdef576cd7e4f4f751114fe1e5176e313"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3Njk3OQ==", "bodyText": "do you still need the order? I don't think so, remove it.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r424676979", "createdAt": "2020-05-13T19:23:25Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,933 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+  }\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5668feebdef576cd7e4f4f751114fe1e5176e313"}, "originalPosition": 316}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3NzE3NQ==", "bodyText": "This test uses the WebLogic domain created in beforeAll method", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r424677175", "createdAt": "2020-05-13T19:23:49Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,933 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+  }\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+\n+    // This test uses the WebLogic domain created beforeEach method", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5668feebdef576cd7e4f4f751114fe1e5176e313"}, "originalPosition": 322}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3OTE0NA==", "bodyText": "checkPodCreated() and checkPodReady() method wait/check for 5 minutes. Isn't that enough irrespective of the new assertion? If that 5 minutes if not enough, that needs to be increased rather than hard sleep of 2 minutes.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r424679144", "createdAt": "2020-05-13T19:27:26Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,998 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"miiaddcluster\";\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+  }\n+\n+  /**\n+   * Start a WebLogic domain without any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the ConfigMap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from the newly added cluster are in running state.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 2 minutes for introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUxMzgzNg=="}, "originalCommit": {"oid": "a2ed6cf30fbeadf43e77dc896ddd9f57f4a9fd43"}, "originalPosition": 381}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3OTkyMw==", "bodyText": "same comment as above", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r424679923", "createdAt": "2020-05-13T19:28:51Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,933 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+  }\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+\n+    // This test uses the WebLogic domain created beforeEach method\n+    // beforeEach method make sure the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 2 minutes for introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    // ToDo need a better Assertion to verify rolling restart\n+    logger.info(\"Check admin server pod {0} to be restarted in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods restarted sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+    // The ServerNamePrefix for the new dynamic cluster is dynamic-server\n+    // Make sure the managed server from the new cluster is running\n+    //\n+    String newServerPodName = domainUid + \"-dynamic-server1\";\n+    checkPodCreated(newServerPodName, domainUid, domainNamespace);\n+    checkPodReady(newServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(newServerPodName, domainNamespace);\n+\n+    boolean isPodRestarted  =\n+        assertDoesNotThrow(() -> isPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime),\n+            String.format(\"Check if the admin pod is restarted\"));\n+    assertTrue(isPodRestarted, \"Admin pod has not been restarted as expected\");\n+\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    checkCluster = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+    checkCluster.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/tenant-monitoring/servers/dynamic-server1\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null\")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+    logger.info(\"curl command {0}\", new String(checkCluster));\n+    try {\n+      result = exec(new String(checkCluster), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Caught unexpected exception {0}\", ex);\n+      fail(\"Got unexpected exception\" + ex);\n+    }\n+\n+    logger.info(\"curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"Server configuration not found\");\n+    logger.info(\"Found the server configuration \");\n+\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a configured cluster.\n+   * Patch the domain resource with the configmap.\n+   * Update the restart version of the domain resource to 3\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5668feebdef576cd7e4f4f751114fe1e5176e313"}, "originalPosition": 463}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd75d203a0c0188e7a45559f2abeb954c8755b1e", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/cd75d203a0c0188e7a45559f2abeb954c8755b1e", "committedDate": "2020-05-14T01:36:44Z", "message": "Remove the AddCluster usecase to another PR"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExNzM3MjY5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#pullrequestreview-411737269", "createdAt": "2020-05-14T12:08:01Z", "commit": {"oid": "cd75d203a0c0188e7a45559f2abeb954c8755b1e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4693, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}