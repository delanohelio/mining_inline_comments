{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY4MTIwNjc5", "number": 1870, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQyMTowOTowN1rOEYniAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNDoyOToxMVrOEcmkhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MjQ4OTYxOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItPodsShutdown.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQyMTowOTowN1rOHBDY4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNDozNTozOVrOHGbLHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2NjE0NA==", "bodyText": "should we change it to k8s API?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1870#discussion_r470866144", "createdAt": "2020-08-14T21:09:07Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItPodsShutdown.java", "diffHunk": "@@ -0,0 +1,290 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.domain.Shutdown;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * This test is to verify shutdown rules when shutdown properties are defined at different levels\n+ * (domain, cluster, adminServer and managedServer level).\n+ */\n+@DisplayName(\"Verify shutdown rules when shutdown properties are defined at different levels\")\n+@IntegrationTest\n+class ItPodsShutdown {\n+\n+  private static String domainNamespace = null;\n+\n+  // domain constants\n+  private static final String domainUid = \"domain1\";\n+  private static final String clusterName = \"cluster-1\";\n+  private static final int replicaCount = 1;\n+  private static final String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private static final String managedServerPrefix = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE;\n+  private static final String managedServer1Name = \"managed-server1\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Get namespaces for operator and WebLogic domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create a basic model in image domain\n+    createAndVerifyMiiDomain();\n+  }\n+\n+  /**\n+   * This test is to verify shutdown rules when shutdown options of serverPos are defined\n+   * at domain level, adminServer level and cluster and managedServer level.\n+   * step 1: Create one managed server domain with the following settings\n+   * domain: SHUTDOWN_TYPE -> Graceful.\n+   * adminServer: SHUTDOWN_TYPE -> Forced.\n+   *              SHUTDOWN_IGNORE_SESSIONS -> true.\n+   *              SHUTDOWN_TIMEOUT -> 40.\n+   * cluster: SHUTDOWN_IGNORE_SESSIONS -> true.\n+   *          SHUTDOWN_TIMEOUT -> 80.\n+   * managedServer1: SHUTDOWN_TIMEOUT -> 100.\n+   * step2: Scale cluster with two managed servers.\n+   * step 3: Verify shutdown properties of admin server, managedServer1 and newly scaled up managedServer2.\n+   * Domain level \"Graceful\" SHUTDOWN_TYPE overrides server level setting and is used for all servers.\n+   * So adminServer has \"Graceful\" SHUTDOWN_TYPE, default \"false\" SHUTDOWN_IGNORE_SESSIONS and\n+   * configured \"40\" SHUTDOWN_TIMEOUT.\n+   * Managed level setting overrides cluster level setting so managedServer1 has configured \"100\"\n+   * SHUTDOWN_TIMEOUT, cluster level \"true\" SHUTDOWN_IGNORE_SESSIONS  \"true\" and \"Graceful\" SHUTDOWN_TYPE.\n+   * Newly scaled up managedServer2 takes setting from combination of domain level and cluster level\n+   * with \"Graceful\" SHUTDOWN_TYPE, \"true\" SHUTDOWN_IGNORE_SESSIONS and default \"30\" SHUTDOWN_TIMEOUT\n+   */\n+  @Test\n+  @DisplayName(\"Verify shutdown rules when shutdown properties are defined at different levels \")\n+  public void testShutdownProps() {\n+\n+    //scare the cluster to 2 managed servers\n+    assertThat(assertDoesNotThrow(() -> scaleCluster(domainUid, domainNamespace, clusterName, 2)))\n+        .as(\"Verify scaling cluster {0} of domain {1} in namespace {2} succeeds\",\n+              clusterName, domainUid, domainNamespace)\n+        .withFailMessage(\"Scaling cluster {0} of domain {1} in namespace {2} failed\",\n+              clusterName, domainUid, domainNamespace)\n+        .isTrue();\n+    assertDoesNotThrow(() -> TimeUnit.SECONDS.sleep(30));\n+\n+    assertTrue(verifyServerShutdownProp(adminServerPodName, domainNamespace, \"Graceful\", \"40\", \"false\"));\n+    assertTrue(verifyServerShutdownProp(managedServerPrefix + 1, domainNamespace, \"Graceful\", \"100\", \"true\"));\n+    assertTrue(verifyServerShutdownProp(managedServerPrefix + 2, domainNamespace, \"Graceful\", \"30\", \"true\"));\n+  }\n+\n+  /**\n+   * Create a model in image domain and verify the server pods are ready.\n+   */\n+  private static void createAndVerifyMiiDomain() {\n+\n+    // get the pre-built image created by IntegrationTestWatcher\n+    String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Creating docker registry secret in namespace {0}\", domainNamespace);\n+    createDockerRegistrySecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Creating secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Creating encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \"weblogicenc\", \"weblogicenc\");\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"SHUTDOWN_TYPE\")\n+                    .value(\"Graceful\")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .serverPod(new ServerPod().shutdown(new Shutdown().shutdownType(\"Forced\")))\n+                .serverPod(new ServerPod().shutdown(new Shutdown().ignoreSessions(true)))\n+                .serverPod(new ServerPod().shutdown(new Shutdown().timeoutSeconds(40L))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")\n+                .serverPod(new ServerPod().shutdown(new Shutdown().timeoutSeconds(80L)))\n+                .serverPod(new ServerPod().shutdown(new Shutdown().ignoreSessions(true))))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(WLS_DOMAIN_TYPE)\n+                    .runtimeEncryptionSecret(encryptionSecretName)))\n+            .addManagedServersItem(new ManagedServer()\n+                .serverName(managedServer1Name)\n+                .serverPod(new ServerPod().shutdown(new Shutdown().timeoutSeconds(100L)))));\n+\n+    // create model in image domain\n+    logger.info(\"Creating model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainAndVerify(domain, domainNamespace);\n+\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin server pod is ready\n+    logger.info(\"Checking that admin server pod {0} is ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin service exists in the domain namespace\n+    logger.info(\"Checking that admin service {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // check for managed server pods existence in the domain namespace\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = managedServerPrefix + i;\n+\n+      // check that the managed server pod exists in the domain namespace\n+      logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodExists(managedServerPodName, domainUid, domainNamespace);\n+\n+      // check that the managed server pod is ready\n+      logger.info(\"Checking that managed server pod {0} is ready in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodReady(managedServerPodName, domainUid, domainNamespace);\n+\n+      // check that the managed server service exists in the domain namespace\n+      logger.info(\"Checking that managed server service {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkServiceExists(managedServerPodName, domainNamespace);\n+    }\n+  }\n+\n+  /**\n+   * Verify the server pod Shutdown properties.\n+   */\n+  private static boolean verifyServerShutdownProp(\n+      String podName,\n+      String domainNS,\n+      String... props) {\n+\n+    StringBuffer cmd = new StringBuffer(\"kubectl get pod \");\n+    cmd.append(podName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f031230c00189e6aed7432cd9f479b258888616"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2OTM5MQ==", "bodyText": "Do you mean using something like\nDomain domain1 = getDomainCustomResource(domainUid, domainNamespace) then from there to domain1.get(xx).get(xx)...\nIf yes, it would be the same as it was originally defined. I might misunderstand you though.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1870#discussion_r470869391", "createdAt": "2020-08-14T21:17:48Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItPodsShutdown.java", "diffHunk": "@@ -0,0 +1,290 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.domain.Shutdown;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * This test is to verify shutdown rules when shutdown properties are defined at different levels\n+ * (domain, cluster, adminServer and managedServer level).\n+ */\n+@DisplayName(\"Verify shutdown rules when shutdown properties are defined at different levels\")\n+@IntegrationTest\n+class ItPodsShutdown {\n+\n+  private static String domainNamespace = null;\n+\n+  // domain constants\n+  private static final String domainUid = \"domain1\";\n+  private static final String clusterName = \"cluster-1\";\n+  private static final int replicaCount = 1;\n+  private static final String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private static final String managedServerPrefix = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE;\n+  private static final String managedServer1Name = \"managed-server1\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Get namespaces for operator and WebLogic domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create a basic model in image domain\n+    createAndVerifyMiiDomain();\n+  }\n+\n+  /**\n+   * This test is to verify shutdown rules when shutdown options of serverPos are defined\n+   * at domain level, adminServer level and cluster and managedServer level.\n+   * step 1: Create one managed server domain with the following settings\n+   * domain: SHUTDOWN_TYPE -> Graceful.\n+   * adminServer: SHUTDOWN_TYPE -> Forced.\n+   *              SHUTDOWN_IGNORE_SESSIONS -> true.\n+   *              SHUTDOWN_TIMEOUT -> 40.\n+   * cluster: SHUTDOWN_IGNORE_SESSIONS -> true.\n+   *          SHUTDOWN_TIMEOUT -> 80.\n+   * managedServer1: SHUTDOWN_TIMEOUT -> 100.\n+   * step2: Scale cluster with two managed servers.\n+   * step 3: Verify shutdown properties of admin server, managedServer1 and newly scaled up managedServer2.\n+   * Domain level \"Graceful\" SHUTDOWN_TYPE overrides server level setting and is used for all servers.\n+   * So adminServer has \"Graceful\" SHUTDOWN_TYPE, default \"false\" SHUTDOWN_IGNORE_SESSIONS and\n+   * configured \"40\" SHUTDOWN_TIMEOUT.\n+   * Managed level setting overrides cluster level setting so managedServer1 has configured \"100\"\n+   * SHUTDOWN_TIMEOUT, cluster level \"true\" SHUTDOWN_IGNORE_SESSIONS  \"true\" and \"Graceful\" SHUTDOWN_TYPE.\n+   * Newly scaled up managedServer2 takes setting from combination of domain level and cluster level\n+   * with \"Graceful\" SHUTDOWN_TYPE, \"true\" SHUTDOWN_IGNORE_SESSIONS and default \"30\" SHUTDOWN_TIMEOUT\n+   */\n+  @Test\n+  @DisplayName(\"Verify shutdown rules when shutdown properties are defined at different levels \")\n+  public void testShutdownProps() {\n+\n+    //scare the cluster to 2 managed servers\n+    assertThat(assertDoesNotThrow(() -> scaleCluster(domainUid, domainNamespace, clusterName, 2)))\n+        .as(\"Verify scaling cluster {0} of domain {1} in namespace {2} succeeds\",\n+              clusterName, domainUid, domainNamespace)\n+        .withFailMessage(\"Scaling cluster {0} of domain {1} in namespace {2} failed\",\n+              clusterName, domainUid, domainNamespace)\n+        .isTrue();\n+    assertDoesNotThrow(() -> TimeUnit.SECONDS.sleep(30));\n+\n+    assertTrue(verifyServerShutdownProp(adminServerPodName, domainNamespace, \"Graceful\", \"40\", \"false\"));\n+    assertTrue(verifyServerShutdownProp(managedServerPrefix + 1, domainNamespace, \"Graceful\", \"100\", \"true\"));\n+    assertTrue(verifyServerShutdownProp(managedServerPrefix + 2, domainNamespace, \"Graceful\", \"30\", \"true\"));\n+  }\n+\n+  /**\n+   * Create a model in image domain and verify the server pods are ready.\n+   */\n+  private static void createAndVerifyMiiDomain() {\n+\n+    // get the pre-built image created by IntegrationTestWatcher\n+    String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Creating docker registry secret in namespace {0}\", domainNamespace);\n+    createDockerRegistrySecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Creating secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Creating encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \"weblogicenc\", \"weblogicenc\");\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"SHUTDOWN_TYPE\")\n+                    .value(\"Graceful\")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .serverPod(new ServerPod().shutdown(new Shutdown().shutdownType(\"Forced\")))\n+                .serverPod(new ServerPod().shutdown(new Shutdown().ignoreSessions(true)))\n+                .serverPod(new ServerPod().shutdown(new Shutdown().timeoutSeconds(40L))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")\n+                .serverPod(new ServerPod().shutdown(new Shutdown().timeoutSeconds(80L)))\n+                .serverPod(new ServerPod().shutdown(new Shutdown().ignoreSessions(true))))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(WLS_DOMAIN_TYPE)\n+                    .runtimeEncryptionSecret(encryptionSecretName)))\n+            .addManagedServersItem(new ManagedServer()\n+                .serverName(managedServer1Name)\n+                .serverPod(new ServerPod().shutdown(new Shutdown().timeoutSeconds(100L)))));\n+\n+    // create model in image domain\n+    logger.info(\"Creating model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainAndVerify(domain, domainNamespace);\n+\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin server pod is ready\n+    logger.info(\"Checking that admin server pod {0} is ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin service exists in the domain namespace\n+    logger.info(\"Checking that admin service {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // check for managed server pods existence in the domain namespace\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = managedServerPrefix + i;\n+\n+      // check that the managed server pod exists in the domain namespace\n+      logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodExists(managedServerPodName, domainUid, domainNamespace);\n+\n+      // check that the managed server pod is ready\n+      logger.info(\"Checking that managed server pod {0} is ready in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodReady(managedServerPodName, domainUid, domainNamespace);\n+\n+      // check that the managed server service exists in the domain namespace\n+      logger.info(\"Checking that managed server service {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkServiceExists(managedServerPodName, domainNamespace);\n+    }\n+  }\n+\n+  /**\n+   * Verify the server pod Shutdown properties.\n+   */\n+  private static boolean verifyServerShutdownProp(\n+      String podName,\n+      String domainNS,\n+      String... props) {\n+\n+    StringBuffer cmd = new StringBuffer(\"kubectl get pod \");\n+    cmd.append(podName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2NjE0NA=="}, "originalCommit": {"oid": "5f031230c00189e6aed7432cd9f479b258888616"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg3NjU4MQ==", "bodyText": "no I meant to use this:\nV1Pod managedServerPod = Kubernetes.getPod(domainNS, null, managedServerPodName);\n//check that managed server pod is up and all applicable variable values are initialized.\nassertNotNull(managedServerPod,\"The managed server pod does not exist in namespace \" + domainNS);\nV1ObjectMeta managedServerMetadata = managedServerPod.getMetadata();\nString serverName = managedServerMetadata.getLabels().get(\"servername\");\n\nyou can retrieve all data from there", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1870#discussion_r470876581", "createdAt": "2020-08-14T21:38:57Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItPodsShutdown.java", "diffHunk": "@@ -0,0 +1,290 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.domain.Shutdown;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * This test is to verify shutdown rules when shutdown properties are defined at different levels\n+ * (domain, cluster, adminServer and managedServer level).\n+ */\n+@DisplayName(\"Verify shutdown rules when shutdown properties are defined at different levels\")\n+@IntegrationTest\n+class ItPodsShutdown {\n+\n+  private static String domainNamespace = null;\n+\n+  // domain constants\n+  private static final String domainUid = \"domain1\";\n+  private static final String clusterName = \"cluster-1\";\n+  private static final int replicaCount = 1;\n+  private static final String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private static final String managedServerPrefix = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE;\n+  private static final String managedServer1Name = \"managed-server1\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Get namespaces for operator and WebLogic domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create a basic model in image domain\n+    createAndVerifyMiiDomain();\n+  }\n+\n+  /**\n+   * This test is to verify shutdown rules when shutdown options of serverPos are defined\n+   * at domain level, adminServer level and cluster and managedServer level.\n+   * step 1: Create one managed server domain with the following settings\n+   * domain: SHUTDOWN_TYPE -> Graceful.\n+   * adminServer: SHUTDOWN_TYPE -> Forced.\n+   *              SHUTDOWN_IGNORE_SESSIONS -> true.\n+   *              SHUTDOWN_TIMEOUT -> 40.\n+   * cluster: SHUTDOWN_IGNORE_SESSIONS -> true.\n+   *          SHUTDOWN_TIMEOUT -> 80.\n+   * managedServer1: SHUTDOWN_TIMEOUT -> 100.\n+   * step2: Scale cluster with two managed servers.\n+   * step 3: Verify shutdown properties of admin server, managedServer1 and newly scaled up managedServer2.\n+   * Domain level \"Graceful\" SHUTDOWN_TYPE overrides server level setting and is used for all servers.\n+   * So adminServer has \"Graceful\" SHUTDOWN_TYPE, default \"false\" SHUTDOWN_IGNORE_SESSIONS and\n+   * configured \"40\" SHUTDOWN_TIMEOUT.\n+   * Managed level setting overrides cluster level setting so managedServer1 has configured \"100\"\n+   * SHUTDOWN_TIMEOUT, cluster level \"true\" SHUTDOWN_IGNORE_SESSIONS  \"true\" and \"Graceful\" SHUTDOWN_TYPE.\n+   * Newly scaled up managedServer2 takes setting from combination of domain level and cluster level\n+   * with \"Graceful\" SHUTDOWN_TYPE, \"true\" SHUTDOWN_IGNORE_SESSIONS and default \"30\" SHUTDOWN_TIMEOUT\n+   */\n+  @Test\n+  @DisplayName(\"Verify shutdown rules when shutdown properties are defined at different levels \")\n+  public void testShutdownProps() {\n+\n+    //scare the cluster to 2 managed servers\n+    assertThat(assertDoesNotThrow(() -> scaleCluster(domainUid, domainNamespace, clusterName, 2)))\n+        .as(\"Verify scaling cluster {0} of domain {1} in namespace {2} succeeds\",\n+              clusterName, domainUid, domainNamespace)\n+        .withFailMessage(\"Scaling cluster {0} of domain {1} in namespace {2} failed\",\n+              clusterName, domainUid, domainNamespace)\n+        .isTrue();\n+    assertDoesNotThrow(() -> TimeUnit.SECONDS.sleep(30));\n+\n+    assertTrue(verifyServerShutdownProp(adminServerPodName, domainNamespace, \"Graceful\", \"40\", \"false\"));\n+    assertTrue(verifyServerShutdownProp(managedServerPrefix + 1, domainNamespace, \"Graceful\", \"100\", \"true\"));\n+    assertTrue(verifyServerShutdownProp(managedServerPrefix + 2, domainNamespace, \"Graceful\", \"30\", \"true\"));\n+  }\n+\n+  /**\n+   * Create a model in image domain and verify the server pods are ready.\n+   */\n+  private static void createAndVerifyMiiDomain() {\n+\n+    // get the pre-built image created by IntegrationTestWatcher\n+    String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Creating docker registry secret in namespace {0}\", domainNamespace);\n+    createDockerRegistrySecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Creating secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Creating encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \"weblogicenc\", \"weblogicenc\");\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"SHUTDOWN_TYPE\")\n+                    .value(\"Graceful\")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .serverPod(new ServerPod().shutdown(new Shutdown().shutdownType(\"Forced\")))\n+                .serverPod(new ServerPod().shutdown(new Shutdown().ignoreSessions(true)))\n+                .serverPod(new ServerPod().shutdown(new Shutdown().timeoutSeconds(40L))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")\n+                .serverPod(new ServerPod().shutdown(new Shutdown().timeoutSeconds(80L)))\n+                .serverPod(new ServerPod().shutdown(new Shutdown().ignoreSessions(true))))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(WLS_DOMAIN_TYPE)\n+                    .runtimeEncryptionSecret(encryptionSecretName)))\n+            .addManagedServersItem(new ManagedServer()\n+                .serverName(managedServer1Name)\n+                .serverPod(new ServerPod().shutdown(new Shutdown().timeoutSeconds(100L)))));\n+\n+    // create model in image domain\n+    logger.info(\"Creating model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainAndVerify(domain, domainNamespace);\n+\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin server pod is ready\n+    logger.info(\"Checking that admin server pod {0} is ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin service exists in the domain namespace\n+    logger.info(\"Checking that admin service {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // check for managed server pods existence in the domain namespace\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = managedServerPrefix + i;\n+\n+      // check that the managed server pod exists in the domain namespace\n+      logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodExists(managedServerPodName, domainUid, domainNamespace);\n+\n+      // check that the managed server pod is ready\n+      logger.info(\"Checking that managed server pod {0} is ready in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodReady(managedServerPodName, domainUid, domainNamespace);\n+\n+      // check that the managed server service exists in the domain namespace\n+      logger.info(\"Checking that managed server service {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkServiceExists(managedServerPodName, domainNamespace);\n+    }\n+  }\n+\n+  /**\n+   * Verify the server pod Shutdown properties.\n+   */\n+  private static boolean verifyServerShutdownProp(\n+      String podName,\n+      String domainNS,\n+      String... props) {\n+\n+    StringBuffer cmd = new StringBuffer(\"kubectl get pod \");\n+    cmd.append(podName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2NjE0NA=="}, "originalCommit": {"oid": "5f031230c00189e6aed7432cd9f479b258888616"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg3ODU4MA==", "bodyText": "Sure. Let me change it", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1870#discussion_r470878580", "createdAt": "2020-08-14T21:45:22Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItPodsShutdown.java", "diffHunk": "@@ -0,0 +1,290 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.domain.Shutdown;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * This test is to verify shutdown rules when shutdown properties are defined at different levels\n+ * (domain, cluster, adminServer and managedServer level).\n+ */\n+@DisplayName(\"Verify shutdown rules when shutdown properties are defined at different levels\")\n+@IntegrationTest\n+class ItPodsShutdown {\n+\n+  private static String domainNamespace = null;\n+\n+  // domain constants\n+  private static final String domainUid = \"domain1\";\n+  private static final String clusterName = \"cluster-1\";\n+  private static final int replicaCount = 1;\n+  private static final String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private static final String managedServerPrefix = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE;\n+  private static final String managedServer1Name = \"managed-server1\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Get namespaces for operator and WebLogic domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create a basic model in image domain\n+    createAndVerifyMiiDomain();\n+  }\n+\n+  /**\n+   * This test is to verify shutdown rules when shutdown options of serverPos are defined\n+   * at domain level, adminServer level and cluster and managedServer level.\n+   * step 1: Create one managed server domain with the following settings\n+   * domain: SHUTDOWN_TYPE -> Graceful.\n+   * adminServer: SHUTDOWN_TYPE -> Forced.\n+   *              SHUTDOWN_IGNORE_SESSIONS -> true.\n+   *              SHUTDOWN_TIMEOUT -> 40.\n+   * cluster: SHUTDOWN_IGNORE_SESSIONS -> true.\n+   *          SHUTDOWN_TIMEOUT -> 80.\n+   * managedServer1: SHUTDOWN_TIMEOUT -> 100.\n+   * step2: Scale cluster with two managed servers.\n+   * step 3: Verify shutdown properties of admin server, managedServer1 and newly scaled up managedServer2.\n+   * Domain level \"Graceful\" SHUTDOWN_TYPE overrides server level setting and is used for all servers.\n+   * So adminServer has \"Graceful\" SHUTDOWN_TYPE, default \"false\" SHUTDOWN_IGNORE_SESSIONS and\n+   * configured \"40\" SHUTDOWN_TIMEOUT.\n+   * Managed level setting overrides cluster level setting so managedServer1 has configured \"100\"\n+   * SHUTDOWN_TIMEOUT, cluster level \"true\" SHUTDOWN_IGNORE_SESSIONS  \"true\" and \"Graceful\" SHUTDOWN_TYPE.\n+   * Newly scaled up managedServer2 takes setting from combination of domain level and cluster level\n+   * with \"Graceful\" SHUTDOWN_TYPE, \"true\" SHUTDOWN_IGNORE_SESSIONS and default \"30\" SHUTDOWN_TIMEOUT\n+   */\n+  @Test\n+  @DisplayName(\"Verify shutdown rules when shutdown properties are defined at different levels \")\n+  public void testShutdownProps() {\n+\n+    //scare the cluster to 2 managed servers\n+    assertThat(assertDoesNotThrow(() -> scaleCluster(domainUid, domainNamespace, clusterName, 2)))\n+        .as(\"Verify scaling cluster {0} of domain {1} in namespace {2} succeeds\",\n+              clusterName, domainUid, domainNamespace)\n+        .withFailMessage(\"Scaling cluster {0} of domain {1} in namespace {2} failed\",\n+              clusterName, domainUid, domainNamespace)\n+        .isTrue();\n+    assertDoesNotThrow(() -> TimeUnit.SECONDS.sleep(30));\n+\n+    assertTrue(verifyServerShutdownProp(adminServerPodName, domainNamespace, \"Graceful\", \"40\", \"false\"));\n+    assertTrue(verifyServerShutdownProp(managedServerPrefix + 1, domainNamespace, \"Graceful\", \"100\", \"true\"));\n+    assertTrue(verifyServerShutdownProp(managedServerPrefix + 2, domainNamespace, \"Graceful\", \"30\", \"true\"));\n+  }\n+\n+  /**\n+   * Create a model in image domain and verify the server pods are ready.\n+   */\n+  private static void createAndVerifyMiiDomain() {\n+\n+    // get the pre-built image created by IntegrationTestWatcher\n+    String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Creating docker registry secret in namespace {0}\", domainNamespace);\n+    createDockerRegistrySecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Creating secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Creating encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \"weblogicenc\", \"weblogicenc\");\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"SHUTDOWN_TYPE\")\n+                    .value(\"Graceful\")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .serverPod(new ServerPod().shutdown(new Shutdown().shutdownType(\"Forced\")))\n+                .serverPod(new ServerPod().shutdown(new Shutdown().ignoreSessions(true)))\n+                .serverPod(new ServerPod().shutdown(new Shutdown().timeoutSeconds(40L))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")\n+                .serverPod(new ServerPod().shutdown(new Shutdown().timeoutSeconds(80L)))\n+                .serverPod(new ServerPod().shutdown(new Shutdown().ignoreSessions(true))))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(WLS_DOMAIN_TYPE)\n+                    .runtimeEncryptionSecret(encryptionSecretName)))\n+            .addManagedServersItem(new ManagedServer()\n+                .serverName(managedServer1Name)\n+                .serverPod(new ServerPod().shutdown(new Shutdown().timeoutSeconds(100L)))));\n+\n+    // create model in image domain\n+    logger.info(\"Creating model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainAndVerify(domain, domainNamespace);\n+\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin server pod is ready\n+    logger.info(\"Checking that admin server pod {0} is ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin service exists in the domain namespace\n+    logger.info(\"Checking that admin service {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // check for managed server pods existence in the domain namespace\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = managedServerPrefix + i;\n+\n+      // check that the managed server pod exists in the domain namespace\n+      logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodExists(managedServerPodName, domainUid, domainNamespace);\n+\n+      // check that the managed server pod is ready\n+      logger.info(\"Checking that managed server pod {0} is ready in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodReady(managedServerPodName, domainUid, domainNamespace);\n+\n+      // check that the managed server service exists in the domain namespace\n+      logger.info(\"Checking that managed server service {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkServiceExists(managedServerPodName, domainNamespace);\n+    }\n+  }\n+\n+  /**\n+   * Verify the server pod Shutdown properties.\n+   */\n+  private static boolean verifyServerShutdownProp(\n+      String podName,\n+      String domainNS,\n+      String... props) {\n+\n+    StringBuffer cmd = new StringBuffer(\"kubectl get pod \");\n+    cmd.append(podName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2NjE0NA=="}, "originalCommit": {"oid": "5f031230c00189e6aed7432cd9f479b258888616"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ5ODcxNw==", "bodyText": "Done. Please review. Thanks.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1870#discussion_r476498717", "createdAt": "2020-08-25T14:35:39Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItPodsShutdown.java", "diffHunk": "@@ -0,0 +1,290 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.domain.Shutdown;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * This test is to verify shutdown rules when shutdown properties are defined at different levels\n+ * (domain, cluster, adminServer and managedServer level).\n+ */\n+@DisplayName(\"Verify shutdown rules when shutdown properties are defined at different levels\")\n+@IntegrationTest\n+class ItPodsShutdown {\n+\n+  private static String domainNamespace = null;\n+\n+  // domain constants\n+  private static final String domainUid = \"domain1\";\n+  private static final String clusterName = \"cluster-1\";\n+  private static final int replicaCount = 1;\n+  private static final String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private static final String managedServerPrefix = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE;\n+  private static final String managedServer1Name = \"managed-server1\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Get namespaces for operator and WebLogic domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create a basic model in image domain\n+    createAndVerifyMiiDomain();\n+  }\n+\n+  /**\n+   * This test is to verify shutdown rules when shutdown options of serverPos are defined\n+   * at domain level, adminServer level and cluster and managedServer level.\n+   * step 1: Create one managed server domain with the following settings\n+   * domain: SHUTDOWN_TYPE -> Graceful.\n+   * adminServer: SHUTDOWN_TYPE -> Forced.\n+   *              SHUTDOWN_IGNORE_SESSIONS -> true.\n+   *              SHUTDOWN_TIMEOUT -> 40.\n+   * cluster: SHUTDOWN_IGNORE_SESSIONS -> true.\n+   *          SHUTDOWN_TIMEOUT -> 80.\n+   * managedServer1: SHUTDOWN_TIMEOUT -> 100.\n+   * step2: Scale cluster with two managed servers.\n+   * step 3: Verify shutdown properties of admin server, managedServer1 and newly scaled up managedServer2.\n+   * Domain level \"Graceful\" SHUTDOWN_TYPE overrides server level setting and is used for all servers.\n+   * So adminServer has \"Graceful\" SHUTDOWN_TYPE, default \"false\" SHUTDOWN_IGNORE_SESSIONS and\n+   * configured \"40\" SHUTDOWN_TIMEOUT.\n+   * Managed level setting overrides cluster level setting so managedServer1 has configured \"100\"\n+   * SHUTDOWN_TIMEOUT, cluster level \"true\" SHUTDOWN_IGNORE_SESSIONS  \"true\" and \"Graceful\" SHUTDOWN_TYPE.\n+   * Newly scaled up managedServer2 takes setting from combination of domain level and cluster level\n+   * with \"Graceful\" SHUTDOWN_TYPE, \"true\" SHUTDOWN_IGNORE_SESSIONS and default \"30\" SHUTDOWN_TIMEOUT\n+   */\n+  @Test\n+  @DisplayName(\"Verify shutdown rules when shutdown properties are defined at different levels \")\n+  public void testShutdownProps() {\n+\n+    //scare the cluster to 2 managed servers\n+    assertThat(assertDoesNotThrow(() -> scaleCluster(domainUid, domainNamespace, clusterName, 2)))\n+        .as(\"Verify scaling cluster {0} of domain {1} in namespace {2} succeeds\",\n+              clusterName, domainUid, domainNamespace)\n+        .withFailMessage(\"Scaling cluster {0} of domain {1} in namespace {2} failed\",\n+              clusterName, domainUid, domainNamespace)\n+        .isTrue();\n+    assertDoesNotThrow(() -> TimeUnit.SECONDS.sleep(30));\n+\n+    assertTrue(verifyServerShutdownProp(adminServerPodName, domainNamespace, \"Graceful\", \"40\", \"false\"));\n+    assertTrue(verifyServerShutdownProp(managedServerPrefix + 1, domainNamespace, \"Graceful\", \"100\", \"true\"));\n+    assertTrue(verifyServerShutdownProp(managedServerPrefix + 2, domainNamespace, \"Graceful\", \"30\", \"true\"));\n+  }\n+\n+  /**\n+   * Create a model in image domain and verify the server pods are ready.\n+   */\n+  private static void createAndVerifyMiiDomain() {\n+\n+    // get the pre-built image created by IntegrationTestWatcher\n+    String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Creating docker registry secret in namespace {0}\", domainNamespace);\n+    createDockerRegistrySecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Creating secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Creating encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \"weblogicenc\", \"weblogicenc\");\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"SHUTDOWN_TYPE\")\n+                    .value(\"Graceful\")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .serverPod(new ServerPod().shutdown(new Shutdown().shutdownType(\"Forced\")))\n+                .serverPod(new ServerPod().shutdown(new Shutdown().ignoreSessions(true)))\n+                .serverPod(new ServerPod().shutdown(new Shutdown().timeoutSeconds(40L))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")\n+                .serverPod(new ServerPod().shutdown(new Shutdown().timeoutSeconds(80L)))\n+                .serverPod(new ServerPod().shutdown(new Shutdown().ignoreSessions(true))))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(WLS_DOMAIN_TYPE)\n+                    .runtimeEncryptionSecret(encryptionSecretName)))\n+            .addManagedServersItem(new ManagedServer()\n+                .serverName(managedServer1Name)\n+                .serverPod(new ServerPod().shutdown(new Shutdown().timeoutSeconds(100L)))));\n+\n+    // create model in image domain\n+    logger.info(\"Creating model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainAndVerify(domain, domainNamespace);\n+\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin server pod is ready\n+    logger.info(\"Checking that admin server pod {0} is ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin service exists in the domain namespace\n+    logger.info(\"Checking that admin service {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // check for managed server pods existence in the domain namespace\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = managedServerPrefix + i;\n+\n+      // check that the managed server pod exists in the domain namespace\n+      logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodExists(managedServerPodName, domainUid, domainNamespace);\n+\n+      // check that the managed server pod is ready\n+      logger.info(\"Checking that managed server pod {0} is ready in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodReady(managedServerPodName, domainUid, domainNamespace);\n+\n+      // check that the managed server service exists in the domain namespace\n+      logger.info(\"Checking that managed server service {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkServiceExists(managedServerPodName, domainNamespace);\n+    }\n+  }\n+\n+  /**\n+   * Verify the server pod Shutdown properties.\n+   */\n+  private static boolean verifyServerShutdownProp(\n+      String podName,\n+      String domainNS,\n+      String... props) {\n+\n+    StringBuffer cmd = new StringBuffer(\"kubectl get pod \");\n+    cmd.append(podName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2NjE0NA=="}, "originalCommit": {"oid": "5f031230c00189e6aed7432cd9f479b258888616"}, "originalPosition": 260}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTcwODY5OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItPodsShutdown.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNzoyMDozNVrOHGiEww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxOToxNjo1NlrOHGmQQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYxMTc3OQ==", "bodyText": "Description:  The test verifies different shutdown options specified at different scope in Domain Resource Definition\nRefer to Documentation link  https://oracle.github.io/weblogic-kubernetes-operator/userguide/managing-domains/domain-lifecycle/startup/", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1870#discussion_r476611779", "createdAt": "2020-08-25T17:20:35Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItPodsShutdown.java", "diffHunk": "@@ -0,0 +1,289 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.domain.Shutdown;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * This test is to verify shutdown rules when shutdown properties are defined at different levels\n+ * (domain, cluster, adminServer and managedServer level).\n+ */\n+@DisplayName(\"Verify shutdown rules when shutdown properties are defined at different levels\")\n+@IntegrationTest\n+class ItPodsShutdown {\n+\n+  private static String domainNamespace = null;\n+\n+  // domain constants\n+  private static final String domainUid = \"domain1\";\n+  private static final String clusterName = \"cluster-1\";\n+  private static final int replicaCount = 1;\n+  private static final String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private static final String managedServerPrefix = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE;\n+  private static final String managedServer1Name = \"managed-server1\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Get namespaces for operator and WebLogic domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create a basic model in image domain\n+    createAndVerifyMiiDomain();\n+  }\n+\n+  /**\n+   * This test is to verify shutdown rules when shutdown options of serverPos are defined", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3bb4336352f61e0b3cd4abbabe5eee53d1b41cea"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY4MDI1OQ==", "bodyText": "Done.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1870#discussion_r476680259", "createdAt": "2020-08-25T19:16:56Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItPodsShutdown.java", "diffHunk": "@@ -0,0 +1,289 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.domain.Shutdown;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * This test is to verify shutdown rules when shutdown properties are defined at different levels\n+ * (domain, cluster, adminServer and managedServer level).\n+ */\n+@DisplayName(\"Verify shutdown rules when shutdown properties are defined at different levels\")\n+@IntegrationTest\n+class ItPodsShutdown {\n+\n+  private static String domainNamespace = null;\n+\n+  // domain constants\n+  private static final String domainUid = \"domain1\";\n+  private static final String clusterName = \"cluster-1\";\n+  private static final int replicaCount = 1;\n+  private static final String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private static final String managedServerPrefix = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE;\n+  private static final String managedServer1Name = \"managed-server1\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Get namespaces for operator and WebLogic domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create a basic model in image domain\n+    createAndVerifyMiiDomain();\n+  }\n+\n+  /**\n+   * This test is to verify shutdown rules when shutdown options of serverPos are defined", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYxMTc3OQ=="}, "originalCommit": {"oid": "3bb4336352f61e0b3cd4abbabe5eee53d1b41cea"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTc0NTg2OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItPodsShutdown.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNzoyNTo1NVrOHGiYQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxOToyNDoyOFrOHGmgxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYxNjc3MA==", "bodyText": "( a manged server domain )  should be replaced with\nCreate a WebLogic Domain with a cluster and an independent manged server not part of cluster", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1870#discussion_r476616770", "createdAt": "2020-08-25T17:25:55Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItPodsShutdown.java", "diffHunk": "@@ -0,0 +1,289 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.domain.Shutdown;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * This test is to verify shutdown rules when shutdown properties are defined at different levels\n+ * (domain, cluster, adminServer and managedServer level).\n+ */\n+@DisplayName(\"Verify shutdown rules when shutdown properties are defined at different levels\")\n+@IntegrationTest\n+class ItPodsShutdown {\n+\n+  private static String domainNamespace = null;\n+\n+  // domain constants\n+  private static final String domainUid = \"domain1\";\n+  private static final String clusterName = \"cluster-1\";\n+  private static final int replicaCount = 1;\n+  private static final String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private static final String managedServerPrefix = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE;\n+  private static final String managedServer1Name = \"managed-server1\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Get namespaces for operator and WebLogic domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create a basic model in image domain\n+    createAndVerifyMiiDomain();\n+  }\n+\n+  /**\n+   * This test is to verify shutdown rules when shutdown options of serverPos are defined\n+   * at domain level, adminServer level and cluster and managedServer level.\n+   * step 1: Create one managed server domain with the following settings", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3bb4336352f61e0b3cd4abbabe5eee53d1b41cea"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY4NDQ4Ng==", "bodyText": "Modified the test description to state that \"Startup a WebLogic domain with one cluster that initially has one running managed server\". Using \"initially\" since the test later will scale up the cluster to have 2nd running managed server.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1870#discussion_r476684486", "createdAt": "2020-08-25T19:24:28Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItPodsShutdown.java", "diffHunk": "@@ -0,0 +1,289 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.domain.Shutdown;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * This test is to verify shutdown rules when shutdown properties are defined at different levels\n+ * (domain, cluster, adminServer and managedServer level).\n+ */\n+@DisplayName(\"Verify shutdown rules when shutdown properties are defined at different levels\")\n+@IntegrationTest\n+class ItPodsShutdown {\n+\n+  private static String domainNamespace = null;\n+\n+  // domain constants\n+  private static final String domainUid = \"domain1\";\n+  private static final String clusterName = \"cluster-1\";\n+  private static final int replicaCount = 1;\n+  private static final String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private static final String managedServerPrefix = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE;\n+  private static final String managedServer1Name = \"managed-server1\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Get namespaces for operator and WebLogic domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create a basic model in image domain\n+    createAndVerifyMiiDomain();\n+  }\n+\n+  /**\n+   * This test is to verify shutdown rules when shutdown options of serverPos are defined\n+   * at domain level, adminServer level and cluster and managedServer level.\n+   * step 1: Create one managed server domain with the following settings", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYxNjc3MA=="}, "originalCommit": {"oid": "3bb4336352f61e0b3cd4abbabe5eee53d1b41cea"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NDI3NTI1OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItPodsShutdownOption.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNDoyOToxMVrOHHO4sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNDozODo0OVrOHHPVJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM0NTk3MA==", "bodyText": "scare the cluster?  It is not Halloween yet...  Did you mean \"scale\"?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1870#discussion_r477345970", "createdAt": "2020-08-26T14:29:11Z", "author": {"login": "ddsharpe"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItPodsShutdownOption.java", "diffHunk": "@@ -0,0 +1,291 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.domain.Shutdown;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * This test is to verify shutdown rules when shutdown properties are defined at different levels\n+ * (domain, cluster, adminServer and managedServer level).\n+ */\n+@DisplayName(\"Verify shutdown rules when shutdown properties are defined at different levels\")\n+@IntegrationTest\n+class ItPodsShutdown {\n+\n+  private static String domainNamespace = null;\n+\n+  // domain constants\n+  private static final String domainUid = \"domain1\";\n+  private static final String clusterName = \"cluster-1\";\n+  private static final int replicaCount = 1;\n+  private static final String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private static final String managedServerPrefix = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE;\n+  private static final String managedServer1Name = \"managed-server1\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Get namespaces for operator and WebLogic domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create a basic model in image domain\n+    createAndVerifyMiiDomain();\n+  }\n+\n+  /**\n+   * This test is to verify different shutdown options specified at different scopes in Domain Resource Definition.\n+   * Refer to section \"Shutdown options\" of Documentation link:\n+   * https://oracle.github.io/weblogic-kubernetes-operator/userguide/managing-domains/domain-lifecycle/startup/\n+   * step 1: Startup a WebLogic domain with one cluster that initially has one running managed server. The shutdown option is\n+   * configured as follows:\n+   * domain: SHUTDOWN_TYPE -> Graceful.\n+   * adminServer: SHUTDOWN_TYPE -> Forced.\n+   *              SHUTDOWN_IGNORE_SESSIONS -> true.\n+   *              SHUTDOWN_TIMEOUT -> 40.\n+   * cluster: SHUTDOWN_IGNORE_SESSIONS -> true.\n+   *          SHUTDOWN_TIMEOUT -> 80.\n+   * managedServer1: SHUTDOWN_TIMEOUT -> 100.\n+   * step2: Scale cluster with two managed servers.\n+   * step 3: Verify shutdown properties of admin server, managedServer1 and newly scaled up managedServer2.\n+   * Domain level \"Graceful\" SHUTDOWN_TYPE overrides server level setting and is used for all servers.\n+   * So adminServer has \"Graceful\" SHUTDOWN_TYPE, default \"false\" SHUTDOWN_IGNORE_SESSIONS and\n+   * configured \"40\" SHUTDOWN_TIMEOUT.\n+   * Managed level setting overrides cluster level setting so managedServer1 has configured \"100\"\n+   * SHUTDOWN_TIMEOUT, cluster level \"true\" SHUTDOWN_IGNORE_SESSIONS  \"true\" and \"Graceful\" SHUTDOWN_TYPE.\n+   * Newly scaled up managedServer2 takes setting from combination of domain level and cluster level\n+   * with \"Graceful\" SHUTDOWN_TYPE, \"true\" SHUTDOWN_IGNORE_SESSIONS and default \"30\" SHUTDOWN_TIMEOUT\n+   */\n+  @Test\n+  @DisplayName(\"Verify shutdown rules when shutdown properties are defined at different levels \")\n+  public void testShutdownProps() throws ApiException {\n+\n+    //scare the cluster to 2 managed servers", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63586129f6e5b457d549a8398f4b0875b86d1752"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM1MzI1Mw==", "bodyText": "Corrected. Thanks!", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1870#discussion_r477353253", "createdAt": "2020-08-26T14:38:49Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItPodsShutdownOption.java", "diffHunk": "@@ -0,0 +1,291 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.domain.Shutdown;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * This test is to verify shutdown rules when shutdown properties are defined at different levels\n+ * (domain, cluster, adminServer and managedServer level).\n+ */\n+@DisplayName(\"Verify shutdown rules when shutdown properties are defined at different levels\")\n+@IntegrationTest\n+class ItPodsShutdown {\n+\n+  private static String domainNamespace = null;\n+\n+  // domain constants\n+  private static final String domainUid = \"domain1\";\n+  private static final String clusterName = \"cluster-1\";\n+  private static final int replicaCount = 1;\n+  private static final String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private static final String managedServerPrefix = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE;\n+  private static final String managedServer1Name = \"managed-server1\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Get namespaces for operator and WebLogic domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create a basic model in image domain\n+    createAndVerifyMiiDomain();\n+  }\n+\n+  /**\n+   * This test is to verify different shutdown options specified at different scopes in Domain Resource Definition.\n+   * Refer to section \"Shutdown options\" of Documentation link:\n+   * https://oracle.github.io/weblogic-kubernetes-operator/userguide/managing-domains/domain-lifecycle/startup/\n+   * step 1: Startup a WebLogic domain with one cluster that initially has one running managed server. The shutdown option is\n+   * configured as follows:\n+   * domain: SHUTDOWN_TYPE -> Graceful.\n+   * adminServer: SHUTDOWN_TYPE -> Forced.\n+   *              SHUTDOWN_IGNORE_SESSIONS -> true.\n+   *              SHUTDOWN_TIMEOUT -> 40.\n+   * cluster: SHUTDOWN_IGNORE_SESSIONS -> true.\n+   *          SHUTDOWN_TIMEOUT -> 80.\n+   * managedServer1: SHUTDOWN_TIMEOUT -> 100.\n+   * step2: Scale cluster with two managed servers.\n+   * step 3: Verify shutdown properties of admin server, managedServer1 and newly scaled up managedServer2.\n+   * Domain level \"Graceful\" SHUTDOWN_TYPE overrides server level setting and is used for all servers.\n+   * So adminServer has \"Graceful\" SHUTDOWN_TYPE, default \"false\" SHUTDOWN_IGNORE_SESSIONS and\n+   * configured \"40\" SHUTDOWN_TIMEOUT.\n+   * Managed level setting overrides cluster level setting so managedServer1 has configured \"100\"\n+   * SHUTDOWN_TIMEOUT, cluster level \"true\" SHUTDOWN_IGNORE_SESSIONS  \"true\" and \"Graceful\" SHUTDOWN_TYPE.\n+   * Newly scaled up managedServer2 takes setting from combination of domain level and cluster level\n+   * with \"Graceful\" SHUTDOWN_TYPE, \"true\" SHUTDOWN_IGNORE_SESSIONS and default \"30\" SHUTDOWN_TIMEOUT\n+   */\n+  @Test\n+  @DisplayName(\"Verify shutdown rules when shutdown properties are defined at different levels \")\n+  public void testShutdownProps() throws ApiException {\n+\n+    //scare the cluster to 2 managed servers", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM0NTk3MA=="}, "originalCommit": {"oid": "63586129f6e5b457d549a8398f4b0875b86d1752"}, "originalPosition": 128}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4201, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}