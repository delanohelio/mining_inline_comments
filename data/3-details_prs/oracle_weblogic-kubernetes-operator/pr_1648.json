{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3NzUyNTg3", "number": 1648, "title": "Create domain on persistent volume using WLST", "bodyText": "This PR adds a new It class ItDomainOnPV\n\nThe added test creates a WebLogic domain on a persistent volume and starts pods to use that domain\nAdded methods to get node port for any service\nAdded a login test for verifying WebLogic console access using HtmlUnit\nFixed a minor IntegrationTestWatcher incorrectly printing the name of the test when a test method throws exception.\n\nJenkins test results\nhttps://build.weblogick8s.org:8443/job/weblogic-kubernetes-operator-model-in-image-tests/666/testReport/", "createdAt": "2020-05-14T05:02:31Z", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648", "merged": true, "mergeCommit": {"oid": "dfa2680f632acb9f638a38a96b9c273d57ecaecd"}, "closed": true, "closedAt": "2020-05-18T19:20:41Z", "author": {"login": "sankarpn"}, "timelineItems": {"totalCount": 34, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABchCgpRgH2gAyNDE3NzUyNTg3OmIxZjI0YjFlYTlhMTI4MWFhYjY4MWVmMGQ3YTE5ZjUyZDk1NTdiYjU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcikD8kAH2gAyNDE3NzUyNTg3OjdlNzE1NzVkZTExNjkwYzU1YTc3NjQzNWZhMzQzNzkxMjE1NmYzNTY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b1f24b1ea9a1281aab681ef0d7a19f52d9557bb5", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b1f24b1ea9a1281aab681ef0d7a19f52d9557bb5", "committedDate": "2020-05-14T00:41:03Z", "message": "Adding domain on persistent volume test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ebf58e3fc6ad288f1be7fdc3db82f99eb90146f", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/7ebf58e3fc6ad288f1be7fdc3db82f99eb90146f", "committedDate": "2020-05-14T00:53:49Z", "message": "Adding the create domain py script"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "562f33d4806a01837216e0edcb90d54bf9fbe82e", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/562f33d4806a01837216e0edcb90d54bf9fbe82e", "committedDate": "2020-05-14T01:05:45Z", "message": "Fix the test name printed when the test method throws an exception"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06fff1c9994cddf7d72967596c88ee536ce18364", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/06fff1c9994cddf7d72967596c88ee536ce18364", "committedDate": "2020-05-14T03:37:40Z", "message": "Adding console login tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8a57802d806a2352b15eac8b101e328af3ca83d", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c8a57802d806a2352b15eac8b101e328af3ca83d", "committedDate": "2020-05-14T04:47:21Z", "message": "Added console login test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExODA4MDY0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#pullrequestreview-411808064", "createdAt": "2020-05-14T13:33:50Z", "commit": {"oid": "c8a57802d806a2352b15eac8b101e328af3ca83d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMzozMzo1MFrOGVcezQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMzozMzo1MFrOGVcezQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTEzOTkxNw==", "bodyText": "Add test... This keeps people happy who review our source because we won't have created a business approval to ship this jar.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425139917", "createdAt": "2020-05-14T13:33:50Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/pom.xml", "diffHunk": "@@ -81,6 +81,11 @@\n           <artifactId>commons-io</artifactId>\n           <scope>test</scope>\n         </dependency>\n+        <dependency>\n+          <groupId>net.sourceforge.htmlunit</groupId>\n+          <artifactId>htmlunit</artifactId>\n+          <version>2.40.0</version>\n+        </dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8a57802d806a2352b15eac8b101e328af3ca83d"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExODA4OTMy", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#pullrequestreview-411808932", "createdAt": "2020-05-14T13:34:47Z", "commit": {"oid": "c8a57802d806a2352b15eac8b101e328af3ca83d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMzozNDo0N1rOGVchoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMzozNDo0N1rOGVchoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE0MDY0MA==", "bodyText": "Is this missing or did you no longer need this?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425140640", "createdAt": "2020-05-14T13:34:47Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,700 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String dockerConfigJson = \"\";\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8a57802d806a2352b15eac8b101e328af3ca83d"}, "originalPosition": 149}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExODEyNTY1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#pullrequestreview-411812565", "createdAt": "2020-05-14T13:38:41Z", "commit": {"oid": "c8a57802d806a2352b15eac8b101e328af3ca83d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMzozODo0MVrOGVcsuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMzozODo0MVrOGVcsuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE0MzQ4Mw==", "bodyText": "Can you use TestConstants.PV_ROOT? I know already know this location will work in our various clusters.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425143483", "createdAt": "2020-05-14T13:38:41Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,700 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String dockerConfigJson = \"\";\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // login to docker-registry and create pull secrets\n+    createDockerSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(2)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> TestActions.getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Accessing admin server node port failed\");\n+    String consoleUrl = new StringBuffer()\n+        .append(\"http://\")\n+        .append(K8S_NODEPORT_HOST)\n+        .append(\":\")\n+        .append(serviceNodePort)\n+        .append(\"/console/login/LoginForm.jsp\").toString();\n+\n+    assertDoesNotThrow(() -> loginTest(consoleUrl, adminUser, adminPassword), \"Console login failed\");\n+  }\n+\n+  /**\n+   * Creates a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void createDomainOnPV() throws IOException {\n+\n+    logger.info(\"create a staging location for domain creation scripts\");\n+    Path pvTemp = Paths.get(WORK_DIR, \"ItDomainOnPV\", \"domainCreateTempPV\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8a57802d806a2352b15eac8b101e328af3ca83d"}, "originalPosition": 302}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExODIyMTI1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#pullrequestreview-411822125", "createdAt": "2020-05-14T13:48:28Z", "commit": {"oid": "c8a57802d806a2352b15eac8b101e328af3ca83d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMzo0ODoyOFrOGVdJbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMzo0ODoyOFrOGVdJbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE1MDgzMQ==", "bodyText": "This is good.  Just putting this comment here so that you know that for some kinds of clusters, such as OKE & OpenShift, the tests will not have direct file system access to the host path. We will need to come and change to later to run tests against OKE or OpenShift. In those cases, we will likely have an NFS mount and you won't be able to access the files from this code without doing something like running another job that mounts the pv/pvc.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425150831", "createdAt": "2020-05-14T13:48:28Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,700 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String dockerConfigJson = \"\";\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // login to docker-registry and create pull secrets\n+    createDockerSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(2)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> TestActions.getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Accessing admin server node port failed\");\n+    String consoleUrl = new StringBuffer()\n+        .append(\"http://\")\n+        .append(K8S_NODEPORT_HOST)\n+        .append(\":\")\n+        .append(serviceNodePort)\n+        .append(\"/console/login/LoginForm.jsp\").toString();\n+\n+    assertDoesNotThrow(() -> loginTest(consoleUrl, adminUser, adminPassword), \"Console login failed\");\n+  }\n+\n+  /**\n+   * Creates a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void createDomainOnPV() throws IOException {\n+\n+    logger.info(\"create a staging location for domain creation scripts\");\n+    Path pvTemp = Paths.get(WORK_DIR, \"ItDomainOnPV\", \"domainCreateTempPV\");\n+    FileUtils.deleteDirectory(pvTemp.toFile());\n+    Files.createDirectories(pvTemp);\n+\n+    logger.info(\"copy the create domain WLST script to staging location\");\n+    Path srcWlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = Paths.get(pvTemp.toString(), \"create-domain.py\");\n+    Files.copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"create WebLogic domain properties file\");\n+    Path domainPropertiesFile = Paths.get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(\n+        () -> createDomainProperties(domainPropertiesFile), \"Creating domain properties file failed\");\n+\n+    logger.info(\"add files to a config map for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Create a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles),\n+        \"Creating configmap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", \"system\");\n+    p.setProperty(\"admin_password\", \"gumby1234\");\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"32001\");\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+\n+    p.store(new FileOutputStream(wlstPropertiesFile.toFile()), \"wlst properties file\");\n+  }\n+\n+  /**\n+   * Create configmap containing domain scripts.\n+   * @param configMapName name of the configmap to create\n+   * @param files files to add in configmap\n+   * @throws IOException when reading the file fails\n+   * @throws ApiException when create configmap fails\n+   */\n+  private void createConfigMapForDomainCreation(String configMapName, List<Path> files)\n+      throws IOException, ApiException {\n+\n+    // add wlst domain creation python script and properties files\n+    // to create domain to the configmap\n+    Map<String, String> data = new HashMap<>();\n+    for (Path file : files) {\n+      data.put(file.getFileName().toString(), Files.readString(file));\n+    }\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> TestActions.createConfigMap(configMap),\n+        String.format(\"Failed to create configmap %s with files %s\", configMapName, files));\n+    assertTrue(cmCreated, String.format(\"Failed while creating ConfigMap %s\", configMapName));\n+  }\n+\n+  /**\n+   * Create job to create a domain on a persistent volume.\n+   */\n+  private void runCreateDomainJob(String pvName, String pvcName, String domainScriptCM, String namespace) {\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job\") // name of the create domain job\n+                .namespace(namespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\")  // change the ownership of the pv to opc:opc\n+                        .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(new V1Container()\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+                        .imagePullPolicy(\"IfNotPresent\")\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))) // mounted under /shared inside pod\n+                        .addCommandItem(\"/bin/sh\") //call wlst.sh script with py and properties file\n+                        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+                        .addArgsItem(\"/u01/weblogic/create-domain.py\")\n+                        .addArgsItem(\"-skipWLSModuleScanning\")\n+                        .addArgsItem(\"-loadProperties\")\n+                        .addArgsItem(\"/u01/weblogic/domain.properties\")))\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptCM))))  //config map containing domain scripts\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(\"docker-store\"))))));\n+    String jobName = assertDoesNotThrow(() -> TestActions\n+        .createNamespacedJob(jobBody), \"Domain creation job failed\");\n+\n+    logger.info(\"Checking if the domain creation job {0} completed in namespace {1}\",\n+        jobName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for job {0} to be completed in namespace {1} \"\n+                + \"(elapsed time {2} ms, remaining time {3} ms)\",\n+                jobName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(jobCompleted(jobName, null, namespace));\n+  }\n+\n+  /**\n+   * Create secret for docker credentials.\n+   */\n+  private void createDockerSecret() {\n+    // docker login, if necessary\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+    }\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", REPO_SECRET_NAME));\n+  }\n+\n+  /**\n+   * Create secret for WebLogic credentials.\n+   */\n+  private void createWebLogicCredentialsSecret() {\n+    logger.info(\"Creating secret for WebLogic credentials\");\n+    wlSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap<>();\n+    adminSecretMap.put(\"username\", adminUser);\n+    adminSecretMap.put(\"password\", adminPassword);\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(wlSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", wlSecretName));\n+  }\n+\n+  /**\n+   * Create a persistent volume and persistent volume claim.\n+   * @throws IOException when creating pv path fails\n+   */\n+  private void createPVandPVC() throws IOException {\n+    logger.info(\"creating persistent volume and persistent volume claim\");\n+\n+    Path pvHostPath = Files.createDirectories(Paths.get(\n+        TestConstants.PV_ROOT, this.getClass().getSimpleName(), domainUid + \"-persistentVolume\"));\n+    logger.info(\"Creating PV directory {0}\", pvHostPath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8a57802d806a2352b15eac8b101e328af3ca83d"}, "originalPosition": 513}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExODI0MjAw", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#pullrequestreview-411824200", "createdAt": "2020-05-14T13:50:31Z", "commit": {"oid": "c8a57802d806a2352b15eac8b101e328af3ca83d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5035891fe8ba1a037300b0c60d65d95d17b02c91", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5035891fe8ba1a037300b0c60d65d95d17b02c91", "committedDate": "2020-05-14T15:59:35Z", "message": "Addressing Ryan's comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f739ac9520183a8d75319a5aaf5666e797beea12", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f739ac9520183a8d75319a5aaf5666e797beea12", "committedDate": "2020-05-14T16:25:21Z", "message": "Change the repo name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4a35e1ee79b4cd77b7ef3d1f4cfb49b9cc81ceb", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d4a35e1ee79b4cd77b7ef3d1f4cfb49b9cc81ceb", "committedDate": "2020-05-14T17:09:16Z", "message": "Merge branch 'develop' into domainonpvusingwlst"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14513d9c868ad0415694cc1c00f8d6550a56b057", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/14513d9c868ad0415694cc1c00f8d6550a56b057", "committedDate": "2020-05-14T17:30:54Z", "message": "Creating a docker config json for repo secret"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59d343f03a59d469725eb1c418a8fa92a31f96d1", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/59d343f03a59d469725eb1c418a8fa92a31f96d1", "committedDate": "2020-05-14T18:10:58Z", "message": "Merge branch 'sankar-debug05132020' into domainonpvusingwlst"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dcab03b6bb9b9b931bf7dc9b86f7c499983dceb2", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/dcab03b6bb9b9b931bf7dc9b86f7c499983dceb2", "committedDate": "2020-05-14T19:38:10Z", "message": "Adding OCR related credentials"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4734a9394df7a21d875ef71ec02d6d2b1e03f2a5", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/4734a9394df7a21d875ef71ec02d6d2b1e03f2a5", "committedDate": "2020-05-14T20:17:11Z", "message": "use a local object"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyMTQ2NzE2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#pullrequestreview-412146716", "createdAt": "2020-05-14T20:09:02Z", "commit": {"oid": "dcab03b6bb9b9b931bf7dc9b86f7c499983dceb2"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQyMDowOTowMlrOGVsZKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQyMDo1MToxNlrOGVtukg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQwMDYxNw==", "bodyText": "are you also creating domain on pv using WDT?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425400617", "createdAt": "2020-05-14T20:09:02Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,708 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcab03b6bb9b9b931bf7dc9b86f7c499983dceb2"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQwMjMyNQ==", "bodyText": "use .replicas(replicaCount)", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425402325", "createdAt": "2020-05-14T20:12:13Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,708 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String dockerConfigJson = \"\";\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(2)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcab03b6bb9b9b931bf7dc9b86f7c499983dceb2"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQwNjE3Mg==", "bodyText": "you can static import TestActions.getServiceNodePort", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425406172", "createdAt": "2020-05-14T20:19:37Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,706 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(2)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> TestActions.getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4734a9394df7a21d875ef71ec02d6d2b1e03f2a5"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQwODk3MQ==", "bodyText": "You can use p.setProperty(\"admin_username\", adminUser) here", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425408971", "createdAt": "2020-05-14T20:24:54Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,706 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(2)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> TestActions.getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Accessing admin server node port failed\");\n+    String consoleUrl = new StringBuffer()\n+        .append(\"http://\")\n+        .append(K8S_NODEPORT_HOST)\n+        .append(\":\")\n+        .append(serviceNodePort)\n+        .append(\"/console/login/LoginForm.jsp\").toString();\n+\n+    assertDoesNotThrow(() -> loginTest(consoleUrl, adminUser, adminPassword), \"Console login failed\");\n+  }\n+\n+  /**\n+   * Creates a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void createDomainOnPV() throws IOException {\n+\n+    logger.info(\"create a staging location for domain creation scripts\");\n+    Path pvTemp = Paths.get(RESULTS_ROOT, \"ItDomainOnPV\", \"domainCreateTempPV\");\n+    FileUtils.deleteDirectory(pvTemp.toFile());\n+    Files.createDirectories(pvTemp);\n+\n+    logger.info(\"copy the create domain WLST script to staging location\");\n+    Path srcWlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = Paths.get(pvTemp.toString(), \"create-domain.py\");\n+    Files.copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"create WebLogic domain properties file\");\n+    Path domainPropertiesFile = Paths.get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(\n+        () -> createDomainProperties(domainPropertiesFile), \"Creating domain properties file failed\");\n+\n+    logger.info(\"add files to a config map for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Create a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles),\n+        \"Creating configmap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", \"system\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4734a9394df7a21d875ef71ec02d6d2b1e03f2a5"}, "originalPosition": 349}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQwOTI1Mg==", "bodyText": "You can use p.setProperty(\"admin_password\", adminPassword) here", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425409252", "createdAt": "2020-05-14T20:25:25Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,706 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(2)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> TestActions.getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Accessing admin server node port failed\");\n+    String consoleUrl = new StringBuffer()\n+        .append(\"http://\")\n+        .append(K8S_NODEPORT_HOST)\n+        .append(\":\")\n+        .append(serviceNodePort)\n+        .append(\"/console/login/LoginForm.jsp\").toString();\n+\n+    assertDoesNotThrow(() -> loginTest(consoleUrl, adminUser, adminPassword), \"Console login failed\");\n+  }\n+\n+  /**\n+   * Creates a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void createDomainOnPV() throws IOException {\n+\n+    logger.info(\"create a staging location for domain creation scripts\");\n+    Path pvTemp = Paths.get(RESULTS_ROOT, \"ItDomainOnPV\", \"domainCreateTempPV\");\n+    FileUtils.deleteDirectory(pvTemp.toFile());\n+    Files.createDirectories(pvTemp);\n+\n+    logger.info(\"copy the create domain WLST script to staging location\");\n+    Path srcWlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = Paths.get(pvTemp.toString(), \"create-domain.py\");\n+    Files.copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"create WebLogic domain properties file\");\n+    Path domainPropertiesFile = Paths.get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(\n+        () -> createDomainProperties(domainPropertiesFile), \"Creating domain properties file failed\");\n+\n+    logger.info(\"add files to a config map for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Create a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles),\n+        \"Creating configmap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", \"system\");\n+    p.setProperty(\"admin_password\", \"gumby1234\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4734a9394df7a21d875ef71ec02d6d2b1e03f2a5"}, "originalPosition": 350}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQxMDIyNg==", "bodyText": "when create domain custom resource, you used:\n.addChannelsItem(new Channel()\n.channelName(\"T3Channel\")\n.nodePort(0))))\nDo you want to hard code the admin_t3_channel_port here?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425410226", "createdAt": "2020-05-14T20:27:20Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,706 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(2)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> TestActions.getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Accessing admin server node port failed\");\n+    String consoleUrl = new StringBuffer()\n+        .append(\"http://\")\n+        .append(K8S_NODEPORT_HOST)\n+        .append(\":\")\n+        .append(serviceNodePort)\n+        .append(\"/console/login/LoginForm.jsp\").toString();\n+\n+    assertDoesNotThrow(() -> loginTest(consoleUrl, adminUser, adminPassword), \"Console login failed\");\n+  }\n+\n+  /**\n+   * Creates a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void createDomainOnPV() throws IOException {\n+\n+    logger.info(\"create a staging location for domain creation scripts\");\n+    Path pvTemp = Paths.get(RESULTS_ROOT, \"ItDomainOnPV\", \"domainCreateTempPV\");\n+    FileUtils.deleteDirectory(pvTemp.toFile());\n+    Files.createDirectories(pvTemp);\n+\n+    logger.info(\"copy the create domain WLST script to staging location\");\n+    Path srcWlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = Paths.get(pvTemp.toString(), \"create-domain.py\");\n+    Files.copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"create WebLogic domain properties file\");\n+    Path domainPropertiesFile = Paths.get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(\n+        () -> createDomainProperties(domainPropertiesFile), \"Creating domain properties file failed\");\n+\n+    logger.info(\"add files to a config map for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Create a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles),\n+        \"Creating configmap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", \"system\");\n+    p.setProperty(\"admin_password\", \"gumby1234\");\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"32001\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4734a9394df7a21d875ef71ec02d6d2b1e03f2a5"}, "originalPosition": 352}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQxMTIxMQ==", "bodyText": "You can static import TestActions.createConfigMap", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425411211", "createdAt": "2020-05-14T20:29:09Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,706 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(2)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> TestActions.getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Accessing admin server node port failed\");\n+    String consoleUrl = new StringBuffer()\n+        .append(\"http://\")\n+        .append(K8S_NODEPORT_HOST)\n+        .append(\":\")\n+        .append(serviceNodePort)\n+        .append(\"/console/login/LoginForm.jsp\").toString();\n+\n+    assertDoesNotThrow(() -> loginTest(consoleUrl, adminUser, adminPassword), \"Console login failed\");\n+  }\n+\n+  /**\n+   * Creates a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void createDomainOnPV() throws IOException {\n+\n+    logger.info(\"create a staging location for domain creation scripts\");\n+    Path pvTemp = Paths.get(RESULTS_ROOT, \"ItDomainOnPV\", \"domainCreateTempPV\");\n+    FileUtils.deleteDirectory(pvTemp.toFile());\n+    Files.createDirectories(pvTemp);\n+\n+    logger.info(\"copy the create domain WLST script to staging location\");\n+    Path srcWlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = Paths.get(pvTemp.toString(), \"create-domain.py\");\n+    Files.copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"create WebLogic domain properties file\");\n+    Path domainPropertiesFile = Paths.get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(\n+        () -> createDomainProperties(domainPropertiesFile), \"Creating domain properties file failed\");\n+\n+    logger.info(\"add files to a config map for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Create a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles),\n+        \"Creating configmap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", \"system\");\n+    p.setProperty(\"admin_password\", \"gumby1234\");\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"32001\");\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+\n+    p.store(new FileOutputStream(wlstPropertiesFile.toFile()), \"wlst properties file\");\n+  }\n+\n+  /**\n+   * Create configmap containing domain scripts.\n+   * @param configMapName name of the configmap to create\n+   * @param files files to add in configmap\n+   * @throws IOException when reading the file fails\n+   * @throws ApiException when create configmap fails\n+   */\n+  private void createConfigMapForDomainCreation(String configMapName, List<Path> files)\n+      throws IOException, ApiException {\n+\n+    // add wlst domain creation python script and properties files\n+    // to create domain to the configmap\n+    Map<String, String> data = new HashMap<>();\n+    for (Path file : files) {\n+      data.put(file.getFileName().toString(), Files.readString(file));\n+    }\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> TestActions.createConfigMap(configMap),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4734a9394df7a21d875ef71ec02d6d2b1e03f2a5"}, "originalPosition": 384}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQxMjgwNw==", "bodyText": "you can static import TestActions.createNamespacedJob here", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425412807", "createdAt": "2020-05-14T20:32:03Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,706 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(2)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> TestActions.getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Accessing admin server node port failed\");\n+    String consoleUrl = new StringBuffer()\n+        .append(\"http://\")\n+        .append(K8S_NODEPORT_HOST)\n+        .append(\":\")\n+        .append(serviceNodePort)\n+        .append(\"/console/login/LoginForm.jsp\").toString();\n+\n+    assertDoesNotThrow(() -> loginTest(consoleUrl, adminUser, adminPassword), \"Console login failed\");\n+  }\n+\n+  /**\n+   * Creates a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void createDomainOnPV() throws IOException {\n+\n+    logger.info(\"create a staging location for domain creation scripts\");\n+    Path pvTemp = Paths.get(RESULTS_ROOT, \"ItDomainOnPV\", \"domainCreateTempPV\");\n+    FileUtils.deleteDirectory(pvTemp.toFile());\n+    Files.createDirectories(pvTemp);\n+\n+    logger.info(\"copy the create domain WLST script to staging location\");\n+    Path srcWlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = Paths.get(pvTemp.toString(), \"create-domain.py\");\n+    Files.copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"create WebLogic domain properties file\");\n+    Path domainPropertiesFile = Paths.get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(\n+        () -> createDomainProperties(domainPropertiesFile), \"Creating domain properties file failed\");\n+\n+    logger.info(\"add files to a config map for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Create a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles),\n+        \"Creating configmap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", \"system\");\n+    p.setProperty(\"admin_password\", \"gumby1234\");\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"32001\");\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+\n+    p.store(new FileOutputStream(wlstPropertiesFile.toFile()), \"wlst properties file\");\n+  }\n+\n+  /**\n+   * Create configmap containing domain scripts.\n+   * @param configMapName name of the configmap to create\n+   * @param files files to add in configmap\n+   * @throws IOException when reading the file fails\n+   * @throws ApiException when create configmap fails\n+   */\n+  private void createConfigMapForDomainCreation(String configMapName, List<Path> files)\n+      throws IOException, ApiException {\n+\n+    // add wlst domain creation python script and properties files\n+    // to create domain to the configmap\n+    Map<String, String> data = new HashMap<>();\n+    for (Path file : files) {\n+      data.put(file.getFileName().toString(), Files.readString(file));\n+    }\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> TestActions.createConfigMap(configMap),\n+        String.format(\"Failed to create configmap %s with files %s\", configMapName, files));\n+    assertTrue(cmCreated, String.format(\"Failed while creating ConfigMap %s\", configMapName));\n+  }\n+\n+  /**\n+   * Create job to create a domain on a persistent volume.\n+   */\n+  private void runCreateDomainJob(String pvName, String pvcName, String domainScriptCM, String namespace) {\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job\") // name of the create domain job\n+                .namespace(namespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\")  // change the ownership of the pv to opc:opc\n+                        .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(new V1Container()\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+                        .imagePullPolicy(\"IfNotPresent\")\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))) // mounted under /shared inside pod\n+                        .addCommandItem(\"/bin/sh\") //call wlst.sh script with py and properties file\n+                        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+                        .addArgsItem(\"/u01/weblogic/create-domain.py\")\n+                        .addArgsItem(\"-skipWLSModuleScanning\")\n+                        .addArgsItem(\"-loadProperties\")\n+                        .addArgsItem(\"/u01/weblogic/domain.properties\")))\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptCM))))  //config map containing domain scripts\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))))));\n+    String jobName = assertDoesNotThrow(() -> TestActions\n+        .createNamespacedJob(jobBody), \"Domain creation job failed\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4734a9394df7a21d875ef71ec02d6d2b1e03f2a5"}, "originalPosition": 450}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQxMzE0Mg==", "bodyText": "delete this empty line", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425413142", "createdAt": "2020-05-14T20:32:45Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,706 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(2)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> TestActions.getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Accessing admin server node port failed\");\n+    String consoleUrl = new StringBuffer()\n+        .append(\"http://\")\n+        .append(K8S_NODEPORT_HOST)\n+        .append(\":\")\n+        .append(serviceNodePort)\n+        .append(\"/console/login/LoginForm.jsp\").toString();\n+\n+    assertDoesNotThrow(() -> loginTest(consoleUrl, adminUser, adminPassword), \"Console login failed\");\n+  }\n+\n+  /**\n+   * Creates a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void createDomainOnPV() throws IOException {\n+\n+    logger.info(\"create a staging location for domain creation scripts\");\n+    Path pvTemp = Paths.get(RESULTS_ROOT, \"ItDomainOnPV\", \"domainCreateTempPV\");\n+    FileUtils.deleteDirectory(pvTemp.toFile());\n+    Files.createDirectories(pvTemp);\n+\n+    logger.info(\"copy the create domain WLST script to staging location\");\n+    Path srcWlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = Paths.get(pvTemp.toString(), \"create-domain.py\");\n+    Files.copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"create WebLogic domain properties file\");\n+    Path domainPropertiesFile = Paths.get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(\n+        () -> createDomainProperties(domainPropertiesFile), \"Creating domain properties file failed\");\n+\n+    logger.info(\"add files to a config map for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Create a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles),\n+        \"Creating configmap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", \"system\");\n+    p.setProperty(\"admin_password\", \"gumby1234\");\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"32001\");\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+\n+    p.store(new FileOutputStream(wlstPropertiesFile.toFile()), \"wlst properties file\");\n+  }\n+\n+  /**\n+   * Create configmap containing domain scripts.\n+   * @param configMapName name of the configmap to create\n+   * @param files files to add in configmap\n+   * @throws IOException when reading the file fails\n+   * @throws ApiException when create configmap fails\n+   */\n+  private void createConfigMapForDomainCreation(String configMapName, List<Path> files)\n+      throws IOException, ApiException {\n+\n+    // add wlst domain creation python script and properties files\n+    // to create domain to the configmap\n+    Map<String, String> data = new HashMap<>();\n+    for (Path file : files) {\n+      data.put(file.getFileName().toString(), Files.readString(file));\n+    }\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> TestActions.createConfigMap(configMap),\n+        String.format(\"Failed to create configmap %s with files %s\", configMapName, files));\n+    assertTrue(cmCreated, String.format(\"Failed while creating ConfigMap %s\", configMapName));\n+  }\n+\n+  /**\n+   * Create job to create a domain on a persistent volume.\n+   */\n+  private void runCreateDomainJob(String pvName, String pvcName, String domainScriptCM, String namespace) {\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job\") // name of the create domain job\n+                .namespace(namespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\")  // change the ownership of the pv to opc:opc\n+                        .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(new V1Container()\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+                        .imagePullPolicy(\"IfNotPresent\")\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))) // mounted under /shared inside pod\n+                        .addCommandItem(\"/bin/sh\") //call wlst.sh script with py and properties file\n+                        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+                        .addArgsItem(\"/u01/weblogic/create-domain.py\")\n+                        .addArgsItem(\"-skipWLSModuleScanning\")\n+                        .addArgsItem(\"-loadProperties\")\n+                        .addArgsItem(\"/u01/weblogic/domain.properties\")))\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptCM))))  //config map containing domain scripts\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))))));\n+    String jobName = assertDoesNotThrow(() -> TestActions\n+        .createNamespacedJob(jobBody), \"Domain creation job failed\");\n+\n+    logger.info(\"Checking if the domain creation job {0} completed in namespace {1}\",\n+        jobName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for job {0} to be completed in namespace {1} \"\n+                + \"(elapsed time {2} ms, remaining time {3} ms)\",\n+                jobName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(jobCompleted(jobName, null, namespace));\n+  }\n+\n+  /**\n+   * Create secret for docker credentials.\n+   */\n+  private void createOCRRepoSecret() {\n+\n+    // docker login, if necessary\n+    logger.info(\"docker login to OCR registry\");\n+    assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"login to OCR failed\");\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4734a9394df7a21d875ef71ec02d6d2b1e03f2a5"}, "originalPosition": 474}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQxNDE4NA==", "bodyText": "you can static import TestConstants.PV_ROOT here.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425414184", "createdAt": "2020-05-14T20:34:52Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,706 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(2)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> TestActions.getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Accessing admin server node port failed\");\n+    String consoleUrl = new StringBuffer()\n+        .append(\"http://\")\n+        .append(K8S_NODEPORT_HOST)\n+        .append(\":\")\n+        .append(serviceNodePort)\n+        .append(\"/console/login/LoginForm.jsp\").toString();\n+\n+    assertDoesNotThrow(() -> loginTest(consoleUrl, adminUser, adminPassword), \"Console login failed\");\n+  }\n+\n+  /**\n+   * Creates a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void createDomainOnPV() throws IOException {\n+\n+    logger.info(\"create a staging location for domain creation scripts\");\n+    Path pvTemp = Paths.get(RESULTS_ROOT, \"ItDomainOnPV\", \"domainCreateTempPV\");\n+    FileUtils.deleteDirectory(pvTemp.toFile());\n+    Files.createDirectories(pvTemp);\n+\n+    logger.info(\"copy the create domain WLST script to staging location\");\n+    Path srcWlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = Paths.get(pvTemp.toString(), \"create-domain.py\");\n+    Files.copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"create WebLogic domain properties file\");\n+    Path domainPropertiesFile = Paths.get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(\n+        () -> createDomainProperties(domainPropertiesFile), \"Creating domain properties file failed\");\n+\n+    logger.info(\"add files to a config map for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Create a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles),\n+        \"Creating configmap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", \"system\");\n+    p.setProperty(\"admin_password\", \"gumby1234\");\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"32001\");\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+\n+    p.store(new FileOutputStream(wlstPropertiesFile.toFile()), \"wlst properties file\");\n+  }\n+\n+  /**\n+   * Create configmap containing domain scripts.\n+   * @param configMapName name of the configmap to create\n+   * @param files files to add in configmap\n+   * @throws IOException when reading the file fails\n+   * @throws ApiException when create configmap fails\n+   */\n+  private void createConfigMapForDomainCreation(String configMapName, List<Path> files)\n+      throws IOException, ApiException {\n+\n+    // add wlst domain creation python script and properties files\n+    // to create domain to the configmap\n+    Map<String, String> data = new HashMap<>();\n+    for (Path file : files) {\n+      data.put(file.getFileName().toString(), Files.readString(file));\n+    }\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> TestActions.createConfigMap(configMap),\n+        String.format(\"Failed to create configmap %s with files %s\", configMapName, files));\n+    assertTrue(cmCreated, String.format(\"Failed while creating ConfigMap %s\", configMapName));\n+  }\n+\n+  /**\n+   * Create job to create a domain on a persistent volume.\n+   */\n+  private void runCreateDomainJob(String pvName, String pvcName, String domainScriptCM, String namespace) {\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job\") // name of the create domain job\n+                .namespace(namespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\")  // change the ownership of the pv to opc:opc\n+                        .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(new V1Container()\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+                        .imagePullPolicy(\"IfNotPresent\")\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))) // mounted under /shared inside pod\n+                        .addCommandItem(\"/bin/sh\") //call wlst.sh script with py and properties file\n+                        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+                        .addArgsItem(\"/u01/weblogic/create-domain.py\")\n+                        .addArgsItem(\"-skipWLSModuleScanning\")\n+                        .addArgsItem(\"-loadProperties\")\n+                        .addArgsItem(\"/u01/weblogic/domain.properties\")))\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptCM))))  //config map containing domain scripts\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))))));\n+    String jobName = assertDoesNotThrow(() -> TestActions\n+        .createNamespacedJob(jobBody), \"Domain creation job failed\");\n+\n+    logger.info(\"Checking if the domain creation job {0} completed in namespace {1}\",\n+        jobName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for job {0} to be completed in namespace {1} \"\n+                + \"(elapsed time {2} ms, remaining time {3} ms)\",\n+                jobName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(jobCompleted(jobName, null, namespace));\n+  }\n+\n+  /**\n+   * Create secret for docker credentials.\n+   */\n+  private void createOCRRepoSecret() {\n+\n+    // docker login, if necessary\n+    logger.info(\"docker login to OCR registry\");\n+    assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"login to OCR failed\");\n+\n+\n+    logger.info(\"Creating repository registry secret in namespace {0}\", domainNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        OCR_USERNAME, OCR_PASSWORD, OCR_EMAIL, OCR_REGISTRY);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(OCR_SECRET_NAME)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", OCR_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", OCR_SECRET_NAME));\n+  }\n+\n+  /**\n+   * Create secret for WebLogic credentials.\n+   */\n+  private void createWebLogicCredentialsSecret() {\n+    logger.info(\"Creating secret for WebLogic credentials\");\n+    wlSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap<>();\n+    adminSecretMap.put(\"username\", adminUser);\n+    adminSecretMap.put(\"password\", adminPassword);\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(wlSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", wlSecretName));\n+  }\n+\n+  /**\n+   * Create a persistent volume and persistent volume claim.\n+   * @throws IOException when creating pv path fails\n+   */\n+  private void createPVandPVC() throws IOException {\n+    logger.info(\"creating persistent volume and persistent volume claim\");\n+\n+    Path pvHostPath = Files.createDirectories(Paths.get(\n+        TestConstants.PV_ROOT, this.getClass().getSimpleName(), domainUid + \"-persistentVolume\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4734a9394df7a21d875ef71ec02d6d2b1e03f2a5"}, "originalPosition": 518}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQxNDk5MA==", "bodyText": "you can static import TestActions.createPersistentVolumeClaim here.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425414990", "createdAt": "2020-05-14T20:36:28Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,706 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(2)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> TestActions.getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Accessing admin server node port failed\");\n+    String consoleUrl = new StringBuffer()\n+        .append(\"http://\")\n+        .append(K8S_NODEPORT_HOST)\n+        .append(\":\")\n+        .append(serviceNodePort)\n+        .append(\"/console/login/LoginForm.jsp\").toString();\n+\n+    assertDoesNotThrow(() -> loginTest(consoleUrl, adminUser, adminPassword), \"Console login failed\");\n+  }\n+\n+  /**\n+   * Creates a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void createDomainOnPV() throws IOException {\n+\n+    logger.info(\"create a staging location for domain creation scripts\");\n+    Path pvTemp = Paths.get(RESULTS_ROOT, \"ItDomainOnPV\", \"domainCreateTempPV\");\n+    FileUtils.deleteDirectory(pvTemp.toFile());\n+    Files.createDirectories(pvTemp);\n+\n+    logger.info(\"copy the create domain WLST script to staging location\");\n+    Path srcWlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = Paths.get(pvTemp.toString(), \"create-domain.py\");\n+    Files.copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"create WebLogic domain properties file\");\n+    Path domainPropertiesFile = Paths.get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(\n+        () -> createDomainProperties(domainPropertiesFile), \"Creating domain properties file failed\");\n+\n+    logger.info(\"add files to a config map for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Create a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles),\n+        \"Creating configmap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", \"system\");\n+    p.setProperty(\"admin_password\", \"gumby1234\");\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"32001\");\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+\n+    p.store(new FileOutputStream(wlstPropertiesFile.toFile()), \"wlst properties file\");\n+  }\n+\n+  /**\n+   * Create configmap containing domain scripts.\n+   * @param configMapName name of the configmap to create\n+   * @param files files to add in configmap\n+   * @throws IOException when reading the file fails\n+   * @throws ApiException when create configmap fails\n+   */\n+  private void createConfigMapForDomainCreation(String configMapName, List<Path> files)\n+      throws IOException, ApiException {\n+\n+    // add wlst domain creation python script and properties files\n+    // to create domain to the configmap\n+    Map<String, String> data = new HashMap<>();\n+    for (Path file : files) {\n+      data.put(file.getFileName().toString(), Files.readString(file));\n+    }\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> TestActions.createConfigMap(configMap),\n+        String.format(\"Failed to create configmap %s with files %s\", configMapName, files));\n+    assertTrue(cmCreated, String.format(\"Failed while creating ConfigMap %s\", configMapName));\n+  }\n+\n+  /**\n+   * Create job to create a domain on a persistent volume.\n+   */\n+  private void runCreateDomainJob(String pvName, String pvcName, String domainScriptCM, String namespace) {\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job\") // name of the create domain job\n+                .namespace(namespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\")  // change the ownership of the pv to opc:opc\n+                        .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(new V1Container()\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+                        .imagePullPolicy(\"IfNotPresent\")\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))) // mounted under /shared inside pod\n+                        .addCommandItem(\"/bin/sh\") //call wlst.sh script with py and properties file\n+                        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+                        .addArgsItem(\"/u01/weblogic/create-domain.py\")\n+                        .addArgsItem(\"-skipWLSModuleScanning\")\n+                        .addArgsItem(\"-loadProperties\")\n+                        .addArgsItem(\"/u01/weblogic/domain.properties\")))\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptCM))))  //config map containing domain scripts\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))))));\n+    String jobName = assertDoesNotThrow(() -> TestActions\n+        .createNamespacedJob(jobBody), \"Domain creation job failed\");\n+\n+    logger.info(\"Checking if the domain creation job {0} completed in namespace {1}\",\n+        jobName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for job {0} to be completed in namespace {1} \"\n+                + \"(elapsed time {2} ms, remaining time {3} ms)\",\n+                jobName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(jobCompleted(jobName, null, namespace));\n+  }\n+\n+  /**\n+   * Create secret for docker credentials.\n+   */\n+  private void createOCRRepoSecret() {\n+\n+    // docker login, if necessary\n+    logger.info(\"docker login to OCR registry\");\n+    assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"login to OCR failed\");\n+\n+\n+    logger.info(\"Creating repository registry secret in namespace {0}\", domainNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        OCR_USERNAME, OCR_PASSWORD, OCR_EMAIL, OCR_REGISTRY);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(OCR_SECRET_NAME)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", OCR_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", OCR_SECRET_NAME));\n+  }\n+\n+  /**\n+   * Create secret for WebLogic credentials.\n+   */\n+  private void createWebLogicCredentialsSecret() {\n+    logger.info(\"Creating secret for WebLogic credentials\");\n+    wlSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap<>();\n+    adminSecretMap.put(\"username\", adminUser);\n+    adminSecretMap.put(\"password\", adminPassword);\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(wlSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", wlSecretName));\n+  }\n+\n+  /**\n+   * Create a persistent volume and persistent volume claim.\n+   * @throws IOException when creating pv path fails\n+   */\n+  private void createPVandPVC() throws IOException {\n+    logger.info(\"creating persistent volume and persistent volume claim\");\n+\n+    Path pvHostPath = Files.createDirectories(Paths.get(\n+        TestConstants.PV_ROOT, this.getClass().getSimpleName(), domainUid + \"-persistentVolume\"));\n+    logger.info(\"Creating PV directory {0}\", pvHostPath);\n+    FileUtils.deleteDirectory(pvHostPath.toFile());\n+    Files.createDirectories(pvHostPath);\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Recycle\")\n+            .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(pvHostPath.toString())))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvName)\n+            .withNamespace(domainNamespace)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+    boolean success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolume(v1pv),\n+        \"Persistent volume creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolume creation failed\");\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeName(pvName)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvcName)\n+            .withNamespace(domainNamespace)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+    success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolumeClaim(v1pvc),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4734a9394df7a21d875ef71ec02d6d2b1e03f2a5"}, "originalPosition": 560}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyMTUyOQ==", "bodyText": "null pointer check for createdJob.getMetadata()", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425421529", "createdAt": "2020-05-14T20:49:28Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1491,92 +1528,32 @@ public static V1ServiceList listServices(String namespace) {\n   }\n \n   /**\n-   * Get V1Service object for the given service name, label and namespace.\n+   * Create a job.\n    *\n-   * @param serviceName name of the service to look for\n-   * @param label key value pair with which the service is decorated with\n-   * @param namespace namespace in which to check for the service\n-   * @return V1Service object if found otherwise null\n-   * @throws ApiException when there is an error in querying the cluster\n-   */\n-  public static V1Service getService(\n-      String serviceName, Map<String, String> label, String namespace)\n-      throws ApiException {\n-    String labelSelector = null;\n-    if (label != null) {\n-      String key = label.keySet().iterator().next().toString();\n-      String value = label.get(key).toString();\n-      labelSelector = String.format(\"%s in (%s)\", key, value);\n-      logger.info(labelSelector);\n-    }\n-    V1ServiceList v1ServiceList\n-        = coreV1Api.listServiceForAllNamespaces(\n-        Boolean.FALSE, // allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n-        null, // continue to query when there is more results to return.\n-        null, // selector to restrict the list of returned objects by their fields\n-        labelSelector, // selector to restrict the list of returned objects by their labels.\n-        null, // maximum number of responses to return for a list call.\n-        Boolean.FALSE.toString(), // pretty print output.\n-        null, // shows changes that occur after that particular version of a resource.\n-        null, // Timeout for the list/watch call.\n-        Boolean.FALSE // Watch for changes to the described resources.\n-    );\n-    for (V1Service service : v1ServiceList.getItems()) {\n-      if (service.getMetadata().getName().equals(serviceName.trim())\n-          && service.getMetadata().getNamespace().equals(namespace.trim())) {\n-        logger.info(\"Service Name : \" + service.getMetadata().getName());\n-        logger.info(\"Service Namespace : \" + service.getMetadata().getNamespace());\n-        Map<String, String> labels = service.getMetadata().getLabels();\n-        if (labels != null) {\n-          for (Map.Entry<String, String> entry : labels.entrySet()) {\n-            logger.log(Level.INFO, \"Label Key: {0} Label Value: {1}\",\n-                new Object[]{entry.getKey(), entry.getValue()});\n-          }\n-        }\n-        return service;\n-      }\n-    }\n-    return null;\n-  }\n-\n-  /**\n-   * Returns NodePort of a admin server service.\n-   *\n-   * @param serviceName name of admin server service\n-   * @param label key value pair with which the service is decorated with\n-   * @param namespace namespace in which to check for the service\n-   * @return AdminNodePort of the Kubernetes service if exists else -1\n-   * @throws ApiException when there is error in querying the cluster\n+   * @param jobBody V1Job object containing job configuration data\n+   * @return String job name if job creation is successful\n+   * @throws ApiException when create job fails\n    */\n-  public static int getAdminServiceNodePort(\n-      String serviceName,\n-      Map<String, String> label,\n-      String namespace) throws ApiException {\n-\n-    V1Service service = getService(serviceName, label, namespace);\n-    if (service == null) {\n-      logger.info(\"Could not find the service ${0} in namespace ${1}\", serviceName, namespace);\n-      return -1;\n-    }\n-    V1ServiceSpec v1ServiceSpec = service.getSpec();\n-    List<V1ServicePort> portList = v1ServiceSpec.getPorts();\n-    if (portList == null) {\n-      logger.info(\"Got NULL portList for service ${0} in namespace ${1}\", serviceName, namespace);\n-      return -1;\n-    }\n-\n-    for (int i = 0; i < portList.size(); i++) {\n-      if (portList.get(i).getName().equals(\"default\")) {\n-        logger.info(portList.get(i).toString());\n-        return portList.get(i).getNodePort().intValue();\n-      }\n+  public static String createNamespacedJob(V1Job jobBody) throws ApiException {\n+    String name = null;\n+    String namespace = jobBody.getMetadata().getNamespace();\n+    try {\n+      BatchV1Api apiInstance = new BatchV1Api(apiClient);\n+      V1Job createdJob = apiInstance.createNamespacedJob(\n+          namespace, // String | namespace in which to create job\n+          jobBody, // V1Job | body of the V1Job containing job data\n+          PRETTY, // String | pretty print output.\n+          null, // String | dry run or permanent change\n+          null // String | field manager who is making the change\n+      );\n+      name = createdJob.getMetadata().getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4734a9394df7a21d875ef71ec02d6d2b1e03f2a5"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyMjQ4Mg==", "bodyText": "null pointer check for job.getMetadata()", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425422482", "createdAt": "2020-05-14T20:51:16Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -394,6 +399,95 @@ public static void listServices(String namespace, String labelSelectors) throws\n     }\n   }\n \n+  /**\n+   * List jobs in the given namespace.\n+   *\n+   * @param namespace in which to list the jobs\n+   * @param labelSelectors labels to narrow the list of jobs\n+   * @return V1JobList list of {@link V1Job} from Kubernetes cluster\n+   * @throws ApiException when list fails\n+   */\n+  public static V1JobList listJobs(String namespace, String labelSelectors)\n+      throws ApiException {\n+    V1JobList list;\n+    try {\n+      BatchV1Api apiInstance = new BatchV1Api(apiClient);\n+      list = apiInstance.listNamespacedJob(\n+          namespace, // String | name of the namespace.\n+          null, // String | pretty print output.\n+          null, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelectors, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          \"\", // String | Shows changes that occur after that particular version of a resource.\n+          5, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return list;\n+  }\n+\n+  /**\n+   * Returns the V1Job object given the following parameters.\n+   * @param namespace in which to check for the job existence\n+   * @param labelSelectors the labels the job is decorated with, if any\n+   * @param jobName name of the job to return\n+   * @return V1Job object if found otherwise null\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static V1Job getJob(String namespace, String labelSelectors, String jobName)\n+      throws ApiException {\n+    List<V1Job> jobs = listJobs(namespace, labelSelectors).getItems();\n+    for (V1Job job : jobs) {\n+      if (job.getMetadata().getName().equals(jobName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4734a9394df7a21d875ef71ec02d6d2b1e03f2a5"}, "originalPosition": 69}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0e1e310256860974c8eeb545b92b2ec674ac1e5", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b0e1e310256860974c8eeb545b92b2ec674ac1e5", "committedDate": "2020-05-14T21:29:25Z", "message": "Addressed Xian's review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0d82d4f551a98ac63296fafcc409fd6b361bb36", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c0d82d4f551a98ac63296fafcc409fd6b361bb36", "committedDate": "2020-05-14T21:31:24Z", "message": "order the imports"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyMTgyMTc0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#pullrequestreview-412182174", "createdAt": "2020-05-14T21:02:46Z", "commit": {"oid": "4734a9394df7a21d875ef71ec02d6d2b1e03f2a5"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQyMTowMjo0N1rOGVuGyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQyMToyODo0NFrOGVu4-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyODY4Mw==", "bodyText": "This test class will be used to add domains created using WDT as well.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425428683", "createdAt": "2020-05-14T21:02:47Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,708 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQwMDYxNw=="}, "originalCommit": {"oid": "dcab03b6bb9b9b931bf7dc9b86f7c499983dceb2"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyOTQ5Mg==", "bodyText": "Fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425429492", "createdAt": "2020-05-14T21:04:30Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,708 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String dockerConfigJson = \"\";\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(2)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQwMjMyNQ=="}, "originalCommit": {"oid": "dcab03b6bb9b9b931bf7dc9b86f7c499983dceb2"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQzMDAyMA==", "bodyText": "Fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425430020", "createdAt": "2020-05-14T21:05:31Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,706 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(2)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> TestActions.getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQwNjE3Mg=="}, "originalCommit": {"oid": "4734a9394df7a21d875ef71ec02d6d2b1e03f2a5"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQzMDk3MA==", "bodyText": "Good catch, fixed.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425430970", "createdAt": "2020-05-14T21:07:17Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,706 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(2)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> TestActions.getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Accessing admin server node port failed\");\n+    String consoleUrl = new StringBuffer()\n+        .append(\"http://\")\n+        .append(K8S_NODEPORT_HOST)\n+        .append(\":\")\n+        .append(serviceNodePort)\n+        .append(\"/console/login/LoginForm.jsp\").toString();\n+\n+    assertDoesNotThrow(() -> loginTest(consoleUrl, adminUser, adminPassword), \"Console login failed\");\n+  }\n+\n+  /**\n+   * Creates a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void createDomainOnPV() throws IOException {\n+\n+    logger.info(\"create a staging location for domain creation scripts\");\n+    Path pvTemp = Paths.get(RESULTS_ROOT, \"ItDomainOnPV\", \"domainCreateTempPV\");\n+    FileUtils.deleteDirectory(pvTemp.toFile());\n+    Files.createDirectories(pvTemp);\n+\n+    logger.info(\"copy the create domain WLST script to staging location\");\n+    Path srcWlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = Paths.get(pvTemp.toString(), \"create-domain.py\");\n+    Files.copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"create WebLogic domain properties file\");\n+    Path domainPropertiesFile = Paths.get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(\n+        () -> createDomainProperties(domainPropertiesFile), \"Creating domain properties file failed\");\n+\n+    logger.info(\"add files to a config map for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Create a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles),\n+        \"Creating configmap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", \"system\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQwODk3MQ=="}, "originalCommit": {"oid": "4734a9394df7a21d875ef71ec02d6d2b1e03f2a5"}, "originalPosition": 349}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQzMTAzNw==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425431037", "createdAt": "2020-05-14T21:07:25Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,706 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(2)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> TestActions.getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Accessing admin server node port failed\");\n+    String consoleUrl = new StringBuffer()\n+        .append(\"http://\")\n+        .append(K8S_NODEPORT_HOST)\n+        .append(\":\")\n+        .append(serviceNodePort)\n+        .append(\"/console/login/LoginForm.jsp\").toString();\n+\n+    assertDoesNotThrow(() -> loginTest(consoleUrl, adminUser, adminPassword), \"Console login failed\");\n+  }\n+\n+  /**\n+   * Creates a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void createDomainOnPV() throws IOException {\n+\n+    logger.info(\"create a staging location for domain creation scripts\");\n+    Path pvTemp = Paths.get(RESULTS_ROOT, \"ItDomainOnPV\", \"domainCreateTempPV\");\n+    FileUtils.deleteDirectory(pvTemp.toFile());\n+    Files.createDirectories(pvTemp);\n+\n+    logger.info(\"copy the create domain WLST script to staging location\");\n+    Path srcWlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = Paths.get(pvTemp.toString(), \"create-domain.py\");\n+    Files.copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"create WebLogic domain properties file\");\n+    Path domainPropertiesFile = Paths.get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(\n+        () -> createDomainProperties(domainPropertiesFile), \"Creating domain properties file failed\");\n+\n+    logger.info(\"add files to a config map for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Create a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles),\n+        \"Creating configmap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", \"system\");\n+    p.setProperty(\"admin_password\", \"gumby1234\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQwOTI1Mg=="}, "originalCommit": {"oid": "4734a9394df7a21d875ef71ec02d6d2b1e03f2a5"}, "originalPosition": 350}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQzNjI2Ng==", "bodyText": "The 32001 port is passed to domain creation scripts and used internally.\nThe\naddChannelsItem(new Channel()\n.channelName(\"T3Channel\")\n.nodePort(0))\nsimply exposes that 32001 with available port in the node", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425436266", "createdAt": "2020-05-14T21:18:03Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,706 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(2)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> TestActions.getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Accessing admin server node port failed\");\n+    String consoleUrl = new StringBuffer()\n+        .append(\"http://\")\n+        .append(K8S_NODEPORT_HOST)\n+        .append(\":\")\n+        .append(serviceNodePort)\n+        .append(\"/console/login/LoginForm.jsp\").toString();\n+\n+    assertDoesNotThrow(() -> loginTest(consoleUrl, adminUser, adminPassword), \"Console login failed\");\n+  }\n+\n+  /**\n+   * Creates a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void createDomainOnPV() throws IOException {\n+\n+    logger.info(\"create a staging location for domain creation scripts\");\n+    Path pvTemp = Paths.get(RESULTS_ROOT, \"ItDomainOnPV\", \"domainCreateTempPV\");\n+    FileUtils.deleteDirectory(pvTemp.toFile());\n+    Files.createDirectories(pvTemp);\n+\n+    logger.info(\"copy the create domain WLST script to staging location\");\n+    Path srcWlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = Paths.get(pvTemp.toString(), \"create-domain.py\");\n+    Files.copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"create WebLogic domain properties file\");\n+    Path domainPropertiesFile = Paths.get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(\n+        () -> createDomainProperties(domainPropertiesFile), \"Creating domain properties file failed\");\n+\n+    logger.info(\"add files to a config map for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Create a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles),\n+        \"Creating configmap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", \"system\");\n+    p.setProperty(\"admin_password\", \"gumby1234\");\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"32001\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQxMDIyNg=="}, "originalCommit": {"oid": "4734a9394df7a21d875ef71ec02d6d2b1e03f2a5"}, "originalPosition": 352}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQzNjg0Nw==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425436847", "createdAt": "2020-05-14T21:19:21Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,706 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(2)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> TestActions.getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Accessing admin server node port failed\");\n+    String consoleUrl = new StringBuffer()\n+        .append(\"http://\")\n+        .append(K8S_NODEPORT_HOST)\n+        .append(\":\")\n+        .append(serviceNodePort)\n+        .append(\"/console/login/LoginForm.jsp\").toString();\n+\n+    assertDoesNotThrow(() -> loginTest(consoleUrl, adminUser, adminPassword), \"Console login failed\");\n+  }\n+\n+  /**\n+   * Creates a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void createDomainOnPV() throws IOException {\n+\n+    logger.info(\"create a staging location for domain creation scripts\");\n+    Path pvTemp = Paths.get(RESULTS_ROOT, \"ItDomainOnPV\", \"domainCreateTempPV\");\n+    FileUtils.deleteDirectory(pvTemp.toFile());\n+    Files.createDirectories(pvTemp);\n+\n+    logger.info(\"copy the create domain WLST script to staging location\");\n+    Path srcWlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = Paths.get(pvTemp.toString(), \"create-domain.py\");\n+    Files.copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"create WebLogic domain properties file\");\n+    Path domainPropertiesFile = Paths.get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(\n+        () -> createDomainProperties(domainPropertiesFile), \"Creating domain properties file failed\");\n+\n+    logger.info(\"add files to a config map for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Create a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles),\n+        \"Creating configmap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", \"system\");\n+    p.setProperty(\"admin_password\", \"gumby1234\");\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"32001\");\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+\n+    p.store(new FileOutputStream(wlstPropertiesFile.toFile()), \"wlst properties file\");\n+  }\n+\n+  /**\n+   * Create configmap containing domain scripts.\n+   * @param configMapName name of the configmap to create\n+   * @param files files to add in configmap\n+   * @throws IOException when reading the file fails\n+   * @throws ApiException when create configmap fails\n+   */\n+  private void createConfigMapForDomainCreation(String configMapName, List<Path> files)\n+      throws IOException, ApiException {\n+\n+    // add wlst domain creation python script and properties files\n+    // to create domain to the configmap\n+    Map<String, String> data = new HashMap<>();\n+    for (Path file : files) {\n+      data.put(file.getFileName().toString(), Files.readString(file));\n+    }\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> TestActions.createConfigMap(configMap),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQxMTIxMQ=="}, "originalCommit": {"oid": "4734a9394df7a21d875ef71ec02d6d2b1e03f2a5"}, "originalPosition": 384}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQzNzYyMw==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425437623", "createdAt": "2020-05-14T21:20:54Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,706 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(2)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> TestActions.getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Accessing admin server node port failed\");\n+    String consoleUrl = new StringBuffer()\n+        .append(\"http://\")\n+        .append(K8S_NODEPORT_HOST)\n+        .append(\":\")\n+        .append(serviceNodePort)\n+        .append(\"/console/login/LoginForm.jsp\").toString();\n+\n+    assertDoesNotThrow(() -> loginTest(consoleUrl, adminUser, adminPassword), \"Console login failed\");\n+  }\n+\n+  /**\n+   * Creates a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void createDomainOnPV() throws IOException {\n+\n+    logger.info(\"create a staging location for domain creation scripts\");\n+    Path pvTemp = Paths.get(RESULTS_ROOT, \"ItDomainOnPV\", \"domainCreateTempPV\");\n+    FileUtils.deleteDirectory(pvTemp.toFile());\n+    Files.createDirectories(pvTemp);\n+\n+    logger.info(\"copy the create domain WLST script to staging location\");\n+    Path srcWlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = Paths.get(pvTemp.toString(), \"create-domain.py\");\n+    Files.copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"create WebLogic domain properties file\");\n+    Path domainPropertiesFile = Paths.get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(\n+        () -> createDomainProperties(domainPropertiesFile), \"Creating domain properties file failed\");\n+\n+    logger.info(\"add files to a config map for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Create a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles),\n+        \"Creating configmap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", \"system\");\n+    p.setProperty(\"admin_password\", \"gumby1234\");\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"32001\");\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+\n+    p.store(new FileOutputStream(wlstPropertiesFile.toFile()), \"wlst properties file\");\n+  }\n+\n+  /**\n+   * Create configmap containing domain scripts.\n+   * @param configMapName name of the configmap to create\n+   * @param files files to add in configmap\n+   * @throws IOException when reading the file fails\n+   * @throws ApiException when create configmap fails\n+   */\n+  private void createConfigMapForDomainCreation(String configMapName, List<Path> files)\n+      throws IOException, ApiException {\n+\n+    // add wlst domain creation python script and properties files\n+    // to create domain to the configmap\n+    Map<String, String> data = new HashMap<>();\n+    for (Path file : files) {\n+      data.put(file.getFileName().toString(), Files.readString(file));\n+    }\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> TestActions.createConfigMap(configMap),\n+        String.format(\"Failed to create configmap %s with files %s\", configMapName, files));\n+    assertTrue(cmCreated, String.format(\"Failed while creating ConfigMap %s\", configMapName));\n+  }\n+\n+  /**\n+   * Create job to create a domain on a persistent volume.\n+   */\n+  private void runCreateDomainJob(String pvName, String pvcName, String domainScriptCM, String namespace) {\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job\") // name of the create domain job\n+                .namespace(namespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\")  // change the ownership of the pv to opc:opc\n+                        .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(new V1Container()\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+                        .imagePullPolicy(\"IfNotPresent\")\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))) // mounted under /shared inside pod\n+                        .addCommandItem(\"/bin/sh\") //call wlst.sh script with py and properties file\n+                        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+                        .addArgsItem(\"/u01/weblogic/create-domain.py\")\n+                        .addArgsItem(\"-skipWLSModuleScanning\")\n+                        .addArgsItem(\"-loadProperties\")\n+                        .addArgsItem(\"/u01/weblogic/domain.properties\")))\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptCM))))  //config map containing domain scripts\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))))));\n+    String jobName = assertDoesNotThrow(() -> TestActions\n+        .createNamespacedJob(jobBody), \"Domain creation job failed\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQxMjgwNw=="}, "originalCommit": {"oid": "4734a9394df7a21d875ef71ec02d6d2b1e03f2a5"}, "originalPosition": 450}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQzNzc2MA==", "bodyText": "done", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425437760", "createdAt": "2020-05-14T21:21:12Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,706 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(2)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> TestActions.getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Accessing admin server node port failed\");\n+    String consoleUrl = new StringBuffer()\n+        .append(\"http://\")\n+        .append(K8S_NODEPORT_HOST)\n+        .append(\":\")\n+        .append(serviceNodePort)\n+        .append(\"/console/login/LoginForm.jsp\").toString();\n+\n+    assertDoesNotThrow(() -> loginTest(consoleUrl, adminUser, adminPassword), \"Console login failed\");\n+  }\n+\n+  /**\n+   * Creates a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void createDomainOnPV() throws IOException {\n+\n+    logger.info(\"create a staging location for domain creation scripts\");\n+    Path pvTemp = Paths.get(RESULTS_ROOT, \"ItDomainOnPV\", \"domainCreateTempPV\");\n+    FileUtils.deleteDirectory(pvTemp.toFile());\n+    Files.createDirectories(pvTemp);\n+\n+    logger.info(\"copy the create domain WLST script to staging location\");\n+    Path srcWlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = Paths.get(pvTemp.toString(), \"create-domain.py\");\n+    Files.copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"create WebLogic domain properties file\");\n+    Path domainPropertiesFile = Paths.get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(\n+        () -> createDomainProperties(domainPropertiesFile), \"Creating domain properties file failed\");\n+\n+    logger.info(\"add files to a config map for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Create a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles),\n+        \"Creating configmap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", \"system\");\n+    p.setProperty(\"admin_password\", \"gumby1234\");\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"32001\");\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+\n+    p.store(new FileOutputStream(wlstPropertiesFile.toFile()), \"wlst properties file\");\n+  }\n+\n+  /**\n+   * Create configmap containing domain scripts.\n+   * @param configMapName name of the configmap to create\n+   * @param files files to add in configmap\n+   * @throws IOException when reading the file fails\n+   * @throws ApiException when create configmap fails\n+   */\n+  private void createConfigMapForDomainCreation(String configMapName, List<Path> files)\n+      throws IOException, ApiException {\n+\n+    // add wlst domain creation python script and properties files\n+    // to create domain to the configmap\n+    Map<String, String> data = new HashMap<>();\n+    for (Path file : files) {\n+      data.put(file.getFileName().toString(), Files.readString(file));\n+    }\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> TestActions.createConfigMap(configMap),\n+        String.format(\"Failed to create configmap %s with files %s\", configMapName, files));\n+    assertTrue(cmCreated, String.format(\"Failed while creating ConfigMap %s\", configMapName));\n+  }\n+\n+  /**\n+   * Create job to create a domain on a persistent volume.\n+   */\n+  private void runCreateDomainJob(String pvName, String pvcName, String domainScriptCM, String namespace) {\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job\") // name of the create domain job\n+                .namespace(namespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\")  // change the ownership of the pv to opc:opc\n+                        .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(new V1Container()\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+                        .imagePullPolicy(\"IfNotPresent\")\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))) // mounted under /shared inside pod\n+                        .addCommandItem(\"/bin/sh\") //call wlst.sh script with py and properties file\n+                        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+                        .addArgsItem(\"/u01/weblogic/create-domain.py\")\n+                        .addArgsItem(\"-skipWLSModuleScanning\")\n+                        .addArgsItem(\"-loadProperties\")\n+                        .addArgsItem(\"/u01/weblogic/domain.properties\")))\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptCM))))  //config map containing domain scripts\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))))));\n+    String jobName = assertDoesNotThrow(() -> TestActions\n+        .createNamespacedJob(jobBody), \"Domain creation job failed\");\n+\n+    logger.info(\"Checking if the domain creation job {0} completed in namespace {1}\",\n+        jobName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for job {0} to be completed in namespace {1} \"\n+                + \"(elapsed time {2} ms, remaining time {3} ms)\",\n+                jobName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(jobCompleted(jobName, null, namespace));\n+  }\n+\n+  /**\n+   * Create secret for docker credentials.\n+   */\n+  private void createOCRRepoSecret() {\n+\n+    // docker login, if necessary\n+    logger.info(\"docker login to OCR registry\");\n+    assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"login to OCR failed\");\n+\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQxMzE0Mg=="}, "originalCommit": {"oid": "4734a9394df7a21d875ef71ec02d6d2b1e03f2a5"}, "originalPosition": 474}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQzODM3Ng==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425438376", "createdAt": "2020-05-14T21:22:21Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,706 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(2)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> TestActions.getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Accessing admin server node port failed\");\n+    String consoleUrl = new StringBuffer()\n+        .append(\"http://\")\n+        .append(K8S_NODEPORT_HOST)\n+        .append(\":\")\n+        .append(serviceNodePort)\n+        .append(\"/console/login/LoginForm.jsp\").toString();\n+\n+    assertDoesNotThrow(() -> loginTest(consoleUrl, adminUser, adminPassword), \"Console login failed\");\n+  }\n+\n+  /**\n+   * Creates a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void createDomainOnPV() throws IOException {\n+\n+    logger.info(\"create a staging location for domain creation scripts\");\n+    Path pvTemp = Paths.get(RESULTS_ROOT, \"ItDomainOnPV\", \"domainCreateTempPV\");\n+    FileUtils.deleteDirectory(pvTemp.toFile());\n+    Files.createDirectories(pvTemp);\n+\n+    logger.info(\"copy the create domain WLST script to staging location\");\n+    Path srcWlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = Paths.get(pvTemp.toString(), \"create-domain.py\");\n+    Files.copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"create WebLogic domain properties file\");\n+    Path domainPropertiesFile = Paths.get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(\n+        () -> createDomainProperties(domainPropertiesFile), \"Creating domain properties file failed\");\n+\n+    logger.info(\"add files to a config map for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Create a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles),\n+        \"Creating configmap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", \"system\");\n+    p.setProperty(\"admin_password\", \"gumby1234\");\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"32001\");\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+\n+    p.store(new FileOutputStream(wlstPropertiesFile.toFile()), \"wlst properties file\");\n+  }\n+\n+  /**\n+   * Create configmap containing domain scripts.\n+   * @param configMapName name of the configmap to create\n+   * @param files files to add in configmap\n+   * @throws IOException when reading the file fails\n+   * @throws ApiException when create configmap fails\n+   */\n+  private void createConfigMapForDomainCreation(String configMapName, List<Path> files)\n+      throws IOException, ApiException {\n+\n+    // add wlst domain creation python script and properties files\n+    // to create domain to the configmap\n+    Map<String, String> data = new HashMap<>();\n+    for (Path file : files) {\n+      data.put(file.getFileName().toString(), Files.readString(file));\n+    }\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> TestActions.createConfigMap(configMap),\n+        String.format(\"Failed to create configmap %s with files %s\", configMapName, files));\n+    assertTrue(cmCreated, String.format(\"Failed while creating ConfigMap %s\", configMapName));\n+  }\n+\n+  /**\n+   * Create job to create a domain on a persistent volume.\n+   */\n+  private void runCreateDomainJob(String pvName, String pvcName, String domainScriptCM, String namespace) {\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job\") // name of the create domain job\n+                .namespace(namespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\")  // change the ownership of the pv to opc:opc\n+                        .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(new V1Container()\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+                        .imagePullPolicy(\"IfNotPresent\")\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))) // mounted under /shared inside pod\n+                        .addCommandItem(\"/bin/sh\") //call wlst.sh script with py and properties file\n+                        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+                        .addArgsItem(\"/u01/weblogic/create-domain.py\")\n+                        .addArgsItem(\"-skipWLSModuleScanning\")\n+                        .addArgsItem(\"-loadProperties\")\n+                        .addArgsItem(\"/u01/weblogic/domain.properties\")))\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptCM))))  //config map containing domain scripts\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))))));\n+    String jobName = assertDoesNotThrow(() -> TestActions\n+        .createNamespacedJob(jobBody), \"Domain creation job failed\");\n+\n+    logger.info(\"Checking if the domain creation job {0} completed in namespace {1}\",\n+        jobName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for job {0} to be completed in namespace {1} \"\n+                + \"(elapsed time {2} ms, remaining time {3} ms)\",\n+                jobName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(jobCompleted(jobName, null, namespace));\n+  }\n+\n+  /**\n+   * Create secret for docker credentials.\n+   */\n+  private void createOCRRepoSecret() {\n+\n+    // docker login, if necessary\n+    logger.info(\"docker login to OCR registry\");\n+    assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"login to OCR failed\");\n+\n+\n+    logger.info(\"Creating repository registry secret in namespace {0}\", domainNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        OCR_USERNAME, OCR_PASSWORD, OCR_EMAIL, OCR_REGISTRY);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(OCR_SECRET_NAME)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", OCR_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", OCR_SECRET_NAME));\n+  }\n+\n+  /**\n+   * Create secret for WebLogic credentials.\n+   */\n+  private void createWebLogicCredentialsSecret() {\n+    logger.info(\"Creating secret for WebLogic credentials\");\n+    wlSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap<>();\n+    adminSecretMap.put(\"username\", adminUser);\n+    adminSecretMap.put(\"password\", adminPassword);\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(wlSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", wlSecretName));\n+  }\n+\n+  /**\n+   * Create a persistent volume and persistent volume claim.\n+   * @throws IOException when creating pv path fails\n+   */\n+  private void createPVandPVC() throws IOException {\n+    logger.info(\"creating persistent volume and persistent volume claim\");\n+\n+    Path pvHostPath = Files.createDirectories(Paths.get(\n+        TestConstants.PV_ROOT, this.getClass().getSimpleName(), domainUid + \"-persistentVolume\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQxNDE4NA=="}, "originalCommit": {"oid": "4734a9394df7a21d875ef71ec02d6d2b1e03f2a5"}, "originalPosition": 518}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQzODQ5NA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425438494", "createdAt": "2020-05-14T21:22:34Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,706 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(2)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> TestActions.getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Accessing admin server node port failed\");\n+    String consoleUrl = new StringBuffer()\n+        .append(\"http://\")\n+        .append(K8S_NODEPORT_HOST)\n+        .append(\":\")\n+        .append(serviceNodePort)\n+        .append(\"/console/login/LoginForm.jsp\").toString();\n+\n+    assertDoesNotThrow(() -> loginTest(consoleUrl, adminUser, adminPassword), \"Console login failed\");\n+  }\n+\n+  /**\n+   * Creates a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void createDomainOnPV() throws IOException {\n+\n+    logger.info(\"create a staging location for domain creation scripts\");\n+    Path pvTemp = Paths.get(RESULTS_ROOT, \"ItDomainOnPV\", \"domainCreateTempPV\");\n+    FileUtils.deleteDirectory(pvTemp.toFile());\n+    Files.createDirectories(pvTemp);\n+\n+    logger.info(\"copy the create domain WLST script to staging location\");\n+    Path srcWlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = Paths.get(pvTemp.toString(), \"create-domain.py\");\n+    Files.copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"create WebLogic domain properties file\");\n+    Path domainPropertiesFile = Paths.get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(\n+        () -> createDomainProperties(domainPropertiesFile), \"Creating domain properties file failed\");\n+\n+    logger.info(\"add files to a config map for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Create a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles),\n+        \"Creating configmap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", \"system\");\n+    p.setProperty(\"admin_password\", \"gumby1234\");\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"32001\");\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+\n+    p.store(new FileOutputStream(wlstPropertiesFile.toFile()), \"wlst properties file\");\n+  }\n+\n+  /**\n+   * Create configmap containing domain scripts.\n+   * @param configMapName name of the configmap to create\n+   * @param files files to add in configmap\n+   * @throws IOException when reading the file fails\n+   * @throws ApiException when create configmap fails\n+   */\n+  private void createConfigMapForDomainCreation(String configMapName, List<Path> files)\n+      throws IOException, ApiException {\n+\n+    // add wlst domain creation python script and properties files\n+    // to create domain to the configmap\n+    Map<String, String> data = new HashMap<>();\n+    for (Path file : files) {\n+      data.put(file.getFileName().toString(), Files.readString(file));\n+    }\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> TestActions.createConfigMap(configMap),\n+        String.format(\"Failed to create configmap %s with files %s\", configMapName, files));\n+    assertTrue(cmCreated, String.format(\"Failed while creating ConfigMap %s\", configMapName));\n+  }\n+\n+  /**\n+   * Create job to create a domain on a persistent volume.\n+   */\n+  private void runCreateDomainJob(String pvName, String pvcName, String domainScriptCM, String namespace) {\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job\") // name of the create domain job\n+                .namespace(namespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\")  // change the ownership of the pv to opc:opc\n+                        .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(new V1Container()\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+                        .imagePullPolicy(\"IfNotPresent\")\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))) // mounted under /shared inside pod\n+                        .addCommandItem(\"/bin/sh\") //call wlst.sh script with py and properties file\n+                        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+                        .addArgsItem(\"/u01/weblogic/create-domain.py\")\n+                        .addArgsItem(\"-skipWLSModuleScanning\")\n+                        .addArgsItem(\"-loadProperties\")\n+                        .addArgsItem(\"/u01/weblogic/domain.properties\")))\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptCM))))  //config map containing domain scripts\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))))));\n+    String jobName = assertDoesNotThrow(() -> TestActions\n+        .createNamespacedJob(jobBody), \"Domain creation job failed\");\n+\n+    logger.info(\"Checking if the domain creation job {0} completed in namespace {1}\",\n+        jobName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for job {0} to be completed in namespace {1} \"\n+                + \"(elapsed time {2} ms, remaining time {3} ms)\",\n+                jobName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(jobCompleted(jobName, null, namespace));\n+  }\n+\n+  /**\n+   * Create secret for docker credentials.\n+   */\n+  private void createOCRRepoSecret() {\n+\n+    // docker login, if necessary\n+    logger.info(\"docker login to OCR registry\");\n+    assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"login to OCR failed\");\n+\n+\n+    logger.info(\"Creating repository registry secret in namespace {0}\", domainNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        OCR_USERNAME, OCR_PASSWORD, OCR_EMAIL, OCR_REGISTRY);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(OCR_SECRET_NAME)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", OCR_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", OCR_SECRET_NAME));\n+  }\n+\n+  /**\n+   * Create secret for WebLogic credentials.\n+   */\n+  private void createWebLogicCredentialsSecret() {\n+    logger.info(\"Creating secret for WebLogic credentials\");\n+    wlSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap<>();\n+    adminSecretMap.put(\"username\", adminUser);\n+    adminSecretMap.put(\"password\", adminPassword);\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(wlSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", wlSecretName));\n+  }\n+\n+  /**\n+   * Create a persistent volume and persistent volume claim.\n+   * @throws IOException when creating pv path fails\n+   */\n+  private void createPVandPVC() throws IOException {\n+    logger.info(\"creating persistent volume and persistent volume claim\");\n+\n+    Path pvHostPath = Files.createDirectories(Paths.get(\n+        TestConstants.PV_ROOT, this.getClass().getSimpleName(), domainUid + \"-persistentVolume\"));\n+    logger.info(\"Creating PV directory {0}\", pvHostPath);\n+    FileUtils.deleteDirectory(pvHostPath.toFile());\n+    Files.createDirectories(pvHostPath);\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Recycle\")\n+            .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(pvHostPath.toString())))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvName)\n+            .withNamespace(domainNamespace)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+    boolean success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolume(v1pv),\n+        \"Persistent volume creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolume creation failed\");\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeName(pvName)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvcName)\n+            .withNamespace(domainNamespace)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+    success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolumeClaim(v1pvc),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQxNDk5MA=="}, "originalCommit": {"oid": "4734a9394df7a21d875ef71ec02d6d2b1e03f2a5"}, "originalPosition": 560}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ0MDg3Ng==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425440876", "createdAt": "2020-05-14T21:27:19Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1491,92 +1528,32 @@ public static V1ServiceList listServices(String namespace) {\n   }\n \n   /**\n-   * Get V1Service object for the given service name, label and namespace.\n+   * Create a job.\n    *\n-   * @param serviceName name of the service to look for\n-   * @param label key value pair with which the service is decorated with\n-   * @param namespace namespace in which to check for the service\n-   * @return V1Service object if found otherwise null\n-   * @throws ApiException when there is an error in querying the cluster\n-   */\n-  public static V1Service getService(\n-      String serviceName, Map<String, String> label, String namespace)\n-      throws ApiException {\n-    String labelSelector = null;\n-    if (label != null) {\n-      String key = label.keySet().iterator().next().toString();\n-      String value = label.get(key).toString();\n-      labelSelector = String.format(\"%s in (%s)\", key, value);\n-      logger.info(labelSelector);\n-    }\n-    V1ServiceList v1ServiceList\n-        = coreV1Api.listServiceForAllNamespaces(\n-        Boolean.FALSE, // allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n-        null, // continue to query when there is more results to return.\n-        null, // selector to restrict the list of returned objects by their fields\n-        labelSelector, // selector to restrict the list of returned objects by their labels.\n-        null, // maximum number of responses to return for a list call.\n-        Boolean.FALSE.toString(), // pretty print output.\n-        null, // shows changes that occur after that particular version of a resource.\n-        null, // Timeout for the list/watch call.\n-        Boolean.FALSE // Watch for changes to the described resources.\n-    );\n-    for (V1Service service : v1ServiceList.getItems()) {\n-      if (service.getMetadata().getName().equals(serviceName.trim())\n-          && service.getMetadata().getNamespace().equals(namespace.trim())) {\n-        logger.info(\"Service Name : \" + service.getMetadata().getName());\n-        logger.info(\"Service Namespace : \" + service.getMetadata().getNamespace());\n-        Map<String, String> labels = service.getMetadata().getLabels();\n-        if (labels != null) {\n-          for (Map.Entry<String, String> entry : labels.entrySet()) {\n-            logger.log(Level.INFO, \"Label Key: {0} Label Value: {1}\",\n-                new Object[]{entry.getKey(), entry.getValue()});\n-          }\n-        }\n-        return service;\n-      }\n-    }\n-    return null;\n-  }\n-\n-  /**\n-   * Returns NodePort of a admin server service.\n-   *\n-   * @param serviceName name of admin server service\n-   * @param label key value pair with which the service is decorated with\n-   * @param namespace namespace in which to check for the service\n-   * @return AdminNodePort of the Kubernetes service if exists else -1\n-   * @throws ApiException when there is error in querying the cluster\n+   * @param jobBody V1Job object containing job configuration data\n+   * @return String job name if job creation is successful\n+   * @throws ApiException when create job fails\n    */\n-  public static int getAdminServiceNodePort(\n-      String serviceName,\n-      Map<String, String> label,\n-      String namespace) throws ApiException {\n-\n-    V1Service service = getService(serviceName, label, namespace);\n-    if (service == null) {\n-      logger.info(\"Could not find the service ${0} in namespace ${1}\", serviceName, namespace);\n-      return -1;\n-    }\n-    V1ServiceSpec v1ServiceSpec = service.getSpec();\n-    List<V1ServicePort> portList = v1ServiceSpec.getPorts();\n-    if (portList == null) {\n-      logger.info(\"Got NULL portList for service ${0} in namespace ${1}\", serviceName, namespace);\n-      return -1;\n-    }\n-\n-    for (int i = 0; i < portList.size(); i++) {\n-      if (portList.get(i).getName().equals(\"default\")) {\n-        logger.info(portList.get(i).toString());\n-        return portList.get(i).getNodePort().intValue();\n-      }\n+  public static String createNamespacedJob(V1Job jobBody) throws ApiException {\n+    String name = null;\n+    String namespace = jobBody.getMetadata().getNamespace();\n+    try {\n+      BatchV1Api apiInstance = new BatchV1Api(apiClient);\n+      V1Job createdJob = apiInstance.createNamespacedJob(\n+          namespace, // String | namespace in which to create job\n+          jobBody, // V1Job | body of the V1Job containing job data\n+          PRETTY, // String | pretty print output.\n+          null, // String | dry run or permanent change\n+          null // String | field manager who is making the change\n+      );\n+      name = createdJob.getMetadata().getName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyMTUyOQ=="}, "originalCommit": {"oid": "4734a9394df7a21d875ef71ec02d6d2b1e03f2a5"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ0MTUzMQ==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425441531", "createdAt": "2020-05-14T21:28:44Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -394,6 +399,95 @@ public static void listServices(String namespace, String labelSelectors) throws\n     }\n   }\n \n+  /**\n+   * List jobs in the given namespace.\n+   *\n+   * @param namespace in which to list the jobs\n+   * @param labelSelectors labels to narrow the list of jobs\n+   * @return V1JobList list of {@link V1Job} from Kubernetes cluster\n+   * @throws ApiException when list fails\n+   */\n+  public static V1JobList listJobs(String namespace, String labelSelectors)\n+      throws ApiException {\n+    V1JobList list;\n+    try {\n+      BatchV1Api apiInstance = new BatchV1Api(apiClient);\n+      list = apiInstance.listNamespacedJob(\n+          namespace, // String | name of the namespace.\n+          null, // String | pretty print output.\n+          null, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelectors, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          \"\", // String | Shows changes that occur after that particular version of a resource.\n+          5, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return list;\n+  }\n+\n+  /**\n+   * Returns the V1Job object given the following parameters.\n+   * @param namespace in which to check for the job existence\n+   * @param labelSelectors the labels the job is decorated with, if any\n+   * @param jobName name of the job to return\n+   * @return V1Job object if found otherwise null\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static V1Job getJob(String namespace, String labelSelectors, String jobName)\n+      throws ApiException {\n+    List<V1Job> jobs = listJobs(namespace, labelSelectors).getItems();\n+    for (V1Job job : jobs) {\n+      if (job.getMetadata().getName().equals(jobName)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyMjQ4Mg=="}, "originalCommit": {"oid": "4734a9394df7a21d875ef71ec02d6d2b1e03f2a5"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyMjIxMjkx", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#pullrequestreview-412221291", "createdAt": "2020-05-14T22:11:21Z", "commit": {"oid": "c0d82d4f551a98ac63296fafcc409fd6b361bb36"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyMzEwNDg1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#pullrequestreview-412310485", "createdAt": "2020-05-15T02:42:26Z", "commit": {"oid": "c0d82d4f551a98ac63296fafcc409fd6b361bb36"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMjo0MjoyNlrOGV0mXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMzowMjowOVrOGV05Sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUzNTA3MQ==", "bodyText": "is docker login needed here? you just need to create the secret..", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425535071", "createdAt": "2020-05-15T02:42:26Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,710 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Accessing admin server node port failed\");\n+    String consoleUrl = new StringBuffer()\n+        .append(\"http://\")\n+        .append(K8S_NODEPORT_HOST)\n+        .append(\":\")\n+        .append(serviceNodePort)\n+        .append(\"/console/login/LoginForm.jsp\").toString();\n+\n+    assertDoesNotThrow(() -> loginTest(consoleUrl, adminUser, adminPassword), \"Console login failed\");\n+  }\n+\n+  /**\n+   * Creates a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void createDomainOnPV() throws IOException {\n+\n+    logger.info(\"create a staging location for domain creation scripts\");\n+    Path pvTemp = Paths.get(RESULTS_ROOT, \"ItDomainOnPV\", \"domainCreateTempPV\");\n+    FileUtils.deleteDirectory(pvTemp.toFile());\n+    Files.createDirectories(pvTemp);\n+\n+    logger.info(\"copy the create domain WLST script to staging location\");\n+    Path srcWlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = Paths.get(pvTemp.toString(), \"create-domain.py\");\n+    Files.copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"create WebLogic domain properties file\");\n+    Path domainPropertiesFile = Paths.get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(\n+        () -> createDomainProperties(domainPropertiesFile), \"Creating domain properties file failed\");\n+\n+    logger.info(\"add files to a config map for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Create a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles),\n+        \"Creating configmap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", adminUser);\n+    p.setProperty(\"admin_password\", adminPassword);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"32001\");\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+\n+    p.store(new FileOutputStream(wlstPropertiesFile.toFile()), \"wlst properties file\");\n+  }\n+\n+  /**\n+   * Create configmap containing domain scripts.\n+   * @param configMapName name of the configmap to create\n+   * @param files files to add in configmap\n+   * @throws IOException when reading the file fails\n+   * @throws ApiException when create configmap fails\n+   */\n+  private void createConfigMapForDomainCreation(String configMapName, List<Path> files)\n+      throws IOException, ApiException {\n+\n+    // add wlst domain creation python script and properties files\n+    // to create domain to the configmap\n+    Map<String, String> data = new HashMap<>();\n+    for (Path file : files) {\n+      data.put(file.getFileName().toString(), Files.readString(file));\n+    }\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Failed to create configmap %s with files %s\", configMapName, files));\n+    assertTrue(cmCreated, String.format(\"Failed while creating ConfigMap %s\", configMapName));\n+  }\n+\n+  /**\n+   * Create job to create a domain on a persistent volume.\n+   */\n+  private void runCreateDomainJob(String pvName, String pvcName, String domainScriptCM, String namespace) {\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job\") // name of the create domain job\n+                .namespace(namespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\")  // change the ownership of the pv to opc:opc\n+                        .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(new V1Container()\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+                        .imagePullPolicy(\"IfNotPresent\")\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))) // mounted under /shared inside pod\n+                        .addCommandItem(\"/bin/sh\") //call wlst.sh script with py and properties file\n+                        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+                        .addArgsItem(\"/u01/weblogic/create-domain.py\")\n+                        .addArgsItem(\"-skipWLSModuleScanning\")\n+                        .addArgsItem(\"-loadProperties\")\n+                        .addArgsItem(\"/u01/weblogic/domain.properties\")))\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptCM))))  //config map containing domain scripts\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))))));\n+    String jobName = assertDoesNotThrow(() ->\n+        createNamespacedJob(jobBody), \"Domain creation job failed\");\n+\n+    logger.info(\"Checking if the domain creation job {0} completed in namespace {1}\",\n+        jobName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for job {0} to be completed in namespace {1} \"\n+                + \"(elapsed time {2} ms, remaining time {3} ms)\",\n+                jobName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(jobCompleted(jobName, null, namespace));\n+  }\n+\n+  /**\n+   * Create secret for docker credentials.\n+   */\n+  private void createOCRRepoSecret() {\n+\n+    // docker login, if necessary\n+    logger.info(\"docker login to OCR registry\");\n+    assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"login to OCR failed\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d82d4f551a98ac63296fafcc409fd6b361bb36"}, "originalPosition": 477}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUzOTkxNQ==", "bodyText": "missing job", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425539915", "createdAt": "2020-05-15T03:02:09Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Job.java", "diffHunk": "@@ -0,0 +1,24 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.concurrent.Callable;\n+\n+public class Job {\n+\n+  /**\n+   * Check a given is in ready status.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d82d4f551a98ac63296fafcc409fd6b361bb36"}, "originalPosition": 11}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyNjA2OTE0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#pullrequestreview-412606914", "createdAt": "2020-05-15T12:34:37Z", "commit": {"oid": "c0d82d4f551a98ac63296fafcc409fd6b361bb36"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMjozNDozN1rOGWC9OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMjo0MjoxMFrOGWDNAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc3MDI5Ng==", "bodyText": "I thought about this and my PR#1650. You can move this check into the assertion adminNodePortAccessible(int nodePort, String adminUser, String adminPassword), then I can close my PR. Let me know if you think otherwise.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425770296", "createdAt": "2020-05-15T12:34:37Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,710 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Accessing admin server node port failed\");\n+    String consoleUrl = new StringBuffer()\n+        .append(\"http://\")\n+        .append(K8S_NODEPORT_HOST)\n+        .append(\":\")\n+        .append(serviceNodePort)\n+        .append(\"/console/login/LoginForm.jsp\").toString();\n+\n+    assertDoesNotThrow(() -> loginTest(consoleUrl, adminUser, adminPassword), \"Console login failed\");\n+  }\n+\n+  /**\n+   * Creates a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void createDomainOnPV() throws IOException {\n+\n+    logger.info(\"create a staging location for domain creation scripts\");\n+    Path pvTemp = Paths.get(RESULTS_ROOT, \"ItDomainOnPV\", \"domainCreateTempPV\");\n+    FileUtils.deleteDirectory(pvTemp.toFile());\n+    Files.createDirectories(pvTemp);\n+\n+    logger.info(\"copy the create domain WLST script to staging location\");\n+    Path srcWlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = Paths.get(pvTemp.toString(), \"create-domain.py\");\n+    Files.copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"create WebLogic domain properties file\");\n+    Path domainPropertiesFile = Paths.get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(\n+        () -> createDomainProperties(domainPropertiesFile), \"Creating domain properties file failed\");\n+\n+    logger.info(\"add files to a config map for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Create a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles),\n+        \"Creating configmap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", adminUser);\n+    p.setProperty(\"admin_password\", adminPassword);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"32001\");\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+\n+    p.store(new FileOutputStream(wlstPropertiesFile.toFile()), \"wlst properties file\");\n+  }\n+\n+  /**\n+   * Create configmap containing domain scripts.\n+   * @param configMapName name of the configmap to create\n+   * @param files files to add in configmap\n+   * @throws IOException when reading the file fails\n+   * @throws ApiException when create configmap fails\n+   */\n+  private void createConfigMapForDomainCreation(String configMapName, List<Path> files)\n+      throws IOException, ApiException {\n+\n+    // add wlst domain creation python script and properties files\n+    // to create domain to the configmap\n+    Map<String, String> data = new HashMap<>();\n+    for (Path file : files) {\n+      data.put(file.getFileName().toString(), Files.readString(file));\n+    }\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Failed to create configmap %s with files %s\", configMapName, files));\n+    assertTrue(cmCreated, String.format(\"Failed while creating ConfigMap %s\", configMapName));\n+  }\n+\n+  /**\n+   * Create job to create a domain on a persistent volume.\n+   */\n+  private void runCreateDomainJob(String pvName, String pvcName, String domainScriptCM, String namespace) {\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job\") // name of the create domain job\n+                .namespace(namespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\")  // change the ownership of the pv to opc:opc\n+                        .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(new V1Container()\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+                        .imagePullPolicy(\"IfNotPresent\")\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))) // mounted under /shared inside pod\n+                        .addCommandItem(\"/bin/sh\") //call wlst.sh script with py and properties file\n+                        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+                        .addArgsItem(\"/u01/weblogic/create-domain.py\")\n+                        .addArgsItem(\"-skipWLSModuleScanning\")\n+                        .addArgsItem(\"-loadProperties\")\n+                        .addArgsItem(\"/u01/weblogic/domain.properties\")))\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptCM))))  //config map containing domain scripts\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))))));\n+    String jobName = assertDoesNotThrow(() ->\n+        createNamespacedJob(jobBody), \"Domain creation job failed\");\n+\n+    logger.info(\"Checking if the domain creation job {0} completed in namespace {1}\",\n+        jobName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for job {0} to be completed in namespace {1} \"\n+                + \"(elapsed time {2} ms, remaining time {3} ms)\",\n+                jobName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(jobCompleted(jobName, null, namespace));\n+  }\n+\n+  /**\n+   * Create secret for docker credentials.\n+   */\n+  private void createOCRRepoSecret() {\n+\n+    // docker login, if necessary\n+    logger.info(\"docker login to OCR registry\");\n+    assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"login to OCR failed\");\n+\n+    logger.info(\"Creating repository registry secret in namespace {0}\", domainNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        OCR_USERNAME, OCR_PASSWORD, OCR_EMAIL, OCR_REGISTRY);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(OCR_SECRET_NAME)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", OCR_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", OCR_SECRET_NAME));\n+  }\n+\n+  /**\n+   * Create secret for WebLogic credentials.\n+   */\n+  private void createWebLogicCredentialsSecret() {\n+    logger.info(\"Creating secret for WebLogic credentials\");\n+    wlSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap<>();\n+    adminSecretMap.put(\"username\", adminUser);\n+    adminSecretMap.put(\"password\", adminPassword);\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(wlSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", wlSecretName));\n+  }\n+\n+  /**\n+   * Create a persistent volume and persistent volume claim.\n+   * @throws IOException when creating pv path fails\n+   */\n+  private void createPVandPVC() throws IOException {\n+    logger.info(\"creating persistent volume and persistent volume claim\");\n+\n+    Path pvHostPath = Files.createDirectories(Paths.get(\n+        PV_ROOT, this.getClass().getSimpleName(), domainUid + \"-persistentVolume\"));\n+    logger.info(\"Creating PV directory {0}\", pvHostPath);\n+    FileUtils.deleteDirectory(pvHostPath.toFile());\n+    Files.createDirectories(pvHostPath);\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Recycle\")\n+            .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(pvHostPath.toString())))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvName)\n+            .withNamespace(domainNamespace)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+    boolean success = assertDoesNotThrow(\n+        () -> createPersistentVolume(v1pv),\n+        \"Persistent volume creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolume creation failed\");\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeName(pvName)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvcName)\n+            .withNamespace(domainNamespace)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+    success = assertDoesNotThrow(\n+        () -> createPersistentVolumeClaim(v1pvc),\n+        \"Persistent volume claim creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolumeClaim creation failed\");\n+  }\n+\n+\n+  /**\n+   * Install WebLogic operator and wait until the operator pod is ready.\n+   */\n+  private static void installAndVerifyOperator() {\n+\n+    logger.info(\"Creating service account for operator\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(new V1ObjectMeta()\n+            .namespace(opNamespace)\n+            .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"operator image name can not be empty\");\n+    logger.info(\"operator image name {0}\", operatorImage);\n+\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    logger.info(\"Creating the V1Secret configuration\");\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\n+        \"createSecret failed while creating secret %s in namespace %s\",\n+        REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // Helm install parameters\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // operator chart values to override\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams)\n+        .image(operatorImage)\n+        .imagePullSecrets(secretNameMap)\n+        .domainNamespaces(Arrays.asList(domainNamespace))\n+        .serviceAccount(serviceAccountName);\n+\n+    // install operator\n+    logger.info(\"Installing operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Failed to install operator in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list Helm releases matching operator release name in operator namespace\n+    logger.info(\"Checking operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+  }\n+\n+  /**\n+   * Check pod is ready.\n+   *\n+   * @param podName pod name to check\n+   */\n+  private void checkPodReady(String podName) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(podReady(podName, domainUid, domainNamespace));\n+  }\n+\n+  /**\n+   * Check service is created.\n+   *\n+   * @param serviceName service name to check\n+   */\n+  private void checkServiceCreated(String serviceName) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for service {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                serviceName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(serviceExists(serviceName, null, domainNamespace));\n+  }\n+\n+\n+  /**\n+   * Login to the WebLogic console and validate its the Home page.\n+   *\n+   * @param consoleUrl url for the WebLogic console\n+   * @param username WebLogic admin username\n+   * @param password WebLogic admin password\n+   * @throws IOException when connection to console url fails\n+   */\n+  public static void loginTest(String consoleUrl, String username, String password) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d82d4f551a98ac63296fafcc409fd6b361bb36"}, "originalPosition": 696}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc3NDMzOA==", "bodyText": "we need to consider moving these methods into helper classes, it applies for MII methods also before the code is duplicated in multiple It classes as more tests will be added now.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425774338", "createdAt": "2020-05-15T12:42:10Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,710 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d82d4f551a98ac63296fafcc409fd6b361bb36"}, "originalPosition": 182}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93d40f178c0d1bc83c7a1fdaf8bb30d7697aea09", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/93d40f178c0d1bc83c7a1fdaf8bb30d7697aea09", "committedDate": "2020-05-15T16:00:03Z", "message": "Addressed Vanaja's review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d5e6b9941e979f0d44759125782494d67e4e987", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9d5e6b9941e979f0d44759125782494d67e4e987", "committedDate": "2020-05-15T16:53:17Z", "message": "changing image pull policy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62dfd12005633c383756152eec5c38b71795c369", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/62dfd12005633c383756152eec5c38b71795c369", "committedDate": "2020-05-15T17:39:25Z", "message": "removed docker login"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyODYwMzg2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#pullrequestreview-412860386", "createdAt": "2020-05-15T18:05:40Z", "commit": {"oid": "62dfd12005633c383756152eec5c38b71795c369"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxODowNTo0MVrOGWO16Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxODowNTo0MVrOGWO16Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk2NTAzMw==", "bodyText": "modify the description to indicate that this assertion is to check node port is working ...\nVerify admin node port(default/t3channel) is accessible by login to WebLogic console using the node port and validate its the Home page.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r425965033", "createdAt": "2020-05-15T18:05:41Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Domain.java", "diffHunk": "@@ -89,7 +94,36 @@ public static boolean adminT3ChannelAccessible(String domainUid, String namespac\n     return true;\n   }\n \n-  public static boolean adminNodePortAccessible(String domainUid, String namespace) {\n+  /**\n+   * Login to the WebLogic console and validate its the Home page.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62dfd12005633c383756152eec5c38b71795c369"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01050a7d16f060afc0b2bedae8a6eb092e792966", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/01050a7d16f060afc0b2bedae8a6eb092e792966", "committedDate": "2020-05-15T19:54:12Z", "message": "change assertion description."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMTIyMDU2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#pullrequestreview-413122056", "createdAt": "2020-05-17T02:27:57Z", "commit": {"oid": "01050a7d16f060afc0b2bedae8a6eb092e792966"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QwMjoyNzo1OFrOGWdxxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QwMjozNDo0N1rOGWdzIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwOTczMw==", "bodyText": "i prefer to be consistent - weblogic/welcome1 - helps if we need to get into the domain to debug something, plus it is clearly not real credentials, which helps with secure coding standards compliance", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r426209733", "createdAt": "2020-05-17T02:27:58Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,682 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01050a7d16f060afc0b2bedae8a6eb092e792966"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwOTg0OQ==", "bodyText": "move this to right before you actually do it, line 283", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r426209849", "createdAt": "2020-05-17T02:30:08Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,682 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"Always\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01050a7d16f060afc0b2bedae8a6eb092e792966"}, "originalPosition": 278}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwOTkzMA==", "bodyText": "that won't work - the t3 port MUST be the same as the node port, or t3 will not connect", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r426209930", "createdAt": "2020-05-17T02:31:45Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,706 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.gargoylesoftware.htmlunit.WebClient;\n+import com.gargoylesoftware.htmlunit.html.HtmlElement;\n+import com.gargoylesoftware.htmlunit.html.HtmlForm;\n+import com.gargoylesoftware.htmlunit.html.HtmlPage;\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(2)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> TestActions.getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Accessing admin server node port failed\");\n+    String consoleUrl = new StringBuffer()\n+        .append(\"http://\")\n+        .append(K8S_NODEPORT_HOST)\n+        .append(\":\")\n+        .append(serviceNodePort)\n+        .append(\"/console/login/LoginForm.jsp\").toString();\n+\n+    assertDoesNotThrow(() -> loginTest(consoleUrl, adminUser, adminPassword), \"Console login failed\");\n+  }\n+\n+  /**\n+   * Creates a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void createDomainOnPV() throws IOException {\n+\n+    logger.info(\"create a staging location for domain creation scripts\");\n+    Path pvTemp = Paths.get(RESULTS_ROOT, \"ItDomainOnPV\", \"domainCreateTempPV\");\n+    FileUtils.deleteDirectory(pvTemp.toFile());\n+    Files.createDirectories(pvTemp);\n+\n+    logger.info(\"copy the create domain WLST script to staging location\");\n+    Path srcWlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = Paths.get(pvTemp.toString(), \"create-domain.py\");\n+    Files.copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"create WebLogic domain properties file\");\n+    Path domainPropertiesFile = Paths.get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(\n+        () -> createDomainProperties(domainPropertiesFile), \"Creating domain properties file failed\");\n+\n+    logger.info(\"add files to a config map for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Create a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles),\n+        \"Creating configmap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", \"system\");\n+    p.setProperty(\"admin_password\", \"gumby1234\");\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"32001\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQxMDIyNg=="}, "originalCommit": {"oid": "4734a9394df7a21d875ef71ec02d6d2b1e03f2a5"}, "originalPosition": 352}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwOTk0Nw==", "bodyText": "WLST", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r426209947", "createdAt": "2020-05-17T02:32:04Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,682 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"Always\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Accessing admin server node port failed\");\n+    String consoleUrl = new StringBuffer()\n+        .append(\"http://\")\n+        .append(K8S_NODEPORT_HOST)\n+        .append(\":\")\n+        .append(serviceNodePort)\n+        .append(\"/console/login/LoginForm.jsp\").toString();\n+\n+    boolean loginSuccessful = assertDoesNotThrow(() -> {\n+      return TestAssertions.adminNodePortAccessible(serviceNodePort, adminUser, adminPassword);\n+    }, \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+  }\n+\n+  /**\n+   * Creates a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void createDomainOnPV() throws IOException {\n+\n+    logger.info(\"create a staging location for domain creation scripts\");\n+    Path pvTemp = Paths.get(RESULTS_ROOT, \"ItDomainOnPV\", \"domainCreateTempPV\");\n+    FileUtils.deleteDirectory(pvTemp.toFile());\n+    Files.createDirectories(pvTemp);\n+\n+    logger.info(\"copy the create domain WLST script to staging location\");\n+    Path srcWlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = Paths.get(pvTemp.toString(), \"create-domain.py\");\n+    Files.copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"create WebLogic domain properties file\");\n+    Path domainPropertiesFile = Paths.get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(\n+        () -> createDomainProperties(domainPropertiesFile), \"Creating domain properties file failed\");\n+\n+    logger.info(\"add files to a config map for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Create a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles),\n+        \"Creating configmap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", adminUser);\n+    p.setProperty(\"admin_password\", adminPassword);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"32001\");\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+\n+    p.store(new FileOutputStream(wlstPropertiesFile.toFile()), \"wlst properties file\");\n+  }\n+\n+  /**\n+   * Create configmap containing domain scripts.\n+   * @param configMapName name of the configmap to create\n+   * @param files files to add in configmap\n+   * @throws IOException when reading the file fails\n+   * @throws ApiException when create configmap fails\n+   */\n+  private void createConfigMapForDomainCreation(String configMapName, List<Path> files)\n+      throws IOException, ApiException {\n+\n+    // add wlst domain creation python script and properties files", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01050a7d16f060afc0b2bedae8a6eb092e792966"}, "originalPosition": 375}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwOTk3MQ==", "bodyText": "when -> if", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r426209971", "createdAt": "2020-05-17T02:32:29Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,682 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"Always\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Accessing admin server node port failed\");\n+    String consoleUrl = new StringBuffer()\n+        .append(\"http://\")\n+        .append(K8S_NODEPORT_HOST)\n+        .append(\":\")\n+        .append(serviceNodePort)\n+        .append(\"/console/login/LoginForm.jsp\").toString();\n+\n+    boolean loginSuccessful = assertDoesNotThrow(() -> {\n+      return TestAssertions.adminNodePortAccessible(serviceNodePort, adminUser, adminPassword);\n+    }, \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+  }\n+\n+  /**\n+   * Creates a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void createDomainOnPV() throws IOException {\n+\n+    logger.info(\"create a staging location for domain creation scripts\");\n+    Path pvTemp = Paths.get(RESULTS_ROOT, \"ItDomainOnPV\", \"domainCreateTempPV\");\n+    FileUtils.deleteDirectory(pvTemp.toFile());\n+    Files.createDirectories(pvTemp);\n+\n+    logger.info(\"copy the create domain WLST script to staging location\");\n+    Path srcWlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = Paths.get(pvTemp.toString(), \"create-domain.py\");\n+    Files.copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"create WebLogic domain properties file\");\n+    Path domainPropertiesFile = Paths.get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(\n+        () -> createDomainProperties(domainPropertiesFile), \"Creating domain properties file failed\");\n+\n+    logger.info(\"add files to a config map for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Create a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles),\n+        \"Creating configmap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", adminUser);\n+    p.setProperty(\"admin_password\", adminPassword);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"32001\");\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+\n+    p.store(new FileOutputStream(wlstPropertiesFile.toFile()), \"wlst properties file\");\n+  }\n+\n+  /**\n+   * Create configmap containing domain scripts.\n+   * @param configMapName name of the configmap to create\n+   * @param files files to add in configmap\n+   * @throws IOException when reading the file fails", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01050a7d16f060afc0b2bedae8a6eb092e792966"}, "originalPosition": 369}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMDAwMQ==", "bodyText": "create a job", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r426210001", "createdAt": "2020-05-17T02:32:43Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,682 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"Always\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Accessing admin server node port failed\");\n+    String consoleUrl = new StringBuffer()\n+        .append(\"http://\")\n+        .append(K8S_NODEPORT_HOST)\n+        .append(\":\")\n+        .append(serviceNodePort)\n+        .append(\"/console/login/LoginForm.jsp\").toString();\n+\n+    boolean loginSuccessful = assertDoesNotThrow(() -> {\n+      return TestAssertions.adminNodePortAccessible(serviceNodePort, adminUser, adminPassword);\n+    }, \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+  }\n+\n+  /**\n+   * Creates a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void createDomainOnPV() throws IOException {\n+\n+    logger.info(\"create a staging location for domain creation scripts\");\n+    Path pvTemp = Paths.get(RESULTS_ROOT, \"ItDomainOnPV\", \"domainCreateTempPV\");\n+    FileUtils.deleteDirectory(pvTemp.toFile());\n+    Files.createDirectories(pvTemp);\n+\n+    logger.info(\"copy the create domain WLST script to staging location\");\n+    Path srcWlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = Paths.get(pvTemp.toString(), \"create-domain.py\");\n+    Files.copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"create WebLogic domain properties file\");\n+    Path domainPropertiesFile = Paths.get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(\n+        () -> createDomainProperties(domainPropertiesFile), \"Creating domain properties file failed\");\n+\n+    logger.info(\"add files to a config map for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Create a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles),\n+        \"Creating configmap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", adminUser);\n+    p.setProperty(\"admin_password\", adminPassword);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"32001\");\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+\n+    p.store(new FileOutputStream(wlstPropertiesFile.toFile()), \"wlst properties file\");\n+  }\n+\n+  /**\n+   * Create configmap containing domain scripts.\n+   * @param configMapName name of the configmap to create\n+   * @param files files to add in configmap\n+   * @throws IOException when reading the file fails\n+   * @throws ApiException when create configmap fails\n+   */\n+  private void createConfigMapForDomainCreation(String configMapName, List<Path> files)\n+      throws IOException, ApiException {\n+\n+    // add wlst domain creation python script and properties files\n+    // to create domain to the configmap\n+    Map<String, String> data = new HashMap<>();\n+    for (Path file : files) {\n+      data.put(file.getFileName().toString(), Files.readString(file));\n+    }\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Failed to create configmap %s with files %s\", configMapName, files));\n+    assertTrue(cmCreated, String.format(\"Failed while creating ConfigMap %s\", configMapName));\n+  }\n+\n+  /**\n+   * Create job to create a domain on a persistent volume.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01050a7d16f060afc0b2bedae8a6eb092e792966"}, "originalPosition": 394}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMDA0NA==", "bodyText": "i think we have one of these somewhere else - we should consider refactoring to avoid duplication", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r426210044", "createdAt": "2020-05-17T02:33:45Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainOnPV.java", "diffHunk": "@@ -0,0 +1,682 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests to create domain on persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the domain can be created on persistent volume\")\n+@IntegrationTest\n+public class ItDomainOnPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private final String domainUid = \"domain-onpv\";\n+  private final String clusterName = \"pv-domain-cluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  private final String managedServerNameBase = \"managed-server\";\n+  String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+  private final int replicaCount = 2;\n+\n+  private final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  private final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+  private String wlSecretName;\n+  private final String adminUser = \"system\";\n+  private final String adminPassword = \"gumby1234\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+  }\n+\n+  @Test\n+  @DisplayName(\"Create domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException {\n+\n+    // create pull secrets for WebLogic image\n+    createOCRRepoSecret();\n+\n+    // create WebLogic credentials secret\n+    createWebLogicCredentialsSecret();\n+\n+    // create persistent volume and persistent volume claims\n+    createPVandPVC();\n+\n+    // create the domain on persistent volume\n+    createDomainOnPV();\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+            .imagePullPolicy(\"Always\")\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(OCR_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    logger.info(\"Creating domain custom resource {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain object to get created\n+    logger.info(\"Checking for domain custom resouce object in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Waiting for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPodNamePrefix + i);\n+    }\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Accessing admin server node port failed\");\n+    String consoleUrl = new StringBuffer()\n+        .append(\"http://\")\n+        .append(K8S_NODEPORT_HOST)\n+        .append(\":\")\n+        .append(serviceNodePort)\n+        .append(\"/console/login/LoginForm.jsp\").toString();\n+\n+    boolean loginSuccessful = assertDoesNotThrow(() -> {\n+      return TestAssertions.adminNodePortAccessible(serviceNodePort, adminUser, adminPassword);\n+    }, \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+  }\n+\n+  /**\n+   * Creates a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void createDomainOnPV() throws IOException {\n+\n+    logger.info(\"create a staging location for domain creation scripts\");\n+    Path pvTemp = Paths.get(RESULTS_ROOT, \"ItDomainOnPV\", \"domainCreateTempPV\");\n+    FileUtils.deleteDirectory(pvTemp.toFile());\n+    Files.createDirectories(pvTemp);\n+\n+    logger.info(\"copy the create domain WLST script to staging location\");\n+    Path srcWlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = Paths.get(pvTemp.toString(), \"create-domain.py\");\n+    Files.copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"create WebLogic domain properties file\");\n+    Path domainPropertiesFile = Paths.get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(\n+        () -> createDomainProperties(domainPropertiesFile), \"Creating domain properties file failed\");\n+\n+    logger.info(\"add files to a config map for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Create a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles),\n+        \"Creating configmap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", adminUser);\n+    p.setProperty(\"admin_password\", adminPassword);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"32001\");\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+\n+    p.store(new FileOutputStream(wlstPropertiesFile.toFile()), \"wlst properties file\");\n+  }\n+\n+  /**\n+   * Create configmap containing domain scripts.\n+   * @param configMapName name of the configmap to create\n+   * @param files files to add in configmap\n+   * @throws IOException when reading the file fails\n+   * @throws ApiException when create configmap fails\n+   */\n+  private void createConfigMapForDomainCreation(String configMapName, List<Path> files)\n+      throws IOException, ApiException {\n+\n+    // add wlst domain creation python script and properties files\n+    // to create domain to the configmap\n+    Map<String, String> data = new HashMap<>();\n+    for (Path file : files) {\n+      data.put(file.getFileName().toString(), Files.readString(file));\n+    }\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Failed to create configmap %s with files %s\", configMapName, files));\n+    assertTrue(cmCreated, String.format(\"Failed while creating ConfigMap %s\", configMapName));\n+  }\n+\n+  /**\n+   * Create job to create a domain on a persistent volume.\n+   */\n+  private void runCreateDomainJob(String pvName, String pvcName, String domainScriptCM, String namespace) {\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job\") // name of the create domain job\n+                .namespace(namespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\")  // change the ownership of the pv to opc:opc\n+                        .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(new V1Container()\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG)\n+                        .imagePullPolicy(\"Always\")\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))) // mounted under /shared inside pod\n+                        .addCommandItem(\"/bin/sh\") //call wlst.sh script with py and properties file\n+                        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+                        .addArgsItem(\"/u01/weblogic/create-domain.py\")\n+                        .addArgsItem(\"-skipWLSModuleScanning\")\n+                        .addArgsItem(\"-loadProperties\")\n+                        .addArgsItem(\"/u01/weblogic/domain.properties\")))\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptCM))))  //config map containing domain scripts\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))))));\n+    String jobName = assertDoesNotThrow(() ->\n+        createNamespacedJob(jobBody), \"Domain creation job failed\");\n+\n+    logger.info(\"Checking if the domain creation job {0} completed in namespace {1}\",\n+        jobName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for job {0} to be completed in namespace {1} \"\n+                + \"(elapsed time {2} ms, remaining time {3} ms)\",\n+                jobName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(jobCompleted(jobName, null, namespace));\n+  }\n+\n+  /**\n+   * Create secret for docker credentials.\n+   */\n+  private void createOCRRepoSecret() {\n+\n+    logger.info(\"Creating image pull secret in namespace {0}\", domainNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        OCR_USERNAME, OCR_PASSWORD, OCR_EMAIL, OCR_REGISTRY);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(OCR_SECRET_NAME)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", OCR_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", OCR_SECRET_NAME));\n+  }\n+\n+  /**\n+   * Create secret for WebLogic credentials.\n+   */\n+  private void createWebLogicCredentialsSecret() {\n+    logger.info(\"Creating secret for WebLogic credentials\");\n+    wlSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap<>();\n+    adminSecretMap.put(\"username\", adminUser);\n+    adminSecretMap.put(\"password\", adminPassword);\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(wlSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", wlSecretName));\n+  }\n+\n+  /**\n+   * Create a persistent volume and persistent volume claim.\n+   * @throws IOException when creating pv path fails\n+   */\n+  private void createPVandPVC() throws IOException {\n+    logger.info(\"creating persistent volume and persistent volume claim\");\n+\n+    Path pvHostPath = Files.createDirectories(Paths.get(\n+        PV_ROOT, this.getClass().getSimpleName(), domainUid + \"-persistentVolume\"));\n+    logger.info(\"Creating PV directory {0}\", pvHostPath);\n+    FileUtils.deleteDirectory(pvHostPath.toFile());\n+    Files.createDirectories(pvHostPath);\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Recycle\")\n+            .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(pvHostPath.toString())))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvName)\n+            .withNamespace(domainNamespace)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+    boolean success = assertDoesNotThrow(\n+        () -> createPersistentVolume(v1pv),\n+        \"Persistent volume creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolume creation failed\");\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeName(pvName)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvcName)\n+            .withNamespace(domainNamespace)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+    success = assertDoesNotThrow(\n+        () -> createPersistentVolumeClaim(v1pvc),\n+        \"Persistent volume claim creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolumeClaim creation failed\");\n+  }\n+\n+\n+  /**\n+   * Install WebLogic operator and wait until the operator pod is ready.\n+   */\n+  private static void installAndVerifyOperator() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01050a7d16f060afc0b2bedae8a6eb092e792966"}, "originalPosition": 570}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMDA4Mw==", "bodyText": "is default the namespace? if so, seems like it should be domainNamespace?\nif it is the name of the port, then that's ok, though be aware that when istio is enabled in the cluster, the port name will not be default, but probably istio-http or something like that", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1648#discussion_r426210083", "createdAt": "2020-05-17T02:34:47Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -321,7 +321,7 @@ public void testCreateMiiConfigMapDomain() {\n       checkServiceCreated(managedServerPrefix + i, domainNamespace);\n     }\n \n-    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    int adminServiceNodePort = getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01050a7d16f060afc0b2bedae8a6eb092e792966"}, "originalPosition": 24}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "304bbd2da10bc5310ba15bf5b21fe6c80b0baf3c", "author": {"user": {"login": "rjeberhard", "name": "Ryan Eberhard"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/304bbd2da10bc5310ba15bf5b21fe6c80b0baf3c", "committedDate": "2020-05-17T19:45:35Z", "message": "Merge branch 'develop' into domainonpvusingwlst"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c123c2ba3187e4b92deae9689c593a2433a2ab6b", "author": {"user": {"login": "rjeberhard", "name": "Ryan Eberhard"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c123c2ba3187e4b92deae9689c593a2433a2ab6b", "committedDate": "2020-05-18T11:32:58Z", "message": "Merge branch 'develop' into domainonpvusingwlst"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "048f584481d3e9d204f5937e29e50fb0996f129e", "author": {"user": {"login": "rjeberhard", "name": "Ryan Eberhard"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/048f584481d3e9d204f5937e29e50fb0996f129e", "committedDate": "2020-05-18T11:43:41Z", "message": "Fix build"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e71575de11690c55a776435fa3437912156f356", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/7e71575de11690c55a776435fa3437912156f356", "committedDate": "2020-05-18T18:20:24Z", "message": "Addressing Mark's review comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4793, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}