{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwMTk0MjI0", "number": 1665, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNTozOTo0MVrOD920Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNDo1NTozN1rOD-oOLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MTg3Nzg3OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiChangeAdminCredentials.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNTozOTo0MVrOGXmjDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNjowNjo0NVrOGXnvKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQwMTk5Ng==", "bodyText": "Remove  the index (1) (2) (3) (4) from javadoc", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1665#discussion_r427401996", "createdAt": "2020-05-19T15:39:41Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiChangeAdminCredentials.java", "diffHunk": "@@ -0,0 +1,528 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainResourceCredentialsSecretPatched;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podRestartVersionUpdated;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to change the WebLogic credentials secret of a domain custom resource that uses model-in-image.\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to patch the model-in-image image to change WebLogic admin credentials secret\")\n+@IntegrationTest\n+class ItMiiChangeAdminCredentials implements LoggedTest {\n+\n+  private static String domainNamespace = null;\n+  private static String domainUid = \"domain1\";\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  private static String adminServerPodName = String.format(\"%s-%s\", domainUid, ADMIN_SERVER_NAME_BASE);\n+  private static String managedServerPrefix = String.format(\"%s-%s\", domainUid, MANAGED_SERVER_NAME_BASE);\n+  private static int replicaCount = 2;\n+\n+  /**\n+   * Perform the following initialization for all the tests in this class:\n+   * 1) set up the necessary namespaces for the operator and one domain,\n+   * 2) install the operator in the first namespace, and\n+   * 3) create a domain in the second namespace using the pre-created basic MII image.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(6, MINUTES).await();\n+\n+    // get namespaces \n+    assertNotNull(namespaces.get(0), String.format(\"Namespace namespaces.get(0) is null\"));\n+    String opNamespace = namespaces.get(0);\n+\n+    assertNotNull(namespaces.get(1), String.format(\"Namespace namespaces.get(1) is null\"));\n+    domainNamespace = namespaces.get(1);\n+\n+    // install the operator\n+    logger.info(\"Install an operator in namespace {0}, managing namespace {1}\",\n+        opNamespace, domainNamespace); \n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+   \n+    // create a domain resource\n+    logger.info(\"Create model-in-image domain {0} in namespace {1}, and wait until it comes up\",\n+        domainUid, domainNamespace); \n+    createAndVerifyMiiDomain();\n+  }\n+  \n+  /**\n+   * Test patching a running model-in-image domain with a new WebLogic credentials secret\u3002\n+   * The test performs two patching operations to the domain spec\uff1a\n+   * 1\uff09 Change the domain spec's webLogicCredentialsSecret\uff1b\n+   * 2\uff09 Change the domain spec's domainRestartVersion to trigger a rolling restart of the server pods\u3002\n+   * The test verifies the following\uff1a\n+   * 1\uff09 the domain spec's webLogicCredentialsSecret and restartVersion are updated\uff1b\n+   * 2\uff09 the server pods are recreated by checking each pod's creationTimestamp before and after patching\uff1b\n+   * 3\uff09 the server pods' weblogic.domainRestartVersion label is updated\uff1b\n+   * 4\uff09 the new credentials are valid and can be used to access WebLogic RESTful Management Services\u3002", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c352cd2424a6e45ff4b30329db542716b2b5270"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQyMTQ4MQ==", "bodyText": "done.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1665#discussion_r427421481", "createdAt": "2020-05-19T16:06:45Z", "author": {"login": "doxiao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiChangeAdminCredentials.java", "diffHunk": "@@ -0,0 +1,528 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainResourceCredentialsSecretPatched;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podRestartVersionUpdated;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to change the WebLogic credentials secret of a domain custom resource that uses model-in-image.\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to patch the model-in-image image to change WebLogic admin credentials secret\")\n+@IntegrationTest\n+class ItMiiChangeAdminCredentials implements LoggedTest {\n+\n+  private static String domainNamespace = null;\n+  private static String domainUid = \"domain1\";\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  private static String adminServerPodName = String.format(\"%s-%s\", domainUid, ADMIN_SERVER_NAME_BASE);\n+  private static String managedServerPrefix = String.format(\"%s-%s\", domainUid, MANAGED_SERVER_NAME_BASE);\n+  private static int replicaCount = 2;\n+\n+  /**\n+   * Perform the following initialization for all the tests in this class:\n+   * 1) set up the necessary namespaces for the operator and one domain,\n+   * 2) install the operator in the first namespace, and\n+   * 3) create a domain in the second namespace using the pre-created basic MII image.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(6, MINUTES).await();\n+\n+    // get namespaces \n+    assertNotNull(namespaces.get(0), String.format(\"Namespace namespaces.get(0) is null\"));\n+    String opNamespace = namespaces.get(0);\n+\n+    assertNotNull(namespaces.get(1), String.format(\"Namespace namespaces.get(1) is null\"));\n+    domainNamespace = namespaces.get(1);\n+\n+    // install the operator\n+    logger.info(\"Install an operator in namespace {0}, managing namespace {1}\",\n+        opNamespace, domainNamespace); \n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+   \n+    // create a domain resource\n+    logger.info(\"Create model-in-image domain {0} in namespace {1}, and wait until it comes up\",\n+        domainUid, domainNamespace); \n+    createAndVerifyMiiDomain();\n+  }\n+  \n+  /**\n+   * Test patching a running model-in-image domain with a new WebLogic credentials secret\u3002\n+   * The test performs two patching operations to the domain spec\uff1a\n+   * 1\uff09 Change the domain spec's webLogicCredentialsSecret\uff1b\n+   * 2\uff09 Change the domain spec's domainRestartVersion to trigger a rolling restart of the server pods\u3002\n+   * The test verifies the following\uff1a\n+   * 1\uff09 the domain spec's webLogicCredentialsSecret and restartVersion are updated\uff1b\n+   * 2\uff09 the server pods are recreated by checking each pod's creationTimestamp before and after patching\uff1b\n+   * 3\uff09 the server pods' weblogic.domainRestartVersion label is updated\uff1b\n+   * 4\uff09 the new credentials are valid and can be used to access WebLogic RESTful Management Services\u3002", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQwMTk5Ng=="}, "originalCommit": {"oid": "2c352cd2424a6e45ff4b30329db542716b2b5270"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjAzODUxOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNjoxNjowNFrOGXoI4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzoyNzo1MFrOGXq-MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQyODA2Nw==", "bodyText": "Can we make this as an Action through TestAction.java, so that all MII test can use it, to verify and upgrade the Domain Restart Version", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1665#discussion_r427428067", "createdAt": "2020-05-19T16:16:04Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -475,6 +475,27 @@ public static String getPodCreationTimestamp(String namespace, String labelSelec\n     }\n   }\n \n+  /**\n+   * Get the weblogic.domainRestartVersion label from a given pod.\n+   *\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName  name of the pod\n+   * @return value of weblogic.domainRestartVersion label, null if unset or the pod is not available\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static String getPodRestartVersion(String namespace, String labelSelector, String podName)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "734241a595b7608a95c7ef9c0ca06323668f0ca6"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NDQ4MA==", "bodyText": "sure.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1665#discussion_r427474480", "createdAt": "2020-05-19T17:27:50Z", "author": {"login": "doxiao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -475,6 +475,27 @@ public static String getPodCreationTimestamp(String namespace, String labelSelec\n     }\n   }\n \n+  /**\n+   * Get the weblogic.domainRestartVersion label from a given pod.\n+   *\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName  name of the pod\n+   * @return value of weblogic.domainRestartVersion label, null if unset or the pod is not available\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static String getPodRestartVersion(String namespace, String labelSelector, String podName)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQyODA2Nw=="}, "originalCommit": {"oid": "734241a595b7608a95c7ef9c0ca06323668f0ca6"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjA4OTY3OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiChangeAdminCredentials.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNjoyODoyM1rOGXopUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNjoyODoyM1rOGXopUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQzNjM2OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertNotNull(adminPodLastCreationTime, \"creationTimestamp of the admin server pod is NULL\");\n          \n          \n            \n                assertNotNull(adminPodLastCreationTime, \"creationTimestamp of the admin server pod is null\");", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1665#discussion_r427436369", "createdAt": "2020-05-19T16:28:23Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiChangeAdminCredentials.java", "diffHunk": "@@ -0,0 +1,525 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainResourceCredentialsSecretPatched;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podRestartVersionUpdated;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to change the WebLogic credentials secret of a domain custom resource that uses model-in-image.\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to patch the model-in-image image to change WebLogic admin credentials secret\")\n+@IntegrationTest\n+class ItMiiChangeAdminCredentials implements LoggedTest {\n+\n+  private static String domainNamespace = null;\n+  private static String domainUid = \"domain1\";\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  private static String adminServerPodName = String.format(\"%s-%s\", domainUid, ADMIN_SERVER_NAME_BASE);\n+  private static String managedServerPrefix = String.format(\"%s-%s\", domainUid, MANAGED_SERVER_NAME_BASE);\n+  private static int replicaCount = 2;\n+\n+  /**\n+   * Perform initialization for all the tests in this class.\n+   * Set up the necessary namespaces, install the operator in the first namespace, and\n+   * create a domain in the second namespace using the pre-created basic MII image.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(6, MINUTES).await();\n+\n+    // get namespaces \n+    assertNotNull(namespaces.get(0), String.format(\"Namespace namespaces.get(0) is null\"));\n+    String opNamespace = namespaces.get(0);\n+\n+    assertNotNull(namespaces.get(1), String.format(\"Namespace namespaces.get(1) is null\"));\n+    domainNamespace = namespaces.get(1);\n+\n+    // install the operator\n+    logger.info(\"Install an operator in namespace {0}, managing namespace {1}\",\n+        opNamespace, domainNamespace); \n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+   \n+    // create a domain resource\n+    logger.info(\"Create model-in-image domain {0} in namespace {1}, and wait until it comes up\",\n+        domainUid, domainNamespace); \n+    createAndVerifyMiiDomain();\n+  }\n+  \n+  /**\n+   * Test patching a running model-in-image domain with a new WebLogic credentials secret.\n+   * Perform two patching operations to the domain spec: change the webLogicCredentialsSecret to a new\n+   * secret, and change the domainRestartVersion to trigger a rolling restart of the server pods.\n+   * Verify that the domain spec's webLogicCredentialsSecret and restartVersion are updated,\n+   * the server pods are recreated by checking each pod's creationTimestamp before and after patching,\n+   * the server pods' weblogic.domainRestartVersion label is updated, and \n+   * the new credentials are valid and can be used to access WebLogic RESTful Management Services.\n+   */\n+  @Test\n+  @DisplayName(\"Change the WebLogic credentials\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testChangeWebLogicCredentials() {\n+    final boolean VALID = true;\n+    final boolean INVALID = false;\n+\n+    // get the creation time of the admin server pod before patching\n+    String adminPodLastCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace,\"\",adminServerPodName),\n+        String.format(\"Failed to get creationTimestamp for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodLastCreationTime, \"creationTimestamp of the admin server pod is NULL\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "734241a595b7608a95c7ef9c0ca06323668f0ca6"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjEzMTkzOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Application.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNjozODoxMVrOGXpDsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODoyNjoxNlrOGXtOEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MzEyMw==", "bodyText": "instead of using curl, you can use the adminNodePortAccessible test assertion to  validate the new credentials.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1665#discussion_r427443123", "createdAt": "2020-05-19T16:38:11Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Application.java", "diffHunk": "@@ -119,4 +123,48 @@ public static boolean appAccessibleInPod(\n       return false;\n     }\n   } \n+  \n+  /**\n+   * Check if the given WebLogic credentials are valid by using the credentials to \n+   * invoke a RESTful Management Services command.\n+   *\n+   * @param host hostname of the admin server pod\n+   * @param podName name of the admin server pod\n+   * @param namespace name of the namespace that the pod is running in\n+   * @param username WebLogic admin username\n+   * @param password WebLogic admin password\n+   * @return true if the RESTful Management Services command succeeded\n+   **/\n+  public static boolean credentialsValid(\n+      String host,\n+      String podName,\n+      String namespace,\n+      String username,\n+      String password) {\n+    int adminServiceNodePort = getServiceNodePort(\n+        namespace, podName + \"-external\", WLS_DEFAULT_CHANNEL_NAME);\n+\n+    if (username == null) {\n+      username = ADMIN_USERNAME_DEFAULT;\n+    }\n+    if (password == null) {\n+      password = ADMIN_PASSWORD_DEFAULT;\n+    }\n+    StringBuffer cmdString = new StringBuffer()\n+        .append(\"status=$(curl --user \" + username + \":\" + password)\n+        .append(\" http://\" + host + \":\" + adminServiceNodePort)\n+        .append(\"/management/tenant-monitoring/servers/managed-server1\")\n+        .append(\" --silent --show-error \")\n+        .append(\" -o /dev/null\")\n+        .append(\" -w %{http_code});\")\n+        .append(\"echo ${status}\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "734241a595b7608a95c7ef9c0ca06323668f0ca6"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwODI1MQ==", "bodyText": "I am trying to do a REST call that causes the admin server to forward the request to a managed server. I believe adminNodePortAccessible only connects to the admin server.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1665#discussion_r427508251", "createdAt": "2020-05-19T18:20:56Z", "author": {"login": "doxiao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Application.java", "diffHunk": "@@ -119,4 +123,48 @@ public static boolean appAccessibleInPod(\n       return false;\n     }\n   } \n+  \n+  /**\n+   * Check if the given WebLogic credentials are valid by using the credentials to \n+   * invoke a RESTful Management Services command.\n+   *\n+   * @param host hostname of the admin server pod\n+   * @param podName name of the admin server pod\n+   * @param namespace name of the namespace that the pod is running in\n+   * @param username WebLogic admin username\n+   * @param password WebLogic admin password\n+   * @return true if the RESTful Management Services command succeeded\n+   **/\n+  public static boolean credentialsValid(\n+      String host,\n+      String podName,\n+      String namespace,\n+      String username,\n+      String password) {\n+    int adminServiceNodePort = getServiceNodePort(\n+        namespace, podName + \"-external\", WLS_DEFAULT_CHANNEL_NAME);\n+\n+    if (username == null) {\n+      username = ADMIN_USERNAME_DEFAULT;\n+    }\n+    if (password == null) {\n+      password = ADMIN_PASSWORD_DEFAULT;\n+    }\n+    StringBuffer cmdString = new StringBuffer()\n+        .append(\"status=$(curl --user \" + username + \":\" + password)\n+        .append(\" http://\" + host + \":\" + adminServiceNodePort)\n+        .append(\"/management/tenant-monitoring/servers/managed-server1\")\n+        .append(\" --silent --show-error \")\n+        .append(\" -o /dev/null\")\n+        .append(\" -w %{http_code});\")\n+        .append(\"echo ${status}\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MzEyMw=="}, "originalCommit": {"oid": "734241a595b7608a95c7ef9c0ca06323668f0ca6"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUxMTMxMw==", "bodyText": "oh, I guess that's good enough.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1665#discussion_r427511313", "createdAt": "2020-05-19T18:26:16Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Application.java", "diffHunk": "@@ -119,4 +123,48 @@ public static boolean appAccessibleInPod(\n       return false;\n     }\n   } \n+  \n+  /**\n+   * Check if the given WebLogic credentials are valid by using the credentials to \n+   * invoke a RESTful Management Services command.\n+   *\n+   * @param host hostname of the admin server pod\n+   * @param podName name of the admin server pod\n+   * @param namespace name of the namespace that the pod is running in\n+   * @param username WebLogic admin username\n+   * @param password WebLogic admin password\n+   * @return true if the RESTful Management Services command succeeded\n+   **/\n+  public static boolean credentialsValid(\n+      String host,\n+      String podName,\n+      String namespace,\n+      String username,\n+      String password) {\n+    int adminServiceNodePort = getServiceNodePort(\n+        namespace, podName + \"-external\", WLS_DEFAULT_CHANNEL_NAME);\n+\n+    if (username == null) {\n+      username = ADMIN_USERNAME_DEFAULT;\n+    }\n+    if (password == null) {\n+      password = ADMIN_PASSWORD_DEFAULT;\n+    }\n+    StringBuffer cmdString = new StringBuffer()\n+        .append(\"status=$(curl --user \" + username + \":\" + password)\n+        .append(\" http://\" + host + \":\" + adminServiceNodePort)\n+        .append(\"/management/tenant-monitoring/servers/managed-server1\")\n+        .append(\" --silent --show-error \")\n+        .append(\" -o /dev/null\")\n+        .append(\" -w %{http_code});\")\n+        .append(\"echo ${status}\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MzEyMw=="}, "originalCommit": {"oid": "734241a595b7608a95c7ef9c0ca06323668f0ca6"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2OTgzMTYxOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiChangeAdminCredentials.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNDoyMDozOFrOGY0qXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNTozMToyMVrOGY3lsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY4MTgyMw==", "bodyText": "space after \"with:\"", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1665#discussion_r428681823", "createdAt": "2020-05-21T14:20:38Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiChangeAdminCredentials.java", "diffHunk": "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsNotValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainResourceCredentialsSecretPatched;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podRestartVersionUpdated;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to change the WebLogic credentials secret of a domain custom resource that uses model-in-image.\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to patch the model-in-image image to change WebLogic admin credentials secret\")\n+@IntegrationTest\n+class ItMiiChangeAdminCredentials implements LoggedTest {\n+\n+  private static String domainNamespace = null;\n+  private static String domainUid = \"domain1\";\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static ConditionFactory withQuickRetryPolicy = null;\n+\n+  private static String adminServerPodName = String.format(\"%s-%s\", domainUid, ADMIN_SERVER_NAME_BASE);\n+  private static String managedServerPrefix = String.format(\"%s-%s\", domainUid, MANAGED_SERVER_NAME_BASE);\n+  private static int replicaCount = 2;\n+\n+  /**\n+   * Perform initialization for all the tests in this class.\n+   * Set up the necessary namespaces, install the operator in the first namespace, and\n+   * create a domain in the second namespace using the pre-created basic MII image.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(6, MINUTES).await();\n+\n+    // create quick, reusable retry/backoff policy\n+    withQuickRetryPolicy = with().pollDelay(0, SECONDS)\n+        .and().with().pollInterval(3, SECONDS)\n+        .atMost(12, SECONDS).await();\n+\n+    // get namespaces \n+    assertNotNull(namespaces.get(0), String.format(\"Namespace namespaces.get(0) is null\"));\n+    String opNamespace = namespaces.get(0);\n+\n+    assertNotNull(namespaces.get(1), String.format(\"Namespace namespaces.get(1) is null\"));\n+    domainNamespace = namespaces.get(1);\n+\n+    // install the operator\n+    logger.info(\"Install an operator in namespace {0}, managing namespace {1}\",\n+        opNamespace, domainNamespace); \n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+   \n+    // create a domain resource\n+    logger.info(\"Create model-in-image domain {0} in namespace {1}, and wait until it comes up\",\n+        domainUid, domainNamespace); \n+    createAndVerifyMiiDomain();\n+  }\n+  \n+  /**\n+   * Test patching a running model-in-image domain with a new WebLogic credentials secret.\n+   * Perform two patching operations to the domain spec: change the webLogicCredentialsSecret to a new\n+   * secret, and change the domainRestartVersion to trigger a rolling restart of the server pods.\n+   * Verify that the domain spec's webLogicCredentialsSecret and restartVersion are updated,\n+   * the server pods are recreated by checking each pod's creationTimestamp before and after patching,\n+   * the server pods' weblogic.domainRestartVersion label is updated, and \n+   * the new credentials are valid and can be used to access WebLogic RESTful Management Services.\n+   */\n+  @Test\n+  @DisplayName(\"Change the WebLogic credentials\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testChangeWebLogicCredentials() {\n+    final boolean VALID = true;\n+    final boolean INVALID = false;\n+\n+    // get the creation time of the admin server pod before patching\n+    String adminPodLastCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace,\"\",adminServerPodName),\n+        String.format(\"Failed to get creationTimestamp for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodLastCreationTime, \"creationTimestamp of the admin server pod is null\");\n+\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodLastCreationTime);\n+    \n+    List<String> msLastCreationTime = new ArrayList<String>();\n+    // get the creation time of the managed server pods before patching\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            msLastCreationTime.add(creationTime);\n+\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    \n+    logger.info(\"Check that before patching current credentials are valid and new credentials are not\");\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, VALID);\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_PATCH, ADMIN_PASSWORD_PATCH, INVALID);\n+    \n+    // create a new secret for admin credentials\n+    logger.info(\"Create a new secret that contains new WebLogic admin credentials\");\n+    String adminSecretName = \"weblogic-credentials-new\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(\n+        adminSecretName,\n+        domainNamespace,\n+        ADMIN_USERNAME_PATCH,\n+        ADMIN_PASSWORD_PATCH),\n+        String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // patch the domain resource with the new secret and verify that the domain resource is patched.\n+    logger.info(\"Patch domain {0} in namespace {1} with the secret {2}, and verify the result\",\n+        domainUid, domainNamespace, adminSecretName); \n+\n+    String restartVersion = patchDomainWithNewSecretAndVerify(\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        managedServerPrefix,\n+        replicaCount,\n+        adminSecretName);\n+\n+    logger.info(\"Wait for domain {0} admin server pod {1} in namespace {2} to be restarted\",\n+        domainUid, adminServerPodName, domainNamespace);\n+    checkPodRestarted(domainUid, domainNamespace, adminServerPodName, adminPodLastCreationTime);\n+    \n+    // check that the admin server pod's label has been updated with the new restartVersion\n+    checkPodRestartVersionUpdated(adminServerPodName, domainUid, domainNamespace, restartVersion);\n+    \n+    // check that the managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      final String podName = managedServerPrefix + i;\n+      final String lastCreationTime = msLastCreationTime.get(i - 1);\n+      logger.info(\"Wait for managed server pod {0} to be restarted in namespace {1}\",\n+          podName, domainNamespace);\n+      checkPodRestarted(domainUid, domainNamespace, podName, lastCreationTime);\n+      \n+      // check that the managed server pod's label has been updated with the new restartVersion\n+      checkPodRestartVersionUpdated(podName, domainUid, domainNamespace, restartVersion);\n+    }\n+ \n+    // check if the new credentials are valid and the old credentials are not valid any more\n+    logger.info(\"Check that after patching current credentials are not valid and new credentials are\");\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, INVALID);\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_PATCH, ADMIN_PASSWORD_PATCH, VALID);\n+    \n+    logger.info(\"Domain {0} in namespace {1} is fully started after changing WebLogic credentials secret\",\n+        domainUid, domainNamespace);\n+  }\n+\n+  /**\n+   * Patch the domain resource with a new WebLogic admin credentials secret.\n+   * \n+   * @param domainResourceName name of the domain resource\n+   * @param namespace Kubernetes namespace that the domain is hosted\n+   * @param secretName name of the new WebLogic admin credentials secret\n+   * @return restartVersion new restartVersion of the domain resource\n+   */\n+  private String patchDomainResourceWithNewAdminSecret(\n+      String domainResourceName,\n+      String namespace,\n+      String secretName\n+  ) {\n+    String patch = String.format(\n+        \"[\\n  {\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/%s\\\", \\\"value\\\": \\\"%s\\\"}\\n]\\n\",\n+            \"webLogicCredentialsSecret/name\", secretName);\n+    logger.info(\"Patch the domain resource {0} in namespace {1} with:{2}\\n\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25b33e831acbcb76ad4c0af938dc431fc4f955ac"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcyOTc3OQ==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1665#discussion_r428729779", "createdAt": "2020-05-21T15:31:21Z", "author": {"login": "doxiao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiChangeAdminCredentials.java", "diffHunk": "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsNotValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainResourceCredentialsSecretPatched;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podRestartVersionUpdated;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to change the WebLogic credentials secret of a domain custom resource that uses model-in-image.\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to patch the model-in-image image to change WebLogic admin credentials secret\")\n+@IntegrationTest\n+class ItMiiChangeAdminCredentials implements LoggedTest {\n+\n+  private static String domainNamespace = null;\n+  private static String domainUid = \"domain1\";\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static ConditionFactory withQuickRetryPolicy = null;\n+\n+  private static String adminServerPodName = String.format(\"%s-%s\", domainUid, ADMIN_SERVER_NAME_BASE);\n+  private static String managedServerPrefix = String.format(\"%s-%s\", domainUid, MANAGED_SERVER_NAME_BASE);\n+  private static int replicaCount = 2;\n+\n+  /**\n+   * Perform initialization for all the tests in this class.\n+   * Set up the necessary namespaces, install the operator in the first namespace, and\n+   * create a domain in the second namespace using the pre-created basic MII image.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(6, MINUTES).await();\n+\n+    // create quick, reusable retry/backoff policy\n+    withQuickRetryPolicy = with().pollDelay(0, SECONDS)\n+        .and().with().pollInterval(3, SECONDS)\n+        .atMost(12, SECONDS).await();\n+\n+    // get namespaces \n+    assertNotNull(namespaces.get(0), String.format(\"Namespace namespaces.get(0) is null\"));\n+    String opNamespace = namespaces.get(0);\n+\n+    assertNotNull(namespaces.get(1), String.format(\"Namespace namespaces.get(1) is null\"));\n+    domainNamespace = namespaces.get(1);\n+\n+    // install the operator\n+    logger.info(\"Install an operator in namespace {0}, managing namespace {1}\",\n+        opNamespace, domainNamespace); \n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+   \n+    // create a domain resource\n+    logger.info(\"Create model-in-image domain {0} in namespace {1}, and wait until it comes up\",\n+        domainUid, domainNamespace); \n+    createAndVerifyMiiDomain();\n+  }\n+  \n+  /**\n+   * Test patching a running model-in-image domain with a new WebLogic credentials secret.\n+   * Perform two patching operations to the domain spec: change the webLogicCredentialsSecret to a new\n+   * secret, and change the domainRestartVersion to trigger a rolling restart of the server pods.\n+   * Verify that the domain spec's webLogicCredentialsSecret and restartVersion are updated,\n+   * the server pods are recreated by checking each pod's creationTimestamp before and after patching,\n+   * the server pods' weblogic.domainRestartVersion label is updated, and \n+   * the new credentials are valid and can be used to access WebLogic RESTful Management Services.\n+   */\n+  @Test\n+  @DisplayName(\"Change the WebLogic credentials\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testChangeWebLogicCredentials() {\n+    final boolean VALID = true;\n+    final boolean INVALID = false;\n+\n+    // get the creation time of the admin server pod before patching\n+    String adminPodLastCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace,\"\",adminServerPodName),\n+        String.format(\"Failed to get creationTimestamp for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodLastCreationTime, \"creationTimestamp of the admin server pod is null\");\n+\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodLastCreationTime);\n+    \n+    List<String> msLastCreationTime = new ArrayList<String>();\n+    // get the creation time of the managed server pods before patching\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            msLastCreationTime.add(creationTime);\n+\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    \n+    logger.info(\"Check that before patching current credentials are valid and new credentials are not\");\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, VALID);\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_PATCH, ADMIN_PASSWORD_PATCH, INVALID);\n+    \n+    // create a new secret for admin credentials\n+    logger.info(\"Create a new secret that contains new WebLogic admin credentials\");\n+    String adminSecretName = \"weblogic-credentials-new\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(\n+        adminSecretName,\n+        domainNamespace,\n+        ADMIN_USERNAME_PATCH,\n+        ADMIN_PASSWORD_PATCH),\n+        String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // patch the domain resource with the new secret and verify that the domain resource is patched.\n+    logger.info(\"Patch domain {0} in namespace {1} with the secret {2}, and verify the result\",\n+        domainUid, domainNamespace, adminSecretName); \n+\n+    String restartVersion = patchDomainWithNewSecretAndVerify(\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        managedServerPrefix,\n+        replicaCount,\n+        adminSecretName);\n+\n+    logger.info(\"Wait for domain {0} admin server pod {1} in namespace {2} to be restarted\",\n+        domainUid, adminServerPodName, domainNamespace);\n+    checkPodRestarted(domainUid, domainNamespace, adminServerPodName, adminPodLastCreationTime);\n+    \n+    // check that the admin server pod's label has been updated with the new restartVersion\n+    checkPodRestartVersionUpdated(adminServerPodName, domainUid, domainNamespace, restartVersion);\n+    \n+    // check that the managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      final String podName = managedServerPrefix + i;\n+      final String lastCreationTime = msLastCreationTime.get(i - 1);\n+      logger.info(\"Wait for managed server pod {0} to be restarted in namespace {1}\",\n+          podName, domainNamespace);\n+      checkPodRestarted(domainUid, domainNamespace, podName, lastCreationTime);\n+      \n+      // check that the managed server pod's label has been updated with the new restartVersion\n+      checkPodRestartVersionUpdated(podName, domainUid, domainNamespace, restartVersion);\n+    }\n+ \n+    // check if the new credentials are valid and the old credentials are not valid any more\n+    logger.info(\"Check that after patching current credentials are not valid and new credentials are\");\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, INVALID);\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_PATCH, ADMIN_PASSWORD_PATCH, VALID);\n+    \n+    logger.info(\"Domain {0} in namespace {1} is fully started after changing WebLogic credentials secret\",\n+        domainUid, domainNamespace);\n+  }\n+\n+  /**\n+   * Patch the domain resource with a new WebLogic admin credentials secret.\n+   * \n+   * @param domainResourceName name of the domain resource\n+   * @param namespace Kubernetes namespace that the domain is hosted\n+   * @param secretName name of the new WebLogic admin credentials secret\n+   * @return restartVersion new restartVersion of the domain resource\n+   */\n+  private String patchDomainResourceWithNewAdminSecret(\n+      String domainResourceName,\n+      String namespace,\n+      String secretName\n+  ) {\n+    String patch = String.format(\n+        \"[\\n  {\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/%s\\\", \\\"value\\\": \\\"%s\\\"}\\n]\\n\",\n+            \"webLogicCredentialsSecret/name\", secretName);\n+    logger.info(\"Patch the domain resource {0} in namespace {1} with:{2}\\n\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY4MTgyMw=="}, "originalCommit": {"oid": "25b33e831acbcb76ad4c0af938dc431fc4f955ac"}, "originalPosition": 236}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2OTgzMjcyOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiChangeAdminCredentials.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNDoyMDo1MlrOGY0rCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNTozMToyOFrOGY3l9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY4MTk5Mg==", "bodyText": "Space after \"with:\"", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1665#discussion_r428681992", "createdAt": "2020-05-21T14:20:52Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiChangeAdminCredentials.java", "diffHunk": "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsNotValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainResourceCredentialsSecretPatched;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podRestartVersionUpdated;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to change the WebLogic credentials secret of a domain custom resource that uses model-in-image.\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to patch the model-in-image image to change WebLogic admin credentials secret\")\n+@IntegrationTest\n+class ItMiiChangeAdminCredentials implements LoggedTest {\n+\n+  private static String domainNamespace = null;\n+  private static String domainUid = \"domain1\";\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static ConditionFactory withQuickRetryPolicy = null;\n+\n+  private static String adminServerPodName = String.format(\"%s-%s\", domainUid, ADMIN_SERVER_NAME_BASE);\n+  private static String managedServerPrefix = String.format(\"%s-%s\", domainUid, MANAGED_SERVER_NAME_BASE);\n+  private static int replicaCount = 2;\n+\n+  /**\n+   * Perform initialization for all the tests in this class.\n+   * Set up the necessary namespaces, install the operator in the first namespace, and\n+   * create a domain in the second namespace using the pre-created basic MII image.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(6, MINUTES).await();\n+\n+    // create quick, reusable retry/backoff policy\n+    withQuickRetryPolicy = with().pollDelay(0, SECONDS)\n+        .and().with().pollInterval(3, SECONDS)\n+        .atMost(12, SECONDS).await();\n+\n+    // get namespaces \n+    assertNotNull(namespaces.get(0), String.format(\"Namespace namespaces.get(0) is null\"));\n+    String opNamespace = namespaces.get(0);\n+\n+    assertNotNull(namespaces.get(1), String.format(\"Namespace namespaces.get(1) is null\"));\n+    domainNamespace = namespaces.get(1);\n+\n+    // install the operator\n+    logger.info(\"Install an operator in namespace {0}, managing namespace {1}\",\n+        opNamespace, domainNamespace); \n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+   \n+    // create a domain resource\n+    logger.info(\"Create model-in-image domain {0} in namespace {1}, and wait until it comes up\",\n+        domainUid, domainNamespace); \n+    createAndVerifyMiiDomain();\n+  }\n+  \n+  /**\n+   * Test patching a running model-in-image domain with a new WebLogic credentials secret.\n+   * Perform two patching operations to the domain spec: change the webLogicCredentialsSecret to a new\n+   * secret, and change the domainRestartVersion to trigger a rolling restart of the server pods.\n+   * Verify that the domain spec's webLogicCredentialsSecret and restartVersion are updated,\n+   * the server pods are recreated by checking each pod's creationTimestamp before and after patching,\n+   * the server pods' weblogic.domainRestartVersion label is updated, and \n+   * the new credentials are valid and can be used to access WebLogic RESTful Management Services.\n+   */\n+  @Test\n+  @DisplayName(\"Change the WebLogic credentials\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testChangeWebLogicCredentials() {\n+    final boolean VALID = true;\n+    final boolean INVALID = false;\n+\n+    // get the creation time of the admin server pod before patching\n+    String adminPodLastCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace,\"\",adminServerPodName),\n+        String.format(\"Failed to get creationTimestamp for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodLastCreationTime, \"creationTimestamp of the admin server pod is null\");\n+\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodLastCreationTime);\n+    \n+    List<String> msLastCreationTime = new ArrayList<String>();\n+    // get the creation time of the managed server pods before patching\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            msLastCreationTime.add(creationTime);\n+\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    \n+    logger.info(\"Check that before patching current credentials are valid and new credentials are not\");\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, VALID);\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_PATCH, ADMIN_PASSWORD_PATCH, INVALID);\n+    \n+    // create a new secret for admin credentials\n+    logger.info(\"Create a new secret that contains new WebLogic admin credentials\");\n+    String adminSecretName = \"weblogic-credentials-new\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(\n+        adminSecretName,\n+        domainNamespace,\n+        ADMIN_USERNAME_PATCH,\n+        ADMIN_PASSWORD_PATCH),\n+        String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // patch the domain resource with the new secret and verify that the domain resource is patched.\n+    logger.info(\"Patch domain {0} in namespace {1} with the secret {2}, and verify the result\",\n+        domainUid, domainNamespace, adminSecretName); \n+\n+    String restartVersion = patchDomainWithNewSecretAndVerify(\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        managedServerPrefix,\n+        replicaCount,\n+        adminSecretName);\n+\n+    logger.info(\"Wait for domain {0} admin server pod {1} in namespace {2} to be restarted\",\n+        domainUid, adminServerPodName, domainNamespace);\n+    checkPodRestarted(domainUid, domainNamespace, adminServerPodName, adminPodLastCreationTime);\n+    \n+    // check that the admin server pod's label has been updated with the new restartVersion\n+    checkPodRestartVersionUpdated(adminServerPodName, domainUid, domainNamespace, restartVersion);\n+    \n+    // check that the managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      final String podName = managedServerPrefix + i;\n+      final String lastCreationTime = msLastCreationTime.get(i - 1);\n+      logger.info(\"Wait for managed server pod {0} to be restarted in namespace {1}\",\n+          podName, domainNamespace);\n+      checkPodRestarted(domainUid, domainNamespace, podName, lastCreationTime);\n+      \n+      // check that the managed server pod's label has been updated with the new restartVersion\n+      checkPodRestartVersionUpdated(podName, domainUid, domainNamespace, restartVersion);\n+    }\n+ \n+    // check if the new credentials are valid and the old credentials are not valid any more\n+    logger.info(\"Check that after patching current credentials are not valid and new credentials are\");\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, INVALID);\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_PATCH, ADMIN_PASSWORD_PATCH, VALID);\n+    \n+    logger.info(\"Domain {0} in namespace {1} is fully started after changing WebLogic credentials secret\",\n+        domainUid, domainNamespace);\n+  }\n+\n+  /**\n+   * Patch the domain resource with a new WebLogic admin credentials secret.\n+   * \n+   * @param domainResourceName name of the domain resource\n+   * @param namespace Kubernetes namespace that the domain is hosted\n+   * @param secretName name of the new WebLogic admin credentials secret\n+   * @return restartVersion new restartVersion of the domain resource\n+   */\n+  private String patchDomainResourceWithNewAdminSecret(\n+      String domainResourceName,\n+      String namespace,\n+      String secretName\n+  ) {\n+    String patch = String.format(\n+        \"[\\n  {\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/%s\\\", \\\"value\\\": \\\"%s\\\"}\\n]\\n\",\n+            \"webLogicCredentialsSecret/name\", secretName);\n+    logger.info(\"Patch the domain resource {0} in namespace {1} with:{2}\\n\",\n+        domainResourceName, namespace, patch);\n+\n+    assertTrue(patchDomainCustomResource(\n+            domainResourceName,\n+            namespace,\n+            new V1Patch(patch),\n+            V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        String.format(\"Failed to patch the domain resource %s in namespace %s with %s:%s\",\n+            domainResourceName, namespace, \"/spec/webLogicCredentialsSecret/name\", secretName));\n+\n+    String oldVersion = assertDoesNotThrow(\n+        () -> getDomainCustomResource(domainResourceName, namespace).getSpec().getRestartVersion(),\n+        String.format(\"Failed to get the restartVersion of %s in namespace %s\", domainResourceName, namespace));\n+    int newVersion = oldVersion == null ? 1 : Integer.valueOf(oldVersion) + 1;\n+    logger.info(\"Update domain resource {0} in namespace {1} restartVersion from {2} to {3}\",\n+        domainResourceName, namespace, oldVersion, newVersion);\n+    patch =\n+        String.format(\"[\\n  {\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/restartVersion\\\", \\\"value\\\": \\\"%s\\\"}\\n]\\n\",\n+            newVersion);\n+    \n+    logger.info(\"Patch the domain resource {0} in namespace {1} with:{2}\\n\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25b33e831acbcb76ad4c0af938dc431fc4f955ac"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcyOTg0Nw==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1665#discussion_r428729847", "createdAt": "2020-05-21T15:31:28Z", "author": {"login": "doxiao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiChangeAdminCredentials.java", "diffHunk": "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsNotValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainResourceCredentialsSecretPatched;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podRestartVersionUpdated;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to change the WebLogic credentials secret of a domain custom resource that uses model-in-image.\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to patch the model-in-image image to change WebLogic admin credentials secret\")\n+@IntegrationTest\n+class ItMiiChangeAdminCredentials implements LoggedTest {\n+\n+  private static String domainNamespace = null;\n+  private static String domainUid = \"domain1\";\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static ConditionFactory withQuickRetryPolicy = null;\n+\n+  private static String adminServerPodName = String.format(\"%s-%s\", domainUid, ADMIN_SERVER_NAME_BASE);\n+  private static String managedServerPrefix = String.format(\"%s-%s\", domainUid, MANAGED_SERVER_NAME_BASE);\n+  private static int replicaCount = 2;\n+\n+  /**\n+   * Perform initialization for all the tests in this class.\n+   * Set up the necessary namespaces, install the operator in the first namespace, and\n+   * create a domain in the second namespace using the pre-created basic MII image.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(6, MINUTES).await();\n+\n+    // create quick, reusable retry/backoff policy\n+    withQuickRetryPolicy = with().pollDelay(0, SECONDS)\n+        .and().with().pollInterval(3, SECONDS)\n+        .atMost(12, SECONDS).await();\n+\n+    // get namespaces \n+    assertNotNull(namespaces.get(0), String.format(\"Namespace namespaces.get(0) is null\"));\n+    String opNamespace = namespaces.get(0);\n+\n+    assertNotNull(namespaces.get(1), String.format(\"Namespace namespaces.get(1) is null\"));\n+    domainNamespace = namespaces.get(1);\n+\n+    // install the operator\n+    logger.info(\"Install an operator in namespace {0}, managing namespace {1}\",\n+        opNamespace, domainNamespace); \n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+   \n+    // create a domain resource\n+    logger.info(\"Create model-in-image domain {0} in namespace {1}, and wait until it comes up\",\n+        domainUid, domainNamespace); \n+    createAndVerifyMiiDomain();\n+  }\n+  \n+  /**\n+   * Test patching a running model-in-image domain with a new WebLogic credentials secret.\n+   * Perform two patching operations to the domain spec: change the webLogicCredentialsSecret to a new\n+   * secret, and change the domainRestartVersion to trigger a rolling restart of the server pods.\n+   * Verify that the domain spec's webLogicCredentialsSecret and restartVersion are updated,\n+   * the server pods are recreated by checking each pod's creationTimestamp before and after patching,\n+   * the server pods' weblogic.domainRestartVersion label is updated, and \n+   * the new credentials are valid and can be used to access WebLogic RESTful Management Services.\n+   */\n+  @Test\n+  @DisplayName(\"Change the WebLogic credentials\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testChangeWebLogicCredentials() {\n+    final boolean VALID = true;\n+    final boolean INVALID = false;\n+\n+    // get the creation time of the admin server pod before patching\n+    String adminPodLastCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace,\"\",adminServerPodName),\n+        String.format(\"Failed to get creationTimestamp for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodLastCreationTime, \"creationTimestamp of the admin server pod is null\");\n+\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodLastCreationTime);\n+    \n+    List<String> msLastCreationTime = new ArrayList<String>();\n+    // get the creation time of the managed server pods before patching\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            msLastCreationTime.add(creationTime);\n+\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    \n+    logger.info(\"Check that before patching current credentials are valid and new credentials are not\");\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, VALID);\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_PATCH, ADMIN_PASSWORD_PATCH, INVALID);\n+    \n+    // create a new secret for admin credentials\n+    logger.info(\"Create a new secret that contains new WebLogic admin credentials\");\n+    String adminSecretName = \"weblogic-credentials-new\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(\n+        adminSecretName,\n+        domainNamespace,\n+        ADMIN_USERNAME_PATCH,\n+        ADMIN_PASSWORD_PATCH),\n+        String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // patch the domain resource with the new secret and verify that the domain resource is patched.\n+    logger.info(\"Patch domain {0} in namespace {1} with the secret {2}, and verify the result\",\n+        domainUid, domainNamespace, adminSecretName); \n+\n+    String restartVersion = patchDomainWithNewSecretAndVerify(\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        managedServerPrefix,\n+        replicaCount,\n+        adminSecretName);\n+\n+    logger.info(\"Wait for domain {0} admin server pod {1} in namespace {2} to be restarted\",\n+        domainUid, adminServerPodName, domainNamespace);\n+    checkPodRestarted(domainUid, domainNamespace, adminServerPodName, adminPodLastCreationTime);\n+    \n+    // check that the admin server pod's label has been updated with the new restartVersion\n+    checkPodRestartVersionUpdated(adminServerPodName, domainUid, domainNamespace, restartVersion);\n+    \n+    // check that the managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      final String podName = managedServerPrefix + i;\n+      final String lastCreationTime = msLastCreationTime.get(i - 1);\n+      logger.info(\"Wait for managed server pod {0} to be restarted in namespace {1}\",\n+          podName, domainNamespace);\n+      checkPodRestarted(domainUid, domainNamespace, podName, lastCreationTime);\n+      \n+      // check that the managed server pod's label has been updated with the new restartVersion\n+      checkPodRestartVersionUpdated(podName, domainUid, domainNamespace, restartVersion);\n+    }\n+ \n+    // check if the new credentials are valid and the old credentials are not valid any more\n+    logger.info(\"Check that after patching current credentials are not valid and new credentials are\");\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, INVALID);\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_PATCH, ADMIN_PASSWORD_PATCH, VALID);\n+    \n+    logger.info(\"Domain {0} in namespace {1} is fully started after changing WebLogic credentials secret\",\n+        domainUid, domainNamespace);\n+  }\n+\n+  /**\n+   * Patch the domain resource with a new WebLogic admin credentials secret.\n+   * \n+   * @param domainResourceName name of the domain resource\n+   * @param namespace Kubernetes namespace that the domain is hosted\n+   * @param secretName name of the new WebLogic admin credentials secret\n+   * @return restartVersion new restartVersion of the domain resource\n+   */\n+  private String patchDomainResourceWithNewAdminSecret(\n+      String domainResourceName,\n+      String namespace,\n+      String secretName\n+  ) {\n+    String patch = String.format(\n+        \"[\\n  {\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/%s\\\", \\\"value\\\": \\\"%s\\\"}\\n]\\n\",\n+            \"webLogicCredentialsSecret/name\", secretName);\n+    logger.info(\"Patch the domain resource {0} in namespace {1} with:{2}\\n\",\n+        domainResourceName, namespace, patch);\n+\n+    assertTrue(patchDomainCustomResource(\n+            domainResourceName,\n+            namespace,\n+            new V1Patch(patch),\n+            V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        String.format(\"Failed to patch the domain resource %s in namespace %s with %s:%s\",\n+            domainResourceName, namespace, \"/spec/webLogicCredentialsSecret/name\", secretName));\n+\n+    String oldVersion = assertDoesNotThrow(\n+        () -> getDomainCustomResource(domainResourceName, namespace).getSpec().getRestartVersion(),\n+        String.format(\"Failed to get the restartVersion of %s in namespace %s\", domainResourceName, namespace));\n+    int newVersion = oldVersion == null ? 1 : Integer.valueOf(oldVersion) + 1;\n+    logger.info(\"Update domain resource {0} in namespace {1} restartVersion from {2} to {3}\",\n+        domainResourceName, namespace, oldVersion, newVersion);\n+    patch =\n+        String.format(\"[\\n  {\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/restartVersion\\\", \\\"value\\\": \\\"%s\\\"}\\n]\\n\",\n+            newVersion);\n+    \n+    logger.info(\"Patch the domain resource {0} in namespace {1} with:{2}\\n\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY4MTk5Mg=="}, "originalCommit": {"oid": "25b33e831acbcb76ad4c0af938dc431fc4f955ac"}, "originalPosition": 257}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2OTgzNDE0OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiChangeAdminCredentials.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNDoyMToxM1rOGY0r5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNTozMTozNlrOGY3mPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY4MjIxNA==", "bodyText": "Same :)... Space after \"startVersion:\"", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1665#discussion_r428682214", "createdAt": "2020-05-21T14:21:13Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiChangeAdminCredentials.java", "diffHunk": "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsNotValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainResourceCredentialsSecretPatched;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podRestartVersionUpdated;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to change the WebLogic credentials secret of a domain custom resource that uses model-in-image.\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to patch the model-in-image image to change WebLogic admin credentials secret\")\n+@IntegrationTest\n+class ItMiiChangeAdminCredentials implements LoggedTest {\n+\n+  private static String domainNamespace = null;\n+  private static String domainUid = \"domain1\";\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static ConditionFactory withQuickRetryPolicy = null;\n+\n+  private static String adminServerPodName = String.format(\"%s-%s\", domainUid, ADMIN_SERVER_NAME_BASE);\n+  private static String managedServerPrefix = String.format(\"%s-%s\", domainUid, MANAGED_SERVER_NAME_BASE);\n+  private static int replicaCount = 2;\n+\n+  /**\n+   * Perform initialization for all the tests in this class.\n+   * Set up the necessary namespaces, install the operator in the first namespace, and\n+   * create a domain in the second namespace using the pre-created basic MII image.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(6, MINUTES).await();\n+\n+    // create quick, reusable retry/backoff policy\n+    withQuickRetryPolicy = with().pollDelay(0, SECONDS)\n+        .and().with().pollInterval(3, SECONDS)\n+        .atMost(12, SECONDS).await();\n+\n+    // get namespaces \n+    assertNotNull(namespaces.get(0), String.format(\"Namespace namespaces.get(0) is null\"));\n+    String opNamespace = namespaces.get(0);\n+\n+    assertNotNull(namespaces.get(1), String.format(\"Namespace namespaces.get(1) is null\"));\n+    domainNamespace = namespaces.get(1);\n+\n+    // install the operator\n+    logger.info(\"Install an operator in namespace {0}, managing namespace {1}\",\n+        opNamespace, domainNamespace); \n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+   \n+    // create a domain resource\n+    logger.info(\"Create model-in-image domain {0} in namespace {1}, and wait until it comes up\",\n+        domainUid, domainNamespace); \n+    createAndVerifyMiiDomain();\n+  }\n+  \n+  /**\n+   * Test patching a running model-in-image domain with a new WebLogic credentials secret.\n+   * Perform two patching operations to the domain spec: change the webLogicCredentialsSecret to a new\n+   * secret, and change the domainRestartVersion to trigger a rolling restart of the server pods.\n+   * Verify that the domain spec's webLogicCredentialsSecret and restartVersion are updated,\n+   * the server pods are recreated by checking each pod's creationTimestamp before and after patching,\n+   * the server pods' weblogic.domainRestartVersion label is updated, and \n+   * the new credentials are valid and can be used to access WebLogic RESTful Management Services.\n+   */\n+  @Test\n+  @DisplayName(\"Change the WebLogic credentials\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testChangeWebLogicCredentials() {\n+    final boolean VALID = true;\n+    final boolean INVALID = false;\n+\n+    // get the creation time of the admin server pod before patching\n+    String adminPodLastCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace,\"\",adminServerPodName),\n+        String.format(\"Failed to get creationTimestamp for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodLastCreationTime, \"creationTimestamp of the admin server pod is null\");\n+\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodLastCreationTime);\n+    \n+    List<String> msLastCreationTime = new ArrayList<String>();\n+    // get the creation time of the managed server pods before patching\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            msLastCreationTime.add(creationTime);\n+\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    \n+    logger.info(\"Check that before patching current credentials are valid and new credentials are not\");\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, VALID);\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_PATCH, ADMIN_PASSWORD_PATCH, INVALID);\n+    \n+    // create a new secret for admin credentials\n+    logger.info(\"Create a new secret that contains new WebLogic admin credentials\");\n+    String adminSecretName = \"weblogic-credentials-new\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(\n+        adminSecretName,\n+        domainNamespace,\n+        ADMIN_USERNAME_PATCH,\n+        ADMIN_PASSWORD_PATCH),\n+        String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // patch the domain resource with the new secret and verify that the domain resource is patched.\n+    logger.info(\"Patch domain {0} in namespace {1} with the secret {2}, and verify the result\",\n+        domainUid, domainNamespace, adminSecretName); \n+\n+    String restartVersion = patchDomainWithNewSecretAndVerify(\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        managedServerPrefix,\n+        replicaCount,\n+        adminSecretName);\n+\n+    logger.info(\"Wait for domain {0} admin server pod {1} in namespace {2} to be restarted\",\n+        domainUid, adminServerPodName, domainNamespace);\n+    checkPodRestarted(domainUid, domainNamespace, adminServerPodName, adminPodLastCreationTime);\n+    \n+    // check that the admin server pod's label has been updated with the new restartVersion\n+    checkPodRestartVersionUpdated(adminServerPodName, domainUid, domainNamespace, restartVersion);\n+    \n+    // check that the managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      final String podName = managedServerPrefix + i;\n+      final String lastCreationTime = msLastCreationTime.get(i - 1);\n+      logger.info(\"Wait for managed server pod {0} to be restarted in namespace {1}\",\n+          podName, domainNamespace);\n+      checkPodRestarted(domainUid, domainNamespace, podName, lastCreationTime);\n+      \n+      // check that the managed server pod's label has been updated with the new restartVersion\n+      checkPodRestartVersionUpdated(podName, domainUid, domainNamespace, restartVersion);\n+    }\n+ \n+    // check if the new credentials are valid and the old credentials are not valid any more\n+    logger.info(\"Check that after patching current credentials are not valid and new credentials are\");\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, INVALID);\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_PATCH, ADMIN_PASSWORD_PATCH, VALID);\n+    \n+    logger.info(\"Domain {0} in namespace {1} is fully started after changing WebLogic credentials secret\",\n+        domainUid, domainNamespace);\n+  }\n+\n+  /**\n+   * Patch the domain resource with a new WebLogic admin credentials secret.\n+   * \n+   * @param domainResourceName name of the domain resource\n+   * @param namespace Kubernetes namespace that the domain is hosted\n+   * @param secretName name of the new WebLogic admin credentials secret\n+   * @return restartVersion new restartVersion of the domain resource\n+   */\n+  private String patchDomainResourceWithNewAdminSecret(\n+      String domainResourceName,\n+      String namespace,\n+      String secretName\n+  ) {\n+    String patch = String.format(\n+        \"[\\n  {\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/%s\\\", \\\"value\\\": \\\"%s\\\"}\\n]\\n\",\n+            \"webLogicCredentialsSecret/name\", secretName);\n+    logger.info(\"Patch the domain resource {0} in namespace {1} with:{2}\\n\",\n+        domainResourceName, namespace, patch);\n+\n+    assertTrue(patchDomainCustomResource(\n+            domainResourceName,\n+            namespace,\n+            new V1Patch(patch),\n+            V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        String.format(\"Failed to patch the domain resource %s in namespace %s with %s:%s\",\n+            domainResourceName, namespace, \"/spec/webLogicCredentialsSecret/name\", secretName));\n+\n+    String oldVersion = assertDoesNotThrow(\n+        () -> getDomainCustomResource(domainResourceName, namespace).getSpec().getRestartVersion(),\n+        String.format(\"Failed to get the restartVersion of %s in namespace %s\", domainResourceName, namespace));\n+    int newVersion = oldVersion == null ? 1 : Integer.valueOf(oldVersion) + 1;\n+    logger.info(\"Update domain resource {0} in namespace {1} restartVersion from {2} to {3}\",\n+        domainResourceName, namespace, oldVersion, newVersion);\n+    patch =\n+        String.format(\"[\\n  {\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/restartVersion\\\", \\\"value\\\": \\\"%s\\\"}\\n]\\n\",\n+            newVersion);\n+    \n+    logger.info(\"Patch the domain resource {0} in namespace {1} with:{2}\\n\",\n+        domainResourceName, namespace, patch);\n+\n+    assertTrue(patchDomainCustomResource(\n+            domainResourceName,\n+            namespace,\n+            new V1Patch(patch),\n+            V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        String.format(\"Failed to patch the domain resource %s in namespace %s with startVersion:%s\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25b33e831acbcb76ad4c0af938dc431fc4f955ac"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcyOTkxNw==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1665#discussion_r428729917", "createdAt": "2020-05-21T15:31:36Z", "author": {"login": "doxiao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiChangeAdminCredentials.java", "diffHunk": "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsNotValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainResourceCredentialsSecretPatched;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podRestartVersionUpdated;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to change the WebLogic credentials secret of a domain custom resource that uses model-in-image.\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to patch the model-in-image image to change WebLogic admin credentials secret\")\n+@IntegrationTest\n+class ItMiiChangeAdminCredentials implements LoggedTest {\n+\n+  private static String domainNamespace = null;\n+  private static String domainUid = \"domain1\";\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static ConditionFactory withQuickRetryPolicy = null;\n+\n+  private static String adminServerPodName = String.format(\"%s-%s\", domainUid, ADMIN_SERVER_NAME_BASE);\n+  private static String managedServerPrefix = String.format(\"%s-%s\", domainUid, MANAGED_SERVER_NAME_BASE);\n+  private static int replicaCount = 2;\n+\n+  /**\n+   * Perform initialization for all the tests in this class.\n+   * Set up the necessary namespaces, install the operator in the first namespace, and\n+   * create a domain in the second namespace using the pre-created basic MII image.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(6, MINUTES).await();\n+\n+    // create quick, reusable retry/backoff policy\n+    withQuickRetryPolicy = with().pollDelay(0, SECONDS)\n+        .and().with().pollInterval(3, SECONDS)\n+        .atMost(12, SECONDS).await();\n+\n+    // get namespaces \n+    assertNotNull(namespaces.get(0), String.format(\"Namespace namespaces.get(0) is null\"));\n+    String opNamespace = namespaces.get(0);\n+\n+    assertNotNull(namespaces.get(1), String.format(\"Namespace namespaces.get(1) is null\"));\n+    domainNamespace = namespaces.get(1);\n+\n+    // install the operator\n+    logger.info(\"Install an operator in namespace {0}, managing namespace {1}\",\n+        opNamespace, domainNamespace); \n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+   \n+    // create a domain resource\n+    logger.info(\"Create model-in-image domain {0} in namespace {1}, and wait until it comes up\",\n+        domainUid, domainNamespace); \n+    createAndVerifyMiiDomain();\n+  }\n+  \n+  /**\n+   * Test patching a running model-in-image domain with a new WebLogic credentials secret.\n+   * Perform two patching operations to the domain spec: change the webLogicCredentialsSecret to a new\n+   * secret, and change the domainRestartVersion to trigger a rolling restart of the server pods.\n+   * Verify that the domain spec's webLogicCredentialsSecret and restartVersion are updated,\n+   * the server pods are recreated by checking each pod's creationTimestamp before and after patching,\n+   * the server pods' weblogic.domainRestartVersion label is updated, and \n+   * the new credentials are valid and can be used to access WebLogic RESTful Management Services.\n+   */\n+  @Test\n+  @DisplayName(\"Change the WebLogic credentials\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testChangeWebLogicCredentials() {\n+    final boolean VALID = true;\n+    final boolean INVALID = false;\n+\n+    // get the creation time of the admin server pod before patching\n+    String adminPodLastCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace,\"\",adminServerPodName),\n+        String.format(\"Failed to get creationTimestamp for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodLastCreationTime, \"creationTimestamp of the admin server pod is null\");\n+\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodLastCreationTime);\n+    \n+    List<String> msLastCreationTime = new ArrayList<String>();\n+    // get the creation time of the managed server pods before patching\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            msLastCreationTime.add(creationTime);\n+\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    \n+    logger.info(\"Check that before patching current credentials are valid and new credentials are not\");\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, VALID);\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_PATCH, ADMIN_PASSWORD_PATCH, INVALID);\n+    \n+    // create a new secret for admin credentials\n+    logger.info(\"Create a new secret that contains new WebLogic admin credentials\");\n+    String adminSecretName = \"weblogic-credentials-new\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(\n+        adminSecretName,\n+        domainNamespace,\n+        ADMIN_USERNAME_PATCH,\n+        ADMIN_PASSWORD_PATCH),\n+        String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // patch the domain resource with the new secret and verify that the domain resource is patched.\n+    logger.info(\"Patch domain {0} in namespace {1} with the secret {2}, and verify the result\",\n+        domainUid, domainNamespace, adminSecretName); \n+\n+    String restartVersion = patchDomainWithNewSecretAndVerify(\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        managedServerPrefix,\n+        replicaCount,\n+        adminSecretName);\n+\n+    logger.info(\"Wait for domain {0} admin server pod {1} in namespace {2} to be restarted\",\n+        domainUid, adminServerPodName, domainNamespace);\n+    checkPodRestarted(domainUid, domainNamespace, adminServerPodName, adminPodLastCreationTime);\n+    \n+    // check that the admin server pod's label has been updated with the new restartVersion\n+    checkPodRestartVersionUpdated(adminServerPodName, domainUid, domainNamespace, restartVersion);\n+    \n+    // check that the managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      final String podName = managedServerPrefix + i;\n+      final String lastCreationTime = msLastCreationTime.get(i - 1);\n+      logger.info(\"Wait for managed server pod {0} to be restarted in namespace {1}\",\n+          podName, domainNamespace);\n+      checkPodRestarted(domainUid, domainNamespace, podName, lastCreationTime);\n+      \n+      // check that the managed server pod's label has been updated with the new restartVersion\n+      checkPodRestartVersionUpdated(podName, domainUid, domainNamespace, restartVersion);\n+    }\n+ \n+    // check if the new credentials are valid and the old credentials are not valid any more\n+    logger.info(\"Check that after patching current credentials are not valid and new credentials are\");\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, INVALID);\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_PATCH, ADMIN_PASSWORD_PATCH, VALID);\n+    \n+    logger.info(\"Domain {0} in namespace {1} is fully started after changing WebLogic credentials secret\",\n+        domainUid, domainNamespace);\n+  }\n+\n+  /**\n+   * Patch the domain resource with a new WebLogic admin credentials secret.\n+   * \n+   * @param domainResourceName name of the domain resource\n+   * @param namespace Kubernetes namespace that the domain is hosted\n+   * @param secretName name of the new WebLogic admin credentials secret\n+   * @return restartVersion new restartVersion of the domain resource\n+   */\n+  private String patchDomainResourceWithNewAdminSecret(\n+      String domainResourceName,\n+      String namespace,\n+      String secretName\n+  ) {\n+    String patch = String.format(\n+        \"[\\n  {\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/%s\\\", \\\"value\\\": \\\"%s\\\"}\\n]\\n\",\n+            \"webLogicCredentialsSecret/name\", secretName);\n+    logger.info(\"Patch the domain resource {0} in namespace {1} with:{2}\\n\",\n+        domainResourceName, namespace, patch);\n+\n+    assertTrue(patchDomainCustomResource(\n+            domainResourceName,\n+            namespace,\n+            new V1Patch(patch),\n+            V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        String.format(\"Failed to patch the domain resource %s in namespace %s with %s:%s\",\n+            domainResourceName, namespace, \"/spec/webLogicCredentialsSecret/name\", secretName));\n+\n+    String oldVersion = assertDoesNotThrow(\n+        () -> getDomainCustomResource(domainResourceName, namespace).getSpec().getRestartVersion(),\n+        String.format(\"Failed to get the restartVersion of %s in namespace %s\", domainResourceName, namespace));\n+    int newVersion = oldVersion == null ? 1 : Integer.valueOf(oldVersion) + 1;\n+    logger.info(\"Update domain resource {0} in namespace {1} restartVersion from {2} to {3}\",\n+        domainResourceName, namespace, oldVersion, newVersion);\n+    patch =\n+        String.format(\"[\\n  {\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/restartVersion\\\", \\\"value\\\": \\\"%s\\\"}\\n]\\n\",\n+            newVersion);\n+    \n+    logger.info(\"Patch the domain resource {0} in namespace {1} with:{2}\\n\",\n+        domainResourceName, namespace, patch);\n+\n+    assertTrue(patchDomainCustomResource(\n+            domainResourceName,\n+            namespace,\n+            new V1Patch(patch),\n+            V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        String.format(\"Failed to patch the domain resource %s in namespace %s with startVersion:%s\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY4MjIxNA=="}, "originalCommit": {"oid": "25b33e831acbcb76ad4c0af938dc431fc4f955ac"}, "originalPosition": 265}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2OTgzODU5OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiChangeAdminCredentials.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNDoyMjoyMlrOGY0uuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNTozMTo0M1rOGY3mjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY4MjkzNg==", "bodyText": "Do we have shared methods for this now?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1665#discussion_r428682936", "createdAt": "2020-05-21T14:22:22Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiChangeAdminCredentials.java", "diffHunk": "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsNotValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainResourceCredentialsSecretPatched;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podRestartVersionUpdated;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to change the WebLogic credentials secret of a domain custom resource that uses model-in-image.\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to patch the model-in-image image to change WebLogic admin credentials secret\")\n+@IntegrationTest\n+class ItMiiChangeAdminCredentials implements LoggedTest {\n+\n+  private static String domainNamespace = null;\n+  private static String domainUid = \"domain1\";\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static ConditionFactory withQuickRetryPolicy = null;\n+\n+  private static String adminServerPodName = String.format(\"%s-%s\", domainUid, ADMIN_SERVER_NAME_BASE);\n+  private static String managedServerPrefix = String.format(\"%s-%s\", domainUid, MANAGED_SERVER_NAME_BASE);\n+  private static int replicaCount = 2;\n+\n+  /**\n+   * Perform initialization for all the tests in this class.\n+   * Set up the necessary namespaces, install the operator in the first namespace, and\n+   * create a domain in the second namespace using the pre-created basic MII image.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(6, MINUTES).await();\n+\n+    // create quick, reusable retry/backoff policy\n+    withQuickRetryPolicy = with().pollDelay(0, SECONDS)\n+        .and().with().pollInterval(3, SECONDS)\n+        .atMost(12, SECONDS).await();\n+\n+    // get namespaces \n+    assertNotNull(namespaces.get(0), String.format(\"Namespace namespaces.get(0) is null\"));\n+    String opNamespace = namespaces.get(0);\n+\n+    assertNotNull(namespaces.get(1), String.format(\"Namespace namespaces.get(1) is null\"));\n+    domainNamespace = namespaces.get(1);\n+\n+    // install the operator\n+    logger.info(\"Install an operator in namespace {0}, managing namespace {1}\",\n+        opNamespace, domainNamespace); \n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+   \n+    // create a domain resource\n+    logger.info(\"Create model-in-image domain {0} in namespace {1}, and wait until it comes up\",\n+        domainUid, domainNamespace); \n+    createAndVerifyMiiDomain();\n+  }\n+  \n+  /**\n+   * Test patching a running model-in-image domain with a new WebLogic credentials secret.\n+   * Perform two patching operations to the domain spec: change the webLogicCredentialsSecret to a new\n+   * secret, and change the domainRestartVersion to trigger a rolling restart of the server pods.\n+   * Verify that the domain spec's webLogicCredentialsSecret and restartVersion are updated,\n+   * the server pods are recreated by checking each pod's creationTimestamp before and after patching,\n+   * the server pods' weblogic.domainRestartVersion label is updated, and \n+   * the new credentials are valid and can be used to access WebLogic RESTful Management Services.\n+   */\n+  @Test\n+  @DisplayName(\"Change the WebLogic credentials\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testChangeWebLogicCredentials() {\n+    final boolean VALID = true;\n+    final boolean INVALID = false;\n+\n+    // get the creation time of the admin server pod before patching\n+    String adminPodLastCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace,\"\",adminServerPodName),\n+        String.format(\"Failed to get creationTimestamp for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodLastCreationTime, \"creationTimestamp of the admin server pod is null\");\n+\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodLastCreationTime);\n+    \n+    List<String> msLastCreationTime = new ArrayList<String>();\n+    // get the creation time of the managed server pods before patching\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            msLastCreationTime.add(creationTime);\n+\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    \n+    logger.info(\"Check that before patching current credentials are valid and new credentials are not\");\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, VALID);\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_PATCH, ADMIN_PASSWORD_PATCH, INVALID);\n+    \n+    // create a new secret for admin credentials\n+    logger.info(\"Create a new secret that contains new WebLogic admin credentials\");\n+    String adminSecretName = \"weblogic-credentials-new\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(\n+        adminSecretName,\n+        domainNamespace,\n+        ADMIN_USERNAME_PATCH,\n+        ADMIN_PASSWORD_PATCH),\n+        String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // patch the domain resource with the new secret and verify that the domain resource is patched.\n+    logger.info(\"Patch domain {0} in namespace {1} with the secret {2}, and verify the result\",\n+        domainUid, domainNamespace, adminSecretName); \n+\n+    String restartVersion = patchDomainWithNewSecretAndVerify(\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        managedServerPrefix,\n+        replicaCount,\n+        adminSecretName);\n+\n+    logger.info(\"Wait for domain {0} admin server pod {1} in namespace {2} to be restarted\",\n+        domainUid, adminServerPodName, domainNamespace);\n+    checkPodRestarted(domainUid, domainNamespace, adminServerPodName, adminPodLastCreationTime);\n+    \n+    // check that the admin server pod's label has been updated with the new restartVersion\n+    checkPodRestartVersionUpdated(adminServerPodName, domainUid, domainNamespace, restartVersion);\n+    \n+    // check that the managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      final String podName = managedServerPrefix + i;\n+      final String lastCreationTime = msLastCreationTime.get(i - 1);\n+      logger.info(\"Wait for managed server pod {0} to be restarted in namespace {1}\",\n+          podName, domainNamespace);\n+      checkPodRestarted(domainUid, domainNamespace, podName, lastCreationTime);\n+      \n+      // check that the managed server pod's label has been updated with the new restartVersion\n+      checkPodRestartVersionUpdated(podName, domainUid, domainNamespace, restartVersion);\n+    }\n+ \n+    // check if the new credentials are valid and the old credentials are not valid any more\n+    logger.info(\"Check that after patching current credentials are not valid and new credentials are\");\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, INVALID);\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_PATCH, ADMIN_PASSWORD_PATCH, VALID);\n+    \n+    logger.info(\"Domain {0} in namespace {1} is fully started after changing WebLogic credentials secret\",\n+        domainUid, domainNamespace);\n+  }\n+\n+  /**\n+   * Patch the domain resource with a new WebLogic admin credentials secret.\n+   * \n+   * @param domainResourceName name of the domain resource\n+   * @param namespace Kubernetes namespace that the domain is hosted\n+   * @param secretName name of the new WebLogic admin credentials secret\n+   * @return restartVersion new restartVersion of the domain resource\n+   */\n+  private String patchDomainResourceWithNewAdminSecret(\n+      String domainResourceName,\n+      String namespace,\n+      String secretName\n+  ) {\n+    String patch = String.format(\n+        \"[\\n  {\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/%s\\\", \\\"value\\\": \\\"%s\\\"}\\n]\\n\",\n+            \"webLogicCredentialsSecret/name\", secretName);\n+    logger.info(\"Patch the domain resource {0} in namespace {1} with:{2}\\n\",\n+        domainResourceName, namespace, patch);\n+\n+    assertTrue(patchDomainCustomResource(\n+            domainResourceName,\n+            namespace,\n+            new V1Patch(patch),\n+            V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        String.format(\"Failed to patch the domain resource %s in namespace %s with %s:%s\",\n+            domainResourceName, namespace, \"/spec/webLogicCredentialsSecret/name\", secretName));\n+\n+    String oldVersion = assertDoesNotThrow(\n+        () -> getDomainCustomResource(domainResourceName, namespace).getSpec().getRestartVersion(),\n+        String.format(\"Failed to get the restartVersion of %s in namespace %s\", domainResourceName, namespace));\n+    int newVersion = oldVersion == null ? 1 : Integer.valueOf(oldVersion) + 1;\n+    logger.info(\"Update domain resource {0} in namespace {1} restartVersion from {2} to {3}\",\n+        domainResourceName, namespace, oldVersion, newVersion);\n+    patch =\n+        String.format(\"[\\n  {\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/restartVersion\\\", \\\"value\\\": \\\"%s\\\"}\\n]\\n\",\n+            newVersion);\n+    \n+    logger.info(\"Patch the domain resource {0} in namespace {1} with:{2}\\n\",\n+        domainResourceName, namespace, patch);\n+\n+    assertTrue(patchDomainCustomResource(\n+            domainResourceName,\n+            namespace,\n+            new V1Patch(patch),\n+            V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        String.format(\"Failed to patch the domain resource %s in namespace %s with startVersion:%s\",\n+              domainResourceName, namespace, newVersion));\n+\n+    String updatedVersion = assertDoesNotThrow(\n+        () -> getDomainCustomResource(domainResourceName, namespace).getSpec().getRestartVersion(),\n+        String.format(\"Failed to get the restartVersion of %s in namespace %s\", domainResourceName, namespace));\n+    logger.info(\"Current restartVersion is {0}\", updatedVersion);\n+    assertTrue(updatedVersion.equals(String.valueOf(newVersion)),\n+        String.format(\"Failed to update the restartVersion of domain %s from %s to %s\",\n+            domainResourceName,\n+            oldVersion,\n+            newVersion));\n+    return String.valueOf(newVersion);\n+  }\n+\n+  /**\n+   * Create a domain object for a Kubernetes domain custom resource using the basic model-in-image image.\n+   * \n+   * @param domainResourceName name of the domain resource\n+   * @param domainNamespace Kubernetes namespace that the domain is hosted\n+   * @param adminSecretName name of the new WebLogic admin credentials secret\n+   * @param repoSecretName name of the secret for pulling the WebLogic image\n+   * @param encryptionSecretName name of the secret for encryption\n+   * @param replicaCount number of managed servers to start\n+   * @return domain of the domain resource\n+   */\n+  private static Domain createDomainResource(\n+      String domainResourceName, \n+      String domNamespace, \n+      String adminSecretName,\n+      String repoSecretName, \n+      String encryptionSecretName, \n+      int replicaCount) {\n+    // create the domain CR\n+    return new Domain()\n+            .apiVersion(DOMAIN_API_VERSION)\n+            .kind(\"Domain\")\n+            .metadata(new V1ObjectMeta()\n+                    .name(domainResourceName)\n+                    .namespace(domNamespace))\n+            .spec(new DomainSpec()\n+                    .domainUid(domainResourceName)\n+                    .domainHomeSourceType(\"FromModel\")\n+                    .image(MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG)\n+                    .addImagePullSecretsItem(new V1LocalObjectReference()\n+                            .name(repoSecretName))\n+                    .webLogicCredentialsSecret(new V1SecretReference()\n+                            .name(adminSecretName)\n+                            .namespace(domNamespace))\n+                    .includeServerOutInPodLog(true)\n+                    .serverStartPolicy(\"IF_NEEDED\")\n+                    .serverPod(new ServerPod()\n+                            .addEnvItem(new V1EnvVar()\n+                                    .name(\"JAVA_OPTIONS\")\n+                                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                            .addEnvItem(new V1EnvVar()\n+                                    .name(\"USER_MEM_ARGS\")\n+                                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+                    .adminServer(new AdminServer()\n+                            .serverStartState(\"RUNNING\")\n+                            .adminService(new AdminService()\n+                                    .addChannelsItem(new Channel()\n+                                            .channelName(\"default\")\n+                                            .nodePort(0))))\n+                    .addClustersItem(new Cluster()\n+                            .clusterName(\"cluster-1\")\n+                            .replicas(replicaCount)\n+                            .serverStartState(\"RUNNING\"))\n+                    .configuration(new Configuration()\n+                            .model(new Model()\n+                                    .domainType(\"WLS\")\n+                                    .runtimeEncryptionSecret(encryptionSecretName))\n+                        .introspectorJobActiveDeadlineSeconds(300L)));\n+\n+  }\n+  \n+  /**\n+   * Patch domain resource with a new WebLogic domain credentials secret and a new restartVersion,\n+   * and verify if the domain spec has been correctly updated.\n+   * \n+   * @param domainUid name of the domain resource\n+   * @param namespace Kubernetes namespace that the domain is hosted\n+   * @param adminServerPodName name of the WebLogic admin server\n+   * @param managedServerPrefix prefix of the managed servers\n+   * @param replicaCount number of managed servers to start\n+   * @param secretNmae name of the secret that is used to patch the domain resource\n+   * @return restartVersion of the domain resource\n+   */\n+  private String patchDomainWithNewSecretAndVerify(\n+      final String domainUid,\n+      final String namespace,\n+      final String adminServerPodName,\n+      final String managedServerPrefix,\n+      final int replicaCount,\n+      final String secretName\n+  ) {\n+    logger.info(\n+        \"Patch domain resource {0} in namespace {1} to use the new secret {2}\",\n+        domainUid, namespace, secretName);\n+\n+    String restartVersion = patchDomainResourceWithNewAdminSecret(domainUid, namespace, secretName);\n+    \n+    logger.info(\n+        \"Check that domain resource {0} in namespace {1} has been patched with new secret {2}\",\n+        domainUid, namespace, secretName);\n+    checkDomainCredentialsSecretPatched(domainUid, namespace, secretName);\n+\n+    // check and wait for the admin server pod to be patched with the new secret\n+    logger.info(\n+        \"Check that admin server pod for domain resource {0} in namespace {1} has been patched with {2}: {3}\",\n+        domainUid, namespace, \"/spec/webLogicCredentialsSecret/name\", secretName);\n+\n+    return restartVersion;\n+  }\n+\n+  /**\n+   * Check that domain resource has been updated with the new WebLogic domain credentials secret.\n+   * \n+   * @param domainUid name of the domain resource\n+   * @param namespace Kubernetes namespace that the domain is hosted\n+   * @param newValue new secret name for the WebLogic domain credentials secret\n+   */\n+  private void checkDomainCredentialsSecretPatched(\n+      String domainUid,\n+      String namespace,\n+      String newValue\n+  ) {\n+   \n+    // check if domain resource has been patched with the new secret\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            domainUid,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> domainResourceCredentialsSecretPatched(domainUid, namespace, newValue),\n+            String.format(\n+               \"Domain %s in namespace %s is not patched with admin credentials secret %s\",\n+               domainUid, namespace, newValue)));\n+\n+  }\n+  \n+  private void checkPodRestarted(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25b33e831acbcb76ad4c0af938dc431fc4f955ac"}, "originalPosition": 409}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY4NzE2MA==", "bodyText": "There is no such method in the common test util yet. Would you like me to move this method there?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1665#discussion_r428687160", "createdAt": "2020-05-21T14:29:00Z", "author": {"login": "doxiao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiChangeAdminCredentials.java", "diffHunk": "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsNotValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainResourceCredentialsSecretPatched;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podRestartVersionUpdated;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to change the WebLogic credentials secret of a domain custom resource that uses model-in-image.\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to patch the model-in-image image to change WebLogic admin credentials secret\")\n+@IntegrationTest\n+class ItMiiChangeAdminCredentials implements LoggedTest {\n+\n+  private static String domainNamespace = null;\n+  private static String domainUid = \"domain1\";\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static ConditionFactory withQuickRetryPolicy = null;\n+\n+  private static String adminServerPodName = String.format(\"%s-%s\", domainUid, ADMIN_SERVER_NAME_BASE);\n+  private static String managedServerPrefix = String.format(\"%s-%s\", domainUid, MANAGED_SERVER_NAME_BASE);\n+  private static int replicaCount = 2;\n+\n+  /**\n+   * Perform initialization for all the tests in this class.\n+   * Set up the necessary namespaces, install the operator in the first namespace, and\n+   * create a domain in the second namespace using the pre-created basic MII image.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(6, MINUTES).await();\n+\n+    // create quick, reusable retry/backoff policy\n+    withQuickRetryPolicy = with().pollDelay(0, SECONDS)\n+        .and().with().pollInterval(3, SECONDS)\n+        .atMost(12, SECONDS).await();\n+\n+    // get namespaces \n+    assertNotNull(namespaces.get(0), String.format(\"Namespace namespaces.get(0) is null\"));\n+    String opNamespace = namespaces.get(0);\n+\n+    assertNotNull(namespaces.get(1), String.format(\"Namespace namespaces.get(1) is null\"));\n+    domainNamespace = namespaces.get(1);\n+\n+    // install the operator\n+    logger.info(\"Install an operator in namespace {0}, managing namespace {1}\",\n+        opNamespace, domainNamespace); \n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+   \n+    // create a domain resource\n+    logger.info(\"Create model-in-image domain {0} in namespace {1}, and wait until it comes up\",\n+        domainUid, domainNamespace); \n+    createAndVerifyMiiDomain();\n+  }\n+  \n+  /**\n+   * Test patching a running model-in-image domain with a new WebLogic credentials secret.\n+   * Perform two patching operations to the domain spec: change the webLogicCredentialsSecret to a new\n+   * secret, and change the domainRestartVersion to trigger a rolling restart of the server pods.\n+   * Verify that the domain spec's webLogicCredentialsSecret and restartVersion are updated,\n+   * the server pods are recreated by checking each pod's creationTimestamp before and after patching,\n+   * the server pods' weblogic.domainRestartVersion label is updated, and \n+   * the new credentials are valid and can be used to access WebLogic RESTful Management Services.\n+   */\n+  @Test\n+  @DisplayName(\"Change the WebLogic credentials\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testChangeWebLogicCredentials() {\n+    final boolean VALID = true;\n+    final boolean INVALID = false;\n+\n+    // get the creation time of the admin server pod before patching\n+    String adminPodLastCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace,\"\",adminServerPodName),\n+        String.format(\"Failed to get creationTimestamp for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodLastCreationTime, \"creationTimestamp of the admin server pod is null\");\n+\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodLastCreationTime);\n+    \n+    List<String> msLastCreationTime = new ArrayList<String>();\n+    // get the creation time of the managed server pods before patching\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            msLastCreationTime.add(creationTime);\n+\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    \n+    logger.info(\"Check that before patching current credentials are valid and new credentials are not\");\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, VALID);\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_PATCH, ADMIN_PASSWORD_PATCH, INVALID);\n+    \n+    // create a new secret for admin credentials\n+    logger.info(\"Create a new secret that contains new WebLogic admin credentials\");\n+    String adminSecretName = \"weblogic-credentials-new\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(\n+        adminSecretName,\n+        domainNamespace,\n+        ADMIN_USERNAME_PATCH,\n+        ADMIN_PASSWORD_PATCH),\n+        String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // patch the domain resource with the new secret and verify that the domain resource is patched.\n+    logger.info(\"Patch domain {0} in namespace {1} with the secret {2}, and verify the result\",\n+        domainUid, domainNamespace, adminSecretName); \n+\n+    String restartVersion = patchDomainWithNewSecretAndVerify(\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        managedServerPrefix,\n+        replicaCount,\n+        adminSecretName);\n+\n+    logger.info(\"Wait for domain {0} admin server pod {1} in namespace {2} to be restarted\",\n+        domainUid, adminServerPodName, domainNamespace);\n+    checkPodRestarted(domainUid, domainNamespace, adminServerPodName, adminPodLastCreationTime);\n+    \n+    // check that the admin server pod's label has been updated with the new restartVersion\n+    checkPodRestartVersionUpdated(adminServerPodName, domainUid, domainNamespace, restartVersion);\n+    \n+    // check that the managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      final String podName = managedServerPrefix + i;\n+      final String lastCreationTime = msLastCreationTime.get(i - 1);\n+      logger.info(\"Wait for managed server pod {0} to be restarted in namespace {1}\",\n+          podName, domainNamespace);\n+      checkPodRestarted(domainUid, domainNamespace, podName, lastCreationTime);\n+      \n+      // check that the managed server pod's label has been updated with the new restartVersion\n+      checkPodRestartVersionUpdated(podName, domainUid, domainNamespace, restartVersion);\n+    }\n+ \n+    // check if the new credentials are valid and the old credentials are not valid any more\n+    logger.info(\"Check that after patching current credentials are not valid and new credentials are\");\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, INVALID);\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_PATCH, ADMIN_PASSWORD_PATCH, VALID);\n+    \n+    logger.info(\"Domain {0} in namespace {1} is fully started after changing WebLogic credentials secret\",\n+        domainUid, domainNamespace);\n+  }\n+\n+  /**\n+   * Patch the domain resource with a new WebLogic admin credentials secret.\n+   * \n+   * @param domainResourceName name of the domain resource\n+   * @param namespace Kubernetes namespace that the domain is hosted\n+   * @param secretName name of the new WebLogic admin credentials secret\n+   * @return restartVersion new restartVersion of the domain resource\n+   */\n+  private String patchDomainResourceWithNewAdminSecret(\n+      String domainResourceName,\n+      String namespace,\n+      String secretName\n+  ) {\n+    String patch = String.format(\n+        \"[\\n  {\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/%s\\\", \\\"value\\\": \\\"%s\\\"}\\n]\\n\",\n+            \"webLogicCredentialsSecret/name\", secretName);\n+    logger.info(\"Patch the domain resource {0} in namespace {1} with:{2}\\n\",\n+        domainResourceName, namespace, patch);\n+\n+    assertTrue(patchDomainCustomResource(\n+            domainResourceName,\n+            namespace,\n+            new V1Patch(patch),\n+            V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        String.format(\"Failed to patch the domain resource %s in namespace %s with %s:%s\",\n+            domainResourceName, namespace, \"/spec/webLogicCredentialsSecret/name\", secretName));\n+\n+    String oldVersion = assertDoesNotThrow(\n+        () -> getDomainCustomResource(domainResourceName, namespace).getSpec().getRestartVersion(),\n+        String.format(\"Failed to get the restartVersion of %s in namespace %s\", domainResourceName, namespace));\n+    int newVersion = oldVersion == null ? 1 : Integer.valueOf(oldVersion) + 1;\n+    logger.info(\"Update domain resource {0} in namespace {1} restartVersion from {2} to {3}\",\n+        domainResourceName, namespace, oldVersion, newVersion);\n+    patch =\n+        String.format(\"[\\n  {\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/restartVersion\\\", \\\"value\\\": \\\"%s\\\"}\\n]\\n\",\n+            newVersion);\n+    \n+    logger.info(\"Patch the domain resource {0} in namespace {1} with:{2}\\n\",\n+        domainResourceName, namespace, patch);\n+\n+    assertTrue(patchDomainCustomResource(\n+            domainResourceName,\n+            namespace,\n+            new V1Patch(patch),\n+            V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        String.format(\"Failed to patch the domain resource %s in namespace %s with startVersion:%s\",\n+              domainResourceName, namespace, newVersion));\n+\n+    String updatedVersion = assertDoesNotThrow(\n+        () -> getDomainCustomResource(domainResourceName, namespace).getSpec().getRestartVersion(),\n+        String.format(\"Failed to get the restartVersion of %s in namespace %s\", domainResourceName, namespace));\n+    logger.info(\"Current restartVersion is {0}\", updatedVersion);\n+    assertTrue(updatedVersion.equals(String.valueOf(newVersion)),\n+        String.format(\"Failed to update the restartVersion of domain %s from %s to %s\",\n+            domainResourceName,\n+            oldVersion,\n+            newVersion));\n+    return String.valueOf(newVersion);\n+  }\n+\n+  /**\n+   * Create a domain object for a Kubernetes domain custom resource using the basic model-in-image image.\n+   * \n+   * @param domainResourceName name of the domain resource\n+   * @param domainNamespace Kubernetes namespace that the domain is hosted\n+   * @param adminSecretName name of the new WebLogic admin credentials secret\n+   * @param repoSecretName name of the secret for pulling the WebLogic image\n+   * @param encryptionSecretName name of the secret for encryption\n+   * @param replicaCount number of managed servers to start\n+   * @return domain of the domain resource\n+   */\n+  private static Domain createDomainResource(\n+      String domainResourceName, \n+      String domNamespace, \n+      String adminSecretName,\n+      String repoSecretName, \n+      String encryptionSecretName, \n+      int replicaCount) {\n+    // create the domain CR\n+    return new Domain()\n+            .apiVersion(DOMAIN_API_VERSION)\n+            .kind(\"Domain\")\n+            .metadata(new V1ObjectMeta()\n+                    .name(domainResourceName)\n+                    .namespace(domNamespace))\n+            .spec(new DomainSpec()\n+                    .domainUid(domainResourceName)\n+                    .domainHomeSourceType(\"FromModel\")\n+                    .image(MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG)\n+                    .addImagePullSecretsItem(new V1LocalObjectReference()\n+                            .name(repoSecretName))\n+                    .webLogicCredentialsSecret(new V1SecretReference()\n+                            .name(adminSecretName)\n+                            .namespace(domNamespace))\n+                    .includeServerOutInPodLog(true)\n+                    .serverStartPolicy(\"IF_NEEDED\")\n+                    .serverPod(new ServerPod()\n+                            .addEnvItem(new V1EnvVar()\n+                                    .name(\"JAVA_OPTIONS\")\n+                                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                            .addEnvItem(new V1EnvVar()\n+                                    .name(\"USER_MEM_ARGS\")\n+                                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+                    .adminServer(new AdminServer()\n+                            .serverStartState(\"RUNNING\")\n+                            .adminService(new AdminService()\n+                                    .addChannelsItem(new Channel()\n+                                            .channelName(\"default\")\n+                                            .nodePort(0))))\n+                    .addClustersItem(new Cluster()\n+                            .clusterName(\"cluster-1\")\n+                            .replicas(replicaCount)\n+                            .serverStartState(\"RUNNING\"))\n+                    .configuration(new Configuration()\n+                            .model(new Model()\n+                                    .domainType(\"WLS\")\n+                                    .runtimeEncryptionSecret(encryptionSecretName))\n+                        .introspectorJobActiveDeadlineSeconds(300L)));\n+\n+  }\n+  \n+  /**\n+   * Patch domain resource with a new WebLogic domain credentials secret and a new restartVersion,\n+   * and verify if the domain spec has been correctly updated.\n+   * \n+   * @param domainUid name of the domain resource\n+   * @param namespace Kubernetes namespace that the domain is hosted\n+   * @param adminServerPodName name of the WebLogic admin server\n+   * @param managedServerPrefix prefix of the managed servers\n+   * @param replicaCount number of managed servers to start\n+   * @param secretNmae name of the secret that is used to patch the domain resource\n+   * @return restartVersion of the domain resource\n+   */\n+  private String patchDomainWithNewSecretAndVerify(\n+      final String domainUid,\n+      final String namespace,\n+      final String adminServerPodName,\n+      final String managedServerPrefix,\n+      final int replicaCount,\n+      final String secretName\n+  ) {\n+    logger.info(\n+        \"Patch domain resource {0} in namespace {1} to use the new secret {2}\",\n+        domainUid, namespace, secretName);\n+\n+    String restartVersion = patchDomainResourceWithNewAdminSecret(domainUid, namespace, secretName);\n+    \n+    logger.info(\n+        \"Check that domain resource {0} in namespace {1} has been patched with new secret {2}\",\n+        domainUid, namespace, secretName);\n+    checkDomainCredentialsSecretPatched(domainUid, namespace, secretName);\n+\n+    // check and wait for the admin server pod to be patched with the new secret\n+    logger.info(\n+        \"Check that admin server pod for domain resource {0} in namespace {1} has been patched with {2}: {3}\",\n+        domainUid, namespace, \"/spec/webLogicCredentialsSecret/name\", secretName);\n+\n+    return restartVersion;\n+  }\n+\n+  /**\n+   * Check that domain resource has been updated with the new WebLogic domain credentials secret.\n+   * \n+   * @param domainUid name of the domain resource\n+   * @param namespace Kubernetes namespace that the domain is hosted\n+   * @param newValue new secret name for the WebLogic domain credentials secret\n+   */\n+  private void checkDomainCredentialsSecretPatched(\n+      String domainUid,\n+      String namespace,\n+      String newValue\n+  ) {\n+   \n+    // check if domain resource has been patched with the new secret\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            domainUid,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> domainResourceCredentialsSecretPatched(domainUid, namespace, newValue),\n+            String.format(\n+               \"Domain %s in namespace %s is not patched with admin credentials secret %s\",\n+               domainUid, namespace, newValue)));\n+\n+  }\n+  \n+  private void checkPodRestarted(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY4MjkzNg=="}, "originalCommit": {"oid": "25b33e831acbcb76ad4c0af938dc431fc4f955ac"}, "originalPosition": 409}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY5MTI5Ng==", "bodyText": "If you are asking the underlying method, then yes, it shares the same TestAssertions method isPodRestarted with other test classes, for example, ItMiiConfigMapOverride.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1665#discussion_r428691296", "createdAt": "2020-05-21T14:35:52Z", "author": {"login": "doxiao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiChangeAdminCredentials.java", "diffHunk": "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsNotValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainResourceCredentialsSecretPatched;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podRestartVersionUpdated;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to change the WebLogic credentials secret of a domain custom resource that uses model-in-image.\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to patch the model-in-image image to change WebLogic admin credentials secret\")\n+@IntegrationTest\n+class ItMiiChangeAdminCredentials implements LoggedTest {\n+\n+  private static String domainNamespace = null;\n+  private static String domainUid = \"domain1\";\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static ConditionFactory withQuickRetryPolicy = null;\n+\n+  private static String adminServerPodName = String.format(\"%s-%s\", domainUid, ADMIN_SERVER_NAME_BASE);\n+  private static String managedServerPrefix = String.format(\"%s-%s\", domainUid, MANAGED_SERVER_NAME_BASE);\n+  private static int replicaCount = 2;\n+\n+  /**\n+   * Perform initialization for all the tests in this class.\n+   * Set up the necessary namespaces, install the operator in the first namespace, and\n+   * create a domain in the second namespace using the pre-created basic MII image.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(6, MINUTES).await();\n+\n+    // create quick, reusable retry/backoff policy\n+    withQuickRetryPolicy = with().pollDelay(0, SECONDS)\n+        .and().with().pollInterval(3, SECONDS)\n+        .atMost(12, SECONDS).await();\n+\n+    // get namespaces \n+    assertNotNull(namespaces.get(0), String.format(\"Namespace namespaces.get(0) is null\"));\n+    String opNamespace = namespaces.get(0);\n+\n+    assertNotNull(namespaces.get(1), String.format(\"Namespace namespaces.get(1) is null\"));\n+    domainNamespace = namespaces.get(1);\n+\n+    // install the operator\n+    logger.info(\"Install an operator in namespace {0}, managing namespace {1}\",\n+        opNamespace, domainNamespace); \n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+   \n+    // create a domain resource\n+    logger.info(\"Create model-in-image domain {0} in namespace {1}, and wait until it comes up\",\n+        domainUid, domainNamespace); \n+    createAndVerifyMiiDomain();\n+  }\n+  \n+  /**\n+   * Test patching a running model-in-image domain with a new WebLogic credentials secret.\n+   * Perform two patching operations to the domain spec: change the webLogicCredentialsSecret to a new\n+   * secret, and change the domainRestartVersion to trigger a rolling restart of the server pods.\n+   * Verify that the domain spec's webLogicCredentialsSecret and restartVersion are updated,\n+   * the server pods are recreated by checking each pod's creationTimestamp before and after patching,\n+   * the server pods' weblogic.domainRestartVersion label is updated, and \n+   * the new credentials are valid and can be used to access WebLogic RESTful Management Services.\n+   */\n+  @Test\n+  @DisplayName(\"Change the WebLogic credentials\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testChangeWebLogicCredentials() {\n+    final boolean VALID = true;\n+    final boolean INVALID = false;\n+\n+    // get the creation time of the admin server pod before patching\n+    String adminPodLastCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace,\"\",adminServerPodName),\n+        String.format(\"Failed to get creationTimestamp for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodLastCreationTime, \"creationTimestamp of the admin server pod is null\");\n+\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodLastCreationTime);\n+    \n+    List<String> msLastCreationTime = new ArrayList<String>();\n+    // get the creation time of the managed server pods before patching\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            msLastCreationTime.add(creationTime);\n+\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    \n+    logger.info(\"Check that before patching current credentials are valid and new credentials are not\");\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, VALID);\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_PATCH, ADMIN_PASSWORD_PATCH, INVALID);\n+    \n+    // create a new secret for admin credentials\n+    logger.info(\"Create a new secret that contains new WebLogic admin credentials\");\n+    String adminSecretName = \"weblogic-credentials-new\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(\n+        adminSecretName,\n+        domainNamespace,\n+        ADMIN_USERNAME_PATCH,\n+        ADMIN_PASSWORD_PATCH),\n+        String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // patch the domain resource with the new secret and verify that the domain resource is patched.\n+    logger.info(\"Patch domain {0} in namespace {1} with the secret {2}, and verify the result\",\n+        domainUid, domainNamespace, adminSecretName); \n+\n+    String restartVersion = patchDomainWithNewSecretAndVerify(\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        managedServerPrefix,\n+        replicaCount,\n+        adminSecretName);\n+\n+    logger.info(\"Wait for domain {0} admin server pod {1} in namespace {2} to be restarted\",\n+        domainUid, adminServerPodName, domainNamespace);\n+    checkPodRestarted(domainUid, domainNamespace, adminServerPodName, adminPodLastCreationTime);\n+    \n+    // check that the admin server pod's label has been updated with the new restartVersion\n+    checkPodRestartVersionUpdated(adminServerPodName, domainUid, domainNamespace, restartVersion);\n+    \n+    // check that the managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      final String podName = managedServerPrefix + i;\n+      final String lastCreationTime = msLastCreationTime.get(i - 1);\n+      logger.info(\"Wait for managed server pod {0} to be restarted in namespace {1}\",\n+          podName, domainNamespace);\n+      checkPodRestarted(domainUid, domainNamespace, podName, lastCreationTime);\n+      \n+      // check that the managed server pod's label has been updated with the new restartVersion\n+      checkPodRestartVersionUpdated(podName, domainUid, domainNamespace, restartVersion);\n+    }\n+ \n+    // check if the new credentials are valid and the old credentials are not valid any more\n+    logger.info(\"Check that after patching current credentials are not valid and new credentials are\");\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, INVALID);\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_PATCH, ADMIN_PASSWORD_PATCH, VALID);\n+    \n+    logger.info(\"Domain {0} in namespace {1} is fully started after changing WebLogic credentials secret\",\n+        domainUid, domainNamespace);\n+  }\n+\n+  /**\n+   * Patch the domain resource with a new WebLogic admin credentials secret.\n+   * \n+   * @param domainResourceName name of the domain resource\n+   * @param namespace Kubernetes namespace that the domain is hosted\n+   * @param secretName name of the new WebLogic admin credentials secret\n+   * @return restartVersion new restartVersion of the domain resource\n+   */\n+  private String patchDomainResourceWithNewAdminSecret(\n+      String domainResourceName,\n+      String namespace,\n+      String secretName\n+  ) {\n+    String patch = String.format(\n+        \"[\\n  {\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/%s\\\", \\\"value\\\": \\\"%s\\\"}\\n]\\n\",\n+            \"webLogicCredentialsSecret/name\", secretName);\n+    logger.info(\"Patch the domain resource {0} in namespace {1} with:{2}\\n\",\n+        domainResourceName, namespace, patch);\n+\n+    assertTrue(patchDomainCustomResource(\n+            domainResourceName,\n+            namespace,\n+            new V1Patch(patch),\n+            V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        String.format(\"Failed to patch the domain resource %s in namespace %s with %s:%s\",\n+            domainResourceName, namespace, \"/spec/webLogicCredentialsSecret/name\", secretName));\n+\n+    String oldVersion = assertDoesNotThrow(\n+        () -> getDomainCustomResource(domainResourceName, namespace).getSpec().getRestartVersion(),\n+        String.format(\"Failed to get the restartVersion of %s in namespace %s\", domainResourceName, namespace));\n+    int newVersion = oldVersion == null ? 1 : Integer.valueOf(oldVersion) + 1;\n+    logger.info(\"Update domain resource {0} in namespace {1} restartVersion from {2} to {3}\",\n+        domainResourceName, namespace, oldVersion, newVersion);\n+    patch =\n+        String.format(\"[\\n  {\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/restartVersion\\\", \\\"value\\\": \\\"%s\\\"}\\n]\\n\",\n+            newVersion);\n+    \n+    logger.info(\"Patch the domain resource {0} in namespace {1} with:{2}\\n\",\n+        domainResourceName, namespace, patch);\n+\n+    assertTrue(patchDomainCustomResource(\n+            domainResourceName,\n+            namespace,\n+            new V1Patch(patch),\n+            V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        String.format(\"Failed to patch the domain resource %s in namespace %s with startVersion:%s\",\n+              domainResourceName, namespace, newVersion));\n+\n+    String updatedVersion = assertDoesNotThrow(\n+        () -> getDomainCustomResource(domainResourceName, namespace).getSpec().getRestartVersion(),\n+        String.format(\"Failed to get the restartVersion of %s in namespace %s\", domainResourceName, namespace));\n+    logger.info(\"Current restartVersion is {0}\", updatedVersion);\n+    assertTrue(updatedVersion.equals(String.valueOf(newVersion)),\n+        String.format(\"Failed to update the restartVersion of domain %s from %s to %s\",\n+            domainResourceName,\n+            oldVersion,\n+            newVersion));\n+    return String.valueOf(newVersion);\n+  }\n+\n+  /**\n+   * Create a domain object for a Kubernetes domain custom resource using the basic model-in-image image.\n+   * \n+   * @param domainResourceName name of the domain resource\n+   * @param domainNamespace Kubernetes namespace that the domain is hosted\n+   * @param adminSecretName name of the new WebLogic admin credentials secret\n+   * @param repoSecretName name of the secret for pulling the WebLogic image\n+   * @param encryptionSecretName name of the secret for encryption\n+   * @param replicaCount number of managed servers to start\n+   * @return domain of the domain resource\n+   */\n+  private static Domain createDomainResource(\n+      String domainResourceName, \n+      String domNamespace, \n+      String adminSecretName,\n+      String repoSecretName, \n+      String encryptionSecretName, \n+      int replicaCount) {\n+    // create the domain CR\n+    return new Domain()\n+            .apiVersion(DOMAIN_API_VERSION)\n+            .kind(\"Domain\")\n+            .metadata(new V1ObjectMeta()\n+                    .name(domainResourceName)\n+                    .namespace(domNamespace))\n+            .spec(new DomainSpec()\n+                    .domainUid(domainResourceName)\n+                    .domainHomeSourceType(\"FromModel\")\n+                    .image(MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG)\n+                    .addImagePullSecretsItem(new V1LocalObjectReference()\n+                            .name(repoSecretName))\n+                    .webLogicCredentialsSecret(new V1SecretReference()\n+                            .name(adminSecretName)\n+                            .namespace(domNamespace))\n+                    .includeServerOutInPodLog(true)\n+                    .serverStartPolicy(\"IF_NEEDED\")\n+                    .serverPod(new ServerPod()\n+                            .addEnvItem(new V1EnvVar()\n+                                    .name(\"JAVA_OPTIONS\")\n+                                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                            .addEnvItem(new V1EnvVar()\n+                                    .name(\"USER_MEM_ARGS\")\n+                                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+                    .adminServer(new AdminServer()\n+                            .serverStartState(\"RUNNING\")\n+                            .adminService(new AdminService()\n+                                    .addChannelsItem(new Channel()\n+                                            .channelName(\"default\")\n+                                            .nodePort(0))))\n+                    .addClustersItem(new Cluster()\n+                            .clusterName(\"cluster-1\")\n+                            .replicas(replicaCount)\n+                            .serverStartState(\"RUNNING\"))\n+                    .configuration(new Configuration()\n+                            .model(new Model()\n+                                    .domainType(\"WLS\")\n+                                    .runtimeEncryptionSecret(encryptionSecretName))\n+                        .introspectorJobActiveDeadlineSeconds(300L)));\n+\n+  }\n+  \n+  /**\n+   * Patch domain resource with a new WebLogic domain credentials secret and a new restartVersion,\n+   * and verify if the domain spec has been correctly updated.\n+   * \n+   * @param domainUid name of the domain resource\n+   * @param namespace Kubernetes namespace that the domain is hosted\n+   * @param adminServerPodName name of the WebLogic admin server\n+   * @param managedServerPrefix prefix of the managed servers\n+   * @param replicaCount number of managed servers to start\n+   * @param secretNmae name of the secret that is used to patch the domain resource\n+   * @return restartVersion of the domain resource\n+   */\n+  private String patchDomainWithNewSecretAndVerify(\n+      final String domainUid,\n+      final String namespace,\n+      final String adminServerPodName,\n+      final String managedServerPrefix,\n+      final int replicaCount,\n+      final String secretName\n+  ) {\n+    logger.info(\n+        \"Patch domain resource {0} in namespace {1} to use the new secret {2}\",\n+        domainUid, namespace, secretName);\n+\n+    String restartVersion = patchDomainResourceWithNewAdminSecret(domainUid, namespace, secretName);\n+    \n+    logger.info(\n+        \"Check that domain resource {0} in namespace {1} has been patched with new secret {2}\",\n+        domainUid, namespace, secretName);\n+    checkDomainCredentialsSecretPatched(domainUid, namespace, secretName);\n+\n+    // check and wait for the admin server pod to be patched with the new secret\n+    logger.info(\n+        \"Check that admin server pod for domain resource {0} in namespace {1} has been patched with {2}: {3}\",\n+        domainUid, namespace, \"/spec/webLogicCredentialsSecret/name\", secretName);\n+\n+    return restartVersion;\n+  }\n+\n+  /**\n+   * Check that domain resource has been updated with the new WebLogic domain credentials secret.\n+   * \n+   * @param domainUid name of the domain resource\n+   * @param namespace Kubernetes namespace that the domain is hosted\n+   * @param newValue new secret name for the WebLogic domain credentials secret\n+   */\n+  private void checkDomainCredentialsSecretPatched(\n+      String domainUid,\n+      String namespace,\n+      String newValue\n+  ) {\n+   \n+    // check if domain resource has been patched with the new secret\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            domainUid,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> domainResourceCredentialsSecretPatched(domainUid, namespace, newValue),\n+            String.format(\n+               \"Domain %s in namespace %s is not patched with admin credentials secret %s\",\n+               domainUid, namespace, newValue)));\n+\n+  }\n+  \n+  private void checkPodRestarted(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY4MjkzNg=="}, "originalCommit": {"oid": "25b33e831acbcb76ad4c0af938dc431fc4f955ac"}, "originalPosition": 409}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcxMDMyOQ==", "bodyText": "I'll move this to CommonTestUtils class.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1665#discussion_r428710329", "createdAt": "2020-05-21T15:01:04Z", "author": {"login": "doxiao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiChangeAdminCredentials.java", "diffHunk": "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsNotValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainResourceCredentialsSecretPatched;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podRestartVersionUpdated;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to change the WebLogic credentials secret of a domain custom resource that uses model-in-image.\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to patch the model-in-image image to change WebLogic admin credentials secret\")\n+@IntegrationTest\n+class ItMiiChangeAdminCredentials implements LoggedTest {\n+\n+  private static String domainNamespace = null;\n+  private static String domainUid = \"domain1\";\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static ConditionFactory withQuickRetryPolicy = null;\n+\n+  private static String adminServerPodName = String.format(\"%s-%s\", domainUid, ADMIN_SERVER_NAME_BASE);\n+  private static String managedServerPrefix = String.format(\"%s-%s\", domainUid, MANAGED_SERVER_NAME_BASE);\n+  private static int replicaCount = 2;\n+\n+  /**\n+   * Perform initialization for all the tests in this class.\n+   * Set up the necessary namespaces, install the operator in the first namespace, and\n+   * create a domain in the second namespace using the pre-created basic MII image.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(6, MINUTES).await();\n+\n+    // create quick, reusable retry/backoff policy\n+    withQuickRetryPolicy = with().pollDelay(0, SECONDS)\n+        .and().with().pollInterval(3, SECONDS)\n+        .atMost(12, SECONDS).await();\n+\n+    // get namespaces \n+    assertNotNull(namespaces.get(0), String.format(\"Namespace namespaces.get(0) is null\"));\n+    String opNamespace = namespaces.get(0);\n+\n+    assertNotNull(namespaces.get(1), String.format(\"Namespace namespaces.get(1) is null\"));\n+    domainNamespace = namespaces.get(1);\n+\n+    // install the operator\n+    logger.info(\"Install an operator in namespace {0}, managing namespace {1}\",\n+        opNamespace, domainNamespace); \n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+   \n+    // create a domain resource\n+    logger.info(\"Create model-in-image domain {0} in namespace {1}, and wait until it comes up\",\n+        domainUid, domainNamespace); \n+    createAndVerifyMiiDomain();\n+  }\n+  \n+  /**\n+   * Test patching a running model-in-image domain with a new WebLogic credentials secret.\n+   * Perform two patching operations to the domain spec: change the webLogicCredentialsSecret to a new\n+   * secret, and change the domainRestartVersion to trigger a rolling restart of the server pods.\n+   * Verify that the domain spec's webLogicCredentialsSecret and restartVersion are updated,\n+   * the server pods are recreated by checking each pod's creationTimestamp before and after patching,\n+   * the server pods' weblogic.domainRestartVersion label is updated, and \n+   * the new credentials are valid and can be used to access WebLogic RESTful Management Services.\n+   */\n+  @Test\n+  @DisplayName(\"Change the WebLogic credentials\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testChangeWebLogicCredentials() {\n+    final boolean VALID = true;\n+    final boolean INVALID = false;\n+\n+    // get the creation time of the admin server pod before patching\n+    String adminPodLastCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace,\"\",adminServerPodName),\n+        String.format(\"Failed to get creationTimestamp for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodLastCreationTime, \"creationTimestamp of the admin server pod is null\");\n+\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodLastCreationTime);\n+    \n+    List<String> msLastCreationTime = new ArrayList<String>();\n+    // get the creation time of the managed server pods before patching\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            msLastCreationTime.add(creationTime);\n+\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    \n+    logger.info(\"Check that before patching current credentials are valid and new credentials are not\");\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, VALID);\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_PATCH, ADMIN_PASSWORD_PATCH, INVALID);\n+    \n+    // create a new secret for admin credentials\n+    logger.info(\"Create a new secret that contains new WebLogic admin credentials\");\n+    String adminSecretName = \"weblogic-credentials-new\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(\n+        adminSecretName,\n+        domainNamespace,\n+        ADMIN_USERNAME_PATCH,\n+        ADMIN_PASSWORD_PATCH),\n+        String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // patch the domain resource with the new secret and verify that the domain resource is patched.\n+    logger.info(\"Patch domain {0} in namespace {1} with the secret {2}, and verify the result\",\n+        domainUid, domainNamespace, adminSecretName); \n+\n+    String restartVersion = patchDomainWithNewSecretAndVerify(\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        managedServerPrefix,\n+        replicaCount,\n+        adminSecretName);\n+\n+    logger.info(\"Wait for domain {0} admin server pod {1} in namespace {2} to be restarted\",\n+        domainUid, adminServerPodName, domainNamespace);\n+    checkPodRestarted(domainUid, domainNamespace, adminServerPodName, adminPodLastCreationTime);\n+    \n+    // check that the admin server pod's label has been updated with the new restartVersion\n+    checkPodRestartVersionUpdated(adminServerPodName, domainUid, domainNamespace, restartVersion);\n+    \n+    // check that the managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      final String podName = managedServerPrefix + i;\n+      final String lastCreationTime = msLastCreationTime.get(i - 1);\n+      logger.info(\"Wait for managed server pod {0} to be restarted in namespace {1}\",\n+          podName, domainNamespace);\n+      checkPodRestarted(domainUid, domainNamespace, podName, lastCreationTime);\n+      \n+      // check that the managed server pod's label has been updated with the new restartVersion\n+      checkPodRestartVersionUpdated(podName, domainUid, domainNamespace, restartVersion);\n+    }\n+ \n+    // check if the new credentials are valid and the old credentials are not valid any more\n+    logger.info(\"Check that after patching current credentials are not valid and new credentials are\");\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, INVALID);\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_PATCH, ADMIN_PASSWORD_PATCH, VALID);\n+    \n+    logger.info(\"Domain {0} in namespace {1} is fully started after changing WebLogic credentials secret\",\n+        domainUid, domainNamespace);\n+  }\n+\n+  /**\n+   * Patch the domain resource with a new WebLogic admin credentials secret.\n+   * \n+   * @param domainResourceName name of the domain resource\n+   * @param namespace Kubernetes namespace that the domain is hosted\n+   * @param secretName name of the new WebLogic admin credentials secret\n+   * @return restartVersion new restartVersion of the domain resource\n+   */\n+  private String patchDomainResourceWithNewAdminSecret(\n+      String domainResourceName,\n+      String namespace,\n+      String secretName\n+  ) {\n+    String patch = String.format(\n+        \"[\\n  {\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/%s\\\", \\\"value\\\": \\\"%s\\\"}\\n]\\n\",\n+            \"webLogicCredentialsSecret/name\", secretName);\n+    logger.info(\"Patch the domain resource {0} in namespace {1} with:{2}\\n\",\n+        domainResourceName, namespace, patch);\n+\n+    assertTrue(patchDomainCustomResource(\n+            domainResourceName,\n+            namespace,\n+            new V1Patch(patch),\n+            V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        String.format(\"Failed to patch the domain resource %s in namespace %s with %s:%s\",\n+            domainResourceName, namespace, \"/spec/webLogicCredentialsSecret/name\", secretName));\n+\n+    String oldVersion = assertDoesNotThrow(\n+        () -> getDomainCustomResource(domainResourceName, namespace).getSpec().getRestartVersion(),\n+        String.format(\"Failed to get the restartVersion of %s in namespace %s\", domainResourceName, namespace));\n+    int newVersion = oldVersion == null ? 1 : Integer.valueOf(oldVersion) + 1;\n+    logger.info(\"Update domain resource {0} in namespace {1} restartVersion from {2} to {3}\",\n+        domainResourceName, namespace, oldVersion, newVersion);\n+    patch =\n+        String.format(\"[\\n  {\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/restartVersion\\\", \\\"value\\\": \\\"%s\\\"}\\n]\\n\",\n+            newVersion);\n+    \n+    logger.info(\"Patch the domain resource {0} in namespace {1} with:{2}\\n\",\n+        domainResourceName, namespace, patch);\n+\n+    assertTrue(patchDomainCustomResource(\n+            domainResourceName,\n+            namespace,\n+            new V1Patch(patch),\n+            V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        String.format(\"Failed to patch the domain resource %s in namespace %s with startVersion:%s\",\n+              domainResourceName, namespace, newVersion));\n+\n+    String updatedVersion = assertDoesNotThrow(\n+        () -> getDomainCustomResource(domainResourceName, namespace).getSpec().getRestartVersion(),\n+        String.format(\"Failed to get the restartVersion of %s in namespace %s\", domainResourceName, namespace));\n+    logger.info(\"Current restartVersion is {0}\", updatedVersion);\n+    assertTrue(updatedVersion.equals(String.valueOf(newVersion)),\n+        String.format(\"Failed to update the restartVersion of domain %s from %s to %s\",\n+            domainResourceName,\n+            oldVersion,\n+            newVersion));\n+    return String.valueOf(newVersion);\n+  }\n+\n+  /**\n+   * Create a domain object for a Kubernetes domain custom resource using the basic model-in-image image.\n+   * \n+   * @param domainResourceName name of the domain resource\n+   * @param domainNamespace Kubernetes namespace that the domain is hosted\n+   * @param adminSecretName name of the new WebLogic admin credentials secret\n+   * @param repoSecretName name of the secret for pulling the WebLogic image\n+   * @param encryptionSecretName name of the secret for encryption\n+   * @param replicaCount number of managed servers to start\n+   * @return domain of the domain resource\n+   */\n+  private static Domain createDomainResource(\n+      String domainResourceName, \n+      String domNamespace, \n+      String adminSecretName,\n+      String repoSecretName, \n+      String encryptionSecretName, \n+      int replicaCount) {\n+    // create the domain CR\n+    return new Domain()\n+            .apiVersion(DOMAIN_API_VERSION)\n+            .kind(\"Domain\")\n+            .metadata(new V1ObjectMeta()\n+                    .name(domainResourceName)\n+                    .namespace(domNamespace))\n+            .spec(new DomainSpec()\n+                    .domainUid(domainResourceName)\n+                    .domainHomeSourceType(\"FromModel\")\n+                    .image(MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG)\n+                    .addImagePullSecretsItem(new V1LocalObjectReference()\n+                            .name(repoSecretName))\n+                    .webLogicCredentialsSecret(new V1SecretReference()\n+                            .name(adminSecretName)\n+                            .namespace(domNamespace))\n+                    .includeServerOutInPodLog(true)\n+                    .serverStartPolicy(\"IF_NEEDED\")\n+                    .serverPod(new ServerPod()\n+                            .addEnvItem(new V1EnvVar()\n+                                    .name(\"JAVA_OPTIONS\")\n+                                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                            .addEnvItem(new V1EnvVar()\n+                                    .name(\"USER_MEM_ARGS\")\n+                                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+                    .adminServer(new AdminServer()\n+                            .serverStartState(\"RUNNING\")\n+                            .adminService(new AdminService()\n+                                    .addChannelsItem(new Channel()\n+                                            .channelName(\"default\")\n+                                            .nodePort(0))))\n+                    .addClustersItem(new Cluster()\n+                            .clusterName(\"cluster-1\")\n+                            .replicas(replicaCount)\n+                            .serverStartState(\"RUNNING\"))\n+                    .configuration(new Configuration()\n+                            .model(new Model()\n+                                    .domainType(\"WLS\")\n+                                    .runtimeEncryptionSecret(encryptionSecretName))\n+                        .introspectorJobActiveDeadlineSeconds(300L)));\n+\n+  }\n+  \n+  /**\n+   * Patch domain resource with a new WebLogic domain credentials secret and a new restartVersion,\n+   * and verify if the domain spec has been correctly updated.\n+   * \n+   * @param domainUid name of the domain resource\n+   * @param namespace Kubernetes namespace that the domain is hosted\n+   * @param adminServerPodName name of the WebLogic admin server\n+   * @param managedServerPrefix prefix of the managed servers\n+   * @param replicaCount number of managed servers to start\n+   * @param secretNmae name of the secret that is used to patch the domain resource\n+   * @return restartVersion of the domain resource\n+   */\n+  private String patchDomainWithNewSecretAndVerify(\n+      final String domainUid,\n+      final String namespace,\n+      final String adminServerPodName,\n+      final String managedServerPrefix,\n+      final int replicaCount,\n+      final String secretName\n+  ) {\n+    logger.info(\n+        \"Patch domain resource {0} in namespace {1} to use the new secret {2}\",\n+        domainUid, namespace, secretName);\n+\n+    String restartVersion = patchDomainResourceWithNewAdminSecret(domainUid, namespace, secretName);\n+    \n+    logger.info(\n+        \"Check that domain resource {0} in namespace {1} has been patched with new secret {2}\",\n+        domainUid, namespace, secretName);\n+    checkDomainCredentialsSecretPatched(domainUid, namespace, secretName);\n+\n+    // check and wait for the admin server pod to be patched with the new secret\n+    logger.info(\n+        \"Check that admin server pod for domain resource {0} in namespace {1} has been patched with {2}: {3}\",\n+        domainUid, namespace, \"/spec/webLogicCredentialsSecret/name\", secretName);\n+\n+    return restartVersion;\n+  }\n+\n+  /**\n+   * Check that domain resource has been updated with the new WebLogic domain credentials secret.\n+   * \n+   * @param domainUid name of the domain resource\n+   * @param namespace Kubernetes namespace that the domain is hosted\n+   * @param newValue new secret name for the WebLogic domain credentials secret\n+   */\n+  private void checkDomainCredentialsSecretPatched(\n+      String domainUid,\n+      String namespace,\n+      String newValue\n+  ) {\n+   \n+    // check if domain resource has been patched with the new secret\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            domainUid,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> domainResourceCredentialsSecretPatched(domainUid, namespace, newValue),\n+            String.format(\n+               \"Domain %s in namespace %s is not patched with admin credentials secret %s\",\n+               domainUid, namespace, newValue)));\n+\n+  }\n+  \n+  private void checkPodRestarted(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY4MjkzNg=="}, "originalCommit": {"oid": "25b33e831acbcb76ad4c0af938dc431fc4f955ac"}, "originalPosition": 409}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcyOTk5Nw==", "bodyText": "moved", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1665#discussion_r428729997", "createdAt": "2020-05-21T15:31:43Z", "author": {"login": "doxiao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiChangeAdminCredentials.java", "diffHunk": "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsNotValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainResourceCredentialsSecretPatched;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podRestartVersionUpdated;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to change the WebLogic credentials secret of a domain custom resource that uses model-in-image.\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to patch the model-in-image image to change WebLogic admin credentials secret\")\n+@IntegrationTest\n+class ItMiiChangeAdminCredentials implements LoggedTest {\n+\n+  private static String domainNamespace = null;\n+  private static String domainUid = \"domain1\";\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static ConditionFactory withQuickRetryPolicy = null;\n+\n+  private static String adminServerPodName = String.format(\"%s-%s\", domainUid, ADMIN_SERVER_NAME_BASE);\n+  private static String managedServerPrefix = String.format(\"%s-%s\", domainUid, MANAGED_SERVER_NAME_BASE);\n+  private static int replicaCount = 2;\n+\n+  /**\n+   * Perform initialization for all the tests in this class.\n+   * Set up the necessary namespaces, install the operator in the first namespace, and\n+   * create a domain in the second namespace using the pre-created basic MII image.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(6, MINUTES).await();\n+\n+    // create quick, reusable retry/backoff policy\n+    withQuickRetryPolicy = with().pollDelay(0, SECONDS)\n+        .and().with().pollInterval(3, SECONDS)\n+        .atMost(12, SECONDS).await();\n+\n+    // get namespaces \n+    assertNotNull(namespaces.get(0), String.format(\"Namespace namespaces.get(0) is null\"));\n+    String opNamespace = namespaces.get(0);\n+\n+    assertNotNull(namespaces.get(1), String.format(\"Namespace namespaces.get(1) is null\"));\n+    domainNamespace = namespaces.get(1);\n+\n+    // install the operator\n+    logger.info(\"Install an operator in namespace {0}, managing namespace {1}\",\n+        opNamespace, domainNamespace); \n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+   \n+    // create a domain resource\n+    logger.info(\"Create model-in-image domain {0} in namespace {1}, and wait until it comes up\",\n+        domainUid, domainNamespace); \n+    createAndVerifyMiiDomain();\n+  }\n+  \n+  /**\n+   * Test patching a running model-in-image domain with a new WebLogic credentials secret.\n+   * Perform two patching operations to the domain spec: change the webLogicCredentialsSecret to a new\n+   * secret, and change the domainRestartVersion to trigger a rolling restart of the server pods.\n+   * Verify that the domain spec's webLogicCredentialsSecret and restartVersion are updated,\n+   * the server pods are recreated by checking each pod's creationTimestamp before and after patching,\n+   * the server pods' weblogic.domainRestartVersion label is updated, and \n+   * the new credentials are valid and can be used to access WebLogic RESTful Management Services.\n+   */\n+  @Test\n+  @DisplayName(\"Change the WebLogic credentials\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testChangeWebLogicCredentials() {\n+    final boolean VALID = true;\n+    final boolean INVALID = false;\n+\n+    // get the creation time of the admin server pod before patching\n+    String adminPodLastCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace,\"\",adminServerPodName),\n+        String.format(\"Failed to get creationTimestamp for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodLastCreationTime, \"creationTimestamp of the admin server pod is null\");\n+\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodLastCreationTime);\n+    \n+    List<String> msLastCreationTime = new ArrayList<String>();\n+    // get the creation time of the managed server pods before patching\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            msLastCreationTime.add(creationTime);\n+\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    \n+    logger.info(\"Check that before patching current credentials are valid and new credentials are not\");\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, VALID);\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_PATCH, ADMIN_PASSWORD_PATCH, INVALID);\n+    \n+    // create a new secret for admin credentials\n+    logger.info(\"Create a new secret that contains new WebLogic admin credentials\");\n+    String adminSecretName = \"weblogic-credentials-new\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(\n+        adminSecretName,\n+        domainNamespace,\n+        ADMIN_USERNAME_PATCH,\n+        ADMIN_PASSWORD_PATCH),\n+        String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // patch the domain resource with the new secret and verify that the domain resource is patched.\n+    logger.info(\"Patch domain {0} in namespace {1} with the secret {2}, and verify the result\",\n+        domainUid, domainNamespace, adminSecretName); \n+\n+    String restartVersion = patchDomainWithNewSecretAndVerify(\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        managedServerPrefix,\n+        replicaCount,\n+        adminSecretName);\n+\n+    logger.info(\"Wait for domain {0} admin server pod {1} in namespace {2} to be restarted\",\n+        domainUid, adminServerPodName, domainNamespace);\n+    checkPodRestarted(domainUid, domainNamespace, adminServerPodName, adminPodLastCreationTime);\n+    \n+    // check that the admin server pod's label has been updated with the new restartVersion\n+    checkPodRestartVersionUpdated(adminServerPodName, domainUid, domainNamespace, restartVersion);\n+    \n+    // check that the managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      final String podName = managedServerPrefix + i;\n+      final String lastCreationTime = msLastCreationTime.get(i - 1);\n+      logger.info(\"Wait for managed server pod {0} to be restarted in namespace {1}\",\n+          podName, domainNamespace);\n+      checkPodRestarted(domainUid, domainNamespace, podName, lastCreationTime);\n+      \n+      // check that the managed server pod's label has been updated with the new restartVersion\n+      checkPodRestartVersionUpdated(podName, domainUid, domainNamespace, restartVersion);\n+    }\n+ \n+    // check if the new credentials are valid and the old credentials are not valid any more\n+    logger.info(\"Check that after patching current credentials are not valid and new credentials are\");\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, INVALID);\n+    verifyCredentials(adminServerPodName, domainNamespace, ADMIN_USERNAME_PATCH, ADMIN_PASSWORD_PATCH, VALID);\n+    \n+    logger.info(\"Domain {0} in namespace {1} is fully started after changing WebLogic credentials secret\",\n+        domainUid, domainNamespace);\n+  }\n+\n+  /**\n+   * Patch the domain resource with a new WebLogic admin credentials secret.\n+   * \n+   * @param domainResourceName name of the domain resource\n+   * @param namespace Kubernetes namespace that the domain is hosted\n+   * @param secretName name of the new WebLogic admin credentials secret\n+   * @return restartVersion new restartVersion of the domain resource\n+   */\n+  private String patchDomainResourceWithNewAdminSecret(\n+      String domainResourceName,\n+      String namespace,\n+      String secretName\n+  ) {\n+    String patch = String.format(\n+        \"[\\n  {\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/%s\\\", \\\"value\\\": \\\"%s\\\"}\\n]\\n\",\n+            \"webLogicCredentialsSecret/name\", secretName);\n+    logger.info(\"Patch the domain resource {0} in namespace {1} with:{2}\\n\",\n+        domainResourceName, namespace, patch);\n+\n+    assertTrue(patchDomainCustomResource(\n+            domainResourceName,\n+            namespace,\n+            new V1Patch(patch),\n+            V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        String.format(\"Failed to patch the domain resource %s in namespace %s with %s:%s\",\n+            domainResourceName, namespace, \"/spec/webLogicCredentialsSecret/name\", secretName));\n+\n+    String oldVersion = assertDoesNotThrow(\n+        () -> getDomainCustomResource(domainResourceName, namespace).getSpec().getRestartVersion(),\n+        String.format(\"Failed to get the restartVersion of %s in namespace %s\", domainResourceName, namespace));\n+    int newVersion = oldVersion == null ? 1 : Integer.valueOf(oldVersion) + 1;\n+    logger.info(\"Update domain resource {0} in namespace {1} restartVersion from {2} to {3}\",\n+        domainResourceName, namespace, oldVersion, newVersion);\n+    patch =\n+        String.format(\"[\\n  {\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/restartVersion\\\", \\\"value\\\": \\\"%s\\\"}\\n]\\n\",\n+            newVersion);\n+    \n+    logger.info(\"Patch the domain resource {0} in namespace {1} with:{2}\\n\",\n+        domainResourceName, namespace, patch);\n+\n+    assertTrue(patchDomainCustomResource(\n+            domainResourceName,\n+            namespace,\n+            new V1Patch(patch),\n+            V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        String.format(\"Failed to patch the domain resource %s in namespace %s with startVersion:%s\",\n+              domainResourceName, namespace, newVersion));\n+\n+    String updatedVersion = assertDoesNotThrow(\n+        () -> getDomainCustomResource(domainResourceName, namespace).getSpec().getRestartVersion(),\n+        String.format(\"Failed to get the restartVersion of %s in namespace %s\", domainResourceName, namespace));\n+    logger.info(\"Current restartVersion is {0}\", updatedVersion);\n+    assertTrue(updatedVersion.equals(String.valueOf(newVersion)),\n+        String.format(\"Failed to update the restartVersion of domain %s from %s to %s\",\n+            domainResourceName,\n+            oldVersion,\n+            newVersion));\n+    return String.valueOf(newVersion);\n+  }\n+\n+  /**\n+   * Create a domain object for a Kubernetes domain custom resource using the basic model-in-image image.\n+   * \n+   * @param domainResourceName name of the domain resource\n+   * @param domainNamespace Kubernetes namespace that the domain is hosted\n+   * @param adminSecretName name of the new WebLogic admin credentials secret\n+   * @param repoSecretName name of the secret for pulling the WebLogic image\n+   * @param encryptionSecretName name of the secret for encryption\n+   * @param replicaCount number of managed servers to start\n+   * @return domain of the domain resource\n+   */\n+  private static Domain createDomainResource(\n+      String domainResourceName, \n+      String domNamespace, \n+      String adminSecretName,\n+      String repoSecretName, \n+      String encryptionSecretName, \n+      int replicaCount) {\n+    // create the domain CR\n+    return new Domain()\n+            .apiVersion(DOMAIN_API_VERSION)\n+            .kind(\"Domain\")\n+            .metadata(new V1ObjectMeta()\n+                    .name(domainResourceName)\n+                    .namespace(domNamespace))\n+            .spec(new DomainSpec()\n+                    .domainUid(domainResourceName)\n+                    .domainHomeSourceType(\"FromModel\")\n+                    .image(MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG)\n+                    .addImagePullSecretsItem(new V1LocalObjectReference()\n+                            .name(repoSecretName))\n+                    .webLogicCredentialsSecret(new V1SecretReference()\n+                            .name(adminSecretName)\n+                            .namespace(domNamespace))\n+                    .includeServerOutInPodLog(true)\n+                    .serverStartPolicy(\"IF_NEEDED\")\n+                    .serverPod(new ServerPod()\n+                            .addEnvItem(new V1EnvVar()\n+                                    .name(\"JAVA_OPTIONS\")\n+                                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                            .addEnvItem(new V1EnvVar()\n+                                    .name(\"USER_MEM_ARGS\")\n+                                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+                    .adminServer(new AdminServer()\n+                            .serverStartState(\"RUNNING\")\n+                            .adminService(new AdminService()\n+                                    .addChannelsItem(new Channel()\n+                                            .channelName(\"default\")\n+                                            .nodePort(0))))\n+                    .addClustersItem(new Cluster()\n+                            .clusterName(\"cluster-1\")\n+                            .replicas(replicaCount)\n+                            .serverStartState(\"RUNNING\"))\n+                    .configuration(new Configuration()\n+                            .model(new Model()\n+                                    .domainType(\"WLS\")\n+                                    .runtimeEncryptionSecret(encryptionSecretName))\n+                        .introspectorJobActiveDeadlineSeconds(300L)));\n+\n+  }\n+  \n+  /**\n+   * Patch domain resource with a new WebLogic domain credentials secret and a new restartVersion,\n+   * and verify if the domain spec has been correctly updated.\n+   * \n+   * @param domainUid name of the domain resource\n+   * @param namespace Kubernetes namespace that the domain is hosted\n+   * @param adminServerPodName name of the WebLogic admin server\n+   * @param managedServerPrefix prefix of the managed servers\n+   * @param replicaCount number of managed servers to start\n+   * @param secretNmae name of the secret that is used to patch the domain resource\n+   * @return restartVersion of the domain resource\n+   */\n+  private String patchDomainWithNewSecretAndVerify(\n+      final String domainUid,\n+      final String namespace,\n+      final String adminServerPodName,\n+      final String managedServerPrefix,\n+      final int replicaCount,\n+      final String secretName\n+  ) {\n+    logger.info(\n+        \"Patch domain resource {0} in namespace {1} to use the new secret {2}\",\n+        domainUid, namespace, secretName);\n+\n+    String restartVersion = patchDomainResourceWithNewAdminSecret(domainUid, namespace, secretName);\n+    \n+    logger.info(\n+        \"Check that domain resource {0} in namespace {1} has been patched with new secret {2}\",\n+        domainUid, namespace, secretName);\n+    checkDomainCredentialsSecretPatched(domainUid, namespace, secretName);\n+\n+    // check and wait for the admin server pod to be patched with the new secret\n+    logger.info(\n+        \"Check that admin server pod for domain resource {0} in namespace {1} has been patched with {2}: {3}\",\n+        domainUid, namespace, \"/spec/webLogicCredentialsSecret/name\", secretName);\n+\n+    return restartVersion;\n+  }\n+\n+  /**\n+   * Check that domain resource has been updated with the new WebLogic domain credentials secret.\n+   * \n+   * @param domainUid name of the domain resource\n+   * @param namespace Kubernetes namespace that the domain is hosted\n+   * @param newValue new secret name for the WebLogic domain credentials secret\n+   */\n+  private void checkDomainCredentialsSecretPatched(\n+      String domainUid,\n+      String namespace,\n+      String newValue\n+  ) {\n+   \n+    // check if domain resource has been patched with the new secret\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            domainUid,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> domainResourceCredentialsSecretPatched(domainUid, namespace, newValue),\n+            String.format(\n+               \"Domain %s in namespace %s is not patched with admin credentials secret %s\",\n+               domainUid, namespace, newValue)));\n+\n+  }\n+  \n+  private void checkPodRestarted(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY4MjkzNg=="}, "originalCommit": {"oid": "25b33e831acbcb76ad4c0af938dc431fc4f955ac"}, "originalPosition": 409}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2OTg0MzIyOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Application.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNDoyMzozNFrOGY0xug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNTozMTo1MVrOGY3m3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY4MzcwNg==", "bodyText": "Add --noproxy '*'", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1665#discussion_r428683706", "createdAt": "2020-05-21T14:23:34Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Application.java", "diffHunk": "@@ -119,4 +123,80 @@ public static boolean appAccessibleInPod(\n       return false;\n     }\n   } \n+  \n+  /**\n+   * Check if the given WebLogic credentials are valid by using the credentials to \n+   * invoke a RESTful Management Services command.\n+   *\n+   * @param host hostname of the admin server pod\n+   * @param podName name of the admin server pod\n+   * @param namespace name of the namespace that the pod is running in\n+   * @param username WebLogic admin username\n+   * @param password WebLogic admin password\n+   * @return true if the RESTful Management Services command succeeded\n+   **/\n+  public static boolean credentialsValid(\n+      String host,\n+      String podName,\n+      String namespace,\n+      String username,\n+      String password) {\n+    CommandParams params = createCommandParams(host, podName, namespace, username, password);\n+    return Command.withParams(params).executeAndVerify(\"200\");\n+  }\n+  \n+  /**\n+   * Check if the given WebLogic credentials are not valid by using the credentials to \n+   * invoke a RESTful Management Services command.\n+   *\n+   * @param host hostname of the admin server pod\n+   * @param podName name of the admin server pod\n+   * @param namespace name of the namespace that the pod is running in\n+   * @param username WebLogic admin username\n+   * @param password WebLogic admin password\n+   * @return true if the RESTful Management Services command failed with exitCode 401\n+   **/\n+  public static boolean credentialsNotValid(\n+      String host,\n+      String podName,\n+      String namespace,\n+      String username,\n+      String password) {\n+    CommandParams params = createCommandParams(host, podName, namespace, username, password);\n+    return Command.withParams(params).executeAndVerify(\"401\");\n+  }\n+ \n+  private static CommandParams createCommandParams(\n+      String host,\n+      String podName,\n+      String namespace,\n+      String username,\n+      String password) {\n+    int adminServiceNodePort = getServiceNodePort(namespace, podName + \"-external\", WLS_DEFAULT_CHANNEL_NAME);\n+\n+    if (username == null) {\n+      username = ADMIN_USERNAME_DEFAULT;\n+    }\n+    if (password == null) {\n+      password = ADMIN_PASSWORD_DEFAULT;\n+    }\n+\n+    // create a RESTful management services command that connects to admin server using given credentials to get\n+    // information about a managed server\n+    StringBuffer cmdString = new StringBuffer()\n+        .append(\"status=$(curl --user \" + username + \":\" + password)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25b33e831acbcb76ad4c0af938dc431fc4f955ac"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODczMDA3OA==", "bodyText": "done", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1665#discussion_r428730078", "createdAt": "2020-05-21T15:31:51Z", "author": {"login": "doxiao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Application.java", "diffHunk": "@@ -119,4 +123,80 @@ public static boolean appAccessibleInPod(\n       return false;\n     }\n   } \n+  \n+  /**\n+   * Check if the given WebLogic credentials are valid by using the credentials to \n+   * invoke a RESTful Management Services command.\n+   *\n+   * @param host hostname of the admin server pod\n+   * @param podName name of the admin server pod\n+   * @param namespace name of the namespace that the pod is running in\n+   * @param username WebLogic admin username\n+   * @param password WebLogic admin password\n+   * @return true if the RESTful Management Services command succeeded\n+   **/\n+  public static boolean credentialsValid(\n+      String host,\n+      String podName,\n+      String namespace,\n+      String username,\n+      String password) {\n+    CommandParams params = createCommandParams(host, podName, namespace, username, password);\n+    return Command.withParams(params).executeAndVerify(\"200\");\n+  }\n+  \n+  /**\n+   * Check if the given WebLogic credentials are not valid by using the credentials to \n+   * invoke a RESTful Management Services command.\n+   *\n+   * @param host hostname of the admin server pod\n+   * @param podName name of the admin server pod\n+   * @param namespace name of the namespace that the pod is running in\n+   * @param username WebLogic admin username\n+   * @param password WebLogic admin password\n+   * @return true if the RESTful Management Services command failed with exitCode 401\n+   **/\n+  public static boolean credentialsNotValid(\n+      String host,\n+      String podName,\n+      String namespace,\n+      String username,\n+      String password) {\n+    CommandParams params = createCommandParams(host, podName, namespace, username, password);\n+    return Command.withParams(params).executeAndVerify(\"401\");\n+  }\n+ \n+  private static CommandParams createCommandParams(\n+      String host,\n+      String podName,\n+      String namespace,\n+      String username,\n+      String password) {\n+    int adminServiceNodePort = getServiceNodePort(namespace, podName + \"-external\", WLS_DEFAULT_CHANNEL_NAME);\n+\n+    if (username == null) {\n+      username = ADMIN_USERNAME_DEFAULT;\n+    }\n+    if (password == null) {\n+      password = ADMIN_PASSWORD_DEFAULT;\n+    }\n+\n+    // create a RESTful management services command that connects to admin server using given credentials to get\n+    // information about a managed server\n+    StringBuffer cmdString = new StringBuffer()\n+        .append(\"status=$(curl --user \" + username + \":\" + password)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY4MzcwNg=="}, "originalCommit": {"oid": "25b33e831acbcb76ad4c0af938dc431fc4f955ac"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2OTg2MzcyOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiChangeAdminCredentials.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNDoyODo1NVrOGY0_EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNDozOTo1MVrOGY1YyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY4NzEyMQ==", "bodyText": "sepc:  --> spec", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1665#discussion_r428687121", "createdAt": "2020-05-21T14:28:55Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiChangeAdminCredentials.java", "diffHunk": "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsNotValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainResourceCredentialsSecretPatched;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podRestartVersionUpdated;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to change the WebLogic credentials secret of a domain custom resource that uses model-in-image.\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to patch the model-in-image image to change WebLogic admin credentials secret\")\n+@IntegrationTest\n+class ItMiiChangeAdminCredentials implements LoggedTest {\n+\n+  private static String domainNamespace = null;\n+  private static String domainUid = \"domain1\";\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static ConditionFactory withQuickRetryPolicy = null;\n+\n+  private static String adminServerPodName = String.format(\"%s-%s\", domainUid, ADMIN_SERVER_NAME_BASE);\n+  private static String managedServerPrefix = String.format(\"%s-%s\", domainUid, MANAGED_SERVER_NAME_BASE);\n+  private static int replicaCount = 2;\n+\n+  /**\n+   * Perform initialization for all the tests in this class.\n+   * Set up the necessary namespaces, install the operator in the first namespace, and\n+   * create a domain in the second namespace using the pre-created basic MII image.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(6, MINUTES).await();\n+\n+    // create quick, reusable retry/backoff policy\n+    withQuickRetryPolicy = with().pollDelay(0, SECONDS)\n+        .and().with().pollInterval(3, SECONDS)\n+        .atMost(12, SECONDS).await();\n+\n+    // get namespaces \n+    assertNotNull(namespaces.get(0), String.format(\"Namespace namespaces.get(0) is null\"));\n+    String opNamespace = namespaces.get(0);\n+\n+    assertNotNull(namespaces.get(1), String.format(\"Namespace namespaces.get(1) is null\"));\n+    domainNamespace = namespaces.get(1);\n+\n+    // install the operator\n+    logger.info(\"Install an operator in namespace {0}, managing namespace {1}\",\n+        opNamespace, domainNamespace); \n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+   \n+    // create a domain resource\n+    logger.info(\"Create model-in-image domain {0} in namespace {1}, and wait until it comes up\",\n+        domainUid, domainNamespace); \n+    createAndVerifyMiiDomain();\n+  }\n+  \n+  /**\n+   * Test patching a running model-in-image domain with a new WebLogic credentials secret.\n+   * Perform two patching operations to the domain spec: change the webLogicCredentialsSecret to a new", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25b33e831acbcb76ad4c0af938dc431fc4f955ac"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY4Nzg0NA==", "bodyText": "there are two operations following this \":\".", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1665#discussion_r428687844", "createdAt": "2020-05-21T14:30:04Z", "author": {"login": "doxiao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiChangeAdminCredentials.java", "diffHunk": "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsNotValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainResourceCredentialsSecretPatched;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podRestartVersionUpdated;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to change the WebLogic credentials secret of a domain custom resource that uses model-in-image.\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to patch the model-in-image image to change WebLogic admin credentials secret\")\n+@IntegrationTest\n+class ItMiiChangeAdminCredentials implements LoggedTest {\n+\n+  private static String domainNamespace = null;\n+  private static String domainUid = \"domain1\";\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static ConditionFactory withQuickRetryPolicy = null;\n+\n+  private static String adminServerPodName = String.format(\"%s-%s\", domainUid, ADMIN_SERVER_NAME_BASE);\n+  private static String managedServerPrefix = String.format(\"%s-%s\", domainUid, MANAGED_SERVER_NAME_BASE);\n+  private static int replicaCount = 2;\n+\n+  /**\n+   * Perform initialization for all the tests in this class.\n+   * Set up the necessary namespaces, install the operator in the first namespace, and\n+   * create a domain in the second namespace using the pre-created basic MII image.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(6, MINUTES).await();\n+\n+    // create quick, reusable retry/backoff policy\n+    withQuickRetryPolicy = with().pollDelay(0, SECONDS)\n+        .and().with().pollInterval(3, SECONDS)\n+        .atMost(12, SECONDS).await();\n+\n+    // get namespaces \n+    assertNotNull(namespaces.get(0), String.format(\"Namespace namespaces.get(0) is null\"));\n+    String opNamespace = namespaces.get(0);\n+\n+    assertNotNull(namespaces.get(1), String.format(\"Namespace namespaces.get(1) is null\"));\n+    domainNamespace = namespaces.get(1);\n+\n+    // install the operator\n+    logger.info(\"Install an operator in namespace {0}, managing namespace {1}\",\n+        opNamespace, domainNamespace); \n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+   \n+    // create a domain resource\n+    logger.info(\"Create model-in-image domain {0} in namespace {1}, and wait until it comes up\",\n+        domainUid, domainNamespace); \n+    createAndVerifyMiiDomain();\n+  }\n+  \n+  /**\n+   * Test patching a running model-in-image domain with a new WebLogic credentials secret.\n+   * Perform two patching operations to the domain spec: change the webLogicCredentialsSecret to a new", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY4NzEyMQ=="}, "originalCommit": {"oid": "25b33e831acbcb76ad4c0af938dc431fc4f955ac"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY5MzcwNQ==", "bodyText": "I'll reword it.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1665#discussion_r428693705", "createdAt": "2020-05-21T14:39:51Z", "author": {"login": "doxiao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiChangeAdminCredentials.java", "diffHunk": "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_PATCH;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsNotValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.credentialsValid;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainResourceCredentialsSecretPatched;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podRestartVersionUpdated;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to change the WebLogic credentials secret of a domain custom resource that uses model-in-image.\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to patch the model-in-image image to change WebLogic admin credentials secret\")\n+@IntegrationTest\n+class ItMiiChangeAdminCredentials implements LoggedTest {\n+\n+  private static String domainNamespace = null;\n+  private static String domainUid = \"domain1\";\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static ConditionFactory withQuickRetryPolicy = null;\n+\n+  private static String adminServerPodName = String.format(\"%s-%s\", domainUid, ADMIN_SERVER_NAME_BASE);\n+  private static String managedServerPrefix = String.format(\"%s-%s\", domainUid, MANAGED_SERVER_NAME_BASE);\n+  private static int replicaCount = 2;\n+\n+  /**\n+   * Perform initialization for all the tests in this class.\n+   * Set up the necessary namespaces, install the operator in the first namespace, and\n+   * create a domain in the second namespace using the pre-created basic MII image.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(6, MINUTES).await();\n+\n+    // create quick, reusable retry/backoff policy\n+    withQuickRetryPolicy = with().pollDelay(0, SECONDS)\n+        .and().with().pollInterval(3, SECONDS)\n+        .atMost(12, SECONDS).await();\n+\n+    // get namespaces \n+    assertNotNull(namespaces.get(0), String.format(\"Namespace namespaces.get(0) is null\"));\n+    String opNamespace = namespaces.get(0);\n+\n+    assertNotNull(namespaces.get(1), String.format(\"Namespace namespaces.get(1) is null\"));\n+    domainNamespace = namespaces.get(1);\n+\n+    // install the operator\n+    logger.info(\"Install an operator in namespace {0}, managing namespace {1}\",\n+        opNamespace, domainNamespace); \n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+   \n+    // create a domain resource\n+    logger.info(\"Create model-in-image domain {0} in namespace {1}, and wait until it comes up\",\n+        domainUid, domainNamespace); \n+    createAndVerifyMiiDomain();\n+  }\n+  \n+  /**\n+   * Test patching a running model-in-image domain with a new WebLogic credentials secret.\n+   * Perform two patching operations to the domain spec: change the webLogicCredentialsSecret to a new", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY4NzEyMQ=="}, "originalCommit": {"oid": "25b33e831acbcb76ad4c0af938dc431fc4f955ac"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2OTk3MjkzOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNDo1NTozN1rOGY2Fug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNTo0MDo0N1rOGY38OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcwNTIxMA==", "bodyText": "Should it not go the Domain Impl,  the Application has nothing to do with Credential Validation.\nA general Comments:  The credential update/Validation is a one-off usecase, which will not be used in other MII usecaes.  So it may NOT be a candidate for a generic assertion at the utility level. We can write the assertion inside the TestClass to limit its scope.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1665#discussion_r428705210", "createdAt": "2020-05-21T14:55:37Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -264,6 +299,46 @@ public static boolean appAccessibleInPodKubectl(\n     return Application.appAccessibleInPodKubectl(namespace, podName, port, appPath, expectedResponse);\n   }\n \n+  /**\n+   * Check if the given WebLogic credentials are valid by using the credentials to \n+   * invoke a RESTful Management Services command.\n+   *\n+   * @param host hostname of the admin server pod\n+   * @param podName name of the admin server pod\n+   * @param namespace name of the namespace that the pod is running in\n+   * @param username WebLogic admin username\n+   * @param password WebLogic admin password\n+   * @return true if the RESTful Management Services command succeeded\n+   */\n+  public static Callable<Boolean> credentialsValid(\n+      String host,\n+      String podName,\n+      String namespace,\n+      String username,\n+      String password) {\n+    return () -> Application.credentialsValid(host, podName, namespace, username, password);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25b33e831acbcb76ad4c0af938dc431fc4f955ac"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODczNTU0NA==", "bodyText": "A general rule is that the test code should not use action/assertion impl classes.\nI can move it to Domain.java.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1665#discussion_r428735544", "createdAt": "2020-05-21T15:40:47Z", "author": {"login": "doxiao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -264,6 +299,46 @@ public static boolean appAccessibleInPodKubectl(\n     return Application.appAccessibleInPodKubectl(namespace, podName, port, appPath, expectedResponse);\n   }\n \n+  /**\n+   * Check if the given WebLogic credentials are valid by using the credentials to \n+   * invoke a RESTful Management Services command.\n+   *\n+   * @param host hostname of the admin server pod\n+   * @param podName name of the admin server pod\n+   * @param namespace name of the namespace that the pod is running in\n+   * @param username WebLogic admin username\n+   * @param password WebLogic admin password\n+   * @return true if the RESTful Management Services command succeeded\n+   */\n+  public static Callable<Boolean> credentialsValid(\n+      String host,\n+      String podName,\n+      String namespace,\n+      String username,\n+      String password) {\n+    return () -> Application.credentialsValid(host, podName, namespace, username, password);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcwNTIxMA=="}, "originalCommit": {"oid": "25b33e831acbcb76ad4c0af938dc431fc4f955ac"}, "originalPosition": 72}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4594, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}