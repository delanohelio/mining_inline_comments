{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzNDE4ODYw", "number": 1563, "title": "Adding test for mii end to end use case", "bodyText": "Adding test for Mii end to end use case :\ncreate unique namespace for operator\ncreate unique namespace for domain\ncreate service account for operator\ninstall operator\nverify operator pod is running\ncreate image using model file\ncreate domain using model in image\nverify domain is created\nverify admin and managed pods are started and ready\nverify admin and managed services are running\ndelete domain\ndelete domain image\nuninstall operator\ndelete service account\ndelete domain namespace\ndelete operator namespace\nAdding Docker Primitive class.\nCalling buildDockerImages.sh from pre-integration-test phase in pom.xml", "createdAt": "2020-04-14T21:16:56Z", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563", "merged": true, "mergeCommit": {"oid": "e5b27c1c9c41e4b7e6897bbca4ddaeed7bdbb07e"}, "closed": true, "closedAt": "2020-04-16T15:04:09Z", "author": {"login": "vanajamukkara"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcXqS4zgFqTM5MzMwNDM4NQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcYOEg8AFqTM5NDcyNjQ4NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMzA0Mzg1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#pullrequestreview-393304385", "createdAt": "2020-04-14T21:20:32Z", "commit": {"oid": "6a01c49b36b56e69612818706a3cd948afc0e225"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMToyMDozMlrOGFhXcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMToyMTozM1rOGFhZPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0MjczNw==", "bodyText": "feels like there are some assertions missing here to make sure createImage and pushImage worked as expected", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408442737", "createdAt": "2020-04-14T21:20:32Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -0,0 +1,557 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.logging.Level;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.extensions.Timing;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMIIImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWITParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceReady;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.awaitility.Awaitility.with;\n+\n+// Test to install Operator, create model in image domain and verify the domain\n+// has started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@ExtendWith(Timing.class)\n+class ItMiiDomain implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME_PREFIX = \"mii-image-\";\n+  private static final String MII_IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private String domainUID = \"domain1\";\n+  private String miiImage = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = createSA(opNamespace);\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertThat(installOperator(opParams))\n+        .as(\"Test installOperator returns true\")\n+        .withFailMessage(\"installOperator() did not return true\")\n+        .isTrue();\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    assertThat(helmList(opHelmParams))\n+        .as(\"Test helmList returns true\")\n+        .withFailMessage(\"helmList() did not return true\")\n+        .isTrue();\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    waitForCondition(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUID + \"-admin-server\";\n+    final String managedServerPrefix = domainUID + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImage();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a01c49b36b56e69612818706a3cd948afc0e225"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0MzE5OA==", "bodyText": "and so on through the file..", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408443198", "createdAt": "2020-04-14T21:21:33Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -0,0 +1,557 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.logging.Level;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.extensions.Timing;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMIIImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWITParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceReady;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.awaitility.Awaitility.with;\n+\n+// Test to install Operator, create model in image domain and verify the domain\n+// has started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@ExtendWith(Timing.class)\n+class ItMiiDomain implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME_PREFIX = \"mii-image-\";\n+  private static final String MII_IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private String domainUID = \"domain1\";\n+  private String miiImage = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = createSA(opNamespace);\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertThat(installOperator(opParams))\n+        .as(\"Test installOperator returns true\")\n+        .withFailMessage(\"installOperator() did not return true\")\n+        .isTrue();\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    assertThat(helmList(opHelmParams))\n+        .as(\"Test helmList returns true\")\n+        .withFailMessage(\"helmList() did not return true\")\n+        .isTrue();\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    waitForCondition(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUID + \"-admin-server\";\n+    final String managedServerPrefix = domainUID + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImage();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0MjczNw=="}, "originalCommit": {"oid": "6a01c49b36b56e69612818706a3cd948afc0e225"}, "originalPosition": 179}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMzExNzIy", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#pullrequestreview-393311722", "createdAt": "2020-04-14T21:32:56Z", "commit": {"oid": "6a01c49b36b56e69612818706a3cd948afc0e225"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMzM2NTM1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#pullrequestreview-393336535", "createdAt": "2020-04-14T22:21:41Z", "commit": {"oid": "6a01c49b36b56e69612818706a3cd948afc0e225"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjoyMTo0MVrOGFjDxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjoyMTo0MVrOGFjDxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MDQ2OA==", "bodyText": "This method can be moved to a utility class so that every IT class can use it.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408470468", "createdAt": "2020-04-14T22:21:41Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -0,0 +1,557 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.logging.Level;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.extensions.Timing;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMIIImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWITParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceReady;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.awaitility.Awaitility.with;\n+\n+// Test to install Operator, create model in image domain and verify the domain\n+// has started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@ExtendWith(Timing.class)\n+class ItMiiDomain implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME_PREFIX = \"mii-image-\";\n+  private static final String MII_IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private String domainUID = \"domain1\";\n+  private String miiImage = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = createSA(opNamespace);\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertThat(installOperator(opParams))\n+        .as(\"Test installOperator returns true\")\n+        .withFailMessage(\"installOperator() did not return true\")\n+        .isTrue();\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    assertThat(helmList(opHelmParams))\n+        .as(\"Test helmList returns true\")\n+        .withFailMessage(\"helmList() did not return true\")\n+        .isTrue();\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    waitForCondition(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUID + \"-admin-server\";\n+    final String managedServerPrefix = domainUID + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImage();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    pushImageToOCIR(miiImage);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretForDomain(adminSecretName, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretForDomain(encryptionSecretName, \"weblogicenc\", \"weblogicenc\");\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUID)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUID)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUID {0} in namespace {1}\",\n+        domainUID, domainNamespace);\n+    createDomain(domain);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    waitForCondition(domainExists(domainUID, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is running\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodRunning(adminServerPodName);\n+\n+    // check managed server pods are running\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodRunning(managedServerPrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+  }\n+\n+  @AfterEach\n+  public void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertThatCode(\n+        () -> deleteDomainCustomResource(domainUID, domainNamespace))\n+        .as(\"Test that deleteDomainCustomResource doesn not throw an exception\")\n+        .withFailMessage(\"delete domain custom resource failed\")\n+        .doesNotThrowAnyException();\n+\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUID + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  /**\n+   * Uninstall Operator, delete service account, domain namespace and\n+   * operator namespace.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+    // uninstall operator release\n+    logger.info(\"Uninstall Operator in namespace {0}\", opNamespace);\n+    if (opHelmParams != null) {\n+      assertThat(uninstallOperator(opHelmParams))\n+          .as(\"Test uninstallOperator returns true\")\n+          .withFailMessage(\"uninstallOperator() did not return true\")\n+          .isTrue();\n+    }\n+\n+    // Delete service account from unique opNamespace\n+    logger.info(\"Delete service account in namespace {0}\", opNamespace);\n+    if (serviceAccount != null) {\n+      assertThatCode(\n+          () -> deleteServiceAccount(serviceAccount.getMetadata().getName(),\n+              serviceAccount.getMetadata().getNamespace()))\n+          .as(\"Test that deleteServiceAccount doesn not throw an exception\")\n+          .withFailMessage(\"deleteServiceAccount() threw an exception\")\n+          .doesNotThrowAnyException();\n+    }\n+    // Delete domain namespaces\n+    logger.info(\"Deleting domain namespace {0}\", domainNamespace);\n+    if (domainNamespace != null) {\n+      assertThatCode(\n+          () -> deleteNamespace(domainNamespace))\n+          .as(\"Test that deleteNamespace doesn not throw an exception\")\n+          .withFailMessage(\"deleteNamespace() threw an exception\")\n+          .doesNotThrowAnyException();\n+      logger.info(\"Deleted namespace: \" + domainNamespace);\n+    }\n+\n+    // Delete opNamespace\n+    logger.info(\"Deleting Operator namespace {0}\", opNamespace);\n+    if (opNamespace != null) {\n+      assertThatCode(\n+          () -> deleteNamespace(opNamespace))\n+          .as(\"Test that deleteNamespace doesn not throw an exception\")\n+          .withFailMessage(\"deleteNamespace() threw an exception\")\n+          .doesNotThrowAnyException();\n+      logger.info(\"Deleted namespace: \" + opNamespace);\n+    }\n+\n+  }\n+\n+  private static String createSA(String namespace) {\n+    final String serviceAccountName = namespace + \"-sa\";\n+    serviceAccount = new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(namespace)\n+                .name(serviceAccountName));\n+\n+    try {\n+      createServiceAccount(serviceAccount);\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createServiceAccount failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createServiceAccount does not throw an exception\")\n+          .withFailMessage(String.format(\"Failed to create service account %s\", serviceAccountName))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    return serviceAccountName;\n+  }\n+\n+  private static String createNamespace() {\n+    String namespace = null;\n+    try {\n+      namespace = createUniqueNamespace();\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createUniqueNamespace failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createUniqueNamespace does not throw an exception\")\n+          .withFailMessage(\"createUniqueNamespace() threw an unexpected exception\")\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    return namespace;\n+  }\n+\n+  private String createImage() {\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    String currentDateTime = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    final String imageName = MII_IMAGE_NAME_PREFIX + currentDateTime;\n+\n+    // build the model file list\n+    List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    boolean archiveBuilt = buildAppArchive(\n+        defaultAppParams()\n+            .srcDir(APP_NAME));\n+\n+    assertThat(archiveBuilt)\n+        .as(\"Create an app archive\")\n+        .withFailMessage(\"Failed to create app archive for \" + APP_NAME)\n+        .isTrue();\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    logger.info(\"Create image {0}:{1} using model directory {2}\",\n+        imageName, MII_IMAGE_TAG, MODEL_DIR);\n+    boolean result = createMIIImage(\n+        defaultWITParams()\n+            .modelImageName(imageName)\n+            .modelImageTag(MII_IMAGE_TAG)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(\"latest\")\n+            .env(env)\n+            .redirect(true));\n+\n+    assertThat(result)\n+        .as(\"Check createMIIImage() returns true\")\n+        .withFailMessage(String.format(\"Failed to create the image %s using WebLogic Image Tool\", imageName))\n+        .isTrue();\n+\n+    // check image exists\n+    assertThat(dockerImageExists(imageName, MII_IMAGE_TAG))\n+        .as(\"Check dockerImageExists() returns true\")\n+        .withFailMessage(String.format(\"Image %s doesn't exist\", imageName + \":\" + MII_IMAGE_TAG))\n+        .isTrue();\n+\n+    return imageName + \":\" + MII_IMAGE_TAG;\n+  }\n+\n+  private void pushImageToOCIR(String image) {\n+    if (System.getenv(\"REPO_REGISTRY\") != null && System.getenv(\"REPO_USERNAME\") != null\n+        && System.getenv(\"REPO_PASSWORD\") != null) {\n+      String repoRegistry = System.getenv(\"REPO_REGISTRY\");\n+      String repoUserName = System.getenv(\"REPO_USERNAME\");\n+      String repoPassword = System.getenv(\"REPO_PASSWORD\");\n+\n+      logger.info(\"Push image {0} to OCIR\", image);\n+      assertThat(dockerLogin(repoRegistry, repoUserName, repoPassword))\n+          .as(\"Test dockerLogin returns true\")\n+          .withFailMessage(\"docker login failed\")\n+          .isTrue();\n+\n+      assertThat(dockerPush(image))\n+          .as(\"Test dockerPush returns true\")\n+          .withFailMessage(String.format(\"docker push failed for image %s\", image))\n+          .isTrue();\n+\n+      //TO Do: Create docker registry secret\n+    }\n+  }\n+\n+  private void createSecretForDomain(String secretName, String username, String password) {\n+    Map<String, String> secretMap = new HashMap();\n+    secretMap.put(\"username\", username);\n+    secretMap.put(\"password\", password);\n+\n+    try {\n+      assertThat(createSecret(new V1Secret()\n+          .metadata(new V1ObjectMeta()\n+              .name(secretName)\n+              .namespace(domainNamespace))\n+          .stringData(secretMap)))\n+          .as(\"Test createSecret returns true\")\n+          .withFailMessage(\"createSecret failed\")\n+          .isTrue();\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createSecret failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createSecret does not throw an exception\")\n+          .withFailMessage(String.format(\"Create secret %s failed while creating secret \"\n+              + \"for admin credentials\", secretName))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private void createDomain(Domain domain) {\n+    boolean result = false;\n+    try {\n+      result = createDomainCustomResource(domain);\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createDomainCustomResource failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createDomainCustomResource does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"Could not create domain custom resource for domainUID %s in namespace %s\",\n+              domainUID, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    assertThat(result)\n+        .as(\"Test createDomainCustomResource returns true\")\n+        .withFailMessage(String.format(\n+            \"Create domain custom resource failed for domainUID %s in namespace %s\",\n+            domainUID, domainNamespace))\n+        .isTrue();\n+\n+  }\n+\n+  private void checkPodCreated(String podName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a01c49b36b56e69612818706a3cd948afc0e225"}, "originalPosition": 505}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMzM2NzA1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#pullrequestreview-393336705", "createdAt": "2020-04-14T22:22:05Z", "commit": {"oid": "6a01c49b36b56e69612818706a3cd948afc0e225"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjoyMjowNVrOGFjEYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjoyMjowNVrOGFjEYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MDYyNw==", "bodyText": "This method can be moved to a utility class so that every IT class can use it.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408470627", "createdAt": "2020-04-14T22:22:05Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -0,0 +1,557 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.logging.Level;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.extensions.Timing;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMIIImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWITParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceReady;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.awaitility.Awaitility.with;\n+\n+// Test to install Operator, create model in image domain and verify the domain\n+// has started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@ExtendWith(Timing.class)\n+class ItMiiDomain implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME_PREFIX = \"mii-image-\";\n+  private static final String MII_IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private String domainUID = \"domain1\";\n+  private String miiImage = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = createSA(opNamespace);\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertThat(installOperator(opParams))\n+        .as(\"Test installOperator returns true\")\n+        .withFailMessage(\"installOperator() did not return true\")\n+        .isTrue();\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    assertThat(helmList(opHelmParams))\n+        .as(\"Test helmList returns true\")\n+        .withFailMessage(\"helmList() did not return true\")\n+        .isTrue();\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    waitForCondition(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUID + \"-admin-server\";\n+    final String managedServerPrefix = domainUID + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImage();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    pushImageToOCIR(miiImage);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretForDomain(adminSecretName, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretForDomain(encryptionSecretName, \"weblogicenc\", \"weblogicenc\");\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUID)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUID)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUID {0} in namespace {1}\",\n+        domainUID, domainNamespace);\n+    createDomain(domain);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    waitForCondition(domainExists(domainUID, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is running\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodRunning(adminServerPodName);\n+\n+    // check managed server pods are running\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodRunning(managedServerPrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+  }\n+\n+  @AfterEach\n+  public void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertThatCode(\n+        () -> deleteDomainCustomResource(domainUID, domainNamespace))\n+        .as(\"Test that deleteDomainCustomResource doesn not throw an exception\")\n+        .withFailMessage(\"delete domain custom resource failed\")\n+        .doesNotThrowAnyException();\n+\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUID + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  /**\n+   * Uninstall Operator, delete service account, domain namespace and\n+   * operator namespace.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+    // uninstall operator release\n+    logger.info(\"Uninstall Operator in namespace {0}\", opNamespace);\n+    if (opHelmParams != null) {\n+      assertThat(uninstallOperator(opHelmParams))\n+          .as(\"Test uninstallOperator returns true\")\n+          .withFailMessage(\"uninstallOperator() did not return true\")\n+          .isTrue();\n+    }\n+\n+    // Delete service account from unique opNamespace\n+    logger.info(\"Delete service account in namespace {0}\", opNamespace);\n+    if (serviceAccount != null) {\n+      assertThatCode(\n+          () -> deleteServiceAccount(serviceAccount.getMetadata().getName(),\n+              serviceAccount.getMetadata().getNamespace()))\n+          .as(\"Test that deleteServiceAccount doesn not throw an exception\")\n+          .withFailMessage(\"deleteServiceAccount() threw an exception\")\n+          .doesNotThrowAnyException();\n+    }\n+    // Delete domain namespaces\n+    logger.info(\"Deleting domain namespace {0}\", domainNamespace);\n+    if (domainNamespace != null) {\n+      assertThatCode(\n+          () -> deleteNamespace(domainNamespace))\n+          .as(\"Test that deleteNamespace doesn not throw an exception\")\n+          .withFailMessage(\"deleteNamespace() threw an exception\")\n+          .doesNotThrowAnyException();\n+      logger.info(\"Deleted namespace: \" + domainNamespace);\n+    }\n+\n+    // Delete opNamespace\n+    logger.info(\"Deleting Operator namespace {0}\", opNamespace);\n+    if (opNamespace != null) {\n+      assertThatCode(\n+          () -> deleteNamespace(opNamespace))\n+          .as(\"Test that deleteNamespace doesn not throw an exception\")\n+          .withFailMessage(\"deleteNamespace() threw an exception\")\n+          .doesNotThrowAnyException();\n+      logger.info(\"Deleted namespace: \" + opNamespace);\n+    }\n+\n+  }\n+\n+  private static String createSA(String namespace) {\n+    final String serviceAccountName = namespace + \"-sa\";\n+    serviceAccount = new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(namespace)\n+                .name(serviceAccountName));\n+\n+    try {\n+      createServiceAccount(serviceAccount);\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createServiceAccount failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createServiceAccount does not throw an exception\")\n+          .withFailMessage(String.format(\"Failed to create service account %s\", serviceAccountName))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    return serviceAccountName;\n+  }\n+\n+  private static String createNamespace() {\n+    String namespace = null;\n+    try {\n+      namespace = createUniqueNamespace();\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createUniqueNamespace failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createUniqueNamespace does not throw an exception\")\n+          .withFailMessage(\"createUniqueNamespace() threw an unexpected exception\")\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    return namespace;\n+  }\n+\n+  private String createImage() {\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    String currentDateTime = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    final String imageName = MII_IMAGE_NAME_PREFIX + currentDateTime;\n+\n+    // build the model file list\n+    List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    boolean archiveBuilt = buildAppArchive(\n+        defaultAppParams()\n+            .srcDir(APP_NAME));\n+\n+    assertThat(archiveBuilt)\n+        .as(\"Create an app archive\")\n+        .withFailMessage(\"Failed to create app archive for \" + APP_NAME)\n+        .isTrue();\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    logger.info(\"Create image {0}:{1} using model directory {2}\",\n+        imageName, MII_IMAGE_TAG, MODEL_DIR);\n+    boolean result = createMIIImage(\n+        defaultWITParams()\n+            .modelImageName(imageName)\n+            .modelImageTag(MII_IMAGE_TAG)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(\"latest\")\n+            .env(env)\n+            .redirect(true));\n+\n+    assertThat(result)\n+        .as(\"Check createMIIImage() returns true\")\n+        .withFailMessage(String.format(\"Failed to create the image %s using WebLogic Image Tool\", imageName))\n+        .isTrue();\n+\n+    // check image exists\n+    assertThat(dockerImageExists(imageName, MII_IMAGE_TAG))\n+        .as(\"Check dockerImageExists() returns true\")\n+        .withFailMessage(String.format(\"Image %s doesn't exist\", imageName + \":\" + MII_IMAGE_TAG))\n+        .isTrue();\n+\n+    return imageName + \":\" + MII_IMAGE_TAG;\n+  }\n+\n+  private void pushImageToOCIR(String image) {\n+    if (System.getenv(\"REPO_REGISTRY\") != null && System.getenv(\"REPO_USERNAME\") != null\n+        && System.getenv(\"REPO_PASSWORD\") != null) {\n+      String repoRegistry = System.getenv(\"REPO_REGISTRY\");\n+      String repoUserName = System.getenv(\"REPO_USERNAME\");\n+      String repoPassword = System.getenv(\"REPO_PASSWORD\");\n+\n+      logger.info(\"Push image {0} to OCIR\", image);\n+      assertThat(dockerLogin(repoRegistry, repoUserName, repoPassword))\n+          .as(\"Test dockerLogin returns true\")\n+          .withFailMessage(\"docker login failed\")\n+          .isTrue();\n+\n+      assertThat(dockerPush(image))\n+          .as(\"Test dockerPush returns true\")\n+          .withFailMessage(String.format(\"docker push failed for image %s\", image))\n+          .isTrue();\n+\n+      //TO Do: Create docker registry secret\n+    }\n+  }\n+\n+  private void createSecretForDomain(String secretName, String username, String password) {\n+    Map<String, String> secretMap = new HashMap();\n+    secretMap.put(\"username\", username);\n+    secretMap.put(\"password\", password);\n+\n+    try {\n+      assertThat(createSecret(new V1Secret()\n+          .metadata(new V1ObjectMeta()\n+              .name(secretName)\n+              .namespace(domainNamespace))\n+          .stringData(secretMap)))\n+          .as(\"Test createSecret returns true\")\n+          .withFailMessage(\"createSecret failed\")\n+          .isTrue();\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createSecret failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createSecret does not throw an exception\")\n+          .withFailMessage(String.format(\"Create secret %s failed while creating secret \"\n+              + \"for admin credentials\", secretName))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private void createDomain(Domain domain) {\n+    boolean result = false;\n+    try {\n+      result = createDomainCustomResource(domain);\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createDomainCustomResource failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createDomainCustomResource does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"Could not create domain custom resource for domainUID %s in namespace %s\",\n+              domainUID, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    assertThat(result)\n+        .as(\"Test createDomainCustomResource returns true\")\n+        .withFailMessage(String.format(\n+            \"Create domain custom resource failed for domainUID %s in namespace %s\",\n+            domainUID, domainNamespace))\n+        .isTrue();\n+\n+  }\n+\n+  private void checkPodCreated(String podName) {\n+    try {\n+      waitForCondition(podExists(podName, domainUID, domainNamespace));\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"podExists failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that podExists does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"pod %s doesn't exist in namespace %s\", podName, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private void checkPodRunning(String podName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a01c49b36b56e69612818706a3cd948afc0e225"}, "originalPosition": 518}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMzM2ODA0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#pullrequestreview-393336804", "createdAt": "2020-04-14T22:22:18Z", "commit": {"oid": "6a01c49b36b56e69612818706a3cd948afc0e225"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjoyMjoxOFrOGFjEwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjoyMjoxOFrOGFjEwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MDcyMA==", "bodyText": "This method can be moved to a utility class so that every IT class can use it.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408470720", "createdAt": "2020-04-14T22:22:18Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -0,0 +1,557 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.logging.Level;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.extensions.Timing;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMIIImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWITParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceReady;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.awaitility.Awaitility.with;\n+\n+// Test to install Operator, create model in image domain and verify the domain\n+// has started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@ExtendWith(Timing.class)\n+class ItMiiDomain implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME_PREFIX = \"mii-image-\";\n+  private static final String MII_IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private String domainUID = \"domain1\";\n+  private String miiImage = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = createSA(opNamespace);\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertThat(installOperator(opParams))\n+        .as(\"Test installOperator returns true\")\n+        .withFailMessage(\"installOperator() did not return true\")\n+        .isTrue();\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    assertThat(helmList(opHelmParams))\n+        .as(\"Test helmList returns true\")\n+        .withFailMessage(\"helmList() did not return true\")\n+        .isTrue();\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    waitForCondition(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUID + \"-admin-server\";\n+    final String managedServerPrefix = domainUID + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImage();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    pushImageToOCIR(miiImage);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretForDomain(adminSecretName, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretForDomain(encryptionSecretName, \"weblogicenc\", \"weblogicenc\");\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUID)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUID)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUID {0} in namespace {1}\",\n+        domainUID, domainNamespace);\n+    createDomain(domain);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    waitForCondition(domainExists(domainUID, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is running\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodRunning(adminServerPodName);\n+\n+    // check managed server pods are running\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodRunning(managedServerPrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+  }\n+\n+  @AfterEach\n+  public void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertThatCode(\n+        () -> deleteDomainCustomResource(domainUID, domainNamespace))\n+        .as(\"Test that deleteDomainCustomResource doesn not throw an exception\")\n+        .withFailMessage(\"delete domain custom resource failed\")\n+        .doesNotThrowAnyException();\n+\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUID + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  /**\n+   * Uninstall Operator, delete service account, domain namespace and\n+   * operator namespace.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+    // uninstall operator release\n+    logger.info(\"Uninstall Operator in namespace {0}\", opNamespace);\n+    if (opHelmParams != null) {\n+      assertThat(uninstallOperator(opHelmParams))\n+          .as(\"Test uninstallOperator returns true\")\n+          .withFailMessage(\"uninstallOperator() did not return true\")\n+          .isTrue();\n+    }\n+\n+    // Delete service account from unique opNamespace\n+    logger.info(\"Delete service account in namespace {0}\", opNamespace);\n+    if (serviceAccount != null) {\n+      assertThatCode(\n+          () -> deleteServiceAccount(serviceAccount.getMetadata().getName(),\n+              serviceAccount.getMetadata().getNamespace()))\n+          .as(\"Test that deleteServiceAccount doesn not throw an exception\")\n+          .withFailMessage(\"deleteServiceAccount() threw an exception\")\n+          .doesNotThrowAnyException();\n+    }\n+    // Delete domain namespaces\n+    logger.info(\"Deleting domain namespace {0}\", domainNamespace);\n+    if (domainNamespace != null) {\n+      assertThatCode(\n+          () -> deleteNamespace(domainNamespace))\n+          .as(\"Test that deleteNamespace doesn not throw an exception\")\n+          .withFailMessage(\"deleteNamespace() threw an exception\")\n+          .doesNotThrowAnyException();\n+      logger.info(\"Deleted namespace: \" + domainNamespace);\n+    }\n+\n+    // Delete opNamespace\n+    logger.info(\"Deleting Operator namespace {0}\", opNamespace);\n+    if (opNamespace != null) {\n+      assertThatCode(\n+          () -> deleteNamespace(opNamespace))\n+          .as(\"Test that deleteNamespace doesn not throw an exception\")\n+          .withFailMessage(\"deleteNamespace() threw an exception\")\n+          .doesNotThrowAnyException();\n+      logger.info(\"Deleted namespace: \" + opNamespace);\n+    }\n+\n+  }\n+\n+  private static String createSA(String namespace) {\n+    final String serviceAccountName = namespace + \"-sa\";\n+    serviceAccount = new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(namespace)\n+                .name(serviceAccountName));\n+\n+    try {\n+      createServiceAccount(serviceAccount);\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createServiceAccount failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createServiceAccount does not throw an exception\")\n+          .withFailMessage(String.format(\"Failed to create service account %s\", serviceAccountName))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    return serviceAccountName;\n+  }\n+\n+  private static String createNamespace() {\n+    String namespace = null;\n+    try {\n+      namespace = createUniqueNamespace();\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createUniqueNamespace failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createUniqueNamespace does not throw an exception\")\n+          .withFailMessage(\"createUniqueNamespace() threw an unexpected exception\")\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    return namespace;\n+  }\n+\n+  private String createImage() {\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    String currentDateTime = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    final String imageName = MII_IMAGE_NAME_PREFIX + currentDateTime;\n+\n+    // build the model file list\n+    List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    boolean archiveBuilt = buildAppArchive(\n+        defaultAppParams()\n+            .srcDir(APP_NAME));\n+\n+    assertThat(archiveBuilt)\n+        .as(\"Create an app archive\")\n+        .withFailMessage(\"Failed to create app archive for \" + APP_NAME)\n+        .isTrue();\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    logger.info(\"Create image {0}:{1} using model directory {2}\",\n+        imageName, MII_IMAGE_TAG, MODEL_DIR);\n+    boolean result = createMIIImage(\n+        defaultWITParams()\n+            .modelImageName(imageName)\n+            .modelImageTag(MII_IMAGE_TAG)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(\"latest\")\n+            .env(env)\n+            .redirect(true));\n+\n+    assertThat(result)\n+        .as(\"Check createMIIImage() returns true\")\n+        .withFailMessage(String.format(\"Failed to create the image %s using WebLogic Image Tool\", imageName))\n+        .isTrue();\n+\n+    // check image exists\n+    assertThat(dockerImageExists(imageName, MII_IMAGE_TAG))\n+        .as(\"Check dockerImageExists() returns true\")\n+        .withFailMessage(String.format(\"Image %s doesn't exist\", imageName + \":\" + MII_IMAGE_TAG))\n+        .isTrue();\n+\n+    return imageName + \":\" + MII_IMAGE_TAG;\n+  }\n+\n+  private void pushImageToOCIR(String image) {\n+    if (System.getenv(\"REPO_REGISTRY\") != null && System.getenv(\"REPO_USERNAME\") != null\n+        && System.getenv(\"REPO_PASSWORD\") != null) {\n+      String repoRegistry = System.getenv(\"REPO_REGISTRY\");\n+      String repoUserName = System.getenv(\"REPO_USERNAME\");\n+      String repoPassword = System.getenv(\"REPO_PASSWORD\");\n+\n+      logger.info(\"Push image {0} to OCIR\", image);\n+      assertThat(dockerLogin(repoRegistry, repoUserName, repoPassword))\n+          .as(\"Test dockerLogin returns true\")\n+          .withFailMessage(\"docker login failed\")\n+          .isTrue();\n+\n+      assertThat(dockerPush(image))\n+          .as(\"Test dockerPush returns true\")\n+          .withFailMessage(String.format(\"docker push failed for image %s\", image))\n+          .isTrue();\n+\n+      //TO Do: Create docker registry secret\n+    }\n+  }\n+\n+  private void createSecretForDomain(String secretName, String username, String password) {\n+    Map<String, String> secretMap = new HashMap();\n+    secretMap.put(\"username\", username);\n+    secretMap.put(\"password\", password);\n+\n+    try {\n+      assertThat(createSecret(new V1Secret()\n+          .metadata(new V1ObjectMeta()\n+              .name(secretName)\n+              .namespace(domainNamespace))\n+          .stringData(secretMap)))\n+          .as(\"Test createSecret returns true\")\n+          .withFailMessage(\"createSecret failed\")\n+          .isTrue();\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createSecret failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createSecret does not throw an exception\")\n+          .withFailMessage(String.format(\"Create secret %s failed while creating secret \"\n+              + \"for admin credentials\", secretName))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private void createDomain(Domain domain) {\n+    boolean result = false;\n+    try {\n+      result = createDomainCustomResource(domain);\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createDomainCustomResource failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createDomainCustomResource does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"Could not create domain custom resource for domainUID %s in namespace %s\",\n+              domainUID, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    assertThat(result)\n+        .as(\"Test createDomainCustomResource returns true\")\n+        .withFailMessage(String.format(\n+            \"Create domain custom resource failed for domainUID %s in namespace %s\",\n+            domainUID, domainNamespace))\n+        .isTrue();\n+\n+  }\n+\n+  private void checkPodCreated(String podName) {\n+    try {\n+      waitForCondition(podExists(podName, domainUID, domainNamespace));\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"podExists failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that podExists does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"pod %s doesn't exist in namespace %s\", podName, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private void checkPodRunning(String podName) {\n+    try {\n+      waitForCondition(podReady(podName, domainUID, domainNamespace));\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"podReady failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that podReady does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"pod %s is not ready in namespace %s\", podName, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private void checkServiceCreated(String serviceName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a01c49b36b56e69612818706a3cd948afc0e225"}, "originalPosition": 531}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMzM2ODk2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#pullrequestreview-393336896", "createdAt": "2020-04-14T22:22:28Z", "commit": {"oid": "6a01c49b36b56e69612818706a3cd948afc0e225"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjoyMjoyOFrOGFjFEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjoyMjoyOFrOGFjFEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MDgwMQ==", "bodyText": "This method can be moved to a utility class so that every IT class can use it.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408470801", "createdAt": "2020-04-14T22:22:28Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -0,0 +1,557 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.logging.Level;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.extensions.Timing;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMIIImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWITParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceReady;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.awaitility.Awaitility.with;\n+\n+// Test to install Operator, create model in image domain and verify the domain\n+// has started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@ExtendWith(Timing.class)\n+class ItMiiDomain implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME_PREFIX = \"mii-image-\";\n+  private static final String MII_IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private String domainUID = \"domain1\";\n+  private String miiImage = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = createSA(opNamespace);\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertThat(installOperator(opParams))\n+        .as(\"Test installOperator returns true\")\n+        .withFailMessage(\"installOperator() did not return true\")\n+        .isTrue();\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    assertThat(helmList(opHelmParams))\n+        .as(\"Test helmList returns true\")\n+        .withFailMessage(\"helmList() did not return true\")\n+        .isTrue();\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    waitForCondition(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUID + \"-admin-server\";\n+    final String managedServerPrefix = domainUID + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImage();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    pushImageToOCIR(miiImage);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretForDomain(adminSecretName, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretForDomain(encryptionSecretName, \"weblogicenc\", \"weblogicenc\");\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUID)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUID)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUID {0} in namespace {1}\",\n+        domainUID, domainNamespace);\n+    createDomain(domain);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    waitForCondition(domainExists(domainUID, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is running\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodRunning(adminServerPodName);\n+\n+    // check managed server pods are running\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodRunning(managedServerPrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+  }\n+\n+  @AfterEach\n+  public void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertThatCode(\n+        () -> deleteDomainCustomResource(domainUID, domainNamespace))\n+        .as(\"Test that deleteDomainCustomResource doesn not throw an exception\")\n+        .withFailMessage(\"delete domain custom resource failed\")\n+        .doesNotThrowAnyException();\n+\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUID + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  /**\n+   * Uninstall Operator, delete service account, domain namespace and\n+   * operator namespace.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+    // uninstall operator release\n+    logger.info(\"Uninstall Operator in namespace {0}\", opNamespace);\n+    if (opHelmParams != null) {\n+      assertThat(uninstallOperator(opHelmParams))\n+          .as(\"Test uninstallOperator returns true\")\n+          .withFailMessage(\"uninstallOperator() did not return true\")\n+          .isTrue();\n+    }\n+\n+    // Delete service account from unique opNamespace\n+    logger.info(\"Delete service account in namespace {0}\", opNamespace);\n+    if (serviceAccount != null) {\n+      assertThatCode(\n+          () -> deleteServiceAccount(serviceAccount.getMetadata().getName(),\n+              serviceAccount.getMetadata().getNamespace()))\n+          .as(\"Test that deleteServiceAccount doesn not throw an exception\")\n+          .withFailMessage(\"deleteServiceAccount() threw an exception\")\n+          .doesNotThrowAnyException();\n+    }\n+    // Delete domain namespaces\n+    logger.info(\"Deleting domain namespace {0}\", domainNamespace);\n+    if (domainNamespace != null) {\n+      assertThatCode(\n+          () -> deleteNamespace(domainNamespace))\n+          .as(\"Test that deleteNamespace doesn not throw an exception\")\n+          .withFailMessage(\"deleteNamespace() threw an exception\")\n+          .doesNotThrowAnyException();\n+      logger.info(\"Deleted namespace: \" + domainNamespace);\n+    }\n+\n+    // Delete opNamespace\n+    logger.info(\"Deleting Operator namespace {0}\", opNamespace);\n+    if (opNamespace != null) {\n+      assertThatCode(\n+          () -> deleteNamespace(opNamespace))\n+          .as(\"Test that deleteNamespace doesn not throw an exception\")\n+          .withFailMessage(\"deleteNamespace() threw an exception\")\n+          .doesNotThrowAnyException();\n+      logger.info(\"Deleted namespace: \" + opNamespace);\n+    }\n+\n+  }\n+\n+  private static String createSA(String namespace) {\n+    final String serviceAccountName = namespace + \"-sa\";\n+    serviceAccount = new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(namespace)\n+                .name(serviceAccountName));\n+\n+    try {\n+      createServiceAccount(serviceAccount);\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createServiceAccount failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createServiceAccount does not throw an exception\")\n+          .withFailMessage(String.format(\"Failed to create service account %s\", serviceAccountName))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    return serviceAccountName;\n+  }\n+\n+  private static String createNamespace() {\n+    String namespace = null;\n+    try {\n+      namespace = createUniqueNamespace();\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createUniqueNamespace failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createUniqueNamespace does not throw an exception\")\n+          .withFailMessage(\"createUniqueNamespace() threw an unexpected exception\")\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    return namespace;\n+  }\n+\n+  private String createImage() {\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    String currentDateTime = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    final String imageName = MII_IMAGE_NAME_PREFIX + currentDateTime;\n+\n+    // build the model file list\n+    List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    boolean archiveBuilt = buildAppArchive(\n+        defaultAppParams()\n+            .srcDir(APP_NAME));\n+\n+    assertThat(archiveBuilt)\n+        .as(\"Create an app archive\")\n+        .withFailMessage(\"Failed to create app archive for \" + APP_NAME)\n+        .isTrue();\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    logger.info(\"Create image {0}:{1} using model directory {2}\",\n+        imageName, MII_IMAGE_TAG, MODEL_DIR);\n+    boolean result = createMIIImage(\n+        defaultWITParams()\n+            .modelImageName(imageName)\n+            .modelImageTag(MII_IMAGE_TAG)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(\"latest\")\n+            .env(env)\n+            .redirect(true));\n+\n+    assertThat(result)\n+        .as(\"Check createMIIImage() returns true\")\n+        .withFailMessage(String.format(\"Failed to create the image %s using WebLogic Image Tool\", imageName))\n+        .isTrue();\n+\n+    // check image exists\n+    assertThat(dockerImageExists(imageName, MII_IMAGE_TAG))\n+        .as(\"Check dockerImageExists() returns true\")\n+        .withFailMessage(String.format(\"Image %s doesn't exist\", imageName + \":\" + MII_IMAGE_TAG))\n+        .isTrue();\n+\n+    return imageName + \":\" + MII_IMAGE_TAG;\n+  }\n+\n+  private void pushImageToOCIR(String image) {\n+    if (System.getenv(\"REPO_REGISTRY\") != null && System.getenv(\"REPO_USERNAME\") != null\n+        && System.getenv(\"REPO_PASSWORD\") != null) {\n+      String repoRegistry = System.getenv(\"REPO_REGISTRY\");\n+      String repoUserName = System.getenv(\"REPO_USERNAME\");\n+      String repoPassword = System.getenv(\"REPO_PASSWORD\");\n+\n+      logger.info(\"Push image {0} to OCIR\", image);\n+      assertThat(dockerLogin(repoRegistry, repoUserName, repoPassword))\n+          .as(\"Test dockerLogin returns true\")\n+          .withFailMessage(\"docker login failed\")\n+          .isTrue();\n+\n+      assertThat(dockerPush(image))\n+          .as(\"Test dockerPush returns true\")\n+          .withFailMessage(String.format(\"docker push failed for image %s\", image))\n+          .isTrue();\n+\n+      //TO Do: Create docker registry secret\n+    }\n+  }\n+\n+  private void createSecretForDomain(String secretName, String username, String password) {\n+    Map<String, String> secretMap = new HashMap();\n+    secretMap.put(\"username\", username);\n+    secretMap.put(\"password\", password);\n+\n+    try {\n+      assertThat(createSecret(new V1Secret()\n+          .metadata(new V1ObjectMeta()\n+              .name(secretName)\n+              .namespace(domainNamespace))\n+          .stringData(secretMap)))\n+          .as(\"Test createSecret returns true\")\n+          .withFailMessage(\"createSecret failed\")\n+          .isTrue();\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createSecret failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createSecret does not throw an exception\")\n+          .withFailMessage(String.format(\"Create secret %s failed while creating secret \"\n+              + \"for admin credentials\", secretName))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private void createDomain(Domain domain) {\n+    boolean result = false;\n+    try {\n+      result = createDomainCustomResource(domain);\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createDomainCustomResource failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createDomainCustomResource does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"Could not create domain custom resource for domainUID %s in namespace %s\",\n+              domainUID, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    assertThat(result)\n+        .as(\"Test createDomainCustomResource returns true\")\n+        .withFailMessage(String.format(\n+            \"Create domain custom resource failed for domainUID %s in namespace %s\",\n+            domainUID, domainNamespace))\n+        .isTrue();\n+\n+  }\n+\n+  private void checkPodCreated(String podName) {\n+    try {\n+      waitForCondition(podExists(podName, domainUID, domainNamespace));\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"podExists failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that podExists does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"pod %s doesn't exist in namespace %s\", podName, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private void checkPodRunning(String podName) {\n+    try {\n+      waitForCondition(podReady(podName, domainUID, domainNamespace));\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"podReady failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that podReady does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"pod %s is not ready in namespace %s\", podName, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private void checkServiceCreated(String serviceName) {\n+    try {\n+      waitForCondition(serviceReady(serviceName, null, domainNamespace));\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"podExists failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that podExists does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"Service %s is not ready in namespace %s\", serviceName, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private static void waitForCondition(Callable callable) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a01c49b36b56e69612818706a3cd948afc0e225"}, "originalPosition": 544}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMzM3NDYz", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#pullrequestreview-393337463", "createdAt": "2020-04-14T22:23:45Z", "commit": {"oid": "6a01c49b36b56e69612818706a3cd948afc0e225"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjoyMzo0NVrOGFjHJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjoyMzo0NVrOGFjHJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MTMzNA==", "bodyText": "This method can be moved to a utility class so that every IT class can use it.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408471334", "createdAt": "2020-04-14T22:23:45Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -0,0 +1,557 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.logging.Level;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.extensions.Timing;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMIIImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWITParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceReady;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.awaitility.Awaitility.with;\n+\n+// Test to install Operator, create model in image domain and verify the domain\n+// has started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@ExtendWith(Timing.class)\n+class ItMiiDomain implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME_PREFIX = \"mii-image-\";\n+  private static final String MII_IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private String domainUID = \"domain1\";\n+  private String miiImage = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = createSA(opNamespace);\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertThat(installOperator(opParams))\n+        .as(\"Test installOperator returns true\")\n+        .withFailMessage(\"installOperator() did not return true\")\n+        .isTrue();\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    assertThat(helmList(opHelmParams))\n+        .as(\"Test helmList returns true\")\n+        .withFailMessage(\"helmList() did not return true\")\n+        .isTrue();\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    waitForCondition(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUID + \"-admin-server\";\n+    final String managedServerPrefix = domainUID + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImage();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    pushImageToOCIR(miiImage);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretForDomain(adminSecretName, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretForDomain(encryptionSecretName, \"weblogicenc\", \"weblogicenc\");\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUID)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUID)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUID {0} in namespace {1}\",\n+        domainUID, domainNamespace);\n+    createDomain(domain);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    waitForCondition(domainExists(domainUID, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is running\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodRunning(adminServerPodName);\n+\n+    // check managed server pods are running\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodRunning(managedServerPrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+  }\n+\n+  @AfterEach\n+  public void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertThatCode(\n+        () -> deleteDomainCustomResource(domainUID, domainNamespace))\n+        .as(\"Test that deleteDomainCustomResource doesn not throw an exception\")\n+        .withFailMessage(\"delete domain custom resource failed\")\n+        .doesNotThrowAnyException();\n+\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUID + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  /**\n+   * Uninstall Operator, delete service account, domain namespace and\n+   * operator namespace.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+    // uninstall operator release\n+    logger.info(\"Uninstall Operator in namespace {0}\", opNamespace);\n+    if (opHelmParams != null) {\n+      assertThat(uninstallOperator(opHelmParams))\n+          .as(\"Test uninstallOperator returns true\")\n+          .withFailMessage(\"uninstallOperator() did not return true\")\n+          .isTrue();\n+    }\n+\n+    // Delete service account from unique opNamespace\n+    logger.info(\"Delete service account in namespace {0}\", opNamespace);\n+    if (serviceAccount != null) {\n+      assertThatCode(\n+          () -> deleteServiceAccount(serviceAccount.getMetadata().getName(),\n+              serviceAccount.getMetadata().getNamespace()))\n+          .as(\"Test that deleteServiceAccount doesn not throw an exception\")\n+          .withFailMessage(\"deleteServiceAccount() threw an exception\")\n+          .doesNotThrowAnyException();\n+    }\n+    // Delete domain namespaces\n+    logger.info(\"Deleting domain namespace {0}\", domainNamespace);\n+    if (domainNamespace != null) {\n+      assertThatCode(\n+          () -> deleteNamespace(domainNamespace))\n+          .as(\"Test that deleteNamespace doesn not throw an exception\")\n+          .withFailMessage(\"deleteNamespace() threw an exception\")\n+          .doesNotThrowAnyException();\n+      logger.info(\"Deleted namespace: \" + domainNamespace);\n+    }\n+\n+    // Delete opNamespace\n+    logger.info(\"Deleting Operator namespace {0}\", opNamespace);\n+    if (opNamespace != null) {\n+      assertThatCode(\n+          () -> deleteNamespace(opNamespace))\n+          .as(\"Test that deleteNamespace doesn not throw an exception\")\n+          .withFailMessage(\"deleteNamespace() threw an exception\")\n+          .doesNotThrowAnyException();\n+      logger.info(\"Deleted namespace: \" + opNamespace);\n+    }\n+\n+  }\n+\n+  private static String createSA(String namespace) {\n+    final String serviceAccountName = namespace + \"-sa\";\n+    serviceAccount = new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(namespace)\n+                .name(serviceAccountName));\n+\n+    try {\n+      createServiceAccount(serviceAccount);\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createServiceAccount failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createServiceAccount does not throw an exception\")\n+          .withFailMessage(String.format(\"Failed to create service account %s\", serviceAccountName))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    return serviceAccountName;\n+  }\n+\n+  private static String createNamespace() {\n+    String namespace = null;\n+    try {\n+      namespace = createUniqueNamespace();\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createUniqueNamespace failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createUniqueNamespace does not throw an exception\")\n+          .withFailMessage(\"createUniqueNamespace() threw an unexpected exception\")\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    return namespace;\n+  }\n+\n+  private String createImage() {\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    String currentDateTime = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    final String imageName = MII_IMAGE_NAME_PREFIX + currentDateTime;\n+\n+    // build the model file list\n+    List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    boolean archiveBuilt = buildAppArchive(\n+        defaultAppParams()\n+            .srcDir(APP_NAME));\n+\n+    assertThat(archiveBuilt)\n+        .as(\"Create an app archive\")\n+        .withFailMessage(\"Failed to create app archive for \" + APP_NAME)\n+        .isTrue();\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    logger.info(\"Create image {0}:{1} using model directory {2}\",\n+        imageName, MII_IMAGE_TAG, MODEL_DIR);\n+    boolean result = createMIIImage(\n+        defaultWITParams()\n+            .modelImageName(imageName)\n+            .modelImageTag(MII_IMAGE_TAG)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(\"latest\")\n+            .env(env)\n+            .redirect(true));\n+\n+    assertThat(result)\n+        .as(\"Check createMIIImage() returns true\")\n+        .withFailMessage(String.format(\"Failed to create the image %s using WebLogic Image Tool\", imageName))\n+        .isTrue();\n+\n+    // check image exists\n+    assertThat(dockerImageExists(imageName, MII_IMAGE_TAG))\n+        .as(\"Check dockerImageExists() returns true\")\n+        .withFailMessage(String.format(\"Image %s doesn't exist\", imageName + \":\" + MII_IMAGE_TAG))\n+        .isTrue();\n+\n+    return imageName + \":\" + MII_IMAGE_TAG;\n+  }\n+\n+  private void pushImageToOCIR(String image) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a01c49b36b56e69612818706a3cd948afc0e225"}, "originalPosition": 437}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a01c49b36b56e69612818706a3cd948afc0e225", "author": {"user": {"login": "vanajamukkara", "name": "Vanajakshi Mukkara"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/6a01c49b36b56e69612818706a3cd948afc0e225", "committedDate": "2020-04-15T05:11:41Z", "message": "adding mii end to end use case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2886c0368503086460034b099e08c865db10309", "author": {"user": {"login": "vanajamukkara", "name": "Vanajakshi Mukkara"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f2886c0368503086460034b099e08c865db10309", "committedDate": "2020-04-15T06:25:37Z", "message": "same image name, different tag"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzNjc4MDky", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#pullrequestreview-393678092", "createdAt": "2020-04-15T11:15:16Z", "commit": {"oid": "f2886c0368503086460034b099e08c865db10309"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMToxNToxNlrOGF1AqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMToyNDo1MFrOGF1TvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NDU4NA==", "bodyText": "the description above suggests that the installation of the operator is a part of the test - so I think that either you should install the operator in the test itself -or- update the description if the installation is not actually part of the test, but the operator is just a pre-req of th test", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408764584", "createdAt": "2020-04-15T11:15:16Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -0,0 +1,555 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.logging.Level;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.extensions.Timing;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMIIImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWITParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceReady;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.awaitility.Awaitility.with;\n+\n+// Test to install Operator, create model in image domain and verify the domain\n+// has started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@ExtendWith(Timing.class)\n+class ItMiiDomain implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private String domainUID = \"domain1\";\n+  private String miiImage = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2886c0368503086460034b099e08c865db10309"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NTUyOA==", "bodyText": "i thought some more about this overnight, and i think i am actually more strongly concerned with this pattern.  this violates one of my key tenets - i want to be able to read the test and understand what it does.  i think this is repeating a mistake from the past, hiding the assertions away in some other method.  i think we want to stop and think about this before we start doing this again. @ddsharpe @rjeberhard what do you think?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408765528", "createdAt": "2020-04-15T11:17:13Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -0,0 +1,557 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.logging.Level;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.extensions.Timing;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMIIImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWITParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceReady;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.awaitility.Awaitility.with;\n+\n+// Test to install Operator, create model in image domain and verify the domain\n+// has started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@ExtendWith(Timing.class)\n+class ItMiiDomain implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME_PREFIX = \"mii-image-\";\n+  private static final String MII_IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private String domainUID = \"domain1\";\n+  private String miiImage = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = createSA(opNamespace);\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertThat(installOperator(opParams))\n+        .as(\"Test installOperator returns true\")\n+        .withFailMessage(\"installOperator() did not return true\")\n+        .isTrue();\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    assertThat(helmList(opHelmParams))\n+        .as(\"Test helmList returns true\")\n+        .withFailMessage(\"helmList() did not return true\")\n+        .isTrue();\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    waitForCondition(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUID + \"-admin-server\";\n+    final String managedServerPrefix = domainUID + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImage();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0MjczNw=="}, "originalCommit": {"oid": "6a01c49b36b56e69612818706a3cd948afc0e225"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NjU2NA==", "bodyText": "this should be handled by generic code in an extension, that will clean up the namespace(s) used by any test class that is finished", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408766564", "createdAt": "2020-04-15T11:19:04Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -0,0 +1,555 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.logging.Level;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.extensions.Timing;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMIIImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWITParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceReady;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.awaitility.Awaitility.with;\n+\n+// Test to install Operator, create model in image domain and verify the domain\n+// has started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@ExtendWith(Timing.class)\n+class ItMiiDomain implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private String domainUID = \"domain1\";\n+  private String miiImage = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = createSA(opNamespace);\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertThat(installOperator(opParams))\n+        .as(\"Test installOperator returns true\")\n+        .withFailMessage(\"installOperator() did not return true\")\n+        .isTrue();\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    assertThat(helmList(opHelmParams))\n+        .as(\"Test helmList returns true\")\n+        .withFailMessage(\"helmList() did not return true\")\n+        .isTrue();\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    waitForCondition(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUID + \"-admin-server\";\n+    final String managedServerPrefix = domainUID + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImage();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    pushImageToOCIR(miiImage);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretForDomain(adminSecretName, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretForDomain(encryptionSecretName, \"weblogicenc\", \"weblogicenc\");\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUID)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUID)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUID {0} in namespace {1}\",\n+        domainUID, domainNamespace);\n+    createDomain(domain);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    waitForCondition(domainExists(domainUID, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is running\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodRunning(adminServerPodName);\n+\n+    // check managed server pods are running\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodRunning(managedServerPrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+  }\n+\n+  @AfterEach\n+  public void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertThatCode(\n+        () -> deleteDomainCustomResource(domainUID, domainNamespace))\n+        .as(\"Test that deleteDomainCustomResource doesn not throw an exception\")\n+        .withFailMessage(\"delete domain custom resource failed\")\n+        .doesNotThrowAnyException();\n+\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUID + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  /**\n+   * Uninstall Operator, delete service account, domain namespace and\n+   * operator namespace.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+    // uninstall operator release", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2886c0368503086460034b099e08c865db10309"}, "originalPosition": 303}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NzUwMQ==", "bodyText": "this message is too generic - the person reading the output will have no idea what you are waiting for", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408767501", "createdAt": "2020-04-15T11:20:57Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -0,0 +1,555 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.logging.Level;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.extensions.Timing;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMIIImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWITParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceReady;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.awaitility.Awaitility.with;\n+\n+// Test to install Operator, create model in image domain and verify the domain\n+// has started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@ExtendWith(Timing.class)\n+class ItMiiDomain implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private String domainUID = \"domain1\";\n+  private String miiImage = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = createSA(opNamespace);\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertThat(installOperator(opParams))\n+        .as(\"Test installOperator returns true\")\n+        .withFailMessage(\"installOperator() did not return true\")\n+        .isTrue();\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    assertThat(helmList(opHelmParams))\n+        .as(\"Test helmList returns true\")\n+        .withFailMessage(\"helmList() did not return true\")\n+        .isTrue();\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    waitForCondition(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUID + \"-admin-server\";\n+    final String managedServerPrefix = domainUID + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImage();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    pushImageToOCIR(miiImage);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretForDomain(adminSecretName, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretForDomain(encryptionSecretName, \"weblogicenc\", \"weblogicenc\");\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUID)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUID)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUID {0} in namespace {1}\",\n+        domainUID, domainNamespace);\n+    createDomain(domain);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    waitForCondition(domainExists(domainUID, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is running\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodRunning(adminServerPodName);\n+\n+    // check managed server pods are running\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodRunning(managedServerPrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+  }\n+\n+  @AfterEach\n+  public void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertThatCode(\n+        () -> deleteDomainCustomResource(domainUID, domainNamespace))\n+        .as(\"Test that deleteDomainCustomResource doesn not throw an exception\")\n+        .withFailMessage(\"delete domain custom resource failed\")\n+        .doesNotThrowAnyException();\n+\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUID + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  /**\n+   * Uninstall Operator, delete service account, domain namespace and\n+   * operator namespace.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+    // uninstall operator release\n+    logger.info(\"Uninstall Operator in namespace {0}\", opNamespace);\n+    if (opHelmParams != null) {\n+      assertThat(uninstallOperator(opHelmParams))\n+          .as(\"Test uninstallOperator returns true\")\n+          .withFailMessage(\"uninstallOperator() did not return true\")\n+          .isTrue();\n+    }\n+\n+    // Delete service account from unique opNamespace\n+    logger.info(\"Delete service account in namespace {0}\", opNamespace);\n+    if (serviceAccount != null) {\n+      assertThatCode(\n+          () -> deleteServiceAccount(serviceAccount.getMetadata().getName(),\n+              serviceAccount.getMetadata().getNamespace()))\n+          .as(\"Test that deleteServiceAccount doesn not throw an exception\")\n+          .withFailMessage(\"deleteServiceAccount() threw an exception\")\n+          .doesNotThrowAnyException();\n+    }\n+    // Delete domain namespaces\n+    logger.info(\"Deleting domain namespace {0}\", domainNamespace);\n+    if (domainNamespace != null) {\n+      assertThatCode(\n+          () -> deleteNamespace(domainNamespace))\n+          .as(\"Test that deleteNamespace doesn not throw an exception\")\n+          .withFailMessage(\"deleteNamespace() threw an exception\")\n+          .doesNotThrowAnyException();\n+      logger.info(\"Deleted namespace: \" + domainNamespace);\n+    }\n+\n+    // Delete opNamespace\n+    logger.info(\"Deleting Operator namespace {0}\", opNamespace);\n+    if (opNamespace != null) {\n+      assertThatCode(\n+          () -> deleteNamespace(opNamespace))\n+          .as(\"Test that deleteNamespace doesn not throw an exception\")\n+          .withFailMessage(\"deleteNamespace() threw an exception\")\n+          .doesNotThrowAnyException();\n+      logger.info(\"Deleted namespace: \" + opNamespace);\n+    }\n+\n+  }\n+\n+  private static String createSA(String namespace) {\n+    final String serviceAccountName = namespace + \"-sa\";\n+    serviceAccount = new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(namespace)\n+                .name(serviceAccountName));\n+\n+    try {\n+      createServiceAccount(serviceAccount);\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createServiceAccount failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createServiceAccount does not throw an exception\")\n+          .withFailMessage(String.format(\"Failed to create service account %s\", serviceAccountName))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    return serviceAccountName;\n+  }\n+\n+  private static String createNamespace() {\n+    String namespace = null;\n+    try {\n+      namespace = createUniqueNamespace();\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createUniqueNamespace failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createUniqueNamespace does not throw an exception\")\n+          .withFailMessage(\"createUniqueNamespace() threw an unexpected exception\")\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    return namespace;\n+  }\n+\n+  private String createImage() {\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+\n+    // build the model file list\n+    List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    boolean archiveBuilt = buildAppArchive(\n+        defaultAppParams()\n+            .srcDir(APP_NAME));\n+\n+    assertThat(archiveBuilt)\n+        .as(\"Create an app archive\")\n+        .withFailMessage(\"Failed to create app archive for \" + APP_NAME)\n+        .isTrue();\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    logger.info(\"Create image {0}:{1} using model directory {2}\",\n+        MII_IMAGE_NAME, imageTag, MODEL_DIR);\n+    boolean result = createMIIImage(\n+        defaultWITParams()\n+            .modelImageName(MII_IMAGE_NAME)\n+            .modelImageTag(imageTag)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(\"latest\")\n+            .env(env)\n+            .redirect(true));\n+\n+    assertThat(result)\n+        .as(\"Check createMIIImage() returns true\")\n+        .withFailMessage(String.format(\"Failed to create the image %s using WebLogic Image Tool\", MII_IMAGE_NAME))\n+        .isTrue();\n+\n+    // check image exists\n+    assertThat(dockerImageExists(MII_IMAGE_NAME, imageTag))\n+        .as(\"Check dockerImageExists() returns true\")\n+        .withFailMessage(String.format(\"Image %s doesn't exist\", MII_IMAGE_NAME + \":\" + imageTag))\n+        .isTrue();\n+\n+    return MII_IMAGE_NAME + \":\" + imageTag;\n+  }\n+\n+  private void pushImageToOCIR(String image) {\n+    if (System.getenv(\"REPO_REGISTRY\") != null && System.getenv(\"REPO_USERNAME\") != null\n+        && System.getenv(\"REPO_PASSWORD\") != null) {\n+      String repoRegistry = System.getenv(\"REPO_REGISTRY\");\n+      String repoUserName = System.getenv(\"REPO_USERNAME\");\n+      String repoPassword = System.getenv(\"REPO_PASSWORD\");\n+\n+      logger.info(\"Push image {0} to OCIR\", image);\n+      assertThat(dockerLogin(repoRegistry, repoUserName, repoPassword))\n+          .as(\"Test dockerLogin returns true\")\n+          .withFailMessage(\"docker login failed\")\n+          .isTrue();\n+\n+      assertThat(dockerPush(image))\n+          .as(\"Test dockerPush returns true\")\n+          .withFailMessage(String.format(\"docker push failed for image %s\", image))\n+          .isTrue();\n+\n+      //TO Do: Create docker registry secret\n+    }\n+  }\n+\n+  private void createSecretForDomain(String secretName, String username, String password) {\n+    Map<String, String> secretMap = new HashMap();\n+    secretMap.put(\"username\", username);\n+    secretMap.put(\"password\", password);\n+\n+    try {\n+      assertThat(createSecret(new V1Secret()\n+          .metadata(new V1ObjectMeta()\n+              .name(secretName)\n+              .namespace(domainNamespace))\n+          .stringData(secretMap)))\n+          .as(\"Test createSecret returns true\")\n+          .withFailMessage(\"createSecret failed\")\n+          .isTrue();\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createSecret failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createSecret does not throw an exception\")\n+          .withFailMessage(String.format(\"Create secret %s failed while creating secret \"\n+              + \"for admin credentials\", secretName))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private void createDomain(Domain domain) {\n+    boolean result = false;\n+    try {\n+      result = createDomainCustomResource(domain);\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createDomainCustomResource failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createDomainCustomResource does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"Could not create domain custom resource for domainUID %s in namespace %s\",\n+              domainUID, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    assertThat(result)\n+        .as(\"Test createDomainCustomResource returns true\")\n+        .withFailMessage(String.format(\n+            \"Create domain custom resource failed for domainUID %s in namespace %s\",\n+            domainUID, domainNamespace))\n+        .isTrue();\n+\n+  }\n+\n+  private void checkPodCreated(String podName) {\n+    try {\n+      waitForCondition(podExists(podName, domainUID, domainNamespace));\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"podExists failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that podExists does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"pod %s doesn't exist in namespace %s\", podName, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private void checkPodRunning(String podName) {\n+    try {\n+      waitForCondition(podReady(podName, domainUID, domainNamespace));\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"podReady failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that podReady does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"pod %s is not ready in namespace %s\", podName, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private void checkServiceCreated(String serviceName) {\n+    try {\n+      waitForCondition(serviceReady(serviceName, null, domainNamespace));\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"podExists failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that podExists does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"Service %s is not ready in namespace %s\", serviceName, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private static void waitForCondition(Callable callable) {\n+    with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\n+                \"Waiting for a condition to be met (elapsed time {0}ms, remaining time {1}ms)\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2886c0368503086460034b099e08c865db10309"}, "originalPosition": 547}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NzcxNg==", "bodyText": "fix javadoc", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408767716", "createdAt": "2020-04-15T11:21:24Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -438,6 +439,37 @@ public static boolean buildAppArchive(AppParams params) {\n             .build();\n   }\n \n+  // ------------------------ Docker --------------------------------------\n+\n+  /**\n+   * Log in to a Docker registry.\n+   * @param registryName registry name\n+   * @param username user\n+   * @param password password\n+   * @return true if successfull\n+   */\n+  public static boolean dockerLogin(String registryName, String username, String password) {\n+    return Docker.login(registryName, username, password);\n+  }\n+\n+  /**\n+   * Push an image to a registry", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2886c0368503086460034b099e08c865db10309"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2ODExMw==", "bodyText": "no imports?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408768113", "createdAt": "2020-04-15T11:22:18Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Docker.java", "diffHunk": "@@ -0,0 +1,51 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl.primitive;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2886c0368503086460034b099e08c865db10309"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2ODY5Nw==", "bodyText": "what does image mean? is the fully qualified docker image name, including the repository and the tag?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408768697", "createdAt": "2020-04-15T11:23:23Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Docker.java", "diffHunk": "@@ -0,0 +1,51 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl.primitive;\n+\n+\n+public class Docker {\n+\n+  /**\n+   * Log in to a Docker registry.\n+   * @param registryName registry name\n+   * @param username user\n+   * @param password password\n+   * @return true if successfull\n+   */\n+  public static boolean login(String registryName, String username, String password) {\n+    String cmdToExecute = String.format(\"docker login %s -u %s -p \\\"%s\\\"\",\n+        registryName, username, password);\n+    return new Command()\n+        .withParams(new CommandParams()\n+            .command(cmdToExecute))\n+        .execute();\n+  }\n+\n+  /**\n+   * Push an image to a registry\n+   * @param image image", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2886c0368503086460034b099e08c865db10309"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2OTQ2OQ==", "bodyText": "a service can't be \"ready\" - what are you really checking for? that it exists? that is has endpoints?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408769469", "createdAt": "2020-04-15T11:24:50Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -98,17 +98,19 @@\n    * Check is a service exists in given namespace.\n    *\n    * @param serviceName the name of the service to check for\n-   * @param label a Map of key value pairs the service is decorated with\n-   * @param namespace in which the service is running\n+   * @param label       a Map of key value pairs the service is decorated with\n+   * @param namespace   in which the service is running\n    * @return true if the service exists otherwise false\n    * @throws ApiException when query fails\n    */\n-  public static boolean serviceReady(\n+  public static Callable<Boolean> serviceReady(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2886c0368503086460034b099e08c865db10309"}, "originalPosition": 39}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa25ced8965e9bd1324648bc69801d9e02bced9d", "author": {"user": {"login": "vanajamukkara", "name": "Vanajakshi Mukkara"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/aa25ced8965e9bd1324648bc69801d9e02bced9d", "committedDate": "2020-04-16T00:22:38Z", "message": "addressing review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7557f8cc938081795845f55239e98be558b96f03", "author": {"user": {"login": "vanajamukkara", "name": "Vanajakshi Mukkara"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/7557f8cc938081795845f55239e98be558b96f03", "committedDate": "2020-04-16T06:14:18Z", "message": "modified exception handling and creating docker registry secret"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NzI0MDA3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#pullrequestreview-394724007", "createdAt": "2020-04-16T15:01:25Z", "commit": {"oid": "7557f8cc938081795845f55239e98be558b96f03"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NzI2NDg1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#pullrequestreview-394726485", "createdAt": "2020-04-16T15:03:52Z", "commit": {"oid": "7557f8cc938081795845f55239e98be558b96f03"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 39, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}