{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQzMjM1MjM0", "number": 1782, "title": "Converted ItCoherenceTest to use Junit5 jenkins-ignore", "bodyText": "Use case:\nCreate a WebLogic domain with a Coherence cluster and deploying it using WDT\nBuild the Coherence proxy client program which load and verify the cache\nTest rolling restart of Coherence managed servers\nVerify that data are not lost during a domain restart\nThe test passed on kind-new\nhttps://build.weblogick8s.org:8443/job/weblogic-kubernetes-operator-kind-new/676", "createdAt": "2020-07-02T03:25:20Z", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782", "merged": true, "mergeCommit": {"oid": "3dbb35d3a1c2327ef614ba13a59e598a4f7e7c19"}, "closed": true, "closedAt": "2020-07-11T00:56:32Z", "author": {"login": "hzhao-github"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcwwrVCgH2gAyNDQzMjM1MjM0Ojk1ZjQwZjgxNGVhN2FlNWYwMGY0ZTU3MmE0Yjg5Yzk0ZGQxNDQ0NTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABczrBM5gH2gAyNDQzMjM1MjM0OjNlYTIzOWI3YTY0YjU1MjBiMDkzNTI4MzM4ZjE1ZDg4ZTJlN2U4MDM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457", "author": {"user": {"login": "hzhao-github", "name": "Huiling Zhao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/95f40f814ea7ae5f00f4e572a4b89c94dd144457", "committedDate": "2020-07-01T20:57:13Z", "message": "Converted ItCoherenceTest to use Junit5 jenkins-ignore"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxODI0OTIw", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#pullrequestreview-441824920", "createdAt": "2020-07-02T15:55:52Z", "commit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNTo1NTo1M1rOGsT0Yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNTo1NTo1M1rOGsT0Yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExNTIzNQ==", "bodyText": "fix cache spelling", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449115235", "createdAt": "2020-07-02T15:55:53Z", "author": {"login": "bhavaniravichandran"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,403 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests implements LoggedTest {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the catche\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "originalPosition": 167}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxODI1MjQw", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#pullrequestreview-441825240", "createdAt": "2020-07-02T15:56:14Z", "commit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNTo1NjoxNFrOGsT1XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNTo1NjoxNFrOGsT1XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExNTQ4NA==", "bodyText": "fix cache spelling", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449115484", "createdAt": "2020-07-02T15:56:14Z", "author": {"login": "bhavaniravichandran"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,403 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests implements LoggedTest {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the catche\"),\n+        () -> assertTrue(execResult1.stdout().contains(successMarker), \"Failed to load the catche\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "originalPosition": 168}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxODI1ODI5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#pullrequestreview-441825829", "createdAt": "2020-07-02T15:56:57Z", "commit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNTo1Njo1N1rOGsT3Mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNTo1Njo1N1rOGsT3Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExNTk1NQ==", "bodyText": "rollingRestartDomainAndVerify", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449115955", "createdAt": "2020-07-02T15:56:57Z", "author": {"login": "bhavaniravichandran"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,403 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests implements LoggedTest {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the catche\"),\n+        () -> assertTrue(execResult1.stdout().contains(successMarker), \"Failed to load the catche\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_LOAD, execResult1.stdout());\n+\n+    // patch domain to rolling restart it by change restartVersion\n+    roolingRestartDomainAndVerify();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "originalPosition": 175}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxODQ3MDk3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#pullrequestreview-441847097", "createdAt": "2020-07-02T16:23:33Z", "commit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjoyMzozM1rOGsU3KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjoyMzozM1rOGsU3KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzMjMyOQ==", "bodyText": "Check if you can use buildApplication in BuildApplication.java to build your app?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449132329", "createdAt": "2020-07-02T16:23:33Z", "author": {"login": "bhavaniravichandran"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,403 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests implements LoggedTest {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the catche\"),\n+        () -> assertTrue(execResult1.stdout().contains(successMarker), \"Failed to load the catche\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_LOAD, execResult1.stdout());\n+\n+    // patch domain to rolling restart it by change restartVersion\n+    roolingRestartDomainAndVerify();\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to verify the cache contents\n+    final ExecResult execResult2 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_VALIDATE),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to validate the cache\"),\n+        () -> assertTrue(execResult2.stdout().contains(successMarker), \"Failed to validate the cache\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_VALIDATE, execResult2.stdout());\n+\n+    logger.info(\"SUCCESS --- testRollingRestart\");\n+  }\n+\n+  private void copyCohProxyClientAppToPods() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "originalPosition": 198}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxODQ3NjM5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#pullrequestreview-441847639", "createdAt": "2020-07-02T16:24:17Z", "commit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjoyNDoxN1rOGsU4sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjoyNDoxN1rOGsU4sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzMjcyMQ==", "bodyText": "not sure what this comment means.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449132721", "createdAt": "2020-07-02T16:24:17Z", "author": {"login": "bhavaniravichandran"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,403 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests implements LoggedTest {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the catche\"),\n+        () -> assertTrue(execResult1.stdout().contains(successMarker), \"Failed to load the catche\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_LOAD, execResult1.stdout());\n+\n+    // patch domain to rolling restart it by change restartVersion\n+    roolingRestartDomainAndVerify();\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to verify the cache contents\n+    final ExecResult execResult2 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_VALIDATE),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to validate the cache\"),\n+        () -> assertTrue(execResult2.stdout().contains(successMarker), \"Failed to validate the cache\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_VALIDATE, execResult2.stdout());\n+\n+    logger.info(\"SUCCESS --- testRollingRestart\");\n+  }\n+\n+  private void copyCohProxyClientAppToPods() {\n+    List<String> dirsToMake = new ArrayList<String>();\n+    dirsToMake.add(APP_LOC_IN_POD + \"/src/main/java/cohapp\");\n+    dirsToMake.add(APP_LOC_IN_POD + \"/src/main/resources\");\n+\n+    // copy the shell script file and all Coherence app files over to the managed server pods\n+    for (int i = 1; i < replicaCount; i++) {\n+      String serverName = managedServerPrefix + i;\n+      assertDoesNotThrow(\n+          () -> FileUtils.makeDirectories(domainNamespace, serverName,\n+              null, true, dirsToMake),\n+          String.format(\"Failed to create dir %s in pod %s in namespace %s \",\n+              dirsToMake.toString(), serverName, domainNamespace));\n+      logger.info(\"Failed to create dir {0} in Pod {1} in namespace {2} \",\n+          dirsToMake.toString(), serverName, domainNamespace);\n+\n+      assertDoesNotThrow(\n+          () -> FileUtils.copyFolderToPod(domainNamespace, serverName,\n+              containerName, Paths.get(APP_LOC_ON_HOST), Paths.get(APP_LOC_IN_POD)),\n+          String.format(\"Failed to copy file %s to pod %s in namespace %s and located at %s \",\n+              APP_LOC_ON_HOST, serverName, domainNamespace, APP_LOC_IN_POD));\n+      logger.info(\"File {0} copied to {1} to Pod {2} in namespace {3} \",\n+          APP_LOC_ON_HOST, APP_LOC_IN_POD, serverName, domainNamespace);\n+    }\n+  }\n+\n+  private ExecResult runCoherenceProxyClient(String serverName, String cacheOp\n+  ) throws IOException, ApiException, InterruptedException {\n+\n+    // build the proxy client in the pod and run the proxy test.\n+    final String coherenceScriptPathInPod = APP_LOC_IN_POD + \"/\" + PROXY_CLIENT_SCRIPT;\n+\n+    String serverPodIP = assertDoesNotThrow(\n+        () -> getPodIP(domainNamespace, \"\", serverName),\n+        String.format(\"Get pod IP address failed with ApiException for %s in namespace %s\",\n+            serverName, domainNamespace));\n+    logger.info(\"Admin Pod IP {0} \", serverPodIP);\n+\n+\n+    StringBuffer coherenceProxyClientCmd = new StringBuffer(\"chmod +x -R \");\n+    coherenceProxyClientCmd\n+        .append(APP_LOC_IN_POD)\n+        .append(\" && sh \")\n+        .append(coherenceScriptPathInPod)\n+        .append(\" \")\n+        .append(APP_LOC_IN_POD)\n+        .append(\" \")\n+        .append(cacheOp)\n+        .append(\" \")\n+        .append(serverPodIP)\n+        .append(\" \")\n+        .append(PROXY_PORT);\n+\n+    logger.info(\"Command to exec script file: \" + coherenceProxyClientCmd);\n+\n+    ExecResult execResult =\n+        execCommand(domainNamespace, serverName, containerName, true,\n+            \"/bin/sh\", \"-c\", coherenceProxyClientCmd.toString());\n+\n+    logger.info(\"\\n Coherence proxy client returns \\n \" + execResult.stdout());\n+\n+    return execResult;\n+  }\n+\n+  private static String createAndVerifyDomainImage() {\n+    // create image with model files\n+    logger.info(\"Create image with model file and verify\");\n+    // build the model file list", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "originalPosition": 265}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxODUwOTU1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#pullrequestreview-441850955", "createdAt": "2020-07-02T16:28:41Z", "commit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjoyODo0MVrOGsVCvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjoyODo0MVrOGsVCvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNTI5NQ==", "bodyText": "Not necessary. PodReady checks both.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449135295", "createdAt": "2020-07-02T16:28:41Z", "author": {"login": "bhavaniravichandran"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,403 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests implements LoggedTest {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the catche\"),\n+        () -> assertTrue(execResult1.stdout().contains(successMarker), \"Failed to load the catche\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_LOAD, execResult1.stdout());\n+\n+    // patch domain to rolling restart it by change restartVersion\n+    roolingRestartDomainAndVerify();\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to verify the cache contents\n+    final ExecResult execResult2 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_VALIDATE),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to validate the cache\"),\n+        () -> assertTrue(execResult2.stdout().contains(successMarker), \"Failed to validate the cache\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_VALIDATE, execResult2.stdout());\n+\n+    logger.info(\"SUCCESS --- testRollingRestart\");\n+  }\n+\n+  private void copyCohProxyClientAppToPods() {\n+    List<String> dirsToMake = new ArrayList<String>();\n+    dirsToMake.add(APP_LOC_IN_POD + \"/src/main/java/cohapp\");\n+    dirsToMake.add(APP_LOC_IN_POD + \"/src/main/resources\");\n+\n+    // copy the shell script file and all Coherence app files over to the managed server pods\n+    for (int i = 1; i < replicaCount; i++) {\n+      String serverName = managedServerPrefix + i;\n+      assertDoesNotThrow(\n+          () -> FileUtils.makeDirectories(domainNamespace, serverName,\n+              null, true, dirsToMake),\n+          String.format(\"Failed to create dir %s in pod %s in namespace %s \",\n+              dirsToMake.toString(), serverName, domainNamespace));\n+      logger.info(\"Failed to create dir {0} in Pod {1} in namespace {2} \",\n+          dirsToMake.toString(), serverName, domainNamespace);\n+\n+      assertDoesNotThrow(\n+          () -> FileUtils.copyFolderToPod(domainNamespace, serverName,\n+              containerName, Paths.get(APP_LOC_ON_HOST), Paths.get(APP_LOC_IN_POD)),\n+          String.format(\"Failed to copy file %s to pod %s in namespace %s and located at %s \",\n+              APP_LOC_ON_HOST, serverName, domainNamespace, APP_LOC_IN_POD));\n+      logger.info(\"File {0} copied to {1} to Pod {2} in namespace {3} \",\n+          APP_LOC_ON_HOST, APP_LOC_IN_POD, serverName, domainNamespace);\n+    }\n+  }\n+\n+  private ExecResult runCoherenceProxyClient(String serverName, String cacheOp\n+  ) throws IOException, ApiException, InterruptedException {\n+\n+    // build the proxy client in the pod and run the proxy test.\n+    final String coherenceScriptPathInPod = APP_LOC_IN_POD + \"/\" + PROXY_CLIENT_SCRIPT;\n+\n+    String serverPodIP = assertDoesNotThrow(\n+        () -> getPodIP(domainNamespace, \"\", serverName),\n+        String.format(\"Get pod IP address failed with ApiException for %s in namespace %s\",\n+            serverName, domainNamespace));\n+    logger.info(\"Admin Pod IP {0} \", serverPodIP);\n+\n+\n+    StringBuffer coherenceProxyClientCmd = new StringBuffer(\"chmod +x -R \");\n+    coherenceProxyClientCmd\n+        .append(APP_LOC_IN_POD)\n+        .append(\" && sh \")\n+        .append(coherenceScriptPathInPod)\n+        .append(\" \")\n+        .append(APP_LOC_IN_POD)\n+        .append(\" \")\n+        .append(cacheOp)\n+        .append(\" \")\n+        .append(serverPodIP)\n+        .append(\" \")\n+        .append(PROXY_PORT);\n+\n+    logger.info(\"Command to exec script file: \" + coherenceProxyClientCmd);\n+\n+    ExecResult execResult =\n+        execCommand(domainNamespace, serverName, containerName, true,\n+            \"/bin/sh\", \"-c\", coherenceProxyClientCmd.toString());\n+\n+    logger.info(\"\\n Coherence proxy client returns \\n \" + execResult.stdout());\n+\n+    return execResult;\n+  }\n+\n+  private static String createAndVerifyDomainImage() {\n+    // create image with model files\n+    logger.info(\"Create image with model file and verify\");\n+    // build the model file list\n+    String miiImage = createImageAndVerify(\n+        COHERENCE_IMAGE_NAME, COHERENCE_MODEL_FILE,\n+            PROXY_SERVER_APP_NAME, COHERENCE_MODEL_PROP, domainUid);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Create docker registry secret in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+        String.format(\"create Docker Registry Secret failed for %s\", REPO_SECRET_NAME));\n+\n+    return miiImage;\n+  }\n+\n+  private static void createAndVerifyDomain(String miiImage) {\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(adminSecretName, domainNamespace,\n+        \"weblogic\", \"welcome1\"),\n+        String.format(\"create secret for admin credentials failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(encryptionSecretName, domainNamespace,\n+        \"weblogicenc\", \"weblogicenc\"),\n+        String.format(\"create encryption secret failed for %s\", encryptionSecretName));\n+\n+    // create domain and verify\n+    logger.info(\"Create model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainCrAndVerify(adminSecretName, miiImage);\n+\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodExists(adminServerPodName, domainUid, domainNamespace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "originalPosition": 304}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxODUxNDky", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#pullrequestreview-441851492", "createdAt": "2020-07-02T16:29:25Z", "commit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjoyOToyNVrOGsVEcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjoyOToyNVrOGsVEcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNTcyOQ==", "bodyText": "Check service check before pod ready check.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449135729", "createdAt": "2020-07-02T16:29:25Z", "author": {"login": "bhavaniravichandran"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,403 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests implements LoggedTest {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the catche\"),\n+        () -> assertTrue(execResult1.stdout().contains(successMarker), \"Failed to load the catche\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_LOAD, execResult1.stdout());\n+\n+    // patch domain to rolling restart it by change restartVersion\n+    roolingRestartDomainAndVerify();\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to verify the cache contents\n+    final ExecResult execResult2 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_VALIDATE),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to validate the cache\"),\n+        () -> assertTrue(execResult2.stdout().contains(successMarker), \"Failed to validate the cache\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_VALIDATE, execResult2.stdout());\n+\n+    logger.info(\"SUCCESS --- testRollingRestart\");\n+  }\n+\n+  private void copyCohProxyClientAppToPods() {\n+    List<String> dirsToMake = new ArrayList<String>();\n+    dirsToMake.add(APP_LOC_IN_POD + \"/src/main/java/cohapp\");\n+    dirsToMake.add(APP_LOC_IN_POD + \"/src/main/resources\");\n+\n+    // copy the shell script file and all Coherence app files over to the managed server pods\n+    for (int i = 1; i < replicaCount; i++) {\n+      String serverName = managedServerPrefix + i;\n+      assertDoesNotThrow(\n+          () -> FileUtils.makeDirectories(domainNamespace, serverName,\n+              null, true, dirsToMake),\n+          String.format(\"Failed to create dir %s in pod %s in namespace %s \",\n+              dirsToMake.toString(), serverName, domainNamespace));\n+      logger.info(\"Failed to create dir {0} in Pod {1} in namespace {2} \",\n+          dirsToMake.toString(), serverName, domainNamespace);\n+\n+      assertDoesNotThrow(\n+          () -> FileUtils.copyFolderToPod(domainNamespace, serverName,\n+              containerName, Paths.get(APP_LOC_ON_HOST), Paths.get(APP_LOC_IN_POD)),\n+          String.format(\"Failed to copy file %s to pod %s in namespace %s and located at %s \",\n+              APP_LOC_ON_HOST, serverName, domainNamespace, APP_LOC_IN_POD));\n+      logger.info(\"File {0} copied to {1} to Pod {2} in namespace {3} \",\n+          APP_LOC_ON_HOST, APP_LOC_IN_POD, serverName, domainNamespace);\n+    }\n+  }\n+\n+  private ExecResult runCoherenceProxyClient(String serverName, String cacheOp\n+  ) throws IOException, ApiException, InterruptedException {\n+\n+    // build the proxy client in the pod and run the proxy test.\n+    final String coherenceScriptPathInPod = APP_LOC_IN_POD + \"/\" + PROXY_CLIENT_SCRIPT;\n+\n+    String serverPodIP = assertDoesNotThrow(\n+        () -> getPodIP(domainNamespace, \"\", serverName),\n+        String.format(\"Get pod IP address failed with ApiException for %s in namespace %s\",\n+            serverName, domainNamespace));\n+    logger.info(\"Admin Pod IP {0} \", serverPodIP);\n+\n+\n+    StringBuffer coherenceProxyClientCmd = new StringBuffer(\"chmod +x -R \");\n+    coherenceProxyClientCmd\n+        .append(APP_LOC_IN_POD)\n+        .append(\" && sh \")\n+        .append(coherenceScriptPathInPod)\n+        .append(\" \")\n+        .append(APP_LOC_IN_POD)\n+        .append(\" \")\n+        .append(cacheOp)\n+        .append(\" \")\n+        .append(serverPodIP)\n+        .append(\" \")\n+        .append(PROXY_PORT);\n+\n+    logger.info(\"Command to exec script file: \" + coherenceProxyClientCmd);\n+\n+    ExecResult execResult =\n+        execCommand(domainNamespace, serverName, containerName, true,\n+            \"/bin/sh\", \"-c\", coherenceProxyClientCmd.toString());\n+\n+    logger.info(\"\\n Coherence proxy client returns \\n \" + execResult.stdout());\n+\n+    return execResult;\n+  }\n+\n+  private static String createAndVerifyDomainImage() {\n+    // create image with model files\n+    logger.info(\"Create image with model file and verify\");\n+    // build the model file list\n+    String miiImage = createImageAndVerify(\n+        COHERENCE_IMAGE_NAME, COHERENCE_MODEL_FILE,\n+            PROXY_SERVER_APP_NAME, COHERENCE_MODEL_PROP, domainUid);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Create docker registry secret in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+        String.format(\"create Docker Registry Secret failed for %s\", REPO_SECRET_NAME));\n+\n+    return miiImage;\n+  }\n+\n+  private static void createAndVerifyDomain(String miiImage) {\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(adminSecretName, domainNamespace,\n+        \"weblogic\", \"welcome1\"),\n+        String.format(\"create secret for admin credentials failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(encryptionSecretName, domainNamespace,\n+        \"weblogicenc\", \"weblogicenc\"),\n+        String.format(\"create encryption secret failed for %s\", encryptionSecretName));\n+\n+    // create domain and verify\n+    logger.info(\"Create model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainCrAndVerify(adminSecretName, miiImage);\n+\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin server pod is ready\n+    logger.info(\"Checking that admin server pod {0} is ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin service exists in the domain namespace\n+    logger.info(\"Checking that admin service {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "originalPosition": 314}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxODUxODU5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#pullrequestreview-441851859", "createdAt": "2020-07-02T16:29:54Z", "commit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjoyOTo1NFrOGsVFhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjoyOTo1NFrOGsVFhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNjAwNQ==", "bodyText": "not needed - same comment as earlier", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449136005", "createdAt": "2020-07-02T16:29:54Z", "author": {"login": "bhavaniravichandran"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,403 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests implements LoggedTest {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the catche\"),\n+        () -> assertTrue(execResult1.stdout().contains(successMarker), \"Failed to load the catche\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_LOAD, execResult1.stdout());\n+\n+    // patch domain to rolling restart it by change restartVersion\n+    roolingRestartDomainAndVerify();\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to verify the cache contents\n+    final ExecResult execResult2 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_VALIDATE),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to validate the cache\"),\n+        () -> assertTrue(execResult2.stdout().contains(successMarker), \"Failed to validate the cache\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_VALIDATE, execResult2.stdout());\n+\n+    logger.info(\"SUCCESS --- testRollingRestart\");\n+  }\n+\n+  private void copyCohProxyClientAppToPods() {\n+    List<String> dirsToMake = new ArrayList<String>();\n+    dirsToMake.add(APP_LOC_IN_POD + \"/src/main/java/cohapp\");\n+    dirsToMake.add(APP_LOC_IN_POD + \"/src/main/resources\");\n+\n+    // copy the shell script file and all Coherence app files over to the managed server pods\n+    for (int i = 1; i < replicaCount; i++) {\n+      String serverName = managedServerPrefix + i;\n+      assertDoesNotThrow(\n+          () -> FileUtils.makeDirectories(domainNamespace, serverName,\n+              null, true, dirsToMake),\n+          String.format(\"Failed to create dir %s in pod %s in namespace %s \",\n+              dirsToMake.toString(), serverName, domainNamespace));\n+      logger.info(\"Failed to create dir {0} in Pod {1} in namespace {2} \",\n+          dirsToMake.toString(), serverName, domainNamespace);\n+\n+      assertDoesNotThrow(\n+          () -> FileUtils.copyFolderToPod(domainNamespace, serverName,\n+              containerName, Paths.get(APP_LOC_ON_HOST), Paths.get(APP_LOC_IN_POD)),\n+          String.format(\"Failed to copy file %s to pod %s in namespace %s and located at %s \",\n+              APP_LOC_ON_HOST, serverName, domainNamespace, APP_LOC_IN_POD));\n+      logger.info(\"File {0} copied to {1} to Pod {2} in namespace {3} \",\n+          APP_LOC_ON_HOST, APP_LOC_IN_POD, serverName, domainNamespace);\n+    }\n+  }\n+\n+  private ExecResult runCoherenceProxyClient(String serverName, String cacheOp\n+  ) throws IOException, ApiException, InterruptedException {\n+\n+    // build the proxy client in the pod and run the proxy test.\n+    final String coherenceScriptPathInPod = APP_LOC_IN_POD + \"/\" + PROXY_CLIENT_SCRIPT;\n+\n+    String serverPodIP = assertDoesNotThrow(\n+        () -> getPodIP(domainNamespace, \"\", serverName),\n+        String.format(\"Get pod IP address failed with ApiException for %s in namespace %s\",\n+            serverName, domainNamespace));\n+    logger.info(\"Admin Pod IP {0} \", serverPodIP);\n+\n+\n+    StringBuffer coherenceProxyClientCmd = new StringBuffer(\"chmod +x -R \");\n+    coherenceProxyClientCmd\n+        .append(APP_LOC_IN_POD)\n+        .append(\" && sh \")\n+        .append(coherenceScriptPathInPod)\n+        .append(\" \")\n+        .append(APP_LOC_IN_POD)\n+        .append(\" \")\n+        .append(cacheOp)\n+        .append(\" \")\n+        .append(serverPodIP)\n+        .append(\" \")\n+        .append(PROXY_PORT);\n+\n+    logger.info(\"Command to exec script file: \" + coherenceProxyClientCmd);\n+\n+    ExecResult execResult =\n+        execCommand(domainNamespace, serverName, containerName, true,\n+            \"/bin/sh\", \"-c\", coherenceProxyClientCmd.toString());\n+\n+    logger.info(\"\\n Coherence proxy client returns \\n \" + execResult.stdout());\n+\n+    return execResult;\n+  }\n+\n+  private static String createAndVerifyDomainImage() {\n+    // create image with model files\n+    logger.info(\"Create image with model file and verify\");\n+    // build the model file list\n+    String miiImage = createImageAndVerify(\n+        COHERENCE_IMAGE_NAME, COHERENCE_MODEL_FILE,\n+            PROXY_SERVER_APP_NAME, COHERENCE_MODEL_PROP, domainUid);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Create docker registry secret in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+        String.format(\"create Docker Registry Secret failed for %s\", REPO_SECRET_NAME));\n+\n+    return miiImage;\n+  }\n+\n+  private static void createAndVerifyDomain(String miiImage) {\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(adminSecretName, domainNamespace,\n+        \"weblogic\", \"welcome1\"),\n+        String.format(\"create secret for admin credentials failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(encryptionSecretName, domainNamespace,\n+        \"weblogicenc\", \"weblogicenc\"),\n+        String.format(\"create encryption secret failed for %s\", encryptionSecretName));\n+\n+    // create domain and verify\n+    logger.info(\"Create model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainCrAndVerify(adminSecretName, miiImage);\n+\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin server pod is ready\n+    logger.info(\"Checking that admin server pod {0} is ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin service exists in the domain namespace\n+    logger.info(\"Checking that admin service {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // check for managed server pods existence in the domain namespace\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = managedServerPrefix + i;\n+\n+      // check that the managed server pod exists\n+      logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodExists(managedServerPodName, domainUid, domainNamespace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "originalPosition": 323}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxODUyMDY5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#pullrequestreview-441852069", "createdAt": "2020-07-02T16:30:11Z", "commit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjozMDoxMVrOGsVGMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjozMDoxMVrOGsVGMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNjE3OA==", "bodyText": "move this before pod ready check.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449136178", "createdAt": "2020-07-02T16:30:11Z", "author": {"login": "bhavaniravichandran"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,403 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests implements LoggedTest {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the catche\"),\n+        () -> assertTrue(execResult1.stdout().contains(successMarker), \"Failed to load the catche\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_LOAD, execResult1.stdout());\n+\n+    // patch domain to rolling restart it by change restartVersion\n+    roolingRestartDomainAndVerify();\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to verify the cache contents\n+    final ExecResult execResult2 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_VALIDATE),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to validate the cache\"),\n+        () -> assertTrue(execResult2.stdout().contains(successMarker), \"Failed to validate the cache\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_VALIDATE, execResult2.stdout());\n+\n+    logger.info(\"SUCCESS --- testRollingRestart\");\n+  }\n+\n+  private void copyCohProxyClientAppToPods() {\n+    List<String> dirsToMake = new ArrayList<String>();\n+    dirsToMake.add(APP_LOC_IN_POD + \"/src/main/java/cohapp\");\n+    dirsToMake.add(APP_LOC_IN_POD + \"/src/main/resources\");\n+\n+    // copy the shell script file and all Coherence app files over to the managed server pods\n+    for (int i = 1; i < replicaCount; i++) {\n+      String serverName = managedServerPrefix + i;\n+      assertDoesNotThrow(\n+          () -> FileUtils.makeDirectories(domainNamespace, serverName,\n+              null, true, dirsToMake),\n+          String.format(\"Failed to create dir %s in pod %s in namespace %s \",\n+              dirsToMake.toString(), serverName, domainNamespace));\n+      logger.info(\"Failed to create dir {0} in Pod {1} in namespace {2} \",\n+          dirsToMake.toString(), serverName, domainNamespace);\n+\n+      assertDoesNotThrow(\n+          () -> FileUtils.copyFolderToPod(domainNamespace, serverName,\n+              containerName, Paths.get(APP_LOC_ON_HOST), Paths.get(APP_LOC_IN_POD)),\n+          String.format(\"Failed to copy file %s to pod %s in namespace %s and located at %s \",\n+              APP_LOC_ON_HOST, serverName, domainNamespace, APP_LOC_IN_POD));\n+      logger.info(\"File {0} copied to {1} to Pod {2} in namespace {3} \",\n+          APP_LOC_ON_HOST, APP_LOC_IN_POD, serverName, domainNamespace);\n+    }\n+  }\n+\n+  private ExecResult runCoherenceProxyClient(String serverName, String cacheOp\n+  ) throws IOException, ApiException, InterruptedException {\n+\n+    // build the proxy client in the pod and run the proxy test.\n+    final String coherenceScriptPathInPod = APP_LOC_IN_POD + \"/\" + PROXY_CLIENT_SCRIPT;\n+\n+    String serverPodIP = assertDoesNotThrow(\n+        () -> getPodIP(domainNamespace, \"\", serverName),\n+        String.format(\"Get pod IP address failed with ApiException for %s in namespace %s\",\n+            serverName, domainNamespace));\n+    logger.info(\"Admin Pod IP {0} \", serverPodIP);\n+\n+\n+    StringBuffer coherenceProxyClientCmd = new StringBuffer(\"chmod +x -R \");\n+    coherenceProxyClientCmd\n+        .append(APP_LOC_IN_POD)\n+        .append(\" && sh \")\n+        .append(coherenceScriptPathInPod)\n+        .append(\" \")\n+        .append(APP_LOC_IN_POD)\n+        .append(\" \")\n+        .append(cacheOp)\n+        .append(\" \")\n+        .append(serverPodIP)\n+        .append(\" \")\n+        .append(PROXY_PORT);\n+\n+    logger.info(\"Command to exec script file: \" + coherenceProxyClientCmd);\n+\n+    ExecResult execResult =\n+        execCommand(domainNamespace, serverName, containerName, true,\n+            \"/bin/sh\", \"-c\", coherenceProxyClientCmd.toString());\n+\n+    logger.info(\"\\n Coherence proxy client returns \\n \" + execResult.stdout());\n+\n+    return execResult;\n+  }\n+\n+  private static String createAndVerifyDomainImage() {\n+    // create image with model files\n+    logger.info(\"Create image with model file and verify\");\n+    // build the model file list\n+    String miiImage = createImageAndVerify(\n+        COHERENCE_IMAGE_NAME, COHERENCE_MODEL_FILE,\n+            PROXY_SERVER_APP_NAME, COHERENCE_MODEL_PROP, domainUid);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Create docker registry secret in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+        String.format(\"create Docker Registry Secret failed for %s\", REPO_SECRET_NAME));\n+\n+    return miiImage;\n+  }\n+\n+  private static void createAndVerifyDomain(String miiImage) {\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(adminSecretName, domainNamespace,\n+        \"weblogic\", \"welcome1\"),\n+        String.format(\"create secret for admin credentials failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(encryptionSecretName, domainNamespace,\n+        \"weblogicenc\", \"weblogicenc\"),\n+        String.format(\"create encryption secret failed for %s\", encryptionSecretName));\n+\n+    // create domain and verify\n+    logger.info(\"Create model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainCrAndVerify(adminSecretName, miiImage);\n+\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin server pod is ready\n+    logger.info(\"Checking that admin server pod {0} is ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin service exists in the domain namespace\n+    logger.info(\"Checking that admin service {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // check for managed server pods existence in the domain namespace\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = managedServerPrefix + i;\n+\n+      // check that the managed server pod exists\n+      logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodExists(managedServerPodName, domainUid, domainNamespace);\n+\n+      // check that the managed server pod is ready\n+      logger.info(\"Checking that managed server pod {0} is ready in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodReady(managedServerPodName, domainUid, domainNamespace);\n+\n+      // check that the managed server service exists in the domain namespace\n+      logger.info(\"Checking that managed server service {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkServiceExists(managedServerPodName, domainNamespace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "originalPosition": 333}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxODUyODI2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#pullrequestreview-441852826", "createdAt": "2020-07-02T16:31:11Z", "commit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjozMToxMVrOGsVIjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjozMToxMVrOGsVIjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNjc4MQ==", "bodyText": "spelling - rolling", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449136781", "createdAt": "2020-07-02T16:31:11Z", "author": {"login": "bhavaniravichandran"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,403 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests implements LoggedTest {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the catche\"),\n+        () -> assertTrue(execResult1.stdout().contains(successMarker), \"Failed to load the catche\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_LOAD, execResult1.stdout());\n+\n+    // patch domain to rolling restart it by change restartVersion\n+    roolingRestartDomainAndVerify();\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to verify the cache contents\n+    final ExecResult execResult2 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_VALIDATE),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to validate the cache\"),\n+        () -> assertTrue(execResult2.stdout().contains(successMarker), \"Failed to validate the cache\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_VALIDATE, execResult2.stdout());\n+\n+    logger.info(\"SUCCESS --- testRollingRestart\");\n+  }\n+\n+  private void copyCohProxyClientAppToPods() {\n+    List<String> dirsToMake = new ArrayList<String>();\n+    dirsToMake.add(APP_LOC_IN_POD + \"/src/main/java/cohapp\");\n+    dirsToMake.add(APP_LOC_IN_POD + \"/src/main/resources\");\n+\n+    // copy the shell script file and all Coherence app files over to the managed server pods\n+    for (int i = 1; i < replicaCount; i++) {\n+      String serverName = managedServerPrefix + i;\n+      assertDoesNotThrow(\n+          () -> FileUtils.makeDirectories(domainNamespace, serverName,\n+              null, true, dirsToMake),\n+          String.format(\"Failed to create dir %s in pod %s in namespace %s \",\n+              dirsToMake.toString(), serverName, domainNamespace));\n+      logger.info(\"Failed to create dir {0} in Pod {1} in namespace {2} \",\n+          dirsToMake.toString(), serverName, domainNamespace);\n+\n+      assertDoesNotThrow(\n+          () -> FileUtils.copyFolderToPod(domainNamespace, serverName,\n+              containerName, Paths.get(APP_LOC_ON_HOST), Paths.get(APP_LOC_IN_POD)),\n+          String.format(\"Failed to copy file %s to pod %s in namespace %s and located at %s \",\n+              APP_LOC_ON_HOST, serverName, domainNamespace, APP_LOC_IN_POD));\n+      logger.info(\"File {0} copied to {1} to Pod {2} in namespace {3} \",\n+          APP_LOC_ON_HOST, APP_LOC_IN_POD, serverName, domainNamespace);\n+    }\n+  }\n+\n+  private ExecResult runCoherenceProxyClient(String serverName, String cacheOp\n+  ) throws IOException, ApiException, InterruptedException {\n+\n+    // build the proxy client in the pod and run the proxy test.\n+    final String coherenceScriptPathInPod = APP_LOC_IN_POD + \"/\" + PROXY_CLIENT_SCRIPT;\n+\n+    String serverPodIP = assertDoesNotThrow(\n+        () -> getPodIP(domainNamespace, \"\", serverName),\n+        String.format(\"Get pod IP address failed with ApiException for %s in namespace %s\",\n+            serverName, domainNamespace));\n+    logger.info(\"Admin Pod IP {0} \", serverPodIP);\n+\n+\n+    StringBuffer coherenceProxyClientCmd = new StringBuffer(\"chmod +x -R \");\n+    coherenceProxyClientCmd\n+        .append(APP_LOC_IN_POD)\n+        .append(\" && sh \")\n+        .append(coherenceScriptPathInPod)\n+        .append(\" \")\n+        .append(APP_LOC_IN_POD)\n+        .append(\" \")\n+        .append(cacheOp)\n+        .append(\" \")\n+        .append(serverPodIP)\n+        .append(\" \")\n+        .append(PROXY_PORT);\n+\n+    logger.info(\"Command to exec script file: \" + coherenceProxyClientCmd);\n+\n+    ExecResult execResult =\n+        execCommand(domainNamespace, serverName, containerName, true,\n+            \"/bin/sh\", \"-c\", coherenceProxyClientCmd.toString());\n+\n+    logger.info(\"\\n Coherence proxy client returns \\n \" + execResult.stdout());\n+\n+    return execResult;\n+  }\n+\n+  private static String createAndVerifyDomainImage() {\n+    // create image with model files\n+    logger.info(\"Create image with model file and verify\");\n+    // build the model file list\n+    String miiImage = createImageAndVerify(\n+        COHERENCE_IMAGE_NAME, COHERENCE_MODEL_FILE,\n+            PROXY_SERVER_APP_NAME, COHERENCE_MODEL_PROP, domainUid);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Create docker registry secret in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+        String.format(\"create Docker Registry Secret failed for %s\", REPO_SECRET_NAME));\n+\n+    return miiImage;\n+  }\n+\n+  private static void createAndVerifyDomain(String miiImage) {\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(adminSecretName, domainNamespace,\n+        \"weblogic\", \"welcome1\"),\n+        String.format(\"create secret for admin credentials failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(encryptionSecretName, domainNamespace,\n+        \"weblogicenc\", \"weblogicenc\"),\n+        String.format(\"create encryption secret failed for %s\", encryptionSecretName));\n+\n+    // create domain and verify\n+    logger.info(\"Create model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainCrAndVerify(adminSecretName, miiImage);\n+\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin server pod is ready\n+    logger.info(\"Checking that admin server pod {0} is ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin service exists in the domain namespace\n+    logger.info(\"Checking that admin service {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // check for managed server pods existence in the domain namespace\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = managedServerPrefix + i;\n+\n+      // check that the managed server pod exists\n+      logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodExists(managedServerPodName, domainUid, domainNamespace);\n+\n+      // check that the managed server pod is ready\n+      logger.info(\"Checking that managed server pod {0} is ready in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodReady(managedServerPodName, domainUid, domainNamespace);\n+\n+      // check that the managed server service exists in the domain namespace\n+      logger.info(\"Checking that managed server service {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkServiceExists(managedServerPodName, domainNamespace);\n+    }\n+  }\n+\n+  private static void createDomainCrAndVerify(String adminSecretName, String miiImage) {\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"Image\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\"))\n+                .introspectorJobActiveDeadlineSeconds(300L)));\n+\n+    logger.info(\"Create domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    boolean domCreated = assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+    assertTrue(domCreated, String.format(\"Create domain custom resource failed with ApiException \"\n+        + \"for %s in namespace %s\", domainUid, domainNamespace));\n+  }\n+\n+  private void roolingRestartDomainAndVerify() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "originalPosition": 387}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxODU3NDcx", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#pullrequestreview-441857471", "createdAt": "2020-07-02T16:37:21Z", "commit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjozNzoyMlrOGsVWuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjozNzoyMlrOGsVWuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0MDQxMQ==", "bodyText": "I think you can use buildApplication() in BuildApplication.java for this.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449140411", "createdAt": "2020-07-02T16:37:22Z", "author": {"login": "bhavaniravichandran"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/AppBuilder.java", "diffHunk": "@@ -97,6 +97,39 @@ public boolean build() {\n     return jarBuilt && zipBuilt;\n   }\n \n+  /**\n+   * Build an application archive using a pre-populated AppParams instance.\n+   * @return true if the command succeeds\n+   */\n+  public boolean buildCoherence() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxODU4NDMy", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#pullrequestreview-441858432", "createdAt": "2020-07-02T16:38:45Z", "commit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjozODo0NVrOGsVZeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjozODo0NVrOGsVZeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0MTExMg==", "bodyText": "Can you check if the existing method to build the archive be used?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449141112", "createdAt": "2020-07-02T16:38:45Z", "author": {"login": "bhavaniravichandran"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/AppBuilder.java", "diffHunk": "@@ -146,6 +179,32 @@ public boolean buildZipArchive(\n         .execute();\n   }\n \n+  /**\n+   * Build a zip archive that includes coh-proxy-server.gar in the srcDir.\n+   *\n+   * @param zipPath zip file path for the resulting archive\n+   * @param srcDir source directory\n+   */\n+  public boolean buildCoherenceZipArchive(String zipPath, String srcDir) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxODU5MTcy", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#pullrequestreview-441859172", "createdAt": "2020-07-02T16:39:49Z", "commit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjozOTo0OVrOGsVb0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjozOTo0OVrOGsVb0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0MTcxNA==", "bodyText": "remove the 2 lines above", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449141714", "createdAt": "2020-07-02T16:39:49Z", "author": {"login": "bhavaniravichandran"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/FileUtils.java", "diffHunk": "@@ -23,7 +25,10 @@\n import oracle.weblogic.kubernetes.logging.LoggingFactory;\n \n import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n import static org.apache.commons.io.FileUtils.cleanDirectory;\n+//import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+//import static org.junit.jupiter.api.Assertions.fail;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxODY4MjY3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#pullrequestreview-441868267", "createdAt": "2020-07-02T16:52:42Z", "commit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjo1Mjo0MlrOGsV29A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjo1Mjo0MlrOGsV29A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0ODY2MA==", "bodyText": "copyright missing", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449148660", "createdAt": "2020-07-02T16:52:42Z", "author": {"login": "bhavaniravichandran"}, "path": "new-integration-tests/src/test/resources/wdt-models/coherence-wdt-config.yaml", "diffHunk": "@@ -0,0 +1,53 @@\n+domainInfo:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxODY4NTQ2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#pullrequestreview-441868546", "createdAt": "2020-07-02T16:53:08Z", "commit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjo1MzowOFrOGsV39Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjo1MzowOFrOGsV39Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0ODkxNw==", "bodyText": "copyright missing", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449148917", "createdAt": "2020-07-02T16:53:08Z", "author": {"login": "bhavaniravichandran"}, "path": "new-integration-tests/src/test/resources/apps/coherence-proxy-server/META-INF/server-cache-config.xml", "diffHunk": "@@ -0,0 +1,50 @@\n+<?xml version=\"1.0\" ?>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxODY4Njkx", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#pullrequestreview-441868691", "createdAt": "2020-07-02T16:53:21Z", "commit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjo1MzoyMVrOGsV4aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjo1MzoyMVrOGsV4aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0OTAzMg==", "bodyText": "copyright missing", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449149032", "createdAt": "2020-07-02T16:53:21Z", "author": {"login": "bhavaniravichandran"}, "path": "new-integration-tests/src/test/resources/apps/coherence-proxy-server/META-INF/coherence-application.xml", "diffHunk": "@@ -0,0 +1,5 @@\n+<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2880b87e7420122d5662c18cab5690a56ae6872d", "author": {"user": {"login": "hzhao-github", "name": "Huiling Zhao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/2880b87e7420122d5662c18cab5690a56ae6872d", "committedDate": "2020-07-04T06:39:14Z", "message": "Changes based on comments Junit5 jenkins-ignore"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2539acbc21521bea4aa9824a4796408869603c77", "author": {"user": {"login": "hzhao-github", "name": "Huiling Zhao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/2539acbc21521bea4aa9824a4796408869603c77", "committedDate": "2020-07-06T18:38:41Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-coh-tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e352b64730c1a27c57b1b5e4bee218678be1666", "author": {"user": {"login": "hzhao-github", "name": "Huiling Zhao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8e352b64730c1a27c57b1b5e4bee218678be1666", "committedDate": "2020-07-07T22:10:21Z", "message": "Added copyright Junit5 jenkins-ignore"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MzY1NDc5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#pullrequestreview-444365479", "createdAt": "2020-07-08T02:11:19Z", "commit": {"oid": "8e352b64730c1a27c57b1b5e4bee218678be1666"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMjoxMToxOVrOGuVn5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMjoyNDo0MVrOGuV05Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MTk1Ng==", "bodyText": "Do you need a new line in each log message.  Same comment on previous log statements.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r451241956", "createdAt": "2020-07-08T02:11:19Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,394 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the cache\"),\n+        () -> assertTrue(execResult1.stdout().contains(successMarker), \"Failed to load the cache\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_LOAD, execResult1.stdout());\n+\n+    // patch domain to rolling restart it by change restartVersion\n+    rollingRestartDomainAndVerify();\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to verify the cache contents\n+    final ExecResult execResult2 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_VALIDATE),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to validate the cache\"),\n+        () -> assertTrue(execResult2.stdout().contains(successMarker), \"Failed to validate the cache\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e352b64730c1a27c57b1b5e4bee218678be1666"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MjU3Mw==", "bodyText": "The Namespace is already created by infra, here we are assigning a  namespace.  So better we should comment \" Assigning a unique namespace for Operator  ( Domain ) \"", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r451242573", "createdAt": "2020-07-08T02:13:44Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,394 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e352b64730c1a27c57b1b5e4bee218678be1666"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MjgzNw==", "bodyText": "Modify the test name to  \"testCohernceServerRollingRestart\"", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r451242837", "createdAt": "2020-07-08T02:14:51Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,394 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testRollingRestart() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e352b64730c1a27c57b1b5e4bee218678be1666"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MzUzOA==", "bodyText": "Extra \"---\"  Change the  statement logger.info(\"Coherence Server restated in rolling fashion\")", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r451243538", "createdAt": "2020-07-08T02:17:32Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,394 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the cache\"),\n+        () -> assertTrue(execResult1.stdout().contains(successMarker), \"Failed to load the cache\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_LOAD, execResult1.stdout());\n+\n+    // patch domain to rolling restart it by change restartVersion\n+    rollingRestartDomainAndVerify();\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to verify the cache contents\n+    final ExecResult execResult2 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_VALIDATE),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to validate the cache\"),\n+        () -> assertTrue(execResult2.stdout().contains(successMarker), \"Failed to validate the cache\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_VALIDATE, execResult2.stdout());\n+\n+    logger.info(\"SUCCESS --- testRollingRestart\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e352b64730c1a27c57b1b5e4bee218678be1666"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0NDkyOQ==", "bodyText": "Why dummy target ?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r451244929", "createdAt": "2020-07-08T02:23:08Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/resources/apps/coherence-proxy-client/build.xml", "diffHunk": "@@ -0,0 +1,110 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!-- ================================================================================= -->\n+<!-- Copyright (c) 2020, Oracle Corporation and/or its affiliates. -->\n+<!-- Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl. -->\n+<!-- ================================================================================= -->\n+\n+<!-- ====================================================================== -->\n+<!-- Ant build file (http://ant.apache.org/) for Ant 1.6.2 or above.        -->\n+<!-- ====================================================================== -->\n+\n+<project name=\"proxy-client\" default=\"package\" basedir=\".\">\n+\n+\n+  <!-- ====================================================================== -->\n+  <!-- Build environment properties                                           -->\n+  <!-- ====================================================================== -->\n+\n+  <property file=\"maven-build.properties\"/>\n+  <property environment=\"env\"/>\n+  <property name=\"maven.build.finalName\" value=\"proxy-client-1.0\"/>\n+  <property name=\"maven.build.dir\" value=\"target\"/>\n+  <property name=\"maven.build.outputDir\" value=\"${maven.build.dir}/classes\"/>\n+  <property name=\"maven.build.srcDir.0\" value=\"src/main/java\"/>\n+  <property name=\"maven.build.resourceDir.0\" value=\"src/main/resources\"/>\n+  <property name=\"maven.reporting.outputDirectory\" value=\"${maven.build.dir}/site\"/>\n+\n+  <property name=\"maven.settings.offline\" value=\"false\"/>\n+  <property name=\"maven.settings.interactiveMode\" value=\"true\"/>\n+\n+  <!-- ====================================================================== -->\n+  <!-- Defining classpaths                                                    -->\n+  <!-- ====================================================================== -->\n+\n+  <path id=\"build.classpath\">\n+    <pathelement location=\"${env.ORACLE_HOME}/coherence/lib/coherence.jar\"/>\n+  </path>\n+\n+\n+  <!-- ====================================================================== -->\n+  <!-- Cleaning up target                                                     -->\n+  <!-- ====================================================================== -->\n+\n+  <target name=\"clean\" description=\"Clean the output directory\">\n+    <delete dir=\"${maven.build.dir}\"/>\n+  </target>\n+\n+  <!-- ====================================================================== -->\n+  <!-- Compilation target                                                     -->\n+  <!-- ====================================================================== -->\n+\n+  <target name=\"compile\" depends=\"get-deps\" description=\"Compile the code\">\n+    <mkdir dir=\"${maven.build.outputDir}\"/>\n+    <javac destdir=\"${maven.build.outputDir}\"\n+      nowarn=\"false\"\n+      debug=\"true\"\n+      optimize=\"false\"\n+      deprecation=\"true\"\n+      target=\"1.8\"\n+      verbose=\"false\"\n+      fork=\"false\"\n+      source=\"1.8\">\n+      <src>\n+        <pathelement location=\"${maven.build.srcDir.0}\"/>\n+      </src>\n+      <classpath refid=\"build.classpath\"/>\n+    </javac>\n+    <copy todir=\"${maven.build.outputDir}\">\n+      <fileset dir=\"${maven.build.resourceDir.0}\"/>\n+    </copy>\n+  </target>\n+\n+\n+  <!-- ====================================================================== -->\n+  <!-- Package target                                                         -->\n+  <!-- ====================================================================== -->\n+\n+  <target name=\"package\" depends=\"compile\" description=\"Package the application\">\n+    <jar jarfile=\"${maven.build.dir}/${maven.build.finalName}.jar\"\n+      compress=\"true\"\n+      index=\"false\"\n+      basedir=\"${maven.build.outputDir}\"\n+      excludes=\"**/package.html\"/>\n+  </target>\n+\n+  <!-- ====================================================================== -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e352b64730c1a27c57b1b5e4bee218678be1666"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0NTI4NQ==", "bodyText": "Remove the comment  regarding 'MBean unit test ...\"", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r451245285", "createdAt": "2020-07-08T02:24:41Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/resources/apps/coherence-proxy-client/src/main/java/cohapp/CacheClient.java", "diffHunk": "@@ -0,0 +1,401 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package cohapp;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import com.tangosol.net.CacheFactory;\n+import com.tangosol.net.ConfigurableCacheFactory;\n+import com.tangosol.net.NamedCache;\n+\n+\n+/**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e352b64730c1a27c57b1b5e4bee218678be1666"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a272fa7d48d4f80a6cedc297a27c52403ea4d8ee", "author": {"user": {"login": "hzhao-github", "name": "Huiling Zhao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a272fa7d48d4f80a6cedc297a27c52403ea4d8ee", "committedDate": "2020-07-08T18:38:18Z", "message": "Changes based on comments Junit5 jenkins-ignore"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NjY5MjI5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#pullrequestreview-446669229", "createdAt": "2020-07-10T20:01:37Z", "commit": {"oid": "a272fa7d48d4f80a6cedc297a27c52403ea4d8ee"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2Njk4NTI1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#pullrequestreview-446698525", "createdAt": "2020-07-10T21:01:14Z", "commit": {"oid": "a272fa7d48d4f80a6cedc297a27c52403ea4d8ee"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMTowMToxNVrOGwFhWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMTowOTo0MlrOGwFt5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3NTI5MQ==", "bodyText": "The test uses DomainHomeInImage Model with WDT, but the description say  \"create and verify WebLogic domain image using model in image with model files\"", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r453075291", "createdAt": "2020-07-10T21:01:15Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,395 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a new unique domainNamespace\n+    logger.info(\"Assigning a unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCohernceServerRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a272fa7d48d4f80a6cedc297a27c52403ea4d8ee"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3NjAxNw==", "bodyText": "Remove extra \"---\" No need to add the word \"SUCCESS\" in log message", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r453076017", "createdAt": "2020-07-10T21:02:55Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,395 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a new unique domainNamespace\n+    logger.info(\"Assigning a unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCohernceServerRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the cache\"),\n+        () -> assertTrue(execResult1.stdout().contains(successMarker), \"Failed to load the cache\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_LOAD, execResult1.stdout());\n+\n+    // patch domain to rolling restart it by change restartVersion\n+    rollingRestartDomainAndVerify();\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to verify the cache contents\n+    final ExecResult execResult2 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_VALIDATE),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to validate the cache\"),\n+        () -> assertTrue(execResult2.stdout().contains(successMarker), \"Failed to validate the cache\")\n+    );\n+\n+    logger.info(\"Coherence proxy client {0} returns {1}\",\n+        OP_CACHE_VALIDATE, execResult2.stdout());\n+\n+    logger.info(\"SUCCESS --- Coherence Server restarted in rolling fashion\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a272fa7d48d4f80a6cedc297a27c52403ea4d8ee"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3NjY0OA==", "bodyText": "Remove \\n from the logger info", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r453076648", "createdAt": "2020-07-10T21:04:43Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/FileUtils.java", "diffHunk": "@@ -132,6 +135,73 @@ public static void copyFileToPod(String namespace,\n     Kubernetes.copyFileToPod(namespace, pod, container, srcPath, destPath);\n   }\n \n+  /**\n+   * Copy a directory to a pod in specified namespace.\n+   * @param namespace namespace in which the pod exists\n+   * @param pod name of pod where the file will be copied to\n+   * @param container name of the container inside of the pod\n+   * @param srcPath source location of the directory\n+   * @param destPath destination location of the directory\n+   * @throws ApiException if Kubernetes API client call fails\n+   * @throws IOException if copy fails\n+   */\n+  public static void copyFolderToPod(String namespace,\n+                                     String pod,\n+                                     String container,\n+                                     Path srcPath,\n+                                     Path destPath) throws ApiException, IOException {\n+\n+    Stream<Path> walk = Files.walk(srcPath);\n+    // find only regular files\n+    List<String> result = walk.filter(Files::isRegularFile)\n+        .map(x -> x.toString()).collect(Collectors.toList());\n+\n+    result.forEach(fileOnHost -> {\n+      // resolve the given path against this path.\n+      Path fileInPod = destPath.resolve(srcPath.relativize(Paths.get(fileOnHost)));\n+      getLogger().info(\"Copying {0} to {1} \", fileOnHost, fileInPod);\n+\n+      try {\n+        // copy each file to the pod.\n+        Kubernetes.copyFileToPod(namespace, pod, container, Paths.get(fileOnHost), fileInPod);\n+        getLogger().info(\"File {0} copied to {1} in Pod {2} in namespace {3} \",\n+            fileOnHost, fileInPod, pod, namespace);\n+      } catch (Exception ex) {\n+        throw new RuntimeException(ex);\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Create a directory in a pod in specified namespace.\n+   * @param namespace The Kubernetes namespace that the pod is in\n+   * @param pod The name of the Kubernetes pod where the command is expected to run\n+   * @param container The container in the Pod where the command is to be run. If no\n+   *                         container name is provided than the first container in the Pod is used.\n+   * @param redirectToStdout copy process output to stdout\n+   * @param directoryToCreate namespace in which the pod exists\n+   */\n+  public static void makeDirectories(String namespace,\n+                                     String pod,\n+                                     String container,\n+                                     boolean redirectToStdout,\n+                                     List<String> directoryToCreate\n+  ) throws IOException, ApiException, InterruptedException  {\n+    //Create directories.\n+    directoryToCreate.forEach(newDir -> {\n+      String mkCmd = \"mkdir -p \" + newDir;\n+      getLogger().info(\"Newdir to make {0} \", mkCmd);\n+\n+      try {\n+        ExecResult execResult = execCommand(namespace,\n+            pod, container, redirectToStdout,\"/bin/sh\", \"-c\", mkCmd);\n+        getLogger().info(\"\\n directory created \\n \" + execResult.stdout());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a272fa7d48d4f80a6cedc297a27c52403ea4d8ee"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3Njg0Nw==", "bodyText": "Remove \\n from logger.info()", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r453076847", "createdAt": "2020-07-10T21:05:13Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,395 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a new unique domainNamespace\n+    logger.info(\"Assigning a unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCohernceServerRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the cache\"),\n+        () -> assertTrue(execResult1.stdout().contains(successMarker), \"Failed to load the cache\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a272fa7d48d4f80a6cedc297a27c52403ea4d8ee"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3Nzc1Mg==", "bodyText": "change the variable name to domImage to reflect the DomainHomeInImage configuration", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r453077752", "createdAt": "2020-07-10T21:07:36Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,395 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a new unique domainNamespace\n+    logger.info(\"Assigning a unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCohernceServerRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a272fa7d48d4f80a6cedc297a27c52403ea4d8ee"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3ODUwMQ==", "bodyText": "Why model-in-image here", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r453078501", "createdAt": "2020-07-10T21:09:42Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -781,6 +781,21 @@ public static boolean buildAppArchive(AppParams params) {\n             .build();\n   }\n \n+  /**\n+   * Create an application archive that can be used by WebLogic Image Tool\n+   * to create an image with coh-proxy-server.gar for testing Coherence use case\n+   * using   model-in-image.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a272fa7d48d4f80a6cedc297a27c52403ea4d8ee"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NzEzNTE1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#pullrequestreview-446713515", "createdAt": "2020-07-10T21:35:16Z", "commit": {"oid": "a272fa7d48d4f80a6cedc297a27c52403ea4d8ee"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ea239b7a64b5520b093528338f15d88e2e7e803", "author": {"user": {"login": "hzhao-github", "name": "Huiling Zhao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3ea239b7a64b5520b093528338f15d88e2e7e803", "committedDate": "2020-07-10T22:03:27Z", "message": "Seveal changes on comments jenkins-ignore"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4258, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}