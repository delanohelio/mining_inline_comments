{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA3MTI4NzMz", "number": 2002, "title": "Owls83995 - Sample scripts to shutdown and start a specific managed server/cluster/domain", "bodyText": "Scripts to start and stop a specific managed server (startServer.sh and stopServer.sh)\nScripts to start and stop a specific cluster (startCluster.sh and stopCluster.sh)\nScripts to start and stop the entire domain (startDomain.sh and stopDomain.sh)\nUpdated product documentation describing how to use the scripts, including\n\nGuide for basic use cases to start/stop a server, cluster, or the whole domain\nDetails on the choice to either have the replica count rise & fall or to stay consistent when managing a clustered server\n\n\n\nI have added new integration tests in ItLifecycleSampleScripts and ran it in external jenkins. The test results are at - https://build.weblogick8s.org:8443/job/weblogic-kubernetes-operator-kind-new/2622/\nhttps://build.weblogick8s.org:8443/job/weblogic-kubernetes-operator-kind-new/2622/testReport/oracle.weblogic.kubernetes/ItLifecycleSampleScripts/", "createdAt": "2020-10-20T22:18:33Z", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002", "merged": true, "mergeCommit": {"oid": "48ded2f6a6f5f9772f14ca5139d72fabe61de97d"}, "closed": true, "closedAt": "2020-11-05T16:25:31Z", "author": {"login": "ankedia"}, "timelineItems": {"totalCount": 129, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdZOchbAFqTUyMzM5OTYyNQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZksePAFqTUyNDQyMjg1NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzk5NjI1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-523399625", "createdAt": "2020-11-04T14:15:10Z", "commit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDoxNToxMFrOHtZ-Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDoxNToxMFrOHtZ-Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3MzQ0Mg==", "bodyText": "add \"and keep_replica_count option is false (the default)\"", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r517373442", "createdAt": "2020-11-04T14:15:10Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/stopServer.sh", "diffHunk": "@@ -0,0 +1,233 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+# This script stops a WebLogic managed server in a domain. \n+# Internal code notes :-\n+# - If server start policy is NEVER or policy is IF_NEEDED and the server is not \n+#   selected to start based on the replica count, it means that server is already \n+#   stopped or is in the process of stopping. In this case, script exits without \n+#   making any changes.\n+#\n+# - If the effective start policy of the server is IF_NEEDED and decreasing replica \n+#   count will naturally stop the server, the script decreases the replica count. \n+#\n+# - If unsetting policy and decreasing the replica count will stop the server, script unsets", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNDIxMzcx", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-523421371", "createdAt": "2020-11-04T14:37:30Z", "commit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDozNzozMFrOHta9zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDozNzozMFrOHta9zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM4OTc3NQ==", "bodyText": "Right now, the script will simply fail-fast if the cm isn't found (due to the global 'set -e').  I suspect it'd be more helpful to the user if it generated a clear error message...  If you want to address this, you can use the same pattern as was used in 'timestamp':  val=$(set +e && dostuff || echo _error_) and if val contains '_error_' then...", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r517389775", "createdAt": "2020-11-04T14:37:30Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,605 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value for cluster level server start policy.\n+#      Legal return values are \"NEVER\" or \"IF_NEEDED\" or \"\".\n+#\n+function getClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __clusterPolicy=$3\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__clusterPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get server start policy at domain level\n+# $1 - Domain resource in json format\n+# $2 - Return value containing domain level server start policy.\n+#      Legal retrun values are \"NEVER\" or \"IF_NEEDED\" or \"ADMIN_ONLY\".\n+#\n+function getDomainPolicy {\n+  local domainJson=$1\n+  local __domainPolicy=$2\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\".spec.serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__domainPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get effective start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Name of cluster\n+# $4 - Return value containing effective server start policy\n+#      Legal retrun values are \"NEVER\" or \"IF_NEEDED\" or \"ALWAYS\".\n+#\n+function getEffectivePolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local __currentPolicy=$4\n+  local currentPolicy=\"\"\n+\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentPolicy\n+  if [ -z \"${currentPolicy}\" ]; then\n+    getClusterPolicy \"${domainJson}\" \"${clusterName}\" currentPolicy\n+    if [ -z \"${currentPolicy}\" ]; then\n+      # Start policy is not set at cluster level, check at domain level\n+      getDomainPolicy \"${domainJson}\" currentPolicy\n+      if [ -z \"${currentPolicy}\" ]; then\n+        # Start policy is not set at domain level, default to IF_NEEDED\n+        currentPolicy=IF_NEEDED\n+      fi\n+    fi\n+  fi\n+  eval $__currentPolicy=\"'${currentPolicy}'\"\n+}\n+\n+#\n+# Function to get current start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Return value containing current server start policy\n+#      Legal retrun values are \"NEVER\" or \"IF_NEEDED\", \"ALWAYS\" or \"\".\n+#\n+function getServerPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __currentPolicy=$3\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentServerStartPolicy=$(echo ${domainJson} | jq \"${extractPolicyCmd}\")\n+    if [ \"${currentServerStartPolicy}\" == \"null\" ]; then\n+      currentServerStartPolicy=\"\"\n+    fi\n+  fi\n+  eval $__currentPolicy=${currentServerStartPolicy}\n+}\n+\n+#\n+# Function to create server start policy patch string\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Policy value \n+# $4 - Return value containing server start policy patch string\n+#\n+function createServerStartPolicyPatch {\n+  local domainJson=$1\n+  local serverName=$2\n+  local policy=$3\n+  local __result=$4\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentServerStartPolicy\n+  if [ -z \"${currentServerStartPolicy}\" ]; then\n+    # Server start policy doesn't exist, add a new policy\n+    addPolicyCmd=\".[.| length] |= . + {\\\"serverName\\\":\\\"${serverName}\\\", \\\n+      \\\"serverStartPolicy\\\":\\\"${policy}\\\"}\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq .spec.managedServers | jq -c \"${addPolicyCmd}\")\n+  else\n+    # Server start policy exists, replace policy value \n+    replacePolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy) |= \\\"${policy}\\\"\"\n+    servers=\"(.spec.managedServers)\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\" | jq -cr \"${servers}\")\n+  fi\n+  eval $__result=\"'${serverStartPolicyPatch}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy and update replica\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - String containing replica patch string\n+# $4 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicyAndUpdateReplica {\n+  local domainJson=$1\n+  local serverName=$2\n+  local replicaPatch=$3\n+  local __result=$4\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaPatch}\",\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update policy \n+# $1 - String containing start policy info\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdatePolicy {\n+  local startPolicy=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update replica \n+# $1 - String containing replica\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdateReplica {\n+  local replicaInfo=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update replica and policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUpdateReplicaAndPolicy {\n+  local replicaInfo=$1\n+  local startPolicy=$2\n+  local __result=$3\n+\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\",\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __result=$3\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to get sorted list of servers in a cluster.\n+# The sorted list is created in 'sortedByAlwaysServers' array.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if policy of current server would be unset.\n+#      valid values are \"UNSET\" and \"CONSTANT\"\n+#\n+function getSortedListOfServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withPolicy=$4\n+  local policy=\"\"\n+  local sortedServers=()\n+  local otherServers=()\n+\n+  configMap=$(${kubernetesCli} get cm ${domainUid}-weblogic-domain-introspect-cm \\\n+    -n ${domainNamespace} -o json)\n+  topology=$(echo \"${configMap}\" | jq '.data[\"topology.yaml\"]')\n+  jsonTopology=$(python -c \\\n+    'import sys, yaml, json; print json.dumps(yaml.safe_load('\"${topology}\"'), indent=4)')\n+  clusterTopology=$(echo ${jsonTopology} | jq -r '.domain | .configuredClusters[] | select (.name == '\\\"${clusterName}\\\"')')\n+  dynaCluster=$(echo ${clusterTopology} | jq .dynamicServersConfig)\n+  if [ \"${dynaCluster}\" == \"null\" ]; then\n+    # Cluster is a configured cluster, get server names\n+    servers=($(echo ${clusterTopology} | jq -r .servers[].name))\n+    # Sort server names in numero lexi order\n+    IFS=$'\\n' sortedServers=($(sort --version-sort <<<\"${servers[*]}\" ))\n+    unset IFS\n+    clusterSize=${#sortedServers[@]}\n+  else \n+    # Cluster is a dynamic cluster, calculate server names\n+    prefix=$(echo ${dynaCluster} | jq -r .serverNamePrefix)\n+    clusterSize=$(echo ${dynaCluster} | jq .dynamicClusterSize) \n+    for (( i=1; i<=$clusterSize; i++ )); do\n+      localServerName=${prefix}$i\n+      sortedServers+=(${localServerName})\n+    done\n+  fi\n+  # Create arrays of ALWAYS policy servers and other servers\n+  for localServerName in ${sortedServers[@]:-}; do\n+    getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+    # Update policy when server name matches current server and unsetting\n+    if [[ \"${withPolicy}\" == \"UNSET\" && \"${serverName}\" == \"${localServerName}\" ]]; then\n+      policy=UNSET\n+    fi\n+    if [ \"${policy}\" == \"ALWAYS\" ]; then\n+      sortedByAlwaysServers+=(${localServerName})\n+    else\n+      otherServers+=(${localServerName})\n+    fi\n+  done\n+  \n+  # append other servers to the list of servers with always policy\n+  for otherServer in ${otherServers[@]:-}; do\n+    sortedByAlwaysServers+=($otherServer)\n+  done\n+}\n+\n+#\n+# Get replica count for a cluster\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster \n+# $3 - Return value containing replica count\n+#\n+function getReplicaCount {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __replicaCount=$3\n+\n+  replicasCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).replicas\"\n+  replicaCount=$(echo ${domainJson} | jq \"${replicasCmd}\")\n+  if [[ -z \"${replicaCount}\" || \"${replicaCount}\" == \"null\" ]]; then\n+    replicaCount=$(echo ${domainJson} | jq .spec.replicas)\n+  fi\n+  if [[ -z \"${replicaCount}\" || \"${replicaCount}\" == \"null\" ]]; then\n+    replicaCount=0\n+  fi\n+  eval $__replicaCount=\"'${replicaCount}'\"\n+\n+}\n+\n+#\n+# Check servers started in a cluster based on server start policy and \n+# replica count.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if replicas will stay constant, incremented or decremented.\n+#      Valid values are \"CONSTANT\", \"INCREMENT\" and \"DECREMENT\"\n+# $5 - Indicates if policy of current server will stay constant or unset.\n+#      Valid values are \"CONSTANT\" and \"UNSET\"\n+# $6 - Return value of \"true\" or \"false\" indicating if current server will be started\n+#\n+function checkStartedServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withReplicas=$4\n+  local withPolicy=$5\n+  local __started=$6\n+  local localServerName=\"\"\n+  local policy=\"\"\n+  local replicaCount=0\n+  local currentReplicas=0\n+  local startedServers=()\n+  local sortedByAlwaysServers=()\n+  \n+  # Get sorted list of servers in 'sortedByAlwaysServers' array\n+  getSortedListOfServers \"${domainJson}\" \"${serverName}\" \"${clusterName}\" \"${withPolicy}\"\n+  getReplicaCount \"${domainJson}\" \"${clusterName}\" replicaCount\n+  # Increment or decrement the replica count based on 'withReplicas' input parameter\n+  if [ \"${withReplicas}\" == \"INCREASED\" ]; then\n+    replicaCount=$((replicaCount+1))\n+  elif [ \"${withReplicas}\" == \"DECREASED\" ]; then\n+    replicaCount=$((replicaCount-1))\n+  fi\n+  for localServerName in ${sortedByAlwaysServers[@]:-}; do\n+    getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+    # Update policy when server name matches current server and unsetting\n+    if [[ \"${serverName}\" == \"${localServerName}\" && \"${withPolicy}\" == \"UNSET\" ]]; then\n+      policy=UNSET\n+    fi\n+    # check if server should start based on replica count, policy and current replicas\n+    shouldStart \"${currentReplicas}\" \"${policy}\" \"${replicaCount}\" result\n+    if [ \"${result}\" == 'true' ]; then\n+      # server should start, increment current replicas and add server to list of started servers\n+      currentReplicas=$((currentReplicas+1))\n+      startedServers+=(${localServerName})\n+    fi\n+  done\n+  startedSize=${#startedServers[@]}\n+  if [ ${startedSize} -gt 0 ]; then\n+    # check if current server is in the list of started servers\n+    if checkStringInArray ${serverName} ${startedServers[@]}; then\n+      eval $__started=\"true\"\n+      return\n+    fi\n+  fi\n+  eval $__started=\"false\"\n+}\n+\n+#\n+# Function to check if server should start based on policy and current replicas\n+# $1 - Current number of replicas\n+# $2 - Server start policy\n+# $3 - Replica count\n+# $4 - Returns \"true\" or \"false\" indicating if server should start.\n+#\n+function shouldStart {\n+  local currentReplicas=$1\n+  local policy=$2\n+  local replicaCount=$3 \n+  local __result=$4\n+\n+  if [ \"$policy\" == \"ALWAYS\" ]; then\n+    eval $__result=true\n+  elif [ \"$policy\" == \"NEVER\" ]; then\n+    eval $__result=false\n+  elif [ \"${currentReplicas}\" -lt \"${replicaCount}\" ]; then\n+    eval $__result=true\n+  else \n+    eval $__result=false\n+  fi\n+}\n+\n+#\n+# Function to create patch string for updating replica count\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster whose replica count will be patched\n+# $3 - operation string indicating whether to increment or decrement replica count. \n+#      Valid values are \"INCREMENT\" and \"DECREMENT\"\n+# $4 - Return value containing replica update patch string\n+# $5 - Return value containing updated replica count\n+#\n+function createReplicaPatch {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local operation=$3\n+  local __result=$4\n+  local __replicaCount=$5\n+  local maxReplicas=\"\"\n+  local infoMessage=\"Current replica count value is same as maximum number of replica count. \\\n+Not increasing replica count value.\"\n+\n+  maxReplicaCmd=\"(.status.clusters[] | select (.clusterName == \\\"${clusterName}\\\")) \\\n+    | .maximumReplicas\"\n+  getReplicaCount  \"${domainJson}\" \"${clusterName}\" replica\n+  if [ \"${operation}\" == \"DECREMENT\" ]; then\n+    replica=$((replica-1))\n+    if [ ${replica} -lt 0 ]; then\n+      replica=0\n+    fi\n+  elif [ \"${operation}\" == \"INCREMENT\" ]; then\n+    maxReplicas=$(echo ${domainJson} | jq \"${maxReplicaCmd}\")\n+    if [ ${replica} -eq ${maxReplicas} ]; then\n+      printInfo \"${infoMessage}\"\n+    else\n+      replica=$((replica+1))\n+    fi\n+  fi\n+\n+  cmd=\"(.spec.clusters[] | select (.clusterName == \\\"${clusterName}\\\") \\\n+    | .replicas) |= ${replica}\"\n+  replicaPatch=$(echo ${domainJson} | jq \"${cmd}\" | jq -cr '(.spec.clusters)')\n+  eval $__result=\"'${replicaPatch}'\"\n+  eval $__replicaCount=\"'${replica}'\"\n+}\n+\n+#\n+# Function to validate whether a server belongs to a  cluster or is an independent managed server\n+# $1 - Domain unique id.\n+# $2 - Domain namespace.\n+# $3 - Server name.\n+# $4 - Return value of \"true\" or \"false\" indicating if server is valid (i.e. if it's part of a cluster or independent server).\n+# $5 - Retrun value containting cluster name to which this server belongs.\n+#\n+function validateServerAndFindCluster {\n+  local domainUid=$1\n+  local domainNamespace=$2 \n+  local serverName=$3\n+  local __isValidServer=$4\n+  local __clusterName=$5\n+  local serverCount=\"\"\n+  local errorMessage=\"Server name is outside the range of allowed servers. \\\n+Please make sure server name is correct.\"\n+\n+  eval $__isValidServer=false\n+  eval $__clusterName=UNKNOWN\n+  configMap=$(${kubernetesCli} get cm ${domainUid}-weblogic-domain-introspect-cm \\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "originalPosition": 443}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNDI1MjM3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-523425237", "createdAt": "2020-11-04T14:41:32Z", "commit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDo0MTozMlrOHtbJkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDo0MTozMlrOHtbJkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM5Mjc4Nw==", "bodyText": "This depends on the pod being up, which isn't necessarily required as the pod may be temporarily down but still in a 'started' state.   Could this be replaced with the 'validateServerAndFindCluster' helper method instead?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r517392787", "createdAt": "2020-11-04T14:41:32Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/stopServer.sh", "diffHunk": "@@ -0,0 +1,233 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+# This script stops a WebLogic managed server in a domain. \n+# Internal code notes :-\n+# - If server start policy is NEVER or policy is IF_NEEDED and the server is not \n+#   selected to start based on the replica count, it means that server is already \n+#   stopped or is in the process of stopping. In this case, script exits without \n+#   making any changes.\n+#\n+# - If the effective start policy of the server is IF_NEEDED and decreasing replica \n+#   count will naturally stop the server, the script decreases the replica count. \n+#\n+# - If unsetting policy and decreasing the replica count will stop the server, script unsets\n+#   the policy and decreases replica count. For e.g. if replica count is 2 and start policy\n+#   of server2 is ALWAYS, unsetting policy and decreasing replica count will stop server2.\n+#\n+# - If option to keep replica count constant ('-k') is selected and unsetting start policy\n+#   will naturally stop the server, script will unset the policy. For e.g. if replica count\n+#   is 1 and start policy  of server2 is ALWAYS, unsetting policy will stop server2.\n+#\n+# - If above conditions are not true, it implies that server policy is IF_NEEDED and server \n+#   is selected to start. In this case, script sets start policy to NEVER. For e.g. replica \n+#   count is 2 and server1 needs to be stopped. The script also decrements the replica count \n+#   by default. If option to keep replica count constant ('-k') is selected, it only sets the \n+#   start policy to NEVER.\n+# \n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+if [ \"${debug}\" == \"true\" ]; then set -x; fi;\n+set -eu\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script stops a running WebLogic managed server in a domain either by\n+  decreasing the value of 'spec.clusters[<cluster-name>].replicas' or by updating \n+  'spec.managedServers[<server-name>].serverStartPolicy' attribute of the domain \n+  resource or both as necessary. The 'spec.clusters[<cluster-name>].replicas' value\n+  can be kept constant by using '-k' option. Please see README.md for more details.\n+ \n+  Usage:\n+ \n+    $(basename $0) -s myserver [-n mynamespace] [-d mydomainuid] [-k] [-m kubecli] [-v]\n+  \n+    -s <server_name>           : Server name parameter is required.\n+\n+    -d <domain_uid>            : Domain unique-id. Default is 'sample-domain1'.\n+\n+    -n <namespace>             : Domain namespace. Default is 'sample-domain1-ns'.\n+    \n+    -k <keep_replica_constant> : Keep replica count constant. Default behavior is to decrement replica count.\n+\n+    -m <kubernetes_cli>        : Kubernetes command line interface. Default is 'kubectl' if KUBERNETES_CLI env\n+                                 variable is not set. Otherwise default is the value of KUBERNETES_CLI env variable.\n+\n+    -v <verbose_mode>          : Enables verbose mode. Default is 'false'.\n+\n+    -h                         : This help.\n+   \n+EOF\n+exit $1\n+}\n+\n+kubernetesCli=${KUBERNETES_CLI:-kubectl}\n+serverName=\"\"\n+clusterName=\"\"\n+domainUid=\"sample-domain1\"\n+domainNamespace=\"sample-domain1-ns\"\n+keepReplicaConstant=false\n+verboseMode=false\n+serverStartPolicy=NEVER\n+serverStarted=\"\"\n+action=\"\"\n+effectivePolicy=\"\"\n+managedServerPolicy=\"\"\n+stoppedWhenAlwaysPolicyReset=\"\"\n+withReplicas=\"CONSTANT\"\n+withPolicy=\"CONSTANT\"\n+\n+while getopts \"vks:m:n:d:h\" opt; do\n+  case $opt in\n+    s) serverName=\"${OPTARG}\"\n+    ;;\n+    n) domainNamespace=\"${OPTARG}\"\n+    ;;\n+    m) kubernetesCli=\"${OPTARG}\"\n+    ;;\n+    d) domainUid=\"${OPTARG}\"\n+    ;;\n+    k) keepReplicaConstant=true;\n+    ;;\n+    v) verboseMode=true;\n+    ;;\n+    h) usage 0\n+    ;;\n+    *) usage 1\n+    ;;\n+  esac\n+done\n+\n+#\n+# Function to perform validations, read files and initialize workspace\n+#\n+function initialize {\n+\n+  validateErrors=false\n+\n+  validateKubernetesCliAvailable\n+  validateJqAvailable\n+\n+  # Validate that server name parameter is specified.\n+  if [ -z \"${serverName}\" ]; then\n+    validationError \"Please specify the server name using '-s' parameter e.g. '-s managed-server1'.\"\n+  fi\n+\n+  failIfValidationErrors\n+}\n+\n+initialize\n+\n+# Get the cluster name for current server \n+clusterName=$(${kubernetesCli} get pod ${domainUid}-${serverName} -n ${domainNamespace} -o=jsonpath=\"{.metadata.labels['weblogic\\.clusterName']}\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "originalPosition": 128}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNDU2ODgy", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-523456882", "createdAt": "2020-11-04T15:13:13Z", "commit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNToxMzoxM1rOHtclGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNToxMzoxM1rOHtclGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxNjIxNg==", "bodyText": "Question for @rjeberhard\nAnil and I went back on forth a bit about documenting the exact algorithm for server start/stop.  In the end, we came to the (not so firm) conclusion that the exact algorithm details are a bit overwhelming and unneeded for the README and 'usage' output, and that it was still minimally necessary include them as a code comment in each script (for anyone that might need to enhance/fix the scripts in the future).\nDoes this sound fine to you?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r517416216", "createdAt": "2020-11-04T15:13:13Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startServer.sh", "diffHunk": "@@ -0,0 +1,252 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+# This script starts a WebLogic managed server in a domain. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNDU5ODM1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-523459835", "createdAt": "2020-11-04T15:16:17Z", "commit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNToxNjoxN1rOHtct7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNToxNjoxN1rOHtct7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxODQ3OA==", "bodyText": "add \"and keep_replica_count option is false (the default)\"", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r517418478", "createdAt": "2020-11-04T15:16:17Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startServer.sh", "diffHunk": "@@ -0,0 +1,252 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+# This script starts a WebLogic managed server in a domain. \n+# Internal code notes :-\n+# - If server start policy is ALWAYS or policy is IF_NEEDED and the server is selected \n+#   to start based on the replica count, it means that server is already started or is\n+#   in the process of starting. In this case, script exits without making any changes.\n+#\n+# - If start policy of servers parent cluster or domain is 'NEVER', script\n+#   fails as server can't be started.\n+#\n+# - If the effective start policy of the server is IF_NEEDED and increasing replica ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNDYwMDQ0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-523460044", "createdAt": "2020-11-04T15:16:27Z", "commit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNToxNjoyN1rOHtcujQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNToxNjoyN1rOHtcujQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxODYzNw==", "bodyText": "add \"and keep_replica_count option is false (the default)\"", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r517418637", "createdAt": "2020-11-04T15:16:27Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startServer.sh", "diffHunk": "@@ -0,0 +1,252 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+# This script starts a WebLogic managed server in a domain. \n+# Internal code notes :-\n+# - If server start policy is ALWAYS or policy is IF_NEEDED and the server is selected \n+#   to start based on the replica count, it means that server is already started or is\n+#   in the process of starting. In this case, script exits without making any changes.\n+#\n+# - If start policy of servers parent cluster or domain is 'NEVER', script\n+#   fails as server can't be started.\n+#\n+# - If the effective start policy of the server is IF_NEEDED and increasing replica \n+#   count will naturally start the server, the script increases the replica count. \n+#\n+# - If unsetting policy and increasing the replica count will start this server, script unsets", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNDgwODA2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-523480806", "createdAt": "2020-11-04T15:37:47Z", "commit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNTozNzo0N1rOHtdrEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNTozNzo0N1rOHtdrEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQzNDEzMA==", "bodyText": "the targetPolicy is never to anything other than \"ALWAYS\" - it doesn't need to be a variable", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r517434130", "createdAt": "2020-11-04T15:37:47Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startServer.sh", "diffHunk": "@@ -0,0 +1,252 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+# This script starts a WebLogic managed server in a domain. \n+# Internal code notes :-\n+# - If server start policy is ALWAYS or policy is IF_NEEDED and the server is selected \n+#   to start based on the replica count, it means that server is already started or is\n+#   in the process of starting. In this case, script exits without making any changes.\n+#\n+# - If start policy of servers parent cluster or domain is 'NEVER', script\n+#   fails as server can't be started.\n+#\n+# - If the effective start policy of the server is IF_NEEDED and increasing replica \n+#   count will naturally start the server, the script increases the replica count. \n+#\n+# - If unsetting policy and increasing the replica count will start this server, script unsets\n+#   the policy and increases replica count. For e.g. if replica count is 1 and start policy\n+#   of server2 is NEVER, unsetting policy and increasing replica count will start server2.\n+#\n+# - If option to keep replica count constant ('-k') is selected and unsetting start policy\n+#   will naturally start the server, script will unset the policy. For e.g. if replica count\n+#   is 2 and start policy  of server2 is NEVER, unsetting policy will start server2.\n+#\n+# - If above conditions are not true, it implies that either start policy is NEVER or policy\n+#   is IF_NEEDED but server is not next in the order to start. In this case, script sets start \n+#   policy to ALWAYS. For e.g. replica count is 3 and server10 needs to start. The script also \n+#   increments the replica count by default. If option to keep replica count constant ('-k') \n+#   is selected, it only sets the start policy to ALWAYS.\n+# \n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+if [ \"${debug}\" == \"true\" ]; then set -x; fi;\n+set -eu\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script starts a WebLogic managed server in a domain either by increasing\n+  the value of 'spec.clusters[<cluster-name>].replicas' by '1' or by updating the\n+  'spec.managedServers[<server-name>].serverStartPolicy' attribute of the domain\n+  resource or both as necessary. The 'spec.clusters[<cluster-name>].replicas' value can\n+  be kept constant by using '-k' option. Please see README.md for more details.\n+\n+  Usage:\n+\n+    $(basename $0) -s myserver [-n mynamespace] [-d mydomainuid] [-k] [-m kubecli] [-v]\n+\n+    -s <server_name>           : Server name parameter is required.\n+\n+    -d <domain_uid>            : Domain unique-id. Default is 'sample-domain1'.\n+\n+    -n <namespace>             : Domain namespace. Default is 'sample-domain1-ns'.\n+\n+    -k <keep_replica_constant> : Keep replica count constant. Default behavior is to increment replica count.\n+\n+    -m <kubernetes_cli>        : Kubernetes command line interface. Default is 'kubectl' if KUBERNETES_CLI env\n+                                 variable is not set. Otherwise default is the value of KUBERNETES_CLI env variable.\n+\n+    -v <verbose_mode>          : Enables verbose mode. Default is 'false'.\n+\n+    -h                         : This help.\n+   \n+EOF\n+exit $1\n+}\n+\n+kubernetesCli=${KUBERNETES_CLI:-kubectl}\n+serverName=\"\"\n+clusterName=\"\"\n+domainUid=\"sample-domain1\"\n+domainNamespace=\"sample-domain1-ns\"\n+keepReplicaConstant=false\n+verboseMode=false\n+withReplicas=\"CONSTANT\"\n+withPolicy=\"CONSTANT\"\n+managedServerPolicy=\"\"\n+effectivePolicy=\"\"\n+action=\"\"\n+isValidServer=\"\"\n+patchJson=\"\"\n+serverStarted=\"\"\n+startsByPolicyUnset=\"\"\n+startsByReplicaIncreaseAndPolicyUnset=\"\"\n+\n+while getopts \"vkd:n:m:s:h\" opt; do\n+  case $opt in\n+    s) serverName=\"${OPTARG}\"\n+    ;;\n+    n) domainNamespace=\"${OPTARG}\"\n+    ;;\n+    d) domainUid=\"${OPTARG}\"\n+    ;;\n+    k) keepReplicaConstant=true;\n+    ;;\n+    m) kubernetesCli=\"${OPTARG}\"\n+    ;;\n+    v) verboseMode=true;\n+    ;;\n+    h) usage 0\n+    ;;\n+    *) usage 1\n+    ;;\n+  esac\n+done\n+\n+#\n+# Function to perform validations, read files and initialize workspace\n+#\n+function initialize {\n+\n+  # Validate the required files exist\n+  validateErrors=false\n+\n+  validateKubernetesCliAvailable\n+  validateJqAvailable\n+\n+  # Validate that server name parameter is specified.\n+  if [ -z \"${serverName}\" ]; then\n+    validationError \"Please specify a server name using '-s' parameter e.g. '-s managed-server1'.\"\n+  fi\n+\n+  failIfValidationErrors\n+}\n+\n+initialize\n+\n+# Get the domain in json format\n+domainJson=$(${kubernetesCli} get domain ${domainUid} -n ${domainNamespace} -o json)\n+if [ $? -ne 0 ]; then\n+  printError \"Unable to get domain resource. Please make sure 'domain_uid' and 'namespace' provided with '-d' and '-n' arguments are correct.\"\n+  exit 1\n+fi\n+\n+# Validate that specified server is either part of a cluster or is an independent managed server\n+validateServerAndFindCluster \"${domainUid}\" \"${domainNamespace}\" \"${serverName}\" isValidServer clusterName\n+if [ \"${isValidServer}\" != 'true' ]; then\n+  printError \"Server ${serverName} is not part of any cluster and it's not an independent managed server. Please make sure that server name specified is correct.\"\n+  exit 1\n+fi\n+\n+getClusterPolicy \"${domainJson}\" \"${clusterName}\" clusterPolicy\n+if [ \"${clusterPolicy}\" == 'NEVER' ]; then\n+  printError \"Cannot start server '${serverName}', the server's parent cluster '.spec.clusters[?(clusterName=\\\"${clusterName}\\\"].serverStartPolicy' in the domain resource is set to 'NEVER'.\"\n+  exit 1\n+fi\n+\n+getDomainPolicy \"${domainJson}\" domainPolicy\n+if [ \"${domainPolicy}\" == 'NEVER' ]; then\n+  printError \"Cannot start server '${serverName}', the .spec.serverStartPolicy in the domain resource is set to 'NEVER'.\"\n+  exit 1\n+fi\n+\n+getEffectivePolicy \"${domainJson}\" \"${serverName}\" \"${clusterName}\" effectivePolicy\n+if [ -n \"${clusterName}\" ]; then\n+  # Server is part of a cluster, check currently started servers\n+  checkStartedServers \"${domainJson}\" \"${serverName}\" \"${clusterName}\" \"${withReplicas}\" \"${withPolicy}\" serverStarted\n+  if [[ ${effectivePolicy} == \"IF_NEEDED\" && ${serverStarted} == \"true\" ]]; then\n+    printInfo \"No changes needed, exiting. The server should be already started or it's in the process of starting. The start policy for server ${serverName} is ${effectivePolicy} and server is chosen to be started based on current replica count.\"\n+    exit 0\n+  elif [[ \"${effectivePolicy}\" == \"ALWAYS\" && ${serverStarted} == \"true\" ]]; then\n+    printInfo \"No changes needed, exiting. The server should be already started or it's in the process of starting. The start policy for server ${serverName} is ${effectivePolicy}.\"\n+    exit 0\n+  fi\n+else \n+  # Server is an independent managed server. \n+  if [[ \"${effectivePolicy}\" == \"ALWAYS\" || \"${effectivePolicy}\" == \"IF_NEEDED\" ]]; then\n+    printInfo \"No changes needed, exiting. The server should be already started or it's in the process of starting. The start policy for server ${serverName} is ${effectivePolicy}.\"\n+    exit 0\n+  fi\n+fi\n+\n+getServerPolicy \"${domainJson}\" \"${serverName}\" managedServerPolicy\n+targetPolicy=\"ALWAYS\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "originalPosition": 178}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNTMxMTE5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-523531119", "createdAt": "2020-11-04T16:30:11Z", "commit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNjozMDoxMlrOHtgBpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNjozMDoxMlrOHtgBpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ3MjY3OQ==", "bodyText": "Consider (a) adding 'verboseMode' to the 4 scripts that  don't already have it, (b) abstracting out the patch domain command and its Info message into a helper function so that they are shared by all 6 scripts, and finally (c) having the printInfo show the entire exact command instead of only the patchJson...", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r517472679", "createdAt": "2020-11-04T16:30:12Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startServer.sh", "diffHunk": "@@ -0,0 +1,252 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+# This script starts a WebLogic managed server in a domain. \n+# Internal code notes :-\n+# - If server start policy is ALWAYS or policy is IF_NEEDED and the server is selected \n+#   to start based on the replica count, it means that server is already started or is\n+#   in the process of starting. In this case, script exits without making any changes.\n+#\n+# - If start policy of servers parent cluster or domain is 'NEVER', script\n+#   fails as server can't be started.\n+#\n+# - If the effective start policy of the server is IF_NEEDED and increasing replica \n+#   count will naturally start the server, the script increases the replica count. \n+#\n+# - If unsetting policy and increasing the replica count will start this server, script unsets\n+#   the policy and increases replica count. For e.g. if replica count is 1 and start policy\n+#   of server2 is NEVER, unsetting policy and increasing replica count will start server2.\n+#\n+# - If option to keep replica count constant ('-k') is selected and unsetting start policy\n+#   will naturally start the server, script will unset the policy. For e.g. if replica count\n+#   is 2 and start policy  of server2 is NEVER, unsetting policy will start server2.\n+#\n+# - If above conditions are not true, it implies that either start policy is NEVER or policy\n+#   is IF_NEEDED but server is not next in the order to start. In this case, script sets start \n+#   policy to ALWAYS. For e.g. replica count is 3 and server10 needs to start. The script also \n+#   increments the replica count by default. If option to keep replica count constant ('-k') \n+#   is selected, it only sets the start policy to ALWAYS.\n+# \n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+if [ \"${debug}\" == \"true\" ]; then set -x; fi;\n+set -eu\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script starts a WebLogic managed server in a domain either by increasing\n+  the value of 'spec.clusters[<cluster-name>].replicas' by '1' or by updating the\n+  'spec.managedServers[<server-name>].serverStartPolicy' attribute of the domain\n+  resource or both as necessary. The 'spec.clusters[<cluster-name>].replicas' value can\n+  be kept constant by using '-k' option. Please see README.md for more details.\n+\n+  Usage:\n+\n+    $(basename $0) -s myserver [-n mynamespace] [-d mydomainuid] [-k] [-m kubecli] [-v]\n+\n+    -s <server_name>           : Server name parameter is required.\n+\n+    -d <domain_uid>            : Domain unique-id. Default is 'sample-domain1'.\n+\n+    -n <namespace>             : Domain namespace. Default is 'sample-domain1-ns'.\n+\n+    -k <keep_replica_constant> : Keep replica count constant. Default behavior is to increment replica count.\n+\n+    -m <kubernetes_cli>        : Kubernetes command line interface. Default is 'kubectl' if KUBERNETES_CLI env\n+                                 variable is not set. Otherwise default is the value of KUBERNETES_CLI env variable.\n+\n+    -v <verbose_mode>          : Enables verbose mode. Default is 'false'.\n+\n+    -h                         : This help.\n+   \n+EOF\n+exit $1\n+}\n+\n+kubernetesCli=${KUBERNETES_CLI:-kubectl}\n+serverName=\"\"\n+clusterName=\"\"\n+domainUid=\"sample-domain1\"\n+domainNamespace=\"sample-domain1-ns\"\n+keepReplicaConstant=false\n+verboseMode=false\n+withReplicas=\"CONSTANT\"\n+withPolicy=\"CONSTANT\"\n+managedServerPolicy=\"\"\n+effectivePolicy=\"\"\n+action=\"\"\n+isValidServer=\"\"\n+patchJson=\"\"\n+serverStarted=\"\"\n+startsByPolicyUnset=\"\"\n+startsByReplicaIncreaseAndPolicyUnset=\"\"\n+\n+while getopts \"vkd:n:m:s:h\" opt; do\n+  case $opt in\n+    s) serverName=\"${OPTARG}\"\n+    ;;\n+    n) domainNamespace=\"${OPTARG}\"\n+    ;;\n+    d) domainUid=\"${OPTARG}\"\n+    ;;\n+    k) keepReplicaConstant=true;\n+    ;;\n+    m) kubernetesCli=\"${OPTARG}\"\n+    ;;\n+    v) verboseMode=true;\n+    ;;\n+    h) usage 0\n+    ;;\n+    *) usage 1\n+    ;;\n+  esac\n+done\n+\n+#\n+# Function to perform validations, read files and initialize workspace\n+#\n+function initialize {\n+\n+  # Validate the required files exist\n+  validateErrors=false\n+\n+  validateKubernetesCliAvailable\n+  validateJqAvailable\n+\n+  # Validate that server name parameter is specified.\n+  if [ -z \"${serverName}\" ]; then\n+    validationError \"Please specify a server name using '-s' parameter e.g. '-s managed-server1'.\"\n+  fi\n+\n+  failIfValidationErrors\n+}\n+\n+initialize\n+\n+# Get the domain in json format\n+domainJson=$(${kubernetesCli} get domain ${domainUid} -n ${domainNamespace} -o json)\n+if [ $? -ne 0 ]; then\n+  printError \"Unable to get domain resource. Please make sure 'domain_uid' and 'namespace' provided with '-d' and '-n' arguments are correct.\"\n+  exit 1\n+fi\n+\n+# Validate that specified server is either part of a cluster or is an independent managed server\n+validateServerAndFindCluster \"${domainUid}\" \"${domainNamespace}\" \"${serverName}\" isValidServer clusterName\n+if [ \"${isValidServer}\" != 'true' ]; then\n+  printError \"Server ${serverName} is not part of any cluster and it's not an independent managed server. Please make sure that server name specified is correct.\"\n+  exit 1\n+fi\n+\n+getClusterPolicy \"${domainJson}\" \"${clusterName}\" clusterPolicy\n+if [ \"${clusterPolicy}\" == 'NEVER' ]; then\n+  printError \"Cannot start server '${serverName}', the server's parent cluster '.spec.clusters[?(clusterName=\\\"${clusterName}\\\"].serverStartPolicy' in the domain resource is set to 'NEVER'.\"\n+  exit 1\n+fi\n+\n+getDomainPolicy \"${domainJson}\" domainPolicy\n+if [ \"${domainPolicy}\" == 'NEVER' ]; then\n+  printError \"Cannot start server '${serverName}', the .spec.serverStartPolicy in the domain resource is set to 'NEVER'.\"\n+  exit 1\n+fi\n+\n+getEffectivePolicy \"${domainJson}\" \"${serverName}\" \"${clusterName}\" effectivePolicy\n+if [ -n \"${clusterName}\" ]; then\n+  # Server is part of a cluster, check currently started servers\n+  checkStartedServers \"${domainJson}\" \"${serverName}\" \"${clusterName}\" \"${withReplicas}\" \"${withPolicy}\" serverStarted\n+  if [[ ${effectivePolicy} == \"IF_NEEDED\" && ${serverStarted} == \"true\" ]]; then\n+    printInfo \"No changes needed, exiting. The server should be already started or it's in the process of starting. The start policy for server ${serverName} is ${effectivePolicy} and server is chosen to be started based on current replica count.\"\n+    exit 0\n+  elif [[ \"${effectivePolicy}\" == \"ALWAYS\" && ${serverStarted} == \"true\" ]]; then\n+    printInfo \"No changes needed, exiting. The server should be already started or it's in the process of starting. The start policy for server ${serverName} is ${effectivePolicy}.\"\n+    exit 0\n+  fi\n+else \n+  # Server is an independent managed server. \n+  if [[ \"${effectivePolicy}\" == \"ALWAYS\" || \"${effectivePolicy}\" == \"IF_NEEDED\" ]]; then\n+    printInfo \"No changes needed, exiting. The server should be already started or it's in the process of starting. The start policy for server ${serverName} is ${effectivePolicy}.\"\n+    exit 0\n+  fi\n+fi\n+\n+getServerPolicy \"${domainJson}\" \"${serverName}\" managedServerPolicy\n+targetPolicy=\"ALWAYS\"\n+createServerStartPolicyPatch \"${domainJson}\" \"${serverName}\" \"${targetPolicy}\" alwaysStartPolicyPatch \n+\n+# if server is part of a cluster and replica count will increase\n+if [[ -n ${clusterName} && \"${keepReplicaConstant}\" != 'true' ]]; then\n+  #check if server starts by increasing replicas and unsetting policy\n+  withReplicas=\"INCREASED\"\n+  withPolicy=\"UNSET\"\n+  checkStartedServers \"${domainJson}\" \"${serverName}\" \"${clusterName}\" \"${withReplicas}\" \"${withPolicy}\" startsByReplicaIncreaseAndPolicyUnset\n+  operation=\"INCREMENT\"\n+  createReplicaPatch \"${domainJson}\" \"${clusterName}\" \"${operation}\" incrementReplicaPatch replicaCount\n+  if [[ -n ${managedServerPolicy} && ${startsByReplicaIncreaseAndPolicyUnset} == \"true\" ]]; then\n+    # Server starts by increasing replicas and policy unset, increment and unset\n+    printInfo \"Unsetting the current start policy '${managedServerPolicy}' for '${serverName}' and incrementing replica count.\"\n+    createPatchJsonToUnsetPolicyAndUpdateReplica \"${domainJson}\" \"${serverName}\" \"${incrementReplicaPatch}\" patchJson\n+    action=\"PATCH_REPLICA_AND_UNSET_POLICY\"\n+  elif [[ -z ${managedServerPolicy} && ${startsByReplicaIncreaseAndPolicyUnset} == \"true\" ]]; then\n+    # Start policy is not set, server starts by increasing replicas based on effective policy, increment replicas\n+    printInfo \"Updating replica count for cluster '${clusterName}' to ${replicaCount}.\"\n+    createPatchJsonToUpdateReplica \"${incrementReplicaPatch}\" patchJson\n+    action=\"PATCH_REPLICA\"\n+  else\n+    # Patch server policy to always and increment replicas\n+    printInfo \"Patching start policy of server '${serverName}' from '${effectivePolicy}' to 'ALWAYS' and \\\n+incrementing replica count for cluster '${clusterName}'.\"\n+    createPatchJsonToUpdateReplicaAndPolicy \"${incrementReplicaPatch}\" \"${alwaysStartPolicyPatch}\" patchJson\n+    action=\"PATCH_REPLICA_AND_POLICY\"\n+  fi\n+elif [[ -n ${clusterName} && \"${keepReplicaConstant}\" == 'true' ]]; then\n+  # Replica count needs to stay constant, check if server starts by unsetting policy\n+  withReplicas=\"CONSTANT\"\n+  withPolicy=\"UNSET\"\n+  checkStartedServers \"${domainJson}\" \"${serverName}\" \"${clusterName}\" \"${withReplicas}\" \"${withPolicy}\" startsByPolicyUnset\n+  if [[ \"${effectivePolicy}\" == \"NEVER\" && ${startsByPolicyUnset} == \"true\" ]]; then\n+    # Server starts by unsetting policy, unset policy\n+    printInfo \"Unsetting the current start policy '${effectivePolicy}' for '${serverName}'.\"\n+    createPatchJsonToUnsetPolicy \"${domainJson}\" \"${serverName}\" patchJson\n+    action=\"UNSET_POLICY\"\n+  else\n+    # Patch server policy to always\n+    printInfo \"Patching start policy for '${serverName}' to '${targetPolicy}'.\"\n+    createPatchJsonToUpdatePolicy \"${alwaysStartPolicyPatch}\" patchJson\n+    action=\"PATCH_POLICY\"\n+  fi\n+else\n+  # Server is an independent managed server\n+  printInfo \"Unsetting the current start policy '${effectivePolicy}' for '${serverName}'.\"\n+  createPatchJsonToUnsetPolicy \"${domainJson}\" \"${serverName}\" patchJson\n+  action=\"UNSET_POLICY\"\n+fi\n+\n+if [ \"${verboseMode}\" == \"true\" ]; then\n+  printInfo \"Patching domain with Json string -> ${patchJson}\"\n+fi\n+${kubernetesCli} patch domain ${domainUid} -n ${domainNamespace} --type='merge' --patch \"${patchJson}\" ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "originalPosition": 232}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNTM3MjMx", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-523537231", "createdAt": "2020-11-04T16:36:50Z", "commit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNjozNjo1MVrOHtgT4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNjozNjo1MVrOHtgT4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ3NzM0Nw==", "bodyText": "Now that the script is simplified, it comes to mind that the following printInfos are redundant given that all paths to this point already have a printInfo that says what the script is about to do before calling patch.  If you agree, consider replacing the entire 'case' statement with 'Patch command succeeded' or similar... (Ditto for the stopServer.sh code).", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r517477347", "createdAt": "2020-11-04T16:36:51Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startServer.sh", "diffHunk": "@@ -0,0 +1,252 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+# This script starts a WebLogic managed server in a domain. \n+# Internal code notes :-\n+# - If server start policy is ALWAYS or policy is IF_NEEDED and the server is selected \n+#   to start based on the replica count, it means that server is already started or is\n+#   in the process of starting. In this case, script exits without making any changes.\n+#\n+# - If start policy of servers parent cluster or domain is 'NEVER', script\n+#   fails as server can't be started.\n+#\n+# - If the effective start policy of the server is IF_NEEDED and increasing replica \n+#   count will naturally start the server, the script increases the replica count. \n+#\n+# - If unsetting policy and increasing the replica count will start this server, script unsets\n+#   the policy and increases replica count. For e.g. if replica count is 1 and start policy\n+#   of server2 is NEVER, unsetting policy and increasing replica count will start server2.\n+#\n+# - If option to keep replica count constant ('-k') is selected and unsetting start policy\n+#   will naturally start the server, script will unset the policy. For e.g. if replica count\n+#   is 2 and start policy  of server2 is NEVER, unsetting policy will start server2.\n+#\n+# - If above conditions are not true, it implies that either start policy is NEVER or policy\n+#   is IF_NEEDED but server is not next in the order to start. In this case, script sets start \n+#   policy to ALWAYS. For e.g. replica count is 3 and server10 needs to start. The script also \n+#   increments the replica count by default. If option to keep replica count constant ('-k') \n+#   is selected, it only sets the start policy to ALWAYS.\n+# \n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+if [ \"${debug}\" == \"true\" ]; then set -x; fi;\n+set -eu\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script starts a WebLogic managed server in a domain either by increasing\n+  the value of 'spec.clusters[<cluster-name>].replicas' by '1' or by updating the\n+  'spec.managedServers[<server-name>].serverStartPolicy' attribute of the domain\n+  resource or both as necessary. The 'spec.clusters[<cluster-name>].replicas' value can\n+  be kept constant by using '-k' option. Please see README.md for more details.\n+\n+  Usage:\n+\n+    $(basename $0) -s myserver [-n mynamespace] [-d mydomainuid] [-k] [-m kubecli] [-v]\n+\n+    -s <server_name>           : Server name parameter is required.\n+\n+    -d <domain_uid>            : Domain unique-id. Default is 'sample-domain1'.\n+\n+    -n <namespace>             : Domain namespace. Default is 'sample-domain1-ns'.\n+\n+    -k <keep_replica_constant> : Keep replica count constant. Default behavior is to increment replica count.\n+\n+    -m <kubernetes_cli>        : Kubernetes command line interface. Default is 'kubectl' if KUBERNETES_CLI env\n+                                 variable is not set. Otherwise default is the value of KUBERNETES_CLI env variable.\n+\n+    -v <verbose_mode>          : Enables verbose mode. Default is 'false'.\n+\n+    -h                         : This help.\n+   \n+EOF\n+exit $1\n+}\n+\n+kubernetesCli=${KUBERNETES_CLI:-kubectl}\n+serverName=\"\"\n+clusterName=\"\"\n+domainUid=\"sample-domain1\"\n+domainNamespace=\"sample-domain1-ns\"\n+keepReplicaConstant=false\n+verboseMode=false\n+withReplicas=\"CONSTANT\"\n+withPolicy=\"CONSTANT\"\n+managedServerPolicy=\"\"\n+effectivePolicy=\"\"\n+action=\"\"\n+isValidServer=\"\"\n+patchJson=\"\"\n+serverStarted=\"\"\n+startsByPolicyUnset=\"\"\n+startsByReplicaIncreaseAndPolicyUnset=\"\"\n+\n+while getopts \"vkd:n:m:s:h\" opt; do\n+  case $opt in\n+    s) serverName=\"${OPTARG}\"\n+    ;;\n+    n) domainNamespace=\"${OPTARG}\"\n+    ;;\n+    d) domainUid=\"${OPTARG}\"\n+    ;;\n+    k) keepReplicaConstant=true;\n+    ;;\n+    m) kubernetesCli=\"${OPTARG}\"\n+    ;;\n+    v) verboseMode=true;\n+    ;;\n+    h) usage 0\n+    ;;\n+    *) usage 1\n+    ;;\n+  esac\n+done\n+\n+#\n+# Function to perform validations, read files and initialize workspace\n+#\n+function initialize {\n+\n+  # Validate the required files exist\n+  validateErrors=false\n+\n+  validateKubernetesCliAvailable\n+  validateJqAvailable\n+\n+  # Validate that server name parameter is specified.\n+  if [ -z \"${serverName}\" ]; then\n+    validationError \"Please specify a server name using '-s' parameter e.g. '-s managed-server1'.\"\n+  fi\n+\n+  failIfValidationErrors\n+}\n+\n+initialize\n+\n+# Get the domain in json format\n+domainJson=$(${kubernetesCli} get domain ${domainUid} -n ${domainNamespace} -o json)\n+if [ $? -ne 0 ]; then\n+  printError \"Unable to get domain resource. Please make sure 'domain_uid' and 'namespace' provided with '-d' and '-n' arguments are correct.\"\n+  exit 1\n+fi\n+\n+# Validate that specified server is either part of a cluster or is an independent managed server\n+validateServerAndFindCluster \"${domainUid}\" \"${domainNamespace}\" \"${serverName}\" isValidServer clusterName\n+if [ \"${isValidServer}\" != 'true' ]; then\n+  printError \"Server ${serverName} is not part of any cluster and it's not an independent managed server. Please make sure that server name specified is correct.\"\n+  exit 1\n+fi\n+\n+getClusterPolicy \"${domainJson}\" \"${clusterName}\" clusterPolicy\n+if [ \"${clusterPolicy}\" == 'NEVER' ]; then\n+  printError \"Cannot start server '${serverName}', the server's parent cluster '.spec.clusters[?(clusterName=\\\"${clusterName}\\\"].serverStartPolicy' in the domain resource is set to 'NEVER'.\"\n+  exit 1\n+fi\n+\n+getDomainPolicy \"${domainJson}\" domainPolicy\n+if [ \"${domainPolicy}\" == 'NEVER' ]; then\n+  printError \"Cannot start server '${serverName}', the .spec.serverStartPolicy in the domain resource is set to 'NEVER'.\"\n+  exit 1\n+fi\n+\n+getEffectivePolicy \"${domainJson}\" \"${serverName}\" \"${clusterName}\" effectivePolicy\n+if [ -n \"${clusterName}\" ]; then\n+  # Server is part of a cluster, check currently started servers\n+  checkStartedServers \"${domainJson}\" \"${serverName}\" \"${clusterName}\" \"${withReplicas}\" \"${withPolicy}\" serverStarted\n+  if [[ ${effectivePolicy} == \"IF_NEEDED\" && ${serverStarted} == \"true\" ]]; then\n+    printInfo \"No changes needed, exiting. The server should be already started or it's in the process of starting. The start policy for server ${serverName} is ${effectivePolicy} and server is chosen to be started based on current replica count.\"\n+    exit 0\n+  elif [[ \"${effectivePolicy}\" == \"ALWAYS\" && ${serverStarted} == \"true\" ]]; then\n+    printInfo \"No changes needed, exiting. The server should be already started or it's in the process of starting. The start policy for server ${serverName} is ${effectivePolicy}.\"\n+    exit 0\n+  fi\n+else \n+  # Server is an independent managed server. \n+  if [[ \"${effectivePolicy}\" == \"ALWAYS\" || \"${effectivePolicy}\" == \"IF_NEEDED\" ]]; then\n+    printInfo \"No changes needed, exiting. The server should be already started or it's in the process of starting. The start policy for server ${serverName} is ${effectivePolicy}.\"\n+    exit 0\n+  fi\n+fi\n+\n+getServerPolicy \"${domainJson}\" \"${serverName}\" managedServerPolicy\n+targetPolicy=\"ALWAYS\"\n+createServerStartPolicyPatch \"${domainJson}\" \"${serverName}\" \"${targetPolicy}\" alwaysStartPolicyPatch \n+\n+# if server is part of a cluster and replica count will increase\n+if [[ -n ${clusterName} && \"${keepReplicaConstant}\" != 'true' ]]; then\n+  #check if server starts by increasing replicas and unsetting policy\n+  withReplicas=\"INCREASED\"\n+  withPolicy=\"UNSET\"\n+  checkStartedServers \"${domainJson}\" \"${serverName}\" \"${clusterName}\" \"${withReplicas}\" \"${withPolicy}\" startsByReplicaIncreaseAndPolicyUnset\n+  operation=\"INCREMENT\"\n+  createReplicaPatch \"${domainJson}\" \"${clusterName}\" \"${operation}\" incrementReplicaPatch replicaCount\n+  if [[ -n ${managedServerPolicy} && ${startsByReplicaIncreaseAndPolicyUnset} == \"true\" ]]; then\n+    # Server starts by increasing replicas and policy unset, increment and unset\n+    printInfo \"Unsetting the current start policy '${managedServerPolicy}' for '${serverName}' and incrementing replica count.\"\n+    createPatchJsonToUnsetPolicyAndUpdateReplica \"${domainJson}\" \"${serverName}\" \"${incrementReplicaPatch}\" patchJson\n+    action=\"PATCH_REPLICA_AND_UNSET_POLICY\"\n+  elif [[ -z ${managedServerPolicy} && ${startsByReplicaIncreaseAndPolicyUnset} == \"true\" ]]; then\n+    # Start policy is not set, server starts by increasing replicas based on effective policy, increment replicas\n+    printInfo \"Updating replica count for cluster '${clusterName}' to ${replicaCount}.\"\n+    createPatchJsonToUpdateReplica \"${incrementReplicaPatch}\" patchJson\n+    action=\"PATCH_REPLICA\"\n+  else\n+    # Patch server policy to always and increment replicas\n+    printInfo \"Patching start policy of server '${serverName}' from '${effectivePolicy}' to 'ALWAYS' and \\\n+incrementing replica count for cluster '${clusterName}'.\"\n+    createPatchJsonToUpdateReplicaAndPolicy \"${incrementReplicaPatch}\" \"${alwaysStartPolicyPatch}\" patchJson\n+    action=\"PATCH_REPLICA_AND_POLICY\"\n+  fi\n+elif [[ -n ${clusterName} && \"${keepReplicaConstant}\" == 'true' ]]; then\n+  # Replica count needs to stay constant, check if server starts by unsetting policy\n+  withReplicas=\"CONSTANT\"\n+  withPolicy=\"UNSET\"\n+  checkStartedServers \"${domainJson}\" \"${serverName}\" \"${clusterName}\" \"${withReplicas}\" \"${withPolicy}\" startsByPolicyUnset\n+  if [[ \"${effectivePolicy}\" == \"NEVER\" && ${startsByPolicyUnset} == \"true\" ]]; then\n+    # Server starts by unsetting policy, unset policy\n+    printInfo \"Unsetting the current start policy '${effectivePolicy}' for '${serverName}'.\"\n+    createPatchJsonToUnsetPolicy \"${domainJson}\" \"${serverName}\" patchJson\n+    action=\"UNSET_POLICY\"\n+  else\n+    # Patch server policy to always\n+    printInfo \"Patching start policy for '${serverName}' to '${targetPolicy}'.\"\n+    createPatchJsonToUpdatePolicy \"${alwaysStartPolicyPatch}\" patchJson\n+    action=\"PATCH_POLICY\"\n+  fi\n+else\n+  # Server is an independent managed server\n+  printInfo \"Unsetting the current start policy '${effectivePolicy}' for '${serverName}'.\"\n+  createPatchJsonToUnsetPolicy \"${domainJson}\" \"${serverName}\" patchJson\n+  action=\"UNSET_POLICY\"\n+fi\n+\n+if [ \"${verboseMode}\" == \"true\" ]; then\n+  printInfo \"Patching domain with Json string -> ${patchJson}\"\n+fi\n+${kubernetesCli} patch domain ${domainUid} -n ${domainNamespace} --type='merge' --patch \"${patchJson}\" \n+\n+case ${action} in", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "originalPosition": 234}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5b1044e1c6f4e1b6f03c7415cd47831caeb5cb1", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e5b1044e1c6f4e1b6f03c7415cd47831caeb5cb1", "committedDate": "2020-11-04T18:57:36Z", "message": "More changes based on review comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNjc1NjU0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-523675654", "createdAt": "2020-11-04T19:35:35Z", "commit": {"oid": "e5b1044e1c6f4e1b6f03c7415cd47831caeb5cb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxOTozNTozNlrOHtm2rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxOTozNTozNlrOHtm2rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4NDU1OA==", "bodyText": "If you add || \"${effectivePolicy}\" == \"\" then any callers of this method won't have to check for the \"\" case...", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r517584558", "createdAt": "2020-11-04T19:35:36Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,662 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value for cluster level server start policy.\n+#      Legal return values are \"NEVER\" or \"IF_NEEDED\" or \"\".\n+#\n+function getClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __clusterPolicy=$3\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__clusterPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get server start policy at domain level\n+# $1 - Domain resource in json format\n+# $2 - Return value containing domain level server start policy.\n+#      Legal retrun values are \"NEVER\" or \"IF_NEEDED\" or \"ADMIN_ONLY\".\n+#\n+function getDomainPolicy {\n+  local domainJson=$1\n+  local __domainPolicy=$2\n+  local effectivePolicy=\"\"\n+\n+  eval $__domainPolicy=\"IF_NEEDED\"\n+  domainPolicyCommand=\".spec.serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${domainPolicyCommand}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5b1044e1c6f4e1b6f03c7415cd47831caeb5cb1"}, "originalPosition": 42}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b17410af5db9216b91a2e914ba43e7d42931efc0", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b17410af5db9216b91a2e914ba43e7d42931efc0", "committedDate": "2020-11-04T19:42:06Z", "message": "Chnages for latest review comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38d442d172b9395ee42f9f3b6064b276836226a2", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/38d442d172b9395ee42f9f3b6064b276836226a2", "committedDate": "2020-11-04T19:45:47Z", "message": "Remove unused action variable and assignments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNzMxMDc0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-523731074", "createdAt": "2020-11-04T21:00:11Z", "commit": {"oid": "38d442d172b9395ee42f9f3b6064b276836226a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMTowMDoxMVrOHtphnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMTowMDoxMVrOHtphnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyODMxNg==", "bodyText": "this 'if' isn't needed -- getDomainPolicy now never returns nothing...", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r517628316", "createdAt": "2020-11-04T21:00:11Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,665 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value for cluster level server start policy.\n+#      Legal return values are \"NEVER\" or \"IF_NEEDED\" or \"\".\n+#\n+function getClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __clusterPolicy=$3\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__clusterPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get server start policy at domain level\n+# $1 - Domain resource in json format\n+# $2 - Return value containing domain level server start policy.\n+#      Legal retrun values are \"NEVER\" or \"IF_NEEDED\" or \"ADMIN_ONLY\".\n+#\n+function getDomainPolicy {\n+  local domainJson=$1\n+  local __domainPolicy=$2\n+  local effectivePolicy=\"\"\n+\n+  eval $__domainPolicy=\"IF_NEEDED\"\n+  domainPolicyCommand=\".spec.serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${domainPolicyCommand}\")\n+  if [[ \"${effectivePolicy}\" == \"null\" || \"${effectivePolicy}\" == \"\" ]]; then\n+    effectivePolicy=\"IF_NEEDED\"\n+  fi\n+  eval $__domainPolicy=\"'${effectivePolicy}'\"\n+}\n+\n+#\n+# Function to get effective start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Name of cluster\n+# $4 - Return value containing effective server start policy\n+#      Legal retrun values are \"NEVER\" or \"IF_NEEDED\" or \"ALWAYS\".\n+#\n+function getEffectivePolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local __currentPolicy=$4\n+  local currentPolicy=\"\"\n+\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentPolicy\n+  if [ -z \"${currentPolicy}\" ]; then\n+    getClusterPolicy \"${domainJson}\" \"${clusterName}\" currentPolicy\n+    if [ -z \"${currentPolicy}\" ]; then\n+      # Start policy is not set at cluster level, check at domain level\n+      getDomainPolicy \"${domainJson}\" currentPolicy\n+      if [ -z \"${currentPolicy}\" ]; then", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38d442d172b9395ee42f9f3b6064b276836226a2"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNzMxNjUw", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-523731650", "createdAt": "2020-11-04T21:01:02Z", "commit": {"oid": "38d442d172b9395ee42f9f3b6064b276836226a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMTowMTowMlrOHtpjPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMTowMTowMlrOHtpjPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyODczMg==", "bodyText": "&& --> ||", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r517628732", "createdAt": "2020-11-04T21:01:02Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startCluster.sh", "diffHunk": "@@ -0,0 +1,124 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+if [ \"${debug}\" == \"true\" ]; then set -x; fi;\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script starts a WebLogic cluster in a domain by patching\n+  'spec.clusters[<cluster-name>].serverStartPolicy' attribute of the domain\n+  resource to 'IF_NEEDED'. This change will cause the operator to initiate\n+  startup of cluster's WebLogic server instance pods if the pods are not\n+  already running and the spec.replicas or\n+  'spec.clusters[<cluster-name>].serverStartPolicy' is set higher than zero.\n+ \n+  Usage:\n+ \n+    $(basename $0) -c mycluster [-n mynamespace] [-d mydomainuid] [-m kubecli]\n+  \n+    -c <cluster-name>   : Cluster name parameter is required.\n+\n+    -d <domain_uid>     : Domain unique-id. Default is 'sample-domain1'.\n+\n+    -n <namespace>      : Domain namespace. Default is 'sample-domain1-ns'.\n+\n+    -m <kubernetes_cli> : Kubernetes command line interface. Default is 'kubectl' if KUBERNETES_CLI env\n+                          variable is not set. Otherwise default is the value of KUBERNETES_CLI env variable.\n+\n+    -v <verbose_mode>   : Enables verbose mode. Default is 'false'.\n+\n+    -h                  : This help.\n+   \n+EOF\n+exit $1\n+}\n+\n+set -eu\n+\n+kubernetesCli=${KUBERNETES_CLI:-kubectl}\n+clusterName=\"\"\n+domainUid=\"sample-domain1\"\n+domainNamespace=\"sample-domain1-ns\"\n+verboseMode=false\n+patchJson=\"\"\n+\n+while getopts \"vc:n:m:d:h\" opt; do\n+  case $opt in\n+    c) clusterName=\"${OPTARG}\"\n+    ;;\n+    n) domainNamespace=\"${OPTARG}\"\n+    ;;\n+    d) domainUid=\"${OPTARG}\"\n+    ;;\n+    m) kubernetesCli=\"${OPTARG}\"\n+    ;;\n+    v) verboseMode=true;\n+    ;;\n+    h) usage 0\n+    ;;\n+    *) usage 1\n+    ;;\n+  esac\n+done\n+\n+#\n+# Function to perform validations, read files and initialize workspace\n+#\n+function initialize {\n+\n+  validateErrors=false\n+\n+  validateKubernetesCliAvailable\n+  validateJqAvailable\n+\n+  if [ -z \"${clusterName}\" ]; then\n+    validationError \"Please specify cluster name using '-c' parameter e.g. '-c cluster-1'.\"\n+  fi\n+\n+  isValidCluster=\"\"\n+  validateClusterName \"${domainUid}\" \"${domainNamespace}\" \"${clusterName}\" isValidCluster\n+\n+  if [ \"${isValidCluster}\" != 'true' ]; then\n+    validationError \"cluster ${clusterName} is not part of domain ${domainUid} in namespace ${domainNamespace}.\"\n+  fi\n+\n+  failIfValidationErrors\n+}\n+\n+initialize\n+\n+# Get the domain in json format\n+domainJson=$(${kubernetesCli} get domain ${domainUid} -n ${domainNamespace} -o json)\n+\n+getDomainPolicy \"${domainJson}\" domainStartPolicy\n+# Fail if effective start policy of domain is NEVER or ADMIN_ONLY\n+if [[ \"${domainStartPolicy}\" == 'NEVER' && \"${domainStartPolicy}\" == 'ADMIN_ONLY' ]]; then", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38d442d172b9395ee42f9f3b6064b276836226a2"}, "originalPosition": 102}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNzMyODI0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-523732824", "createdAt": "2020-11-04T21:02:58Z", "commit": {"oid": "38d442d172b9395ee42f9f3b6064b276836226a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMTowMjo1OFrOHtpmuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMTowMjo1OFrOHtpmuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyOTYyNQ==", "bodyText": "What should this do if the DomainPolicy is 'ADMIN_ONLY'?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r517629625", "createdAt": "2020-11-04T21:02:58Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startServer.sh", "diffHunk": "@@ -0,0 +1,225 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+# This script starts a WebLogic managed server in a domain. \n+# Internal code notes :-\n+# - If server start policy is ALWAYS or policy is IF_NEEDED and the server is selected \n+#   to start based on the replica count, it means that server is already started or is\n+#   in the process of starting. In this case, script exits without making any changes.\n+#\n+# - If start policy of servers parent cluster or domain is 'NEVER', script\n+#   fails as server can't be started.\n+#\n+# - If server is part of a cluster and keep_replica_constant option is false (the default)\n+#   and the effective start policy of the server is IF_NEEDED and increasing replica count\n+#   will naturally start the server, the script increases the replica count. \n+#\n+# - If server is part of a cluster and keep_replica_constant option is false (the default) \n+#   and unsetting policy and increasing the replica count will start this server, script \n+#   unsets the policy and increases replica count. For e.g. if replica count is 1 and \n+#   start policy of server2 is NEVER, unsetting policy and increasing replica count will \n+#   start server2.\n+#\n+# - If option to keep replica count constant ('-k') is selected and unsetting start policy\n+#   will naturally start the server, script will unset the policy. For e.g. if replica count\n+#   is 2 and start policy  of server2 is NEVER, unsetting policy will start server2.\n+#\n+# - If above conditions are not true, it implies that either start policy is NEVER or policy\n+#   is IF_NEEDED but server is not next in the order to start. In this case, script sets start \n+#   policy to ALWAYS. For e.g. replica count is 3 and server10 needs to start. The script also \n+#   increments the replica count by default. If option to keep replica count constant ('-k') \n+#   is selected, it only sets the start policy to ALWAYS.\n+# \n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+if [ \"${debug}\" == \"true\" ]; then set -x; fi;\n+set -eu\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script starts a WebLogic managed server in a domain either by increasing\n+  the value of 'spec.clusters[<cluster-name>].replicas' by '1' or by updating the\n+  'spec.managedServers[<server-name>].serverStartPolicy' attribute of the domain\n+  resource or both as necessary. The 'spec.clusters[<cluster-name>].replicas' value can\n+  be kept constant by using '-k' option. Please see README.md for more details.\n+\n+  Usage:\n+\n+    $(basename $0) -s myserver [-n mynamespace] [-d mydomainuid] [-k] [-m kubecli] [-v]\n+\n+    -s <server_name>           : Server name parameter is required.\n+\n+    -d <domain_uid>            : Domain unique-id. Default is 'sample-domain1'.\n+\n+    -n <namespace>             : Domain namespace. Default is 'sample-domain1-ns'.\n+\n+    -k <keep_replica_constant> : Keep replica count constant. Default behavior is to increment replica count.\n+\n+    -m <kubernetes_cli>        : Kubernetes command line interface. Default is 'kubectl' if KUBERNETES_CLI env\n+                                 variable is not set. Otherwise default is the value of KUBERNETES_CLI env variable.\n+\n+    -v <verbose_mode>          : Enables verbose mode. Default is 'false'.\n+\n+    -h                         : This help.\n+   \n+EOF\n+exit $1\n+}\n+\n+kubernetesCli=${KUBERNETES_CLI:-kubectl}\n+serverName=\"\"\n+clusterName=\"\"\n+domainUid=\"sample-domain1\"\n+domainNamespace=\"sample-domain1-ns\"\n+keepReplicaConstant=false\n+verboseMode=false\n+withReplicas=\"CONSTANT\"\n+withPolicy=\"CONSTANT\"\n+managedServerPolicy=\"\"\n+effectivePolicy=\"\"\n+isValidServer=\"\"\n+patchJson=\"\"\n+serverStarted=\"\"\n+startsByPolicyUnset=\"\"\n+startsByReplicaIncreaseAndPolicyUnset=\"\"\n+\n+while getopts \"vkd:n:m:s:h\" opt; do\n+  case $opt in\n+    s) serverName=\"${OPTARG}\"\n+    ;;\n+    n) domainNamespace=\"${OPTARG}\"\n+    ;;\n+    d) domainUid=\"${OPTARG}\"\n+    ;;\n+    k) keepReplicaConstant=true;\n+    ;;\n+    m) kubernetesCli=\"${OPTARG}\"\n+    ;;\n+    v) verboseMode=true;\n+    ;;\n+    h) usage 0\n+    ;;\n+    *) usage 1\n+    ;;\n+  esac\n+done\n+\n+#\n+# Function to perform validations, read files and initialize workspace\n+#\n+function initialize {\n+\n+  # Validate the required files exist\n+  validateErrors=false\n+\n+  validateKubernetesCliAvailable\n+  validateJqAvailable\n+\n+  # Validate that server name parameter is specified.\n+  if [ -z \"${serverName}\" ]; then\n+    validationError \"Please specify a server name using '-s' parameter e.g. '-s managed-server1'.\"\n+  fi\n+\n+  failIfValidationErrors\n+}\n+\n+initialize\n+\n+# Get the domain in json format\n+domainJson=$(${kubernetesCli} get domain ${domainUid} -n ${domainNamespace} -o json)\n+if [ $? -ne 0 ]; then\n+  printError \"Unable to get domain resource. Please make sure 'domain_uid' and 'namespace' provided with '-d' and '-n' arguments are correct.\"\n+  exit 1\n+fi\n+\n+# Validate that specified server is either part of a cluster or is an independent managed server\n+validateServerAndFindCluster \"${domainUid}\" \"${domainNamespace}\" \"${serverName}\" isValidServer clusterName\n+if [ \"${isValidServer}\" != 'true' ]; then\n+  printError \"Server ${serverName} is not part of any cluster and it's not an independent managed server. Please make sure that server name specified is correct.\"\n+  exit 1\n+fi\n+\n+getClusterPolicy \"${domainJson}\" \"${clusterName}\" clusterPolicy\n+if [ \"${clusterPolicy}\" == 'NEVER' ]; then\n+  printError \"Cannot start server '${serverName}', the server's parent cluster '.spec.clusters[?(clusterName=\\\"${clusterName}\\\"].serverStartPolicy' in the domain resource is set to 'NEVER'.\"\n+  exit 1\n+fi\n+\n+getDomainPolicy \"${domainJson}\" domainPolicy\n+if [ \"${domainPolicy}\" == 'NEVER' ]; then\n+  printError \"Cannot start server '${serverName}', the .spec.serverStartPolicy in the domain resource is set to 'NEVER'.\"\n+  exit 1\n+fi\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38d442d172b9395ee42f9f3b6064b276836226a2"}, "originalPosition": 159}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNzMzNDk5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-523733499", "createdAt": "2020-11-04T21:04:03Z", "commit": {"oid": "38d442d172b9395ee42f9f3b6064b276836226a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMTowNDowM1rOHtpo4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMTowNDowM1rOHtpo4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzMDE3Nw==", "bodyText": "|| \"${startPolicy}\" = \"ADMIN_ONLY\"", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r517630177", "createdAt": "2020-11-04T21:04:03Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/stopCluster.sh", "diffHunk": "@@ -0,0 +1,115 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+if [ \"${debug}\" == \"true\" ]; then set -x; fi;\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script stops a WebLogic cluster in a domain by patching\n+  'spec.clusters[<cluster-name>].serverStartPolicy' attribute of the domain\n+  resource to 'NEVER'. This change will cause the operator to initiate shutdown\n+  of cluster's WebLogic server instance pods if the pods are running.\n+ \n+  Usage:\n+ \n+    $(basename $0) -c mycluster [-n mynamespace] [-d mydomainuid] [-m kubecli]\n+  \n+    -c <cluster-name>   : Cluster name parameter is required.\n+\n+    -d <domain_uid>     : Domain unique-id. Default is 'sample-domain1'.\n+\n+    -n <namespace>      : Domain namespace. Default is 'sample-domain1-ns'.\n+\n+    -m <kubernetes_cli> : Kubernetes command line interface. Default is 'kubectl' if KUBERNETES_CLI env\n+                          variable is not set. Otherwise default is the value of KUBERNETES_CLI env variable.\n+\n+    -v <verbose_mode>   : Enables verbose mode. Default is 'false'.\n+\n+    -h                  : This help.\n+   \n+EOF\n+exit $1\n+}\n+\n+kubernetesCli=${KUBERNETES_CLI:-kubectl}\n+clusterName=\"\"\n+domainUid=\"sample-domain1\"\n+domainNamespace=\"sample-domain1-ns\"\n+verboseMode=false\n+patchJson=\"\"\n+\n+while getopts \"vc:n:m:d:h\" opt; do\n+  case $opt in\n+    c) clusterName=\"${OPTARG}\"\n+    ;;\n+    n) domainNamespace=\"${OPTARG}\"\n+    ;;\n+    d) domainUid=\"${OPTARG}\"\n+    ;;\n+    m) kubernetesCli=\"${OPTARG}\"\n+    ;;\n+    v) verboseMode=true;\n+    ;;\n+    h) usage 0\n+    ;;\n+    *) usage 1\n+    ;;\n+  esac\n+done\n+\n+set -eu\n+\n+#\n+# Function to perform validations, read files and initialize workspace\n+#\n+function initialize {\n+\n+  validateErrors=false\n+\n+  validateKubernetesCliAvailable\n+  validateJqAvailable\n+\n+  if [ -z \"${clusterName}\" ]; then\n+    validationError \"Please specify cluster name using '-c' parameter e.g. '-c cluster-1'.\"\n+  fi\n+\n+  isValidCluster=\"\"\n+  validateClusterName \"${domainUid}\" \"${domainNamespace}\" \"${clusterName}\" isValidCluster\n+\n+  if [ \"${isValidCluster}\" != 'true' ]; then\n+    validationError \"cluster ${clusterName} is not part of domain ${domainUid} in namespace ${domainNamespace}. \"\n+  fi\n+\n+  failIfValidationErrors\n+}\n+\n+initialize\n+\n+# Get the domain in json format\n+domainJson=$(${kubernetesCli} get domain ${domainUid} -n ${domainNamespace} -o json)\n+\n+# Get server start policy for this server\n+getClusterPolicy \"${domainJson}\" \"${clusterName}\" startPolicy\n+if [ -z \"${startPolicy}\" ]; then\n+  getDomainPolicy \"${domainJson}\" startPolicy\n+fi\n+\n+if [ \"${startPolicy}\" == 'NEVER' ]; then ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38d442d172b9395ee42f9f3b6064b276836226a2"}, "originalPosition": 104}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNzM5NTY5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-523739569", "createdAt": "2020-11-04T21:13:58Z", "commit": {"oid": "38d442d172b9395ee42f9f3b6064b276836226a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMToxMzo1OFrOHtp6-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMToxMzo1OFrOHtp6-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzNDgwOQ==", "bodyText": "Is this another occurrence of get cm that should have a helpful message if it fails?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r517634809", "createdAt": "2020-11-04T21:13:58Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,665 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value for cluster level server start policy.\n+#      Legal return values are \"NEVER\" or \"IF_NEEDED\" or \"\".\n+#\n+function getClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __clusterPolicy=$3\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__clusterPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get server start policy at domain level\n+# $1 - Domain resource in json format\n+# $2 - Return value containing domain level server start policy.\n+#      Legal retrun values are \"NEVER\" or \"IF_NEEDED\" or \"ADMIN_ONLY\".\n+#\n+function getDomainPolicy {\n+  local domainJson=$1\n+  local __domainPolicy=$2\n+  local effectivePolicy=\"\"\n+\n+  eval $__domainPolicy=\"IF_NEEDED\"\n+  domainPolicyCommand=\".spec.serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${domainPolicyCommand}\")\n+  if [[ \"${effectivePolicy}\" == \"null\" || \"${effectivePolicy}\" == \"\" ]]; then\n+    effectivePolicy=\"IF_NEEDED\"\n+  fi\n+  eval $__domainPolicy=\"'${effectivePolicy}'\"\n+}\n+\n+#\n+# Function to get effective start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Name of cluster\n+# $4 - Return value containing effective server start policy\n+#      Legal retrun values are \"NEVER\" or \"IF_NEEDED\" or \"ALWAYS\".\n+#\n+function getEffectivePolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local __currentPolicy=$4\n+  local currentPolicy=\"\"\n+\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentPolicy\n+  if [ -z \"${currentPolicy}\" ]; then\n+    getClusterPolicy \"${domainJson}\" \"${clusterName}\" currentPolicy\n+    if [ -z \"${currentPolicy}\" ]; then\n+      # Start policy is not set at cluster level, check at domain level\n+      getDomainPolicy \"${domainJson}\" currentPolicy\n+      if [ -z \"${currentPolicy}\" ]; then\n+        # Start policy is not set at domain level, default to IF_NEEDED\n+        currentPolicy=IF_NEEDED\n+      fi\n+    fi\n+  fi\n+  eval $__currentPolicy=\"'${currentPolicy}'\"\n+}\n+\n+#\n+# Function to get current start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Return value containing current server start policy\n+#      Legal retrun values are \"NEVER\" or \"IF_NEEDED\", \"ALWAYS\" or \"\".\n+#\n+function getServerPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __currentPolicy=$3\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  eval $__currentPolicy=\"\"\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentServerStartPolicy=$(echo ${domainJson} | jq \"${extractPolicyCmd}\")\n+    if [ \"${currentServerStartPolicy}\" == \"null\" ]; then\n+      currentServerStartPolicy=\"\"\n+    fi\n+  fi\n+  eval $__currentPolicy=\"'${currentServerStartPolicy}'\"\n+}\n+\n+#\n+# Function to create server start policy patch string\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Policy value \n+# $4 - Return value containing server start policy patch string\n+#\n+function createServerStartPolicyPatch {\n+  local domainJson=$1\n+  local serverName=$2\n+  local policy=$3\n+  local __result=$4\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentServerStartPolicy\n+  if [ -z \"${currentServerStartPolicy}\" ]; then\n+    # Server start policy doesn't exist, add a new policy\n+    addPolicyCmd=\".[.| length] |= . + {\\\"serverName\\\":\\\"${serverName}\\\", \\\n+      \\\"serverStartPolicy\\\":\\\"${policy}\\\"}\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq .spec.managedServers | jq -c \"${addPolicyCmd}\")\n+  else\n+    # Server start policy exists, replace policy value \n+    replacePolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy) |= \\\"${policy}\\\"\"\n+    servers=\"(.spec.managedServers)\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\" | jq -cr \"${servers}\")\n+  fi\n+  eval $__result=\"'${serverStartPolicyPatch}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy and update replica\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - String containing replica patch string\n+# $4 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicyAndUpdateReplica {\n+  local domainJson=$1\n+  local serverName=$2\n+  local replicaPatch=$3\n+  local __result=$4\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaPatch}\",\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update policy \n+# $1 - String containing start policy info\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdatePolicy {\n+  local startPolicy=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update replica \n+# $1 - String containing replica\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdateReplica {\n+  local replicaInfo=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update replica and policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUpdateReplicaAndPolicy {\n+  local replicaInfo=$1\n+  local startPolicy=$2\n+  local __result=$3\n+\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\",\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __result=$3\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json to update cluster server start policy\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster whose policy will be patched\n+# $3 - policy value of \"IF_NEEDED\" or \"NEVER\"\n+# $4 - Return value containing patch json string\n+#\n+function createPatchJsonToUpdateClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local policy=$3\n+  local __result=$4\n+  \n+  replacePolicyCmd=\"(.spec.clusters[] | select (.clusterName == \\\"${clusterName}\\\") \\\n+    | .serverStartPolicy) |= \\\"${policy}\\\"\"\n+  startPolicy=$(echo ${domainJson} | jq \"${replacePolicyCmd}\" | jq -cr '(.spec.clusters)')\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json to update domain server start policy\n+# $1 - policy value of \"IF_NEEDED\" or \"NEVER\"\n+# $2 - Return value containing patch json string\n+#\n+function createPatchJsonToUpdateDomainPolicy {\n+  local policy=$1\n+  local __result=$2\n+  \n+  patchServerStartPolicy=\"{\\\"spec\\\": {\\\"serverStartPolicy\\\": \\\"${policy}\\\"}}\"\n+  eval $__result=\"'${patchServerStartPolicy}'\"\n+}\n+\n+#\n+# Function to get sorted list of servers in a cluster.\n+# The sorted list is created in 'sortedByAlwaysServers' array.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if policy of current server would be unset.\n+#      valid values are \"UNSET\" and \"CONSTANT\"\n+#\n+function getSortedListOfServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withPolicy=$4\n+  local policy=\"\"\n+  local sortedServers=()\n+  local otherServers=()\n+  errorMessage=\"Domain config map '${domainUid}-weblogic-domain-introspect-cm' not found. \\\n+    This script will requires that the introspector job for the specified domain ran \\\n+    successfully and generated this config map. Exiting.\"\n+\n+  configMap=$(set +e && ${kubernetesCli} get cm ${domainUid}-weblogic-domain-introspect-cm \\\n+    -n ${domainNamespace} -o json || printError ${errorMessage} && exit 1)\n+  topology=$(echo \"${configMap}\" | jq '.data[\"topology.yaml\"]')\n+  jsonTopology=$(python -c \\\n+    'import sys, yaml, json; print json.dumps(yaml.safe_load('\"${topology}\"'), indent=4)')\n+  clusterTopology=$(echo ${jsonTopology} | jq -r '.domain | .configuredClusters[] | select (.name == '\\\"${clusterName}\\\"')')\n+  dynaCluster=$(echo ${clusterTopology} | jq .dynamicServersConfig)\n+  if [ \"${dynaCluster}\" == \"null\" ]; then\n+    # Cluster is a configured cluster, get server names\n+    servers=($(echo ${clusterTopology} | jq -r .servers[].name))\n+    # Sort server names in numero lexi order\n+    IFS=$'\\n' sortedServers=($(sort --version-sort <<<\"${servers[*]}\" ))\n+    unset IFS\n+    clusterSize=${#sortedServers[@]}\n+  else \n+    # Cluster is a dynamic cluster, calculate server names\n+    prefix=$(echo ${dynaCluster} | jq -r .serverNamePrefix)\n+    clusterSize=$(echo ${dynaCluster} | jq .dynamicClusterSize) \n+    for (( i=1; i<=$clusterSize; i++ )); do\n+      localServerName=${prefix}$i\n+      sortedServers+=(${localServerName})\n+    done\n+  fi\n+  # Create arrays of ALWAYS policy servers and other servers\n+  for localServerName in ${sortedServers[@]:-}; do\n+    getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+    # Update policy when server name matches current server and unsetting\n+    if [[ \"${withPolicy}\" == \"UNSET\" && \"${serverName}\" == \"${localServerName}\" ]]; then\n+      policy=UNSET\n+    fi\n+    if [ \"${policy}\" == \"ALWAYS\" ]; then\n+      sortedByAlwaysServers+=(${localServerName})\n+    else\n+      otherServers+=(${localServerName})\n+    fi\n+  done\n+  \n+  # append other servers to the list of servers with always policy\n+  for otherServer in ${otherServers[@]:-}; do\n+    sortedByAlwaysServers+=($otherServer)\n+  done\n+}\n+\n+#\n+# Get replica count for a cluster\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster \n+# $3 - Return value containing replica count\n+#\n+function getReplicaCount {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __replicaCount=$3\n+\n+  replicasCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).replicas\"\n+  replicaCount=$(echo ${domainJson} | jq \"${replicasCmd}\")\n+  if [[ -z \"${replicaCount}\" || \"${replicaCount}\" == \"null\" ]]; then\n+    replicaCount=$(echo ${domainJson} | jq .spec.replicas)\n+  fi\n+  if [[ -z \"${replicaCount}\" || \"${replicaCount}\" == \"null\" ]]; then\n+    replicaCount=0\n+  fi\n+  eval $__replicaCount=\"'${replicaCount}'\"\n+\n+}\n+\n+#\n+# Check servers started in a cluster based on server start policy and \n+# replica count.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if replicas will stay constant, incremented or decremented.\n+#      Valid values are \"CONSTANT\", \"INCREMENT\" and \"DECREMENT\"\n+# $5 - Indicates if policy of current server will stay constant or unset.\n+#      Valid values are \"CONSTANT\" and \"UNSET\"\n+# $6 - Return value of \"true\" or \"false\" indicating if current server will be started\n+#\n+function checkStartedServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withReplicas=$4\n+  local withPolicy=$5\n+  local __started=$6\n+  local localServerName=\"\"\n+  local policy=\"\"\n+  local replicaCount=0\n+  local currentReplicas=0\n+  local startedServers=()\n+  local sortedByAlwaysServers=()\n+  \n+  # Get sorted list of servers in 'sortedByAlwaysServers' array\n+  getSortedListOfServers \"${domainJson}\" \"${serverName}\" \"${clusterName}\" \"${withPolicy}\"\n+  getReplicaCount \"${domainJson}\" \"${clusterName}\" replicaCount\n+  # Increment or decrement the replica count based on 'withReplicas' input parameter\n+  if [ \"${withReplicas}\" == \"INCREASED\" ]; then\n+    replicaCount=$((replicaCount+1))\n+  elif [ \"${withReplicas}\" == \"DECREASED\" ]; then\n+    replicaCount=$((replicaCount-1))\n+  fi\n+  for localServerName in ${sortedByAlwaysServers[@]:-}; do\n+    getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+    # Update policy when server name matches current server and unsetting\n+    if [[ \"${serverName}\" == \"${localServerName}\" && \"${withPolicy}\" == \"UNSET\" ]]; then\n+      policy=UNSET\n+    fi\n+    # check if server should start based on replica count, policy and current replicas\n+    shouldStart \"${currentReplicas}\" \"${policy}\" \"${replicaCount}\" result\n+    if [ \"${result}\" == 'true' ]; then\n+      # server should start, increment current replicas and add server to list of started servers\n+      currentReplicas=$((currentReplicas+1))\n+      startedServers+=(${localServerName})\n+    fi\n+  done\n+  startedSize=${#startedServers[@]}\n+  if [ ${startedSize} -gt 0 ]; then\n+    # check if current server is in the list of started servers\n+    if checkStringInArray ${serverName} ${startedServers[@]}; then\n+      eval $__started=\"true\"\n+      return\n+    fi\n+  fi\n+  eval $__started=\"false\"\n+}\n+\n+#\n+# Function to check if server should start based on policy and current replicas\n+# $1 - Current number of replicas\n+# $2 - Server start policy\n+# $3 - Replica count\n+# $4 - Returns \"true\" or \"false\" indicating if server should start.\n+#\n+function shouldStart {\n+  local currentReplicas=$1\n+  local policy=$2\n+  local replicaCount=$3 \n+  local __result=$4\n+\n+  if [ \"$policy\" == \"ALWAYS\" ]; then\n+    eval $__result=true\n+  elif [ \"$policy\" == \"NEVER\" ]; then\n+    eval $__result=false\n+  elif [ \"${currentReplicas}\" -lt \"${replicaCount}\" ]; then\n+    eval $__result=true\n+  else \n+    eval $__result=false\n+  fi\n+}\n+\n+#\n+# Function to create patch string for updating replica count\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster whose replica count will be patched\n+# $3 - operation string indicating whether to increment or decrement replica count. \n+#      Valid values are \"INCREMENT\" and \"DECREMENT\"\n+# $4 - Return value containing replica update patch string\n+# $5 - Return value containing updated replica count\n+#\n+function createReplicaPatch {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local operation=$3\n+  local __result=$4\n+  local __replicaCount=$5\n+  local maxReplicas=\"\"\n+  local infoMessage=\"Current replica count value is same as or greater than maximum number of replica count. \\\n+Not increasing replica count value.\"\n+\n+  maxReplicaCmd=\"(.status.clusters[] | select (.clusterName == \\\"${clusterName}\\\")) \\\n+    | .maximumReplicas\"\n+  getReplicaCount  \"${domainJson}\" \"${clusterName}\" replica\n+  if [ \"${operation}\" == \"DECREMENT\" ]; then\n+    replica=$((replica-1))\n+    if [ ${replica} -lt 0 ]; then\n+      replica=0\n+    fi\n+  elif [ \"${operation}\" == \"INCREMENT\" ]; then\n+    maxReplicas=$(echo ${domainJson} | jq \"${maxReplicaCmd}\")\n+    if [ ${replica} -ge ${maxReplicas} ]; then\n+      printInfo \"${infoMessage}\"\n+    else\n+      replica=$((replica+1))\n+    fi\n+  fi\n+\n+  cmd=\"(.spec.clusters[] | select (.clusterName == \\\"${clusterName}\\\") \\\n+    | .replicas) |= ${replica}\"\n+  replicaPatch=$(echo ${domainJson} | jq \"${cmd}\" | jq -cr '(.spec.clusters)')\n+  eval $__result=\"'${replicaPatch}'\"\n+  eval $__replicaCount=\"'${replica}'\"\n+}\n+\n+#\n+# Function to validate whether a server belongs to a  cluster or is an independent managed server\n+# $1 - Domain unique id.\n+# $2 - Domain namespace.\n+# $3 - Server name.\n+# $4 - Return value of \"true\" or \"false\" indicating if server is valid (i.e. if it's part of a cluster or independent server).\n+# $5 - Retrun value containting cluster name to which this server belongs.\n+#\n+function validateServerAndFindCluster {\n+  local domainUid=$1\n+  local domainNamespace=$2 \n+  local serverName=$3\n+  local __isValidServer=$4\n+  local __clusterName=$5\n+  local serverCount=\"\"\n+  local errorMessage=\"Server name is outside the range of allowed servers. \\\n+Please make sure server name is correct.\"\n+\n+  eval $__isValidServer=false\n+  eval $__clusterName=UNKNOWN\n+  configMap=$(${kubernetesCli} get cm ${domainUid}-weblogic-domain-introspect-cm \\\n+    -n ${domainNamespace} -o json)\n+  topology=$(echo \"${configMap}\" | jq '.data[\"topology.yaml\"]')\n+  jsonTopology=$(python -c \\\n+    'import sys, yaml, json; print json.dumps(yaml.safe_load('\"${topology}\"'), indent=4)')\n+  servers=($(echo $jsonTopology | jq -r '.domain.servers[].name'))\n+  if  checkStringInArray \"${serverName}\" \"${servers[@]}\" ; then\n+    eval $__clusterName=\"\"\n+    eval $__isValidServer=true\n+  else\n+    dynamicClause=\".domain.configuredClusters[] | select (.dynamicServersConfig != null)\"\n+    namePrefixSize=\". | {name: .name, prefix:.dynamicServersConfig.serverNamePrefix, \\\n+                 max:.dynamicServersConfig.maxDynamicClusterSize}\"\n+    dynamicClusters=($(echo $jsonTopology | jq \"${dynamicClause}\" | jq -cr \"${namePrefixSize}\"))\n+    dynamicClustersSize=${#dynamicClusters[@]}\n+    for dynaClusterNamePrefix in ${dynamicClusters[@]:-}; do\n+      prefix=$(echo ${dynaClusterNamePrefix} | jq -r .prefix)\n+      if [[ \"${serverName}\" == \"${prefix}\"* ]]; then\n+        maxSize=$(echo ${dynaClusterNamePrefix} | jq -r .max)\n+        number='^[0-9]+$'\n+        if [ $(echo \"${serverName}\" | grep -c -Eo '[0-9]+$') -gt 0 ]; then\n+          serverCount=$(echo \"${serverName}\" | grep -Eo '[0-9]+$')\n+        fi\n+        if ! [[ $serverCount =~ $number ]] ; then\n+           echo \"error: Server name is not valid for dynamic cluster.\" \n+           exit 1\n+        fi\n+        if [ \"${serverCount}\" -gt \"${maxSize}\" ]; then\n+          printError \"${errorMessage}\"\n+          exit 1\n+        fi\n+        eval $__clusterName=\"'$(echo ${dynaClusterNamePrefix} | jq -r .name)'\"\n+        eval $__isValidServer=true\n+        break\n+      fi\n+    done\n+    staticClause=\".domain.configuredClusters[] | select (.dynamicServersConfig == null)\"\n+    nameCmd=\" . | {name: .name, serverName: .servers[].name}\"\n+    configuredClusters=($(echo $jsonTopology | jq \"${staticClause}\" | jq -cr \"${nameCmd}\"))\n+    configuredClusterSize=${#configuredClusters[@]}\n+    for configuredClusterName in ${configuredClusters[@]:-}; do\n+      name=$(echo ${configuredClusterName} | jq -r .serverName)\n+      if [ \"${serverName}\" == \"${name}\" ]; then\n+        eval $__clusterName=\"'$(echo ${configuredClusterName} | jq -r .name)'\"\n+        eval $__isValidServer=true\n+        break\n+      fi\n+    done\n+  fi\n+}\n+\n+#\n+# Function to validate whether a cluster is valid and part of the domain\n+# $1 - Domain unique id.\n+# $2 - Domain namespace.\n+# $3 - cluster name\n+# $4 - Retrun value \"true\" or \"false\" indicating whether cluster name is valid\n+#\n+function validateClusterName {\n+  local domainUid=$1\n+  local domainNamespace=$2\n+  local clusterName=$3\n+  local __isValidCluster=$4\n+\n+  configMap=$(${kubernetesCli} get cm ${domainUid}-weblogic-domain-introspect-cm \\\n+    -n ${domainNamespace} -o json)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38d442d172b9395ee42f9f3b6064b276836226a2"}, "originalPosition": 546}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4bf493c36e213789df96ec5e5aaa053ded34d82", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e4bf493c36e213789df96ec5e5aaa053ded34d82", "committedDate": "2020-11-04T21:17:18Z", "message": "Fix the logic to display error when config map not found and return policy without quotes."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNzU2OTkz", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-523756993", "createdAt": "2020-11-04T21:43:43Z", "commit": {"oid": "e4bf493c36e213789df96ec5e5aaa053ded34d82"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMTo0Mzo0M1rOHtqwNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMTo0Mzo0M1rOHtqwNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY0ODQzOA==", "bodyText": "echo --> printError", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r517648438", "createdAt": "2020-11-04T21:43:43Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,669 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value for cluster level server start policy.\n+#      Legal return values are \"NEVER\" or \"IF_NEEDED\" or \"\".\n+#\n+function getClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __clusterPolicy=$3\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__clusterPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get server start policy at domain level\n+# $1 - Domain resource in json format\n+# $2 - Return value containing domain level server start policy.\n+#      Legal retrun values are \"NEVER\" or \"IF_NEEDED\" or \"ADMIN_ONLY\".\n+#\n+function getDomainPolicy {\n+  local domainJson=$1\n+  local __domainPolicy=$2\n+  local effectivePolicy=\"\"\n+\n+  eval $__domainPolicy=\"IF_NEEDED\"\n+  domainPolicyCommand=\".spec.serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${domainPolicyCommand}\")\n+  if [[ \"${effectivePolicy}\" == \"null\" || \"${effectivePolicy}\" == \"\" ]]; then\n+    effectivePolicy=\"IF_NEEDED\"\n+  fi\n+  eval $__domainPolicy=\"'${effectivePolicy}'\"\n+}\n+\n+#\n+# Function to get effective start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Name of cluster\n+# $4 - Return value containing effective server start policy\n+#      Legal retrun values are \"NEVER\" or \"IF_NEEDED\" or \"ALWAYS\".\n+#\n+function getEffectivePolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local __currentPolicy=$4\n+  local currentPolicy=\"\"\n+\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentPolicy\n+  if [ -z \"${currentPolicy}\" ]; then\n+    getClusterPolicy \"${domainJson}\" \"${clusterName}\" currentPolicy\n+    if [ -z \"${currentPolicy}\" ]; then\n+      # Start policy is not set at cluster level, check at domain level\n+      getDomainPolicy \"${domainJson}\" currentPolicy\n+      if [ -z \"${currentPolicy}\" ]; then\n+        # Start policy is not set at domain level, default to IF_NEEDED\n+        currentPolicy=IF_NEEDED\n+      fi\n+    fi\n+  fi\n+  eval $__currentPolicy=${currentPolicy}\n+}\n+\n+#\n+# Function to get current start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Return value containing current server start policy\n+#      Legal retrun values are \"NEVER\" or \"IF_NEEDED\", \"ALWAYS\" or \"\".\n+#\n+function getServerPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __currentPolicy=$3\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  eval $__currentPolicy=\"\"\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentServerStartPolicy=$(echo ${domainJson} | jq \"${extractPolicyCmd}\")\n+    if [ \"${currentServerStartPolicy}\" == \"null\" ]; then\n+      currentServerStartPolicy=\"\"\n+    fi\n+  fi\n+  eval $__currentPolicy=${currentServerStartPolicy}\n+}\n+\n+#\n+# Function to create server start policy patch string\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Policy value \n+# $4 - Return value containing server start policy patch string\n+#\n+function createServerStartPolicyPatch {\n+  local domainJson=$1\n+  local serverName=$2\n+  local policy=$3\n+  local __result=$4\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentServerStartPolicy\n+  if [ -z \"${currentServerStartPolicy}\" ]; then\n+    # Server start policy doesn't exist, add a new policy\n+    addPolicyCmd=\".[.| length] |= . + {\\\"serverName\\\":\\\"${serverName}\\\", \\\n+      \\\"serverStartPolicy\\\":\\\"${policy}\\\"}\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq .spec.managedServers | jq -c \"${addPolicyCmd}\")\n+  else\n+    # Server start policy exists, replace policy value \n+    replacePolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy) |= \\\"${policy}\\\"\"\n+    servers=\"(.spec.managedServers)\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\" | jq -cr \"${servers}\")\n+  fi\n+  eval $__result=\"'${serverStartPolicyPatch}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy and update replica\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - String containing replica patch string\n+# $4 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicyAndUpdateReplica {\n+  local domainJson=$1\n+  local serverName=$2\n+  local replicaPatch=$3\n+  local __result=$4\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaPatch}\",\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update policy \n+# $1 - String containing start policy info\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdatePolicy {\n+  local startPolicy=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update replica \n+# $1 - String containing replica\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdateReplica {\n+  local replicaInfo=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update replica and policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUpdateReplicaAndPolicy {\n+  local replicaInfo=$1\n+  local startPolicy=$2\n+  local __result=$3\n+\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\",\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __result=$3\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json to update cluster server start policy\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster whose policy will be patched\n+# $3 - policy value of \"IF_NEEDED\" or \"NEVER\"\n+# $4 - Return value containing patch json string\n+#\n+function createPatchJsonToUpdateClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local policy=$3\n+  local __result=$4\n+  \n+  replacePolicyCmd=\"(.spec.clusters[] | select (.clusterName == \\\"${clusterName}\\\") \\\n+    | .serverStartPolicy) |= \\\"${policy}\\\"\"\n+  startPolicy=$(echo ${domainJson} | jq \"${replacePolicyCmd}\" | jq -cr '(.spec.clusters)')\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json to update domain server start policy\n+# $1 - policy value of \"IF_NEEDED\" or \"NEVER\"\n+# $2 - Return value containing patch json string\n+#\n+function createPatchJsonToUpdateDomainPolicy {\n+  local policy=$1\n+  local __result=$2\n+  \n+  patchServerStartPolicy=\"{\\\"spec\\\": {\\\"serverStartPolicy\\\": \\\"${policy}\\\"}}\"\n+  eval $__result=\"'${patchServerStartPolicy}'\"\n+}\n+\n+#\n+# Function to get sorted list of servers in a cluster.\n+# The sorted list is created in 'sortedByAlwaysServers' array.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if policy of current server would be unset.\n+#      valid values are \"UNSET\" and \"CONSTANT\"\n+#\n+function getSortedListOfServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withPolicy=$4\n+  local policy=\"\"\n+  local sortedServers=()\n+  local otherServers=()\n+  errorMessage=\"Domain config map '${domainUid}-weblogic-domain-introspect-cm' not found. \\\n+This script requires that the introspector job for the specified domain ran \\\n+successfully and generated this config map. Exiting.\"\n+\n+  configMap=$(${kubernetesCli} get cm ${domainUid}-weblogic-domain-introspect-cm \\\n+    -n ${domainNamespace} -o json --ignore-not-found)\n+  if [ -z \"${configMap}\" ]; then\n+    echo \"${errorMessage}\" ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4bf493c36e213789df96ec5e5aaa053ded34d82"}, "originalPosition": 270}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b775210bb752a166d72866d91abcd5c52d738d44", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b775210bb752a166d72866d91abcd5c52d738d44", "committedDate": "2020-11-04T22:03:48Z", "message": "Changes for latest review comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1f109d0c415c668df7229e2282f67a437d75e60", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c1f109d0c415c668df7229e2282f67a437d75e60", "committedDate": "2020-11-04T22:50:01Z", "message": "Changes for latest round of review comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNzk4Njc2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-523798676", "createdAt": "2020-11-04T23:00:55Z", "commit": {"oid": "c1f109d0c415c668df7229e2282f67a437d75e60"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMzowMDo1NVrOHtsyow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMzowMDo1NVrOHtsyow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY4MTgyNw==", "bodyText": "minor nit: can use printError", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r517681827", "createdAt": "2020-11-04T23:00:55Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,678 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value for cluster level server start policy.\n+#      Legal return values are \"NEVER\" or \"IF_NEEDED\" or \"\".\n+#\n+function getClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __clusterPolicy=$3\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__clusterPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get server start policy at domain level\n+# $1 - Domain resource in json format\n+# $2 - Return value containing domain level server start policy.\n+#      Legal retrun values are \"NEVER\" or \"IF_NEEDED\" or \"ADMIN_ONLY\".\n+#\n+function getDomainPolicy {\n+  local domainJson=$1\n+  local __domainPolicy=$2\n+  local effectivePolicy=\"\"\n+\n+  eval $__domainPolicy=\"IF_NEEDED\"\n+  domainPolicyCommand=\".spec.serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${domainPolicyCommand}\")\n+  if [[ \"${effectivePolicy}\" == \"null\" || \"${effectivePolicy}\" == \"\" ]]; then\n+    effectivePolicy=\"IF_NEEDED\"\n+  fi\n+  eval $__domainPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get effective start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Name of cluster\n+# $4 - Return value containing effective server start policy\n+#      Legal retrun values are \"NEVER\" or \"IF_NEEDED\" or \"ALWAYS\".\n+#\n+function getEffectivePolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local __currentPolicy=$4\n+  local currentPolicy=\"\"\n+\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentPolicy\n+  if [ -z \"${currentPolicy}\" ]; then\n+    getClusterPolicy \"${domainJson}\" \"${clusterName}\" currentPolicy\n+    if [ -z \"${currentPolicy}\" ]; then\n+      # Start policy is not set at cluster level, check at domain level\n+      getDomainPolicy \"${domainJson}\" currentPolicy\n+    fi\n+  fi\n+  eval $__currentPolicy=${currentPolicy}\n+}\n+\n+#\n+# Function to get current start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Return value containing current server start policy\n+#      Legal retrun values are \"NEVER\" or \"IF_NEEDED\", \"ALWAYS\" or \"\".\n+#\n+function getServerPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __currentPolicy=$3\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  eval $__currentPolicy=\"\"\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentServerStartPolicy=$(echo ${domainJson} | jq \"${extractPolicyCmd}\")\n+    if [ \"${currentServerStartPolicy}\" == \"null\" ]; then\n+      currentServerStartPolicy=\"\"\n+    fi\n+  fi\n+  eval $__currentPolicy=${currentServerStartPolicy}\n+}\n+\n+#\n+# Function to create server start policy patch string\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Policy value \n+# $4 - Return value containing server start policy patch string\n+#\n+function createServerStartPolicyPatch {\n+  local domainJson=$1\n+  local serverName=$2\n+  local policy=$3\n+  local __result=$4\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentServerStartPolicy\n+  if [ -z \"${currentServerStartPolicy}\" ]; then\n+    # Server start policy doesn't exist, add a new policy\n+    addPolicyCmd=\".[.| length] |= . + {\\\"serverName\\\":\\\"${serverName}\\\", \\\n+      \\\"serverStartPolicy\\\":\\\"${policy}\\\"}\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq .spec.managedServers | jq -c \"${addPolicyCmd}\")\n+  else\n+    # Server start policy exists, replace policy value \n+    replacePolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy) |= \\\"${policy}\\\"\"\n+    servers=\"(.spec.managedServers)\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\" | jq -cr \"${servers}\")\n+  fi\n+  eval $__result=\"'${serverStartPolicyPatch}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy and update replica\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - String containing replica patch string\n+# $4 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicyAndUpdateReplica {\n+  local domainJson=$1\n+  local serverName=$2\n+  local replicaPatch=$3\n+  local __result=$4\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaPatch}\",\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update policy \n+# $1 - String containing start policy info\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdatePolicy {\n+  local startPolicy=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update replica \n+# $1 - String containing replica\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdateReplica {\n+  local replicaInfo=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update replica and policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUpdateReplicaAndPolicy {\n+  local replicaInfo=$1\n+  local startPolicy=$2\n+  local __result=$3\n+\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\",\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __result=$3\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json to update cluster server start policy\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster whose policy will be patched\n+# $3 - policy value of \"IF_NEEDED\" or \"NEVER\"\n+# $4 - Return value containing patch json string\n+#\n+function createPatchJsonToUpdateClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local policy=$3\n+  local __result=$4\n+  \n+  replacePolicyCmd=\"(.spec.clusters[] | select (.clusterName == \\\"${clusterName}\\\") \\\n+    | .serverStartPolicy) |= \\\"${policy}\\\"\"\n+  startPolicy=$(echo ${domainJson} | jq \"${replacePolicyCmd}\" | jq -cr '(.spec.clusters)')\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json to update domain server start policy\n+# $1 - policy value of \"IF_NEEDED\" or \"NEVER\"\n+# $2 - Return value containing patch json string\n+#\n+function createPatchJsonToUpdateDomainPolicy {\n+  local policy=$1\n+  local __result=$2\n+  \n+  patchServerStartPolicy=\"{\\\"spec\\\": {\\\"serverStartPolicy\\\": \\\"${policy}\\\"}}\"\n+  eval $__result=\"'${patchServerStartPolicy}'\"\n+}\n+\n+#\n+# Function to get sorted list of servers in a cluster.\n+# The sorted list is created in 'sortedByAlwaysServers' array.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if policy of current server would be unset.\n+#      valid values are \"UNSET\" and \"CONSTANT\"\n+#\n+function getSortedListOfServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withPolicy=$4\n+  local policy=\"\"\n+  local sortedServers=()\n+  local otherServers=()\n+\n+  getConfigMap \"${domainUid}\" \"${domainNamespace}\" configMap\n+  topology=$(echo \"${configMap}\" | jq '.data[\"topology.yaml\"]')\n+  jsonTopology=$(python -c \\\n+    'import sys, yaml, json; print json.dumps(yaml.safe_load('\"${topology}\"'), indent=4)')\n+  clusterTopology=$(echo ${jsonTopology} | jq -r '.domain | .configuredClusters[] | select (.name == '\\\"${clusterName}\\\"')')\n+  dynaCluster=$(echo ${clusterTopology} | jq .dynamicServersConfig)\n+  if [ \"${dynaCluster}\" == \"null\" ]; then\n+    # Cluster is a configured cluster, get server names\n+    servers=($(echo ${clusterTopology} | jq -r .servers[].name))\n+    # Sort server names in numero lexi order\n+    IFS=$'\\n' sortedServers=($(sort --version-sort <<<\"${servers[*]}\" ))\n+    unset IFS\n+    clusterSize=${#sortedServers[@]}\n+  else \n+    # Cluster is a dynamic cluster, calculate server names\n+    prefix=$(echo ${dynaCluster} | jq -r .serverNamePrefix)\n+    clusterSize=$(echo ${dynaCluster} | jq .dynamicClusterSize) \n+    for (( i=1; i<=$clusterSize; i++ )); do\n+      localServerName=${prefix}$i\n+      sortedServers+=(${localServerName})\n+    done\n+  fi\n+  # Create arrays of ALWAYS policy servers and other servers\n+  for localServerName in ${sortedServers[@]:-}; do\n+    getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+    # Update policy when server name matches current server and unsetting\n+    if [[ \"${withPolicy}\" == \"UNSET\" && \"${serverName}\" == \"${localServerName}\" ]]; then\n+      policy=UNSET\n+    fi\n+    if [ \"${policy}\" == \"ALWAYS\" ]; then\n+      sortedByAlwaysServers+=(${localServerName})\n+    else\n+      otherServers+=(${localServerName})\n+    fi\n+  done\n+  \n+  # append other servers to the list of servers with always policy\n+  for otherServer in ${otherServers[@]:-}; do\n+    sortedByAlwaysServers+=($otherServer)\n+  done\n+}\n+\n+#\n+# Get replica count for a cluster\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster \n+# $3 - Return value containing replica count\n+#\n+function getReplicaCount {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __replicaCount=$3\n+\n+  replicasCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).replicas\"\n+  replicaCount=$(echo ${domainJson} | jq \"${replicasCmd}\")\n+  if [[ -z \"${replicaCount}\" || \"${replicaCount}\" == \"null\" ]]; then\n+    replicaCount=$(echo ${domainJson} | jq .spec.replicas)\n+  fi\n+  if [[ -z \"${replicaCount}\" || \"${replicaCount}\" == \"null\" ]]; then\n+    replicaCount=0\n+  fi\n+  eval $__replicaCount=\"'${replicaCount}'\"\n+\n+}\n+\n+#\n+# Check servers started in a cluster based on server start policy and \n+# replica count.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if replicas will stay constant, incremented or decremented.\n+#      Valid values are \"CONSTANT\", \"INCREMENT\" and \"DECREMENT\"\n+# $5 - Indicates if policy of current server will stay constant or unset.\n+#      Valid values are \"CONSTANT\" and \"UNSET\"\n+# $6 - Return value of \"true\" or \"false\" indicating if current server will be started\n+#\n+function checkStartedServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withReplicas=$4\n+  local withPolicy=$5\n+  local __started=$6\n+  local localServerName=\"\"\n+  local policy=\"\"\n+  local replicaCount=0\n+  local currentReplicas=0\n+  local startedServers=()\n+  local sortedByAlwaysServers=()\n+  \n+  # Get sorted list of servers in 'sortedByAlwaysServers' array\n+  getSortedListOfServers \"${domainJson}\" \"${serverName}\" \"${clusterName}\" \"${withPolicy}\"\n+  getReplicaCount \"${domainJson}\" \"${clusterName}\" replicaCount\n+  # Increment or decrement the replica count based on 'withReplicas' input parameter\n+  if [ \"${withReplicas}\" == \"INCREASED\" ]; then\n+    replicaCount=$((replicaCount+1))\n+  elif [ \"${withReplicas}\" == \"DECREASED\" ]; then\n+    replicaCount=$((replicaCount-1))\n+  fi\n+  for localServerName in ${sortedByAlwaysServers[@]:-}; do\n+    getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+    # Update policy when server name matches current server and unsetting\n+    if [[ \"${serverName}\" == \"${localServerName}\" && \"${withPolicy}\" == \"UNSET\" ]]; then\n+      policy=UNSET\n+    fi\n+    # check if server should start based on replica count, policy and current replicas\n+    shouldStart \"${currentReplicas}\" \"${policy}\" \"${replicaCount}\" result\n+    if [ \"${result}\" == 'true' ]; then\n+      # server should start, increment current replicas and add server to list of started servers\n+      currentReplicas=$((currentReplicas+1))\n+      startedServers+=(${localServerName})\n+    fi\n+  done\n+  startedSize=${#startedServers[@]}\n+  if [ ${startedSize} -gt 0 ]; then\n+    # check if current server is in the list of started servers\n+    if checkStringInArray ${serverName} ${startedServers[@]}; then\n+      eval $__started=\"true\"\n+      return\n+    fi\n+  fi\n+  eval $__started=\"false\"\n+}\n+\n+#\n+# Function to check if server should start based on policy and current replicas\n+# $1 - Current number of replicas\n+# $2 - Server start policy\n+# $3 - Replica count\n+# $4 - Returns \"true\" or \"false\" indicating if server should start.\n+#\n+function shouldStart {\n+  local currentReplicas=$1\n+  local policy=$2\n+  local replicaCount=$3 \n+  local __result=$4\n+\n+  if [ \"$policy\" == \"ALWAYS\" ]; then\n+    eval $__result=true\n+  elif [ \"$policy\" == \"NEVER\" ]; then\n+    eval $__result=false\n+  elif [ \"${currentReplicas}\" -lt \"${replicaCount}\" ]; then\n+    eval $__result=true\n+  else \n+    eval $__result=false\n+  fi\n+}\n+\n+#\n+# Function to create patch string for updating replica count\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster whose replica count will be patched\n+# $3 - operation string indicating whether to increment or decrement replica count. \n+#      Valid values are \"INCREMENT\" and \"DECREMENT\"\n+# $4 - Return value containing replica update patch string\n+# $5 - Return value containing updated replica count\n+#\n+function createReplicaPatch {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local operation=$3\n+  local __result=$4\n+  local __replicaCount=$5\n+  local maxReplicas=\"\"\n+  local infoMessage=\"Current replica count value is same as or greater than maximum number of replica count. \\\n+Not increasing replica count value.\"\n+\n+  maxReplicaCmd=\"(.status.clusters[] | select (.clusterName == \\\"${clusterName}\\\")) \\\n+    | .maximumReplicas\"\n+  getReplicaCount  \"${domainJson}\" \"${clusterName}\" replica\n+  if [ \"${operation}\" == \"DECREMENT\" ]; then\n+    replica=$((replica-1))\n+    if [ ${replica} -lt 0 ]; then\n+      replica=0\n+    fi\n+  elif [ \"${operation}\" == \"INCREMENT\" ]; then\n+    maxReplicas=$(echo ${domainJson} | jq \"${maxReplicaCmd}\")\n+    if [ ${replica} -ge ${maxReplicas} ]; then\n+      printInfo \"${infoMessage}\"\n+    else\n+      replica=$((replica+1))\n+    fi\n+  fi\n+\n+  cmd=\"(.spec.clusters[] | select (.clusterName == \\\"${clusterName}\\\") \\\n+    | .replicas) |= ${replica}\"\n+  replicaPatch=$(echo ${domainJson} | jq \"${cmd}\" | jq -cr '(.spec.clusters)')\n+  eval $__result=\"'${replicaPatch}'\"\n+  eval $__replicaCount=\"'${replica}'\"\n+}\n+\n+#\n+# Function to validate whether a server belongs to a  cluster or is an independent managed server\n+# $1 - Domain unique id.\n+# $2 - Domain namespace.\n+# $3 - Server name.\n+# $4 - Return value of \"true\" or \"false\" indicating if server is valid (i.e. if it's part of a cluster or independent server).\n+# $5 - Retrun value containting cluster name to which this server belongs.\n+#\n+function validateServerAndFindCluster {\n+  local domainUid=$1\n+  local domainNamespace=$2 \n+  local serverName=$3\n+  local __isValidServer=$4\n+  local __clusterName=$5\n+  local serverCount=\"\"\n+\n+  eval $__isValidServer=false\n+  eval $__clusterName=UNKNOWN\n+  getConfigMap \"${domainUid}\" \"${domainNamespace}\" configMap\n+  topology=$(echo \"${configMap}\" | jq '.data[\"topology.yaml\"]')\n+  jsonTopology=$(python -c \\\n+    'import sys, yaml, json; print json.dumps(yaml.safe_load('\"${topology}\"'), indent=4)')\n+  adminServer=$(echo $jsonTopology | jq -r .domain.adminServerName)\n+  if [ \"${serverName}\" == \"${adminServer}\" ]; then\n+    printError \"Server '${serverName}' is administration server. The '${script}' script doesn't support starting or stopping administration server.\"\n+    exit 1\n+  fi\n+  servers=($(echo $jsonTopology | jq -r '.domain.servers[].name'))\n+  if  checkStringInArray \"${serverName}\" \"${servers[@]}\" ; then\n+    eval $__clusterName=\"\"\n+    eval $__isValidServer=true\n+  else\n+    dynamicClause=\".domain.configuredClusters[] | select (.dynamicServersConfig != null)\"\n+    namePrefixSize=\". | {name: .name, prefix:.dynamicServersConfig.serverNamePrefix, \\\n+                 max:.dynamicServersConfig.maxDynamicClusterSize}\"\n+    dynamicClusters=($(echo $jsonTopology | jq \"${dynamicClause}\" | jq -cr \"${namePrefixSize}\"))\n+    dynamicClustersSize=${#dynamicClusters[@]}\n+    for dynaClusterNamePrefix in ${dynamicClusters[@]:-}; do\n+      prefix=$(echo ${dynaClusterNamePrefix} | jq -r .prefix)\n+      if [[ \"${serverName}\" == \"${prefix}\"* ]]; then\n+        maxSize=$(echo ${dynaClusterNamePrefix} | jq -r .max)\n+        number='^[0-9]+$'\n+        if [ $(echo \"${serverName}\" | grep -c -Eo '[0-9]+$') -gt 0 ]; then\n+          serverCount=$(echo \"${serverName}\" | grep -Eo '[0-9]+$')\n+        fi\n+        if ! [[ $serverCount =~ $number ]] ; then\n+           echo \"error: Server name is not valid for dynamic cluster.\" ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1f109d0c415c668df7229e2282f67a437d75e60"}, "originalPosition": 499}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzODAwMjc0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-523800274", "createdAt": "2020-11-04T23:04:29Z", "commit": {"oid": "c1f109d0c415c668df7229e2282f67a437d75e60"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c5ae36c97a39ad655f6e2d14e9488c3304bf949", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/2c5ae36c97a39ad655f6e2d14e9488c3304bf949", "committedDate": "2020-11-04T23:23:13Z", "message": "use printError instead of echo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0MzM1NzEy", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-524335712", "createdAt": "2020-11-05T14:48:19Z", "commit": {"oid": "2c5ae36c97a39ad655f6e2d14e9488c3304bf949"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0MzU1NTgw", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-524355580", "createdAt": "2020-11-05T15:07:01Z", "commit": {"oid": "2c5ae36c97a39ad655f6e2d14e9488c3304bf949"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNTowNzowMVrOHuHpTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNToxMDo0M1rOHuH0UA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODEyMTgwNQ==", "bodyText": "start the server along with increased replica count -> start the server along with an increased replica count OR start the server with an increased replica count", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r518121805", "createdAt": "2020-11-05T15:07:01Z", "author": {"login": "rosemarymarano"}, "path": "kubernetes/samples/scripts/domain-lifecycle/README.md", "diffHunk": "@@ -0,0 +1,76 @@\n+### Domain lifecycle sample scripts\n+\n+The operator provides sample scripts to start up or shut down a specific Managed Server or cluster in a deployed domain, or the entire deployed domain.\n+\n+**Note**: Prior to running these scripts, you must have previously created and deployed the domain.\n+\n+These scripts can be helpful when scripting the life cycle of a WebLogic Server domain. For information on how to start, stop, restart, and scale WebLogic Server instances in your domain, see [Domain Life Cycle](https://oracle.github.io/weblogic-kubernetes-operator/userguide/managing-domains/domain-lifecycle).\n+\n+#### Scripts to start and stop a Managed Server\n+The `startServer.sh` script starts a Managed Server either by increasing the `spec.clusters[<cluster-name>].replicas` value for the Managed Server's cluster by `1` or by updating the `spec.managedServers[<server-name>].serverStartPolicy` attribute of the domain resource or both as necessary. The script provides an option to keep the `spec.clusters[<cluster-name>].replicas` value constant for clustered servers. See the script `usage` information by using the `-h` option.\n+\n+Use the following command to start the server along with increased replica count:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c5ae36c97a39ad655f6e2d14e9488c3304bf949"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODEyMjA5NQ==", "bodyText": "without increasing replica count -> without increasing the replica count", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r518122095", "createdAt": "2020-11-05T15:07:23Z", "author": {"login": "rosemarymarano"}, "path": "kubernetes/samples/scripts/domain-lifecycle/README.md", "diffHunk": "@@ -0,0 +1,76 @@\n+### Domain lifecycle sample scripts\n+\n+The operator provides sample scripts to start up or shut down a specific Managed Server or cluster in a deployed domain, or the entire deployed domain.\n+\n+**Note**: Prior to running these scripts, you must have previously created and deployed the domain.\n+\n+These scripts can be helpful when scripting the life cycle of a WebLogic Server domain. For information on how to start, stop, restart, and scale WebLogic Server instances in your domain, see [Domain Life Cycle](https://oracle.github.io/weblogic-kubernetes-operator/userguide/managing-domains/domain-lifecycle).\n+\n+#### Scripts to start and stop a Managed Server\n+The `startServer.sh` script starts a Managed Server either by increasing the `spec.clusters[<cluster-name>].replicas` value for the Managed Server's cluster by `1` or by updating the `spec.managedServers[<server-name>].serverStartPolicy` attribute of the domain resource or both as necessary. The script provides an option to keep the `spec.clusters[<cluster-name>].replicas` value constant for clustered servers. See the script `usage` information by using the `-h` option.\n+\n+Use the following command to start the server along with increased replica count:\n+```\n+$ startServer.sh -d domain1 -n weblogic-domain-1 -s managed-server1\n+[INFO] Updating replica count for cluster 'cluster-1' to 1.\n+domain.weblogic.oracle/domain1 patched\n+[INFO] Successfully updated replica count for cluster 'cluster-1' to 1.\n+```\n+\n+Use the following command to start the server without increasing replica count:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c5ae36c97a39ad655f6e2d14e9488c3304bf949"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODEyNDIwOQ==", "bodyText": "stop the server along with decreased replica count -> this does not make sense to me; do you mean stop the server along with decreasing the replica count OR stop the server with a decreased replica count? Please clarify.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r518124209", "createdAt": "2020-11-05T15:10:14Z", "author": {"login": "rosemarymarano"}, "path": "kubernetes/samples/scripts/domain-lifecycle/README.md", "diffHunk": "@@ -0,0 +1,76 @@\n+### Domain lifecycle sample scripts\n+\n+The operator provides sample scripts to start up or shut down a specific Managed Server or cluster in a deployed domain, or the entire deployed domain.\n+\n+**Note**: Prior to running these scripts, you must have previously created and deployed the domain.\n+\n+These scripts can be helpful when scripting the life cycle of a WebLogic Server domain. For information on how to start, stop, restart, and scale WebLogic Server instances in your domain, see [Domain Life Cycle](https://oracle.github.io/weblogic-kubernetes-operator/userguide/managing-domains/domain-lifecycle).\n+\n+#### Scripts to start and stop a Managed Server\n+The `startServer.sh` script starts a Managed Server either by increasing the `spec.clusters[<cluster-name>].replicas` value for the Managed Server's cluster by `1` or by updating the `spec.managedServers[<server-name>].serverStartPolicy` attribute of the domain resource or both as necessary. The script provides an option to keep the `spec.clusters[<cluster-name>].replicas` value constant for clustered servers. See the script `usage` information by using the `-h` option.\n+\n+Use the following command to start the server along with increased replica count:\n+```\n+$ startServer.sh -d domain1 -n weblogic-domain-1 -s managed-server1\n+[INFO] Updating replica count for cluster 'cluster-1' to 1.\n+domain.weblogic.oracle/domain1 patched\n+[INFO] Successfully updated replica count for cluster 'cluster-1' to 1.\n+```\n+\n+Use the following command to start the server without increasing replica count:\n+```\n+$ startServer.sh -d domain1 -n weblogic-domain-1 -s managed-server2 -k\n+[INFO] Patching start policy for 'managed-server2' to 'ALWAYS'.\n+domain.weblogic.oracle/domain1 patched\n+[INFO] Successfully patched server 'managed-server2' with 'ALWAYS' start policy.\n+```\n+\n+The `stopServer.sh` script shuts down a running Managed Server either by decreasing the `spec.clusters[<cluster-name>].replicas` value for the Managed Server's cluster by `1` or by patching the `spec.managedServers[<server-name>].serverStartPolicy` attribute of the domain resource or both as necessary. The script provides an option to keep the `spec.clusters[<cluster-name>].replicas` value constant for clustered servers. See the script `usage` information by using the `-h` option.\n+\n+Use the following command to stop the server along with decreased replica count:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c5ae36c97a39ad655f6e2d14e9488c3304bf949"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODEyNDYyNA==", "bodyText": "stop the server without decreasing replica count -> stop the server without decreasing the replica count", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r518124624", "createdAt": "2020-11-05T15:10:43Z", "author": {"login": "rosemarymarano"}, "path": "kubernetes/samples/scripts/domain-lifecycle/README.md", "diffHunk": "@@ -0,0 +1,76 @@\n+### Domain lifecycle sample scripts\n+\n+The operator provides sample scripts to start up or shut down a specific Managed Server or cluster in a deployed domain, or the entire deployed domain.\n+\n+**Note**: Prior to running these scripts, you must have previously created and deployed the domain.\n+\n+These scripts can be helpful when scripting the life cycle of a WebLogic Server domain. For information on how to start, stop, restart, and scale WebLogic Server instances in your domain, see [Domain Life Cycle](https://oracle.github.io/weblogic-kubernetes-operator/userguide/managing-domains/domain-lifecycle).\n+\n+#### Scripts to start and stop a Managed Server\n+The `startServer.sh` script starts a Managed Server either by increasing the `spec.clusters[<cluster-name>].replicas` value for the Managed Server's cluster by `1` or by updating the `spec.managedServers[<server-name>].serverStartPolicy` attribute of the domain resource or both as necessary. The script provides an option to keep the `spec.clusters[<cluster-name>].replicas` value constant for clustered servers. See the script `usage` information by using the `-h` option.\n+\n+Use the following command to start the server along with increased replica count:\n+```\n+$ startServer.sh -d domain1 -n weblogic-domain-1 -s managed-server1\n+[INFO] Updating replica count for cluster 'cluster-1' to 1.\n+domain.weblogic.oracle/domain1 patched\n+[INFO] Successfully updated replica count for cluster 'cluster-1' to 1.\n+```\n+\n+Use the following command to start the server without increasing replica count:\n+```\n+$ startServer.sh -d domain1 -n weblogic-domain-1 -s managed-server2 -k\n+[INFO] Patching start policy for 'managed-server2' to 'ALWAYS'.\n+domain.weblogic.oracle/domain1 patched\n+[INFO] Successfully patched server 'managed-server2' with 'ALWAYS' start policy.\n+```\n+\n+The `stopServer.sh` script shuts down a running Managed Server either by decreasing the `spec.clusters[<cluster-name>].replicas` value for the Managed Server's cluster by `1` or by patching the `spec.managedServers[<server-name>].serverStartPolicy` attribute of the domain resource or both as necessary. The script provides an option to keep the `spec.clusters[<cluster-name>].replicas` value constant for clustered servers. See the script `usage` information by using the `-h` option.\n+\n+Use the following command to stop the server along with decreased replica count:\n+```\n+$ stopServer.sh -d domain1 -n weblogic-domain-1 -s managed-server1\n+[INFO] Updating replica count for cluster cluster-1 to 0.\n+domain.weblogic.oracle/domain1 patched\n+[INFO] Successfully updated replica count for cluster 'cluster-1' to 0.\n+```\n+\n+Use the following command to stop the server without decreasing replica count:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c5ae36c97a39ad655f6e2d14e9488c3304bf949"}, "originalPosition": 38}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "899073a9d2619e1a2df64be00897885625d90f20", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/899073a9d2619e1a2df64be00897885625d90f20", "committedDate": "2020-11-05T16:03:59Z", "message": "Changes to remove integration tests and doc review comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0NDIyODU0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-524422854", "createdAt": "2020-11-05T16:10:30Z", "commit": {"oid": "899073a9d2619e1a2df64be00897885625d90f20"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d6de237ab8886843ad94de6f5e81d9faca70470", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/4d6de237ab8886843ad94de6f5e81d9faca70470", "committedDate": "2020-10-20T21:44:29Z", "message": "owls-83995 - Scripts to start/stop a managed server/cluster/domain"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e20b630f9144b047442eda245291a0005caab9cd", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e20b630f9144b047442eda245291a0005caab9cd", "committedDate": "2020-10-20T21:55:52Z", "message": "fix method comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a2b1e3c49f3f8e6e872f5be124ada9faf196b09", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/7a2b1e3c49f3f8e6e872f5be124ada9faf196b09", "committedDate": "2020-10-20T22:11:19Z", "message": "Minor changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMjE5NTU4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-513219558", "createdAt": "2020-10-21T00:06:34Z", "commit": {"oid": "7a2b1e3c49f3f8e6e872f5be124ada9faf196b09"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMDowNjozNFrOHlVkpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMDowNjozNFrOHlVkpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkxMjgwNQ==", "bodyText": "'set -e' is called above, so I assume the $? question check isn't needed?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r508912805", "createdAt": "2020-10-21T00:06:34Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/stopServer.sh", "diffHunk": "@@ -0,0 +1,124 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/../common/utility.sh\n+source ${scriptDir}/../common/validate.sh\n+source ${scriptDir}/helper.sh\n+if [ \"${debug}\" == \"true\" ]; then set -x; fi;\n+set -e\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This is a helper script for stopping a managed server in a domain by patching\n+  it's 'spec.serverStartPolicy' field to 'NEVER'. This change will cause\n+  the operator to initiate shutdown of WebLogic server pod if the pod \n+  is already running.\n+ \n+  Usage:\n+ \n+    $(basename $0) -s myserver [-n mynamespace] [-d mydomainuid]\n+  \n+    -s <server_name>           : Server name parameter is required.\n+\n+    -d <domain_uid>            : Default is 'sample-domain1'.\n+\n+    -n <namespace>             : Default is 'sample-domain1-ns'.\n+    \n+    -k <keep_replica_constant> : Keep replica count constant. Default behavior is to decrement replica count.\n+\n+    -m <kubernetes_cli>        : Kubernetes command line interface. Default is 'kubectl'.\n+\n+    -h                         : This help.\n+   \n+EOF\n+exit $1\n+}\n+\n+kubernetesCli=${KUBERNETES_CLI:-kubectl}\n+serverName=\"\"\n+clusterName=\"\"\n+domainUid=\"sample-domain1\"\n+domainNamespace=\"sample-domain1-ns\"\n+keepReplicaConstant=false\n+\n+while getopts \"ks:m:n:d:h:\" opt; do\n+  case $opt in\n+    s) serverName=\"${OPTARG}\"\n+    ;;\n+    n) domainNamespace=\"${OPTARG}\"\n+    ;;\n+    m) kubernetesCli=\"${OPTARG}\"\n+    ;;\n+    d) domainUid=\"${OPTARG}\"\n+    ;;\n+    k) keepReplicaConstant=true;\n+    ;;\n+    h) usage 0\n+    ;;\n+    *) usage 1\n+    ;;\n+  esac\n+done\n+\n+#\n+# Function to perform validations, read files and initialize workspace\n+#\n+function initialize {\n+\n+  # Validate the required files exist\n+  validateErrors=false\n+\n+  validateKubernetesCliAvailable\n+  validateJqAvailable\n+\n+  if [ -z \"${serverName}\" ]; then\n+    validationError \"Please specify name of server to start using '-s' parameter e.g. '-s managed-server1'.\"\n+  fi\n+\n+  failIfValidationErrors\n+}\n+\n+initialize\n+\n+# Get the cluster name for current server \n+clusterName=$(${kubernetesCli} get pod ${domainUid}-${serverName} -n ${domainNamespace} -o=jsonpath=\"{.metadata.labels['weblogic\\.clusterName']}\")\n+\n+# Get the domain in json format\n+domainJson=$(${kubernetesCli} get domain ${domainUid} -n ${domainNamespace} -o json)\n+\n+# Create server start policy patch with IF_NEEDED value\n+serverStartPolicy=NEVER\n+createServerStartPolicyPatch \"${domainJson}\" \"${serverName}\" \"${serverStartPolicy}\" serverStartPolicyPatch policy\n+\n+if [[ -n \"${clusterName}\" && \"${keepReplicaConstant}\" != 'true' ]]; then\n+  # if server is part of a cluster and replica count needs to be updated, update replica count and patch server start policy\n+  operation=\"DECREMENT\"\n+  createReplicaPatch \"${domainJson}\" \"${clusterName}\" \"${operation}\" replicaPatch replicaCount\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaPatch}\",\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  echo \"[INFO] Patching start policy of server '${serverName}' from '${policy}' to 'NEVER' and decrementing replica count for cluster '${clusterName}'.\"\n+else\n+  # if server is an independent managed server or replica count needs to stay constant, only patch server start policy\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  echo \"[INFO] Patching start policy of '${serverName}' from '${policy}' to 'NEVER'.\"\n+fi\n+${kubernetesCli} patch domain ${domainUid} -n ${domainNamespace} --type='merge' --patch \"${patchJson}\"\n+\n+if [ $? != 0 ]; then", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a2b1e3c49f3f8e6e872f5be124ada9faf196b09"}, "originalPosition": 112}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMjI0Njkz", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-513224693", "createdAt": "2020-10-21T00:23:11Z", "commit": {"oid": "7a2b1e3c49f3f8e6e872f5be124ada9faf196b09"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMDoyMzoxMVrOHlV20g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMDoyMzoxMVrOHlV20g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkxNzQ1OA==", "bodyText": "(1) There is overlap between the scripts markup doc and each script's built-in usage. I suspect it'd be better for usage/doc maintenance and for self documentation purposes if the information was merged into one place - the usage - and the doc minimized so as only to have high level descriptions of each script.\n(2) Since the scripts are technically samples, I suspect the majority of their doc probably should be under content/samples (then domain-lifecycle and the sample doc can cross-reference).", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r508917458", "createdAt": "2020-10-21T00:23:11Z", "author": {"login": "tbarnes-us"}, "path": "docs-source/content/userguide/managing-domains/domain-lifecycle/startup.md", "diffHunk": "@@ -82,6 +87,46 @@ updates before advancing the server to the running state.\n \n Changes to the `serverStartState` property do not affect already started servers.\n \n+### Scripts for starting and stopping a managed server\n+The [`startServer.sh`](https://github.com/oracle/weblogic-kubernetes-operator/blob/master/kubernetes/samples/scripts/domain-lifecycle/startServer.sh) and [`stopServer.sh`](https://github.com/oracle/weblogic-kubernetes-operator/blob/master/kubernetes/samples/scripts/domain-lifecycle/stopServer.sh) scripts located in the `kubernetes/samples/scripts/domain-lifecycle` directory can be used to start-up or shut down a specific managed server in a WebLogic Server Domain. These scripts accept below four input parameters.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a2b1e3c49f3f8e6e872f5be124ada9faf196b09"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMjI2ODcy", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-513226872", "createdAt": "2020-10-21T00:30:07Z", "commit": {"oid": "7a2b1e3c49f3f8e6e872f5be124ada9faf196b09"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMDozMDowN1rOHlV-lA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMDozMDowN1rOHlV-lA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkxOTQ0NA==", "bodyText": "It looks like vars above and below can all be declared local (ditto for other functions).", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r508919444", "createdAt": "2020-10-21T00:30:07Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,151 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to create server start policy patch string\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Policy value \n+# $4 - Return value containing server start policy patch string\n+#\n+function createServerStartPolicyPatch {\n+  domainJson=$1\n+  serverName=$2\n+  policy=$3\n+  __result=$4\n+  __currentPolicy=$5\n+\n+  # Get server start policy for this server\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentServerStartPolicy=$(echo ${domainJson} | jq \"${extractPolicyCmd}\")\n+  fi\n+  if [ -z \"${currentServerStartPolicy}\" ]; then\n+    # Server start policy doesn't exist, add a new policy\n+    addPolicyCmd=\".[.| length] |= . + {\\\"serverName\\\":\\\"${serverName}\\\", \\\n+      \\\"serverStartPolicy\\\":\\\"${policy}\\\"}\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq .spec.managedServers | jq -c \"${addPolicyCmd}\")\n+  else\n+    # Server start policy exists, replace policy value \n+    replacePolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy) |= \\\"${policy}\\\"\"\n+    servers=\"(.spec.managedServers)\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\" | jq -cr \"${servers}\")\n+  fi\n+  eval $__result=\"'${serverStartPolicyPatch}'\"\n+  eval $__currentPolicy=${currentServerStartPolicy}\n+}\n+\n+#\n+# Function to create patch string for updating replica count\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster whose replica count will be patched\n+# $3 - operatation string indicating whether to increment or decrement count\n+# $4 - Return value containing replica update patch string\n+# $5 - Retrun value containing updated replica count\n+#\n+function createReplicaPatch {\n+domainJson=$1\n+clusterName=$2\n+operation=$3\n+__result=$4\n+__relicaCount=$5\n+local errorMessage=\"@@ ERROR: Maximum number of servers allowed (maxReplica = ${maxReplicas}) \\\n+are already running. Please increase cluster size to start new servers.\"\n+\n+  replicasCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).replicas\"\n+  maxReplicaCmd=\"(.status.clusters[] | select (.clusterName == \\\"${clusterName}\\\")) \\\n+    | .maximumReplicas\"\n+  if [ \"${operation}\" == \"DECREMENT\" ]; then\n+    replica=$(($(echo ${domainJson} | jq \"${replicasCmd}\")-1))\n+  elif [ \"${operation}\" == \"INCREMENT\" ]; then\n+    replica=$(($(echo ${domainJson} | jq \"${replicasCmd}\")+1))\n+    maxReplicas=$(echo ${domainJson} | jq \"${maxReplicaCmd}\")\n+    if [ ${replica} -gt ${maxReplicas} ]; then\n+      echo \"${errorMessage}\"\n+      eval $__result=\"MAX_REPLICA_COUNT_EXCEEDED\"\n+      return\n+    fi\n+  fi\n+\n+  cmd=\"(.spec.clusters[] | select (.clusterName == \\\"${clusterName}\\\") \\\n+    | .replicas) |= ${replica}\"\n+  replicaPatch=$(echo ${domainJson} | jq \"${cmd}\" | jq -cr '(.spec.clusters)')\n+  eval $__result=\"'${replicaPatch}'\"\n+  eval $__relicaCount=\"'${replica}'\"\n+}\n+\n+#\n+# Function to validate whether a server belongs to a  cluster or is an independent managed server\n+# $1 - Domain unique id.\n+# $2 - Domain namespace.\n+# $3 - Return value indicating if server is valid (i.e. if it's part of a cluster or independent server).\n+# $4 - Retrun value containting cluster name to which this server belongs.\n+#\n+function validateServerAndFindCluster {\n+domainUid=$1\n+domainNamespace=$2 \n+__isValidServer=$3\n+__clusterName=$4", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a2b1e3c49f3f8e6e872f5be124ada9faf196b09"}, "originalPosition": 94}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMjI3NDM2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-513227436", "createdAt": "2020-10-21T00:31:55Z", "commit": {"oid": "7a2b1e3c49f3f8e6e872f5be124ada9faf196b09"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMDozMTo1NVrOHlWAlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMDozMTo1NVrOHlWAlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkxOTk1OQ==", "bodyText": "Since all vars seem to be set to some value or are accessed in default expressions, maybe use \"set -eu\"  instead of \"set -e\" in order to assert that you don't use an undefined var?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r508919959", "createdAt": "2020-10-21T00:31:55Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startCluster.sh", "diffHunk": "@@ -0,0 +1,105 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/../common/utility.sh\n+source ${scriptDir}/../common/validate.sh\n+source ${scriptDir}/helper.sh\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This is a helper script for starting a cluster by patching\n+  it's 'spec.serverStartPolicy' field to 'IF_NEEDED'. This change will cause\n+  the operator to initiate startup of cluster's WebLogic server pods if the \n+  pods are not already running.\n+ \n+  Usage:\n+ \n+    $(basename $0) -c mycluster [-n mynamespace] [-d mydomainuid]\n+  \n+    -c <cluster>        : Cluster name parameter is required.\n+\n+    -d <domain_uid>     : Default is 'sample-domain1'.\n+\n+    -n <namespace>      : Default is 'sample-domain1-ns'.\n+\n+    -m <kubernetes_cli> : Kubernetes command line interface. Default is 'kubectl'.\n+\n+    -h                  : This help.\n+   \n+EOF\n+exit $1\n+}\n+\n+set -e", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a2b1e3c49f3f8e6e872f5be124ada9faf196b09"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMjMxODcx", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-513231871", "createdAt": "2020-10-21T00:46:41Z", "commit": {"oid": "7a2b1e3c49f3f8e6e872f5be124ada9faf196b09"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMDo0Njo0MVrOHlWQ1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMDo0Njo0MVrOHlWQ1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkyNDExNw==", "bodyText": "As far as I can tell, the new sample scripts make minimal use of utility.sh and validate.sh -- if this is true, then the sample scripts would be easier to understand and nicely self contained if the dependency on these scripts was removed. (Move/copy the little that's needed into helper.sh).", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r508924117", "createdAt": "2020-10-21T00:46:41Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/stopServer.sh", "diffHunk": "@@ -0,0 +1,124 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/../common/utility.sh\n+source ${scriptDir}/../common/validate.sh\n+source ${scriptDir}/helper.sh", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a2b1e3c49f3f8e6e872f5be124ada9faf196b09"}, "originalPosition": 10}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf096af2d9aff28849c2a4e7684c83400bacb64a", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/cf096af2d9aff28849c2a4e7684c83400bacb64a", "committedDate": "2020-10-21T13:16:12Z", "message": "Address review comments and fix script comments/usages."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "302a597d3ee2cf9744c27f818496402459648ecf", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/302a597d3ee2cf9744c27f818496402459648ecf", "committedDate": "2020-10-22T00:38:54Z", "message": "Added integration tests, made few doc changes based on review comments and minor fix."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1346894ee0d4df0858c572abc5bec3e6f8c3b1f", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a1346894ee0d4df0858c572abc5bec3e6f8c3b1f", "committedDate": "2020-10-22T14:01:53Z", "message": "Clarify script usage, updated README file and minor changes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97b7fcd21856634cef2e0a5dd3207850509f50dc", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/97b7fcd21856634cef2e0a5dd3207850509f50dc", "committedDate": "2020-10-22T15:59:36Z", "message": "Changes to add script usage details"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0OTM3MTUx", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-514937151", "createdAt": "2020-10-22T16:58:52Z", "commit": {"oid": "97b7fcd21856634cef2e0a5dd3207850509f50dc"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNjo1ODo1M1rOHmrVtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNzowMzowMVrOHmrfmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDMxODAwNg==", "bodyText": "Please change this directory to be different from one used in ItSamples. Otherwise when both these tests are running in parallel one might delete this directory and tests will fail.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r510318006", "createdAt": "2020-10-22T16:58:53Z", "author": {"login": "sankarpn"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItLifecycleSampleScripts.java", "diffHunk": "@@ -0,0 +1,448 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.BASE_IMAGES_REPO_SECRET;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.WEBLOGIC_IMAGE_TO_USE_IN_SPEC;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.pvExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.pvcExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkClusterReplicaCountMatches;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretForBaseImages;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.replaceStringInFile;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.apache.commons.io.FileUtils.copyDirectory;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests related to domain lifecycle sample scripts.\n+ */\n+@DisplayName(\"Verify the domain lifecycle sample scripts\")\n+@IntegrationTest\n+public class ItLifecycleSampleScripts {\n+\n+  public static final String SERVER_LIFECYCLE = \"Server\";\n+  public static final String CLUSTER_LIFECYCLE = \"Cluster\";\n+  public static final String DOMAIN = \"DOMAIN\";\n+  public static final String STOP_SERVER_SCRIPT = \"stopServer.sh\";\n+  public static final String START_SERVER_SCRIPT = \"startServer.sh\";\n+  public static final String STOP_CLUSTER_SCRIPT = \"stopCluster.sh\";\n+  public static final String START_CLUSTER_SCRIPT = \"startCluster.sh\";\n+  public static final String STOP_DOMAIN_SCRIPT = \"stopDomain.sh\";\n+  public static final String START_DOMAIN_SCRIPT = \"startDomain.sh\";\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String domainName = \"domain1\";\n+  private final int replicaCount = 2;\n+  private final String clusterName = \"cluster-1\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String managedServerNameBase = \"managed-server\";\n+\n+  private final String adminServerPodName = domainName + \"-\" + adminServerName;\n+  private final String managedServerPodNamePrefix = domainName + \"-\" + managedServerNameBase;\n+  private final Path samplePath = Paths.get(ITTESTS_DIR, \"../kubernetes/samples\");\n+  private final Path domainLifecycleSamplePath = Paths.get(samplePath + \"/scripts/domain-lifecycle\");\n+  private final Path tempSamplePath = Paths.get(WORK_DIR, \"sample-testing\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97b7fcd21856634cef2e0a5dd3207850509f50dc"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDMxOTc4OA==", "bodyText": "There is only 1 domain created in this test", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r510319788", "createdAt": "2020-10-22T17:01:39Z", "author": {"login": "sankarpn"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItLifecycleSampleScripts.java", "diffHunk": "@@ -0,0 +1,448 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.BASE_IMAGES_REPO_SECRET;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.WEBLOGIC_IMAGE_TO_USE_IN_SPEC;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.pvExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.pvcExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkClusterReplicaCountMatches;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretForBaseImages;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.replaceStringInFile;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.apache.commons.io.FileUtils.copyDirectory;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests related to domain lifecycle sample scripts.\n+ */\n+@DisplayName(\"Verify the domain lifecycle sample scripts\")\n+@IntegrationTest\n+public class ItLifecycleSampleScripts {\n+\n+  public static final String SERVER_LIFECYCLE = \"Server\";\n+  public static final String CLUSTER_LIFECYCLE = \"Cluster\";\n+  public static final String DOMAIN = \"DOMAIN\";\n+  public static final String STOP_SERVER_SCRIPT = \"stopServer.sh\";\n+  public static final String START_SERVER_SCRIPT = \"startServer.sh\";\n+  public static final String STOP_CLUSTER_SCRIPT = \"stopCluster.sh\";\n+  public static final String START_CLUSTER_SCRIPT = \"startCluster.sh\";\n+  public static final String STOP_DOMAIN_SCRIPT = \"stopDomain.sh\";\n+  public static final String START_DOMAIN_SCRIPT = \"startDomain.sh\";\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String domainName = \"domain1\";\n+  private final int replicaCount = 2;\n+  private final String clusterName = \"cluster-1\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String managedServerNameBase = \"managed-server\";\n+\n+  private final String adminServerPodName = domainName + \"-\" + adminServerName;\n+  private final String managedServerPodNamePrefix = domainName + \"-\" + managedServerNameBase;\n+  private final Path samplePath = Paths.get(ITTESTS_DIR, \"../kubernetes/samples\");\n+  private final Path domainLifecycleSamplePath = Paths.get(samplePath + \"/scripts/domain-lifecycle\");\n+  private final Path tempSamplePath = Paths.get(WORK_DIR, \"sample-testing\");\n+  private final Path sampleBase =\n+          Paths.get(tempSamplePath.toString(), \"scripts/create-weblogic-domain/domain-home-on-pv\");\n+\n+  private static final String[] params = {\"wlst:domain1\"};\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(10, MINUTES).await();\n+\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains and installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    // this secret is used only for non-kind cluster\n+    createSecretForBaseImages(domainNamespace);\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //create and start WebLogic domain using domain-home-on-pv sample scripts\n+    createDomain(sampleBase);\n+  }\n+\n+  /**\n+   * Test scripts for stopping and starting a managed server.\n+   */\n+  @ParameterizedTest\n+  @MethodSource(\"paramProvider\")\n+  @DisplayName(\"Test server lifecycle samples scripts\")\n+  public void testServerLifecycleScripts() {\n+\n+    // Verify that stopServer script execution shuts down server pod and replica count is decremented\n+    String serverName = managedServerNameBase + \"1\";\n+    executeLifecycleScript(STOP_SERVER_SCRIPT, SERVER_LIFECYCLE, serverName);\n+    checkPodDoesNotExist(managedServerPodNamePrefix + \"1\", domainName, domainNamespace);\n+    assertDoesNotThrow(() -> {\n+      checkClusterReplicaCountMatches(clusterName, domainName, domainNamespace, 1);\n+    });\n+\n+    // Verify that startServer script execution starts server pod and replica count is incremented\n+    executeLifecycleScript(START_SERVER_SCRIPT, SERVER_LIFECYCLE, serverName);\n+    checkPodExists(managedServerPodNamePrefix + \"1\", domainName, domainNamespace);\n+    assertDoesNotThrow(() -> {\n+      checkClusterReplicaCountMatches(clusterName, domainName, domainNamespace, 2);\n+    });\n+  }\n+\n+  /**\n+   * Test scripts for stopping and starting a managed server while keeping replica count constant.\n+   */\n+  @ParameterizedTest\n+  @MethodSource(\"paramProvider\")\n+  @DisplayName(\"Test server lifecycle samples scripts with constant replica count\")\n+  public void testServerLifecycleScriptsWithConstantReplicaCount() {\n+    String serverName = managedServerNameBase + \"1\";\n+    String keepReplicaCountConstantParameter = \"-k\";\n+    // Verify that replica count is not changed when using \"-k\" parameter and a replacement server is started\n+    executeLifecycleScript(STOP_SERVER_SCRIPT, SERVER_LIFECYCLE, serverName, keepReplicaCountConstantParameter);\n+    checkPodDoesNotExist(managedServerPodNamePrefix + \"1\", domainName, domainNamespace);\n+    checkPodExists(managedServerPodNamePrefix + \"3\", domainName, domainNamespace);\n+    assertDoesNotThrow(() -> {\n+      checkClusterReplicaCountMatches(clusterName, domainName, domainNamespace, 2);\n+    });\n+\n+    // Verify that replica count is not changed when using \"-k\" parameter and replacement server is shutdown\n+    executeLifecycleScript(START_SERVER_SCRIPT, SERVER_LIFECYCLE, serverName, keepReplicaCountConstantParameter);\n+    checkPodExists(managedServerPodNamePrefix + \"1\", domainName, domainNamespace);\n+    checkPodDoesNotExist(managedServerPodNamePrefix + \"3\", domainName, domainNamespace);\n+    assertDoesNotThrow(() -> {\n+      checkClusterReplicaCountMatches(clusterName, domainName, domainNamespace, 2);\n+    });\n+  }\n+\n+  /**\n+   * Test scripts for stopping and starting a cluster.\n+   */\n+  @ParameterizedTest\n+  @MethodSource(\"paramProvider\")\n+  @DisplayName(\"Test cluster lifecycle scripts\")\n+  public void testClusterLifecycleScripts() {\n+\n+    // Verify all clustered server pods are shut down after stopCluster script execution\n+    executeLifecycleScript(STOP_CLUSTER_SCRIPT, CLUSTER_LIFECYCLE, clusterName);\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodDoesNotExist(managedServerPodNamePrefix + i, domainName, domainNamespace);\n+    }\n+\n+    // Verify all clustered server pods are started after startCluster script execution\n+    executeLifecycleScript(START_CLUSTER_SCRIPT, CLUSTER_LIFECYCLE, clusterName);\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodExists(managedServerPodNamePrefix + i, domainName, domainNamespace);\n+    }\n+  }\n+\n+  /**\n+   * Test scripts for stopping and starting a domain.\n+   */\n+  @ParameterizedTest\n+  @MethodSource(\"paramProvider\")\n+  @DisplayName(\"Test domain lifecycle scripts\")\n+  public void testDomainLifecycleScripts() {\n+    // Verify all WebLogic server instance pods are shut down after stopDomain script execution\n+    executeLifecycleScript(STOP_DOMAIN_SCRIPT, DOMAIN, null);\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodDoesNotExist(managedServerPodNamePrefix + i, domainName, domainNamespace);\n+    }\n+    checkPodDoesNotExist(adminServerPodName, domainName, domainNamespace);\n+\n+    // Verify all WebLogic server instance pods are started after startDomain script execution\n+    executeLifecycleScript(START_DOMAIN_SCRIPT, DOMAIN, null);\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodExists(managedServerPodNamePrefix + i, domainName, domainNamespace);\n+    }\n+    checkPodExists(adminServerPodName, domainName, domainNamespace);\n+  }\n+\n+  // Function to execute domain lifecyle scripts\n+  private void executeLifecycleScript(String script, String scriptType, String entityName) {\n+    executeLifecycleScript(script, scriptType, entityName, \"\");\n+  }\n+\n+  // Function to execute domain lifecyle scripts\n+  private void executeLifecycleScript(String script, String scriptType, String entityName, String extraParams) {\n+    CommandParams params;\n+    boolean result;\n+    String commonParameters = \" -d \" + domainName + \" -n \" + domainNamespace;\n+    params = new CommandParams().defaults();\n+    if (scriptType.equals(SERVER_LIFECYCLE)) {\n+      params.command(\"sh \"\n+              + Paths.get(domainLifecycleSamplePath.toString(), \"/\" + script).toString()\n+              + commonParameters + \" -s \" + entityName + \" \" + extraParams);\n+    } else if (scriptType.equals(CLUSTER_LIFECYCLE)) {\n+      params.command(\"sh \"\n+              + Paths.get(domainLifecycleSamplePath.toString(), \"/\" + script).toString()\n+              + commonParameters + \" -c \" + entityName);\n+    } else {\n+      params.command(\"sh \"\n+              + Paths.get(domainLifecycleSamplePath.toString(), \"/\" + script).toString()\n+              + commonParameters);\n+    }\n+    result = Command.withParams(params).execute();\n+    assertTrue(result, \"Failed to execute script \" + script);\n+  }\n+\n+  // generates the stream of objects used by parametrized test.\n+  private static Stream<String> paramProvider() {\n+    return Arrays.stream(params);\n+  }\n+\n+  // Create domain using doamain-home-on-pv sample script and verify admin/managed pods are ready\n+  private void createDomain(Path sampleBase) {\n+    //copy the samples directory to a temporary location\n+    setupSample();\n+    //create PV and PVC used by the domain\n+    createPvPvc(domainName);\n+\n+    //create WebLogic secrets for the domain\n+    createSecretWithUsernamePassword(domainName + \"-weblogic-credentials\", domainNamespace,\n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // change namespace from default to custom, set wlst or wdt, domain name, and t3PublicAddress\n+    assertDoesNotThrow(() -> {\n+      replaceStringInFile(Paths.get(sampleBase.toString(), \"create-domain-inputs.yaml\").toString(),\n+              \"namespace: default\", \"namespace: \" + domainNamespace);\n+      replaceStringInFile(Paths.get(sampleBase.toString(), \"create-domain-inputs.yaml\").toString(),\n+              \"#t3PublicAddress:\", \"t3PublicAddress: \" + K8S_NODEPORT_HOST);\n+      replaceStringInFile(Paths.get(sampleBase.toString(), \"create-domain-inputs.yaml\").toString(),\n+              \"image: container-registry.oracle.com/middleware/weblogic:12.2.1.4\",\n+              \"image: \" + WEBLOGIC_IMAGE_TO_USE_IN_SPEC);\n+      replaceStringInFile(Paths.get(sampleBase.toString(), \"create-domain-inputs.yaml\").toString(),\n+              \"#imagePullSecretName:\", \"imagePullSecretName: \" + BASE_IMAGES_REPO_SECRET);\n+    });\n+\n+    // run create-domain.sh to create domain.yaml file\n+    CommandParams params = new CommandParams().defaults();\n+    params.command(\"sh \"\n+            + Paths.get(sampleBase.toString(), \"create-domain.sh\").toString()\n+            + \" -i \" + Paths.get(sampleBase.toString(), \"create-domain-inputs.yaml\").toString()\n+            + \" -o \"\n+            + Paths.get(sampleBase.toString()));\n+\n+    boolean result = Command.withParams(params).execute();\n+    assertTrue(result, \"Failed to create domain.yaml\");\n+\n+    // run kubectl to create the domain\n+    params = new CommandParams().defaults();\n+    params.command(\"kubectl apply -f \"\n+            + Paths.get(sampleBase.toString(), \"weblogic-domains/\" + domainName + \"/domain.yaml\").toString());\n+\n+    result = Command.withParams(params).execute();\n+    assertTrue(result, \"Failed to create domain custom resource\");\n+\n+    // wait for the domain to exist\n+    logger.info(\"Checking for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+              .conditionEvaluationListener(\n+                  condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                                  + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                            domainName,\n+                            domainNamespace,\n+                            condition.getElapsedTimeInMS(),\n+                            condition.getRemainingTimeInMS()))\n+              .until(domainExists(domainName, DOMAIN_VERSION, domainNamespace));\n+\n+    // verify the admin server service and pod is created\n+    checkPodReadyAndServiceExists(adminServerPodName, domainName, domainNamespace);\n+\n+    // verify managed server services created and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodReadyAndServiceExists(managedServerPodNamePrefix + i, domainName, domainNamespace);\n+    }\n+\n+  }\n+\n+  // copy samples directory to a temporary location\n+  private void setupSample() {\n+    assertDoesNotThrow(() -> {\n+      // copy ITTESTS_DIR + \"../kubernates/samples\" to WORK_DIR + \"/sample-testing\"\n+      logger.info(\"Deleting and recreating {0}\", tempSamplePath);\n+      Files.createDirectories(tempSamplePath);\n+      deleteDirectory(tempSamplePath.toFile());\n+      Files.createDirectories(tempSamplePath);\n+\n+      logger.info(\"Copying {0} to {1}\", samplePath, tempSamplePath);\n+      copyDirectory(samplePath.toFile(), tempSamplePath.toFile());\n+    });\n+  }\n+\n+  // create persistent volume and persistent volume claims used by the samples\n+  private void createPvPvc(String domainName) {\n+\n+    String pvName = domainName + \"-weblogic-sample-pv\";\n+    String pvcName = domainName + \"-weblogic-sample-pvc\";\n+\n+    Path pvpvcBase = Paths.get(tempSamplePath.toString(),\n+        \"scripts/create-weblogic-domain-pv-pvc\");\n+\n+    // create pv and pvc\n+    assertDoesNotThrow(() -> {\n+      // when tests are running in local box the PV directories need to exist\n+      Path pvHostPath = null;\n+      pvHostPath = Files.createDirectories(Paths.get(PV_ROOT, this.getClass().getSimpleName(), pvName));\n+\n+      logger.info(\"Creating PV directory host path {0}\", pvHostPath);\n+      deleteDirectory(pvHostPath.toFile());\n+      Files.createDirectories(pvHostPath);\n+\n+      // set the pvHostPath in create-pv-pvc-inputs.yaml\n+      replaceStringInFile(Paths.get(pvpvcBase.toString(), \"create-pv-pvc-inputs.yaml\").toString(),\n+          \"#weblogicDomainStoragePath: /scratch/k8s_dir\", \"weblogicDomainStoragePath: \" + pvHostPath);\n+      // set the namespace in create-pv-pvc-inputs.yaml\n+      replaceStringInFile(Paths.get(pvpvcBase.toString(), \"create-pv-pvc-inputs.yaml\").toString(),\n+          \"namespace: default\", \"namespace: \" + domainNamespace);\n+      // set the baseName to domain name in create-pv-pvc-inputs.yaml\n+      replaceStringInFile(Paths.get(pvpvcBase.toString(), \"create-pv-pvc-inputs.yaml\").toString(),\n+          \"baseName: weblogic-sample\", \"baseName: \" + domainName + \"-weblogic-sample\");\n+      // set the pv storage policy to Recycle in create-pv-pvc-inputs.yaml\n+      replaceStringInFile(Paths.get(pvpvcBase.toString(), \"create-pv-pvc-inputs.yaml\").toString(),\n+          \"weblogicDomainStorageReclaimPolicy: Retain\", \"weblogicDomainStorageReclaimPolicy: Recycle\");\n+    });\n+\n+    // generate the create-pv-pvc-inputs.yaml\n+    CommandParams params = new CommandParams().defaults();\n+    params.command(\"sh \"\n+        + Paths.get(pvpvcBase.toString(), \"create-pv-pvc.sh\").toString()\n+        + \" -i \" + Paths.get(pvpvcBase.toString(), \"create-pv-pvc-inputs.yaml\").toString()\n+        + \" -o \"\n+        + Paths.get(pvpvcBase.toString()));\n+\n+    boolean result = Command.withParams(params).execute();\n+    assertTrue(result, \"Failed to create create-pv-pvc-inputs.yaml\");\n+\n+    //create pv and pvc\n+    params = new CommandParams().defaults();\n+    params.command(\"kubectl create -f \" + Paths.get(pvpvcBase.toString(),\n+        \"pv-pvcs/\" + domainName + \"-weblogic-sample-pv.yaml\").toString());\n+    result = Command.withParams(params).execute();\n+    assertTrue(result, \"Failed to create pv\");\n+\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pv {0} to be ready, \"\n+                + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                pvName,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> pvExists(pvName, null),\n+            String.format(\"pvExists failed with ApiException for pv %s\",\n+                pvName)));\n+\n+    params = new CommandParams().defaults();\n+    params.command(\"kubectl create -f \" + Paths.get(pvpvcBase.toString(),\n+        \"pv-pvcs/\" + domainName + \"-weblogic-sample-pvc.yaml\").toString());\n+    result = Command.withParams(params).execute();\n+    assertTrue(result, \"Failed to create pvc\");\n+\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pv {0} to be ready in namespace {1} \"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                pvcName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> pvcExists(pvcName, domainNamespace),\n+            String.format(\"pvcExists failed with ApiException for pvc %s\",\n+                pvcName)));\n+\n+  }\n+\n+  /**\n+   * Delete the persistent volumes since the pv is not decorated with label.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+    deleteDomain();\n+    for (String domainName : new String[]{\"domain1\", \"domain2\"}) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97b7fcd21856634cef2e0a5dd3207850509f50dc"}, "originalPosition": 419}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDMyMDUzNg==", "bodyText": "Are you planning to add more domain types for these tests? If not you don't need to Parameterize the tests, since only 1 domain is created.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r510320536", "createdAt": "2020-10-22T17:03:01Z", "author": {"login": "sankarpn"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItLifecycleSampleScripts.java", "diffHunk": "@@ -0,0 +1,448 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.BASE_IMAGES_REPO_SECRET;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.WEBLOGIC_IMAGE_TO_USE_IN_SPEC;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.pvExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.pvcExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkClusterReplicaCountMatches;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretForBaseImages;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.replaceStringInFile;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.apache.commons.io.FileUtils.copyDirectory;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests related to domain lifecycle sample scripts.\n+ */\n+@DisplayName(\"Verify the domain lifecycle sample scripts\")\n+@IntegrationTest\n+public class ItLifecycleSampleScripts {\n+\n+  public static final String SERVER_LIFECYCLE = \"Server\";\n+  public static final String CLUSTER_LIFECYCLE = \"Cluster\";\n+  public static final String DOMAIN = \"DOMAIN\";\n+  public static final String STOP_SERVER_SCRIPT = \"stopServer.sh\";\n+  public static final String START_SERVER_SCRIPT = \"startServer.sh\";\n+  public static final String STOP_CLUSTER_SCRIPT = \"stopCluster.sh\";\n+  public static final String START_CLUSTER_SCRIPT = \"startCluster.sh\";\n+  public static final String STOP_DOMAIN_SCRIPT = \"stopDomain.sh\";\n+  public static final String START_DOMAIN_SCRIPT = \"startDomain.sh\";\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String domainName = \"domain1\";\n+  private final int replicaCount = 2;\n+  private final String clusterName = \"cluster-1\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String managedServerNameBase = \"managed-server\";\n+\n+  private final String adminServerPodName = domainName + \"-\" + adminServerName;\n+  private final String managedServerPodNamePrefix = domainName + \"-\" + managedServerNameBase;\n+  private final Path samplePath = Paths.get(ITTESTS_DIR, \"../kubernetes/samples\");\n+  private final Path domainLifecycleSamplePath = Paths.get(samplePath + \"/scripts/domain-lifecycle\");\n+  private final Path tempSamplePath = Paths.get(WORK_DIR, \"sample-testing\");\n+  private final Path sampleBase =\n+          Paths.get(tempSamplePath.toString(), \"scripts/create-weblogic-domain/domain-home-on-pv\");\n+\n+  private static final String[] params = {\"wlst:domain1\"};\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(10, MINUTES).await();\n+\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains and installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    // this secret is used only for non-kind cluster\n+    createSecretForBaseImages(domainNamespace);\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //create and start WebLogic domain using domain-home-on-pv sample scripts\n+    createDomain(sampleBase);\n+  }\n+\n+  /**\n+   * Test scripts for stopping and starting a managed server.\n+   */\n+  @ParameterizedTest", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97b7fcd21856634cef2e0a5dd3207850509f50dc"}, "originalPosition": 129}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fde5cb83c7e2c78df33e9b35c67a2e4304512303", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/fde5cb83c7e2c78df33e9b35c67a2e4304512303", "committedDate": "2020-10-22T18:20:13Z", "message": "Address PR review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MDA1NjY3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-515005667", "createdAt": "2020-10-22T18:26:31Z", "commit": {"oid": "fde5cb83c7e2c78df33e9b35c67a2e4304512303"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxODoyNjozMVrOHmuhhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxODoyNjo1M1rOHmuiYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM3MDE4MA==", "bodyText": "Since the tests are not parameterized you can remove this line.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r510370180", "createdAt": "2020-10-22T18:26:31Z", "author": {"login": "sankarpn"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItLifecycleSampleScripts.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.BASE_IMAGES_REPO_SECRET;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.WEBLOGIC_IMAGE_TO_USE_IN_SPEC;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.pvExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.pvcExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkClusterReplicaCountMatches;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretForBaseImages;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.replaceStringInFile;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.apache.commons.io.FileUtils.copyDirectory;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests related to domain lifecycle sample scripts.\n+ */\n+@DisplayName(\"Verify the domain lifecycle sample scripts\")\n+@IntegrationTest\n+public class ItLifecycleSampleScripts {\n+\n+  public static final String SERVER_LIFECYCLE = \"Server\";\n+  public static final String CLUSTER_LIFECYCLE = \"Cluster\";\n+  public static final String DOMAIN = \"DOMAIN\";\n+  public static final String STOP_SERVER_SCRIPT = \"stopServer.sh\";\n+  public static final String START_SERVER_SCRIPT = \"startServer.sh\";\n+  public static final String STOP_CLUSTER_SCRIPT = \"stopCluster.sh\";\n+  public static final String START_CLUSTER_SCRIPT = \"startCluster.sh\";\n+  public static final String STOP_DOMAIN_SCRIPT = \"stopDomain.sh\";\n+  public static final String START_DOMAIN_SCRIPT = \"startDomain.sh\";\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String domainName = \"domain1\";\n+  private final int replicaCount = 2;\n+  private final String clusterName = \"cluster-1\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String managedServerNameBase = \"managed-server\";\n+\n+  private final String adminServerPodName = domainName + \"-\" + adminServerName;\n+  private final String managedServerPodNamePrefix = domainName + \"-\" + managedServerNameBase;\n+  private final Path samplePath = Paths.get(ITTESTS_DIR, \"../kubernetes/samples\");\n+  private final Path domainLifecycleSamplePath = Paths.get(samplePath + \"/scripts/domain-lifecycle\");\n+  private final Path tempSamplePath = Paths.get(WORK_DIR, \"lifecycle-scripts-testing\");\n+  private final Path sampleBase =\n+          Paths.get(tempSamplePath.toString(), \"scripts/create-weblogic-domain/domain-home-on-pv\");\n+\n+  private static final String[] params = {\"wlst:domain1\"};\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(10, MINUTES).await();\n+\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains and installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    // this secret is used only for non-kind cluster\n+    createSecretForBaseImages(domainNamespace);\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //create and start WebLogic domain using domain-home-on-pv sample scripts\n+    createDomain(sampleBase);\n+  }\n+\n+  /**\n+   * Test scripts for stopping and starting a managed server.\n+   */\n+  @Test\n+  @MethodSource(\"paramProvider\")\n+  @DisplayName(\"Test server lifecycle samples scripts\")\n+  public void testServerLifecycleScripts() {\n+\n+    // Verify that stopServer script execution shuts down server pod and replica count is decremented\n+    String serverName = managedServerNameBase + \"1\";\n+    executeLifecycleScript(STOP_SERVER_SCRIPT, SERVER_LIFECYCLE, serverName);\n+    checkPodDoesNotExist(managedServerPodNamePrefix + \"1\", domainName, domainNamespace);\n+    assertDoesNotThrow(() -> {\n+      checkClusterReplicaCountMatches(clusterName, domainName, domainNamespace, 1);\n+    });\n+\n+    // Verify that startServer script execution starts server pod and replica count is incremented\n+    executeLifecycleScript(START_SERVER_SCRIPT, SERVER_LIFECYCLE, serverName);\n+    checkPodExists(managedServerPodNamePrefix + \"1\", domainName, domainNamespace);\n+    assertDoesNotThrow(() -> {\n+      checkClusterReplicaCountMatches(clusterName, domainName, domainNamespace, 2);\n+    });\n+  }\n+\n+  /**\n+   * Test scripts for stopping and starting a managed server while keeping replica count constant.\n+   */\n+  @Test\n+  @MethodSource(\"paramProvider\")\n+  @DisplayName(\"Test server lifecycle samples scripts with constant replica count\")\n+  public void testServerLifecycleScriptsWithConstantReplicaCount() {\n+    String serverName = managedServerNameBase + \"1\";\n+    String keepReplicaCountConstantParameter = \"-k\";\n+    // Verify that replica count is not changed when using \"-k\" parameter and a replacement server is started\n+    executeLifecycleScript(STOP_SERVER_SCRIPT, SERVER_LIFECYCLE, serverName, keepReplicaCountConstantParameter);\n+    checkPodDoesNotExist(managedServerPodNamePrefix + \"1\", domainName, domainNamespace);\n+    checkPodExists(managedServerPodNamePrefix + \"3\", domainName, domainNamespace);\n+    assertDoesNotThrow(() -> {\n+      checkClusterReplicaCountMatches(clusterName, domainName, domainNamespace, 2);\n+    });\n+\n+    // Verify that replica count is not changed when using \"-k\" parameter and replacement server is shutdown\n+    executeLifecycleScript(START_SERVER_SCRIPT, SERVER_LIFECYCLE, serverName, keepReplicaCountConstantParameter);\n+    checkPodExists(managedServerPodNamePrefix + \"1\", domainName, domainNamespace);\n+    checkPodDoesNotExist(managedServerPodNamePrefix + \"3\", domainName, domainNamespace);\n+    assertDoesNotThrow(() -> {\n+      checkClusterReplicaCountMatches(clusterName, domainName, domainNamespace, 2);\n+    });\n+  }\n+\n+  /**\n+   * Test scripts for stopping and starting a cluster.\n+   */\n+  @Test\n+  @MethodSource(\"paramProvider\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fde5cb83c7e2c78df33e9b35c67a2e4304512303"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM3MDQwMw==", "bodyText": "You don't need this method", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r510370403", "createdAt": "2020-10-22T18:26:53Z", "author": {"login": "sankarpn"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItLifecycleSampleScripts.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.BASE_IMAGES_REPO_SECRET;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.WEBLOGIC_IMAGE_TO_USE_IN_SPEC;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.pvExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.pvcExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkClusterReplicaCountMatches;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretForBaseImages;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.replaceStringInFile;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.apache.commons.io.FileUtils.copyDirectory;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests related to domain lifecycle sample scripts.\n+ */\n+@DisplayName(\"Verify the domain lifecycle sample scripts\")\n+@IntegrationTest\n+public class ItLifecycleSampleScripts {\n+\n+  public static final String SERVER_LIFECYCLE = \"Server\";\n+  public static final String CLUSTER_LIFECYCLE = \"Cluster\";\n+  public static final String DOMAIN = \"DOMAIN\";\n+  public static final String STOP_SERVER_SCRIPT = \"stopServer.sh\";\n+  public static final String START_SERVER_SCRIPT = \"startServer.sh\";\n+  public static final String STOP_CLUSTER_SCRIPT = \"stopCluster.sh\";\n+  public static final String START_CLUSTER_SCRIPT = \"startCluster.sh\";\n+  public static final String STOP_DOMAIN_SCRIPT = \"stopDomain.sh\";\n+  public static final String START_DOMAIN_SCRIPT = \"startDomain.sh\";\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String domainName = \"domain1\";\n+  private final int replicaCount = 2;\n+  private final String clusterName = \"cluster-1\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String managedServerNameBase = \"managed-server\";\n+\n+  private final String adminServerPodName = domainName + \"-\" + adminServerName;\n+  private final String managedServerPodNamePrefix = domainName + \"-\" + managedServerNameBase;\n+  private final Path samplePath = Paths.get(ITTESTS_DIR, \"../kubernetes/samples\");\n+  private final Path domainLifecycleSamplePath = Paths.get(samplePath + \"/scripts/domain-lifecycle\");\n+  private final Path tempSamplePath = Paths.get(WORK_DIR, \"lifecycle-scripts-testing\");\n+  private final Path sampleBase =\n+          Paths.get(tempSamplePath.toString(), \"scripts/create-weblogic-domain/domain-home-on-pv\");\n+\n+  private static final String[] params = {\"wlst:domain1\"};\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(10, MINUTES).await();\n+\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains and installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    // this secret is used only for non-kind cluster\n+    createSecretForBaseImages(domainNamespace);\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //create and start WebLogic domain using domain-home-on-pv sample scripts\n+    createDomain(sampleBase);\n+  }\n+\n+  /**\n+   * Test scripts for stopping and starting a managed server.\n+   */\n+  @Test\n+  @MethodSource(\"paramProvider\")\n+  @DisplayName(\"Test server lifecycle samples scripts\")\n+  public void testServerLifecycleScripts() {\n+\n+    // Verify that stopServer script execution shuts down server pod and replica count is decremented\n+    String serverName = managedServerNameBase + \"1\";\n+    executeLifecycleScript(STOP_SERVER_SCRIPT, SERVER_LIFECYCLE, serverName);\n+    checkPodDoesNotExist(managedServerPodNamePrefix + \"1\", domainName, domainNamespace);\n+    assertDoesNotThrow(() -> {\n+      checkClusterReplicaCountMatches(clusterName, domainName, domainNamespace, 1);\n+    });\n+\n+    // Verify that startServer script execution starts server pod and replica count is incremented\n+    executeLifecycleScript(START_SERVER_SCRIPT, SERVER_LIFECYCLE, serverName);\n+    checkPodExists(managedServerPodNamePrefix + \"1\", domainName, domainNamespace);\n+    assertDoesNotThrow(() -> {\n+      checkClusterReplicaCountMatches(clusterName, domainName, domainNamespace, 2);\n+    });\n+  }\n+\n+  /**\n+   * Test scripts for stopping and starting a managed server while keeping replica count constant.\n+   */\n+  @Test\n+  @MethodSource(\"paramProvider\")\n+  @DisplayName(\"Test server lifecycle samples scripts with constant replica count\")\n+  public void testServerLifecycleScriptsWithConstantReplicaCount() {\n+    String serverName = managedServerNameBase + \"1\";\n+    String keepReplicaCountConstantParameter = \"-k\";\n+    // Verify that replica count is not changed when using \"-k\" parameter and a replacement server is started\n+    executeLifecycleScript(STOP_SERVER_SCRIPT, SERVER_LIFECYCLE, serverName, keepReplicaCountConstantParameter);\n+    checkPodDoesNotExist(managedServerPodNamePrefix + \"1\", domainName, domainNamespace);\n+    checkPodExists(managedServerPodNamePrefix + \"3\", domainName, domainNamespace);\n+    assertDoesNotThrow(() -> {\n+      checkClusterReplicaCountMatches(clusterName, domainName, domainNamespace, 2);\n+    });\n+\n+    // Verify that replica count is not changed when using \"-k\" parameter and replacement server is shutdown\n+    executeLifecycleScript(START_SERVER_SCRIPT, SERVER_LIFECYCLE, serverName, keepReplicaCountConstantParameter);\n+    checkPodExists(managedServerPodNamePrefix + \"1\", domainName, domainNamespace);\n+    checkPodDoesNotExist(managedServerPodNamePrefix + \"3\", domainName, domainNamespace);\n+    assertDoesNotThrow(() -> {\n+      checkClusterReplicaCountMatches(clusterName, domainName, domainNamespace, 2);\n+    });\n+  }\n+\n+  /**\n+   * Test scripts for stopping and starting a cluster.\n+   */\n+  @Test\n+  @MethodSource(\"paramProvider\")\n+  @DisplayName(\"Test cluster lifecycle scripts\")\n+  public void testClusterLifecycleScripts() {\n+\n+    // Verify all clustered server pods are shut down after stopCluster script execution\n+    executeLifecycleScript(STOP_CLUSTER_SCRIPT, CLUSTER_LIFECYCLE, clusterName);\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodDoesNotExist(managedServerPodNamePrefix + i, domainName, domainNamespace);\n+    }\n+\n+    // Verify all clustered server pods are started after startCluster script execution\n+    executeLifecycleScript(START_CLUSTER_SCRIPT, CLUSTER_LIFECYCLE, clusterName);\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodExists(managedServerPodNamePrefix + i, domainName, domainNamespace);\n+    }\n+  }\n+\n+  /**\n+   * Test scripts for stopping and starting a domain.\n+   */\n+  @Test\n+  @MethodSource(\"paramProvider\")\n+  @DisplayName(\"Test domain lifecycle scripts\")\n+  public void testDomainLifecycleScripts() {\n+    // Verify all WebLogic server instance pods are shut down after stopDomain script execution\n+    executeLifecycleScript(STOP_DOMAIN_SCRIPT, DOMAIN, null);\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodDoesNotExist(managedServerPodNamePrefix + i, domainName, domainNamespace);\n+    }\n+    checkPodDoesNotExist(adminServerPodName, domainName, domainNamespace);\n+\n+    // Verify all WebLogic server instance pods are started after startDomain script execution\n+    executeLifecycleScript(START_DOMAIN_SCRIPT, DOMAIN, null);\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodExists(managedServerPodNamePrefix + i, domainName, domainNamespace);\n+    }\n+    checkPodExists(adminServerPodName, domainName, domainNamespace);\n+  }\n+\n+  // Function to execute domain lifecyle scripts\n+  private void executeLifecycleScript(String script, String scriptType, String entityName) {\n+    executeLifecycleScript(script, scriptType, entityName, \"\");\n+  }\n+\n+  // Function to execute domain lifecyle scripts\n+  private void executeLifecycleScript(String script, String scriptType, String entityName, String extraParams) {\n+    CommandParams params;\n+    boolean result;\n+    String commonParameters = \" -d \" + domainName + \" -n \" + domainNamespace;\n+    params = new CommandParams().defaults();\n+    if (scriptType.equals(SERVER_LIFECYCLE)) {\n+      params.command(\"sh \"\n+              + Paths.get(domainLifecycleSamplePath.toString(), \"/\" + script).toString()\n+              + commonParameters + \" -s \" + entityName + \" \" + extraParams);\n+    } else if (scriptType.equals(CLUSTER_LIFECYCLE)) {\n+      params.command(\"sh \"\n+              + Paths.get(domainLifecycleSamplePath.toString(), \"/\" + script).toString()\n+              + commonParameters + \" -c \" + entityName);\n+    } else {\n+      params.command(\"sh \"\n+              + Paths.get(domainLifecycleSamplePath.toString(), \"/\" + script).toString()\n+              + commonParameters);\n+    }\n+    result = Command.withParams(params).execute();\n+    assertTrue(result, \"Failed to execute script \" + script);\n+  }\n+\n+  // generates the stream of objects used by parametrized test.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fde5cb83c7e2c78df33e9b35c67a2e4304512303"}, "originalPosition": 247}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2927762ee4a04cfd8747c2ac6df56200dbf7e991", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/2927762ee4a04cfd8747c2ac6df56200dbf7e991", "committedDate": "2020-10-22T18:51:24Z", "message": "Review comment and cleanup."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MDc0ODc4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-515074878", "createdAt": "2020-10-22T20:01:21Z", "commit": {"oid": "2927762ee4a04cfd8747c2ac6df56200dbf7e991"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMDowMToyMVrOHmxu5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMDowMToyMVrOHmxu5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQyMjc1Nw==", "bodyText": "You can add these tests into existing ItSamples.java. You can use the domain that's already created/started by the test in ItSamples to verify your scripts. That saves time for domain creation/startup and all the tests for verifying the samples will be in one class.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r510422757", "createdAt": "2020-10-22T20:01:21Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItLifecycleSampleScripts.java", "diffHunk": "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.BASE_IMAGES_REPO_SECRET;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.WEBLOGIC_IMAGE_TO_USE_IN_SPEC;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.pvExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.pvcExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkClusterReplicaCountMatches;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretForBaseImages;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.replaceStringInFile;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.apache.commons.io.FileUtils.copyDirectory;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests related to domain lifecycle sample scripts.\n+ */\n+@DisplayName(\"Verify the domain lifecycle sample scripts\")\n+@IntegrationTest\n+public class ItLifecycleSampleScripts {\n+\n+  public static final String SERVER_LIFECYCLE = \"Server\";\n+  public static final String CLUSTER_LIFECYCLE = \"Cluster\";\n+  public static final String DOMAIN = \"DOMAIN\";\n+  public static final String STOP_SERVER_SCRIPT = \"stopServer.sh\";\n+  public static final String START_SERVER_SCRIPT = \"startServer.sh\";\n+  public static final String STOP_CLUSTER_SCRIPT = \"stopCluster.sh\";\n+  public static final String START_CLUSTER_SCRIPT = \"startCluster.sh\";\n+  public static final String STOP_DOMAIN_SCRIPT = \"stopDomain.sh\";\n+  public static final String START_DOMAIN_SCRIPT = \"startDomain.sh\";\n+  private static String domainNamespace = null;\n+  private static final String domainName = \"domain1\";\n+  private final int replicaCount = 2;\n+  private final String clusterName = \"cluster-1\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String managedServerNameBase = \"managed-server\";\n+\n+  private final String adminServerPodName = domainName + \"-\" + adminServerName;\n+  private final String managedServerPodNamePrefix = domainName + \"-\" + managedServerNameBase;\n+  private final Path samplePath = Paths.get(ITTESTS_DIR, \"../kubernetes/samples\");\n+  private final Path domainLifecycleSamplePath = Paths.get(samplePath + \"/scripts/domain-lifecycle\");\n+  private final Path tempSamplePath = Paths.get(WORK_DIR, \"lifecycle-scripts-testing\");\n+  private final Path sampleBase =\n+          Paths.get(tempSamplePath.toString(), \"scripts/create-weblogic-domain/domain-home-on-pv\");\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(10, MINUTES).await();\n+\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains and installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    String opNamespace = namespaces.get(0);\n+\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    logger.info(\"Assign a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    // this secret is used only for non-kind cluster\n+    createSecretForBaseImages(domainNamespace);\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //create and start WebLogic domain using domain-home-on-pv sample scripts\n+    createDomain(sampleBase);\n+  }\n+\n+  /**\n+   * Test scripts for stopping and starting a managed server.\n+   */\n+  @Test\n+  @DisplayName(\"Test server lifecycle samples scripts\")\n+  public void testServerLifecycleScripts() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2927762ee4a04cfd8747c2ac6df56200dbf7e991"}, "originalPosition": 126}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MTE3MzY1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-515117365", "createdAt": "2020-10-22T21:04:03Z", "commit": {"oid": "2927762ee4a04cfd8747c2ac6df56200dbf7e991"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1NzcwODY2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-515770866", "createdAt": "2020-10-23T15:22:54Z", "commit": {"oid": "2927762ee4a04cfd8747c2ac6df56200dbf7e991"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNToyMjo1NFrOHnSiDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNToyMjo1NFrOHnSiDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk2MDE0MQ==", "bodyText": "Everything remaining below should be removed - since it's now in the sample which you reference ^^^.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r510960141", "createdAt": "2020-10-23T15:22:54Z", "author": {"login": "tbarnes-us"}, "path": "docs-source/content/userguide/managing-domains/domain-lifecycle/startup.md", "diffHunk": "@@ -82,6 +83,75 @@ updates before advancing the server to the running state.\n \n Changes to the `serverStartState` property do not affect already started servers.\n \n+### Domain lifecycle sample scripts\n+Beginning with operator version 3.1.0, the WebLogic Server Kubernetes Operator project provides a set of sample scripts to shut-down or start-up a specific managed-server, cluster or the entire domain. These scripts are located in the `kubernetes/samples/scripts/domain-lifecycle` directory. These can be helpful when scripting the lifecycle of a WebLogic Server Domain.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2927762ee4a04cfd8747c2ac6df56200dbf7e991"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1Nzg0Nzg5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-515784789", "createdAt": "2020-10-23T15:35:45Z", "commit": {"oid": "2927762ee4a04cfd8747c2ac6df56200dbf7e991"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTozNTo0NVrOHnTIew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTozNTo0NVrOHnTIew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk2OTk3OQ==", "bodyText": "Please add a link back to the lifecycle documenation here.  Note that because this is not underr 'docs-source/content' the link will need to be a full URL (github.io/...) or a relatively link (../..).  Often, both styles of link are helpful - for example:\n./create-weblogic-domain/model-in-image/README.md:  - [source](../../../../../docs-source/content/samples/simple/domains/model-in-image/_index.md)\n./create-weblogic-domain/model-in-image/README.md:  - [latest public](https://oracle.github.io/weblogic-kubernetes-operator/samples/simple/domains/model-in-image)", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r510969979", "createdAt": "2020-10-23T15:35:45Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/README.md", "diffHunk": "@@ -0,0 +1,65 @@\n+### Domain lifecycle sample scripts\n+The WebLogic Server Kubernetes Operator project provides a set of sample scripts to shut down or start a specific managed-server, cluster or the entire domain. These can be helpful when scripting the lifecycle of a WebLogic Server Domain.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2927762ee4a04cfd8747c2ac6df56200dbf7e991"}, "originalPosition": 2}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1Nzg4MTU0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-515788154", "createdAt": "2020-10-23T15:39:55Z", "commit": {"oid": "2927762ee4a04cfd8747c2ac6df56200dbf7e991"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTozOTo1NVrOHnTSyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTozOTo1NVrOHnTSyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3MjYxNg==", "bodyText": "Please add a documentation stub in the sample's doc-source documentation that points here.  Specifically, add a new directory and small markup file under /scratch/tbarnes/github-k8op/weblogic-kubernetes-operator/docs-source/content/samples/simple/domains/some-new-directory/_index.md.  You can follow the pattern for the delete-domain directory.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r510972616", "createdAt": "2020-10-23T15:39:55Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/README.md", "diffHunk": "@@ -0,0 +1,65 @@\n+### Domain lifecycle sample scripts", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2927762ee4a04cfd8747c2ac6df56200dbf7e991"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1ODA1MzY2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-515805366", "createdAt": "2020-10-23T16:01:11Z", "commit": {"oid": "2927762ee4a04cfd8747c2ac6df56200dbf7e991"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjowMToxMlrOHnUF4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjowMToxMlrOHnUF4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NTY5OA==", "bodyText": "I have a general concern that readers that reach this point in the documentation might be very new to WKO and so may not realize that they need to have deployed a domain first and that the domain's introspector must have run successfully first.  Please call out these assumptions here.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r510985698", "createdAt": "2020-10-23T16:01:12Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/README.md", "diffHunk": "@@ -0,0 +1,65 @@\n+### Domain lifecycle sample scripts\n+The WebLogic Server Kubernetes Operator project provides a set of sample scripts to shut down or start a specific managed-server, cluster or the entire domain. These can be helpful when scripting the lifecycle of a WebLogic Server Domain.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2927762ee4a04cfd8747c2ac6df56200dbf7e991"}, "originalPosition": 2}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1ODEwNjgx", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-515810681", "createdAt": "2020-10-23T16:07:56Z", "commit": {"oid": "2927762ee4a04cfd8747c2ac6df56200dbf7e991"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjowNzo1N1rOHnUVbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjowNzo1N1rOHnUVbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4OTY3OA==", "bodyText": "Everywhere 'server start policy' or another domain resource setting is mentioned, please prepend the words 'domain resource' and append the words 'attribute' so that the reader knows exactly what kind of attribute is being referenced - unless the doc has already clearly made a fully qualified reference to the attribute in a nearby location.  Where appropriate, it can also be helpful to provide the exact name of the attribute, eg. spec.xxx.server-name.xxx.yyy...", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r510989678", "createdAt": "2020-10-23T16:07:57Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/README.md", "diffHunk": "@@ -0,0 +1,65 @@\n+### Domain lifecycle sample scripts\n+The WebLogic Server Kubernetes Operator project provides a set of sample scripts to shut down or start a specific managed-server, cluster or the entire domain. These can be helpful when scripting the lifecycle of a WebLogic Server Domain.\n+\n+#### Scripts to start and stop a managed server\n+The `startServer.sh` script starts a managed server by patching it's server start policy to `ALWAYS`. It also increases the replica count value for the managed server's cluster by `1`. The script provides an option to keep the replica count value constant. Please see script `usage` information using `-h` option.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2927762ee4a04cfd8747c2ac6df56200dbf7e991"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1ODE0ODc1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-515814875", "createdAt": "2020-10-23T16:13:37Z", "commit": {"oid": "2927762ee4a04cfd8747c2ac6df56200dbf7e991"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxMzozN1rOHnUiJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxMzozN1rOHnUiJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5MjkzMg==", "bodyText": "Is it a requirement for this script to work using the (ancient) version of bash on MacOS? We have that requirement for other k8s scripts, but I hope not for this script.  But if so, then please do some ad hoc testing to make sure it works.  Note that jq isn't available on MacOS by default.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r510992932", "createdAt": "2020-10-23T16:13:37Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,207 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to create server start policy patch string\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Policy value \n+# $4 - Return value containing server start policy patch string\n+#\n+function createServerStartPolicyPatch {\n+  local domainJson=$1\n+  local serverName=$2\n+  local policy=$3\n+  local __result=$4\n+  local __currentPolicy=$5\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentServerStartPolicy=$(echo ${domainJson} | jq \"${extractPolicyCmd}\")\n+  fi\n+  if [ -z \"${currentServerStartPolicy}\" ]; then\n+    # Server start policy doesn't exist, add a new policy\n+    addPolicyCmd=\".[.| length] |= . + {\\\"serverName\\\":\\\"${serverName}\\\", \\\n+      \\\"serverStartPolicy\\\":\\\"${policy}\\\"}\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq .spec.managedServers | jq -c \"${addPolicyCmd}\")\n+  else\n+    # Server start policy exists, replace policy value \n+    replacePolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy) |= \\\"${policy}\\\"\"\n+    servers=\"(.spec.managedServers)\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\" | jq -cr \"${servers}\")\n+  fi\n+  eval $__result=\"'${serverStartPolicyPatch}'\"\n+  eval $__currentPolicy=${currentServerStartPolicy}\n+}\n+\n+#\n+# Function to create patch string for updating replica count\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster whose replica count will be patched\n+# $3 - operatation string indicating whether to increment or decrement count\n+# $4 - Return value containing replica update patch string\n+# $5 - Retrun value containing updated replica count\n+#\n+function createReplicaPatch {\n+local domainJson=$1\n+local clusterName=$2\n+local operation=$3\n+local __result=$4\n+local __relicaCount=$5\n+maxReplicas=\"\"\n+local errorMessage=\"@@ ERROR: Maximum number of servers allowed (maxReplica = ${maxReplicas}) \\\n+are already running. Please increase cluster size to start new servers.\"\n+\n+  replicasCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).replicas\"\n+  maxReplicaCmd=\"(.status.clusters[] | select (.clusterName == \\\"${clusterName}\\\")) \\\n+    | .maximumReplicas\"\n+  if [ \"${operation}\" == \"DECREMENT\" ]; then\n+    replica=$(($(echo ${domainJson} | jq \"${replicasCmd}\")-1))\n+    if [ ${replica} -lt 0 ]; then\n+      replica=0\n+    fi\n+  elif [ \"${operation}\" == \"INCREMENT\" ]; then\n+    replica=$(($(echo ${domainJson} | jq \"${replicasCmd}\")+1))\n+    maxReplicas=$(echo ${domainJson} | jq \"${maxReplicaCmd}\")\n+    if [ ${replica} -gt ${maxReplicas} ]; then\n+      echo \"${errorMessage}\"\n+      eval $__result=\"MAX_REPLICA_COUNT_EXCEEDED\"\n+      return\n+    fi\n+  fi\n+\n+  cmd=\"(.spec.clusters[] | select (.clusterName == \\\"${clusterName}\\\") \\\n+    | .replicas) |= ${replica}\"\n+  replicaPatch=$(echo ${domainJson} | jq \"${cmd}\" | jq -cr '(.spec.clusters)')\n+  eval $__result=\"'${replicaPatch}'\"\n+  eval $__relicaCount=\"'${replica}'\"\n+}\n+\n+#\n+# Function to validate whether a server belongs to a  cluster or is an independent managed server\n+# $1 - Domain unique id.\n+# $2 - Domain namespace.\n+# $3 - Return value indicating if server is valid (i.e. if it's part of a cluster or independent server).\n+# $4 - Retrun value containting cluster name to which this server belongs.\n+#\n+function validateServerAndFindCluster {\n+local domainUid=$1\n+local domainNamespace=$2 \n+local __isValidServer=$3\n+local __clusterName=$4\n+local errorMessage=\"Server name is outside the range of allowed servers. \\\n+Please make sure server name is correct.\"\n+\n+  configMap=$(${kubernetesCli} get cm ${domainUid}-weblogic-domain-introspect-cm \\\n+    -n ${domainNamespace} -o json)\n+  topology=$(echo \"${configMap}\" | jq '.data[\"topology.yaml\"]')\n+  jsonTopology=$(python -c \\\n+    'import sys, yaml, json; print json.dumps(yaml.safe_load('\"${topology}\"'), indent=4)')\n+  servers=($(echo $jsonTopology | jq -r '.domain.servers[].name'))\n+  if  checkStringInArray \"${serverName}\" \"${servers[@]}\" ; then", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2927762ee4a04cfd8747c2ac6df56200dbf7e991"}, "originalPosition": 109}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1ODE1Nzg3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-515815787", "createdAt": "2020-10-23T16:14:47Z", "commit": {"oid": "2927762ee4a04cfd8747c2ac6df56200dbf7e991"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxNDo0N1rOHnUktQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxNDo0N1rOHnUktQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5MzU4OQ==", "bodyText": "it's --> its", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r510993589", "createdAt": "2020-10-23T16:14:47Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startCluster.sh", "diffHunk": "@@ -0,0 +1,100 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script starts a WebLogic cluster in a domain by patching it's", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2927762ee4a04cfd8747c2ac6df56200dbf7e991"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1ODE3MTIw", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-515817120", "createdAt": "2020-10-23T16:16:37Z", "commit": {"oid": "2927762ee4a04cfd8747c2ac6df56200dbf7e991"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxNjozN1rOHnUo-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxNjozN1rOHnUo-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NDY4Mg==", "bodyText": "consider updating the 'serverStartPolicy' reference here (and in similar usage doc) so that its fully qualifie.  'spec.xxx.SERVER-NAME.xxx.serverStartPolicy'...", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r510994682", "createdAt": "2020-10-23T16:16:37Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startCluster.sh", "diffHunk": "@@ -0,0 +1,100 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script starts a WebLogic cluster in a domain by patching it's\n+  'serverStartPolicy' field to 'IF_NEEDED'. This change will cause the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2927762ee4a04cfd8747c2ac6df56200dbf7e991"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1ODE5OTk1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-515819995", "createdAt": "2020-10-23T16:20:32Z", "commit": {"oid": "2927762ee4a04cfd8747c2ac6df56200dbf7e991"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoyMDozMlrOHnUxzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoyMDozMlrOHnUxzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5Njk0Mw==", "bodyText": "Are clearly understandable errors generated when referencing an invalid domain-uid, a domain that does not have a corresponding introspector cm (e.g. hasn't been deployed succesfully), invalid cluster name, or invalid managed server name?   If not, then I think additional validation would be helpful.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r510996943", "createdAt": "2020-10-23T16:20:32Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startCluster.sh", "diffHunk": "@@ -0,0 +1,100 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script starts a WebLogic cluster in a domain by patching it's\n+  'serverStartPolicy' field to 'IF_NEEDED'. This change will cause the\n+  operator to initiate startup of cluster's WebLogic server instance pods\n+  if the pods are not already running.\n+ \n+  Usage:\n+ \n+    $(basename $0) -c mycluster [-n mynamespace] [-d mydomainuid] [-m kubecli]\n+  \n+    -c <cluster>        : Cluster name parameter is required.\n+\n+    -d <domain_uid>     : Domain unique-id. Default is 'sample-domain1'.\n+\n+    -n <namespace>      : Domain namespace. Default is 'sample-domain1-ns'.\n+\n+    -m <kubernetes_cli> : Kubernetes command line interface. Default is 'kubectl'.\n+\n+    -h                  : This help.\n+   \n+EOF\n+exit $1\n+}\n+\n+set -eu\n+\n+kubernetesCli=${KUBERNETES_CLI:-kubectl}\n+clusterName=\"\"\n+domainUid=\"sample-domain1\"\n+domainNamespace=\"sample-domain1-ns\"\n+\n+while getopts \"c:n:m:d:h\" opt; do\n+  case $opt in\n+    c) clusterName=\"${OPTARG}\"\n+    ;;\n+    n) domainNamespace=\"${OPTARG}\"\n+    ;;\n+    d) domainUid=\"${OPTARG}\"\n+    ;;\n+    m) kubernetesCli=\"${OPTARG}\"\n+    ;;\n+    h) usage 0\n+    ;;\n+    *) usage 1\n+    ;;\n+  esac\n+done\n+\n+#\n+# Function to perform validations, read files and initialize workspace\n+#\n+function initialize {\n+\n+  # Validate the required files exist\n+  validateErrors=false\n+\n+  validateKubernetesCliAvailable\n+  validateJqAvailable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2927762ee4a04cfd8747c2ac6df56200dbf7e991"}, "originalPosition": 70}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01e630767ff07db1d11fa96ea6eeef74524ea8e1", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/01e630767ff07db1d11fa96ea6eeef74524ea8e1", "committedDate": "2020-10-23T18:47:46Z", "message": "Documentation changes based on PR review comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1OTMzNTc2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-515933576", "createdAt": "2020-10-23T19:02:16Z", "commit": {"oid": "01e630767ff07db1d11fa96ea6eeef74524ea8e1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxOTowMjoxNlrOHnaSIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxOTowMjoxNlrOHnaSIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA4NzEzOQ==", "bodyText": "Please fully qualify the replica count attribute (just like you did for the serverStartPolicy attribute).", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r511087139", "createdAt": "2020-10-23T19:02:16Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/README.md", "diffHunk": "@@ -0,0 +1,65 @@\n+### Domain lifecycle sample scripts\n+The WebLogic Server Kubernetes Operator project provides a set of sample scripts to shut-down or start-up a specific managed-server or cluster in a deployed Domain or the entire deployed Domain. Please note that Domain must have been created and deployed before these scripts can start or stop managed servers, clusters or the Domain. These can be helpful when scripting the lifecycle of a WebLogic Server Domain. Please see [Domain Life Cycle](https://oracle.github.io/weblogic-kubernetes-operator/userguide/managing-domains/domain-lifecycle) to learn how to start, stop, restart, and scale the WebLogic Server instances in your Domain.\n+\n+#### Scripts to start and stop a managed server\n+The `startServer.sh` script starts a managed server by patching 'spec.managedServers.<server-name>.serverStartPolicy' attribute of the domain resource to `ALWAYS`. It also increases the replica count value for the managed server's cluster by `1`. The script provides an option to keep the replica count value constant. Please see script `usage` information using `-h` option.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01e630767ff07db1d11fa96ea6eeef74524ea8e1"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1OTM0NTYx", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-515934561", "createdAt": "2020-10-23T19:03:57Z", "commit": {"oid": "01e630767ff07db1d11fa96ea6eeef74524ea8e1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxOTowMzo1N1rOHnaU4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxOTowMzo1N1rOHnaU4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA4Nzg0MQ==", "bodyText": "Please fully qualify the cluster attribute location, juste like you did above for the managed server case, plus the replica count location.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r511087841", "createdAt": "2020-10-23T19:03:57Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/README.md", "diffHunk": "@@ -0,0 +1,65 @@\n+### Domain lifecycle sample scripts\n+The WebLogic Server Kubernetes Operator project provides a set of sample scripts to shut-down or start-up a specific managed-server or cluster in a deployed Domain or the entire deployed Domain. Please note that Domain must have been created and deployed before these scripts can start or stop managed servers, clusters or the Domain. These can be helpful when scripting the lifecycle of a WebLogic Server Domain. Please see [Domain Life Cycle](https://oracle.github.io/weblogic-kubernetes-operator/userguide/managing-domains/domain-lifecycle) to learn how to start, stop, restart, and scale the WebLogic Server instances in your Domain.\n+\n+#### Scripts to start and stop a managed server\n+The `startServer.sh` script starts a managed server by patching 'spec.managedServers.<server-name>.serverStartPolicy' attribute of the domain resource to `ALWAYS`. It also increases the replica count value for the managed server's cluster by `1`. The script provides an option to keep the replica count value constant. Please see script `usage` information using `-h` option.\n+```\n+$ startServer.sh -d domain1 -n weblogic-domain-1 -s managed-server1\n+[INFO] Patching start policy of server 'managed-server1' from 'NEVER' to 'ALWAYS' and incrementing replica count for cluster 'cluster-1'.\n+domain.weblogic.oracle/domain1 patched\n+[INFO] Successfully patched server 'managed-server1' with 'ALWAYS' start policy!\n+\n+       The replica count for cluster 'cluster-1' updated to 1.\n+```\n+\n+The `stopServer.sh` script shuts down a running managed server by patching 'spec.managedServers.<server-name>.serverStartPolicy' attribute of the domain resource to `NEVER`. It also decreases the replica count for the managed server's cluster by `1`. The script provides an option to keep the replica count value constant. Please see script `usage` information using `-h` option.\n+```\n+$ stopServer.sh -d domain1 -n weblogic-domain-1 -s managed-server1\n+[INFO] Patching start policy of server 'managed-server1' from 'ALWAYS' to 'NEVER' and decrementing replica count for cluster 'cluster-1'.\n+domain.weblogic.oracle/domain1 patched\n+[INFO] Successfully patched server 'managed-server1' with 'NEVER' start policy!\n+\n+       The replica count for cluster 'cluster-1' updated to 0.\n+```\n+\n+#### Script behavior when starting or stopping a clustered managed server\n+Below table shows the new values of 'serverStartPolicy' attribute and replica count as updated by the server start and stop scripts.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01e630767ff07db1d11fa96ea6eeef74524ea8e1"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1OTM1MTQ2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-515935146", "createdAt": "2020-10-23T19:04:55Z", "commit": {"oid": "01e630767ff07db1d11fa96ea6eeef74524ea8e1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxOTowNDo1NVrOHnaWqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxOTowNDo1NVrOHnaWqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA4ODI5OA==", "bodyText": "Fully qualify replica count.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r511088298", "createdAt": "2020-10-23T19:04:55Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/README.md", "diffHunk": "@@ -0,0 +1,65 @@\n+### Domain lifecycle sample scripts\n+The WebLogic Server Kubernetes Operator project provides a set of sample scripts to shut-down or start-up a specific managed-server or cluster in a deployed Domain or the entire deployed Domain. Please note that Domain must have been created and deployed before these scripts can start or stop managed servers, clusters or the Domain. These can be helpful when scripting the lifecycle of a WebLogic Server Domain. Please see [Domain Life Cycle](https://oracle.github.io/weblogic-kubernetes-operator/userguide/managing-domains/domain-lifecycle) to learn how to start, stop, restart, and scale the WebLogic Server instances in your Domain.\n+\n+#### Scripts to start and stop a managed server\n+The `startServer.sh` script starts a managed server by patching 'spec.managedServers.<server-name>.serverStartPolicy' attribute of the domain resource to `ALWAYS`. It also increases the replica count value for the managed server's cluster by `1`. The script provides an option to keep the replica count value constant. Please see script `usage` information using `-h` option.\n+```\n+$ startServer.sh -d domain1 -n weblogic-domain-1 -s managed-server1\n+[INFO] Patching start policy of server 'managed-server1' from 'NEVER' to 'ALWAYS' and incrementing replica count for cluster 'cluster-1'.\n+domain.weblogic.oracle/domain1 patched\n+[INFO] Successfully patched server 'managed-server1' with 'ALWAYS' start policy!\n+\n+       The replica count for cluster 'cluster-1' updated to 1.\n+```\n+\n+The `stopServer.sh` script shuts down a running managed server by patching 'spec.managedServers.<server-name>.serverStartPolicy' attribute of the domain resource to `NEVER`. It also decreases the replica count for the managed server's cluster by `1`. The script provides an option to keep the replica count value constant. Please see script `usage` information using `-h` option.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01e630767ff07db1d11fa96ea6eeef74524ea8e1"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1OTM1OTM1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-515935935", "createdAt": "2020-10-23T19:06:21Z", "commit": {"oid": "01e630767ff07db1d11fa96ea6eeef74524ea8e1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxOTowNjoyMVrOHnaZPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxOTowNjoyMVrOHnaZPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA4ODk1Ng==", "bodyText": "Fully qualify the start policy & replica count.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r511088956", "createdAt": "2020-10-23T19:06:21Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startServer.sh", "diffHunk": "@@ -0,0 +1,144 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+if [ \"${debug}\" == \"true\" ]; then set -x; fi;\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script starts a WebLogic managed server in a domain by patching\n+  it's 'serverStartPolicy' field to 'ALWAYS'. It also increases the replica\n+  count value for the managed server's cluster by '1'.  The replica count\n+  value can be kept constant by using '-k' option. If the server pod is\n+  already running, script exits without updating 'serverStartPolicy' or", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01e630767ff07db1d11fa96ea6eeef74524ea8e1"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1OTM2MzEy", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-515936312", "createdAt": "2020-10-23T19:06:55Z", "commit": {"oid": "01e630767ff07db1d11fa96ea6eeef74524ea8e1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxOTowNjo1NVrOHnaaUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxOTowNjo1NVrOHnaaUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA4OTIzMg==", "bodyText": "Fully qulify the start policy.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r511089232", "createdAt": "2020-10-23T19:06:55Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/stopCluster.sh", "diffHunk": "@@ -0,0 +1,100 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script stops a WebLogic cluster in a domain by patching\n+  it's 'serverStartPolicy' field to 'NEVER'. This change will cause\n+  the operator to initiate shutdown of cluster's WebLogic server instance \n+  pods if the pods are running.\n+ ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01e630767ff07db1d11fa96ea6eeef74524ea8e1"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1OTM3MDU1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-515937055", "createdAt": "2020-10-23T19:08:18Z", "commit": {"oid": "01e630767ff07db1d11fa96ea6eeef74524ea8e1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxOTowODoxOFrOHnadRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxOTowODoxOFrOHnadRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA4OTk5MQ==", "bodyText": "Fully qualify start policy & replica count.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r511089991", "createdAt": "2020-10-23T19:08:18Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/stopServer.sh", "diffHunk": "@@ -0,0 +1,121 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+if [ \"${debug}\" == \"true\" ]; then set -x; fi;\n+set -eu\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script stops a running WebLogic managed server in a domain by\n+  patching it's 'serverStartPolicy' field to 'NEVER'. It also decreases\n+  the replica count value for the managed server's cluster by '1'. The\n+  replica count value can be kept constant by using '-k' option. If the\n+  server pod is not running, script exits without updating 'serverStartPolicy'\n+  or replica count value.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01e630767ff07db1d11fa96ea6eeef74524ea8e1"}, "originalPosition": 21}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4eba0729462b6caff0e89559a453d4bceee2e94a", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/4eba0729462b6caff0e89559a453d4bceee2e94a", "committedDate": "2020-10-23T19:22:16Z", "message": "Fully qualified replica value as per review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eadad48da542495358be1733fd413650c888bdd0", "author": {"user": {"login": "rosemarymarano", "name": "Rosemary Marano"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/eadad48da542495358be1733fd413650c888bdd0", "committedDate": "2020-10-23T20:21:50Z", "message": "edit docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5845883cfa6f8086904ab24a5c4b5d8a68ecd416", "author": {"user": {"login": "rosemarymarano", "name": "Rosemary Marano"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5845883cfa6f8086904ab24a5c4b5d8a68ecd416", "committedDate": "2020-10-23T20:25:15Z", "message": "edit README"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1fda64add638aedfbbf5a6530ae23ae18de1ca9b", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/1fda64add638aedfbbf5a6530ae23ae18de1ca9b", "committedDate": "2020-10-23T20:54:22Z", "message": "Address PR review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MDEyOTEz", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-516012913", "createdAt": "2020-10-23T21:11:38Z", "commit": {"oid": "1fda64add638aedfbbf5a6530ae23ae18de1ca9b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMToxMTozOFrOHnekUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMToxMTozOFrOHnekUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1NzMyOA==", "bodyText": "Small point... These JSONPath samples are not correct because the managedServers and clusters elements are lists rather than maps. You might use something like spec.managedServers[?(serverName=\"<server-name>\")].serverStartPolicy or spc.clusters[?(clusterName=\"<cluster-name>\")].replicas", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r511157328", "createdAt": "2020-10-23T21:11:38Z", "author": {"login": "rjeberhard"}, "path": "kubernetes/samples/scripts/domain-lifecycle/README.md", "diffHunk": "@@ -0,0 +1,74 @@\n+### Domain lifecycle sample scripts\n+\n+The operator provides sample scripts to start up or shut down a specific Managed Server or cluster in a deployed domain, or the entire deployed domain.\n+\n+**Note**: Prior to running these scripts, you must have previously created and deployed the domain.\n+\n+These scripts can be helpful when scripting the life cycle of a WebLogic Server domain. For information on how to start, stop, restart, and scale WebLogic Server instances in your domain, see [Domain Life Cycle](https://oracle.github.io/weblogic-kubernetes-operator/userguide/managing-domains/domain-lifecycle).\n+\n+#### Scripts to start and stop a Managed Server\n+The `startServer.sh` script starts a Managed Server by patching the `spec.managedServers.<server-name>.serverStartPolicy` attribute of the domain resource to `ALWAYS`. For clustered servers, it also increases the `spec.clusters.<cluster-name>.replicas` value for the Managed Server's cluster by `1`. The script provides an option to keep the `spec.clusters.<cluster-name>.replicas` value constant for clustered servers. See the script `usage` information by using the `-h` option.\n+\n+```\n+$ startServer.sh -d domain1 -n weblogic-domain-1 -s managed-server1\n+[INFO] Patching start policy of server 'managed-server1' from 'NEVER' to 'ALWAYS' and incrementing replica count for cluster 'cluster-1'.\n+domain.weblogic.oracle/domain1 patched\n+[INFO] Successfully patched server 'managed-server1' with 'ALWAYS' start policy!\n+\n+       The replica count for cluster 'cluster-1' updated to 1.\n+```\n+\n+The `stopServer.sh` script shuts down a running Managed Server by patching the  `spec.managedServers.<server-name>.serverStartPolicy` attribute of the domain resource to `NEVER`. For clustered servers, it also decreases the `spec.clusters.<cluster-name>.replicas` for the Managed Server's cluster by `1`. The script provides an option to keep the `spec.clusters.<cluster-name>.replicas` value constant for clustered servers. See the script `usage` information by using the `-h` option.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fda64add638aedfbbf5a6530ae23ae18de1ca9b"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MDEzMjI3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-516013227", "createdAt": "2020-10-23T21:12:22Z", "commit": {"oid": "1fda64add638aedfbbf5a6530ae23ae18de1ca9b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMToxMjoyMlrOHnelMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMToxMjoyMlrOHnelMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1NzU1NQ==", "bodyText": "Same comment here", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r511157555", "createdAt": "2020-10-23T21:12:22Z", "author": {"login": "rjeberhard"}, "path": "kubernetes/samples/scripts/domain-lifecycle/README.md", "diffHunk": "@@ -0,0 +1,74 @@\n+### Domain lifecycle sample scripts\n+\n+The operator provides sample scripts to start up or shut down a specific Managed Server or cluster in a deployed domain, or the entire deployed domain.\n+\n+**Note**: Prior to running these scripts, you must have previously created and deployed the domain.\n+\n+These scripts can be helpful when scripting the life cycle of a WebLogic Server domain. For information on how to start, stop, restart, and scale WebLogic Server instances in your domain, see [Domain Life Cycle](https://oracle.github.io/weblogic-kubernetes-operator/userguide/managing-domains/domain-lifecycle).\n+\n+#### Scripts to start and stop a Managed Server\n+The `startServer.sh` script starts a Managed Server by patching the `spec.managedServers.<server-name>.serverStartPolicy` attribute of the domain resource to `ALWAYS`. For clustered servers, it also increases the `spec.clusters.<cluster-name>.replicas` value for the Managed Server's cluster by `1`. The script provides an option to keep the `spec.clusters.<cluster-name>.replicas` value constant for clustered servers. See the script `usage` information by using the `-h` option.\n+\n+```\n+$ startServer.sh -d domain1 -n weblogic-domain-1 -s managed-server1\n+[INFO] Patching start policy of server 'managed-server1' from 'NEVER' to 'ALWAYS' and incrementing replica count for cluster 'cluster-1'.\n+domain.weblogic.oracle/domain1 patched\n+[INFO] Successfully patched server 'managed-server1' with 'ALWAYS' start policy!\n+\n+       The replica count for cluster 'cluster-1' updated to 1.\n+```\n+\n+The `stopServer.sh` script shuts down a running Managed Server by patching the  `spec.managedServers.<server-name>.serverStartPolicy` attribute of the domain resource to `NEVER`. For clustered servers, it also decreases the `spec.clusters.<cluster-name>.replicas` for the Managed Server's cluster by `1`. The script provides an option to keep the `spec.clusters.<cluster-name>.replicas` value constant for clustered servers. See the script `usage` information by using the `-h` option.\n+\n+```\n+$ stopServer.sh -d domain1 -n weblogic-domain-1 -s managed-server1\n+[INFO] Patching start policy of server 'managed-server1' from 'ALWAYS' to 'NEVER' and decrementing replica count for cluster 'cluster-1'.\n+domain.weblogic.oracle/domain1 patched\n+[INFO] Successfully patched server 'managed-server1' with 'NEVER' start policy!\n+\n+       The replica count for cluster 'cluster-1' updated to 0.\n+```\n+\n+#### Script behavior when starting or stopping a clustered Managed Server\n+The following table shows the new values of `spec.managedServers.<server-name>.serverStartPolicy` and `spec.clusters.<cluster-name>.replicas` as updated by the server start and stop scripts.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fda64add638aedfbbf5a6530ae23ae18de1ca9b"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MDM5MTM2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-516039136", "createdAt": "2020-10-23T22:16:40Z", "commit": {"oid": "1fda64add638aedfbbf5a6530ae23ae18de1ca9b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMjoxNjo0MFrOHnf3jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMjoxNjo0MFrOHnf3jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3ODYzOA==", "bodyText": "Minor comment: the 'locals' should be indented two spaces just as has been already been done for the previous function. Ditto for the following functions.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r511178638", "createdAt": "2020-10-23T22:16:40Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,237 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to create server start policy patch string\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Policy value \n+# $4 - Return value containing server start policy patch string\n+#\n+function createServerStartPolicyPatch {\n+  local domainJson=$1\n+  local serverName=$2\n+  local policy=$3\n+  local __result=$4\n+  local __currentPolicy=$5\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentServerStartPolicy=$(echo ${domainJson} | jq \"${extractPolicyCmd}\")\n+  fi\n+  if [ -z \"${currentServerStartPolicy}\" ]; then\n+    # Server start policy doesn't exist, add a new policy\n+    addPolicyCmd=\".[.| length] |= . + {\\\"serverName\\\":\\\"${serverName}\\\", \\\n+      \\\"serverStartPolicy\\\":\\\"${policy}\\\"}\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq .spec.managedServers | jq -c \"${addPolicyCmd}\")\n+  else\n+    # Server start policy exists, replace policy value \n+    replacePolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy) |= \\\"${policy}\\\"\"\n+    servers=\"(.spec.managedServers)\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\" | jq -cr \"${servers}\")\n+  fi\n+  eval $__result=\"'${serverStartPolicyPatch}'\"\n+  eval $__currentPolicy=${currentServerStartPolicy}\n+}\n+\n+#\n+# Function to create patch string for updating replica count\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster whose replica count will be patched\n+# $3 - operatation string indicating whether to increment or decrement count\n+# $4 - Return value containing replica update patch string\n+# $5 - Retrun value containing updated replica count\n+#\n+function createReplicaPatch {\n+local domainJson=$1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fda64add638aedfbbf5a6530ae23ae18de1ca9b"}, "originalPosition": 53}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71922ebc0d6a3c6ce3dbdcf81ecd9c67a5aa336d", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/71922ebc0d6a3c6ce3dbdcf81ecd9c67a5aa336d", "committedDate": "2020-10-23T22:23:24Z", "message": "Changes to address PR review comments and removed ItLifecycleSampleScripts class by adding methods in ItSamples"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d66c1a8d25cdaf276753334ece524002f96cdf08", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d66c1a8d25cdaf276753334ece524002f96cdf08", "committedDate": "2020-10-23T22:29:51Z", "message": "fix indentation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MDQ0MjA2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-516044206", "createdAt": "2020-10-23T22:32:29Z", "commit": {"oid": "d66c1a8d25cdaf276753334ece524002f96cdf08"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMjozMjoyOVrOHngIPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMjozMjoyOVrOHngIPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE4MjkxMA==", "bodyText": "Minor point: Looks like there's now a $5 - if you have the time, please make sure your function comments are up to date.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r511182910", "createdAt": "2020-10-23T22:32:29Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,237 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to create server start policy patch string\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Policy value \n+# $4 - Return value containing server start policy patch string\n+#", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d66c1a8d25cdaf276753334ece524002f96cdf08"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MDQ0NjU2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-516044656", "createdAt": "2020-10-23T22:33:45Z", "commit": {"oid": "d66c1a8d25cdaf276753334ece524002f96cdf08"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMjozMzo0NlrOHngJwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMjozMzo0NlrOHngJwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE4MzI5Ng==", "bodyText": "Minor comment: mispelling. relica --> replica", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r511183296", "createdAt": "2020-10-23T22:33:46Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,237 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to create server start policy patch string\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Policy value \n+# $4 - Return value containing server start policy patch string\n+#\n+function createServerStartPolicyPatch {\n+  local domainJson=$1\n+  local serverName=$2\n+  local policy=$3\n+  local __result=$4\n+  local __currentPolicy=$5\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentServerStartPolicy=$(echo ${domainJson} | jq \"${extractPolicyCmd}\")\n+  fi\n+  if [ -z \"${currentServerStartPolicy}\" ]; then\n+    # Server start policy doesn't exist, add a new policy\n+    addPolicyCmd=\".[.| length] |= . + {\\\"serverName\\\":\\\"${serverName}\\\", \\\n+      \\\"serverStartPolicy\\\":\\\"${policy}\\\"}\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq .spec.managedServers | jq -c \"${addPolicyCmd}\")\n+  else\n+    # Server start policy exists, replace policy value \n+    replacePolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy) |= \\\"${policy}\\\"\"\n+    servers=\"(.spec.managedServers)\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\" | jq -cr \"${servers}\")\n+  fi\n+  eval $__result=\"'${serverStartPolicyPatch}'\"\n+  eval $__currentPolicy=${currentServerStartPolicy}\n+}\n+\n+#\n+# Function to create patch string for updating replica count\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster whose replica count will be patched\n+# $3 - operatation string indicating whether to increment or decrement count\n+# $4 - Return value containing replica update patch string\n+# $5 - Retrun value containing updated replica count\n+#\n+function createReplicaPatch {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local operation=$3\n+  local __result=$4\n+  local __relicaCount=$5", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d66c1a8d25cdaf276753334ece524002f96cdf08"}, "originalPosition": 57}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05c5a3f80408f65b3b6f9fdad445e81e01ea4266", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/05c5a3f80408f65b3b6f9fdad445e81e01ea4266", "committedDate": "2020-10-23T22:36:22Z", "message": "fix comment and typo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MDQ4NjMx", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-516048631", "createdAt": "2020-10-23T22:47:43Z", "commit": {"oid": "d66c1a8d25cdaf276753334ece524002f96cdf08"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMjo0Nzo0M1rOHngX8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMjo0Nzo0M1rOHngX8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE4NjkzMQ==", "bodyText": "General comment:  Sorry for not noticing this earlier, but if I understand the code correctly, none of the scripts detect when a start policy already matches the target policy.  In that case, the scripts should exit early without doing anything and should print a helpful info message to let the user know. (And they definitely  shouldn't adjust replica count).", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r511186931", "createdAt": "2020-10-23T22:47:43Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/stopServer.sh", "diffHunk": "@@ -0,0 +1,120 @@\n+# !/bin/sh", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d66c1a8d25cdaf276753334ece524002f96cdf08"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ba9537453fffa37b1890fcbff8a9a165edc62ce", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/0ba9537453fffa37b1890fcbff8a9a165edc62ce", "committedDate": "2020-10-24T00:30:29Z", "message": "Added validation as per review comment."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2Mjg0NzM0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-516284734", "createdAt": "2020-10-24T15:13:34Z", "commit": {"oid": "0ba9537453fffa37b1890fcbff8a9a165edc62ce"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNToxMzozNFrOHnyY-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNToxMzozNFrOHnyY-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ4MjEwNA==", "bodyText": "I think the check to see if the server pod is up ^^^ might be misleading - the existence/non-existence of a server pod does not always correctly reflect it's current server-start-policy.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r511482104", "createdAt": "2020-10-24T15:13:34Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startServer.sh", "diffHunk": "@@ -0,0 +1,143 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+if [ \"${debug}\" == \"true\" ]; then set -x; fi;\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script starts a WebLogic managed server in a domain by patching\n+  'spec.managedServers[<server-name>].serverStartPolicy' attribute of the domain\n+  resource to 'ALWAYS'. It also increases the 'spec.clusters[<cluster-name>].replicas'\n+  value for the managed server's cluster by '1'.  The 'spec.clusters[<cluster-name>].replicas'\n+  value can be kept constant by using '-k' option.\n+ \n+  Usage:\n+ \n+    $(basename $0) -s myserver [-n mynamespace] [-d mydomainuid] [-k] {-m kubecli]\n+  \n+    -s <server_name>           : Server name parameter is required.\n+\n+    -d <domain_uid>            : Domain unique-id. Default is 'sample-domain1'.\n+\n+    -n <namespace>             : Domain namespace. Default is 'sample-domain1-ns'.\n+\n+    -k <keep_replica_constant> : Keep replica count constant. Default behavior is to increment replica count.\n+\n+    -m <kubernetes_cli>        : Kubernetes command line interface. Default is 'kubectl'.\n+\n+    -h                         : This help.\n+   \n+EOF\n+exit $1\n+}\n+\n+kubernetesCli=${KUBERNETES_CLI:-kubectl}\n+serverName=\"\"\n+clusterName=\"\"\n+domainUid=\"sample-domain1\"\n+domainNamespace=\"sample-domain1-ns\"\n+keepReplicaConstant=false\n+\n+while getopts \"kd:n:m:s:h\" opt; do\n+  case $opt in\n+    s) serverName=\"${OPTARG}\"\n+    ;;\n+    n) domainNamespace=\"${OPTARG}\"\n+    ;;\n+    d) domainUid=\"${OPTARG}\"\n+    ;;\n+    k) keepReplicaConstant=true;\n+    ;;\n+    m) kubernetesCli=\"${OPTARG}\"\n+    ;;\n+    h) usage 0\n+    ;;\n+    *) usage 1\n+    ;;\n+  esac\n+done\n+\n+#\n+# Function to perform validations, read files and initialize workspace\n+#\n+function initialize {\n+\n+  # Validate the required files exist\n+  validateErrors=false\n+\n+  validateKubernetesCliAvailable\n+  validateJqAvailable\n+\n+  # Validate that server name parameter is specified.\n+  if [ -z \"${serverName}\" ]; then\n+    validationError \"Please specify a server name using '-s' parameter e.g. '-s managed-server1'.\"\n+  fi\n+\n+  failIfValidationErrors\n+}\n+\n+initialize\n+\n+# Get the domain in json format\n+domainJson=$(${kubernetesCli} get domain ${domainUid} -n ${domainNamespace} -o json)\n+if [ $? -ne 0 ]; then\n+  echo \"[ERROR} Unable to get domain resource. Please make sure 'domain_uid' and 'namespace' provided with '-d' and '-n' arguments are correct.\"\n+  exit 1\n+fi\n+\n+# check if server pod is already running\n+${kubernetesCli} get pod ${domainUid}-${serverName} -n ${domainNamespace} > /dev/null 2>&1\n+if [ $? -eq 0 ]; then\n+  echo \"Server pod ${domainUid}-${serverName} already exists. Exiting.\"\n+  exit 1\n+fi\n+\n+# Validate that specified server is either part of a cluster or is an independent managed server\n+validateServerAndFindCluster \"${domainUid}\" \"${domainNamespace}\" isValidServer clusterName\n+if [ \"${isValidServer}\" != 'true' ]; then\n+  printError \"Server ${serverName} is not part of any cluster and it's not an independent managed server. Please make sure that server name specified is correct.\"\n+  exit 1\n+fi\n+\n+# Create server start policy patch with ALWAYS value\n+currentPolicy=\"\"\n+serverStartPolicy=ALWAYS\n+createServerStartPolicyPatch \"${domainJson}\" \"${serverName}\" \"${serverStartPolicy}\" serverStartPolicyPatch currentPolicy", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ba9537453fffa37b1890fcbff8a9a165edc62ce"}, "originalPosition": 112}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2Mjg1NDIw", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-516285420", "createdAt": "2020-10-24T15:23:16Z", "commit": {"oid": "0ba9537453fffa37b1890fcbff8a9a165edc62ce"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNToyMzoxNlrOHnyeCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNToyMzoxNlrOHnyeCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ4MzQwMA==", "bodyText": "Minor point:  Among these var declarations, it looks like all but 'serverName' are used as local variables and are not directly accessed by the helper functions (I realize you can't mark them local since this is the global scope).  To make the code a little more readable, it'd be nice to treat serverName similarly - pass it in to the helper function instead of implicitly expecting it to be global...", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r511483400", "createdAt": "2020-10-24T15:23:16Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startServer.sh", "diffHunk": "@@ -0,0 +1,143 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+if [ \"${debug}\" == \"true\" ]; then set -x; fi;\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script starts a WebLogic managed server in a domain by patching\n+  'spec.managedServers[<server-name>].serverStartPolicy' attribute of the domain\n+  resource to 'ALWAYS'. It also increases the 'spec.clusters[<cluster-name>].replicas'\n+  value for the managed server's cluster by '1'.  The 'spec.clusters[<cluster-name>].replicas'\n+  value can be kept constant by using '-k' option.\n+ \n+  Usage:\n+ \n+    $(basename $0) -s myserver [-n mynamespace] [-d mydomainuid] [-k] {-m kubecli]\n+  \n+    -s <server_name>           : Server name parameter is required.\n+\n+    -d <domain_uid>            : Domain unique-id. Default is 'sample-domain1'.\n+\n+    -n <namespace>             : Domain namespace. Default is 'sample-domain1-ns'.\n+\n+    -k <keep_replica_constant> : Keep replica count constant. Default behavior is to increment replica count.\n+\n+    -m <kubernetes_cli>        : Kubernetes command line interface. Default is 'kubectl'.\n+\n+    -h                         : This help.\n+   \n+EOF\n+exit $1\n+}\n+\n+kubernetesCli=${KUBERNETES_CLI:-kubectl}\n+serverName=\"\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ba9537453fffa37b1890fcbff8a9a165edc62ce"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2Mjg1NTkz", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-516285593", "createdAt": "2020-10-24T15:26:36Z", "commit": {"oid": "0ba9537453fffa37b1890fcbff8a9a165edc62ce"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNToyNjozNlrOHnyfKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNToyNjozNlrOHnyfKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ4MzY4OQ==", "bodyText": "Out of curiosity, can this ever happen? Or is it more in the nature of an assertion?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r511483689", "createdAt": "2020-10-24T15:26:36Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,238 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to create server start policy patch string\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Policy value \n+# $4 - Return value containing server start policy patch string\n+# $5 - Return value of current server start policy\n+#\n+function createServerStartPolicyPatch {\n+  local domainJson=$1\n+  local serverName=$2\n+  local policy=$3\n+  local __result=$4\n+  local __currentPolicy=$5\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentServerStartPolicy=$(echo ${domainJson} | jq \"${extractPolicyCmd}\")\n+  fi\n+  if [ -z \"${currentServerStartPolicy}\" ]; then\n+    # Server start policy doesn't exist, add a new policy\n+    addPolicyCmd=\".[.| length] |= . + {\\\"serverName\\\":\\\"${serverName}\\\", \\\n+      \\\"serverStartPolicy\\\":\\\"${policy}\\\"}\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq .spec.managedServers | jq -c \"${addPolicyCmd}\")\n+  else\n+    # Server start policy exists, replace policy value \n+    replacePolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy) |= \\\"${policy}\\\"\"\n+    servers=\"(.spec.managedServers)\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\" | jq -cr \"${servers}\")\n+  fi\n+  eval $__result=\"'${serverStartPolicyPatch}'\"\n+  eval $__currentPolicy=${currentServerStartPolicy}\n+}\n+\n+#\n+# Function to create patch string for updating replica count\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster whose replica count will be patched\n+# $3 - operatation string indicating whether to increment or decrement count\n+# $4 - Return value containing replica update patch string\n+# $5 - Retrun value containing updated replica count\n+#\n+function createReplicaPatch {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local operation=$3\n+  local __result=$4\n+  local __replicaCount=$5\n+  local maxReplicas=\"\"\n+  local errorMessage=\"@@ ERROR: Maximum number of servers allowed (maxReplica = ${maxReplicas}) \\\n+are already running. Please increase cluster size to start new servers.\"\n+\n+  replicasCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).replicas\"\n+  maxReplicaCmd=\"(.status.clusters[] | select (.clusterName == \\\"${clusterName}\\\")) \\\n+    | .maximumReplicas\"\n+  replica=$(echo ${domainJson} | jq \"${replicasCmd}\")\n+  if [[ -z \"${replica}\" || \"${replica}\" == \"null\" ]]; then\n+    replica=$(echo ${domainJson} | jq .spec.replicas)\n+  fi\n+  if [ \"${operation}\" == \"DECREMENT\" ]; then\n+    replica=$((replica-1))\n+    if [ ${replica} -lt 0 ]; then\n+      replica=0\n+    fi\n+  elif [ \"${operation}\" == \"INCREMENT\" ]; then\n+    replica=$((replica+1))\n+    maxReplicas=$(echo ${domainJson} | jq \"${maxReplicaCmd}\")\n+    if [ ${replica} -gt ${maxReplicas} ]; then\n+      echo \"${errorMessage}\"\n+      eval $__result=\"MAX_REPLICA_COUNT_EXCEEDED\"\n+      return\n+    fi\n+  fi\n+\n+  cmd=\"(.spec.clusters[] | select (.clusterName == \\\"${clusterName}\\\") \\\n+    | .replicas) |= ${replica}\"\n+  replicaPatch=$(echo ${domainJson} | jq \"${cmd}\" | jq -cr '(.spec.clusters)')\n+  eval $__result=\"'${replicaPatch}'\"\n+  eval $__replicaCount=\"'${replica}'\"\n+}\n+\n+#\n+# Function to validate whether a server belongs to a  cluster or is an independent managed server\n+# $1 - Domain unique id.\n+# $2 - Domain namespace.\n+# $3 - Return value indicating if server is valid (i.e. if it's part of a cluster or independent server).\n+# $4 - Retrun value containting cluster name to which this server belongs.\n+#\n+function validateServerAndFindCluster {\n+  local domainUid=$1\n+  local domainNamespace=$2 \n+  local __isValidServer=$3\n+  local __clusterName=$4\n+  local errorMessage=\"Server name is outside the range of allowed servers. \\\n+Please make sure server name is correct.\"\n+\n+  configMap=$(${kubernetesCli} get cm ${domainUid}-weblogic-domain-introspect-cm \\\n+    -n ${domainNamespace} -o json)\n+  topology=$(echo \"${configMap}\" | jq '.data[\"topology.yaml\"]')\n+  jsonTopology=$(python -c \\\n+    'import sys, yaml, json; print json.dumps(yaml.safe_load('\"${topology}\"'), indent=4)')\n+  servers=($(echo $jsonTopology | jq -r '.domain.servers[].name'))\n+  if  checkStringInArray \"${serverName}\" \"${servers[@]}\" ; then\n+    eval $__clusterName=\"\"\n+    eval $__isValidServer=true\n+  else\n+    dynamicClause=\".domain.configuredClusters[] | select (.dynamicServersConfig != null)\"\n+    namePrefixSize=\". | {name: .name, prefix:.dynamicServersConfig.serverNamePrefix, \\\n+                 max:.dynamicServersConfig.maxDynamicClusterSize}\"\n+    dynamicClusters=($(echo $jsonTopology | jq \"${dynamicClause}\" | jq -cr \"${namePrefixSize}\"))\n+    for dynaClusterNamePrefix in \"${dynamicClusters[@]}\"; do\n+      prefix=$(echo ${dynaClusterNamePrefix} | jq -r .prefix)\n+      if [[ \"${serverName}\" == \"${prefix}\"* ]]; then\n+        serverCount=$(echo \"${serverName: -1}\")\n+        maxSize=$(echo ${dynaClusterNamePrefix} | jq -r .max)\n+        if [ ${serverCount} -gt ${maxSize} ]; then\n+          printError \"${errorMessage}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ba9537453fffa37b1890fcbff8a9a165edc62ce"}, "originalPosition": 128}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ab8bd0e37a89d3856d3f58a075ff73bdb93ff7e", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/0ab8bd0e37a89d3856d3f58a075ff73bdb93ff7e", "committedDate": "2020-10-25T23:05:45Z", "message": "changes to address review comment and minor cleanup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2ODQ5OTQz", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-516849943", "createdAt": "2020-10-26T14:43:59Z", "commit": {"oid": "0ab8bd0e37a89d3856d3f58a075ff73bdb93ff7e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNDo0NDowMFrOHoS6Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNDo0NDowMFrOHoS6Iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxNDg4Mw==", "bodyText": "If the startPolicy is not set at all in either location, I think we can assume the value is IF_NEEDED.  (Please check if the other scripts also can helpfullly assume this defaulting...)", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r512014883", "createdAt": "2020-10-26T14:44:00Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startCluster.sh", "diffHunk": "@@ -91,9 +91,12 @@ domainJson=$(${kubernetesCli} get domain ${domainUid} -n ${domainNamespace} -o j\n \n # Get server start policy for this cluster\n startPolicy=$(echo ${domainJson} | jq -r '(.spec.clusters[] | select (.clusterName == \"'${clusterName}'\") | .serverStartPolicy)')\n+if [ \"${startPolicy}\" == \"null\" ]; then\n+  startPolicy=$(echo ${domainJson} | jq -r .spec.serverStartPolicy)\n+fi", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ab8bd0e37a89d3856d3f58a075ff73bdb93ff7e"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3950815b74a3e442198346cff88ea0103a2780ee", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3950815b74a3e442198346cff88ea0103a2780ee", "committedDate": "2020-10-26T16:30:05Z", "message": "PR review comment - changes to assume default policy is IF_NEEDED if policy is not set at domain level."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2859f0865a7a5ced929e3d6eb7d793fea231ee3f", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/2859f0865a7a5ced929e3d6eb7d793fea231ee3f", "committedDate": "2020-10-30T22:47:40Z", "message": "changes for new algorithm as documented on http://aseng-wiki.us.oracle.com/asengwiki/pages/viewpage.action?pageId=5280694898"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81e04869b8bb243f182ac6b22999043e465e210f", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/81e04869b8bb243f182ac6b22999043e465e210f", "committedDate": "2020-10-31T17:19:49Z", "message": "More changes for new algorithm."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6c287b5e4406c8bfb80275de446b340a9ec6ef7", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c6c287b5e4406c8bfb80275de446b340a9ec6ef7", "committedDate": "2020-11-01T17:42:32Z", "message": "code refactoring and minor doc update."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3456c6829e97258fb6099f0dfca2212bb5bc3d9f", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3456c6829e97258fb6099f0dfca2212bb5bc3d9f", "committedDate": "2020-11-02T05:05:34Z", "message": "Minor change for dynamic server name validation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODQwNDA1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-521840405", "createdAt": "2020-11-02T17:19:14Z", "commit": {"oid": "3456c6829e97258fb6099f0dfca2212bb5bc3d9f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNzoxOToxNFrOHsOLcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNzoxOToxNFrOHsOLcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjEzMTY5Ng==", "bodyText": "If you choose to update README.md to have significant additional details,  add a sentence like 'See README.md for additional details.'", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516131696", "createdAt": "2020-11-02T17:19:14Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startServer.sh", "diffHunk": "@@ -0,0 +1,225 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+if [ \"${debug}\" == \"true\" ]; then set -x; fi;\n+set -eu\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script starts a WebLogic managed server in a domain either by increasing\n+  the value of 'spec.clusters[<cluster-name>].replicas' by '1' or by updating the\n+  'spec.managedServers[<server-name>].serverStartPolicy' attribute of the domain\n+  resource or both as needed. The 'spec.clusters[<cluster-name>].replicas' value can\n+  be kept constant by using '-k' option.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3456c6829e97258fb6099f0dfca2212bb5bc3d9f"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODQxMTc1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-521841175", "createdAt": "2020-11-02T17:20:09Z", "commit": {"oid": "3456c6829e97258fb6099f0dfca2212bb5bc3d9f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNzoyMDowOVrOHsOOhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNzoyMDowOVrOHsOOhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjEzMjQ4NQ==", "bodyText": "This write-up is a little vague - I suspect we should provide a section labeled 'details' or even 'internals' with the exact detail about exactly when the script will choose simply to only alter the replica count, when it will set ALWAYS/NEVER, when it will do both, etc - otherwise we will get questions.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516132485", "createdAt": "2020-11-02T17:20:09Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/README.md", "diffHunk": "@@ -0,0 +1,76 @@\n+### Domain lifecycle sample scripts\n+\n+The operator provides sample scripts to start up or shut down a specific Managed Server or cluster in a deployed domain, or the entire deployed domain.\n+\n+**Note**: Prior to running these scripts, you must have previously created and deployed the domain.\n+\n+These scripts can be helpful when scripting the life cycle of a WebLogic Server domain. For information on how to start, stop, restart, and scale WebLogic Server instances in your domain, see [Domain Life Cycle](https://oracle.github.io/weblogic-kubernetes-operator/userguide/managing-domains/domain-lifecycle).\n+\n+#### Scripts to start and stop a Managed Server\n+The `startServer.sh` script starts a Managed Server either by increasing the `spec.clusters[<cluster-name>].replicas` value for the Managed Server's cluster by `1` or by updating the `spec.managedServers[<server-name>].serverStartPolicy` attribute of the domain resource or both as necessary. The script provides an option to keep the `spec.clusters[<cluster-name>].replicas` value constant for clustered servers. See the script `usage` information by using the `-h` option.\n+\n+Use the following command to start the server along with increased replica count:\n+```\n+$ startServer.sh -d domain1 -n weblogic-domain-1 -s managed-server1\n+[INFO] Updating replica count for cluster 'cluster-1' to 1.\n+domain.weblogic.oracle/domain1 patched\n+[INFO] Successfully updated replica count for cluster 'cluster-1' to 1.\n+```\n+\n+Use the following command to start the server without increasing replica count:\n+```\n+$ startServer.sh -d domain1 -n weblogic-domain-1 -s managed-server2 -k\n+[INFO] Patching start policy for 'managed-server2' to 'ALWAYS'.\n+domain.weblogic.oracle/domain1 patched\n+[INFO] Successfully patched server 'managed-server2' with 'ALWAYS' start policy.\n+```\n+\n+The `stopServer.sh` script shuts down a running Managed Server either by decreasing the `spec.clusters[<cluster-name>].replicas` value for the Managed Server's cluster by `1` or by patching the `spec.managedServers[<server-name>].serverStartPolicy` attribute of the domain resource or both as necessary. The script provides an option to keep the `spec.clusters[<cluster-name>].replicas` value constant for clustered servers. See the script `usage` information by using the `-h` option.\n+\n+Use the following command to stop the server along with decreased replica count:\n+```\n+$ stopServer.sh -d domain1 -n weblogic-domain-1 -s managed-server1\n+[INFO] Updating replica count for cluster cluster-1 to 0.\n+domain.weblogic.oracle/domain1 patched\n+[INFO] Successfully updated replica count for cluster 'cluster-1' to 0.\n+```\n+\n+Use the following command to stop the server without decreasing replica count:\n+```\n+$ stopServer.sh -d domain1 -n weblogic-domain-1 -s managed-server2 -k\n+[INFO] Unsetting the current start policy 'ALWAYS' for 'managed-server2'.\n+domain.weblogic.oracle/domain1 patched\n+[INFO] Successfully unset policy 'ALWAYS'.\n+```", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3456c6829e97258fb6099f0dfca2212bb5bc3d9f"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODU5Mzk2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-521859396", "createdAt": "2020-11-02T17:43:35Z", "commit": {"oid": "3456c6829e97258fb6099f0dfca2212bb5bc3d9f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNzo0MzozNlrOHsPN9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNzo0MzozNlrOHsPN9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE0ODcyNQ==", "bodyText": "spelling: Relicas", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516148725", "createdAt": "2020-11-02T17:43:36Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startServer.sh", "diffHunk": "@@ -0,0 +1,225 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+if [ \"${debug}\" == \"true\" ]; then set -x; fi;\n+set -eu\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script starts a WebLogic managed server in a domain either by increasing\n+  the value of 'spec.clusters[<cluster-name>].replicas' by '1' or by updating the\n+  'spec.managedServers[<server-name>].serverStartPolicy' attribute of the domain\n+  resource or both as needed. The 'spec.clusters[<cluster-name>].replicas' value can\n+  be kept constant by using '-k' option.\n+\n+  Usage:\n+\n+    $(basename $0) -s myserver [-n mynamespace] [-d mydomainuid] [-k] [-m kubecli] [-v]\n+\n+    -s <server_name>           : Server name parameter is required.\n+\n+    -d <domain_uid>            : Domain unique-id. Default is 'sample-domain1'.\n+\n+    -n <namespace>             : Domain namespace. Default is 'sample-domain1-ns'.\n+\n+    -k <keep_replica_constant> : Keep replica count constant. Default behavior is to increment replica count.\n+\n+    -m <kubernetes_cli>        : Kubernetes command line interface. Default is 'kubectl'.\n+\n+    -v <verbose_mode>          : Enables verbose mode. Default is 'false'.\n+\n+    -h                         : This help.\n+   \n+EOF\n+exit $1\n+}\n+\n+kubernetesCli=${KUBERNETES_CLI:-kubectl}\n+serverName=\"\"\n+clusterName=\"\"\n+domainUid=\"sample-domain1\"\n+domainNamespace=\"sample-domain1-ns\"\n+keepReplicaConstant=false\n+verboseMode=false\n+withRelicas=\"CONSTANT\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3456c6829e97258fb6099f0dfca2212bb5bc3d9f"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODYyNjky", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-521862692", "createdAt": "2020-11-02T17:47:58Z", "commit": {"oid": "3456c6829e97258fb6099f0dfca2212bb5bc3d9f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNzo0Nzo1OFrOHsPYcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNzo0Nzo1OFrOHsPYcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE1MTQwOA==", "bodyText": "Should this be exit 1?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516151408", "createdAt": "2020-11-02T17:47:58Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startServer.sh", "diffHunk": "@@ -0,0 +1,225 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+if [ \"${debug}\" == \"true\" ]; then set -x; fi;\n+set -eu\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script starts a WebLogic managed server in a domain either by increasing\n+  the value of 'spec.clusters[<cluster-name>].replicas' by '1' or by updating the\n+  'spec.managedServers[<server-name>].serverStartPolicy' attribute of the domain\n+  resource or both as needed. The 'spec.clusters[<cluster-name>].replicas' value can\n+  be kept constant by using '-k' option.\n+\n+  Usage:\n+\n+    $(basename $0) -s myserver [-n mynamespace] [-d mydomainuid] [-k] [-m kubecli] [-v]\n+\n+    -s <server_name>           : Server name parameter is required.\n+\n+    -d <domain_uid>            : Domain unique-id. Default is 'sample-domain1'.\n+\n+    -n <namespace>             : Domain namespace. Default is 'sample-domain1-ns'.\n+\n+    -k <keep_replica_constant> : Keep replica count constant. Default behavior is to increment replica count.\n+\n+    -m <kubernetes_cli>        : Kubernetes command line interface. Default is 'kubectl'.\n+\n+    -v <verbose_mode>          : Enables verbose mode. Default is 'false'.\n+\n+    -h                         : This help.\n+   \n+EOF\n+exit $1\n+}\n+\n+kubernetesCli=${KUBERNETES_CLI:-kubectl}\n+serverName=\"\"\n+clusterName=\"\"\n+domainUid=\"sample-domain1\"\n+domainNamespace=\"sample-domain1-ns\"\n+keepReplicaConstant=false\n+verboseMode=false\n+withRelicas=\"CONSTANT\"\n+withPolicy=\"CONSTANT\"\n+managedServerPolicy=\"\"\n+action=\"\"\n+isValidServer=\"\"\n+patchJson=\"\"\n+serverStarted=\"\"\n+startsByPolicyUnset=\"\"\n+startsByReplicaIncreaseAndPolicyUnset=\"\"\n+\n+while getopts \"vkd:n:m:s:h\" opt; do\n+  case $opt in\n+    s) serverName=\"${OPTARG}\"\n+    ;;\n+    n) domainNamespace=\"${OPTARG}\"\n+    ;;\n+    d) domainUid=\"${OPTARG}\"\n+    ;;\n+    k) keepReplicaConstant=true;\n+    ;;\n+    m) kubernetesCli=\"${OPTARG}\"\n+    ;;\n+    v) verboseMode=true;\n+    ;;\n+    h) usage 0\n+    ;;\n+    *) usage 1\n+    ;;\n+  esac\n+done\n+\n+#\n+# Function to perform validations, read files and initialize workspace\n+#\n+function initialize {\n+\n+  # Validate the required files exist\n+  validateErrors=false\n+\n+  validateKubernetesCliAvailable\n+  validateJqAvailable\n+\n+  # Validate that server name parameter is specified.\n+  if [ -z \"${serverName}\" ]; then\n+    validationError \"Please specify a server name using '-s' parameter e.g. '-s managed-server1'.\"\n+  fi\n+\n+  failIfValidationErrors\n+}\n+\n+initialize\n+\n+# Get the domain in json format\n+domainJson=$(${kubernetesCli} get domain ${domainUid} -n ${domainNamespace} -o json)\n+if [ $? -ne 0 ]; then\n+  echo \"[ERROR} Unable to get domain resource. Please make sure 'domain_uid' and 'namespace' provided with '-d' and '-n' arguments are correct.\"\n+  exit 1\n+fi\n+\n+# Validate that specified server is either part of a cluster or is an independent managed server\n+validateServerAndFindCluster \"${domainUid}\" \"${domainNamespace}\" \"${serverName}\" isValidServer clusterName\n+if [ \"${isValidServer}\" != 'true' ]; then\n+  printError \"Server ${serverName} is not part of any cluster and it's not an independent managed server. Please make sure that server name specified is correct.\"\n+  exit 1\n+fi\n+\n+getClusterPolicy \"${domainJson}\" \"${clusterName}\" clusterPolicy\n+if [ \"${clusterPolicy}\" == 'NEVER' ]; then\n+  echo \"The .spec.clusters[?(clusterName=\"${clusterName}\"].serverStartPolicy of the domain resource is 'NEVER'. The $(basename $0) script will exit without starting server ${serverName}.\"\n+  exit 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3456c6829e97258fb6099f0dfca2212bb5bc3d9f"}, "originalPosition": 120}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODY4MDkx", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-521868091", "createdAt": "2020-11-02T17:55:06Z", "commit": {"oid": "3456c6829e97258fb6099f0dfca2212bb5bc3d9f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNzo1NTowNlrOHsPpFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNzo1NTowNlrOHsPpFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE1NTY3MA==", "bodyText": "Same comments as the cluster check above ^^^", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516155670", "createdAt": "2020-11-02T17:55:06Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startServer.sh", "diffHunk": "@@ -0,0 +1,225 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+if [ \"${debug}\" == \"true\" ]; then set -x; fi;\n+set -eu\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script starts a WebLogic managed server in a domain either by increasing\n+  the value of 'spec.clusters[<cluster-name>].replicas' by '1' or by updating the\n+  'spec.managedServers[<server-name>].serverStartPolicy' attribute of the domain\n+  resource or both as needed. The 'spec.clusters[<cluster-name>].replicas' value can\n+  be kept constant by using '-k' option.\n+\n+  Usage:\n+\n+    $(basename $0) -s myserver [-n mynamespace] [-d mydomainuid] [-k] [-m kubecli] [-v]\n+\n+    -s <server_name>           : Server name parameter is required.\n+\n+    -d <domain_uid>            : Domain unique-id. Default is 'sample-domain1'.\n+\n+    -n <namespace>             : Domain namespace. Default is 'sample-domain1-ns'.\n+\n+    -k <keep_replica_constant> : Keep replica count constant. Default behavior is to increment replica count.\n+\n+    -m <kubernetes_cli>        : Kubernetes command line interface. Default is 'kubectl'.\n+\n+    -v <verbose_mode>          : Enables verbose mode. Default is 'false'.\n+\n+    -h                         : This help.\n+   \n+EOF\n+exit $1\n+}\n+\n+kubernetesCli=${KUBERNETES_CLI:-kubectl}\n+serverName=\"\"\n+clusterName=\"\"\n+domainUid=\"sample-domain1\"\n+domainNamespace=\"sample-domain1-ns\"\n+keepReplicaConstant=false\n+verboseMode=false\n+withRelicas=\"CONSTANT\"\n+withPolicy=\"CONSTANT\"\n+managedServerPolicy=\"\"\n+action=\"\"\n+isValidServer=\"\"\n+patchJson=\"\"\n+serverStarted=\"\"\n+startsByPolicyUnset=\"\"\n+startsByReplicaIncreaseAndPolicyUnset=\"\"\n+\n+while getopts \"vkd:n:m:s:h\" opt; do\n+  case $opt in\n+    s) serverName=\"${OPTARG}\"\n+    ;;\n+    n) domainNamespace=\"${OPTARG}\"\n+    ;;\n+    d) domainUid=\"${OPTARG}\"\n+    ;;\n+    k) keepReplicaConstant=true;\n+    ;;\n+    m) kubernetesCli=\"${OPTARG}\"\n+    ;;\n+    v) verboseMode=true;\n+    ;;\n+    h) usage 0\n+    ;;\n+    *) usage 1\n+    ;;\n+  esac\n+done\n+\n+#\n+# Function to perform validations, read files and initialize workspace\n+#\n+function initialize {\n+\n+  # Validate the required files exist\n+  validateErrors=false\n+\n+  validateKubernetesCliAvailable\n+  validateJqAvailable\n+\n+  # Validate that server name parameter is specified.\n+  if [ -z \"${serverName}\" ]; then\n+    validationError \"Please specify a server name using '-s' parameter e.g. '-s managed-server1'.\"\n+  fi\n+\n+  failIfValidationErrors\n+}\n+\n+initialize\n+\n+# Get the domain in json format\n+domainJson=$(${kubernetesCli} get domain ${domainUid} -n ${domainNamespace} -o json)\n+if [ $? -ne 0 ]; then\n+  echo \"[ERROR} Unable to get domain resource. Please make sure 'domain_uid' and 'namespace' provided with '-d' and '-n' arguments are correct.\"\n+  exit 1\n+fi\n+\n+# Validate that specified server is either part of a cluster or is an independent managed server\n+validateServerAndFindCluster \"${domainUid}\" \"${domainNamespace}\" \"${serverName}\" isValidServer clusterName\n+if [ \"${isValidServer}\" != 'true' ]; then\n+  printError \"Server ${serverName} is not part of any cluster and it's not an independent managed server. Please make sure that server name specified is correct.\"\n+  exit 1\n+fi\n+\n+getClusterPolicy \"${domainJson}\" \"${clusterName}\" clusterPolicy\n+if [ \"${clusterPolicy}\" == 'NEVER' ]; then\n+  echo \"The .spec.clusters[?(clusterName=\"${clusterName}\"].serverStartPolicy of the domain resource is 'NEVER'. The $(basename $0) script will exit without starting server ${serverName}.\"\n+  exit 0\n+fi\n+\n+getDomainPolicy \"${domainJson}\" domainPolicy\n+if [ \"${domainPolicy}\" == 'NEVER' ]; then\n+  echo \"The .spec.serverStartPolicy of the domain resource is 'NEVER'. The $(basename $0) script will exit without starting server ${serverName}.\"\n+  exit 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3456c6829e97258fb6099f0dfca2212bb5bc3d9f"}, "originalPosition": 126}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODcxNDQ1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-521871445", "createdAt": "2020-11-02T17:59:46Z", "commit": {"oid": "3456c6829e97258fb6099f0dfca2212bb5bc3d9f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNzo1OTo0NlrOHsPz2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNzo1OTo0NlrOHsPz2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE1ODQyNA==", "bodyText": "Maybe let's have a zoom and word-smith the script's messages a little together?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516158424", "createdAt": "2020-11-02T17:59:46Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startServer.sh", "diffHunk": "@@ -0,0 +1,225 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+if [ \"${debug}\" == \"true\" ]; then set -x; fi;\n+set -eu\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script starts a WebLogic managed server in a domain either by increasing\n+  the value of 'spec.clusters[<cluster-name>].replicas' by '1' or by updating the\n+  'spec.managedServers[<server-name>].serverStartPolicy' attribute of the domain\n+  resource or both as needed. The 'spec.clusters[<cluster-name>].replicas' value can\n+  be kept constant by using '-k' option.\n+\n+  Usage:\n+\n+    $(basename $0) -s myserver [-n mynamespace] [-d mydomainuid] [-k] [-m kubecli] [-v]\n+\n+    -s <server_name>           : Server name parameter is required.\n+\n+    -d <domain_uid>            : Domain unique-id. Default is 'sample-domain1'.\n+\n+    -n <namespace>             : Domain namespace. Default is 'sample-domain1-ns'.\n+\n+    -k <keep_replica_constant> : Keep replica count constant. Default behavior is to increment replica count.\n+\n+    -m <kubernetes_cli>        : Kubernetes command line interface. Default is 'kubectl'.\n+\n+    -v <verbose_mode>          : Enables verbose mode. Default is 'false'.\n+\n+    -h                         : This help.\n+   \n+EOF\n+exit $1\n+}\n+\n+kubernetesCli=${KUBERNETES_CLI:-kubectl}\n+serverName=\"\"\n+clusterName=\"\"\n+domainUid=\"sample-domain1\"\n+domainNamespace=\"sample-domain1-ns\"\n+keepReplicaConstant=false\n+verboseMode=false\n+withRelicas=\"CONSTANT\"\n+withPolicy=\"CONSTANT\"\n+managedServerPolicy=\"\"\n+action=\"\"\n+isValidServer=\"\"\n+patchJson=\"\"\n+serverStarted=\"\"\n+startsByPolicyUnset=\"\"\n+startsByReplicaIncreaseAndPolicyUnset=\"\"\n+\n+while getopts \"vkd:n:m:s:h\" opt; do\n+  case $opt in\n+    s) serverName=\"${OPTARG}\"\n+    ;;\n+    n) domainNamespace=\"${OPTARG}\"\n+    ;;\n+    d) domainUid=\"${OPTARG}\"\n+    ;;\n+    k) keepReplicaConstant=true;\n+    ;;\n+    m) kubernetesCli=\"${OPTARG}\"\n+    ;;\n+    v) verboseMode=true;\n+    ;;\n+    h) usage 0\n+    ;;\n+    *) usage 1\n+    ;;\n+  esac\n+done\n+\n+#\n+# Function to perform validations, read files and initialize workspace\n+#\n+function initialize {\n+\n+  # Validate the required files exist\n+  validateErrors=false\n+\n+  validateKubernetesCliAvailable\n+  validateJqAvailable\n+\n+  # Validate that server name parameter is specified.\n+  if [ -z \"${serverName}\" ]; then\n+    validationError \"Please specify a server name using '-s' parameter e.g. '-s managed-server1'.\"\n+  fi\n+\n+  failIfValidationErrors\n+}\n+\n+initialize\n+\n+# Get the domain in json format\n+domainJson=$(${kubernetesCli} get domain ${domainUid} -n ${domainNamespace} -o json)\n+if [ $? -ne 0 ]; then\n+  echo \"[ERROR} Unable to get domain resource. Please make sure 'domain_uid' and 'namespace' provided with '-d' and '-n' arguments are correct.\"\n+  exit 1\n+fi\n+\n+# Validate that specified server is either part of a cluster or is an independent managed server\n+validateServerAndFindCluster \"${domainUid}\" \"${domainNamespace}\" \"${serverName}\" isValidServer clusterName\n+if [ \"${isValidServer}\" != 'true' ]; then\n+  printError \"Server ${serverName} is not part of any cluster and it's not an independent managed server. Please make sure that server name specified is correct.\"\n+  exit 1\n+fi\n+\n+getClusterPolicy \"${domainJson}\" \"${clusterName}\" clusterPolicy\n+if [ \"${clusterPolicy}\" == 'NEVER' ]; then\n+  echo \"The .spec.clusters[?(clusterName=\"${clusterName}\"].serverStartPolicy of the domain resource is 'NEVER'. The $(basename $0) script will exit without starting server ${serverName}.\"\n+  exit 0\n+fi\n+\n+getDomainPolicy \"${domainJson}\" domainPolicy\n+if [ \"${domainPolicy}\" == 'NEVER' ]; then\n+  echo \"The .spec.serverStartPolicy of the domain resource is 'NEVER'. The $(basename $0) script will exit without starting server ${serverName}.\"\n+  exit 0\n+fi\n+\n+getEffectivePolicy \"${domainJson}\" \"${serverName}\" \"${clusterName}\" effectivePolicy\n+if [ -n \"${clusterName}\" ]; then\n+  # Server is part of a cluster, check currently started servers\n+  checkStartedServers \"${domainJson}\" \"${serverName}\" \"${clusterName}\" \"${withRelicas}\" \"${withPolicy}\" serverStarted\n+  if [[ ${effectivePolicy} == \"IF_NEEDED\" && ${serverStarted} == \"true\" ]]; then\n+    echo \"[INFO] The server should be already started or it's starting. The start policy for server ${serverName} is ${effectivePolicy} and server is chosen to be started based on current replica count.\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3456c6829e97258fb6099f0dfca2212bb5bc3d9f"}, "originalPosition": 134}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODk4MTM2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-521898136", "createdAt": "2020-11-02T18:37:46Z", "commit": {"oid": "3456c6829e97258fb6099f0dfca2212bb5bc3d9f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxODozNzo0NlrOHsRFEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxODozNzo0NlrOHsRFEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3OTIxOQ==", "bodyText": "Can this be simplified  to call 'getServer/Cluster/DomainPolicy' instead of calling the same code as those three functions?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516179219", "createdAt": "2020-11-02T18:37:46Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,554 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value containing cluster level server start policy\n+#\n+function getClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __clusterPolicy=$3\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  eval $__clusterPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get server start policy at domain level\n+# $1 - Domain resource in json format\n+# $2 - Return value containing domain level server start policy\n+#\n+function getDomainPolicy {\n+  local domainJson=$1\n+  local __domainPolicy=$2\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\".spec.serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  eval $__domainPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get effective start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Name of cluster\n+# $4 - Return value containing effective server start policy\n+#\n+function getEffectivePolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local __currentPolicy=$4\n+  local policyFound=false\n+  local managedServers=\"\"\n+\n+  # Get server start policy for this server\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentPolicy=$(echo ${domainJson} | jq -r \"${extractPolicyCmd}\")\n+    if [[ -n ${currentPolicy} && ${currentPolicy} != \"null\" ]]; then\n+      # Start policy is set at server level, return policy\n+      eval $__currentPolicy=\"'${currentPolicy}'\"\n+      policyFound=true\n+    fi\n+  fi\n+  if [ \"${policyFound}\" == 'false' ]; then\n+    clusterPolicyCmd=\"(.spec.clusters[] \\\n+      | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+    currentPolicy=$(echo ${domainJson} | jq -r \"${clusterPolicyCmd}\")\n+    if [ \"${currentPolicy}\" == \"null\" ]; then\n+      # Start policy is not set at cluster level, check at domain level\n+      clusterPolicyCmd=\".spec.serverStartPolicy\"\n+      currentPolicy=$(echo ${domainJson} | jq -r \"${clusterPolicyCmd}\")\n+      if [ \"${currentPolicy}\" == \"null\" ]; then\n+        # Start policy is not set at domain level, default to IF_NEEDED\n+        currentPolicy=IF_NEEDED\n+      fi\n+    fi\n+    eval $__currentPolicy=\"'${currentPolicy}'\"\n+  fi", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3456c6829e97258fb6099f0dfca2212bb5bc3d9f"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODk4NzM3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-521898737", "createdAt": "2020-11-02T18:38:38Z", "commit": {"oid": "3456c6829e97258fb6099f0dfca2212bb5bc3d9f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxODozODozOFrOHsRGuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxODozODozOFrOHsRGuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3OTY0MA==", "bodyText": "Consider renaming to getServerPolicy so that its nomenclature matches getDomainPolicy and getClusterPolicy ^^^", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516179640", "createdAt": "2020-11-02T18:38:38Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,554 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value containing cluster level server start policy\n+#\n+function getClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __clusterPolicy=$3\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  eval $__clusterPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get server start policy at domain level\n+# $1 - Domain resource in json format\n+# $2 - Return value containing domain level server start policy\n+#\n+function getDomainPolicy {\n+  local domainJson=$1\n+  local __domainPolicy=$2\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\".spec.serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  eval $__domainPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get effective start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Name of cluster\n+# $4 - Return value containing effective server start policy\n+#\n+function getEffectivePolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local __currentPolicy=$4\n+  local policyFound=false\n+  local managedServers=\"\"\n+\n+  # Get server start policy for this server\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentPolicy=$(echo ${domainJson} | jq -r \"${extractPolicyCmd}\")\n+    if [[ -n ${currentPolicy} && ${currentPolicy} != \"null\" ]]; then\n+      # Start policy is set at server level, return policy\n+      eval $__currentPolicy=\"'${currentPolicy}'\"\n+      policyFound=true\n+    fi\n+  fi\n+  if [ \"${policyFound}\" == 'false' ]; then\n+    clusterPolicyCmd=\"(.spec.clusters[] \\\n+      | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+    currentPolicy=$(echo ${domainJson} | jq -r \"${clusterPolicyCmd}\")\n+    if [ \"${currentPolicy}\" == \"null\" ]; then\n+      # Start policy is not set at cluster level, check at domain level\n+      clusterPolicyCmd=\".spec.serverStartPolicy\"\n+      currentPolicy=$(echo ${domainJson} | jq -r \"${clusterPolicyCmd}\")\n+      if [ \"${currentPolicy}\" == \"null\" ]; then\n+        # Start policy is not set at domain level, default to IF_NEEDED\n+        currentPolicy=IF_NEEDED\n+      fi\n+    fi\n+    eval $__currentPolicy=\"'${currentPolicy}'\"\n+  fi\n+}\n+\n+#\n+# Function to get current start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Return value containing current server start policy\n+#\n+function getCurrentPolicy {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3456c6829e97258fb6099f0dfca2212bb5bc3d9f"}, "originalPosition": 89}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODk5Njk5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-521899699", "createdAt": "2020-11-02T18:40:06Z", "commit": {"oid": "3456c6829e97258fb6099f0dfca2212bb5bc3d9f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxODo0MDowNlrOHsRJ0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxODo0MDowNlrOHsRJ0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE4MDQzNA==", "bodyText": "could this be replaced with 'getServerPolicy'?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516180434", "createdAt": "2020-11-02T18:40:06Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,554 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value containing cluster level server start policy\n+#\n+function getClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __clusterPolicy=$3\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  eval $__clusterPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get server start policy at domain level\n+# $1 - Domain resource in json format\n+# $2 - Return value containing domain level server start policy\n+#\n+function getDomainPolicy {\n+  local domainJson=$1\n+  local __domainPolicy=$2\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\".spec.serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  eval $__domainPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get effective start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Name of cluster\n+# $4 - Return value containing effective server start policy\n+#\n+function getEffectivePolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local __currentPolicy=$4\n+  local policyFound=false\n+  local managedServers=\"\"\n+\n+  # Get server start policy for this server\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentPolicy=$(echo ${domainJson} | jq -r \"${extractPolicyCmd}\")\n+    if [[ -n ${currentPolicy} && ${currentPolicy} != \"null\" ]]; then\n+      # Start policy is set at server level, return policy\n+      eval $__currentPolicy=\"'${currentPolicy}'\"\n+      policyFound=true\n+    fi\n+  fi\n+  if [ \"${policyFound}\" == 'false' ]; then\n+    clusterPolicyCmd=\"(.spec.clusters[] \\\n+      | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+    currentPolicy=$(echo ${domainJson} | jq -r \"${clusterPolicyCmd}\")\n+    if [ \"${currentPolicy}\" == \"null\" ]; then\n+      # Start policy is not set at cluster level, check at domain level\n+      clusterPolicyCmd=\".spec.serverStartPolicy\"\n+      currentPolicy=$(echo ${domainJson} | jq -r \"${clusterPolicyCmd}\")\n+      if [ \"${currentPolicy}\" == \"null\" ]; then\n+        # Start policy is not set at domain level, default to IF_NEEDED\n+        currentPolicy=IF_NEEDED\n+      fi\n+    fi\n+    eval $__currentPolicy=\"'${currentPolicy}'\"\n+  fi\n+}\n+\n+#\n+# Function to get current start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Return value containing current server start policy\n+#\n+function getCurrentPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __currentPolicy=$3\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentServerStartPolicy=$(echo ${domainJson} | jq \"${extractPolicyCmd}\")\n+  fi\n+  eval $__currentPolicy=${currentServerStartPolicy}\n+}\n+\n+#\n+# Function to create server start policy patch string\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Policy value \n+# $4 - Return value containing server start policy patch string\n+#\n+function createServerStartPolicyPatch {\n+  local domainJson=$1\n+  local serverName=$2\n+  local policy=$3\n+  local __result=$4\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3456c6829e97258fb6099f0dfca2212bb5bc3d9f"}, "originalPosition": 122}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df3c33f1d2ff36840d937115ca2428f2246011ac", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/df3c33f1d2ff36840d937115ca2428f2246011ac", "committedDate": "2020-11-02T20:58:30Z", "message": "Changes to address review comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMDA2NzM0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-522006734", "createdAt": "2020-11-02T21:30:46Z", "commit": {"oid": "df3c33f1d2ff36840d937115ca2428f2246011ac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMTozMDo0NlrOHsWWHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMTozMDo0NlrOHsWWHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI2NTUwMA==", "bodyText": "slight simplification: would it help to  have the 'get' helpers  convert 'null' ret vals to '', so you don't need to check for both \"null\" and -z everywhere?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516265500", "createdAt": "2020-11-02T21:30:46Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,535 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value containing cluster level server start policy\n+#\n+function getClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __clusterPolicy=$3\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  eval $__clusterPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get server start policy at domain level\n+# $1 - Domain resource in json format\n+# $2 - Return value containing domain level server start policy\n+#\n+function getDomainPolicy {\n+  local domainJson=$1\n+  local __domainPolicy=$2\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\".spec.serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  eval $__domainPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get effective start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Name of cluster\n+# $4 - Return value containing effective server start policy\n+#\n+function getEffectivePolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local __currentPolicy=$4\n+  local currentPolicy=\"\"\n+\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentPolicy\n+  if [[ -z \"${currentPolicy}\" ||  ${currentPolicy} == \"null\" ]]; then", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df3c33f1d2ff36840d937115ca2428f2246011ac"}, "originalPosition": 54}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e028fb390ab44274ced681d23255f8504f6ecb6", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3e028fb390ab44274ced681d23255f8504f6ecb6", "committedDate": "2020-11-03T05:46:27Z", "message": "More review comment changes and cleanup."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/10feb9907e6a6ae987998b1792243ac22d041cb1", "committedDate": "2020-11-03T14:48:27Z", "message": "Unset policy to start independent (stadalone) maanged server instead of ALWAYS."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNjY0NTc1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-522664575", "createdAt": "2020-11-03T16:21:35Z", "commit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNjoyMTozNVrOHs2evQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNjoyMTozNVrOHs2evQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc5MTk5Nw==", "bodyText": "just a minor point:  in my experimentation changing to  the following:\n    # note that the lack of quotes is deliberate\n    for localServerName in ${sortedByAlwaysServers[@]:-}; do\n    done\n\nis nearly equivalent to:\n  sortedByAlwaysSize=${#sortedByAlwaysServers[@]}\n  if [ \"${sortedByAlwaysSize}\" -gt 0 ]; then\n    for localServerName in \"${sortedByAlwaysServers[@]}\"; do\n    done\n  fi\n\nThe drawback is that it  (a) assumes server names won't have special chars like quotes in them - which is probably a reasonable assumption, and (b) it defeats the 'set -u' var name check so a bad var name would short circuit the loop...", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516791997", "createdAt": "2020-11-03T16:21:35Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,606 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value containing cluster level server start policy\n+#\n+function getClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __clusterPolicy=$3\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__clusterPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get server start policy at domain level\n+# $1 - Domain resource in json format\n+# $2 - Return value containing domain level server start policy\n+#\n+function getDomainPolicy {\n+  local domainJson=$1\n+  local __domainPolicy=$2\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\".spec.serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__domainPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get effective start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Name of cluster\n+# $4 - Return value containing effective server start policy\n+#\n+function getEffectivePolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local __currentPolicy=$4\n+  local currentPolicy=\"\"\n+\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentPolicy\n+  if [ -z \"${currentPolicy}\" ]; then\n+    getClusterPolicy \"${domainJson}\" \"${clusterName}\" currentPolicy\n+    if [ -z \"${currentPolicy}\" ]; then\n+      # Start policy is not set at cluster level, check at domain level\n+      getDomainPolicy \"${domainJson}\" currentPolicy\n+      if [ -z \"${currentPolicy}\" ]; then\n+        # Start policy is not set at domain level, default to IF_NEEDED\n+        currentPolicy=IF_NEEDED\n+      fi\n+    fi\n+  fi\n+  eval $__currentPolicy=\"'${currentPolicy}'\"\n+}\n+\n+#\n+# Function to get current start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Return value containing current server start policy\n+#\n+function getServerPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __currentPolicy=$3\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentServerStartPolicy=$(echo ${domainJson} | jq \"${extractPolicyCmd}\")\n+    if [ \"${currentServerStartPolicy}\" == \"null\" ]; then\n+      currentServerStartPolicy=\"\"\n+    fi\n+  fi\n+  eval $__currentPolicy=${currentServerStartPolicy}\n+}\n+\n+#\n+# Function to create server start policy patch string\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Policy value \n+# $4 - Return value containing server start policy patch string\n+#\n+function createServerStartPolicyPatch {\n+  local domainJson=$1\n+  local serverName=$2\n+  local policy=$3\n+  local __result=$4\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentServerStartPolicy\n+  if [ -z \"${currentServerStartPolicy}\" ]; then\n+    # Server start policy doesn't exist, add a new policy\n+    addPolicyCmd=\".[.| length] |= . + {\\\"serverName\\\":\\\"${serverName}\\\", \\\n+      \\\"serverStartPolicy\\\":\\\"${policy}\\\"}\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq .spec.managedServers | jq -c \"${addPolicyCmd}\")\n+  else\n+    # Server start policy exists, replace policy value \n+    replacePolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy) |= \\\"${policy}\\\"\"\n+    servers=\"(.spec.managedServers)\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\" | jq -cr \"${servers}\")\n+  fi\n+  eval $__result=\"'${serverStartPolicyPatch}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy and update replica\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - String containing replica patch string\n+# $4 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicyAndUpdateReplica {\n+  local domainJson=$1\n+  local serverName=$2\n+  local replicaPatch=$3\n+  local __result=$4\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaPatch}\",\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update policy \n+# $1 - String containing start policy info\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdatePolicy {\n+  local startPolicy=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update replica \n+# $1 - String containing replica\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdateReplica {\n+  local replicaInfo=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUpdateReplicaAndPolicy {\n+  local replicaInfo=$1\n+  local startPolicy=$2\n+  local __result=$3\n+\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\",\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __result=$3\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to get sorted list of servers in a cluster.\n+# The sorted list is created in 'sortedByAlwaysServers' array.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if policy of current server would be unset\n+#\n+function getSortedListOfServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withPolicy=$4\n+  local policy=\"\"\n+  local sortedServers=()\n+  local otherServers=()\n+\n+  configMap=$(${kubernetesCli} get cm ${domainUid}-weblogic-domain-introspect-cm \\\n+    -n ${domainNamespace} -o json)\n+  topology=$(echo \"${configMap}\" | jq '.data[\"topology.yaml\"]')\n+  jsonTopology=$(python -c \\\n+    'import sys, yaml, json; print json.dumps(yaml.safe_load('\"${topology}\"'), indent=4)')\n+  clusterTopology=$(echo ${jsonTopology} | jq -r '.domain | .configuredClusters[] | select (.name == '\\\"${clusterName}\\\"')')\n+  dynaCluster=$(echo ${clusterTopology} | jq .dynamicServersConfig)\n+  if [ \"${dynaCluster}\" == \"null\" ]; then\n+    # Cluster is a configured cluster, get server names\n+    servers=($(echo ${clusterTopology} | jq -r .servers[].name))\n+    # Sort server names in numero lexi order\n+    IFS=$'\\n' sortedServers=($(sort --version-sort <<<\"${servers[*]}\" ))\n+    unset IFS\n+    clusterSize=${#sortedServers[@]}\n+  else \n+    # Cluster is a dynamic cluster, calculate server names\n+    prefix=$(echo ${dynaCluster} | jq -r .serverNamePrefix)\n+    clusterSize=$(echo ${dynaCluster} | jq .dynamicClusterSize) \n+    for (( i=1; i<=$clusterSize; i++ )); do\n+      localServerName=${prefix}$i\n+      sortedServers+=(${localServerName})\n+    done\n+  fi\n+  # Create arrays of ALWAYS policy servers and other servers\n+  sortedServersSize=${#sortedServers[@]}\n+  if [ \"${sortedServersSize}\" -gt 0 ]; then\n+    for localServerName in \"${sortedServers[@]}\"; do\n+      getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+      # Update policy when server name matches current server and unsetting\n+      if [[ \"${withPolicy}\" == \"UNSET\" && \"${serverName}\" == \"${localServerName}\" ]]; then\n+        policy=UNSET\n+      fi\n+      if [ \"${policy}\" == \"ALWAYS\" ]; then\n+        sortedByAlwaysServers+=(${localServerName})\n+      else\n+        otherServers+=(${localServerName})\n+      fi\n+    done\n+  fi\n+  \n+  # append other servers to the list of servers with always policy\n+  otherServersSize=${#otherServers[@]}\n+  if [ \"${otherServersSize}\" -gt 0 ]; then\n+    for otherServer in \"${otherServers[@]}\"; do\n+      sortedByAlwaysServers+=($otherServer)\n+    done\n+  fi\n+}\n+\n+#\n+# Get replica count for a cluster\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster \n+# $3 - Return value containing replica count\n+#\n+function getReplicaCount {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __replicaCount=$3\n+\n+  replicasCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).replicas\"\n+  replicaCount=$(echo ${domainJson} | jq \"${replicasCmd}\")\n+  eval $__replicaCount=\"'${replicaCount}'\"\n+\n+}\n+\n+#\n+# Check servers started in a cluster based on server start policy and \n+# replica count.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if replicas will stay constant, incremented or decremented\n+# $5 - Indicates if policy of current server will stay same or unset\n+# $6 - Return value indicating if current server will be started\n+#\n+function checkStartedServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withReplicas=$4\n+  local withPolicy=$5\n+  local __started=$6\n+  local localServerName=\"\"\n+  local policy=\"\"\n+  local replicaCount=0\n+  local currentReplicas=0\n+  local startedServers=()\n+  local sortedByAlwaysServers=()\n+  \n+  # Get sorted list of servers in 'sortedByAlwaysServers' array\n+  getSortedListOfServers \"${domainJson}\" \"${serverName}\" \"${clusterName}\" \"${withPolicy}\"\n+  getReplicaCount \"${domainJson}\" \"${clusterName}\" replicaCount\n+  # Increment or decrement the replica count based on 'withReplicas' input parameter\n+  if [ \"${withReplicas}\" == \"INCREASED\" ]; then\n+    replicaCount=$((replicaCount+1))\n+  elif [ \"${withReplicas}\" == \"DECREASED\" ]; then\n+    replicaCount=$((replicaCount-1))\n+  fi\n+  sortedByAlwaysSize=${#sortedByAlwaysServers[@]}\n+  if [ \"${sortedByAlwaysSize}\" -gt 0 ]; then", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "originalPosition": 325}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNjgxMjMx", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-522681231", "createdAt": "2020-11-03T16:38:47Z", "commit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNjozODo0OFrOHs3Ozw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNjozODo0OFrOHs3Ozw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgwNDMwMw==", "bodyText": "Unfortunately, this fn won't work on the mac bash because you have a global 'set -e'.  To work-around it do this, do a local 'set +e' around the potential illegal call:\n  timestamp=\"$(set +e && date --utc '+%Y-%m-%dT%H:%M:%S %N %s %Z' 2>&1 || exit 0)\"", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516804303", "createdAt": "2020-11-03T16:38:48Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,606 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value containing cluster level server start policy\n+#\n+function getClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __clusterPolicy=$3\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__clusterPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get server start policy at domain level\n+# $1 - Domain resource in json format\n+# $2 - Return value containing domain level server start policy\n+#\n+function getDomainPolicy {\n+  local domainJson=$1\n+  local __domainPolicy=$2\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\".spec.serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__domainPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get effective start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Name of cluster\n+# $4 - Return value containing effective server start policy\n+#\n+function getEffectivePolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local __currentPolicy=$4\n+  local currentPolicy=\"\"\n+\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentPolicy\n+  if [ -z \"${currentPolicy}\" ]; then\n+    getClusterPolicy \"${domainJson}\" \"${clusterName}\" currentPolicy\n+    if [ -z \"${currentPolicy}\" ]; then\n+      # Start policy is not set at cluster level, check at domain level\n+      getDomainPolicy \"${domainJson}\" currentPolicy\n+      if [ -z \"${currentPolicy}\" ]; then\n+        # Start policy is not set at domain level, default to IF_NEEDED\n+        currentPolicy=IF_NEEDED\n+      fi\n+    fi\n+  fi\n+  eval $__currentPolicy=\"'${currentPolicy}'\"\n+}\n+\n+#\n+# Function to get current start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Return value containing current server start policy\n+#\n+function getServerPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __currentPolicy=$3\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentServerStartPolicy=$(echo ${domainJson} | jq \"${extractPolicyCmd}\")\n+    if [ \"${currentServerStartPolicy}\" == \"null\" ]; then\n+      currentServerStartPolicy=\"\"\n+    fi\n+  fi\n+  eval $__currentPolicy=${currentServerStartPolicy}\n+}\n+\n+#\n+# Function to create server start policy patch string\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Policy value \n+# $4 - Return value containing server start policy patch string\n+#\n+function createServerStartPolicyPatch {\n+  local domainJson=$1\n+  local serverName=$2\n+  local policy=$3\n+  local __result=$4\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentServerStartPolicy\n+  if [ -z \"${currentServerStartPolicy}\" ]; then\n+    # Server start policy doesn't exist, add a new policy\n+    addPolicyCmd=\".[.| length] |= . + {\\\"serverName\\\":\\\"${serverName}\\\", \\\n+      \\\"serverStartPolicy\\\":\\\"${policy}\\\"}\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq .spec.managedServers | jq -c \"${addPolicyCmd}\")\n+  else\n+    # Server start policy exists, replace policy value \n+    replacePolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy) |= \\\"${policy}\\\"\"\n+    servers=\"(.spec.managedServers)\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\" | jq -cr \"${servers}\")\n+  fi\n+  eval $__result=\"'${serverStartPolicyPatch}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy and update replica\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - String containing replica patch string\n+# $4 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicyAndUpdateReplica {\n+  local domainJson=$1\n+  local serverName=$2\n+  local replicaPatch=$3\n+  local __result=$4\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaPatch}\",\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update policy \n+# $1 - String containing start policy info\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdatePolicy {\n+  local startPolicy=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update replica \n+# $1 - String containing replica\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdateReplica {\n+  local replicaInfo=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUpdateReplicaAndPolicy {\n+  local replicaInfo=$1\n+  local startPolicy=$2\n+  local __result=$3\n+\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\",\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __result=$3\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to get sorted list of servers in a cluster.\n+# The sorted list is created in 'sortedByAlwaysServers' array.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if policy of current server would be unset\n+#\n+function getSortedListOfServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withPolicy=$4\n+  local policy=\"\"\n+  local sortedServers=()\n+  local otherServers=()\n+\n+  configMap=$(${kubernetesCli} get cm ${domainUid}-weblogic-domain-introspect-cm \\\n+    -n ${domainNamespace} -o json)\n+  topology=$(echo \"${configMap}\" | jq '.data[\"topology.yaml\"]')\n+  jsonTopology=$(python -c \\\n+    'import sys, yaml, json; print json.dumps(yaml.safe_load('\"${topology}\"'), indent=4)')\n+  clusterTopology=$(echo ${jsonTopology} | jq -r '.domain | .configuredClusters[] | select (.name == '\\\"${clusterName}\\\"')')\n+  dynaCluster=$(echo ${clusterTopology} | jq .dynamicServersConfig)\n+  if [ \"${dynaCluster}\" == \"null\" ]; then\n+    # Cluster is a configured cluster, get server names\n+    servers=($(echo ${clusterTopology} | jq -r .servers[].name))\n+    # Sort server names in numero lexi order\n+    IFS=$'\\n' sortedServers=($(sort --version-sort <<<\"${servers[*]}\" ))\n+    unset IFS\n+    clusterSize=${#sortedServers[@]}\n+  else \n+    # Cluster is a dynamic cluster, calculate server names\n+    prefix=$(echo ${dynaCluster} | jq -r .serverNamePrefix)\n+    clusterSize=$(echo ${dynaCluster} | jq .dynamicClusterSize) \n+    for (( i=1; i<=$clusterSize; i++ )); do\n+      localServerName=${prefix}$i\n+      sortedServers+=(${localServerName})\n+    done\n+  fi\n+  # Create arrays of ALWAYS policy servers and other servers\n+  sortedServersSize=${#sortedServers[@]}\n+  if [ \"${sortedServersSize}\" -gt 0 ]; then\n+    for localServerName in \"${sortedServers[@]}\"; do\n+      getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+      # Update policy when server name matches current server and unsetting\n+      if [[ \"${withPolicy}\" == \"UNSET\" && \"${serverName}\" == \"${localServerName}\" ]]; then\n+        policy=UNSET\n+      fi\n+      if [ \"${policy}\" == \"ALWAYS\" ]; then\n+        sortedByAlwaysServers+=(${localServerName})\n+      else\n+        otherServers+=(${localServerName})\n+      fi\n+    done\n+  fi\n+  \n+  # append other servers to the list of servers with always policy\n+  otherServersSize=${#otherServers[@]}\n+  if [ \"${otherServersSize}\" -gt 0 ]; then\n+    for otherServer in \"${otherServers[@]}\"; do\n+      sortedByAlwaysServers+=($otherServer)\n+    done\n+  fi\n+}\n+\n+#\n+# Get replica count for a cluster\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster \n+# $3 - Return value containing replica count\n+#\n+function getReplicaCount {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __replicaCount=$3\n+\n+  replicasCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).replicas\"\n+  replicaCount=$(echo ${domainJson} | jq \"${replicasCmd}\")\n+  eval $__replicaCount=\"'${replicaCount}'\"\n+\n+}\n+\n+#\n+# Check servers started in a cluster based on server start policy and \n+# replica count.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if replicas will stay constant, incremented or decremented\n+# $5 - Indicates if policy of current server will stay same or unset\n+# $6 - Return value indicating if current server will be started\n+#\n+function checkStartedServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withReplicas=$4\n+  local withPolicy=$5\n+  local __started=$6\n+  local localServerName=\"\"\n+  local policy=\"\"\n+  local replicaCount=0\n+  local currentReplicas=0\n+  local startedServers=()\n+  local sortedByAlwaysServers=()\n+  \n+  # Get sorted list of servers in 'sortedByAlwaysServers' array\n+  getSortedListOfServers \"${domainJson}\" \"${serverName}\" \"${clusterName}\" \"${withPolicy}\"\n+  getReplicaCount \"${domainJson}\" \"${clusterName}\" replicaCount\n+  # Increment or decrement the replica count based on 'withReplicas' input parameter\n+  if [ \"${withReplicas}\" == \"INCREASED\" ]; then\n+    replicaCount=$((replicaCount+1))\n+  elif [ \"${withReplicas}\" == \"DECREASED\" ]; then\n+    replicaCount=$((replicaCount-1))\n+  fi\n+  sortedByAlwaysSize=${#sortedByAlwaysServers[@]}\n+  if [ \"${sortedByAlwaysSize}\" -gt 0 ]; then\n+    for localServerName in \"${sortedByAlwaysServers[@]}\"; do\n+      getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+      # Update policy when server name matches current server and unsetting\n+      if [[ \"${serverName}\" == \"${localServerName}\" && \"${withPolicy}\" == \"UNSET\" ]]; then\n+        policy=UNSET\n+      fi\n+      # check if server should start based on replica count, policy and current replicas\n+      shouldStart \"${currentReplicas}\" \"${policy}\" \"${replicaCount}\" result\n+      if [ \"${result}\" == 'True' ]; then\n+        # server should start, increment current replicas and add server to list of started servers\n+        currentReplicas=$((currentReplicas+1))\n+        startedServers+=(${localServerName})\n+      fi\n+    done\n+  fi\n+  startedSize=${#startedServers[@]}\n+  if [ ${startedSize} -gt 0 ]; then\n+    # check if current server is in the list of started servers\n+    if checkStringInArray ${serverName} ${startedServers[@]}; then\n+      eval $__started=\"true\"\n+      return\n+    fi\n+  fi\n+  eval $__started=\"false\"\n+}\n+\n+#\n+# Function to check if server should start based on policy and current replicas\n+# $1 - Current number of replicas\n+# $2 - Server start policy\n+# $3 - Replica count\n+# $4 - Return value\n+#\n+function shouldStart {\n+  local currentReplicas=$1\n+  local policy=$2\n+  local replicaCount=$3 \n+  local __result=$4\n+\n+  if [ \"$policy\" == \"ALWAYS\" ]; then\n+    eval $__result=True\n+  elif [ \"$policy\" == \"NEVER\" ]; then\n+    eval $__result=False\n+  elif [ \"${currentReplicas}\" -lt \"${replicaCount}\" ]; then\n+    eval $__result=True\n+  else \n+    eval $__result=False\n+  fi\n+}\n+\n+#\n+# Function to create patch string for updating replica count\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster whose replica count will be patched\n+# $3 - operatation string indicating whether to increment or decrement count\n+# $4 - Return value containing replica update patch string\n+# $5 - Retrun value containing updated replica count\n+#\n+function createReplicaPatch {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local operation=$3\n+  local __result=$4\n+  local __replicaCount=$5\n+  local maxReplicas=\"\"\n+  local errorMessage=\"@@ ERROR: Maximum number of servers allowed (maxReplica = ${maxReplicas}) \\\n+are already running. Please increase cluster size to start new servers.\"\n+\n+  replicasCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).replicas\"\n+  maxReplicaCmd=\"(.status.clusters[] | select (.clusterName == \\\"${clusterName}\\\")) \\\n+    | .maximumReplicas\"\n+  replica=$(echo ${domainJson} | jq \"${replicasCmd}\")\n+  if [[ -z \"${replica}\" || \"${replica}\" == \"null\" ]]; then\n+    replica=$(echo ${domainJson} | jq .spec.replicas)\n+  fi\n+  if [ \"${operation}\" == \"DECREMENT\" ]; then\n+    replica=$((replica-1))\n+    if [ ${replica} -lt 0 ]; then\n+      replica=0\n+    fi\n+  elif [ \"${operation}\" == \"INCREMENT\" ]; then\n+    replica=$((replica+1))\n+    maxReplicas=$(echo ${domainJson} | jq \"${maxReplicaCmd}\")\n+    if [ ${replica} -gt ${maxReplicas} ]; then\n+      echo \"${errorMessage}\"\n+      eval $__result=\"MAX_REPLICA_COUNT_EXCEEDED\"\n+      return\n+    fi\n+  fi\n+\n+  cmd=\"(.spec.clusters[] | select (.clusterName == \\\"${clusterName}\\\") \\\n+    | .replicas) |= ${replica}\"\n+  replicaPatch=$(echo ${domainJson} | jq \"${cmd}\" | jq -cr '(.spec.clusters)')\n+  eval $__result=\"'${replicaPatch}'\"\n+  eval $__replicaCount=\"'${replica}'\"\n+}\n+\n+#\n+# Function to validate whether a server belongs to a  cluster or is an independent managed server\n+# $1 - Domain unique id.\n+# $2 - Domain namespace.\n+# $3 - Server name.\n+# $4 - Return value indicating if server is valid (i.e. if it's part of a cluster or independent server).\n+# $5 - Retrun value containting cluster name to which this server belongs.\n+#\n+function validateServerAndFindCluster {\n+  local domainUid=$1\n+  local domainNamespace=$2 \n+  local serverName=$3\n+  local __isValidServer=$4\n+  local __clusterName=$5\n+  local serverCount=\"\"\n+  local errorMessage=\"Server name is outside the range of allowed servers. \\\n+Please make sure server name is correct.\"\n+\n+  configMap=$(${kubernetesCli} get cm ${domainUid}-weblogic-domain-introspect-cm \\\n+    -n ${domainNamespace} -o json)\n+  topology=$(echo \"${configMap}\" | jq '.data[\"topology.yaml\"]')\n+  jsonTopology=$(python -c \\\n+    'import sys, yaml, json; print json.dumps(yaml.safe_load('\"${topology}\"'), indent=4)')\n+  servers=($(echo $jsonTopology | jq -r '.domain.servers[].name'))\n+  if  checkStringInArray \"${serverName}\" \"${servers[@]}\" ; then\n+    eval $__clusterName=\"\"\n+    eval $__isValidServer=true\n+  else\n+    dynamicClause=\".domain.configuredClusters[] | select (.dynamicServersConfig != null)\"\n+    namePrefixSize=\". | {name: .name, prefix:.dynamicServersConfig.serverNamePrefix, \\\n+                 max:.dynamicServersConfig.maxDynamicClusterSize}\"\n+    dynamicClusters=($(echo $jsonTopology | jq \"${dynamicClause}\" | jq -cr \"${namePrefixSize}\"))\n+    dynamicClustersSize=${#dynamicClusters[@]}\n+    if [ \"${dynamicClustersSize}\" -gt 0 ]; then\n+      for dynaClusterNamePrefix in \"${dynamicClusters[@]}\"; do\n+        prefix=$(echo ${dynaClusterNamePrefix} | jq -r .prefix)\n+        if [[ \"${serverName}\" == \"${prefix}\"* ]]; then\n+          maxSize=$(echo ${dynaClusterNamePrefix} | jq -r .max)\n+          number='^[0-9]+$'\n+          if [ $(echo \"${serverName}\" | grep -c -Eo '[0-9]+$') -gt 0 ]; then\n+            serverCount=$(echo \"${serverName}\" | grep -Eo '[0-9]+$')\n+          fi\n+          if ! [[ $serverCount =~ $number ]] ; then\n+             echo \"error: Server name is not valid for dynamic cluster.\" \n+             exit 1\n+          fi\n+          if [ \"${serverCount}\" -gt \"${maxSize}\" ]; then\n+            printError \"${errorMessage}\"\n+            exit 1\n+          fi\n+          eval $__clusterName=\"'$(echo ${dynaClusterNamePrefix} | jq -r .name)'\"\n+          eval $__isValidServer=true\n+          break\n+        fi\n+      done\n+    fi\n+    staticClause=\".domain.configuredClusters[] | select (.dynamicServersConfig == null)\"\n+    nameCmd=\" . | {name: .name, serverName: .servers[].name}\"\n+    configuredClusters=($(echo $jsonTopology | jq \"${staticClause}\" | jq -cr \"${nameCmd}\"))\n+    configuredClusterSize=${#configuredClusters[@]}\n+    if [ \"${configuredClusterSize}\" -gt 0 ]; then\n+      for configuredClusterName in \"${configuredClusters[@]}\"; do\n+        name=$(echo ${configuredClusterName} | jq -r .serverName)\n+        if [ \"${serverName}\" == \"${name}\" ]; then\n+          eval $__clusterName=\"'$(echo ${configuredClusterName} | jq -r .name)'\"\n+          eval $__isValidServer=true\n+          break\n+        fi\n+      done\n+    fi\n+  fi\n+}\n+\n+#\n+# Function to validate whether a cluster is valid and part of the domain\n+# $1 - Domain unique id.\n+# $2 - Domain namespace.\n+# $3 - cluster name\n+# $4 - Retrun value indicating whether cluster name is valid\n+#\n+function validateClusterName {\n+  local domainUid=$1\n+  local domainNamespace=$2\n+  local clusterName=$3\n+  local __isValidCluster=$4\n+\n+  configMap=$(${kubernetesCli} get cm ${domainUid}-weblogic-domain-introspect-cm \\\n+    -n ${domainNamespace} -o json)\n+  topology=$(echo \"${configMap}\" | jq '.data[\"topology.yaml\"]')\n+  jsonTopology=$(python -c \\\n+    'import sys, yaml, json; print json.dumps(yaml.safe_load('\"${topology}\"'), indent=4)')\n+  clusters=($(echo $jsonTopology | jq -cr .domain.configuredClusters[].name))\n+  if  checkStringInArray \"${clusterName}\" \"${clusters[@]}\" ; then\n+    eval $__isValidCluster=true\n+  fi\n+}\n+\n+#\n+# check if string passed as first argument is present in array passed as second argument\n+# $1 - string to check\n+# $2 - array\n+checkStringInArray() {\n+    local str=$1 arr\n+    shift\n+    for arr; do\n+      [[ $str = \"$arr\" ]] && return\n+    done\n+    return 1\n+}\n+\n+# try to execute jq to see whether jq is available\n+function validateJqAvailable {\n+  if ! [ -x \"$(command -v jq)\" ]; then\n+    validationError \"jq is not installed\"\n+  fi\n+}\n+\n+# try to execute python to see whether python is available\n+function validatePythonAvailable {\n+  if ! [ -x \"$(command -v python)\" ]; then\n+    validationError \"python is not installed\"\n+  fi\n+}\n+\n+# try to execute kubernetes cli to see whether cli is available\n+function validateKubernetesCliAvailable {\n+  if ! [ -x \"$(command -v ${kubernetesCli})\" ]; then\n+    validationError \"${kubernetesCli} is not installed\"\n+  fi\n+}\n+\n+#\n+# Function to exit and print an error message\n+# $1 - text of message\n+function fail {\n+  printError $*\n+  exit 1\n+}\n+\n+# Function to print an error message\n+function printError {\n+  echo [`timestamp`][ERROR] $*\n+}\n+\n+# Function to print an error message\n+function printInfo {\n+  echo [`timestamp`][INFO] $*\n+}\n+\n+# timestamp\n+#   purpose:  echo timestamp in the form yyyymmddThh:mm:ss.mmm ZZZ\n+#   example:  20181001T14:00:00.001 UTC\n+function timestamp() {\n+  local timestamp=\"`date --utc '+%Y-%m-%dT%H:%M:%S %N %s %Z' 2>&1`\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "originalPosition": 577}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNjk0Mzc5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-522694379", "createdAt": "2020-11-03T16:52:56Z", "commit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNjo1Mjo1N1rOHs31vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNjo1Mjo1N1rOHs31vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgxNDI2OQ==", "bodyText": "If the replica count is already maxed out, why not just continue and start the server by unsetting it (e.g. implicitly bringing it to IF_NEEDED)?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516814269", "createdAt": "2020-11-03T16:52:57Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startServer.sh", "diffHunk": "@@ -0,0 +1,255 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+# This script starts a WebLogic managed server in a domain. \n+# Internal code notes :-\n+# - If server start policy is ALWAYS or policy is IF_NEEDED and the server is selected \n+#   to start based on the replica count, it means that server is already started or is\n+#   in the process of starting. In this case, script exits without making any changes.\n+#\n+# - If start policy of servers parent cluster or domain is 'NEVER', script\n+#   fails as server can't be started.\n+#\n+# - If the effective start policy of the server is IF_NEEDED and increasing replica \n+#   count will naturally start the server, the script increases the replica count. \n+#\n+# - If unsetting policy and increasing the replica count will start this server, script unsets\n+#   the policy and increases replica count. For e.g. if replica count is 1 and start policy\n+#   of server2 is NEVER, unsetting policy and increasing replica count will start server2.\n+#\n+# - If option to keep replica count constant ('-k') is selected and unsetting start policy\n+#   will naturally start the server, script will unset the policy. For e.g. if replica count\n+#   is 2 and start policy  of server2 is NEVER, unsetting policy will start server2.\n+#\n+# - If above conditions are not true, it implies that either start policy is NEVER or policy\n+#   is IF_NEEDED but server is not next in the order to start. In this case, script sets start \n+#   policy to ALWAYS. For e.g. replica count is 3 and server10 needs to start. The script also \n+#   increments the replica count by default. If option to keep replica count constant ('-k') \n+#   is selected, it only sets the start policy to ALWAYS.\n+# \n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+if [ \"${debug}\" == \"true\" ]; then set -x; fi;\n+set -eu\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script starts a WebLogic managed server in a domain either by increasing\n+  the value of 'spec.clusters[<cluster-name>].replicas' by '1' or by updating the\n+  'spec.managedServers[<server-name>].serverStartPolicy' attribute of the domain\n+  resource or both as necessary. The 'spec.clusters[<cluster-name>].replicas' value can\n+  be kept constant by using '-k' option. Please see README.md for more details.\n+\n+  Usage:\n+\n+    $(basename $0) -s myserver [-n mynamespace] [-d mydomainuid] [-k] [-m kubecli] [-v]\n+\n+    -s <server_name>           : Server name parameter is required.\n+\n+    -d <domain_uid>            : Domain unique-id. Default is 'sample-domain1'.\n+\n+    -n <namespace>             : Domain namespace. Default is 'sample-domain1-ns'.\n+\n+    -k <keep_replica_constant> : Keep replica count constant. Default behavior is to increment replica count.\n+\n+    -m <kubernetes_cli>        : Kubernetes command line interface. Default is 'kubectl' if KUBERNETES_CLI env\n+                                 variable is not set. Otherwise default is the value of KUBERNETES_CLI env variable.\n+\n+    -v <verbose_mode>          : Enables verbose mode. Default is 'false'.\n+\n+    -h                         : This help.\n+   \n+EOF\n+exit $1\n+}\n+\n+kubernetesCli=${KUBERNETES_CLI:-kubectl}\n+serverName=\"\"\n+clusterName=\"\"\n+domainUid=\"sample-domain1\"\n+domainNamespace=\"sample-domain1-ns\"\n+keepReplicaConstant=false\n+verboseMode=false\n+withReplicas=\"CONSTANT\"\n+withPolicy=\"CONSTANT\"\n+managedServerPolicy=\"\"\n+effectivePolicy=\"\"\n+action=\"\"\n+isValidServer=\"\"\n+patchJson=\"\"\n+serverStarted=\"\"\n+startsByPolicyUnset=\"\"\n+startsByReplicaIncreaseAndPolicyUnset=\"\"\n+\n+while getopts \"vkd:n:m:s:h\" opt; do\n+  case $opt in\n+    s) serverName=\"${OPTARG}\"\n+    ;;\n+    n) domainNamespace=\"${OPTARG}\"\n+    ;;\n+    d) domainUid=\"${OPTARG}\"\n+    ;;\n+    k) keepReplicaConstant=true;\n+    ;;\n+    m) kubernetesCli=\"${OPTARG}\"\n+    ;;\n+    v) verboseMode=true;\n+    ;;\n+    h) usage 0\n+    ;;\n+    *) usage 1\n+    ;;\n+  esac\n+done\n+\n+#\n+# Function to perform validations, read files and initialize workspace\n+#\n+function initialize {\n+\n+  # Validate the required files exist\n+  validateErrors=false\n+\n+  validateKubernetesCliAvailable\n+  validateJqAvailable\n+\n+  # Validate that server name parameter is specified.\n+  if [ -z \"${serverName}\" ]; then\n+    validationError \"Please specify a server name using '-s' parameter e.g. '-s managed-server1'.\"\n+  fi\n+\n+  failIfValidationErrors\n+}\n+\n+initialize\n+\n+# Get the domain in json format\n+domainJson=$(${kubernetesCli} get domain ${domainUid} -n ${domainNamespace} -o json)\n+if [ $? -ne 0 ]; then\n+  printError \"Unable to get domain resource. Please make sure 'domain_uid' and 'namespace' provided with '-d' and '-n' arguments are correct.\"\n+  exit 1\n+fi\n+\n+# Validate that specified server is either part of a cluster or is an independent managed server\n+validateServerAndFindCluster \"${domainUid}\" \"${domainNamespace}\" \"${serverName}\" isValidServer clusterName\n+if [ \"${isValidServer}\" != 'true' ]; then\n+  printError \"Server ${serverName} is not part of any cluster and it's not an independent managed server. Please make sure that server name specified is correct.\"\n+  exit 1\n+fi\n+\n+getClusterPolicy \"${domainJson}\" \"${clusterName}\" clusterPolicy\n+if [ \"${clusterPolicy}\" == 'NEVER' ]; then\n+  printError \"Cannot start server '${serverName}', the server's parent cluster '.spec.clusters[?(clusterName=\\\"${clusterName}\\\"].serverStartPolicy' in the domain resource is set to 'NEVER'.\"\n+  exit 1\n+fi\n+\n+getDomainPolicy \"${domainJson}\" domainPolicy\n+if [ \"${domainPolicy}\" == 'NEVER' ]; then\n+  printError \"Cannot start server '${serverName}', the .spec.serverStartPolicy in the domain resource is set to 'NEVER'.\"\n+  exit 1\n+fi\n+\n+getEffectivePolicy \"${domainJson}\" \"${serverName}\" \"${clusterName}\" effectivePolicy\n+if [ -n \"${clusterName}\" ]; then\n+  # Server is part of a cluster, check currently started servers\n+  checkStartedServers \"${domainJson}\" \"${serverName}\" \"${clusterName}\" \"${withReplicas}\" \"${withPolicy}\" serverStarted\n+  if [[ ${effectivePolicy} == \"IF_NEEDED\" && ${serverStarted} == \"true\" ]]; then\n+    printInfo \"No changes needed, exiting. The server should be already started or it's in the process of starting. The start policy for server ${serverName} is ${effectivePolicy} and server is chosen to be started based on current replica count.\"\n+    exit 0\n+  elif [[ \"${effectivePolicy}\" == \"ALWAYS\" && ${serverStarted} == \"true\" ]]; then\n+    printInfo \"No changes needed, exiting. The server should be already started or it's in the process of starting. The start policy for server ${serverName} is ${effectivePolicy}.\"\n+    exit 0\n+  fi\n+else \n+  # Server is an independent managed server. \n+  if [[ \"${effectivePolicy}\" == \"ALWAYS\" || \"${effectivePolicy}\" == \"IF_NEEDED\" ]]; then\n+    printInfo \"No changes needed, exiting. The server should be already started or it's in the process of starting. The start policy for server ${serverName} is ${effectivePolicy}.\"\n+    exit 0\n+  fi\n+fi\n+\n+getServerPolicy \"${domainJson}\" \"${serverName}\" managedServerPolicy\n+targetPolicy=\"ALWAYS\"\n+createServerStartPolicyPatch \"${domainJson}\" \"${serverName}\" \"${targetPolicy}\" alwaysStartPolicyPatch \n+\n+# if server is part of a cluster and replica count will increase\n+if [[ -n ${clusterName} && \"${keepReplicaConstant}\" != 'true' ]]; then\n+  #check if server starts by increasing replicas and unsetting policy\n+  withReplicas=\"INCREASED\"\n+  withPolicy=\"UNSET\"\n+  checkStartedServers \"${domainJson}\" \"${serverName}\" \"${clusterName}\" \"${withReplicas}\" \"${withPolicy}\" startsByReplicaIncreaseAndPolicyUnset\n+  operation=\"INCREMENT\"\n+  createReplicaPatch \"${domainJson}\" \"${clusterName}\" \"${operation}\" incrementReplicaPatch replicaCount\n+  if [ \"${incrementReplicaPatch}\" == \"MAX_REPLICA_COUNT_EXCEEDED\" ]; then ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "originalPosition": 189}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNzAxMjcz", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-522701273", "createdAt": "2020-11-03T17:00:04Z", "commit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzowMDowNFrOHs4J6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzowMDowNFrOHs4J6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgxOTQzMw==", "bodyText": "else\neval $__isValidCluster=false", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516819433", "createdAt": "2020-11-03T17:00:04Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,606 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value containing cluster level server start policy\n+#\n+function getClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __clusterPolicy=$3\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__clusterPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get server start policy at domain level\n+# $1 - Domain resource in json format\n+# $2 - Return value containing domain level server start policy\n+#\n+function getDomainPolicy {\n+  local domainJson=$1\n+  local __domainPolicy=$2\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\".spec.serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__domainPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get effective start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Name of cluster\n+# $4 - Return value containing effective server start policy\n+#\n+function getEffectivePolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local __currentPolicy=$4\n+  local currentPolicy=\"\"\n+\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentPolicy\n+  if [ -z \"${currentPolicy}\" ]; then\n+    getClusterPolicy \"${domainJson}\" \"${clusterName}\" currentPolicy\n+    if [ -z \"${currentPolicy}\" ]; then\n+      # Start policy is not set at cluster level, check at domain level\n+      getDomainPolicy \"${domainJson}\" currentPolicy\n+      if [ -z \"${currentPolicy}\" ]; then\n+        # Start policy is not set at domain level, default to IF_NEEDED\n+        currentPolicy=IF_NEEDED\n+      fi\n+    fi\n+  fi\n+  eval $__currentPolicy=\"'${currentPolicy}'\"\n+}\n+\n+#\n+# Function to get current start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Return value containing current server start policy\n+#\n+function getServerPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __currentPolicy=$3\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentServerStartPolicy=$(echo ${domainJson} | jq \"${extractPolicyCmd}\")\n+    if [ \"${currentServerStartPolicy}\" == \"null\" ]; then\n+      currentServerStartPolicy=\"\"\n+    fi\n+  fi\n+  eval $__currentPolicy=${currentServerStartPolicy}\n+}\n+\n+#\n+# Function to create server start policy patch string\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Policy value \n+# $4 - Return value containing server start policy patch string\n+#\n+function createServerStartPolicyPatch {\n+  local domainJson=$1\n+  local serverName=$2\n+  local policy=$3\n+  local __result=$4\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentServerStartPolicy\n+  if [ -z \"${currentServerStartPolicy}\" ]; then\n+    # Server start policy doesn't exist, add a new policy\n+    addPolicyCmd=\".[.| length] |= . + {\\\"serverName\\\":\\\"${serverName}\\\", \\\n+      \\\"serverStartPolicy\\\":\\\"${policy}\\\"}\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq .spec.managedServers | jq -c \"${addPolicyCmd}\")\n+  else\n+    # Server start policy exists, replace policy value \n+    replacePolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy) |= \\\"${policy}\\\"\"\n+    servers=\"(.spec.managedServers)\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\" | jq -cr \"${servers}\")\n+  fi\n+  eval $__result=\"'${serverStartPolicyPatch}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy and update replica\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - String containing replica patch string\n+# $4 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicyAndUpdateReplica {\n+  local domainJson=$1\n+  local serverName=$2\n+  local replicaPatch=$3\n+  local __result=$4\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaPatch}\",\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update policy \n+# $1 - String containing start policy info\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdatePolicy {\n+  local startPolicy=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update replica \n+# $1 - String containing replica\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdateReplica {\n+  local replicaInfo=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUpdateReplicaAndPolicy {\n+  local replicaInfo=$1\n+  local startPolicy=$2\n+  local __result=$3\n+\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\",\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __result=$3\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to get sorted list of servers in a cluster.\n+# The sorted list is created in 'sortedByAlwaysServers' array.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if policy of current server would be unset\n+#\n+function getSortedListOfServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withPolicy=$4\n+  local policy=\"\"\n+  local sortedServers=()\n+  local otherServers=()\n+\n+  configMap=$(${kubernetesCli} get cm ${domainUid}-weblogic-domain-introspect-cm \\\n+    -n ${domainNamespace} -o json)\n+  topology=$(echo \"${configMap}\" | jq '.data[\"topology.yaml\"]')\n+  jsonTopology=$(python -c \\\n+    'import sys, yaml, json; print json.dumps(yaml.safe_load('\"${topology}\"'), indent=4)')\n+  clusterTopology=$(echo ${jsonTopology} | jq -r '.domain | .configuredClusters[] | select (.name == '\\\"${clusterName}\\\"')')\n+  dynaCluster=$(echo ${clusterTopology} | jq .dynamicServersConfig)\n+  if [ \"${dynaCluster}\" == \"null\" ]; then\n+    # Cluster is a configured cluster, get server names\n+    servers=($(echo ${clusterTopology} | jq -r .servers[].name))\n+    # Sort server names in numero lexi order\n+    IFS=$'\\n' sortedServers=($(sort --version-sort <<<\"${servers[*]}\" ))\n+    unset IFS\n+    clusterSize=${#sortedServers[@]}\n+  else \n+    # Cluster is a dynamic cluster, calculate server names\n+    prefix=$(echo ${dynaCluster} | jq -r .serverNamePrefix)\n+    clusterSize=$(echo ${dynaCluster} | jq .dynamicClusterSize) \n+    for (( i=1; i<=$clusterSize; i++ )); do\n+      localServerName=${prefix}$i\n+      sortedServers+=(${localServerName})\n+    done\n+  fi\n+  # Create arrays of ALWAYS policy servers and other servers\n+  sortedServersSize=${#sortedServers[@]}\n+  if [ \"${sortedServersSize}\" -gt 0 ]; then\n+    for localServerName in \"${sortedServers[@]}\"; do\n+      getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+      # Update policy when server name matches current server and unsetting\n+      if [[ \"${withPolicy}\" == \"UNSET\" && \"${serverName}\" == \"${localServerName}\" ]]; then\n+        policy=UNSET\n+      fi\n+      if [ \"${policy}\" == \"ALWAYS\" ]; then\n+        sortedByAlwaysServers+=(${localServerName})\n+      else\n+        otherServers+=(${localServerName})\n+      fi\n+    done\n+  fi\n+  \n+  # append other servers to the list of servers with always policy\n+  otherServersSize=${#otherServers[@]}\n+  if [ \"${otherServersSize}\" -gt 0 ]; then\n+    for otherServer in \"${otherServers[@]}\"; do\n+      sortedByAlwaysServers+=($otherServer)\n+    done\n+  fi\n+}\n+\n+#\n+# Get replica count for a cluster\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster \n+# $3 - Return value containing replica count\n+#\n+function getReplicaCount {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __replicaCount=$3\n+\n+  replicasCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).replicas\"\n+  replicaCount=$(echo ${domainJson} | jq \"${replicasCmd}\")\n+  eval $__replicaCount=\"'${replicaCount}'\"\n+\n+}\n+\n+#\n+# Check servers started in a cluster based on server start policy and \n+# replica count.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if replicas will stay constant, incremented or decremented\n+# $5 - Indicates if policy of current server will stay same or unset\n+# $6 - Return value indicating if current server will be started\n+#\n+function checkStartedServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withReplicas=$4\n+  local withPolicy=$5\n+  local __started=$6\n+  local localServerName=\"\"\n+  local policy=\"\"\n+  local replicaCount=0\n+  local currentReplicas=0\n+  local startedServers=()\n+  local sortedByAlwaysServers=()\n+  \n+  # Get sorted list of servers in 'sortedByAlwaysServers' array\n+  getSortedListOfServers \"${domainJson}\" \"${serverName}\" \"${clusterName}\" \"${withPolicy}\"\n+  getReplicaCount \"${domainJson}\" \"${clusterName}\" replicaCount\n+  # Increment or decrement the replica count based on 'withReplicas' input parameter\n+  if [ \"${withReplicas}\" == \"INCREASED\" ]; then\n+    replicaCount=$((replicaCount+1))\n+  elif [ \"${withReplicas}\" == \"DECREASED\" ]; then\n+    replicaCount=$((replicaCount-1))\n+  fi\n+  sortedByAlwaysSize=${#sortedByAlwaysServers[@]}\n+  if [ \"${sortedByAlwaysSize}\" -gt 0 ]; then\n+    for localServerName in \"${sortedByAlwaysServers[@]}\"; do\n+      getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+      # Update policy when server name matches current server and unsetting\n+      if [[ \"${serverName}\" == \"${localServerName}\" && \"${withPolicy}\" == \"UNSET\" ]]; then\n+        policy=UNSET\n+      fi\n+      # check if server should start based on replica count, policy and current replicas\n+      shouldStart \"${currentReplicas}\" \"${policy}\" \"${replicaCount}\" result\n+      if [ \"${result}\" == 'True' ]; then\n+        # server should start, increment current replicas and add server to list of started servers\n+        currentReplicas=$((currentReplicas+1))\n+        startedServers+=(${localServerName})\n+      fi\n+    done\n+  fi\n+  startedSize=${#startedServers[@]}\n+  if [ ${startedSize} -gt 0 ]; then\n+    # check if current server is in the list of started servers\n+    if checkStringInArray ${serverName} ${startedServers[@]}; then\n+      eval $__started=\"true\"\n+      return\n+    fi\n+  fi\n+  eval $__started=\"false\"\n+}\n+\n+#\n+# Function to check if server should start based on policy and current replicas\n+# $1 - Current number of replicas\n+# $2 - Server start policy\n+# $3 - Replica count\n+# $4 - Return value\n+#\n+function shouldStart {\n+  local currentReplicas=$1\n+  local policy=$2\n+  local replicaCount=$3 \n+  local __result=$4\n+\n+  if [ \"$policy\" == \"ALWAYS\" ]; then\n+    eval $__result=True\n+  elif [ \"$policy\" == \"NEVER\" ]; then\n+    eval $__result=False\n+  elif [ \"${currentReplicas}\" -lt \"${replicaCount}\" ]; then\n+    eval $__result=True\n+  else \n+    eval $__result=False\n+  fi\n+}\n+\n+#\n+# Function to create patch string for updating replica count\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster whose replica count will be patched\n+# $3 - operatation string indicating whether to increment or decrement count\n+# $4 - Return value containing replica update patch string\n+# $5 - Retrun value containing updated replica count\n+#\n+function createReplicaPatch {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local operation=$3\n+  local __result=$4\n+  local __replicaCount=$5\n+  local maxReplicas=\"\"\n+  local errorMessage=\"@@ ERROR: Maximum number of servers allowed (maxReplica = ${maxReplicas}) \\\n+are already running. Please increase cluster size to start new servers.\"\n+\n+  replicasCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).replicas\"\n+  maxReplicaCmd=\"(.status.clusters[] | select (.clusterName == \\\"${clusterName}\\\")) \\\n+    | .maximumReplicas\"\n+  replica=$(echo ${domainJson} | jq \"${replicasCmd}\")\n+  if [[ -z \"${replica}\" || \"${replica}\" == \"null\" ]]; then\n+    replica=$(echo ${domainJson} | jq .spec.replicas)\n+  fi\n+  if [ \"${operation}\" == \"DECREMENT\" ]; then\n+    replica=$((replica-1))\n+    if [ ${replica} -lt 0 ]; then\n+      replica=0\n+    fi\n+  elif [ \"${operation}\" == \"INCREMENT\" ]; then\n+    replica=$((replica+1))\n+    maxReplicas=$(echo ${domainJson} | jq \"${maxReplicaCmd}\")\n+    if [ ${replica} -gt ${maxReplicas} ]; then\n+      echo \"${errorMessage}\"\n+      eval $__result=\"MAX_REPLICA_COUNT_EXCEEDED\"\n+      return\n+    fi\n+  fi\n+\n+  cmd=\"(.spec.clusters[] | select (.clusterName == \\\"${clusterName}\\\") \\\n+    | .replicas) |= ${replica}\"\n+  replicaPatch=$(echo ${domainJson} | jq \"${cmd}\" | jq -cr '(.spec.clusters)')\n+  eval $__result=\"'${replicaPatch}'\"\n+  eval $__replicaCount=\"'${replica}'\"\n+}\n+\n+#\n+# Function to validate whether a server belongs to a  cluster or is an independent managed server\n+# $1 - Domain unique id.\n+# $2 - Domain namespace.\n+# $3 - Server name.\n+# $4 - Return value indicating if server is valid (i.e. if it's part of a cluster or independent server).\n+# $5 - Retrun value containting cluster name to which this server belongs.\n+#\n+function validateServerAndFindCluster {\n+  local domainUid=$1\n+  local domainNamespace=$2 \n+  local serverName=$3\n+  local __isValidServer=$4\n+  local __clusterName=$5\n+  local serverCount=\"\"\n+  local errorMessage=\"Server name is outside the range of allowed servers. \\\n+Please make sure server name is correct.\"\n+\n+  configMap=$(${kubernetesCli} get cm ${domainUid}-weblogic-domain-introspect-cm \\\n+    -n ${domainNamespace} -o json)\n+  topology=$(echo \"${configMap}\" | jq '.data[\"topology.yaml\"]')\n+  jsonTopology=$(python -c \\\n+    'import sys, yaml, json; print json.dumps(yaml.safe_load('\"${topology}\"'), indent=4)')\n+  servers=($(echo $jsonTopology | jq -r '.domain.servers[].name'))\n+  if  checkStringInArray \"${serverName}\" \"${servers[@]}\" ; then\n+    eval $__clusterName=\"\"\n+    eval $__isValidServer=true\n+  else\n+    dynamicClause=\".domain.configuredClusters[] | select (.dynamicServersConfig != null)\"\n+    namePrefixSize=\". | {name: .name, prefix:.dynamicServersConfig.serverNamePrefix, \\\n+                 max:.dynamicServersConfig.maxDynamicClusterSize}\"\n+    dynamicClusters=($(echo $jsonTopology | jq \"${dynamicClause}\" | jq -cr \"${namePrefixSize}\"))\n+    dynamicClustersSize=${#dynamicClusters[@]}\n+    if [ \"${dynamicClustersSize}\" -gt 0 ]; then\n+      for dynaClusterNamePrefix in \"${dynamicClusters[@]}\"; do\n+        prefix=$(echo ${dynaClusterNamePrefix} | jq -r .prefix)\n+        if [[ \"${serverName}\" == \"${prefix}\"* ]]; then\n+          maxSize=$(echo ${dynaClusterNamePrefix} | jq -r .max)\n+          number='^[0-9]+$'\n+          if [ $(echo \"${serverName}\" | grep -c -Eo '[0-9]+$') -gt 0 ]; then\n+            serverCount=$(echo \"${serverName}\" | grep -Eo '[0-9]+$')\n+          fi\n+          if ! [[ $serverCount =~ $number ]] ; then\n+             echo \"error: Server name is not valid for dynamic cluster.\" \n+             exit 1\n+          fi\n+          if [ \"${serverCount}\" -gt \"${maxSize}\" ]; then\n+            printError \"${errorMessage}\"\n+            exit 1\n+          fi\n+          eval $__clusterName=\"'$(echo ${dynaClusterNamePrefix} | jq -r .name)'\"\n+          eval $__isValidServer=true\n+          break\n+        fi\n+      done\n+    fi\n+    staticClause=\".domain.configuredClusters[] | select (.dynamicServersConfig == null)\"\n+    nameCmd=\" . | {name: .name, serverName: .servers[].name}\"\n+    configuredClusters=($(echo $jsonTopology | jq \"${staticClause}\" | jq -cr \"${nameCmd}\"))\n+    configuredClusterSize=${#configuredClusters[@]}\n+    if [ \"${configuredClusterSize}\" -gt 0 ]; then\n+      for configuredClusterName in \"${configuredClusters[@]}\"; do\n+        name=$(echo ${configuredClusterName} | jq -r .serverName)\n+        if [ \"${serverName}\" == \"${name}\" ]; then\n+          eval $__clusterName=\"'$(echo ${configuredClusterName} | jq -r .name)'\"\n+          eval $__isValidServer=true\n+          break\n+        fi\n+      done\n+    fi\n+  fi\n+}\n+\n+#\n+# Function to validate whether a cluster is valid and part of the domain\n+# $1 - Domain unique id.\n+# $2 - Domain namespace.\n+# $3 - cluster name\n+# $4 - Retrun value indicating whether cluster name is valid\n+#\n+function validateClusterName {\n+  local domainUid=$1\n+  local domainNamespace=$2\n+  local clusterName=$3\n+  local __isValidCluster=$4\n+\n+  configMap=$(${kubernetesCli} get cm ${domainUid}-weblogic-domain-introspect-cm \\\n+    -n ${domainNamespace} -o json)\n+  topology=$(echo \"${configMap}\" | jq '.data[\"topology.yaml\"]')\n+  jsonTopology=$(python -c \\\n+    'import sys, yaml, json; print json.dumps(yaml.safe_load('\"${topology}\"'), indent=4)')\n+  clusters=($(echo $jsonTopology | jq -cr .domain.configuredClusters[].name))\n+  if  checkStringInArray \"${clusterName}\" \"${clusters[@]}\" ; then\n+    eval $__isValidCluster=true", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "originalPosition": 517}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNzAzMTEx", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-522703111", "createdAt": "2020-11-03T17:02:03Z", "commit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzowMjowM1rOHs4PQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzowMjowM1rOHs4PQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgyMDgwMg==", "bodyText": "It's more clear if script set variables on failure too, so at start could do something like:\neval $__isValidServer=false\neval $__clusterName=UNKNOWN", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516820802", "createdAt": "2020-11-03T17:02:03Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,606 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value containing cluster level server start policy\n+#\n+function getClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __clusterPolicy=$3\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__clusterPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get server start policy at domain level\n+# $1 - Domain resource in json format\n+# $2 - Return value containing domain level server start policy\n+#\n+function getDomainPolicy {\n+  local domainJson=$1\n+  local __domainPolicy=$2\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\".spec.serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__domainPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get effective start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Name of cluster\n+# $4 - Return value containing effective server start policy\n+#\n+function getEffectivePolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local __currentPolicy=$4\n+  local currentPolicy=\"\"\n+\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentPolicy\n+  if [ -z \"${currentPolicy}\" ]; then\n+    getClusterPolicy \"${domainJson}\" \"${clusterName}\" currentPolicy\n+    if [ -z \"${currentPolicy}\" ]; then\n+      # Start policy is not set at cluster level, check at domain level\n+      getDomainPolicy \"${domainJson}\" currentPolicy\n+      if [ -z \"${currentPolicy}\" ]; then\n+        # Start policy is not set at domain level, default to IF_NEEDED\n+        currentPolicy=IF_NEEDED\n+      fi\n+    fi\n+  fi\n+  eval $__currentPolicy=\"'${currentPolicy}'\"\n+}\n+\n+#\n+# Function to get current start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Return value containing current server start policy\n+#\n+function getServerPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __currentPolicy=$3\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentServerStartPolicy=$(echo ${domainJson} | jq \"${extractPolicyCmd}\")\n+    if [ \"${currentServerStartPolicy}\" == \"null\" ]; then\n+      currentServerStartPolicy=\"\"\n+    fi\n+  fi\n+  eval $__currentPolicy=${currentServerStartPolicy}\n+}\n+\n+#\n+# Function to create server start policy patch string\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Policy value \n+# $4 - Return value containing server start policy patch string\n+#\n+function createServerStartPolicyPatch {\n+  local domainJson=$1\n+  local serverName=$2\n+  local policy=$3\n+  local __result=$4\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentServerStartPolicy\n+  if [ -z \"${currentServerStartPolicy}\" ]; then\n+    # Server start policy doesn't exist, add a new policy\n+    addPolicyCmd=\".[.| length] |= . + {\\\"serverName\\\":\\\"${serverName}\\\", \\\n+      \\\"serverStartPolicy\\\":\\\"${policy}\\\"}\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq .spec.managedServers | jq -c \"${addPolicyCmd}\")\n+  else\n+    # Server start policy exists, replace policy value \n+    replacePolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy) |= \\\"${policy}\\\"\"\n+    servers=\"(.spec.managedServers)\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\" | jq -cr \"${servers}\")\n+  fi\n+  eval $__result=\"'${serverStartPolicyPatch}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy and update replica\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - String containing replica patch string\n+# $4 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicyAndUpdateReplica {\n+  local domainJson=$1\n+  local serverName=$2\n+  local replicaPatch=$3\n+  local __result=$4\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaPatch}\",\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update policy \n+# $1 - String containing start policy info\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdatePolicy {\n+  local startPolicy=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update replica \n+# $1 - String containing replica\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdateReplica {\n+  local replicaInfo=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUpdateReplicaAndPolicy {\n+  local replicaInfo=$1\n+  local startPolicy=$2\n+  local __result=$3\n+\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\",\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __result=$3\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to get sorted list of servers in a cluster.\n+# The sorted list is created in 'sortedByAlwaysServers' array.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if policy of current server would be unset\n+#\n+function getSortedListOfServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withPolicy=$4\n+  local policy=\"\"\n+  local sortedServers=()\n+  local otherServers=()\n+\n+  configMap=$(${kubernetesCli} get cm ${domainUid}-weblogic-domain-introspect-cm \\\n+    -n ${domainNamespace} -o json)\n+  topology=$(echo \"${configMap}\" | jq '.data[\"topology.yaml\"]')\n+  jsonTopology=$(python -c \\\n+    'import sys, yaml, json; print json.dumps(yaml.safe_load('\"${topology}\"'), indent=4)')\n+  clusterTopology=$(echo ${jsonTopology} | jq -r '.domain | .configuredClusters[] | select (.name == '\\\"${clusterName}\\\"')')\n+  dynaCluster=$(echo ${clusterTopology} | jq .dynamicServersConfig)\n+  if [ \"${dynaCluster}\" == \"null\" ]; then\n+    # Cluster is a configured cluster, get server names\n+    servers=($(echo ${clusterTopology} | jq -r .servers[].name))\n+    # Sort server names in numero lexi order\n+    IFS=$'\\n' sortedServers=($(sort --version-sort <<<\"${servers[*]}\" ))\n+    unset IFS\n+    clusterSize=${#sortedServers[@]}\n+  else \n+    # Cluster is a dynamic cluster, calculate server names\n+    prefix=$(echo ${dynaCluster} | jq -r .serverNamePrefix)\n+    clusterSize=$(echo ${dynaCluster} | jq .dynamicClusterSize) \n+    for (( i=1; i<=$clusterSize; i++ )); do\n+      localServerName=${prefix}$i\n+      sortedServers+=(${localServerName})\n+    done\n+  fi\n+  # Create arrays of ALWAYS policy servers and other servers\n+  sortedServersSize=${#sortedServers[@]}\n+  if [ \"${sortedServersSize}\" -gt 0 ]; then\n+    for localServerName in \"${sortedServers[@]}\"; do\n+      getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+      # Update policy when server name matches current server and unsetting\n+      if [[ \"${withPolicy}\" == \"UNSET\" && \"${serverName}\" == \"${localServerName}\" ]]; then\n+        policy=UNSET\n+      fi\n+      if [ \"${policy}\" == \"ALWAYS\" ]; then\n+        sortedByAlwaysServers+=(${localServerName})\n+      else\n+        otherServers+=(${localServerName})\n+      fi\n+    done\n+  fi\n+  \n+  # append other servers to the list of servers with always policy\n+  otherServersSize=${#otherServers[@]}\n+  if [ \"${otherServersSize}\" -gt 0 ]; then\n+    for otherServer in \"${otherServers[@]}\"; do\n+      sortedByAlwaysServers+=($otherServer)\n+    done\n+  fi\n+}\n+\n+#\n+# Get replica count for a cluster\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster \n+# $3 - Return value containing replica count\n+#\n+function getReplicaCount {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __replicaCount=$3\n+\n+  replicasCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).replicas\"\n+  replicaCount=$(echo ${domainJson} | jq \"${replicasCmd}\")\n+  eval $__replicaCount=\"'${replicaCount}'\"\n+\n+}\n+\n+#\n+# Check servers started in a cluster based on server start policy and \n+# replica count.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if replicas will stay constant, incremented or decremented\n+# $5 - Indicates if policy of current server will stay same or unset\n+# $6 - Return value indicating if current server will be started\n+#\n+function checkStartedServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withReplicas=$4\n+  local withPolicy=$5\n+  local __started=$6\n+  local localServerName=\"\"\n+  local policy=\"\"\n+  local replicaCount=0\n+  local currentReplicas=0\n+  local startedServers=()\n+  local sortedByAlwaysServers=()\n+  \n+  # Get sorted list of servers in 'sortedByAlwaysServers' array\n+  getSortedListOfServers \"${domainJson}\" \"${serverName}\" \"${clusterName}\" \"${withPolicy}\"\n+  getReplicaCount \"${domainJson}\" \"${clusterName}\" replicaCount\n+  # Increment or decrement the replica count based on 'withReplicas' input parameter\n+  if [ \"${withReplicas}\" == \"INCREASED\" ]; then\n+    replicaCount=$((replicaCount+1))\n+  elif [ \"${withReplicas}\" == \"DECREASED\" ]; then\n+    replicaCount=$((replicaCount-1))\n+  fi\n+  sortedByAlwaysSize=${#sortedByAlwaysServers[@]}\n+  if [ \"${sortedByAlwaysSize}\" -gt 0 ]; then\n+    for localServerName in \"${sortedByAlwaysServers[@]}\"; do\n+      getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+      # Update policy when server name matches current server and unsetting\n+      if [[ \"${serverName}\" == \"${localServerName}\" && \"${withPolicy}\" == \"UNSET\" ]]; then\n+        policy=UNSET\n+      fi\n+      # check if server should start based on replica count, policy and current replicas\n+      shouldStart \"${currentReplicas}\" \"${policy}\" \"${replicaCount}\" result\n+      if [ \"${result}\" == 'True' ]; then\n+        # server should start, increment current replicas and add server to list of started servers\n+        currentReplicas=$((currentReplicas+1))\n+        startedServers+=(${localServerName})\n+      fi\n+    done\n+  fi\n+  startedSize=${#startedServers[@]}\n+  if [ ${startedSize} -gt 0 ]; then\n+    # check if current server is in the list of started servers\n+    if checkStringInArray ${serverName} ${startedServers[@]}; then\n+      eval $__started=\"true\"\n+      return\n+    fi\n+  fi\n+  eval $__started=\"false\"\n+}\n+\n+#\n+# Function to check if server should start based on policy and current replicas\n+# $1 - Current number of replicas\n+# $2 - Server start policy\n+# $3 - Replica count\n+# $4 - Return value\n+#\n+function shouldStart {\n+  local currentReplicas=$1\n+  local policy=$2\n+  local replicaCount=$3 \n+  local __result=$4\n+\n+  if [ \"$policy\" == \"ALWAYS\" ]; then\n+    eval $__result=True\n+  elif [ \"$policy\" == \"NEVER\" ]; then\n+    eval $__result=False\n+  elif [ \"${currentReplicas}\" -lt \"${replicaCount}\" ]; then\n+    eval $__result=True\n+  else \n+    eval $__result=False\n+  fi\n+}\n+\n+#\n+# Function to create patch string for updating replica count\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster whose replica count will be patched\n+# $3 - operatation string indicating whether to increment or decrement count\n+# $4 - Return value containing replica update patch string\n+# $5 - Retrun value containing updated replica count\n+#\n+function createReplicaPatch {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local operation=$3\n+  local __result=$4\n+  local __replicaCount=$5\n+  local maxReplicas=\"\"\n+  local errorMessage=\"@@ ERROR: Maximum number of servers allowed (maxReplica = ${maxReplicas}) \\\n+are already running. Please increase cluster size to start new servers.\"\n+\n+  replicasCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).replicas\"\n+  maxReplicaCmd=\"(.status.clusters[] | select (.clusterName == \\\"${clusterName}\\\")) \\\n+    | .maximumReplicas\"\n+  replica=$(echo ${domainJson} | jq \"${replicasCmd}\")\n+  if [[ -z \"${replica}\" || \"${replica}\" == \"null\" ]]; then\n+    replica=$(echo ${domainJson} | jq .spec.replicas)\n+  fi\n+  if [ \"${operation}\" == \"DECREMENT\" ]; then\n+    replica=$((replica-1))\n+    if [ ${replica} -lt 0 ]; then\n+      replica=0\n+    fi\n+  elif [ \"${operation}\" == \"INCREMENT\" ]; then\n+    replica=$((replica+1))\n+    maxReplicas=$(echo ${domainJson} | jq \"${maxReplicaCmd}\")\n+    if [ ${replica} -gt ${maxReplicas} ]; then\n+      echo \"${errorMessage}\"\n+      eval $__result=\"MAX_REPLICA_COUNT_EXCEEDED\"\n+      return\n+    fi\n+  fi\n+\n+  cmd=\"(.spec.clusters[] | select (.clusterName == \\\"${clusterName}\\\") \\\n+    | .replicas) |= ${replica}\"\n+  replicaPatch=$(echo ${domainJson} | jq \"${cmd}\" | jq -cr '(.spec.clusters)')\n+  eval $__result=\"'${replicaPatch}'\"\n+  eval $__replicaCount=\"'${replica}'\"\n+}\n+\n+#\n+# Function to validate whether a server belongs to a  cluster or is an independent managed server\n+# $1 - Domain unique id.\n+# $2 - Domain namespace.\n+# $3 - Server name.\n+# $4 - Return value indicating if server is valid (i.e. if it's part of a cluster or independent server).\n+# $5 - Retrun value containting cluster name to which this server belongs.\n+#\n+function validateServerAndFindCluster {\n+  local domainUid=$1\n+  local domainNamespace=$2 \n+  local serverName=$3\n+  local __isValidServer=$4\n+  local __clusterName=$5\n+  local serverCount=\"\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "originalPosition": 438}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNzA1MzE2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-522705316", "createdAt": "2020-11-03T17:04:34Z", "commit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzowNDozNFrOHs4Vtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzowNDozNFrOHs4Vtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgyMjQ1NQ==", "bodyText": "document here that $3 should INCREMENT or DECREMENT", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516822455", "createdAt": "2020-11-03T17:04:34Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,606 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value containing cluster level server start policy\n+#\n+function getClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __clusterPolicy=$3\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__clusterPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get server start policy at domain level\n+# $1 - Domain resource in json format\n+# $2 - Return value containing domain level server start policy\n+#\n+function getDomainPolicy {\n+  local domainJson=$1\n+  local __domainPolicy=$2\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\".spec.serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__domainPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get effective start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Name of cluster\n+# $4 - Return value containing effective server start policy\n+#\n+function getEffectivePolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local __currentPolicy=$4\n+  local currentPolicy=\"\"\n+\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentPolicy\n+  if [ -z \"${currentPolicy}\" ]; then\n+    getClusterPolicy \"${domainJson}\" \"${clusterName}\" currentPolicy\n+    if [ -z \"${currentPolicy}\" ]; then\n+      # Start policy is not set at cluster level, check at domain level\n+      getDomainPolicy \"${domainJson}\" currentPolicy\n+      if [ -z \"${currentPolicy}\" ]; then\n+        # Start policy is not set at domain level, default to IF_NEEDED\n+        currentPolicy=IF_NEEDED\n+      fi\n+    fi\n+  fi\n+  eval $__currentPolicy=\"'${currentPolicy}'\"\n+}\n+\n+#\n+# Function to get current start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Return value containing current server start policy\n+#\n+function getServerPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __currentPolicy=$3\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentServerStartPolicy=$(echo ${domainJson} | jq \"${extractPolicyCmd}\")\n+    if [ \"${currentServerStartPolicy}\" == \"null\" ]; then\n+      currentServerStartPolicy=\"\"\n+    fi\n+  fi\n+  eval $__currentPolicy=${currentServerStartPolicy}\n+}\n+\n+#\n+# Function to create server start policy patch string\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Policy value \n+# $4 - Return value containing server start policy patch string\n+#\n+function createServerStartPolicyPatch {\n+  local domainJson=$1\n+  local serverName=$2\n+  local policy=$3\n+  local __result=$4\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentServerStartPolicy\n+  if [ -z \"${currentServerStartPolicy}\" ]; then\n+    # Server start policy doesn't exist, add a new policy\n+    addPolicyCmd=\".[.| length] |= . + {\\\"serverName\\\":\\\"${serverName}\\\", \\\n+      \\\"serverStartPolicy\\\":\\\"${policy}\\\"}\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq .spec.managedServers | jq -c \"${addPolicyCmd}\")\n+  else\n+    # Server start policy exists, replace policy value \n+    replacePolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy) |= \\\"${policy}\\\"\"\n+    servers=\"(.spec.managedServers)\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\" | jq -cr \"${servers}\")\n+  fi\n+  eval $__result=\"'${serverStartPolicyPatch}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy and update replica\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - String containing replica patch string\n+# $4 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicyAndUpdateReplica {\n+  local domainJson=$1\n+  local serverName=$2\n+  local replicaPatch=$3\n+  local __result=$4\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaPatch}\",\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update policy \n+# $1 - String containing start policy info\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdatePolicy {\n+  local startPolicy=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update replica \n+# $1 - String containing replica\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdateReplica {\n+  local replicaInfo=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUpdateReplicaAndPolicy {\n+  local replicaInfo=$1\n+  local startPolicy=$2\n+  local __result=$3\n+\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\",\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __result=$3\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to get sorted list of servers in a cluster.\n+# The sorted list is created in 'sortedByAlwaysServers' array.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if policy of current server would be unset\n+#\n+function getSortedListOfServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withPolicy=$4\n+  local policy=\"\"\n+  local sortedServers=()\n+  local otherServers=()\n+\n+  configMap=$(${kubernetesCli} get cm ${domainUid}-weblogic-domain-introspect-cm \\\n+    -n ${domainNamespace} -o json)\n+  topology=$(echo \"${configMap}\" | jq '.data[\"topology.yaml\"]')\n+  jsonTopology=$(python -c \\\n+    'import sys, yaml, json; print json.dumps(yaml.safe_load('\"${topology}\"'), indent=4)')\n+  clusterTopology=$(echo ${jsonTopology} | jq -r '.domain | .configuredClusters[] | select (.name == '\\\"${clusterName}\\\"')')\n+  dynaCluster=$(echo ${clusterTopology} | jq .dynamicServersConfig)\n+  if [ \"${dynaCluster}\" == \"null\" ]; then\n+    # Cluster is a configured cluster, get server names\n+    servers=($(echo ${clusterTopology} | jq -r .servers[].name))\n+    # Sort server names in numero lexi order\n+    IFS=$'\\n' sortedServers=($(sort --version-sort <<<\"${servers[*]}\" ))\n+    unset IFS\n+    clusterSize=${#sortedServers[@]}\n+  else \n+    # Cluster is a dynamic cluster, calculate server names\n+    prefix=$(echo ${dynaCluster} | jq -r .serverNamePrefix)\n+    clusterSize=$(echo ${dynaCluster} | jq .dynamicClusterSize) \n+    for (( i=1; i<=$clusterSize; i++ )); do\n+      localServerName=${prefix}$i\n+      sortedServers+=(${localServerName})\n+    done\n+  fi\n+  # Create arrays of ALWAYS policy servers and other servers\n+  sortedServersSize=${#sortedServers[@]}\n+  if [ \"${sortedServersSize}\" -gt 0 ]; then\n+    for localServerName in \"${sortedServers[@]}\"; do\n+      getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+      # Update policy when server name matches current server and unsetting\n+      if [[ \"${withPolicy}\" == \"UNSET\" && \"${serverName}\" == \"${localServerName}\" ]]; then\n+        policy=UNSET\n+      fi\n+      if [ \"${policy}\" == \"ALWAYS\" ]; then\n+        sortedByAlwaysServers+=(${localServerName})\n+      else\n+        otherServers+=(${localServerName})\n+      fi\n+    done\n+  fi\n+  \n+  # append other servers to the list of servers with always policy\n+  otherServersSize=${#otherServers[@]}\n+  if [ \"${otherServersSize}\" -gt 0 ]; then\n+    for otherServer in \"${otherServers[@]}\"; do\n+      sortedByAlwaysServers+=($otherServer)\n+    done\n+  fi\n+}\n+\n+#\n+# Get replica count for a cluster\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster \n+# $3 - Return value containing replica count\n+#\n+function getReplicaCount {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __replicaCount=$3\n+\n+  replicasCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).replicas\"\n+  replicaCount=$(echo ${domainJson} | jq \"${replicasCmd}\")\n+  eval $__replicaCount=\"'${replicaCount}'\"\n+\n+}\n+\n+#\n+# Check servers started in a cluster based on server start policy and \n+# replica count.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if replicas will stay constant, incremented or decremented\n+# $5 - Indicates if policy of current server will stay same or unset\n+# $6 - Return value indicating if current server will be started\n+#\n+function checkStartedServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withReplicas=$4\n+  local withPolicy=$5\n+  local __started=$6\n+  local localServerName=\"\"\n+  local policy=\"\"\n+  local replicaCount=0\n+  local currentReplicas=0\n+  local startedServers=()\n+  local sortedByAlwaysServers=()\n+  \n+  # Get sorted list of servers in 'sortedByAlwaysServers' array\n+  getSortedListOfServers \"${domainJson}\" \"${serverName}\" \"${clusterName}\" \"${withPolicy}\"\n+  getReplicaCount \"${domainJson}\" \"${clusterName}\" replicaCount\n+  # Increment or decrement the replica count based on 'withReplicas' input parameter\n+  if [ \"${withReplicas}\" == \"INCREASED\" ]; then\n+    replicaCount=$((replicaCount+1))\n+  elif [ \"${withReplicas}\" == \"DECREASED\" ]; then\n+    replicaCount=$((replicaCount-1))\n+  fi\n+  sortedByAlwaysSize=${#sortedByAlwaysServers[@]}\n+  if [ \"${sortedByAlwaysSize}\" -gt 0 ]; then\n+    for localServerName in \"${sortedByAlwaysServers[@]}\"; do\n+      getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+      # Update policy when server name matches current server and unsetting\n+      if [[ \"${serverName}\" == \"${localServerName}\" && \"${withPolicy}\" == \"UNSET\" ]]; then\n+        policy=UNSET\n+      fi\n+      # check if server should start based on replica count, policy and current replicas\n+      shouldStart \"${currentReplicas}\" \"${policy}\" \"${replicaCount}\" result\n+      if [ \"${result}\" == 'True' ]; then\n+        # server should start, increment current replicas and add server to list of started servers\n+        currentReplicas=$((currentReplicas+1))\n+        startedServers+=(${localServerName})\n+      fi\n+    done\n+  fi\n+  startedSize=${#startedServers[@]}\n+  if [ ${startedSize} -gt 0 ]; then\n+    # check if current server is in the list of started servers\n+    if checkStringInArray ${serverName} ${startedServers[@]}; then\n+      eval $__started=\"true\"\n+      return\n+    fi\n+  fi\n+  eval $__started=\"false\"\n+}\n+\n+#\n+# Function to check if server should start based on policy and current replicas\n+# $1 - Current number of replicas\n+# $2 - Server start policy\n+# $3 - Replica count\n+# $4 - Return value\n+#\n+function shouldStart {\n+  local currentReplicas=$1\n+  local policy=$2\n+  local replicaCount=$3 \n+  local __result=$4\n+\n+  if [ \"$policy\" == \"ALWAYS\" ]; then\n+    eval $__result=True\n+  elif [ \"$policy\" == \"NEVER\" ]; then\n+    eval $__result=False\n+  elif [ \"${currentReplicas}\" -lt \"${replicaCount}\" ]; then\n+    eval $__result=True\n+  else \n+    eval $__result=False\n+  fi\n+}\n+\n+#\n+# Function to create patch string for updating replica count\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster whose replica count will be patched\n+# $3 - operatation string indicating whether to increment or decrement count", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "originalPosition": 380}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNzA1ODI5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-522705829", "createdAt": "2020-11-03T17:05:11Z", "commit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzowNToxMVrOHs4XTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzowNToxMVrOHs4XTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgyMjg2Mw==", "bodyText": "Document the expected return values after a failure", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516822863", "createdAt": "2020-11-03T17:05:11Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,606 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value containing cluster level server start policy\n+#\n+function getClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __clusterPolicy=$3\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__clusterPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get server start policy at domain level\n+# $1 - Domain resource in json format\n+# $2 - Return value containing domain level server start policy\n+#\n+function getDomainPolicy {\n+  local domainJson=$1\n+  local __domainPolicy=$2\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\".spec.serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__domainPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get effective start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Name of cluster\n+# $4 - Return value containing effective server start policy\n+#\n+function getEffectivePolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local __currentPolicy=$4\n+  local currentPolicy=\"\"\n+\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentPolicy\n+  if [ -z \"${currentPolicy}\" ]; then\n+    getClusterPolicy \"${domainJson}\" \"${clusterName}\" currentPolicy\n+    if [ -z \"${currentPolicy}\" ]; then\n+      # Start policy is not set at cluster level, check at domain level\n+      getDomainPolicy \"${domainJson}\" currentPolicy\n+      if [ -z \"${currentPolicy}\" ]; then\n+        # Start policy is not set at domain level, default to IF_NEEDED\n+        currentPolicy=IF_NEEDED\n+      fi\n+    fi\n+  fi\n+  eval $__currentPolicy=\"'${currentPolicy}'\"\n+}\n+\n+#\n+# Function to get current start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Return value containing current server start policy\n+#\n+function getServerPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __currentPolicy=$3\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentServerStartPolicy=$(echo ${domainJson} | jq \"${extractPolicyCmd}\")\n+    if [ \"${currentServerStartPolicy}\" == \"null\" ]; then\n+      currentServerStartPolicy=\"\"\n+    fi\n+  fi\n+  eval $__currentPolicy=${currentServerStartPolicy}\n+}\n+\n+#\n+# Function to create server start policy patch string\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Policy value \n+# $4 - Return value containing server start policy patch string\n+#\n+function createServerStartPolicyPatch {\n+  local domainJson=$1\n+  local serverName=$2\n+  local policy=$3\n+  local __result=$4\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentServerStartPolicy\n+  if [ -z \"${currentServerStartPolicy}\" ]; then\n+    # Server start policy doesn't exist, add a new policy\n+    addPolicyCmd=\".[.| length] |= . + {\\\"serverName\\\":\\\"${serverName}\\\", \\\n+      \\\"serverStartPolicy\\\":\\\"${policy}\\\"}\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq .spec.managedServers | jq -c \"${addPolicyCmd}\")\n+  else\n+    # Server start policy exists, replace policy value \n+    replacePolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy) |= \\\"${policy}\\\"\"\n+    servers=\"(.spec.managedServers)\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\" | jq -cr \"${servers}\")\n+  fi\n+  eval $__result=\"'${serverStartPolicyPatch}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy and update replica\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - String containing replica patch string\n+# $4 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicyAndUpdateReplica {\n+  local domainJson=$1\n+  local serverName=$2\n+  local replicaPatch=$3\n+  local __result=$4\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaPatch}\",\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update policy \n+# $1 - String containing start policy info\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdatePolicy {\n+  local startPolicy=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update replica \n+# $1 - String containing replica\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdateReplica {\n+  local replicaInfo=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUpdateReplicaAndPolicy {\n+  local replicaInfo=$1\n+  local startPolicy=$2\n+  local __result=$3\n+\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\",\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __result=$3\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to get sorted list of servers in a cluster.\n+# The sorted list is created in 'sortedByAlwaysServers' array.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if policy of current server would be unset\n+#\n+function getSortedListOfServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withPolicy=$4\n+  local policy=\"\"\n+  local sortedServers=()\n+  local otherServers=()\n+\n+  configMap=$(${kubernetesCli} get cm ${domainUid}-weblogic-domain-introspect-cm \\\n+    -n ${domainNamespace} -o json)\n+  topology=$(echo \"${configMap}\" | jq '.data[\"topology.yaml\"]')\n+  jsonTopology=$(python -c \\\n+    'import sys, yaml, json; print json.dumps(yaml.safe_load('\"${topology}\"'), indent=4)')\n+  clusterTopology=$(echo ${jsonTopology} | jq -r '.domain | .configuredClusters[] | select (.name == '\\\"${clusterName}\\\"')')\n+  dynaCluster=$(echo ${clusterTopology} | jq .dynamicServersConfig)\n+  if [ \"${dynaCluster}\" == \"null\" ]; then\n+    # Cluster is a configured cluster, get server names\n+    servers=($(echo ${clusterTopology} | jq -r .servers[].name))\n+    # Sort server names in numero lexi order\n+    IFS=$'\\n' sortedServers=($(sort --version-sort <<<\"${servers[*]}\" ))\n+    unset IFS\n+    clusterSize=${#sortedServers[@]}\n+  else \n+    # Cluster is a dynamic cluster, calculate server names\n+    prefix=$(echo ${dynaCluster} | jq -r .serverNamePrefix)\n+    clusterSize=$(echo ${dynaCluster} | jq .dynamicClusterSize) \n+    for (( i=1; i<=$clusterSize; i++ )); do\n+      localServerName=${prefix}$i\n+      sortedServers+=(${localServerName})\n+    done\n+  fi\n+  # Create arrays of ALWAYS policy servers and other servers\n+  sortedServersSize=${#sortedServers[@]}\n+  if [ \"${sortedServersSize}\" -gt 0 ]; then\n+    for localServerName in \"${sortedServers[@]}\"; do\n+      getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+      # Update policy when server name matches current server and unsetting\n+      if [[ \"${withPolicy}\" == \"UNSET\" && \"${serverName}\" == \"${localServerName}\" ]]; then\n+        policy=UNSET\n+      fi\n+      if [ \"${policy}\" == \"ALWAYS\" ]; then\n+        sortedByAlwaysServers+=(${localServerName})\n+      else\n+        otherServers+=(${localServerName})\n+      fi\n+    done\n+  fi\n+  \n+  # append other servers to the list of servers with always policy\n+  otherServersSize=${#otherServers[@]}\n+  if [ \"${otherServersSize}\" -gt 0 ]; then\n+    for otherServer in \"${otherServers[@]}\"; do\n+      sortedByAlwaysServers+=($otherServer)\n+    done\n+  fi\n+}\n+\n+#\n+# Get replica count for a cluster\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster \n+# $3 - Return value containing replica count\n+#\n+function getReplicaCount {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __replicaCount=$3\n+\n+  replicasCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).replicas\"\n+  replicaCount=$(echo ${domainJson} | jq \"${replicasCmd}\")\n+  eval $__replicaCount=\"'${replicaCount}'\"\n+\n+}\n+\n+#\n+# Check servers started in a cluster based on server start policy and \n+# replica count.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if replicas will stay constant, incremented or decremented\n+# $5 - Indicates if policy of current server will stay same or unset\n+# $6 - Return value indicating if current server will be started\n+#\n+function checkStartedServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withReplicas=$4\n+  local withPolicy=$5\n+  local __started=$6\n+  local localServerName=\"\"\n+  local policy=\"\"\n+  local replicaCount=0\n+  local currentReplicas=0\n+  local startedServers=()\n+  local sortedByAlwaysServers=()\n+  \n+  # Get sorted list of servers in 'sortedByAlwaysServers' array\n+  getSortedListOfServers \"${domainJson}\" \"${serverName}\" \"${clusterName}\" \"${withPolicy}\"\n+  getReplicaCount \"${domainJson}\" \"${clusterName}\" replicaCount\n+  # Increment or decrement the replica count based on 'withReplicas' input parameter\n+  if [ \"${withReplicas}\" == \"INCREASED\" ]; then\n+    replicaCount=$((replicaCount+1))\n+  elif [ \"${withReplicas}\" == \"DECREASED\" ]; then\n+    replicaCount=$((replicaCount-1))\n+  fi\n+  sortedByAlwaysSize=${#sortedByAlwaysServers[@]}\n+  if [ \"${sortedByAlwaysSize}\" -gt 0 ]; then\n+    for localServerName in \"${sortedByAlwaysServers[@]}\"; do\n+      getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+      # Update policy when server name matches current server and unsetting\n+      if [[ \"${serverName}\" == \"${localServerName}\" && \"${withPolicy}\" == \"UNSET\" ]]; then\n+        policy=UNSET\n+      fi\n+      # check if server should start based on replica count, policy and current replicas\n+      shouldStart \"${currentReplicas}\" \"${policy}\" \"${replicaCount}\" result\n+      if [ \"${result}\" == 'True' ]; then\n+        # server should start, increment current replicas and add server to list of started servers\n+        currentReplicas=$((currentReplicas+1))\n+        startedServers+=(${localServerName})\n+      fi\n+    done\n+  fi\n+  startedSize=${#startedServers[@]}\n+  if [ ${startedSize} -gt 0 ]; then\n+    # check if current server is in the list of started servers\n+    if checkStringInArray ${serverName} ${startedServers[@]}; then\n+      eval $__started=\"true\"\n+      return\n+    fi\n+  fi\n+  eval $__started=\"false\"\n+}\n+\n+#\n+# Function to check if server should start based on policy and current replicas\n+# $1 - Current number of replicas\n+# $2 - Server start policy\n+# $3 - Replica count\n+# $4 - Return value\n+#\n+function shouldStart {\n+  local currentReplicas=$1\n+  local policy=$2\n+  local replicaCount=$3 \n+  local __result=$4\n+\n+  if [ \"$policy\" == \"ALWAYS\" ]; then\n+    eval $__result=True\n+  elif [ \"$policy\" == \"NEVER\" ]; then\n+    eval $__result=False\n+  elif [ \"${currentReplicas}\" -lt \"${replicaCount}\" ]; then\n+    eval $__result=True\n+  else \n+    eval $__result=False\n+  fi\n+}\n+\n+#\n+# Function to create patch string for updating replica count\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster whose replica count will be patched\n+# $3 - operatation string indicating whether to increment or decrement count\n+# $4 - Return value containing replica update patch string\n+# $5 - Retrun value containing updated replica count", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "originalPosition": 382}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNzA5NjM5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-522709639", "createdAt": "2020-11-03T17:09:40Z", "commit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzowOTo0MFrOHs4igw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzowOTo0MFrOHs4igw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgyNTczMQ==", "bodyText": "Document that should be either UNSET or CONSTANT", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516825731", "createdAt": "2020-11-03T17:09:40Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,606 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value containing cluster level server start policy\n+#\n+function getClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __clusterPolicy=$3\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__clusterPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get server start policy at domain level\n+# $1 - Domain resource in json format\n+# $2 - Return value containing domain level server start policy\n+#\n+function getDomainPolicy {\n+  local domainJson=$1\n+  local __domainPolicy=$2\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\".spec.serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__domainPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get effective start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Name of cluster\n+# $4 - Return value containing effective server start policy\n+#\n+function getEffectivePolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local __currentPolicy=$4\n+  local currentPolicy=\"\"\n+\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentPolicy\n+  if [ -z \"${currentPolicy}\" ]; then\n+    getClusterPolicy \"${domainJson}\" \"${clusterName}\" currentPolicy\n+    if [ -z \"${currentPolicy}\" ]; then\n+      # Start policy is not set at cluster level, check at domain level\n+      getDomainPolicy \"${domainJson}\" currentPolicy\n+      if [ -z \"${currentPolicy}\" ]; then\n+        # Start policy is not set at domain level, default to IF_NEEDED\n+        currentPolicy=IF_NEEDED\n+      fi\n+    fi\n+  fi\n+  eval $__currentPolicy=\"'${currentPolicy}'\"\n+}\n+\n+#\n+# Function to get current start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Return value containing current server start policy\n+#\n+function getServerPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __currentPolicy=$3\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentServerStartPolicy=$(echo ${domainJson} | jq \"${extractPolicyCmd}\")\n+    if [ \"${currentServerStartPolicy}\" == \"null\" ]; then\n+      currentServerStartPolicy=\"\"\n+    fi\n+  fi\n+  eval $__currentPolicy=${currentServerStartPolicy}\n+}\n+\n+#\n+# Function to create server start policy patch string\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Policy value \n+# $4 - Return value containing server start policy patch string\n+#\n+function createServerStartPolicyPatch {\n+  local domainJson=$1\n+  local serverName=$2\n+  local policy=$3\n+  local __result=$4\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentServerStartPolicy\n+  if [ -z \"${currentServerStartPolicy}\" ]; then\n+    # Server start policy doesn't exist, add a new policy\n+    addPolicyCmd=\".[.| length] |= . + {\\\"serverName\\\":\\\"${serverName}\\\", \\\n+      \\\"serverStartPolicy\\\":\\\"${policy}\\\"}\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq .spec.managedServers | jq -c \"${addPolicyCmd}\")\n+  else\n+    # Server start policy exists, replace policy value \n+    replacePolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy) |= \\\"${policy}\\\"\"\n+    servers=\"(.spec.managedServers)\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\" | jq -cr \"${servers}\")\n+  fi\n+  eval $__result=\"'${serverStartPolicyPatch}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy and update replica\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - String containing replica patch string\n+# $4 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicyAndUpdateReplica {\n+  local domainJson=$1\n+  local serverName=$2\n+  local replicaPatch=$3\n+  local __result=$4\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaPatch}\",\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update policy \n+# $1 - String containing start policy info\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdatePolicy {\n+  local startPolicy=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update replica \n+# $1 - String containing replica\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdateReplica {\n+  local replicaInfo=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUpdateReplicaAndPolicy {\n+  local replicaInfo=$1\n+  local startPolicy=$2\n+  local __result=$3\n+\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\",\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __result=$3\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to get sorted list of servers in a cluster.\n+# The sorted list is created in 'sortedByAlwaysServers' array.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if policy of current server would be unset", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "originalPosition": 213}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNzEwMzgz", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-522710383", "createdAt": "2020-11-03T17:10:33Z", "commit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzoxMDozM1rOHs4kpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzoxMDozM1rOHs4kpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgyNjI3Ng==", "bodyText": "Document that should be either UNSET or CONSTANT", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516826276", "createdAt": "2020-11-03T17:10:33Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,606 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value containing cluster level server start policy\n+#\n+function getClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __clusterPolicy=$3\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__clusterPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get server start policy at domain level\n+# $1 - Domain resource in json format\n+# $2 - Return value containing domain level server start policy\n+#\n+function getDomainPolicy {\n+  local domainJson=$1\n+  local __domainPolicy=$2\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\".spec.serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__domainPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get effective start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Name of cluster\n+# $4 - Return value containing effective server start policy\n+#\n+function getEffectivePolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local __currentPolicy=$4\n+  local currentPolicy=\"\"\n+\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentPolicy\n+  if [ -z \"${currentPolicy}\" ]; then\n+    getClusterPolicy \"${domainJson}\" \"${clusterName}\" currentPolicy\n+    if [ -z \"${currentPolicy}\" ]; then\n+      # Start policy is not set at cluster level, check at domain level\n+      getDomainPolicy \"${domainJson}\" currentPolicy\n+      if [ -z \"${currentPolicy}\" ]; then\n+        # Start policy is not set at domain level, default to IF_NEEDED\n+        currentPolicy=IF_NEEDED\n+      fi\n+    fi\n+  fi\n+  eval $__currentPolicy=\"'${currentPolicy}'\"\n+}\n+\n+#\n+# Function to get current start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Return value containing current server start policy\n+#\n+function getServerPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __currentPolicy=$3\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentServerStartPolicy=$(echo ${domainJson} | jq \"${extractPolicyCmd}\")\n+    if [ \"${currentServerStartPolicy}\" == \"null\" ]; then\n+      currentServerStartPolicy=\"\"\n+    fi\n+  fi\n+  eval $__currentPolicy=${currentServerStartPolicy}\n+}\n+\n+#\n+# Function to create server start policy patch string\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Policy value \n+# $4 - Return value containing server start policy patch string\n+#\n+function createServerStartPolicyPatch {\n+  local domainJson=$1\n+  local serverName=$2\n+  local policy=$3\n+  local __result=$4\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentServerStartPolicy\n+  if [ -z \"${currentServerStartPolicy}\" ]; then\n+    # Server start policy doesn't exist, add a new policy\n+    addPolicyCmd=\".[.| length] |= . + {\\\"serverName\\\":\\\"${serverName}\\\", \\\n+      \\\"serverStartPolicy\\\":\\\"${policy}\\\"}\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq .spec.managedServers | jq -c \"${addPolicyCmd}\")\n+  else\n+    # Server start policy exists, replace policy value \n+    replacePolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy) |= \\\"${policy}\\\"\"\n+    servers=\"(.spec.managedServers)\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\" | jq -cr \"${servers}\")\n+  fi\n+  eval $__result=\"'${serverStartPolicyPatch}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy and update replica\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - String containing replica patch string\n+# $4 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicyAndUpdateReplica {\n+  local domainJson=$1\n+  local serverName=$2\n+  local replicaPatch=$3\n+  local __result=$4\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaPatch}\",\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update policy \n+# $1 - String containing start policy info\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdatePolicy {\n+  local startPolicy=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update replica \n+# $1 - String containing replica\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdateReplica {\n+  local replicaInfo=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUpdateReplicaAndPolicy {\n+  local replicaInfo=$1\n+  local startPolicy=$2\n+  local __result=$3\n+\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\",\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __result=$3\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to get sorted list of servers in a cluster.\n+# The sorted list is created in 'sortedByAlwaysServers' array.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if policy of current server would be unset\n+#\n+function getSortedListOfServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withPolicy=$4\n+  local policy=\"\"\n+  local sortedServers=()\n+  local otherServers=()\n+\n+  configMap=$(${kubernetesCli} get cm ${domainUid}-weblogic-domain-introspect-cm \\\n+    -n ${domainNamespace} -o json)\n+  topology=$(echo \"${configMap}\" | jq '.data[\"topology.yaml\"]')\n+  jsonTopology=$(python -c \\\n+    'import sys, yaml, json; print json.dumps(yaml.safe_load('\"${topology}\"'), indent=4)')\n+  clusterTopology=$(echo ${jsonTopology} | jq -r '.domain | .configuredClusters[] | select (.name == '\\\"${clusterName}\\\"')')\n+  dynaCluster=$(echo ${clusterTopology} | jq .dynamicServersConfig)\n+  if [ \"${dynaCluster}\" == \"null\" ]; then\n+    # Cluster is a configured cluster, get server names\n+    servers=($(echo ${clusterTopology} | jq -r .servers[].name))\n+    # Sort server names in numero lexi order\n+    IFS=$'\\n' sortedServers=($(sort --version-sort <<<\"${servers[*]}\" ))\n+    unset IFS\n+    clusterSize=${#sortedServers[@]}\n+  else \n+    # Cluster is a dynamic cluster, calculate server names\n+    prefix=$(echo ${dynaCluster} | jq -r .serverNamePrefix)\n+    clusterSize=$(echo ${dynaCluster} | jq .dynamicClusterSize) \n+    for (( i=1; i<=$clusterSize; i++ )); do\n+      localServerName=${prefix}$i\n+      sortedServers+=(${localServerName})\n+    done\n+  fi\n+  # Create arrays of ALWAYS policy servers and other servers\n+  sortedServersSize=${#sortedServers[@]}\n+  if [ \"${sortedServersSize}\" -gt 0 ]; then\n+    for localServerName in \"${sortedServers[@]}\"; do\n+      getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+      # Update policy when server name matches current server and unsetting\n+      if [[ \"${withPolicy}\" == \"UNSET\" && \"${serverName}\" == \"${localServerName}\" ]]; then\n+        policy=UNSET\n+      fi\n+      if [ \"${policy}\" == \"ALWAYS\" ]; then\n+        sortedByAlwaysServers+=(${localServerName})\n+      else\n+        otherServers+=(${localServerName})\n+      fi\n+    done\n+  fi\n+  \n+  # append other servers to the list of servers with always policy\n+  otherServersSize=${#otherServers[@]}\n+  if [ \"${otherServersSize}\" -gt 0 ]; then\n+    for otherServer in \"${otherServers[@]}\"; do\n+      sortedByAlwaysServers+=($otherServer)\n+    done\n+  fi\n+}\n+\n+#\n+# Get replica count for a cluster\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster \n+# $3 - Return value containing replica count\n+#\n+function getReplicaCount {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __replicaCount=$3\n+\n+  replicasCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).replicas\"\n+  replicaCount=$(echo ${domainJson} | jq \"${replicasCmd}\")\n+  eval $__replicaCount=\"'${replicaCount}'\"\n+\n+}\n+\n+#\n+# Check servers started in a cluster based on server start policy and \n+# replica count.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if replicas will stay constant, incremented or decremented\n+# $5 - Indicates if policy of current server will stay same or unset", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "originalPosition": 298}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNzE2MjAw", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-522716200", "createdAt": "2020-11-03T17:17:39Z", "commit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzoxNzozOVrOHs411g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzoxNzozOVrOHs411g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzMDY3OA==", "bodyText": "For all enumerated type inputs/outputs on all functions please document the legal values (in this case it can return \"NEVER\" or \"IF_NEEDED\" or \"\".", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516830678", "createdAt": "2020-11-03T17:17:39Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,606 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value containing cluster level server start policy", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNzE4MTE2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-522718116", "createdAt": "2020-11-03T17:19:55Z", "commit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzoxOTo1NlrOHs47ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzoxOTo1NlrOHs47ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzMjE2Mw==", "bodyText": "Document that this can return IF_NEEDED NEVER or ADMIN_ONLY", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516832163", "createdAt": "2020-11-03T17:19:56Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,606 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value containing cluster level server start policy\n+#\n+function getClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __clusterPolicy=$3\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__clusterPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get server start policy at domain level\n+# $1 - Domain resource in json format\n+# $2 - Return value containing domain level server start policy", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNzIxOTI5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-522721929", "createdAt": "2020-11-03T17:24:29Z", "commit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzoyNDoyOVrOHs5HqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzoyNDoyOVrOHs5HqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzNTI0MQ==", "bodyText": "should this be a 'printError'?  Or maybe it should just be aan INFO?  See my new comment on the caller of this function.\nmaybe also set __replicaCount to some dummy value?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516835241", "createdAt": "2020-11-03T17:24:29Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,606 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value containing cluster level server start policy\n+#\n+function getClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __clusterPolicy=$3\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__clusterPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get server start policy at domain level\n+# $1 - Domain resource in json format\n+# $2 - Return value containing domain level server start policy\n+#\n+function getDomainPolicy {\n+  local domainJson=$1\n+  local __domainPolicy=$2\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\".spec.serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__domainPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get effective start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Name of cluster\n+# $4 - Return value containing effective server start policy\n+#\n+function getEffectivePolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local __currentPolicy=$4\n+  local currentPolicy=\"\"\n+\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentPolicy\n+  if [ -z \"${currentPolicy}\" ]; then\n+    getClusterPolicy \"${domainJson}\" \"${clusterName}\" currentPolicy\n+    if [ -z \"${currentPolicy}\" ]; then\n+      # Start policy is not set at cluster level, check at domain level\n+      getDomainPolicy \"${domainJson}\" currentPolicy\n+      if [ -z \"${currentPolicy}\" ]; then\n+        # Start policy is not set at domain level, default to IF_NEEDED\n+        currentPolicy=IF_NEEDED\n+      fi\n+    fi\n+  fi\n+  eval $__currentPolicy=\"'${currentPolicy}'\"\n+}\n+\n+#\n+# Function to get current start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Return value containing current server start policy\n+#\n+function getServerPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __currentPolicy=$3\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentServerStartPolicy=$(echo ${domainJson} | jq \"${extractPolicyCmd}\")\n+    if [ \"${currentServerStartPolicy}\" == \"null\" ]; then\n+      currentServerStartPolicy=\"\"\n+    fi\n+  fi\n+  eval $__currentPolicy=${currentServerStartPolicy}\n+}\n+\n+#\n+# Function to create server start policy patch string\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Policy value \n+# $4 - Return value containing server start policy patch string\n+#\n+function createServerStartPolicyPatch {\n+  local domainJson=$1\n+  local serverName=$2\n+  local policy=$3\n+  local __result=$4\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentServerStartPolicy\n+  if [ -z \"${currentServerStartPolicy}\" ]; then\n+    # Server start policy doesn't exist, add a new policy\n+    addPolicyCmd=\".[.| length] |= . + {\\\"serverName\\\":\\\"${serverName}\\\", \\\n+      \\\"serverStartPolicy\\\":\\\"${policy}\\\"}\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq .spec.managedServers | jq -c \"${addPolicyCmd}\")\n+  else\n+    # Server start policy exists, replace policy value \n+    replacePolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy) |= \\\"${policy}\\\"\"\n+    servers=\"(.spec.managedServers)\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\" | jq -cr \"${servers}\")\n+  fi\n+  eval $__result=\"'${serverStartPolicyPatch}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy and update replica\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - String containing replica patch string\n+# $4 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicyAndUpdateReplica {\n+  local domainJson=$1\n+  local serverName=$2\n+  local replicaPatch=$3\n+  local __result=$4\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaPatch}\",\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update policy \n+# $1 - String containing start policy info\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdatePolicy {\n+  local startPolicy=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update replica \n+# $1 - String containing replica\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdateReplica {\n+  local replicaInfo=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUpdateReplicaAndPolicy {\n+  local replicaInfo=$1\n+  local startPolicy=$2\n+  local __result=$3\n+\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\",\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __result=$3\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to get sorted list of servers in a cluster.\n+# The sorted list is created in 'sortedByAlwaysServers' array.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if policy of current server would be unset\n+#\n+function getSortedListOfServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withPolicy=$4\n+  local policy=\"\"\n+  local sortedServers=()\n+  local otherServers=()\n+\n+  configMap=$(${kubernetesCli} get cm ${domainUid}-weblogic-domain-introspect-cm \\\n+    -n ${domainNamespace} -o json)\n+  topology=$(echo \"${configMap}\" | jq '.data[\"topology.yaml\"]')\n+  jsonTopology=$(python -c \\\n+    'import sys, yaml, json; print json.dumps(yaml.safe_load('\"${topology}\"'), indent=4)')\n+  clusterTopology=$(echo ${jsonTopology} | jq -r '.domain | .configuredClusters[] | select (.name == '\\\"${clusterName}\\\"')')\n+  dynaCluster=$(echo ${clusterTopology} | jq .dynamicServersConfig)\n+  if [ \"${dynaCluster}\" == \"null\" ]; then\n+    # Cluster is a configured cluster, get server names\n+    servers=($(echo ${clusterTopology} | jq -r .servers[].name))\n+    # Sort server names in numero lexi order\n+    IFS=$'\\n' sortedServers=($(sort --version-sort <<<\"${servers[*]}\" ))\n+    unset IFS\n+    clusterSize=${#sortedServers[@]}\n+  else \n+    # Cluster is a dynamic cluster, calculate server names\n+    prefix=$(echo ${dynaCluster} | jq -r .serverNamePrefix)\n+    clusterSize=$(echo ${dynaCluster} | jq .dynamicClusterSize) \n+    for (( i=1; i<=$clusterSize; i++ )); do\n+      localServerName=${prefix}$i\n+      sortedServers+=(${localServerName})\n+    done\n+  fi\n+  # Create arrays of ALWAYS policy servers and other servers\n+  sortedServersSize=${#sortedServers[@]}\n+  if [ \"${sortedServersSize}\" -gt 0 ]; then\n+    for localServerName in \"${sortedServers[@]}\"; do\n+      getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+      # Update policy when server name matches current server and unsetting\n+      if [[ \"${withPolicy}\" == \"UNSET\" && \"${serverName}\" == \"${localServerName}\" ]]; then\n+        policy=UNSET\n+      fi\n+      if [ \"${policy}\" == \"ALWAYS\" ]; then\n+        sortedByAlwaysServers+=(${localServerName})\n+      else\n+        otherServers+=(${localServerName})\n+      fi\n+    done\n+  fi\n+  \n+  # append other servers to the list of servers with always policy\n+  otherServersSize=${#otherServers[@]}\n+  if [ \"${otherServersSize}\" -gt 0 ]; then\n+    for otherServer in \"${otherServers[@]}\"; do\n+      sortedByAlwaysServers+=($otherServer)\n+    done\n+  fi\n+}\n+\n+#\n+# Get replica count for a cluster\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster \n+# $3 - Return value containing replica count\n+#\n+function getReplicaCount {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __replicaCount=$3\n+\n+  replicasCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).replicas\"\n+  replicaCount=$(echo ${domainJson} | jq \"${replicasCmd}\")\n+  eval $__replicaCount=\"'${replicaCount}'\"\n+\n+}\n+\n+#\n+# Check servers started in a cluster based on server start policy and \n+# replica count.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if replicas will stay constant, incremented or decremented\n+# $5 - Indicates if policy of current server will stay same or unset\n+# $6 - Return value indicating if current server will be started\n+#\n+function checkStartedServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withReplicas=$4\n+  local withPolicy=$5\n+  local __started=$6\n+  local localServerName=\"\"\n+  local policy=\"\"\n+  local replicaCount=0\n+  local currentReplicas=0\n+  local startedServers=()\n+  local sortedByAlwaysServers=()\n+  \n+  # Get sorted list of servers in 'sortedByAlwaysServers' array\n+  getSortedListOfServers \"${domainJson}\" \"${serverName}\" \"${clusterName}\" \"${withPolicy}\"\n+  getReplicaCount \"${domainJson}\" \"${clusterName}\" replicaCount\n+  # Increment or decrement the replica count based on 'withReplicas' input parameter\n+  if [ \"${withReplicas}\" == \"INCREASED\" ]; then\n+    replicaCount=$((replicaCount+1))\n+  elif [ \"${withReplicas}\" == \"DECREASED\" ]; then\n+    replicaCount=$((replicaCount-1))\n+  fi\n+  sortedByAlwaysSize=${#sortedByAlwaysServers[@]}\n+  if [ \"${sortedByAlwaysSize}\" -gt 0 ]; then\n+    for localServerName in \"${sortedByAlwaysServers[@]}\"; do\n+      getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+      # Update policy when server name matches current server and unsetting\n+      if [[ \"${serverName}\" == \"${localServerName}\" && \"${withPolicy}\" == \"UNSET\" ]]; then\n+        policy=UNSET\n+      fi\n+      # check if server should start based on replica count, policy and current replicas\n+      shouldStart \"${currentReplicas}\" \"${policy}\" \"${replicaCount}\" result\n+      if [ \"${result}\" == 'True' ]; then\n+        # server should start, increment current replicas and add server to list of started servers\n+        currentReplicas=$((currentReplicas+1))\n+        startedServers+=(${localServerName})\n+      fi\n+    done\n+  fi\n+  startedSize=${#startedServers[@]}\n+  if [ ${startedSize} -gt 0 ]; then\n+    # check if current server is in the list of started servers\n+    if checkStringInArray ${serverName} ${startedServers[@]}; then\n+      eval $__started=\"true\"\n+      return\n+    fi\n+  fi\n+  eval $__started=\"false\"\n+}\n+\n+#\n+# Function to check if server should start based on policy and current replicas\n+# $1 - Current number of replicas\n+# $2 - Server start policy\n+# $3 - Replica count\n+# $4 - Return value\n+#\n+function shouldStart {\n+  local currentReplicas=$1\n+  local policy=$2\n+  local replicaCount=$3 \n+  local __result=$4\n+\n+  if [ \"$policy\" == \"ALWAYS\" ]; then\n+    eval $__result=True\n+  elif [ \"$policy\" == \"NEVER\" ]; then\n+    eval $__result=False\n+  elif [ \"${currentReplicas}\" -lt \"${replicaCount}\" ]; then\n+    eval $__result=True\n+  else \n+    eval $__result=False\n+  fi\n+}\n+\n+#\n+# Function to create patch string for updating replica count\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster whose replica count will be patched\n+# $3 - operatation string indicating whether to increment or decrement count\n+# $4 - Return value containing replica update patch string\n+# $5 - Retrun value containing updated replica count\n+#\n+function createReplicaPatch {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local operation=$3\n+  local __result=$4\n+  local __replicaCount=$5\n+  local maxReplicas=\"\"\n+  local errorMessage=\"@@ ERROR: Maximum number of servers allowed (maxReplica = ${maxReplicas}) \\\n+are already running. Please increase cluster size to start new servers.\"\n+\n+  replicasCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).replicas\"\n+  maxReplicaCmd=\"(.status.clusters[] | select (.clusterName == \\\"${clusterName}\\\")) \\\n+    | .maximumReplicas\"\n+  replica=$(echo ${domainJson} | jq \"${replicasCmd}\")\n+  if [[ -z \"${replica}\" || \"${replica}\" == \"null\" ]]; then\n+    replica=$(echo ${domainJson} | jq .spec.replicas)\n+  fi\n+  if [ \"${operation}\" == \"DECREMENT\" ]; then\n+    replica=$((replica-1))\n+    if [ ${replica} -lt 0 ]; then\n+      replica=0\n+    fi\n+  elif [ \"${operation}\" == \"INCREMENT\" ]; then\n+    replica=$((replica+1))\n+    maxReplicas=$(echo ${domainJson} | jq \"${maxReplicaCmd}\")\n+    if [ ${replica} -gt ${maxReplicas} ]; then\n+      echo \"${errorMessage}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "originalPosition": 411}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNzU3NjEz", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-522757613", "createdAt": "2020-11-03T18:10:43Z", "commit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxODoxMDo0M1rOHs60HQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxODoxMDo0M1rOHs60HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg2MzAwNQ==", "bodyText": "doc returns \"True\" or \"False\"", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516863005", "createdAt": "2020-11-03T18:10:43Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,606 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value containing cluster level server start policy\n+#\n+function getClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __clusterPolicy=$3\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__clusterPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get server start policy at domain level\n+# $1 - Domain resource in json format\n+# $2 - Return value containing domain level server start policy\n+#\n+function getDomainPolicy {\n+  local domainJson=$1\n+  local __domainPolicy=$2\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\".spec.serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__domainPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get effective start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Name of cluster\n+# $4 - Return value containing effective server start policy\n+#\n+function getEffectivePolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local __currentPolicy=$4\n+  local currentPolicy=\"\"\n+\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentPolicy\n+  if [ -z \"${currentPolicy}\" ]; then\n+    getClusterPolicy \"${domainJson}\" \"${clusterName}\" currentPolicy\n+    if [ -z \"${currentPolicy}\" ]; then\n+      # Start policy is not set at cluster level, check at domain level\n+      getDomainPolicy \"${domainJson}\" currentPolicy\n+      if [ -z \"${currentPolicy}\" ]; then\n+        # Start policy is not set at domain level, default to IF_NEEDED\n+        currentPolicy=IF_NEEDED\n+      fi\n+    fi\n+  fi\n+  eval $__currentPolicy=\"'${currentPolicy}'\"\n+}\n+\n+#\n+# Function to get current start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Return value containing current server start policy\n+#\n+function getServerPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __currentPolicy=$3\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentServerStartPolicy=$(echo ${domainJson} | jq \"${extractPolicyCmd}\")\n+    if [ \"${currentServerStartPolicy}\" == \"null\" ]; then\n+      currentServerStartPolicy=\"\"\n+    fi\n+  fi\n+  eval $__currentPolicy=${currentServerStartPolicy}\n+}\n+\n+#\n+# Function to create server start policy patch string\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Policy value \n+# $4 - Return value containing server start policy patch string\n+#\n+function createServerStartPolicyPatch {\n+  local domainJson=$1\n+  local serverName=$2\n+  local policy=$3\n+  local __result=$4\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentServerStartPolicy\n+  if [ -z \"${currentServerStartPolicy}\" ]; then\n+    # Server start policy doesn't exist, add a new policy\n+    addPolicyCmd=\".[.| length] |= . + {\\\"serverName\\\":\\\"${serverName}\\\", \\\n+      \\\"serverStartPolicy\\\":\\\"${policy}\\\"}\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq .spec.managedServers | jq -c \"${addPolicyCmd}\")\n+  else\n+    # Server start policy exists, replace policy value \n+    replacePolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy) |= \\\"${policy}\\\"\"\n+    servers=\"(.spec.managedServers)\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\" | jq -cr \"${servers}\")\n+  fi\n+  eval $__result=\"'${serverStartPolicyPatch}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy and update replica\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - String containing replica patch string\n+# $4 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicyAndUpdateReplica {\n+  local domainJson=$1\n+  local serverName=$2\n+  local replicaPatch=$3\n+  local __result=$4\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaPatch}\",\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update policy \n+# $1 - String containing start policy info\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdatePolicy {\n+  local startPolicy=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update replica \n+# $1 - String containing replica\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdateReplica {\n+  local replicaInfo=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUpdateReplicaAndPolicy {\n+  local replicaInfo=$1\n+  local startPolicy=$2\n+  local __result=$3\n+\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\",\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __result=$3\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to get sorted list of servers in a cluster.\n+# The sorted list is created in 'sortedByAlwaysServers' array.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if policy of current server would be unset\n+#\n+function getSortedListOfServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withPolicy=$4\n+  local policy=\"\"\n+  local sortedServers=()\n+  local otherServers=()\n+\n+  configMap=$(${kubernetesCli} get cm ${domainUid}-weblogic-domain-introspect-cm \\\n+    -n ${domainNamespace} -o json)\n+  topology=$(echo \"${configMap}\" | jq '.data[\"topology.yaml\"]')\n+  jsonTopology=$(python -c \\\n+    'import sys, yaml, json; print json.dumps(yaml.safe_load('\"${topology}\"'), indent=4)')\n+  clusterTopology=$(echo ${jsonTopology} | jq -r '.domain | .configuredClusters[] | select (.name == '\\\"${clusterName}\\\"')')\n+  dynaCluster=$(echo ${clusterTopology} | jq .dynamicServersConfig)\n+  if [ \"${dynaCluster}\" == \"null\" ]; then\n+    # Cluster is a configured cluster, get server names\n+    servers=($(echo ${clusterTopology} | jq -r .servers[].name))\n+    # Sort server names in numero lexi order\n+    IFS=$'\\n' sortedServers=($(sort --version-sort <<<\"${servers[*]}\" ))\n+    unset IFS\n+    clusterSize=${#sortedServers[@]}\n+  else \n+    # Cluster is a dynamic cluster, calculate server names\n+    prefix=$(echo ${dynaCluster} | jq -r .serverNamePrefix)\n+    clusterSize=$(echo ${dynaCluster} | jq .dynamicClusterSize) \n+    for (( i=1; i<=$clusterSize; i++ )); do\n+      localServerName=${prefix}$i\n+      sortedServers+=(${localServerName})\n+    done\n+  fi\n+  # Create arrays of ALWAYS policy servers and other servers\n+  sortedServersSize=${#sortedServers[@]}\n+  if [ \"${sortedServersSize}\" -gt 0 ]; then\n+    for localServerName in \"${sortedServers[@]}\"; do\n+      getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+      # Update policy when server name matches current server and unsetting\n+      if [[ \"${withPolicy}\" == \"UNSET\" && \"${serverName}\" == \"${localServerName}\" ]]; then\n+        policy=UNSET\n+      fi\n+      if [ \"${policy}\" == \"ALWAYS\" ]; then\n+        sortedByAlwaysServers+=(${localServerName})\n+      else\n+        otherServers+=(${localServerName})\n+      fi\n+    done\n+  fi\n+  \n+  # append other servers to the list of servers with always policy\n+  otherServersSize=${#otherServers[@]}\n+  if [ \"${otherServersSize}\" -gt 0 ]; then\n+    for otherServer in \"${otherServers[@]}\"; do\n+      sortedByAlwaysServers+=($otherServer)\n+    done\n+  fi\n+}\n+\n+#\n+# Get replica count for a cluster\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster \n+# $3 - Return value containing replica count\n+#\n+function getReplicaCount {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __replicaCount=$3\n+\n+  replicasCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).replicas\"\n+  replicaCount=$(echo ${domainJson} | jq \"${replicasCmd}\")\n+  eval $__replicaCount=\"'${replicaCount}'\"\n+\n+}\n+\n+#\n+# Check servers started in a cluster based on server start policy and \n+# replica count.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if replicas will stay constant, incremented or decremented\n+# $5 - Indicates if policy of current server will stay same or unset\n+# $6 - Return value indicating if current server will be started\n+#\n+function checkStartedServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withReplicas=$4\n+  local withPolicy=$5\n+  local __started=$6\n+  local localServerName=\"\"\n+  local policy=\"\"\n+  local replicaCount=0\n+  local currentReplicas=0\n+  local startedServers=()\n+  local sortedByAlwaysServers=()\n+  \n+  # Get sorted list of servers in 'sortedByAlwaysServers' array\n+  getSortedListOfServers \"${domainJson}\" \"${serverName}\" \"${clusterName}\" \"${withPolicy}\"\n+  getReplicaCount \"${domainJson}\" \"${clusterName}\" replicaCount\n+  # Increment or decrement the replica count based on 'withReplicas' input parameter\n+  if [ \"${withReplicas}\" == \"INCREASED\" ]; then\n+    replicaCount=$((replicaCount+1))\n+  elif [ \"${withReplicas}\" == \"DECREASED\" ]; then\n+    replicaCount=$((replicaCount-1))\n+  fi\n+  sortedByAlwaysSize=${#sortedByAlwaysServers[@]}\n+  if [ \"${sortedByAlwaysSize}\" -gt 0 ]; then\n+    for localServerName in \"${sortedByAlwaysServers[@]}\"; do\n+      getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+      # Update policy when server name matches current server and unsetting\n+      if [[ \"${serverName}\" == \"${localServerName}\" && \"${withPolicy}\" == \"UNSET\" ]]; then\n+        policy=UNSET\n+      fi\n+      # check if server should start based on replica count, policy and current replicas\n+      shouldStart \"${currentReplicas}\" \"${policy}\" \"${replicaCount}\" result\n+      if [ \"${result}\" == 'True' ]; then\n+        # server should start, increment current replicas and add server to list of started servers\n+        currentReplicas=$((currentReplicas+1))\n+        startedServers+=(${localServerName})\n+      fi\n+    done\n+  fi\n+  startedSize=${#startedServers[@]}\n+  if [ ${startedSize} -gt 0 ]; then\n+    # check if current server is in the list of started servers\n+    if checkStringInArray ${serverName} ${startedServers[@]}; then\n+      eval $__started=\"true\"\n+      return\n+    fi\n+  fi\n+  eval $__started=\"false\"\n+}\n+\n+#\n+# Function to check if server should start based on policy and current replicas\n+# $1 - Current number of replicas\n+# $2 - Server start policy\n+# $3 - Replica count\n+# $4 - Return value", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "originalPosition": 357}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNzYyMzY3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-522762367", "createdAt": "2020-11-03T18:17:11Z", "commit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxODoxNzoxMVrOHs7CCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxODoxNzoxMVrOHs7CCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg2NjU3MA==", "bodyText": "In some parts of the code \"true/false\" is used, while others \"True/False\" is used - can you standardize on the former?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516866570", "createdAt": "2020-11-03T18:17:11Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,606 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value containing cluster level server start policy\n+#\n+function getClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __clusterPolicy=$3\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__clusterPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get server start policy at domain level\n+# $1 - Domain resource in json format\n+# $2 - Return value containing domain level server start policy\n+#\n+function getDomainPolicy {\n+  local domainJson=$1\n+  local __domainPolicy=$2\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\".spec.serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__domainPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get effective start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Name of cluster\n+# $4 - Return value containing effective server start policy\n+#\n+function getEffectivePolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local __currentPolicy=$4\n+  local currentPolicy=\"\"\n+\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentPolicy\n+  if [ -z \"${currentPolicy}\" ]; then\n+    getClusterPolicy \"${domainJson}\" \"${clusterName}\" currentPolicy\n+    if [ -z \"${currentPolicy}\" ]; then\n+      # Start policy is not set at cluster level, check at domain level\n+      getDomainPolicy \"${domainJson}\" currentPolicy\n+      if [ -z \"${currentPolicy}\" ]; then\n+        # Start policy is not set at domain level, default to IF_NEEDED\n+        currentPolicy=IF_NEEDED\n+      fi\n+    fi\n+  fi\n+  eval $__currentPolicy=\"'${currentPolicy}'\"\n+}\n+\n+#\n+# Function to get current start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Return value containing current server start policy\n+#\n+function getServerPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __currentPolicy=$3\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentServerStartPolicy=$(echo ${domainJson} | jq \"${extractPolicyCmd}\")\n+    if [ \"${currentServerStartPolicy}\" == \"null\" ]; then\n+      currentServerStartPolicy=\"\"\n+    fi\n+  fi\n+  eval $__currentPolicy=${currentServerStartPolicy}\n+}\n+\n+#\n+# Function to create server start policy patch string\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Policy value \n+# $4 - Return value containing server start policy patch string\n+#\n+function createServerStartPolicyPatch {\n+  local domainJson=$1\n+  local serverName=$2\n+  local policy=$3\n+  local __result=$4\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentServerStartPolicy\n+  if [ -z \"${currentServerStartPolicy}\" ]; then\n+    # Server start policy doesn't exist, add a new policy\n+    addPolicyCmd=\".[.| length] |= . + {\\\"serverName\\\":\\\"${serverName}\\\", \\\n+      \\\"serverStartPolicy\\\":\\\"${policy}\\\"}\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq .spec.managedServers | jq -c \"${addPolicyCmd}\")\n+  else\n+    # Server start policy exists, replace policy value \n+    replacePolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy) |= \\\"${policy}\\\"\"\n+    servers=\"(.spec.managedServers)\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\" | jq -cr \"${servers}\")\n+  fi\n+  eval $__result=\"'${serverStartPolicyPatch}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy and update replica\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - String containing replica patch string\n+# $4 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicyAndUpdateReplica {\n+  local domainJson=$1\n+  local serverName=$2\n+  local replicaPatch=$3\n+  local __result=$4\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaPatch}\",\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update policy \n+# $1 - String containing start policy info\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdatePolicy {\n+  local startPolicy=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update replica \n+# $1 - String containing replica\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdateReplica {\n+  local replicaInfo=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUpdateReplicaAndPolicy {\n+  local replicaInfo=$1\n+  local startPolicy=$2\n+  local __result=$3\n+\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\",\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __result=$3\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to get sorted list of servers in a cluster.\n+# The sorted list is created in 'sortedByAlwaysServers' array.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if policy of current server would be unset\n+#\n+function getSortedListOfServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withPolicy=$4\n+  local policy=\"\"\n+  local sortedServers=()\n+  local otherServers=()\n+\n+  configMap=$(${kubernetesCli} get cm ${domainUid}-weblogic-domain-introspect-cm \\\n+    -n ${domainNamespace} -o json)\n+  topology=$(echo \"${configMap}\" | jq '.data[\"topology.yaml\"]')\n+  jsonTopology=$(python -c \\\n+    'import sys, yaml, json; print json.dumps(yaml.safe_load('\"${topology}\"'), indent=4)')\n+  clusterTopology=$(echo ${jsonTopology} | jq -r '.domain | .configuredClusters[] | select (.name == '\\\"${clusterName}\\\"')')\n+  dynaCluster=$(echo ${clusterTopology} | jq .dynamicServersConfig)\n+  if [ \"${dynaCluster}\" == \"null\" ]; then\n+    # Cluster is a configured cluster, get server names\n+    servers=($(echo ${clusterTopology} | jq -r .servers[].name))\n+    # Sort server names in numero lexi order\n+    IFS=$'\\n' sortedServers=($(sort --version-sort <<<\"${servers[*]}\" ))\n+    unset IFS\n+    clusterSize=${#sortedServers[@]}\n+  else \n+    # Cluster is a dynamic cluster, calculate server names\n+    prefix=$(echo ${dynaCluster} | jq -r .serverNamePrefix)\n+    clusterSize=$(echo ${dynaCluster} | jq .dynamicClusterSize) \n+    for (( i=1; i<=$clusterSize; i++ )); do\n+      localServerName=${prefix}$i\n+      sortedServers+=(${localServerName})\n+    done\n+  fi\n+  # Create arrays of ALWAYS policy servers and other servers\n+  sortedServersSize=${#sortedServers[@]}\n+  if [ \"${sortedServersSize}\" -gt 0 ]; then\n+    for localServerName in \"${sortedServers[@]}\"; do\n+      getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+      # Update policy when server name matches current server and unsetting\n+      if [[ \"${withPolicy}\" == \"UNSET\" && \"${serverName}\" == \"${localServerName}\" ]]; then\n+        policy=UNSET\n+      fi\n+      if [ \"${policy}\" == \"ALWAYS\" ]; then\n+        sortedByAlwaysServers+=(${localServerName})\n+      else\n+        otherServers+=(${localServerName})\n+      fi\n+    done\n+  fi\n+  \n+  # append other servers to the list of servers with always policy\n+  otherServersSize=${#otherServers[@]}\n+  if [ \"${otherServersSize}\" -gt 0 ]; then\n+    for otherServer in \"${otherServers[@]}\"; do\n+      sortedByAlwaysServers+=($otherServer)\n+    done\n+  fi\n+}\n+\n+#\n+# Get replica count for a cluster\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster \n+# $3 - Return value containing replica count\n+#\n+function getReplicaCount {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __replicaCount=$3\n+\n+  replicasCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).replicas\"\n+  replicaCount=$(echo ${domainJson} | jq \"${replicasCmd}\")\n+  eval $__replicaCount=\"'${replicaCount}'\"\n+\n+}\n+\n+#\n+# Check servers started in a cluster based on server start policy and \n+# replica count.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if replicas will stay constant, incremented or decremented\n+# $5 - Indicates if policy of current server will stay same or unset\n+# $6 - Return value indicating if current server will be started\n+#\n+function checkStartedServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withReplicas=$4\n+  local withPolicy=$5\n+  local __started=$6\n+  local localServerName=\"\"\n+  local policy=\"\"\n+  local replicaCount=0\n+  local currentReplicas=0\n+  local startedServers=()\n+  local sortedByAlwaysServers=()\n+  \n+  # Get sorted list of servers in 'sortedByAlwaysServers' array\n+  getSortedListOfServers \"${domainJson}\" \"${serverName}\" \"${clusterName}\" \"${withPolicy}\"\n+  getReplicaCount \"${domainJson}\" \"${clusterName}\" replicaCount\n+  # Increment or decrement the replica count based on 'withReplicas' input parameter\n+  if [ \"${withReplicas}\" == \"INCREASED\" ]; then\n+    replicaCount=$((replicaCount+1))\n+  elif [ \"${withReplicas}\" == \"DECREASED\" ]; then\n+    replicaCount=$((replicaCount-1))\n+  fi\n+  sortedByAlwaysSize=${#sortedByAlwaysServers[@]}\n+  if [ \"${sortedByAlwaysSize}\" -gt 0 ]; then\n+    for localServerName in \"${sortedByAlwaysServers[@]}\"; do\n+      getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+      # Update policy when server name matches current server and unsetting\n+      if [[ \"${serverName}\" == \"${localServerName}\" && \"${withPolicy}\" == \"UNSET\" ]]; then\n+        policy=UNSET\n+      fi\n+      # check if server should start based on replica count, policy and current replicas\n+      shouldStart \"${currentReplicas}\" \"${policy}\" \"${replicaCount}\" result\n+      if [ \"${result}\" == 'True' ]; then\n+        # server should start, increment current replicas and add server to list of started servers\n+        currentReplicas=$((currentReplicas+1))\n+        startedServers+=(${localServerName})\n+      fi\n+    done\n+  fi\n+  startedSize=${#startedServers[@]}\n+  if [ ${startedSize} -gt 0 ]; then\n+    # check if current server is in the list of started servers\n+    if checkStringInArray ${serverName} ${startedServers[@]}; then\n+      eval $__started=\"true\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "originalPosition": 345}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNzY5MDgx", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-522769081", "createdAt": "2020-11-03T18:26:21Z", "commit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxODoyNjoyMVrOHs7VvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxODoyNjoyMVrOHs7VvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg3MTYxMw==", "bodyText": "If replicas is not set on the cluster, should this should return .spec.replica?  and if that is not set, should it should return 0?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516871613", "createdAt": "2020-11-03T18:26:21Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,606 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value containing cluster level server start policy\n+#\n+function getClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __clusterPolicy=$3\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__clusterPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get server start policy at domain level\n+# $1 - Domain resource in json format\n+# $2 - Return value containing domain level server start policy\n+#\n+function getDomainPolicy {\n+  local domainJson=$1\n+  local __domainPolicy=$2\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\".spec.serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__domainPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get effective start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Name of cluster\n+# $4 - Return value containing effective server start policy\n+#\n+function getEffectivePolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local __currentPolicy=$4\n+  local currentPolicy=\"\"\n+\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentPolicy\n+  if [ -z \"${currentPolicy}\" ]; then\n+    getClusterPolicy \"${domainJson}\" \"${clusterName}\" currentPolicy\n+    if [ -z \"${currentPolicy}\" ]; then\n+      # Start policy is not set at cluster level, check at domain level\n+      getDomainPolicy \"${domainJson}\" currentPolicy\n+      if [ -z \"${currentPolicy}\" ]; then\n+        # Start policy is not set at domain level, default to IF_NEEDED\n+        currentPolicy=IF_NEEDED\n+      fi\n+    fi\n+  fi\n+  eval $__currentPolicy=\"'${currentPolicy}'\"\n+}\n+\n+#\n+# Function to get current start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Return value containing current server start policy\n+#\n+function getServerPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __currentPolicy=$3\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentServerStartPolicy=$(echo ${domainJson} | jq \"${extractPolicyCmd}\")\n+    if [ \"${currentServerStartPolicy}\" == \"null\" ]; then\n+      currentServerStartPolicy=\"\"\n+    fi\n+  fi\n+  eval $__currentPolicy=${currentServerStartPolicy}\n+}\n+\n+#\n+# Function to create server start policy patch string\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Policy value \n+# $4 - Return value containing server start policy patch string\n+#\n+function createServerStartPolicyPatch {\n+  local domainJson=$1\n+  local serverName=$2\n+  local policy=$3\n+  local __result=$4\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentServerStartPolicy\n+  if [ -z \"${currentServerStartPolicy}\" ]; then\n+    # Server start policy doesn't exist, add a new policy\n+    addPolicyCmd=\".[.| length] |= . + {\\\"serverName\\\":\\\"${serverName}\\\", \\\n+      \\\"serverStartPolicy\\\":\\\"${policy}\\\"}\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq .spec.managedServers | jq -c \"${addPolicyCmd}\")\n+  else\n+    # Server start policy exists, replace policy value \n+    replacePolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy) |= \\\"${policy}\\\"\"\n+    servers=\"(.spec.managedServers)\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\" | jq -cr \"${servers}\")\n+  fi\n+  eval $__result=\"'${serverStartPolicyPatch}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy and update replica\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - String containing replica patch string\n+# $4 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicyAndUpdateReplica {\n+  local domainJson=$1\n+  local serverName=$2\n+  local replicaPatch=$3\n+  local __result=$4\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaPatch}\",\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update policy \n+# $1 - String containing start policy info\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdatePolicy {\n+  local startPolicy=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update replica \n+# $1 - String containing replica\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdateReplica {\n+  local replicaInfo=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUpdateReplicaAndPolicy {\n+  local replicaInfo=$1\n+  local startPolicy=$2\n+  local __result=$3\n+\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\",\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __result=$3\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to get sorted list of servers in a cluster.\n+# The sorted list is created in 'sortedByAlwaysServers' array.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if policy of current server would be unset\n+#\n+function getSortedListOfServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withPolicy=$4\n+  local policy=\"\"\n+  local sortedServers=()\n+  local otherServers=()\n+\n+  configMap=$(${kubernetesCli} get cm ${domainUid}-weblogic-domain-introspect-cm \\\n+    -n ${domainNamespace} -o json)\n+  topology=$(echo \"${configMap}\" | jq '.data[\"topology.yaml\"]')\n+  jsonTopology=$(python -c \\\n+    'import sys, yaml, json; print json.dumps(yaml.safe_load('\"${topology}\"'), indent=4)')\n+  clusterTopology=$(echo ${jsonTopology} | jq -r '.domain | .configuredClusters[] | select (.name == '\\\"${clusterName}\\\"')')\n+  dynaCluster=$(echo ${clusterTopology} | jq .dynamicServersConfig)\n+  if [ \"${dynaCluster}\" == \"null\" ]; then\n+    # Cluster is a configured cluster, get server names\n+    servers=($(echo ${clusterTopology} | jq -r .servers[].name))\n+    # Sort server names in numero lexi order\n+    IFS=$'\\n' sortedServers=($(sort --version-sort <<<\"${servers[*]}\" ))\n+    unset IFS\n+    clusterSize=${#sortedServers[@]}\n+  else \n+    # Cluster is a dynamic cluster, calculate server names\n+    prefix=$(echo ${dynaCluster} | jq -r .serverNamePrefix)\n+    clusterSize=$(echo ${dynaCluster} | jq .dynamicClusterSize) \n+    for (( i=1; i<=$clusterSize; i++ )); do\n+      localServerName=${prefix}$i\n+      sortedServers+=(${localServerName})\n+    done\n+  fi\n+  # Create arrays of ALWAYS policy servers and other servers\n+  sortedServersSize=${#sortedServers[@]}\n+  if [ \"${sortedServersSize}\" -gt 0 ]; then\n+    for localServerName in \"${sortedServers[@]}\"; do\n+      getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+      # Update policy when server name matches current server and unsetting\n+      if [[ \"${withPolicy}\" == \"UNSET\" && \"${serverName}\" == \"${localServerName}\" ]]; then\n+        policy=UNSET\n+      fi\n+      if [ \"${policy}\" == \"ALWAYS\" ]; then\n+        sortedByAlwaysServers+=(${localServerName})\n+      else\n+        otherServers+=(${localServerName})\n+      fi\n+    done\n+  fi\n+  \n+  # append other servers to the list of servers with always policy\n+  otherServersSize=${#otherServers[@]}\n+  if [ \"${otherServersSize}\" -gt 0 ]; then\n+    for otherServer in \"${otherServers[@]}\"; do\n+      sortedByAlwaysServers+=($otherServer)\n+    done\n+  fi\n+}\n+\n+#\n+# Get replica count for a cluster\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster \n+# $3 - Return value containing replica count\n+#\n+function getReplicaCount {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "originalPosition": 279}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNzcwNTM3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-522770537", "createdAt": "2020-11-03T18:28:27Z", "commit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxODoyODoyN1rOHs7aAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxODoyODoyN1rOHs7aAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg3MjcwNA==", "bodyText": "Doc that this shold BE INCREASED,DECREASED, or CONSTANT", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516872704", "createdAt": "2020-11-03T18:28:27Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,606 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value containing cluster level server start policy\n+#\n+function getClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __clusterPolicy=$3\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__clusterPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get server start policy at domain level\n+# $1 - Domain resource in json format\n+# $2 - Return value containing domain level server start policy\n+#\n+function getDomainPolicy {\n+  local domainJson=$1\n+  local __domainPolicy=$2\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\".spec.serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__domainPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get effective start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Name of cluster\n+# $4 - Return value containing effective server start policy\n+#\n+function getEffectivePolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local __currentPolicy=$4\n+  local currentPolicy=\"\"\n+\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentPolicy\n+  if [ -z \"${currentPolicy}\" ]; then\n+    getClusterPolicy \"${domainJson}\" \"${clusterName}\" currentPolicy\n+    if [ -z \"${currentPolicy}\" ]; then\n+      # Start policy is not set at cluster level, check at domain level\n+      getDomainPolicy \"${domainJson}\" currentPolicy\n+      if [ -z \"${currentPolicy}\" ]; then\n+        # Start policy is not set at domain level, default to IF_NEEDED\n+        currentPolicy=IF_NEEDED\n+      fi\n+    fi\n+  fi\n+  eval $__currentPolicy=\"'${currentPolicy}'\"\n+}\n+\n+#\n+# Function to get current start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Return value containing current server start policy\n+#\n+function getServerPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __currentPolicy=$3\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentServerStartPolicy=$(echo ${domainJson} | jq \"${extractPolicyCmd}\")\n+    if [ \"${currentServerStartPolicy}\" == \"null\" ]; then\n+      currentServerStartPolicy=\"\"\n+    fi\n+  fi\n+  eval $__currentPolicy=${currentServerStartPolicy}\n+}\n+\n+#\n+# Function to create server start policy patch string\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Policy value \n+# $4 - Return value containing server start policy patch string\n+#\n+function createServerStartPolicyPatch {\n+  local domainJson=$1\n+  local serverName=$2\n+  local policy=$3\n+  local __result=$4\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentServerStartPolicy\n+  if [ -z \"${currentServerStartPolicy}\" ]; then\n+    # Server start policy doesn't exist, add a new policy\n+    addPolicyCmd=\".[.| length] |= . + {\\\"serverName\\\":\\\"${serverName}\\\", \\\n+      \\\"serverStartPolicy\\\":\\\"${policy}\\\"}\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq .spec.managedServers | jq -c \"${addPolicyCmd}\")\n+  else\n+    # Server start policy exists, replace policy value \n+    replacePolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy) |= \\\"${policy}\\\"\"\n+    servers=\"(.spec.managedServers)\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\" | jq -cr \"${servers}\")\n+  fi\n+  eval $__result=\"'${serverStartPolicyPatch}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy and update replica\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - String containing replica patch string\n+# $4 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicyAndUpdateReplica {\n+  local domainJson=$1\n+  local serverName=$2\n+  local replicaPatch=$3\n+  local __result=$4\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaPatch}\",\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update policy \n+# $1 - String containing start policy info\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdatePolicy {\n+  local startPolicy=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update replica \n+# $1 - String containing replica\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdateReplica {\n+  local replicaInfo=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUpdateReplicaAndPolicy {\n+  local replicaInfo=$1\n+  local startPolicy=$2\n+  local __result=$3\n+\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\",\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __result=$3\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to get sorted list of servers in a cluster.\n+# The sorted list is created in 'sortedByAlwaysServers' array.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if policy of current server would be unset\n+#\n+function getSortedListOfServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withPolicy=$4\n+  local policy=\"\"\n+  local sortedServers=()\n+  local otherServers=()\n+\n+  configMap=$(${kubernetesCli} get cm ${domainUid}-weblogic-domain-introspect-cm \\\n+    -n ${domainNamespace} -o json)\n+  topology=$(echo \"${configMap}\" | jq '.data[\"topology.yaml\"]')\n+  jsonTopology=$(python -c \\\n+    'import sys, yaml, json; print json.dumps(yaml.safe_load('\"${topology}\"'), indent=4)')\n+  clusterTopology=$(echo ${jsonTopology} | jq -r '.domain | .configuredClusters[] | select (.name == '\\\"${clusterName}\\\"')')\n+  dynaCluster=$(echo ${clusterTopology} | jq .dynamicServersConfig)\n+  if [ \"${dynaCluster}\" == \"null\" ]; then\n+    # Cluster is a configured cluster, get server names\n+    servers=($(echo ${clusterTopology} | jq -r .servers[].name))\n+    # Sort server names in numero lexi order\n+    IFS=$'\\n' sortedServers=($(sort --version-sort <<<\"${servers[*]}\" ))\n+    unset IFS\n+    clusterSize=${#sortedServers[@]}\n+  else \n+    # Cluster is a dynamic cluster, calculate server names\n+    prefix=$(echo ${dynaCluster} | jq -r .serverNamePrefix)\n+    clusterSize=$(echo ${dynaCluster} | jq .dynamicClusterSize) \n+    for (( i=1; i<=$clusterSize; i++ )); do\n+      localServerName=${prefix}$i\n+      sortedServers+=(${localServerName})\n+    done\n+  fi\n+  # Create arrays of ALWAYS policy servers and other servers\n+  sortedServersSize=${#sortedServers[@]}\n+  if [ \"${sortedServersSize}\" -gt 0 ]; then\n+    for localServerName in \"${sortedServers[@]}\"; do\n+      getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+      # Update policy when server name matches current server and unsetting\n+      if [[ \"${withPolicy}\" == \"UNSET\" && \"${serverName}\" == \"${localServerName}\" ]]; then\n+        policy=UNSET\n+      fi\n+      if [ \"${policy}\" == \"ALWAYS\" ]; then\n+        sortedByAlwaysServers+=(${localServerName})\n+      else\n+        otherServers+=(${localServerName})\n+      fi\n+    done\n+  fi\n+  \n+  # append other servers to the list of servers with always policy\n+  otherServersSize=${#otherServers[@]}\n+  if [ \"${otherServersSize}\" -gt 0 ]; then\n+    for otherServer in \"${otherServers[@]}\"; do\n+      sortedByAlwaysServers+=($otherServer)\n+    done\n+  fi\n+}\n+\n+#\n+# Get replica count for a cluster\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster \n+# $3 - Return value containing replica count\n+#\n+function getReplicaCount {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __replicaCount=$3\n+\n+  replicasCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).replicas\"\n+  replicaCount=$(echo ${domainJson} | jq \"${replicasCmd}\")\n+  eval $__replicaCount=\"'${replicaCount}'\"\n+\n+}\n+\n+#\n+# Check servers started in a cluster based on server start policy and \n+# replica count.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if replicas will stay constant, incremented or decremented", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "originalPosition": 297}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNzczOTEz", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-522773913", "createdAt": "2020-11-03T18:33:22Z", "commit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxODozMzoyM1rOHs7kPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxODozMzoyM1rOHs7kPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg3NTMyNA==", "bodyText": "Could the determining of replica be replaced with a call to the getReplicaCount function (once the fn is updated to account for spec.replicas)?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516875324", "createdAt": "2020-11-03T18:33:23Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,606 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value containing cluster level server start policy\n+#\n+function getClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __clusterPolicy=$3\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__clusterPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get server start policy at domain level\n+# $1 - Domain resource in json format\n+# $2 - Return value containing domain level server start policy\n+#\n+function getDomainPolicy {\n+  local domainJson=$1\n+  local __domainPolicy=$2\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\".spec.serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__domainPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get effective start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Name of cluster\n+# $4 - Return value containing effective server start policy\n+#\n+function getEffectivePolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local __currentPolicy=$4\n+  local currentPolicy=\"\"\n+\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentPolicy\n+  if [ -z \"${currentPolicy}\" ]; then\n+    getClusterPolicy \"${domainJson}\" \"${clusterName}\" currentPolicy\n+    if [ -z \"${currentPolicy}\" ]; then\n+      # Start policy is not set at cluster level, check at domain level\n+      getDomainPolicy \"${domainJson}\" currentPolicy\n+      if [ -z \"${currentPolicy}\" ]; then\n+        # Start policy is not set at domain level, default to IF_NEEDED\n+        currentPolicy=IF_NEEDED\n+      fi\n+    fi\n+  fi\n+  eval $__currentPolicy=\"'${currentPolicy}'\"\n+}\n+\n+#\n+# Function to get current start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Return value containing current server start policy\n+#\n+function getServerPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __currentPolicy=$3\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentServerStartPolicy=$(echo ${domainJson} | jq \"${extractPolicyCmd}\")\n+    if [ \"${currentServerStartPolicy}\" == \"null\" ]; then\n+      currentServerStartPolicy=\"\"\n+    fi\n+  fi\n+  eval $__currentPolicy=${currentServerStartPolicy}\n+}\n+\n+#\n+# Function to create server start policy patch string\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Policy value \n+# $4 - Return value containing server start policy patch string\n+#\n+function createServerStartPolicyPatch {\n+  local domainJson=$1\n+  local serverName=$2\n+  local policy=$3\n+  local __result=$4\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentServerStartPolicy\n+  if [ -z \"${currentServerStartPolicy}\" ]; then\n+    # Server start policy doesn't exist, add a new policy\n+    addPolicyCmd=\".[.| length] |= . + {\\\"serverName\\\":\\\"${serverName}\\\", \\\n+      \\\"serverStartPolicy\\\":\\\"${policy}\\\"}\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq .spec.managedServers | jq -c \"${addPolicyCmd}\")\n+  else\n+    # Server start policy exists, replace policy value \n+    replacePolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy) |= \\\"${policy}\\\"\"\n+    servers=\"(.spec.managedServers)\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\" | jq -cr \"${servers}\")\n+  fi\n+  eval $__result=\"'${serverStartPolicyPatch}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy and update replica\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - String containing replica patch string\n+# $4 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicyAndUpdateReplica {\n+  local domainJson=$1\n+  local serverName=$2\n+  local replicaPatch=$3\n+  local __result=$4\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaPatch}\",\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update policy \n+# $1 - String containing start policy info\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdatePolicy {\n+  local startPolicy=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update replica \n+# $1 - String containing replica\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdateReplica {\n+  local replicaInfo=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUpdateReplicaAndPolicy {\n+  local replicaInfo=$1\n+  local startPolicy=$2\n+  local __result=$3\n+\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\",\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __result=$3\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to get sorted list of servers in a cluster.\n+# The sorted list is created in 'sortedByAlwaysServers' array.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if policy of current server would be unset\n+#\n+function getSortedListOfServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withPolicy=$4\n+  local policy=\"\"\n+  local sortedServers=()\n+  local otherServers=()\n+\n+  configMap=$(${kubernetesCli} get cm ${domainUid}-weblogic-domain-introspect-cm \\\n+    -n ${domainNamespace} -o json)\n+  topology=$(echo \"${configMap}\" | jq '.data[\"topology.yaml\"]')\n+  jsonTopology=$(python -c \\\n+    'import sys, yaml, json; print json.dumps(yaml.safe_load('\"${topology}\"'), indent=4)')\n+  clusterTopology=$(echo ${jsonTopology} | jq -r '.domain | .configuredClusters[] | select (.name == '\\\"${clusterName}\\\"')')\n+  dynaCluster=$(echo ${clusterTopology} | jq .dynamicServersConfig)\n+  if [ \"${dynaCluster}\" == \"null\" ]; then\n+    # Cluster is a configured cluster, get server names\n+    servers=($(echo ${clusterTopology} | jq -r .servers[].name))\n+    # Sort server names in numero lexi order\n+    IFS=$'\\n' sortedServers=($(sort --version-sort <<<\"${servers[*]}\" ))\n+    unset IFS\n+    clusterSize=${#sortedServers[@]}\n+  else \n+    # Cluster is a dynamic cluster, calculate server names\n+    prefix=$(echo ${dynaCluster} | jq -r .serverNamePrefix)\n+    clusterSize=$(echo ${dynaCluster} | jq .dynamicClusterSize) \n+    for (( i=1; i<=$clusterSize; i++ )); do\n+      localServerName=${prefix}$i\n+      sortedServers+=(${localServerName})\n+    done\n+  fi\n+  # Create arrays of ALWAYS policy servers and other servers\n+  sortedServersSize=${#sortedServers[@]}\n+  if [ \"${sortedServersSize}\" -gt 0 ]; then\n+    for localServerName in \"${sortedServers[@]}\"; do\n+      getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+      # Update policy when server name matches current server and unsetting\n+      if [[ \"${withPolicy}\" == \"UNSET\" && \"${serverName}\" == \"${localServerName}\" ]]; then\n+        policy=UNSET\n+      fi\n+      if [ \"${policy}\" == \"ALWAYS\" ]; then\n+        sortedByAlwaysServers+=(${localServerName})\n+      else\n+        otherServers+=(${localServerName})\n+      fi\n+    done\n+  fi\n+  \n+  # append other servers to the list of servers with always policy\n+  otherServersSize=${#otherServers[@]}\n+  if [ \"${otherServersSize}\" -gt 0 ]; then\n+    for otherServer in \"${otherServers[@]}\"; do\n+      sortedByAlwaysServers+=($otherServer)\n+    done\n+  fi\n+}\n+\n+#\n+# Get replica count for a cluster\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster \n+# $3 - Return value containing replica count\n+#\n+function getReplicaCount {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __replicaCount=$3\n+\n+  replicasCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).replicas\"\n+  replicaCount=$(echo ${domainJson} | jq \"${replicasCmd}\")\n+  eval $__replicaCount=\"'${replicaCount}'\"\n+\n+}\n+\n+#\n+# Check servers started in a cluster based on server start policy and \n+# replica count.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if replicas will stay constant, incremented or decremented\n+# $5 - Indicates if policy of current server will stay same or unset\n+# $6 - Return value indicating if current server will be started\n+#\n+function checkStartedServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withReplicas=$4\n+  local withPolicy=$5\n+  local __started=$6\n+  local localServerName=\"\"\n+  local policy=\"\"\n+  local replicaCount=0\n+  local currentReplicas=0\n+  local startedServers=()\n+  local sortedByAlwaysServers=()\n+  \n+  # Get sorted list of servers in 'sortedByAlwaysServers' array\n+  getSortedListOfServers \"${domainJson}\" \"${serverName}\" \"${clusterName}\" \"${withPolicy}\"\n+  getReplicaCount \"${domainJson}\" \"${clusterName}\" replicaCount\n+  # Increment or decrement the replica count based on 'withReplicas' input parameter\n+  if [ \"${withReplicas}\" == \"INCREASED\" ]; then\n+    replicaCount=$((replicaCount+1))\n+  elif [ \"${withReplicas}\" == \"DECREASED\" ]; then\n+    replicaCount=$((replicaCount-1))\n+  fi\n+  sortedByAlwaysSize=${#sortedByAlwaysServers[@]}\n+  if [ \"${sortedByAlwaysSize}\" -gt 0 ]; then\n+    for localServerName in \"${sortedByAlwaysServers[@]}\"; do\n+      getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+      # Update policy when server name matches current server and unsetting\n+      if [[ \"${serverName}\" == \"${localServerName}\" && \"${withPolicy}\" == \"UNSET\" ]]; then\n+        policy=UNSET\n+      fi\n+      # check if server should start based on replica count, policy and current replicas\n+      shouldStart \"${currentReplicas}\" \"${policy}\" \"${replicaCount}\" result\n+      if [ \"${result}\" == 'True' ]; then\n+        # server should start, increment current replicas and add server to list of started servers\n+        currentReplicas=$((currentReplicas+1))\n+        startedServers+=(${localServerName})\n+      fi\n+    done\n+  fi\n+  startedSize=${#startedServers[@]}\n+  if [ ${startedSize} -gt 0 ]; then\n+    # check if current server is in the list of started servers\n+    if checkStringInArray ${serverName} ${startedServers[@]}; then\n+      eval $__started=\"true\"\n+      return\n+    fi\n+  fi\n+  eval $__started=\"false\"\n+}\n+\n+#\n+# Function to check if server should start based on policy and current replicas\n+# $1 - Current number of replicas\n+# $2 - Server start policy\n+# $3 - Replica count\n+# $4 - Return value\n+#\n+function shouldStart {\n+  local currentReplicas=$1\n+  local policy=$2\n+  local replicaCount=$3 \n+  local __result=$4\n+\n+  if [ \"$policy\" == \"ALWAYS\" ]; then\n+    eval $__result=True\n+  elif [ \"$policy\" == \"NEVER\" ]; then\n+    eval $__result=False\n+  elif [ \"${currentReplicas}\" -lt \"${replicaCount}\" ]; then\n+    eval $__result=True\n+  else \n+    eval $__result=False\n+  fi\n+}\n+\n+#\n+# Function to create patch string for updating replica count\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster whose replica count will be patched\n+# $3 - operatation string indicating whether to increment or decrement count\n+# $4 - Return value containing replica update patch string\n+# $5 - Retrun value containing updated replica count\n+#\n+function createReplicaPatch {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local operation=$3\n+  local __result=$4\n+  local __replicaCount=$5\n+  local maxReplicas=\"\"\n+  local errorMessage=\"@@ ERROR: Maximum number of servers allowed (maxReplica = ${maxReplicas}) \\\n+are already running. Please increase cluster size to start new servers.\"\n+\n+  replicasCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).replicas\"\n+  maxReplicaCmd=\"(.status.clusters[] | select (.clusterName == \\\"${clusterName}\\\")) \\\n+    | .maximumReplicas\"\n+  replica=$(echo ${domainJson} | jq \"${replicasCmd}\")\n+  if [[ -z \"${replica}\" || \"${replica}\" == \"null\" ]]; then\n+    replica=$(echo ${domainJson} | jq .spec.replicas)\n+  fi", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "originalPosition": 401}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNzkxMDk3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-522791097", "createdAt": "2020-11-03T18:58:10Z", "commit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxODo1ODoxMVrOHs8ZAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxODo1ODoxMVrOHs8ZAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg4ODgzNA==", "bodyText": "add \"and the cluster's replica count is set higher than the default (spec.replicas or spec.cluster.CLUSTERNAME.replicas is set higher than zero\").", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516888834", "createdAt": "2020-11-03T18:58:11Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startCluster.sh", "diffHunk": "@@ -0,0 +1,120 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script starts a WebLogic cluster in a domain by patching\n+  'spec.clusters[<cluster-name>].serverStartPolicy' attribute of the domain\n+  resource to 'IF_NEEDED'. This change will cause the operator to initiate\n+  startup of cluster's WebLogic server instance pods if the pods are not\n+  already running.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNzkxNjAw", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-522791600", "createdAt": "2020-11-03T18:58:54Z", "commit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxODo1ODo1NFrOHs8adQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxODo1ODo1NFrOHs8adQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg4OTIwNQ==", "bodyText": "should there be a period \".\"?  e.g 'spec.clusters.[].serverStartPolicy'", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r516889205", "createdAt": "2020-11-03T18:58:54Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startCluster.sh", "diffHunk": "@@ -0,0 +1,120 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script starts a WebLogic cluster in a domain by patching\n+  'spec.clusters[<cluster-name>].serverStartPolicy' attribute of the domain", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10feb9907e6a6ae987998b1792243ac22d041cb1"}, "originalPosition": 15}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39", "author": {"user": {"login": "ankedia", "name": "Anil Kedia"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/15c725a6c333bfd7675506f68ce06f1efa20bd39", "committedDate": "2020-11-03T21:52:18Z", "message": "Latest review comment changes."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzc0NTc4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-523374578", "createdAt": "2020-11-04T13:47:59Z", "commit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0ODowMFrOHtYytg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0ODowMFrOHtYytg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NDE2Ng==", "bodyText": "minor nit: clusterPolicyCmd -> domainPolicyCommand", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r517354166", "createdAt": "2020-11-04T13:48:00Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,605 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value for cluster level server start policy.\n+#      Legal return values are \"NEVER\" or \"IF_NEEDED\" or \"\".\n+#\n+function getClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __clusterPolicy=$3\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__clusterPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get server start policy at domain level\n+# $1 - Domain resource in json format\n+# $2 - Return value containing domain level server start policy.\n+#      Legal retrun values are \"NEVER\" or \"IF_NEEDED\" or \"ADMIN_ONLY\".\n+#\n+function getDomainPolicy {\n+  local domainJson=$1\n+  local __domainPolicy=$2\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\".spec.serverStartPolicy\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzc1NzU1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-523375755", "createdAt": "2020-11-04T13:49:19Z", "commit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0OToxOVrOHtY2Mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0OToxOVrOHtY2Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NTA1OQ==", "bodyText": "This could be simplified by leveraging the getClusterPolicy and getDomainPolicy helper.sh methods.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r517355059", "createdAt": "2020-11-04T13:49:19Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startCluster.sh", "diffHunk": "@@ -0,0 +1,121 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script starts a WebLogic cluster in a domain by patching\n+  'spec.clusters[<cluster-name>].serverStartPolicy' attribute of the domain\n+  resource to 'IF_NEEDED'. This change will cause the operator to initiate\n+  startup of cluster's WebLogic server instance pods if the pods are not\n+  already running and the spec.replicas or\n+  'spec.clusters[<cluster-name>].serverStartPolicy' is set higher than zero.\n+ \n+  Usage:\n+ \n+    $(basename $0) -c mycluster [-n mynamespace] [-d mydomainuid] [-m kubecli]\n+  \n+    -c <cluster-name>   : Cluster name parameter is required.\n+\n+    -d <domain_uid>     : Domain unique-id. Default is 'sample-domain1'.\n+\n+    -n <namespace>      : Domain namespace. Default is 'sample-domain1-ns'.\n+\n+    -m <kubernetes_cli> : Kubernetes command line interface. Default is 'kubectl' if KUBERNETES_CLI env\n+                          variable is not set. Otherwise default is the value of KUBERNETES_CLI env variable.\n+\n+    -h                  : This help.\n+   \n+EOF\n+exit $1\n+}\n+\n+set -eu\n+\n+kubernetesCli=${KUBERNETES_CLI:-kubectl}\n+clusterName=\"\"\n+domainUid=\"sample-domain1\"\n+domainNamespace=\"sample-domain1-ns\"\n+\n+while getopts \"c:n:m:d:h\" opt; do\n+  case $opt in\n+    c) clusterName=\"${OPTARG}\"\n+    ;;\n+    n) domainNamespace=\"${OPTARG}\"\n+    ;;\n+    d) domainUid=\"${OPTARG}\"\n+    ;;\n+    m) kubernetesCli=\"${OPTARG}\"\n+    ;;\n+    h) usage 0\n+    ;;\n+    *) usage 1\n+    ;;\n+  esac\n+done\n+\n+#\n+# Function to perform validations, read files and initialize workspace\n+#\n+function initialize {\n+\n+  # Validate the required files exist\n+  validateErrors=false\n+\n+  validateKubernetesCliAvailable\n+  validateJqAvailable\n+\n+  if [ -z \"${clusterName}\" ]; then\n+    validationError \"Please specify cluster name using '-c' parameter e.g. '-c cluster-1'.\"\n+  fi\n+\n+  isValidCluster=\"\"\n+  validateClusterName \"${domainUid}\" \"${domainNamespace}\" \"${clusterName}\" isValidCluster\n+\n+  if [ \"${isValidCluster}\" != 'true' ]; then\n+    validationError \"cluster ${clusterName} is not part of domain ${domainUid} in namespace ${domainNamespace}.\"\n+  fi\n+\n+  failIfValidationErrors\n+}\n+\n+initialize\n+\n+# Get the domain in json format\n+domainJson=$(${kubernetesCli} get domain ${domainUid} -n ${domainNamespace} -o json)\n+\n+# Get server start policy for this cluster", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "originalPosition": 94}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzc4OTM2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-523378936", "createdAt": "2020-11-04T13:52:53Z", "commit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1Mjo1M1rOHtY_iQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1Mjo1M1rOHtY_iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NzQ0OQ==", "bodyText": "Can this clause be reached? It looks like the above code sets startPolicy to IF_NEEDED if it's not already set.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r517357449", "createdAt": "2020-11-04T13:52:53Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startCluster.sh", "diffHunk": "@@ -0,0 +1,121 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script starts a WebLogic cluster in a domain by patching\n+  'spec.clusters[<cluster-name>].serverStartPolicy' attribute of the domain\n+  resource to 'IF_NEEDED'. This change will cause the operator to initiate\n+  startup of cluster's WebLogic server instance pods if the pods are not\n+  already running and the spec.replicas or\n+  'spec.clusters[<cluster-name>].serverStartPolicy' is set higher than zero.\n+ \n+  Usage:\n+ \n+    $(basename $0) -c mycluster [-n mynamespace] [-d mydomainuid] [-m kubecli]\n+  \n+    -c <cluster-name>   : Cluster name parameter is required.\n+\n+    -d <domain_uid>     : Domain unique-id. Default is 'sample-domain1'.\n+\n+    -n <namespace>      : Domain namespace. Default is 'sample-domain1-ns'.\n+\n+    -m <kubernetes_cli> : Kubernetes command line interface. Default is 'kubectl' if KUBERNETES_CLI env\n+                          variable is not set. Otherwise default is the value of KUBERNETES_CLI env variable.\n+\n+    -h                  : This help.\n+   \n+EOF\n+exit $1\n+}\n+\n+set -eu\n+\n+kubernetesCli=${KUBERNETES_CLI:-kubectl}\n+clusterName=\"\"\n+domainUid=\"sample-domain1\"\n+domainNamespace=\"sample-domain1-ns\"\n+\n+while getopts \"c:n:m:d:h\" opt; do\n+  case $opt in\n+    c) clusterName=\"${OPTARG}\"\n+    ;;\n+    n) domainNamespace=\"${OPTARG}\"\n+    ;;\n+    d) domainUid=\"${OPTARG}\"\n+    ;;\n+    m) kubernetesCli=\"${OPTARG}\"\n+    ;;\n+    h) usage 0\n+    ;;\n+    *) usage 1\n+    ;;\n+  esac\n+done\n+\n+#\n+# Function to perform validations, read files and initialize workspace\n+#\n+function initialize {\n+\n+  # Validate the required files exist\n+  validateErrors=false\n+\n+  validateKubernetesCliAvailable\n+  validateJqAvailable\n+\n+  if [ -z \"${clusterName}\" ]; then\n+    validationError \"Please specify cluster name using '-c' parameter e.g. '-c cluster-1'.\"\n+  fi\n+\n+  isValidCluster=\"\"\n+  validateClusterName \"${domainUid}\" \"${domainNamespace}\" \"${clusterName}\" isValidCluster\n+\n+  if [ \"${isValidCluster}\" != 'true' ]; then\n+    validationError \"cluster ${clusterName} is not part of domain ${domainUid} in namespace ${domainNamespace}.\"\n+  fi\n+\n+  failIfValidationErrors\n+}\n+\n+initialize\n+\n+# Get the domain in json format\n+domainJson=$(${kubernetesCli} get domain ${domainUid} -n ${domainNamespace} -o json)\n+\n+# Get server start policy for this cluster\n+startPolicy=$(echo ${domainJson} | jq -r '(.spec.clusters[] | select (.clusterName == \"'${clusterName}'\") | .serverStartPolicy)')\n+if [ \"${startPolicy}\" == \"null\" ]; then\n+  startPolicy=$(echo ${domainJson} | jq -r .spec.serverStartPolicy)\n+  if [ \"${startPolicy}\" == \"null\" ]; then\n+    startPolicy=IF_NEEDED\n+  fi\n+fi\n+\n+if [ \"${startPolicy}\" == 'IF_NEEDED' ]; then \n+  printInfo \"No changes needed, exiting. The cluster '${clusterName}' is already started or starting. The effective value of 'spec.clusters[?(clusterName=\"${clusterName}\"].serverStartPolicy' attribute on the domain resource is 'IF_NEEDED'.\"\n+  exit 0\n+fi\n+\n+if [ -z ${startPolicy} ]; then", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "originalPosition": 108}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzc5NTUz", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-523379553", "createdAt": "2020-11-04T13:53:38Z", "commit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1MzozOFrOHtZBVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1MzozOFrOHtZBVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NzkxMA==", "bodyText": "Should this script exit early with an error if domain policy is NEVER?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r517357910", "createdAt": "2020-11-04T13:53:38Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startCluster.sh", "diffHunk": "@@ -0,0 +1,121 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script starts a WebLogic cluster in a domain by patching\n+  'spec.clusters[<cluster-name>].serverStartPolicy' attribute of the domain\n+  resource to 'IF_NEEDED'. This change will cause the operator to initiate\n+  startup of cluster's WebLogic server instance pods if the pods are not\n+  already running and the spec.replicas or\n+  'spec.clusters[<cluster-name>].serverStartPolicy' is set higher than zero.\n+ \n+  Usage:\n+ \n+    $(basename $0) -c mycluster [-n mynamespace] [-d mydomainuid] [-m kubecli]\n+  \n+    -c <cluster-name>   : Cluster name parameter is required.\n+\n+    -d <domain_uid>     : Domain unique-id. Default is 'sample-domain1'.\n+\n+    -n <namespace>      : Domain namespace. Default is 'sample-domain1-ns'.\n+\n+    -m <kubernetes_cli> : Kubernetes command line interface. Default is 'kubectl' if KUBERNETES_CLI env\n+                          variable is not set. Otherwise default is the value of KUBERNETES_CLI env variable.\n+\n+    -h                  : This help.\n+   \n+EOF\n+exit $1\n+}\n+\n+set -eu\n+\n+kubernetesCli=${KUBERNETES_CLI:-kubectl}\n+clusterName=\"\"\n+domainUid=\"sample-domain1\"\n+domainNamespace=\"sample-domain1-ns\"\n+\n+while getopts \"c:n:m:d:h\" opt; do\n+  case $opt in\n+    c) clusterName=\"${OPTARG}\"\n+    ;;\n+    n) domainNamespace=\"${OPTARG}\"\n+    ;;\n+    d) domainUid=\"${OPTARG}\"\n+    ;;\n+    m) kubernetesCli=\"${OPTARG}\"\n+    ;;\n+    h) usage 0\n+    ;;\n+    *) usage 1\n+    ;;\n+  esac\n+done\n+\n+#\n+# Function to perform validations, read files and initialize workspace\n+#\n+function initialize {\n+\n+  # Validate the required files exist\n+  validateErrors=false\n+\n+  validateKubernetesCliAvailable\n+  validateJqAvailable\n+\n+  if [ -z \"${clusterName}\" ]; then\n+    validationError \"Please specify cluster name using '-c' parameter e.g. '-c cluster-1'.\"\n+  fi\n+\n+  isValidCluster=\"\"\n+  validateClusterName \"${domainUid}\" \"${domainNamespace}\" \"${clusterName}\" isValidCluster\n+\n+  if [ \"${isValidCluster}\" != 'true' ]; then\n+    validationError \"cluster ${clusterName} is not part of domain ${domainUid} in namespace ${domainNamespace}.\"\n+  fi\n+\n+  failIfValidationErrors\n+}\n+\n+initialize\n+\n+# Get the domain in json format\n+domainJson=$(${kubernetesCli} get domain ${domainUid} -n ${domainNamespace} -o json)\n+\n+# Get server start policy for this cluster\n+startPolicy=$(echo ${domainJson} | jq -r '(.spec.clusters[] | select (.clusterName == \"'${clusterName}'\") | .serverStartPolicy)')\n+if [ \"${startPolicy}\" == \"null\" ]; then\n+  startPolicy=$(echo ${domainJson} | jq -r .spec.serverStartPolicy)\n+  if [ \"${startPolicy}\" == \"null\" ]; then\n+    startPolicy=IF_NEEDED\n+  fi\n+fi\n+\n+if [ \"${startPolicy}\" == 'IF_NEEDED' ]; then \n+  printInfo \"No changes needed, exiting. The cluster '${clusterName}' is already started or starting. The effective value of 'spec.clusters[?(clusterName=\"${clusterName}\"].serverStartPolicy' attribute on the domain resource is 'IF_NEEDED'.\"\n+  exit 0\n+fi", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "originalPosition": 106}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzgxODgy", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-523381882", "createdAt": "2020-11-04T13:56:14Z", "commit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1NjoxNFrOHtZIOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1NjoxNFrOHtZIOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1OTY3Mg==", "bodyText": "This should use the existing helper function that does same...", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r517359672", "createdAt": "2020-11-04T13:56:14Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startDomain.sh", "diffHunk": "@@ -0,0 +1,78 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script starts a deployed WebLogic domain by patching 'spec.serverStartPolicy'\n+  attribute of the domain resource to 'IF_NEEDED'. This change will cause the operator\n+  to initiate startup of domain's WebLogic server instance pods if the pods are not\n+  already running.\n+ \n+  Usage:\n+ \n+    $(basename $0) [-n mynamespace] [-d mydomainuid] [-m kubecli]\n+  \n+    -d <domain_uid>     : Domain unique-id. Default is 'sample-domain1'.\n+\n+    -n <namespace>      : Domain namespace. Default is 'sample-domain1-ns'.\n+\n+    -m <kubernetes_cli> : Kubernetes command line interface. Default is 'kubectl' if KUBERNETES_CLI env\n+                          variable is not set. Otherwise default is the value of KUBERNETES_CLI env variable.\n+\n+    -h                  : This help.\n+   \n+EOF\n+exit $1\n+}\n+\n+kubernetesCli=${KUBERNETES_CLI:-kubectl}\n+domainUid=\"sample-domain1\"\n+domainNamespace=\"sample-domain1-ns\"\n+\n+while getopts \"n:d:m:h\" opt; do\n+  case $opt in\n+    n) domainNamespace=\"${OPTARG}\"\n+    ;;\n+    d) domainUid=\"${OPTARG}\"\n+    ;;\n+    m) kubernetesCli=\"${OPTARG}\"\n+    ;;\n+    h) usage 0\n+    ;;\n+    *) usage 1\n+    ;;\n+  esac\n+done\n+\n+\n+set -eu\n+set -o pipefail\n+\n+if ! [ -x \"$(command -v ${kubernetesCli})\" ]; then\n+  fail \"${kubernetesCli} is not installed\"\n+fi\n+\n+serverStartPolicy=`${kubernetesCli} -n ${domainNamespace} get domain ${domainUid} -o=jsonpath='{.spec.serverStartPolicy}'`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "originalPosition": 63}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzgyMzEw", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-523382310", "createdAt": "2020-11-04T13:56:42Z", "commit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1Njo0M1rOHtZJaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1Njo0M1rOHtZJaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1OTk3Nw==", "bodyText": "This should use the existing helper functions that does same (see startCluster.sh).", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r517359977", "createdAt": "2020-11-04T13:56:43Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/startDomain.sh", "diffHunk": "@@ -0,0 +1,78 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script starts a deployed WebLogic domain by patching 'spec.serverStartPolicy'\n+  attribute of the domain resource to 'IF_NEEDED'. This change will cause the operator\n+  to initiate startup of domain's WebLogic server instance pods if the pods are not\n+  already running.\n+ \n+  Usage:\n+ \n+    $(basename $0) [-n mynamespace] [-d mydomainuid] [-m kubecli]\n+  \n+    -d <domain_uid>     : Domain unique-id. Default is 'sample-domain1'.\n+\n+    -n <namespace>      : Domain namespace. Default is 'sample-domain1-ns'.\n+\n+    -m <kubernetes_cli> : Kubernetes command line interface. Default is 'kubectl' if KUBERNETES_CLI env\n+                          variable is not set. Otherwise default is the value of KUBERNETES_CLI env variable.\n+\n+    -h                  : This help.\n+   \n+EOF\n+exit $1\n+}\n+\n+kubernetesCli=${KUBERNETES_CLI:-kubectl}\n+domainUid=\"sample-domain1\"\n+domainNamespace=\"sample-domain1-ns\"\n+\n+while getopts \"n:d:m:h\" opt; do\n+  case $opt in\n+    n) domainNamespace=\"${OPTARG}\"\n+    ;;\n+    d) domainUid=\"${OPTARG}\"\n+    ;;\n+    m) kubernetesCli=\"${OPTARG}\"\n+    ;;\n+    h) usage 0\n+    ;;\n+    *) usage 1\n+    ;;\n+  esac\n+done\n+\n+\n+set -eu\n+set -o pipefail\n+\n+if ! [ -x \"$(command -v ${kubernetesCli})\" ]; then\n+  fail \"${kubernetesCli} is not installed\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "originalPosition": 60}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzg2MDc2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-523386076", "createdAt": "2020-11-04T14:00:47Z", "commit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDowMDo0N1rOHtZU2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDowMDo0N1rOHtZU2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2MjkwNA==", "bodyText": "Just in case the replica count already happens to be above max, maybe change to -ge and modify the info message accordingly.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r517362904", "createdAt": "2020-11-04T14:00:47Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/helper.sh", "diffHunk": "@@ -0,0 +1,605 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+#\n+# Function to get server start policy at cluster level\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster\n+# $3 - Return value for cluster level server start policy.\n+#      Legal return values are \"NEVER\" or \"IF_NEEDED\" or \"\".\n+#\n+function getClusterPolicy {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __clusterPolicy=$3\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__clusterPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get server start policy at domain level\n+# $1 - Domain resource in json format\n+# $2 - Return value containing domain level server start policy.\n+#      Legal retrun values are \"NEVER\" or \"IF_NEEDED\" or \"ADMIN_ONLY\".\n+#\n+function getDomainPolicy {\n+  local domainJson=$1\n+  local __domainPolicy=$2\n+  local effectivePolicy=\"\"\n+\n+  clusterPolicyCmd=\".spec.serverStartPolicy\"\n+  effectivePolicy=$(echo ${domainJson} | jq \"${clusterPolicyCmd}\")\n+  if [ \"${effectivePolicy}\" == \"null\" ]; then\n+    effectivePolicy=\"\"\n+  fi\n+  eval $__domainPolicy=${effectivePolicy}\n+}\n+\n+#\n+# Function to get effective start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Name of cluster\n+# $4 - Return value containing effective server start policy\n+#      Legal retrun values are \"NEVER\" or \"IF_NEEDED\" or \"ALWAYS\".\n+#\n+function getEffectivePolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local __currentPolicy=$4\n+  local currentPolicy=\"\"\n+\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentPolicy\n+  if [ -z \"${currentPolicy}\" ]; then\n+    getClusterPolicy \"${domainJson}\" \"${clusterName}\" currentPolicy\n+    if [ -z \"${currentPolicy}\" ]; then\n+      # Start policy is not set at cluster level, check at domain level\n+      getDomainPolicy \"${domainJson}\" currentPolicy\n+      if [ -z \"${currentPolicy}\" ]; then\n+        # Start policy is not set at domain level, default to IF_NEEDED\n+        currentPolicy=IF_NEEDED\n+      fi\n+    fi\n+  fi\n+  eval $__currentPolicy=\"'${currentPolicy}'\"\n+}\n+\n+#\n+# Function to get current start policy of server\n+# $1 - Domain resource in json format\n+# $2 - Name of server\n+# $3 - Return value containing current server start policy\n+#      Legal retrun values are \"NEVER\" or \"IF_NEEDED\", \"ALWAYS\" or \"\".\n+#\n+function getServerPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __currentPolicy=$3\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  managedServers=$(echo ${domainJson} | jq -cr '(.spec.managedServers)')\n+  if [ \"${managedServers}\" != \"null\" ]; then\n+    extractPolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy)\"\n+    currentServerStartPolicy=$(echo ${domainJson} | jq \"${extractPolicyCmd}\")\n+    if [ \"${currentServerStartPolicy}\" == \"null\" ]; then\n+      currentServerStartPolicy=\"\"\n+    fi\n+  fi\n+  eval $__currentPolicy=${currentServerStartPolicy}\n+}\n+\n+#\n+# Function to create server start policy patch string\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Policy value \n+# $4 - Return value containing server start policy patch string\n+#\n+function createServerStartPolicyPatch {\n+  local domainJson=$1\n+  local serverName=$2\n+  local policy=$3\n+  local __result=$4\n+  local currentServerStartPolicy=\"\"\n+\n+  # Get server start policy for this server\n+  getServerPolicy \"${domainJson}\" \"${serverName}\" currentServerStartPolicy\n+  if [ -z \"${currentServerStartPolicy}\" ]; then\n+    # Server start policy doesn't exist, add a new policy\n+    addPolicyCmd=\".[.| length] |= . + {\\\"serverName\\\":\\\"${serverName}\\\", \\\n+      \\\"serverStartPolicy\\\":\\\"${policy}\\\"}\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq .spec.managedServers | jq -c \"${addPolicyCmd}\")\n+  else\n+    # Server start policy exists, replace policy value \n+    replacePolicyCmd=\"(.spec.managedServers[] \\\n+      | select (.serverName == \\\"${serverName}\\\") | .serverStartPolicy) |= \\\"${policy}\\\"\"\n+    servers=\"(.spec.managedServers)\"\n+    serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\" | jq -cr \"${servers}\")\n+  fi\n+  eval $__result=\"'${serverStartPolicyPatch}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy and update replica\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - String containing replica patch string\n+# $4 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicyAndUpdateReplica {\n+  local domainJson=$1\n+  local serverName=$2\n+  local replicaPatch=$3\n+  local __result=$4\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaPatch}\",\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update policy \n+# $1 - String containing start policy info\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdatePolicy {\n+  local startPolicy=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update replica \n+# $1 - String containing replica\n+# $2 - String containing json to patch domain resource\n+#\n+function createPatchJsonToUpdateReplica {\n+  local replicaInfo=$1\n+  local __result=$2\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to update replica and policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUpdateReplicaAndPolicy {\n+  local replicaInfo=$1\n+  local startPolicy=$2\n+  local __result=$3\n+\n+  patchJson=\"{\\\"spec\\\": {\\\"clusters\\\": \"${replicaInfo}\",\\\"managedServers\\\": \"${startPolicy}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to create patch json string to unset policy\n+# $1 - Domain resource in json format\n+# $2 - Name of server whose policy will be patched\n+# $3 - Return value containing patch json string\n+#\n+function createPatchJsonToUnsetPolicy {\n+  local domainJson=$1\n+  local serverName=$2\n+  local __result=$3\n+\n+  replacePolicyCmd=\"[(.spec.managedServers[] \\\n+    | select (.serverName != \\\"${serverName}\\\"))]\"\n+  serverStartPolicyPatch=$(echo ${domainJson} | jq \"${replacePolicyCmd}\")\n+  patchJson=\"{\\\"spec\\\": {\\\"managedServers\\\": \"${serverStartPolicyPatch}\"}}\"\n+  eval $__result=\"'${patchJson}'\"\n+}\n+\n+#\n+# Function to get sorted list of servers in a cluster.\n+# The sorted list is created in 'sortedByAlwaysServers' array.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if policy of current server would be unset.\n+#      valid values are \"UNSET\" and \"CONSTANT\"\n+#\n+function getSortedListOfServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withPolicy=$4\n+  local policy=\"\"\n+  local sortedServers=()\n+  local otherServers=()\n+\n+  configMap=$(${kubernetesCli} get cm ${domainUid}-weblogic-domain-introspect-cm \\\n+    -n ${domainNamespace} -o json)\n+  topology=$(echo \"${configMap}\" | jq '.data[\"topology.yaml\"]')\n+  jsonTopology=$(python -c \\\n+    'import sys, yaml, json; print json.dumps(yaml.safe_load('\"${topology}\"'), indent=4)')\n+  clusterTopology=$(echo ${jsonTopology} | jq -r '.domain | .configuredClusters[] | select (.name == '\\\"${clusterName}\\\"')')\n+  dynaCluster=$(echo ${clusterTopology} | jq .dynamicServersConfig)\n+  if [ \"${dynaCluster}\" == \"null\" ]; then\n+    # Cluster is a configured cluster, get server names\n+    servers=($(echo ${clusterTopology} | jq -r .servers[].name))\n+    # Sort server names in numero lexi order\n+    IFS=$'\\n' sortedServers=($(sort --version-sort <<<\"${servers[*]}\" ))\n+    unset IFS\n+    clusterSize=${#sortedServers[@]}\n+  else \n+    # Cluster is a dynamic cluster, calculate server names\n+    prefix=$(echo ${dynaCluster} | jq -r .serverNamePrefix)\n+    clusterSize=$(echo ${dynaCluster} | jq .dynamicClusterSize) \n+    for (( i=1; i<=$clusterSize; i++ )); do\n+      localServerName=${prefix}$i\n+      sortedServers+=(${localServerName})\n+    done\n+  fi\n+  # Create arrays of ALWAYS policy servers and other servers\n+  for localServerName in ${sortedServers[@]:-}; do\n+    getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+    # Update policy when server name matches current server and unsetting\n+    if [[ \"${withPolicy}\" == \"UNSET\" && \"${serverName}\" == \"${localServerName}\" ]]; then\n+      policy=UNSET\n+    fi\n+    if [ \"${policy}\" == \"ALWAYS\" ]; then\n+      sortedByAlwaysServers+=(${localServerName})\n+    else\n+      otherServers+=(${localServerName})\n+    fi\n+  done\n+  \n+  # append other servers to the list of servers with always policy\n+  for otherServer in ${otherServers[@]:-}; do\n+    sortedByAlwaysServers+=($otherServer)\n+  done\n+}\n+\n+#\n+# Get replica count for a cluster\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster \n+# $3 - Return value containing replica count\n+#\n+function getReplicaCount {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __replicaCount=$3\n+\n+  replicasCmd=\"(.spec.clusters[] \\\n+    | select (.clusterName == \\\"${clusterName}\\\")).replicas\"\n+  replicaCount=$(echo ${domainJson} | jq \"${replicasCmd}\")\n+  if [[ -z \"${replicaCount}\" || \"${replicaCount}\" == \"null\" ]]; then\n+    replicaCount=$(echo ${domainJson} | jq .spec.replicas)\n+  fi\n+  if [[ -z \"${replicaCount}\" || \"${replicaCount}\" == \"null\" ]]; then\n+    replicaCount=0\n+  fi\n+  eval $__replicaCount=\"'${replicaCount}'\"\n+\n+}\n+\n+#\n+# Check servers started in a cluster based on server start policy and \n+# replica count.\n+# $1 - Domain resource in json format\n+# $2 - Name of server \n+# $3 - Name of cluster \n+# $4 - Indicates if replicas will stay constant, incremented or decremented.\n+#      Valid values are \"CONSTANT\", \"INCREMENT\" and \"DECREMENT\"\n+# $5 - Indicates if policy of current server will stay constant or unset.\n+#      Valid values are \"CONSTANT\" and \"UNSET\"\n+# $6 - Return value of \"true\" or \"false\" indicating if current server will be started\n+#\n+function checkStartedServers {\n+  local domainJson=$1\n+  local serverName=$2\n+  local clusterName=$3\n+  local withReplicas=$4\n+  local withPolicy=$5\n+  local __started=$6\n+  local localServerName=\"\"\n+  local policy=\"\"\n+  local replicaCount=0\n+  local currentReplicas=0\n+  local startedServers=()\n+  local sortedByAlwaysServers=()\n+  \n+  # Get sorted list of servers in 'sortedByAlwaysServers' array\n+  getSortedListOfServers \"${domainJson}\" \"${serverName}\" \"${clusterName}\" \"${withPolicy}\"\n+  getReplicaCount \"${domainJson}\" \"${clusterName}\" replicaCount\n+  # Increment or decrement the replica count based on 'withReplicas' input parameter\n+  if [ \"${withReplicas}\" == \"INCREASED\" ]; then\n+    replicaCount=$((replicaCount+1))\n+  elif [ \"${withReplicas}\" == \"DECREASED\" ]; then\n+    replicaCount=$((replicaCount-1))\n+  fi\n+  for localServerName in ${sortedByAlwaysServers[@]:-}; do\n+    getEffectivePolicy \"${domainJson}\" \"${localServerName}\" \"${clusterName}\" policy\n+    # Update policy when server name matches current server and unsetting\n+    if [[ \"${serverName}\" == \"${localServerName}\" && \"${withPolicy}\" == \"UNSET\" ]]; then\n+      policy=UNSET\n+    fi\n+    # check if server should start based on replica count, policy and current replicas\n+    shouldStart \"${currentReplicas}\" \"${policy}\" \"${replicaCount}\" result\n+    if [ \"${result}\" == 'true' ]; then\n+      # server should start, increment current replicas and add server to list of started servers\n+      currentReplicas=$((currentReplicas+1))\n+      startedServers+=(${localServerName})\n+    fi\n+  done\n+  startedSize=${#startedServers[@]}\n+  if [ ${startedSize} -gt 0 ]; then\n+    # check if current server is in the list of started servers\n+    if checkStringInArray ${serverName} ${startedServers[@]}; then\n+      eval $__started=\"true\"\n+      return\n+    fi\n+  fi\n+  eval $__started=\"false\"\n+}\n+\n+#\n+# Function to check if server should start based on policy and current replicas\n+# $1 - Current number of replicas\n+# $2 - Server start policy\n+# $3 - Replica count\n+# $4 - Returns \"true\" or \"false\" indicating if server should start.\n+#\n+function shouldStart {\n+  local currentReplicas=$1\n+  local policy=$2\n+  local replicaCount=$3 \n+  local __result=$4\n+\n+  if [ \"$policy\" == \"ALWAYS\" ]; then\n+    eval $__result=true\n+  elif [ \"$policy\" == \"NEVER\" ]; then\n+    eval $__result=false\n+  elif [ \"${currentReplicas}\" -lt \"${replicaCount}\" ]; then\n+    eval $__result=true\n+  else \n+    eval $__result=false\n+  fi\n+}\n+\n+#\n+# Function to create patch string for updating replica count\n+# $1 - Domain resource in json format\n+# $2 - Name of cluster whose replica count will be patched\n+# $3 - operation string indicating whether to increment or decrement replica count. \n+#      Valid values are \"INCREMENT\" and \"DECREMENT\"\n+# $4 - Return value containing replica update patch string\n+# $5 - Return value containing updated replica count\n+#\n+function createReplicaPatch {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local operation=$3\n+  local __result=$4\n+  local __replicaCount=$5\n+  local maxReplicas=\"\"\n+  local infoMessage=\"Current replica count value is same as maximum number of replica count. \\\n+Not increasing replica count value.\"\n+\n+  maxReplicaCmd=\"(.status.clusters[] | select (.clusterName == \\\"${clusterName}\\\")) \\\n+    | .maximumReplicas\"\n+  getReplicaCount  \"${domainJson}\" \"${clusterName}\" replica\n+  if [ \"${operation}\" == \"DECREMENT\" ]; then\n+    replica=$((replica-1))\n+    if [ ${replica} -lt 0 ]; then\n+      replica=0\n+    fi\n+  elif [ \"${operation}\" == \"INCREMENT\" ]; then\n+    maxReplicas=$(echo ${domainJson} | jq \"${maxReplicaCmd}\")\n+    if [ ${replica} -eq ${maxReplicas} ]; then", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "originalPosition": 409}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzk3MDU0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-523397054", "createdAt": "2020-11-04T14:12:25Z", "commit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDoxMjoyNlrOHtZ2SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDoxMjoyNlrOHtZ2SA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3MTQ2NA==", "bodyText": "start and stopDomain have similar patch code, so perhaps move it to the helper..., ditto for start/stopCluster", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r517371464", "createdAt": "2020-11-04T14:12:26Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/stopDomain.sh", "diffHunk": "@@ -0,0 +1,77 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+script=\"${BASH_SOURCE[0]}\"\n+scriptDir=\"$( cd \"$( dirname \"${script}\" )\" && pwd )\"\n+source ${scriptDir}/helper.sh\n+\n+function usage() {\n+\n+  cat << EOF\n+\n+  This script stops a deployed WebLogic domain by patching\n+  'spec.serverStartPolicy' attribute of domain resource to 'NEVER'.\n+  This change will cause the operator to initiate shutdown of the\n+  domain's WebLogic server instance pods if the pods are running.\n+ \n+  Usage:\n+ \n+    $(basename $0) [-n mynamespace] [-d mydomainuid] [-m kubecli]\n+  \n+    -d <domain_uid>     : Domain unique-id. Default is 'sample-domain1'.\n+\n+    -n <namespace>      : Domain namespace. Default is 'sample-domain1-ns'.\n+\n+    -m <kubernetes_cli> : Kubernetes command line interface. Default is 'kubectl' if KUBERNETES_CLI env\n+                          variable is not set. Otherwise default is the value of KUBERNETES_CLI env variable.\n+\n+    -h                  : This help.\n+   \n+EOF\n+exit $1\n+}\n+\n+kubernetesCli=${KUBERNETES_CLI:-kubectl}\n+domainUid=\"sample-domain1\"\n+domainNamespace=\"sample-domain1-ns\"\n+\n+while getopts \"n:d:m:h\" opt; do\n+  case $opt in\n+    n) domainNamespace=\"${OPTARG}\"\n+    ;;\n+    d) domainUid=\"${OPTARG}\"\n+    ;;\n+    m) kubernetesCli=\"${OPTARG}\"\n+    ;;\n+    h) usage 0\n+    ;;\n+    *) usage 1\n+    ;;\n+  esac\n+done\n+\n+set -eu\n+set -o pipefail\n+\n+if ! [ -x \"$(command -v ${kubernetesCli})\" ]; then\n+  fail \"${kubernetesCli} is not installed\"\n+fi\n+\n+serverStartPolicy=`${kubernetesCli} -n ${domainNamespace} get domain ${domainUid} -o=jsonpath='{.spec.serverStartPolicy}'`\n+if [ -z \"${serverStartPolicy}\" ]; then\n+  serverStartPolicy=IF_NEEDED\n+fi\n+\n+if [ \"${serverStartPolicy}\" == 'NEVER' ]; then \n+  printInfo \"No changes needed, exiting. The domain '${domainUid}' is already stopped or stopping. The value of 'spec.serverStartPolicy' attribute on the domain resource is 'NEVER'.\"\n+  exit 0\n+fi\n+\n+printInfo \"Patching domain '${domainUid}' in namespace '${domainNamespace}' from serverStartPolicy='${serverStartPolicy}' to 'NEVER'.\"\n+\n+${kubernetesCli} -n ${domainNamespace} patch domain ${domainUid} --type='json' \\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "originalPosition": 74}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzk5NDQ5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#pullrequestreview-523399449", "createdAt": "2020-11-04T14:14:57Z", "commit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDoxNDo1N1rOHtZ9cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDoxNDo1N1rOHtZ9cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3MzI5OA==", "bodyText": "add \"and keep_replica_count option is false (the default)\"", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2002#discussion_r517373298", "createdAt": "2020-11-04T14:14:57Z", "author": {"login": "tbarnes-us"}, "path": "kubernetes/samples/scripts/domain-lifecycle/stopServer.sh", "diffHunk": "@@ -0,0 +1,233 @@\n+# !/bin/sh\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+\n+# This script stops a WebLogic managed server in a domain. \n+# Internal code notes :-\n+# - If server start policy is NEVER or policy is IF_NEEDED and the server is not \n+#   selected to start based on the replica count, it means that server is already \n+#   stopped or is in the process of stopping. In this case, script exits without \n+#   making any changes.\n+#\n+# - If the effective start policy of the server is IF_NEEDED and decreasing replica ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c725a6c333bfd7675506f68ce06f1efa20bd39"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4031, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}