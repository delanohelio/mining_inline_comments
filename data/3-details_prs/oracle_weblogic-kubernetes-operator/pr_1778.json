{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyMTkwNzAz", "number": 1778, "title": "Two Domain with Single Istio Ingress Controller", "bodyText": "Create two domains using domainhome-in-image model.\nAdd istio configuration with default readinessPort.\nDeploy istio gateway and virtual service on each domain namespaces.\nAdd host information to gateway and virtual service configurations.\nPut the namespace.org as host configuration\nVerify domain pods runs in ready state and services are created.\nVerify login to WebLogic console on domain1 through istio ingress http  port by passing host information in HTTP header.\nDeploy a web application to domain1 through istio ingress http port  using host information in HTTP header.\nAccess web application through istio http ingress port using host information in HTTP header.\nRepeat the same steps for domain2.\nInfra Change\nNow istio will be installed and (un) installed only once during entire run. so the individual test need not (un)install istio\nThe new istio configuration (VS/Gateway) template has an explicit host info based on unique domain namespace\nNew utility method to  access/deploy application thru REST with optional HTTP host information\nKind Cluster Result\nhttps://build.weblogick8s.org:8443/job/weblogic-kubernetes-operator-kind-new/603\nMultiNode Cluster\nhttps://build.weblogick8s.org:8443/job/weblogic-kubernetes-operator-model-in-image-tests/1095", "createdAt": "2020-06-30T17:30:32Z", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778", "merged": true, "mergeCommit": {"oid": "81e90daa12bc77226bbdb788dca2dac074817750"}, "closed": true, "closedAt": "2020-07-02T15:58:20Z", "author": {"login": "anpanigr"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcvL_5KAH2gAyNDQyMTkwNzAzOjVkNDExMWZhOTlhMjZhM2FiNWY4OWU5YjBjNjNlNDgwMjM3ODRlY2U=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcxAym_gFqTQ0MTgxNDAyNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5d4111fa99a26a3ab5f89e9b0c63e48023784ece", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5d4111fa99a26a3ab5f89e9b0c63e48023784ece", "committedDate": "2020-06-26T23:39:16Z", "message": "Added unique host info to istion VS/Gateway"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c212514ab7202bc6de5e645bce1151deb68af975", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c212514ab7202bc6de5e645bce1151deb68af975", "committedDate": "2020-06-29T17:22:31Z", "message": "Modify checkAppUsingHostHeader()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cec30fb7028c129ef8c4102081ee315f3c471de4", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/cec30fb7028c129ef8c4102081ee315f3c471de4", "committedDate": "2020-06-29T17:45:15Z", "message": "Checking for server readiness with quick retry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49949b794a8f8be7be1fb8cf8ae0a07206fcddf3", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/49949b794a8f8be7be1fb8cf8ae0a07206fcddf3", "committedDate": "2020-06-29T18:57:14Z", "message": "Removed hard-coded sleep beore checking Console"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9ff874498c2a183ea831972f13312f1e47c1c07", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a9ff874498c2a183ea831972f13312f1e47c1c07", "committedDate": "2020-06-29T23:55:32Z", "message": "Added two doamin test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39dbb01c25b1562f2ab9b97bd0cc9e9642a6a2b0", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/39dbb01c25b1562f2ab9b97bd0cc9e9642a6a2b0", "committedDate": "2020-06-30T15:29:44Z", "message": "Fixed the javadoc comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMjcxMjk3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#pullrequestreview-440271297", "createdAt": "2020-06-30T18:15:28Z", "commit": {"oid": "39dbb01c25b1562f2ab9b97bd0cc9e9642a6a2b0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxODoxNToyOFrOGrI0aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxODoxNToyOFrOGrI0aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg4NjQ0Mw==", "bodyText": "accessible", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r447886443", "createdAt": "2020-06-30T18:15:28Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioTwoDomainsInImage.java", "diffHunk": "@@ -0,0 +1,369 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkAppUsingHostHeader;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create WebLogic domain in domainhome-in-image model with istio configuration\")\n+@IntegrationTest\n+class ItIstioTwoDomainsInImage {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace1 = null;\n+  private static String domainNamespace2 = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private final String clusterName = \"cluster-1\"; // do not modify \n+  private final String adminServerName = \"admin-server\"; // do not modify\n+  private final String domainUid1 = \"istio-dii-wdt-1\";\n+  private final String domainUid2 = \"istio-dii-wdt-2\";\n+  private final String adminServerPodName1 = domainUid1 + \"-\" + adminServerName;\n+  private final String adminServerPodName2 = domainUid2 + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    installIstio();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+    logger.info(\"Creating unique namespace for Domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domainNamespace2 = namespaces.get(2);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace1,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace2,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    logger.info(\"Namespaces [{0}, {1}, {2}] Labeled \",opNamespace, domainNamespace1, domainNamespace2);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace1,domainNamespace2);\n+  }\n+\n+  /**\n+   * Create two domains using domainhome-in-image model.\n+   * Add istio configuration with default readinessPort. \n+   * Deploy istio gateway and virtual service on each domain namespaces.\n+   * Add host information to gateway and virtual service configurations.\n+   * Put the namespace.org as host configuration \n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console on domain1 through istio ingress http \n+   * port by passing host information in HTTP header.\n+   * Deploy a web application to domain1 through istio ingress http port \n+   * using host information in HTTP header. \n+   * Access web application through istio http ingress port using host i\n+   * information in HTTP header.\n+   * Repeat the same steps for domain2.\n+   */\n+  @Test\n+  @DisplayName(\"Two WebLogic domainhome-in-image with single istio ingress\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testIstioTwoDomainsiWithSingleIngress() {\n+    final String managedServerPrefix1 = domainUid1 + \"-managed-server\";\n+    final String managedServerPrefix2 = domainUid2 + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // Create the repo secret to pull the image\n+    createDockerRegistrySecret(domainNamespace1);\n+    createDockerRegistrySecret(domainNamespace2);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName1 = \"weblogic-credentials-1\";\n+    createSecretWithUsernamePassword(adminSecretName1, domainNamespace1, \n+         ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    String adminSecretName2 = \"weblogic-credentials-2\";\n+    createSecretWithUsernamePassword(adminSecretName2, domainNamespace2, \n+         ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create the domain CR(s)\n+    createDomainResource(domainUid1, domainNamespace1, adminSecretName1, REPO_SECRET_NAME,\n+        replicaCount);\n+    createDomainResource(domainUid2, domainNamespace2, adminSecretName2, REPO_SECRET_NAME,\n+        replicaCount);\n+\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace1);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid1,\n+                domainNamespace1,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid1, DOMAIN_VERSION, domainNamespace1));\n+\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace2);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid2,\n+                domainNamespace2,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid2, DOMAIN_VERSION, domainNamespace2));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName1, domainNamespace1);\n+    checkPodReady(adminServerPodName1, domainUid1, domainNamespace1);\n+\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName2, domainNamespace2);\n+    checkPodReady(adminServerPodName2, domainUid2, domainNamespace2);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix1 + i, domainNamespace1);\n+      checkPodReady(managedServerPrefix1 + i, domainUid1, domainNamespace1);\n+      logger.info(\"Wait for managed pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix2 + i, domainNamespace2);\n+      checkPodReady(managedServerPrefix2 + i, domainUid2, domainNamespace2);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName1, domainNamespace1);\n+    checkServiceExists(adminServerPodName1, domainNamespace1);\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName2, domainNamespace2);\n+    checkServiceExists(adminServerPodName2, domainNamespace2);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managedserver service {0} is created in namespace {1}\",\n+          managedServerPrefix1 + i, domainNamespace1);\n+      checkServiceExists(managedServerPrefix1 + i, domainNamespace1);\n+      logger.info(\"Check managedserver service {0} is created in namespace {1}\",\n+          managedServerPrefix2 + i, domainNamespace2);\n+      checkServiceExists(managedServerPrefix2 + i, domainNamespace2);\n+    }\n+\n+    String clusterService1 = domainUid1 + \"-cluster-\" + clusterName + \".\" + domainNamespace1 + \".svc.cluster.local\";\n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"NAMESPACE\", domainNamespace1);\n+    templateMap.put(\"DUID\", domainUid1);\n+    templateMap.put(\"ADMIN_SERVICE\",adminServerPodName1);\n+    templateMap.put(\"CLUSTER_SERVICE\", clusterService1);\n+\n+    Path srcHttpFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-http-template.yaml\");\n+    Path targetHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcHttpFile.toString(), \"istio-http1.yaml\", templateMap));\n+    logger.info(\"Generated Http VS/Gateway file path is {0} for domain1\", targetHttpFile);\n+    boolean deployRes = assertDoesNotThrow(\n+        () -> deployHttpIstioGatewayAndVirtualservice(targetHttpFile)); \n+    assertTrue(deployRes, \"Failed to deploy Http Istio Gateway/VirtualService\");\n+\n+    Path srcDrFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-dr-template.yaml\");\n+    Path targetDrFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcDrFile.toString(), \"istio-dr1.yaml\", templateMap));\n+    logger.info(\"Generated DestinationRule file path is {0}\", targetDrFile);\n+\n+    deployRes = assertDoesNotThrow(\n+        () -> deployIstioDestinationRule(targetDrFile));\n+    assertTrue(deployRes, \"Failed to deploy Istio DestinationRule\");\n+    String clusterService2 = domainUid2 + \"-cluster-\" + clusterName + \".\" + domainNamespace2 + \".svc.cluster.local\";\n+    templateMap.put(\"NAMESPACE\", domainNamespace2);\n+    templateMap.put(\"DUID\", domainUid2);\n+    templateMap.put(\"ADMIN_SERVICE\",adminServerPodName2);\n+    templateMap.put(\"CLUSTER_SERVICE\", clusterService2);\n+\n+    Path targetHttpFile2 = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcHttpFile.toString(), \"istio-http2.yaml\", templateMap));\n+    logger.info(\"Generated Http VS/Gateway file path is {0} for domain2\", targetHttpFile);\n+    deployRes = assertDoesNotThrow(\n+        () -> deployHttpIstioGatewayAndVirtualservice(targetHttpFile2)); \n+    assertTrue(deployRes, \"Failed to deploy Http Istio Gateway/VirtualService\");\n+    \n+    Path targetDrFile2 = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcDrFile.toString(), \"istio-dr2.yaml\", templateMap));\n+    logger.info(\"Generated DestinationRule file path is {0}\", targetDrFile);\n+\n+    deployRes = assertDoesNotThrow(\n+        () -> deployIstioDestinationRule(targetDrFile2));\n+    assertTrue(deployRes, \"Failed to deploy Istio DestinationRule\");\n+\n+    int istioIngressPort = getIstioHttpIngressPort();\n+    logger.info(\"Istio Ingress Port is {0}\", istioIngressPort);\n+\n+    String consoleUrl = \"http://\" + K8S_NODEPORT_HOST + \":\" + istioIngressPort + \"/console/login/LoginForm.jsp\";\n+    boolean checkConsole = \n+         checkAppUsingHostHeader(consoleUrl, domainNamespace1 + \".org\");\n+    assertTrue(checkConsole, \"Failed to access WebLogic console on domain1\");\n+    logger.info(\"WebLogic console on domain1 is acceesible\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39dbb01c25b1562f2ab9b97bd0cc9e9642a6a2b0"}, "originalPosition": 285}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMzgxNzQ4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#pullrequestreview-440381748", "createdAt": "2020-06-30T21:00:03Z", "commit": {"oid": "39dbb01c25b1562f2ab9b97bd0cc9e9642a6a2b0"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMTowMDozNlrOGrOS2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMTozMToyMVrOGrPNmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3NjE1Mw==", "bodyText": "accessible typo", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r447976153", "createdAt": "2020-06-30T21:00:36Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInImage.java", "diffHunk": "@@ -216,33 +215,26 @@ public void testIstioDomainHomeInImageUsingWdt() {\n     int istioIngressPort = getIstioHttpIngressPort();\n     logger.info(\"Istio Ingress Port is {0}\", istioIngressPort);\n \n-    logger.info(\"Validating WebLogic admin server access by login to console\");\n-    boolean loginSuccessful = assertDoesNotThrow(() -> {\n-      return adminNodePortAccessible(istioIngressPort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n-    }, \"Access to admin server node port failed\");\n-    assertTrue(loginSuccessful, \"Console login validation failed\");\n+    String consoleUrl = \"http://\" + K8S_NODEPORT_HOST + \":\" + istioIngressPort + \"/console/login/LoginForm.jsp\";\n+    boolean checkConsole = \n+         checkAppUsingHostHeader(consoleUrl, domainNamespace + \".org\");\n+    assertTrue(checkConsole, \"Failed to access WebLogic console\");\n+    logger.info(\"WebLogic console is acceesible\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39dbb01c25b1562f2ab9b97bd0cc9e9642a6a2b0"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3NjI5Mw==", "bodyText": "return", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r447976293", "createdAt": "2020-06-30T21:00:52Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInImage.java", "diffHunk": "@@ -216,33 +215,26 @@ public void testIstioDomainHomeInImageUsingWdt() {\n     int istioIngressPort = getIstioHttpIngressPort();\n     logger.info(\"Istio Ingress Port is {0}\", istioIngressPort);\n \n-    logger.info(\"Validating WebLogic admin server access by login to console\");\n-    boolean loginSuccessful = assertDoesNotThrow(() -> {\n-      return adminNodePortAccessible(istioIngressPort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n-    }, \"Access to admin server node port failed\");\n-    assertTrue(loginSuccessful, \"Console login validation failed\");\n+    String consoleUrl = \"http://\" + K8S_NODEPORT_HOST + \":\" + istioIngressPort + \"/console/login/LoginForm.jsp\";\n+    boolean checkConsole = \n+         checkAppUsingHostHeader(consoleUrl, domainNamespace + \".org\");\n+    assertTrue(checkConsole, \"Failed to access WebLogic console\");\n+    logger.info(\"WebLogic console is acceesible\");\n \n     Path archivePath = Paths.get(ITTESTS_DIR, \"../src/integration-tests/apps/testwebapp.war\");\n     ExecResult result = null;\n     result = DeployUtil.deployUsingRest(K8S_NODEPORT_HOST, \n         String.valueOf(istioIngressPort),\n         ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, \n-        clusterName, archivePath);\n+        clusterName, archivePath, domainNamespace + \".org\");\n     assertNotNull(result, \"Application deployment failed\");\n     logger.info(\"Application deployment returned {0}\", result.toString());\n-    assertEquals(\"202\", result.stdout(), \"Application deployed successfully\");\n+    assertEquals(\"202\", result.stdout(), \"Deployment does not returns HTTP status code 202\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39dbb01c25b1562f2ab9b97bd0cc9e9642a6a2b0"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3OTY5NQ==", "bodyText": "Verify server pods are in ready state", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r447979695", "createdAt": "2020-06-30T21:07:38Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioTwoDomainsInImage.java", "diffHunk": "@@ -0,0 +1,369 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkAppUsingHostHeader;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create WebLogic domain in domainhome-in-image model with istio configuration\")\n+@IntegrationTest\n+class ItIstioTwoDomainsInImage {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace1 = null;\n+  private static String domainNamespace2 = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private final String clusterName = \"cluster-1\"; // do not modify \n+  private final String adminServerName = \"admin-server\"; // do not modify\n+  private final String domainUid1 = \"istio-dii-wdt-1\";\n+  private final String domainUid2 = \"istio-dii-wdt-2\";\n+  private final String adminServerPodName1 = domainUid1 + \"-\" + adminServerName;\n+  private final String adminServerPodName2 = domainUid2 + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    installIstio();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+    logger.info(\"Creating unique namespace for Domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domainNamespace2 = namespaces.get(2);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace1,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace2,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    logger.info(\"Namespaces [{0}, {1}, {2}] Labeled \",opNamespace, domainNamespace1, domainNamespace2);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace1,domainNamespace2);\n+  }\n+\n+  /**\n+   * Create two domains using domainhome-in-image model.\n+   * Add istio configuration with default readinessPort. \n+   * Deploy istio gateway and virtual service on each domain namespaces.\n+   * Add host information to gateway and virtual service configurations.\n+   * Put the namespace.org as host configuration \n+   * Verify domain pods runs in ready state and services are created.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39dbb01c25b1562f2ab9b97bd0cc9e9642a6a2b0"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4NjY5Nw==", "bodyText": "Deployment did not return HTTP status code 202", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r447986697", "createdAt": "2020-06-30T21:21:56Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioTwoDomainsInImage.java", "diffHunk": "@@ -0,0 +1,369 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkAppUsingHostHeader;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create WebLogic domain in domainhome-in-image model with istio configuration\")\n+@IntegrationTest\n+class ItIstioTwoDomainsInImage {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace1 = null;\n+  private static String domainNamespace2 = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private final String clusterName = \"cluster-1\"; // do not modify \n+  private final String adminServerName = \"admin-server\"; // do not modify\n+  private final String domainUid1 = \"istio-dii-wdt-1\";\n+  private final String domainUid2 = \"istio-dii-wdt-2\";\n+  private final String adminServerPodName1 = domainUid1 + \"-\" + adminServerName;\n+  private final String adminServerPodName2 = domainUid2 + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    installIstio();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+    logger.info(\"Creating unique namespace for Domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domainNamespace2 = namespaces.get(2);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace1,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace2,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    logger.info(\"Namespaces [{0}, {1}, {2}] Labeled \",opNamespace, domainNamespace1, domainNamespace2);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace1,domainNamespace2);\n+  }\n+\n+  /**\n+   * Create two domains using domainhome-in-image model.\n+   * Add istio configuration with default readinessPort. \n+   * Deploy istio gateway and virtual service on each domain namespaces.\n+   * Add host information to gateway and virtual service configurations.\n+   * Put the namespace.org as host configuration \n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console on domain1 through istio ingress http \n+   * port by passing host information in HTTP header.\n+   * Deploy a web application to domain1 through istio ingress http port \n+   * using host information in HTTP header. \n+   * Access web application through istio http ingress port using host i\n+   * information in HTTP header.\n+   * Repeat the same steps for domain2.\n+   */\n+  @Test\n+  @DisplayName(\"Two WebLogic domainhome-in-image with single istio ingress\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testIstioTwoDomainsiWithSingleIngress() {\n+    final String managedServerPrefix1 = domainUid1 + \"-managed-server\";\n+    final String managedServerPrefix2 = domainUid2 + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // Create the repo secret to pull the image\n+    createDockerRegistrySecret(domainNamespace1);\n+    createDockerRegistrySecret(domainNamespace2);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName1 = \"weblogic-credentials-1\";\n+    createSecretWithUsernamePassword(adminSecretName1, domainNamespace1, \n+         ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    String adminSecretName2 = \"weblogic-credentials-2\";\n+    createSecretWithUsernamePassword(adminSecretName2, domainNamespace2, \n+         ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create the domain CR(s)\n+    createDomainResource(domainUid1, domainNamespace1, adminSecretName1, REPO_SECRET_NAME,\n+        replicaCount);\n+    createDomainResource(domainUid2, domainNamespace2, adminSecretName2, REPO_SECRET_NAME,\n+        replicaCount);\n+\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace1);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid1,\n+                domainNamespace1,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid1, DOMAIN_VERSION, domainNamespace1));\n+\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace2);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid2,\n+                domainNamespace2,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid2, DOMAIN_VERSION, domainNamespace2));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName1, domainNamespace1);\n+    checkPodReady(adminServerPodName1, domainUid1, domainNamespace1);\n+\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName2, domainNamespace2);\n+    checkPodReady(adminServerPodName2, domainUid2, domainNamespace2);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix1 + i, domainNamespace1);\n+      checkPodReady(managedServerPrefix1 + i, domainUid1, domainNamespace1);\n+      logger.info(\"Wait for managed pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix2 + i, domainNamespace2);\n+      checkPodReady(managedServerPrefix2 + i, domainUid2, domainNamespace2);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName1, domainNamespace1);\n+    checkServiceExists(adminServerPodName1, domainNamespace1);\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName2, domainNamespace2);\n+    checkServiceExists(adminServerPodName2, domainNamespace2);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managedserver service {0} is created in namespace {1}\",\n+          managedServerPrefix1 + i, domainNamespace1);\n+      checkServiceExists(managedServerPrefix1 + i, domainNamespace1);\n+      logger.info(\"Check managedserver service {0} is created in namespace {1}\",\n+          managedServerPrefix2 + i, domainNamespace2);\n+      checkServiceExists(managedServerPrefix2 + i, domainNamespace2);\n+    }\n+\n+    String clusterService1 = domainUid1 + \"-cluster-\" + clusterName + \".\" + domainNamespace1 + \".svc.cluster.local\";\n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"NAMESPACE\", domainNamespace1);\n+    templateMap.put(\"DUID\", domainUid1);\n+    templateMap.put(\"ADMIN_SERVICE\",adminServerPodName1);\n+    templateMap.put(\"CLUSTER_SERVICE\", clusterService1);\n+\n+    Path srcHttpFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-http-template.yaml\");\n+    Path targetHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcHttpFile.toString(), \"istio-http1.yaml\", templateMap));\n+    logger.info(\"Generated Http VS/Gateway file path is {0} for domain1\", targetHttpFile);\n+    boolean deployRes = assertDoesNotThrow(\n+        () -> deployHttpIstioGatewayAndVirtualservice(targetHttpFile)); \n+    assertTrue(deployRes, \"Failed to deploy Http Istio Gateway/VirtualService\");\n+\n+    Path srcDrFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-dr-template.yaml\");\n+    Path targetDrFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcDrFile.toString(), \"istio-dr1.yaml\", templateMap));\n+    logger.info(\"Generated DestinationRule file path is {0}\", targetDrFile);\n+\n+    deployRes = assertDoesNotThrow(\n+        () -> deployIstioDestinationRule(targetDrFile));\n+    assertTrue(deployRes, \"Failed to deploy Istio DestinationRule\");\n+    String clusterService2 = domainUid2 + \"-cluster-\" + clusterName + \".\" + domainNamespace2 + \".svc.cluster.local\";\n+    templateMap.put(\"NAMESPACE\", domainNamespace2);\n+    templateMap.put(\"DUID\", domainUid2);\n+    templateMap.put(\"ADMIN_SERVICE\",adminServerPodName2);\n+    templateMap.put(\"CLUSTER_SERVICE\", clusterService2);\n+\n+    Path targetHttpFile2 = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcHttpFile.toString(), \"istio-http2.yaml\", templateMap));\n+    logger.info(\"Generated Http VS/Gateway file path is {0} for domain2\", targetHttpFile);\n+    deployRes = assertDoesNotThrow(\n+        () -> deployHttpIstioGatewayAndVirtualservice(targetHttpFile2)); \n+    assertTrue(deployRes, \"Failed to deploy Http Istio Gateway/VirtualService\");\n+    \n+    Path targetDrFile2 = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcDrFile.toString(), \"istio-dr2.yaml\", templateMap));\n+    logger.info(\"Generated DestinationRule file path is {0}\", targetDrFile);\n+\n+    deployRes = assertDoesNotThrow(\n+        () -> deployIstioDestinationRule(targetDrFile2));\n+    assertTrue(deployRes, \"Failed to deploy Istio DestinationRule\");\n+\n+    int istioIngressPort = getIstioHttpIngressPort();\n+    logger.info(\"Istio Ingress Port is {0}\", istioIngressPort);\n+\n+    String consoleUrl = \"http://\" + K8S_NODEPORT_HOST + \":\" + istioIngressPort + \"/console/login/LoginForm.jsp\";\n+    boolean checkConsole = \n+         checkAppUsingHostHeader(consoleUrl, domainNamespace1 + \".org\");\n+    assertTrue(checkConsole, \"Failed to access WebLogic console on domain1\");\n+    logger.info(\"WebLogic console on domain1 is acceesible\");\n+    Path archivePath = Paths.get(ITTESTS_DIR, \"../src/integration-tests/apps/testwebapp.war\");\n+    ExecResult result = null;\n+    result = DeployUtil.deployUsingRest(K8S_NODEPORT_HOST, \n+        String.valueOf(istioIngressPort),\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, \n+        clusterName, archivePath, domainNamespace1 + \".org\");\n+    assertNotNull(result, \"Application deployment failed on domain1\");\n+    logger.info(\"Application deployment on domain1 returned {0}\", result.toString());\n+    assertEquals(\"202\", result.stdout(), \"Deployment does not returns HTTP status code 202\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39dbb01c25b1562f2ab9b97bd0cc9e9642a6a2b0"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4NzE3NQ==", "bodyText": "accessible", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r447987175", "createdAt": "2020-06-30T21:22:56Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioTwoDomainsInImage.java", "diffHunk": "@@ -0,0 +1,369 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkAppUsingHostHeader;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create WebLogic domain in domainhome-in-image model with istio configuration\")\n+@IntegrationTest\n+class ItIstioTwoDomainsInImage {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace1 = null;\n+  private static String domainNamespace2 = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private final String clusterName = \"cluster-1\"; // do not modify \n+  private final String adminServerName = \"admin-server\"; // do not modify\n+  private final String domainUid1 = \"istio-dii-wdt-1\";\n+  private final String domainUid2 = \"istio-dii-wdt-2\";\n+  private final String adminServerPodName1 = domainUid1 + \"-\" + adminServerName;\n+  private final String adminServerPodName2 = domainUid2 + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    installIstio();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+    logger.info(\"Creating unique namespace for Domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domainNamespace2 = namespaces.get(2);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace1,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace2,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    logger.info(\"Namespaces [{0}, {1}, {2}] Labeled \",opNamespace, domainNamespace1, domainNamespace2);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace1,domainNamespace2);\n+  }\n+\n+  /**\n+   * Create two domains using domainhome-in-image model.\n+   * Add istio configuration with default readinessPort. \n+   * Deploy istio gateway and virtual service on each domain namespaces.\n+   * Add host information to gateway and virtual service configurations.\n+   * Put the namespace.org as host configuration \n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console on domain1 through istio ingress http \n+   * port by passing host information in HTTP header.\n+   * Deploy a web application to domain1 through istio ingress http port \n+   * using host information in HTTP header. \n+   * Access web application through istio http ingress port using host i\n+   * information in HTTP header.\n+   * Repeat the same steps for domain2.\n+   */\n+  @Test\n+  @DisplayName(\"Two WebLogic domainhome-in-image with single istio ingress\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testIstioTwoDomainsiWithSingleIngress() {\n+    final String managedServerPrefix1 = domainUid1 + \"-managed-server\";\n+    final String managedServerPrefix2 = domainUid2 + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // Create the repo secret to pull the image\n+    createDockerRegistrySecret(domainNamespace1);\n+    createDockerRegistrySecret(domainNamespace2);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName1 = \"weblogic-credentials-1\";\n+    createSecretWithUsernamePassword(adminSecretName1, domainNamespace1, \n+         ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    String adminSecretName2 = \"weblogic-credentials-2\";\n+    createSecretWithUsernamePassword(adminSecretName2, domainNamespace2, \n+         ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create the domain CR(s)\n+    createDomainResource(domainUid1, domainNamespace1, adminSecretName1, REPO_SECRET_NAME,\n+        replicaCount);\n+    createDomainResource(domainUid2, domainNamespace2, adminSecretName2, REPO_SECRET_NAME,\n+        replicaCount);\n+\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace1);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid1,\n+                domainNamespace1,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid1, DOMAIN_VERSION, domainNamespace1));\n+\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace2);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid2,\n+                domainNamespace2,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid2, DOMAIN_VERSION, domainNamespace2));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName1, domainNamespace1);\n+    checkPodReady(adminServerPodName1, domainUid1, domainNamespace1);\n+\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName2, domainNamespace2);\n+    checkPodReady(adminServerPodName2, domainUid2, domainNamespace2);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix1 + i, domainNamespace1);\n+      checkPodReady(managedServerPrefix1 + i, domainUid1, domainNamespace1);\n+      logger.info(\"Wait for managed pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix2 + i, domainNamespace2);\n+      checkPodReady(managedServerPrefix2 + i, domainUid2, domainNamespace2);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName1, domainNamespace1);\n+    checkServiceExists(adminServerPodName1, domainNamespace1);\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName2, domainNamespace2);\n+    checkServiceExists(adminServerPodName2, domainNamespace2);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managedserver service {0} is created in namespace {1}\",\n+          managedServerPrefix1 + i, domainNamespace1);\n+      checkServiceExists(managedServerPrefix1 + i, domainNamespace1);\n+      logger.info(\"Check managedserver service {0} is created in namespace {1}\",\n+          managedServerPrefix2 + i, domainNamespace2);\n+      checkServiceExists(managedServerPrefix2 + i, domainNamespace2);\n+    }\n+\n+    String clusterService1 = domainUid1 + \"-cluster-\" + clusterName + \".\" + domainNamespace1 + \".svc.cluster.local\";\n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"NAMESPACE\", domainNamespace1);\n+    templateMap.put(\"DUID\", domainUid1);\n+    templateMap.put(\"ADMIN_SERVICE\",adminServerPodName1);\n+    templateMap.put(\"CLUSTER_SERVICE\", clusterService1);\n+\n+    Path srcHttpFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-http-template.yaml\");\n+    Path targetHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcHttpFile.toString(), \"istio-http1.yaml\", templateMap));\n+    logger.info(\"Generated Http VS/Gateway file path is {0} for domain1\", targetHttpFile);\n+    boolean deployRes = assertDoesNotThrow(\n+        () -> deployHttpIstioGatewayAndVirtualservice(targetHttpFile)); \n+    assertTrue(deployRes, \"Failed to deploy Http Istio Gateway/VirtualService\");\n+\n+    Path srcDrFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-dr-template.yaml\");\n+    Path targetDrFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcDrFile.toString(), \"istio-dr1.yaml\", templateMap));\n+    logger.info(\"Generated DestinationRule file path is {0}\", targetDrFile);\n+\n+    deployRes = assertDoesNotThrow(\n+        () -> deployIstioDestinationRule(targetDrFile));\n+    assertTrue(deployRes, \"Failed to deploy Istio DestinationRule\");\n+    String clusterService2 = domainUid2 + \"-cluster-\" + clusterName + \".\" + domainNamespace2 + \".svc.cluster.local\";\n+    templateMap.put(\"NAMESPACE\", domainNamespace2);\n+    templateMap.put(\"DUID\", domainUid2);\n+    templateMap.put(\"ADMIN_SERVICE\",adminServerPodName2);\n+    templateMap.put(\"CLUSTER_SERVICE\", clusterService2);\n+\n+    Path targetHttpFile2 = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcHttpFile.toString(), \"istio-http2.yaml\", templateMap));\n+    logger.info(\"Generated Http VS/Gateway file path is {0} for domain2\", targetHttpFile);\n+    deployRes = assertDoesNotThrow(\n+        () -> deployHttpIstioGatewayAndVirtualservice(targetHttpFile2)); \n+    assertTrue(deployRes, \"Failed to deploy Http Istio Gateway/VirtualService\");\n+    \n+    Path targetDrFile2 = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcDrFile.toString(), \"istio-dr2.yaml\", templateMap));\n+    logger.info(\"Generated DestinationRule file path is {0}\", targetDrFile);\n+\n+    deployRes = assertDoesNotThrow(\n+        () -> deployIstioDestinationRule(targetDrFile2));\n+    assertTrue(deployRes, \"Failed to deploy Istio DestinationRule\");\n+\n+    int istioIngressPort = getIstioHttpIngressPort();\n+    logger.info(\"Istio Ingress Port is {0}\", istioIngressPort);\n+\n+    String consoleUrl = \"http://\" + K8S_NODEPORT_HOST + \":\" + istioIngressPort + \"/console/login/LoginForm.jsp\";\n+    boolean checkConsole = \n+         checkAppUsingHostHeader(consoleUrl, domainNamespace1 + \".org\");\n+    assertTrue(checkConsole, \"Failed to access WebLogic console on domain1\");\n+    logger.info(\"WebLogic console on domain1 is acceesible\");\n+    Path archivePath = Paths.get(ITTESTS_DIR, \"../src/integration-tests/apps/testwebapp.war\");\n+    ExecResult result = null;\n+    result = DeployUtil.deployUsingRest(K8S_NODEPORT_HOST, \n+        String.valueOf(istioIngressPort),\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, \n+        clusterName, archivePath, domainNamespace1 + \".org\");\n+    assertNotNull(result, \"Application deployment failed on domain1\");\n+    logger.info(\"Application deployment on domain1 returned {0}\", result.toString());\n+    assertEquals(\"202\", result.stdout(), \"Deployment does not returns HTTP status code 202\");\n+\n+    String url = \"http://\" + K8S_NODEPORT_HOST + \":\" + istioIngressPort + \"/testwebapp/index.jsp\";\n+    logger.info(\"Application Access URL {0}\", url);\n+    boolean checkApp = checkAppUsingHostHeader(url, domainNamespace1 + \".org\");\n+    assertTrue(checkApp, \"Failed to access WebLogic application on domain1\");\n+\n+    checkConsole = checkAppUsingHostHeader(consoleUrl, domainNamespace2 + \".org\");\n+    assertTrue(checkConsole, \"Failed to access domain2 WebLogic console\");\n+    logger.info(\"WebLogic console on domain2 is acceesible\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39dbb01c25b1562f2ab9b97bd0cc9e9642a6a2b0"}, "originalPosition": 303}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4NzM5Ng==", "bodyText": "same as above", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r447987396", "createdAt": "2020-06-30T21:23:25Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioTwoDomainsInImage.java", "diffHunk": "@@ -0,0 +1,369 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkAppUsingHostHeader;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create WebLogic domain in domainhome-in-image model with istio configuration\")\n+@IntegrationTest\n+class ItIstioTwoDomainsInImage {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace1 = null;\n+  private static String domainNamespace2 = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private final String clusterName = \"cluster-1\"; // do not modify \n+  private final String adminServerName = \"admin-server\"; // do not modify\n+  private final String domainUid1 = \"istio-dii-wdt-1\";\n+  private final String domainUid2 = \"istio-dii-wdt-2\";\n+  private final String adminServerPodName1 = domainUid1 + \"-\" + adminServerName;\n+  private final String adminServerPodName2 = domainUid2 + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    installIstio();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+    logger.info(\"Creating unique namespace for Domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domainNamespace2 = namespaces.get(2);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace1,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace2,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    logger.info(\"Namespaces [{0}, {1}, {2}] Labeled \",opNamespace, domainNamespace1, domainNamespace2);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace1,domainNamespace2);\n+  }\n+\n+  /**\n+   * Create two domains using domainhome-in-image model.\n+   * Add istio configuration with default readinessPort. \n+   * Deploy istio gateway and virtual service on each domain namespaces.\n+   * Add host information to gateway and virtual service configurations.\n+   * Put the namespace.org as host configuration \n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console on domain1 through istio ingress http \n+   * port by passing host information in HTTP header.\n+   * Deploy a web application to domain1 through istio ingress http port \n+   * using host information in HTTP header. \n+   * Access web application through istio http ingress port using host i\n+   * information in HTTP header.\n+   * Repeat the same steps for domain2.\n+   */\n+  @Test\n+  @DisplayName(\"Two WebLogic domainhome-in-image with single istio ingress\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testIstioTwoDomainsiWithSingleIngress() {\n+    final String managedServerPrefix1 = domainUid1 + \"-managed-server\";\n+    final String managedServerPrefix2 = domainUid2 + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // Create the repo secret to pull the image\n+    createDockerRegistrySecret(domainNamespace1);\n+    createDockerRegistrySecret(domainNamespace2);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName1 = \"weblogic-credentials-1\";\n+    createSecretWithUsernamePassword(adminSecretName1, domainNamespace1, \n+         ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    String adminSecretName2 = \"weblogic-credentials-2\";\n+    createSecretWithUsernamePassword(adminSecretName2, domainNamespace2, \n+         ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create the domain CR(s)\n+    createDomainResource(domainUid1, domainNamespace1, adminSecretName1, REPO_SECRET_NAME,\n+        replicaCount);\n+    createDomainResource(domainUid2, domainNamespace2, adminSecretName2, REPO_SECRET_NAME,\n+        replicaCount);\n+\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace1);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid1,\n+                domainNamespace1,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid1, DOMAIN_VERSION, domainNamespace1));\n+\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace2);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid2,\n+                domainNamespace2,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid2, DOMAIN_VERSION, domainNamespace2));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName1, domainNamespace1);\n+    checkPodReady(adminServerPodName1, domainUid1, domainNamespace1);\n+\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName2, domainNamespace2);\n+    checkPodReady(adminServerPodName2, domainUid2, domainNamespace2);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix1 + i, domainNamespace1);\n+      checkPodReady(managedServerPrefix1 + i, domainUid1, domainNamespace1);\n+      logger.info(\"Wait for managed pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix2 + i, domainNamespace2);\n+      checkPodReady(managedServerPrefix2 + i, domainUid2, domainNamespace2);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName1, domainNamespace1);\n+    checkServiceExists(adminServerPodName1, domainNamespace1);\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName2, domainNamespace2);\n+    checkServiceExists(adminServerPodName2, domainNamespace2);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managedserver service {0} is created in namespace {1}\",\n+          managedServerPrefix1 + i, domainNamespace1);\n+      checkServiceExists(managedServerPrefix1 + i, domainNamespace1);\n+      logger.info(\"Check managedserver service {0} is created in namespace {1}\",\n+          managedServerPrefix2 + i, domainNamespace2);\n+      checkServiceExists(managedServerPrefix2 + i, domainNamespace2);\n+    }\n+\n+    String clusterService1 = domainUid1 + \"-cluster-\" + clusterName + \".\" + domainNamespace1 + \".svc.cluster.local\";\n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"NAMESPACE\", domainNamespace1);\n+    templateMap.put(\"DUID\", domainUid1);\n+    templateMap.put(\"ADMIN_SERVICE\",adminServerPodName1);\n+    templateMap.put(\"CLUSTER_SERVICE\", clusterService1);\n+\n+    Path srcHttpFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-http-template.yaml\");\n+    Path targetHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcHttpFile.toString(), \"istio-http1.yaml\", templateMap));\n+    logger.info(\"Generated Http VS/Gateway file path is {0} for domain1\", targetHttpFile);\n+    boolean deployRes = assertDoesNotThrow(\n+        () -> deployHttpIstioGatewayAndVirtualservice(targetHttpFile)); \n+    assertTrue(deployRes, \"Failed to deploy Http Istio Gateway/VirtualService\");\n+\n+    Path srcDrFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-dr-template.yaml\");\n+    Path targetDrFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcDrFile.toString(), \"istio-dr1.yaml\", templateMap));\n+    logger.info(\"Generated DestinationRule file path is {0}\", targetDrFile);\n+\n+    deployRes = assertDoesNotThrow(\n+        () -> deployIstioDestinationRule(targetDrFile));\n+    assertTrue(deployRes, \"Failed to deploy Istio DestinationRule\");\n+    String clusterService2 = domainUid2 + \"-cluster-\" + clusterName + \".\" + domainNamespace2 + \".svc.cluster.local\";\n+    templateMap.put(\"NAMESPACE\", domainNamespace2);\n+    templateMap.put(\"DUID\", domainUid2);\n+    templateMap.put(\"ADMIN_SERVICE\",adminServerPodName2);\n+    templateMap.put(\"CLUSTER_SERVICE\", clusterService2);\n+\n+    Path targetHttpFile2 = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcHttpFile.toString(), \"istio-http2.yaml\", templateMap));\n+    logger.info(\"Generated Http VS/Gateway file path is {0} for domain2\", targetHttpFile);\n+    deployRes = assertDoesNotThrow(\n+        () -> deployHttpIstioGatewayAndVirtualservice(targetHttpFile2)); \n+    assertTrue(deployRes, \"Failed to deploy Http Istio Gateway/VirtualService\");\n+    \n+    Path targetDrFile2 = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcDrFile.toString(), \"istio-dr2.yaml\", templateMap));\n+    logger.info(\"Generated DestinationRule file path is {0}\", targetDrFile);\n+\n+    deployRes = assertDoesNotThrow(\n+        () -> deployIstioDestinationRule(targetDrFile2));\n+    assertTrue(deployRes, \"Failed to deploy Istio DestinationRule\");\n+\n+    int istioIngressPort = getIstioHttpIngressPort();\n+    logger.info(\"Istio Ingress Port is {0}\", istioIngressPort);\n+\n+    String consoleUrl = \"http://\" + K8S_NODEPORT_HOST + \":\" + istioIngressPort + \"/console/login/LoginForm.jsp\";\n+    boolean checkConsole = \n+         checkAppUsingHostHeader(consoleUrl, domainNamespace1 + \".org\");\n+    assertTrue(checkConsole, \"Failed to access WebLogic console on domain1\");\n+    logger.info(\"WebLogic console on domain1 is acceesible\");\n+    Path archivePath = Paths.get(ITTESTS_DIR, \"../src/integration-tests/apps/testwebapp.war\");\n+    ExecResult result = null;\n+    result = DeployUtil.deployUsingRest(K8S_NODEPORT_HOST, \n+        String.valueOf(istioIngressPort),\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, \n+        clusterName, archivePath, domainNamespace1 + \".org\");\n+    assertNotNull(result, \"Application deployment failed on domain1\");\n+    logger.info(\"Application deployment on domain1 returned {0}\", result.toString());\n+    assertEquals(\"202\", result.stdout(), \"Deployment does not returns HTTP status code 202\");\n+\n+    String url = \"http://\" + K8S_NODEPORT_HOST + \":\" + istioIngressPort + \"/testwebapp/index.jsp\";\n+    logger.info(\"Application Access URL {0}\", url);\n+    boolean checkApp = checkAppUsingHostHeader(url, domainNamespace1 + \".org\");\n+    assertTrue(checkApp, \"Failed to access WebLogic application on domain1\");\n+\n+    checkConsole = checkAppUsingHostHeader(consoleUrl, domainNamespace2 + \".org\");\n+    assertTrue(checkConsole, \"Failed to access domain2 WebLogic console\");\n+    logger.info(\"WebLogic console on domain2 is acceesible\");\n+    result = DeployUtil.deployUsingRest(K8S_NODEPORT_HOST, \n+        String.valueOf(istioIngressPort),\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, \n+        clusterName, archivePath, domainNamespace2 + \".org\");\n+    assertNotNull(result, \"Application deployment on domain2 failed\");\n+    logger.info(\"Application deployment on domain2 returned {0}\", result.toString());\n+    assertEquals(\"202\", result.stdout(), \"Deployment does not returns HTTP status code 202\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39dbb01c25b1562f2ab9b97bd0cc9e9642a6a2b0"}, "originalPosition": 310}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk5MTE5Mw==", "bodyText": "should there be one more argument to the method - app name testwebapp ?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r447991193", "createdAt": "2020-06-30T21:31:21Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DeployUtil.java", "diffHunk": "@@ -310,4 +309,46 @@ public static ExecResult deployUsingRest(String host, String port,\n     return result;\n   }\n \n+  /**\n+   * Deploy application using REST API with curl utility.\n+   * @param host name of the admin server host\n+   * @param port node port of admin server\n+   * @param userName admin server user name\n+   * @param password admin server password\n+   * @param cluster name of the cluster to deploy application\n+   * @param archivePath local path of the application archive\n+   * @param hostHeader name of the cluster to deploy application\n+   * @return ExecResult \n+   */\n+  public static ExecResult deployUsingRest(String host, String port,\n+            String userName, String password, String cluster, \n+            Path archivePath, String hostHeader) {\n+    final LoggingFacade logger = getLogger();\n+    ExecResult result = null;\n+    StringBuffer curlString = new StringBuffer(\"status=$(curl --noproxy '*' \");\n+    curlString.append(\" --user \" + userName + \":\" + password);\n+    curlString.append(\" -w %{http_code} --show-error -o /dev/null \")\n+        .append(\"-H 'host: \" + hostHeader  + \"' \")\n+        .append(\"-H X-Requested-By:MyClient \")\n+        .append(\"-H Accept:application/json  \")\n+        .append(\"-H Content-Type:multipart/form-data \")\n+        .append(\"-H Prefer:respond-async \")\n+        .append(\"-F \\\"model={ name: 'testwebapp', targets: [ { identity: [ clusters, '\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39dbb01c25b1562f2ab9b97bd0cc9e9642a6a2b0"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b61265b0f91124b07f8e62bed028f6da99518752", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b61265b0f91124b07f8e62bed028f6da99518752", "committedDate": "2020-06-30T23:46:59Z", "message": "addressed review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e2628fa62ccee05261b79fc027439c08e683684", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3e2628fa62ccee05261b79fc027439c08e683684", "committedDate": "2020-07-01T03:04:33Z", "message": "Added support for parallel run; one istio install/unistall per run"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3635ff7e16f62166152001af4c459e2ec1eab8b9", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3635ff7e16f62166152001af4c459e2ec1eab8b9", "committedDate": "2020-07-01T03:04:55Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into istio-twodoms"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab83b1b800e01fe45e0c3d1c34777f0e8b99dd8e", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/ab83b1b800e01fe45e0c3d1c34777f0e8b99dd8e", "committedDate": "2020-07-01T16:16:14Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into istio-twodoms"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "050b8ea0763aa1281d700ec2de250f18cf0de668", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/050b8ea0763aa1281d700ec2de250f18cf0de668", "committedDate": "2020-07-01T17:39:58Z", "message": "Updated utility to make the http hostHeader optional, add new parameter for app name during rest deploy"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMTIyMzA1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#pullrequestreview-441122305", "createdAt": "2020-07-01T18:57:28Z", "commit": {"oid": "050b8ea0763aa1281d700ec2de250f18cf0de668"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxODo1NzoyOFrOGrxyxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxODo1NzoyOFrOGrxyxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU1Nzc2Ng==", "bodyText": "don't see the change", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448557766", "createdAt": "2020-07-01T18:57:28Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioTwoDomainsInImage.java", "diffHunk": "@@ -0,0 +1,369 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkAppUsingHostHeader;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create WebLogic domain in domainhome-in-image model with istio configuration\")\n+@IntegrationTest\n+class ItIstioTwoDomainsInImage {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace1 = null;\n+  private static String domainNamespace2 = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private final String clusterName = \"cluster-1\"; // do not modify \n+  private final String adminServerName = \"admin-server\"; // do not modify\n+  private final String domainUid1 = \"istio-dii-wdt-1\";\n+  private final String domainUid2 = \"istio-dii-wdt-2\";\n+  private final String adminServerPodName1 = domainUid1 + \"-\" + adminServerName;\n+  private final String adminServerPodName2 = domainUid2 + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    installIstio();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+    logger.info(\"Creating unique namespace for Domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domainNamespace2 = namespaces.get(2);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace1,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace2,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    logger.info(\"Namespaces [{0}, {1}, {2}] Labeled \",opNamespace, domainNamespace1, domainNamespace2);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace1,domainNamespace2);\n+  }\n+\n+  /**\n+   * Create two domains using domainhome-in-image model.\n+   * Add istio configuration with default readinessPort. \n+   * Deploy istio gateway and virtual service on each domain namespaces.\n+   * Add host information to gateway and virtual service configurations.\n+   * Put the namespace.org as host configuration \n+   * Verify domain pods runs in ready state and services are created.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3OTY5NQ=="}, "originalCommit": {"oid": "39dbb01c25b1562f2ab9b97bd0cc9e9642a6a2b0"}, "originalPosition": 138}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fbf834576fd097d133ef8403d0ab4ae9a3a9e18d", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/fbf834576fd097d133ef8403d0ab4ae9a3a9e18d", "committedDate": "2020-07-01T19:22:57Z", "message": "Minot javadoc change"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMTkwNTE3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#pullrequestreview-441190517", "createdAt": "2020-07-01T20:55:06Z", "commit": {"oid": "fbf834576fd097d133ef8403d0ab4ae9a3a9e18d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMDo1NTowNlrOGr1D2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMToxNjo0MFrOGr1oGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMTI4OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertEquals(\"202\", result.stdout(), \"Deployment does not return HTTP status code 202\");\n          \n          \n            \n                assertEquals(\"202\", result.stdout(), \"Deployment didn't return HTTP status code 202\");", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448611289", "createdAt": "2020-07-01T20:55:06Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInImage.java", "diffHunk": "@@ -216,33 +213,26 @@ public void testIstioDomainHomeInImageUsingWdt() {\n     int istioIngressPort = getIstioHttpIngressPort();\n     logger.info(\"Istio Ingress Port is {0}\", istioIngressPort);\n \n-    logger.info(\"Validating WebLogic admin server access by login to console\");\n-    boolean loginSuccessful = assertDoesNotThrow(() -> {\n-      return adminNodePortAccessible(istioIngressPort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n-    }, \"Access to admin server node port failed\");\n-    assertTrue(loginSuccessful, \"Console login validation failed\");\n+    String consoleUrl = \"http://\" + K8S_NODEPORT_HOST + \":\" + istioIngressPort + \"/console/login/LoginForm.jsp\";\n+    boolean checkConsole = \n+         checkAppUsingHostHeader(consoleUrl, domainNamespace + \".org\");\n+    assertTrue(checkConsole, \"Failed to access WebLogic console\");\n+    logger.info(\"WebLogic console is accessible\");\n \n     Path archivePath = Paths.get(ITTESTS_DIR, \"../src/integration-tests/apps/testwebapp.war\");\n     ExecResult result = null;\n     result = DeployUtil.deployUsingRest(K8S_NODEPORT_HOST, \n         String.valueOf(istioIngressPort),\n         ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, \n-        clusterName, archivePath);\n+        clusterName, archivePath, domainNamespace + \".org\", \"testwebapp\");\n     assertNotNull(result, \"Application deployment failed\");\n     logger.info(\"Application deployment returned {0}\", result.toString());\n-    assertEquals(\"202\", result.stdout(), \"Application deployed successfully\");\n+    assertEquals(\"202\", result.stdout(), \"Deployment does not return HTTP status code 202\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbf834576fd097d133ef8403d0ab4ae9a3a9e18d"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMTc5MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertTrue(checkApp, \"Failed to access WebLogic appliation\");\n          \n          \n            \n                assertTrue(checkApp, \"Failed to access WebLogic application\");", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448611791", "createdAt": "2020-07-01T20:56:10Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInImage.java", "diffHunk": "@@ -216,33 +213,26 @@ public void testIstioDomainHomeInImageUsingWdt() {\n     int istioIngressPort = getIstioHttpIngressPort();\n     logger.info(\"Istio Ingress Port is {0}\", istioIngressPort);\n \n-    logger.info(\"Validating WebLogic admin server access by login to console\");\n-    boolean loginSuccessful = assertDoesNotThrow(() -> {\n-      return adminNodePortAccessible(istioIngressPort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n-    }, \"Access to admin server node port failed\");\n-    assertTrue(loginSuccessful, \"Console login validation failed\");\n+    String consoleUrl = \"http://\" + K8S_NODEPORT_HOST + \":\" + istioIngressPort + \"/console/login/LoginForm.jsp\";\n+    boolean checkConsole = \n+         checkAppUsingHostHeader(consoleUrl, domainNamespace + \".org\");\n+    assertTrue(checkConsole, \"Failed to access WebLogic console\");\n+    logger.info(\"WebLogic console is accessible\");\n \n     Path archivePath = Paths.get(ITTESTS_DIR, \"../src/integration-tests/apps/testwebapp.war\");\n     ExecResult result = null;\n     result = DeployUtil.deployUsingRest(K8S_NODEPORT_HOST, \n         String.valueOf(istioIngressPort),\n         ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, \n-        clusterName, archivePath);\n+        clusterName, archivePath, domainNamespace + \".org\", \"testwebapp\");\n     assertNotNull(result, \"Application deployment failed\");\n     logger.info(\"Application deployment returned {0}\", result.toString());\n-    assertEquals(\"202\", result.stdout(), \"Application deployed successfully\");\n+    assertEquals(\"202\", result.stdout(), \"Deployment does not return HTTP status code 202\");\n+\n     String url = \"http://\" + K8S_NODEPORT_HOST + \":\" + istioIngressPort + \"/testwebapp/index.jsp\";\n     logger.info(\"Application Access URL {0}\", url);\n-\n-    try {\n-      Thread.sleep(5 * 1000);\n-    } catch (InterruptedException ie) {\n-      //    \n-    }\n-    assertEquals(200,\n-        assertDoesNotThrow(() -> OracleHttpClient.get(url, true),\n-            \"Accessing sample application on admin server failed\")\n-            .statusCode(), \"Status code not equals to 200\");\n+    boolean checkApp = checkAppUsingHostHeader(url, domainNamespace + \".org\");\n+    assertTrue(checkApp, \"Failed to access WebLogic appliation\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbf834576fd097d133ef8403d0ab4ae9a3a9e18d"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMjE5Nw==", "bodyText": "Update DisplayName description", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448612197", "createdAt": "2020-07-01T20:56:59Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioTwoDomainsInImage.java", "diffHunk": "@@ -0,0 +1,367 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkAppUsingHostHeader;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create WebLogic domain in domainhome-in-image model with istio configuration\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbf834576fd097d133ef8403d0ab4ae9a3a9e18d"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMjYxNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                logger.info(\"Creating unique namespace for Operator\");\n          \n          \n            \n                logger.info(\"Assigning unique namespace for Operator\");", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448612616", "createdAt": "2020-07-01T20:57:57Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioTwoDomainsInImage.java", "diffHunk": "@@ -0,0 +1,367 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkAppUsingHostHeader;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create WebLogic domain in domainhome-in-image model with istio configuration\")\n+@IntegrationTest\n+class ItIstioTwoDomainsInImage {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace1 = null;\n+  private static String domainNamespace2 = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private final String clusterName = \"cluster-1\"; // do not modify \n+  private final String adminServerName = \"admin-server\"; // do not modify\n+  private final String domainUid1 = \"istio-dii-wdt-1\";\n+  private final String domainUid2 = \"istio-dii-wdt-2\";\n+  private final String adminServerPodName1 = domainUid1 + \"-\" + adminServerName;\n+  private final String adminServerPodName2 = domainUid2 + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbf834576fd097d133ef8403d0ab4ae9a3a9e18d"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMjc3NQ==", "bodyText": "same for below lines", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448612775", "createdAt": "2020-07-01T20:58:18Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioTwoDomainsInImage.java", "diffHunk": "@@ -0,0 +1,367 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkAppUsingHostHeader;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create WebLogic domain in domainhome-in-image model with istio configuration\")\n+@IntegrationTest\n+class ItIstioTwoDomainsInImage {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace1 = null;\n+  private static String domainNamespace2 = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private final String clusterName = \"cluster-1\"; // do not modify \n+  private final String adminServerName = \"admin-server\"; // do not modify\n+  private final String domainUid1 = \"istio-dii-wdt-1\";\n+  private final String domainUid2 = \"istio-dii-wdt-2\";\n+  private final String adminServerPodName1 = domainUid1 + \"-\" + adminServerName;\n+  private final String adminServerPodName2 = domainUid2 + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMjYxNg=="}, "originalCommit": {"oid": "fbf834576fd097d133ef8403d0ab4ae9a3a9e18d"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMzMyNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                logger.info(\"Namespaces [{0}, {1}, {2}] Labeled \",opNamespace, domainNamespace1, domainNamespace2);\n          \n          \n            \n                logger.info(\"Namespaces [{0}, {1}, {2}] labeled with istio-injection:enabled\",opNamespace, domainNamespace1, domainNamespace2);", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448613327", "createdAt": "2020-07-01T20:59:39Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioTwoDomainsInImage.java", "diffHunk": "@@ -0,0 +1,367 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkAppUsingHostHeader;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create WebLogic domain in domainhome-in-image model with istio configuration\")\n+@IntegrationTest\n+class ItIstioTwoDomainsInImage {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace1 = null;\n+  private static String domainNamespace2 = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private final String clusterName = \"cluster-1\"; // do not modify \n+  private final String adminServerName = \"admin-server\"; // do not modify\n+  private final String domainUid1 = \"istio-dii-wdt-1\";\n+  private final String domainUid2 = \"istio-dii-wdt-2\";\n+  private final String adminServerPodName1 = domainUid1 + \"-\" + adminServerName;\n+  private final String adminServerPodName2 = domainUid2 + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+    logger.info(\"Creating unique namespace for Domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domainNamespace2 = namespaces.get(2);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace1,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace2,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    logger.info(\"Namespaces [{0}, {1}, {2}] Labeled \",opNamespace, domainNamespace1, domainNamespace2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbf834576fd097d133ef8403d0ab4ae9a3a9e18d"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxNTA5NA==", "bodyText": "These tests can be run in parallel, is there a reason why it shouldn't be?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448615094", "createdAt": "2020-07-01T21:03:48Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioTwoDomainsInImage.java", "diffHunk": "@@ -0,0 +1,367 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkAppUsingHostHeader;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create WebLogic domain in domainhome-in-image model with istio configuration\")\n+@IntegrationTest\n+class ItIstioTwoDomainsInImage {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace1 = null;\n+  private static String domainNamespace2 = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private final String clusterName = \"cluster-1\"; // do not modify \n+  private final String adminServerName = \"admin-server\"; // do not modify\n+  private final String domainUid1 = \"istio-dii-wdt-1\";\n+  private final String domainUid2 = \"istio-dii-wdt-2\";\n+  private final String adminServerPodName1 = domainUid1 + \"-\" + adminServerName;\n+  private final String adminServerPodName2 = domainUid2 + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+    logger.info(\"Creating unique namespace for Domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domainNamespace2 = namespaces.get(2);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace1,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace2,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    logger.info(\"Namespaces [{0}, {1}, {2}] Labeled \",opNamespace, domainNamespace1, domainNamespace2);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace1,domainNamespace2);\n+  }\n+\n+  /**\n+   * Create two domains using domainhome-in-image model.\n+   * Add istio configuration with default readinessPort. \n+   * Deploy istio gateway and virtual service on each domain namespaces.\n+   * Add host information to gateway and virtual service configurations.\n+   * Put the namespace.org as host configuration \n+   * Verify server pods are in ready state and services are created\n+   * Verify login to WebLogic console on domain1 through istio ingress http \n+   * port by passing host information in HTTP header.\n+   * Deploy a web application to domain1 through istio ingress http port \n+   * using host information in HTTP header. \n+   * Access web application through istio http ingress port using host \n+   * information in HTTP header.\n+   * Repeat the same steps for domain2.\n+   */\n+  @Test\n+  @DisplayName(\"Two WebLogic domainhome-in-image with single istio ingress\")\n+  @Slow\n+  @MustNotRunInParallel", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbf834576fd097d133ef8403d0ab4ae9a3a9e18d"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxNjAxOQ==", "bodyText": "The podReady and serviceExists should be done in this order.\n\ncheck admin service exists\ncheck admin pod ready\ncheck ms service exists\ncheck ms pod ready", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448616019", "createdAt": "2020-07-01T21:06:03Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioTwoDomainsInImage.java", "diffHunk": "@@ -0,0 +1,367 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkAppUsingHostHeader;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create WebLogic domain in domainhome-in-image model with istio configuration\")\n+@IntegrationTest\n+class ItIstioTwoDomainsInImage {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace1 = null;\n+  private static String domainNamespace2 = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private final String clusterName = \"cluster-1\"; // do not modify \n+  private final String adminServerName = \"admin-server\"; // do not modify\n+  private final String domainUid1 = \"istio-dii-wdt-1\";\n+  private final String domainUid2 = \"istio-dii-wdt-2\";\n+  private final String adminServerPodName1 = domainUid1 + \"-\" + adminServerName;\n+  private final String adminServerPodName2 = domainUid2 + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+    logger.info(\"Creating unique namespace for Domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domainNamespace2 = namespaces.get(2);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace1,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace2,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    logger.info(\"Namespaces [{0}, {1}, {2}] Labeled \",opNamespace, domainNamespace1, domainNamespace2);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace1,domainNamespace2);\n+  }\n+\n+  /**\n+   * Create two domains using domainhome-in-image model.\n+   * Add istio configuration with default readinessPort. \n+   * Deploy istio gateway and virtual service on each domain namespaces.\n+   * Add host information to gateway and virtual service configurations.\n+   * Put the namespace.org as host configuration \n+   * Verify server pods are in ready state and services are created\n+   * Verify login to WebLogic console on domain1 through istio ingress http \n+   * port by passing host information in HTTP header.\n+   * Deploy a web application to domain1 through istio ingress http port \n+   * using host information in HTTP header. \n+   * Access web application through istio http ingress port using host \n+   * information in HTTP header.\n+   * Repeat the same steps for domain2.\n+   */\n+  @Test\n+  @DisplayName(\"Two WebLogic domainhome-in-image with single istio ingress\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testIstioTwoDomainsWithSingleIngress() {\n+    final String managedServerPrefix1 = domainUid1 + \"-managed-server\";\n+    final String managedServerPrefix2 = domainUid2 + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // Create the repo secret to pull the image\n+    createDockerRegistrySecret(domainNamespace1);\n+    createDockerRegistrySecret(domainNamespace2);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName1 = \"weblogic-credentials-1\";\n+    createSecretWithUsernamePassword(adminSecretName1, domainNamespace1, \n+         ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    String adminSecretName2 = \"weblogic-credentials-2\";\n+    createSecretWithUsernamePassword(adminSecretName2, domainNamespace2, \n+         ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create the domain CR(s)\n+    createDomainResource(domainUid1, domainNamespace1, adminSecretName1, REPO_SECRET_NAME,\n+        replicaCount);\n+    createDomainResource(domainUid2, domainNamespace2, adminSecretName2, REPO_SECRET_NAME,\n+        replicaCount);\n+\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace1);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid1,\n+                domainNamespace1,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid1, DOMAIN_VERSION, domainNamespace1));\n+\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace2);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid2,\n+                domainNamespace2,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid2, DOMAIN_VERSION, domainNamespace2));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName1, domainNamespace1);\n+    checkPodReady(adminServerPodName1, domainUid1, domainNamespace1);\n+\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName2, domainNamespace2);\n+    checkPodReady(adminServerPodName2, domainUid2, domainNamespace2);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix1 + i, domainNamespace1);\n+      checkPodReady(managedServerPrefix1 + i, domainUid1, domainNamespace1);\n+      logger.info(\"Wait for managed pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix2 + i, domainNamespace2);\n+      checkPodReady(managedServerPrefix2 + i, domainUid2, domainNamespace2);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName1, domainNamespace1);\n+    checkServiceExists(adminServerPodName1, domainNamespace1);\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName2, domainNamespace2);\n+    checkServiceExists(adminServerPodName2, domainNamespace2);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managedserver service {0} is created in namespace {1}\",\n+          managedServerPrefix1 + i, domainNamespace1);\n+      checkServiceExists(managedServerPrefix1 + i, domainNamespace1);\n+      logger.info(\"Check managedserver service {0} is created in namespace {1}\",\n+          managedServerPrefix2 + i, domainNamespace2);\n+      checkServiceExists(managedServerPrefix2 + i, domainNamespace2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbf834576fd097d133ef8403d0ab4ae9a3a9e18d"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYyMDU2OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Check the WebLogic application using host information in the header.\n          \n          \n            \n               * Check the application running in WebLogic server using host information in the header.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448620568", "createdAt": "2020-07-01T21:16:40Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonTestUtils.java", "diffHunk": "@@ -1821,12 +1822,51 @@ public static Path generateFileFromTemplate(\n   }\n \n   /**\n-  * Create a persistent volume.\n+   * Check the WebLogic application using host information in the header.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbf834576fd097d133ef8403d0ab4ae9a3a9e18d"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de470b6f59af2693fe05bb51fb958a192f43663b", "author": {"user": null}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/de470b6f59af2693fe05bb51fb958a192f43663b", "committedDate": "2020-07-01T22:17:34Z", "message": "Addressed more review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxODA1MDcx", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#pullrequestreview-441805071", "createdAt": "2020-07-02T15:33:01Z", "commit": {"oid": "de470b6f59af2693fe05bb51fb958a192f43663b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxODE0MDI3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#pullrequestreview-441814027", "createdAt": "2020-07-02T15:43:39Z", "commit": {"oid": "de470b6f59af2693fe05bb51fb958a192f43663b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4632, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}