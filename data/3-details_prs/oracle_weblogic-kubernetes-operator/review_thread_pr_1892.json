{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc2NTUwMjc2", "number": 1892, "reviewThreads": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzo1Nzo0OFrOEfd6_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxODoyNzowNlrOEgfFwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDMxNTQ5OnYy", "diffSide": "RIGHT", "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzo1Nzo0OFrOHLwcOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzo1Nzo0OFrOHLwcOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA5MDA0MQ==", "bodyText": "Please create the domain by calling DomainProcessorTestSetup.createTestDomain(). That ensures consistency of symbols and ensures that as new requirements are added to the domain, all tests will use them. If you need to add to the created domain, you can do so in your test.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482090041", "createdAt": "2020-09-02T13:57:48Z", "author": {"login": "russgold"}, "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "diffHunk": "@@ -0,0 +1,383 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.steps;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import javax.annotation.Nonnull;\n+\n+import com.meterware.simplestub.Memento;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodStatus;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.kubernetes.operator.KubernetesConstants;\n+import oracle.kubernetes.operator.LabelConstants;\n+import oracle.kubernetes.operator.PodAwaiterStepFactory;\n+import oracle.kubernetes.operator.ProcessingConstants;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo.ServerShutdownInfo;\n+import oracle.kubernetes.operator.helpers.KubernetesTestSupport;\n+import oracle.kubernetes.operator.helpers.LegalNames;\n+import oracle.kubernetes.operator.helpers.PodHelperTestBase;\n+import oracle.kubernetes.operator.helpers.TuningParametersStub;\n+import oracle.kubernetes.operator.utils.WlsDomainConfigSupport;\n+import oracle.kubernetes.operator.wlsconfig.WlsClusterConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsDomainConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsServerConfig;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.operator.work.TerminalStep;\n+import oracle.kubernetes.utils.TestUtils;\n+import oracle.kubernetes.weblogic.domain.ClusterConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfiguratorFactory;\n+import oracle.kubernetes.weblogic.domain.model.Domain;\n+import oracle.kubernetes.weblogic.domain.model.DomainSpec;\n+import org.hamcrest.junit.MatcherAssert;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.junit.MatcherAssert.assertThat;\n+\n+public class ServerDownIteratorStepTest {\n+\n+  protected static final String DOMAIN_NAME = \"domain1\";\n+  private static final String NS = \"namespace\";\n+  private static final String UID = \"uid1\";\n+  protected static final String KUBERNETES_UID = \"12345\";\n+  private static final String ADMIN = \"asName\";\n+  private static final String CLUSTER = \"cluster1\";\n+  private static final boolean INCLUDE_SERVER_OUT_IN_POD_LOG = true;\n+  private static final String CREDENTIALS_SECRET_NAME = \"webLogicCredentialsSecretName\";\n+  private static final String LATEST_IMAGE = \"image:latest\";\n+  private static final String MS_PREFIX = \"ms\";\n+  private static final String MS1 = MS_PREFIX + \"1\";\n+  private static final String MS2 = MS_PREFIX + \"2\";\n+  private static final String MS3 = MS_PREFIX + \"3\";\n+  private static final String MS4 = MS_PREFIX + \"4\";\n+  private static final int MAX_SERVERS = 5;\n+  private static final int PORT = 8001;\n+  private static final String[] MANAGED_SERVER_NAMES =\n+          IntStream.rangeClosed(1, MAX_SERVERS)\n+                  .mapToObj(ServerDownIteratorStepTest::getManagedServerName).toArray(String[]::new);\n+\n+  @Nonnull\n+  private static String getManagedServerName(int n) {\n+    return MS_PREFIX + n;\n+  }\n+\n+  private final Domain domain = createDomain();\n+  private final DomainConfigurator configurator = DomainConfiguratorFactory.forDomain(domain);\n+  private final WlsDomainConfigSupport configSupport = new WlsDomainConfigSupport(DOMAIN_NAME);\n+\n+  private final Step nextStep = new TerminalStep();\n+  private final KubernetesTestSupport testSupport = new KubernetesTestSupport();\n+  private final List<Memento> mementos = new ArrayList<>();\n+  private DomainPresenceInfo domainPresenceInfo = createDomainPresenceInfoWithServers();\n+  private final WlsDomainConfig domainConfig = createDomainConfig();\n+\n+  private static WlsDomainConfig createDomainConfig() {\n+    WlsClusterConfig clusterConfig = new WlsClusterConfig(CLUSTER);\n+    for (String serverName : MANAGED_SERVER_NAMES) {\n+      clusterConfig.addServerConfig(new WlsServerConfig(serverName, \"domain1-\" + serverName, 8001));\n+    }\n+    return new WlsDomainConfig(\"base_domain\")\n+            .withAdminServer(ADMIN, \"domain1-admin-server\", 7001)\n+            .withCluster(clusterConfig);\n+  }\n+\n+  private DomainPresenceInfo createDomainPresenceInfoWithServers(String... serverNames) {\n+    DomainPresenceInfo dpi = new DomainPresenceInfo(domain);\n+    addServer(dpi, ADMIN);\n+    Arrays.asList(serverNames).forEach(serverName -> addServer(dpi, serverName));\n+    return dpi;\n+  }\n+\n+  private Domain createDomain() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8597bca2836390659420e4603a74f6f363c45a82"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDM3Mzc3OnYy", "diffSide": "RIGHT", "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNDoxMDowMFrOHLxACg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNDoxMDowMFrOHLxACg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA5OTIxMA==", "bodyText": "This code can be simplified by extracting a method and using Stream.collect:\n\n  @NotNull\n  private List<ServerShutdownInfo> createServerShutdownInfosForCluster(String clusterName, String... servers) {\n    return Arrays.stream(servers).map(s -> createShutdownInfo(clusterName, s)).collect(Collectors.toList());\n  }\n  \n  private ServerShutdownInfo createShutdownInfo(String clusterName, String serverName) {\n    return new ServerShutdownInfo(configSupport.getWlsServer(clusterName, serverName).getName(), clusterName);\n  }", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482099210", "createdAt": "2020-09-02T14:10:00Z", "author": {"login": "russgold"}, "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "diffHunk": "@@ -0,0 +1,383 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.steps;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import javax.annotation.Nonnull;\n+\n+import com.meterware.simplestub.Memento;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodStatus;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.kubernetes.operator.KubernetesConstants;\n+import oracle.kubernetes.operator.LabelConstants;\n+import oracle.kubernetes.operator.PodAwaiterStepFactory;\n+import oracle.kubernetes.operator.ProcessingConstants;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo.ServerShutdownInfo;\n+import oracle.kubernetes.operator.helpers.KubernetesTestSupport;\n+import oracle.kubernetes.operator.helpers.LegalNames;\n+import oracle.kubernetes.operator.helpers.PodHelperTestBase;\n+import oracle.kubernetes.operator.helpers.TuningParametersStub;\n+import oracle.kubernetes.operator.utils.WlsDomainConfigSupport;\n+import oracle.kubernetes.operator.wlsconfig.WlsClusterConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsDomainConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsServerConfig;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.operator.work.TerminalStep;\n+import oracle.kubernetes.utils.TestUtils;\n+import oracle.kubernetes.weblogic.domain.ClusterConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfiguratorFactory;\n+import oracle.kubernetes.weblogic.domain.model.Domain;\n+import oracle.kubernetes.weblogic.domain.model.DomainSpec;\n+import org.hamcrest.junit.MatcherAssert;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.junit.MatcherAssert.assertThat;\n+\n+public class ServerDownIteratorStepTest {\n+\n+  protected static final String DOMAIN_NAME = \"domain1\";\n+  private static final String NS = \"namespace\";\n+  private static final String UID = \"uid1\";\n+  protected static final String KUBERNETES_UID = \"12345\";\n+  private static final String ADMIN = \"asName\";\n+  private static final String CLUSTER = \"cluster1\";\n+  private static final boolean INCLUDE_SERVER_OUT_IN_POD_LOG = true;\n+  private static final String CREDENTIALS_SECRET_NAME = \"webLogicCredentialsSecretName\";\n+  private static final String LATEST_IMAGE = \"image:latest\";\n+  private static final String MS_PREFIX = \"ms\";\n+  private static final String MS1 = MS_PREFIX + \"1\";\n+  private static final String MS2 = MS_PREFIX + \"2\";\n+  private static final String MS3 = MS_PREFIX + \"3\";\n+  private static final String MS4 = MS_PREFIX + \"4\";\n+  private static final int MAX_SERVERS = 5;\n+  private static final int PORT = 8001;\n+  private static final String[] MANAGED_SERVER_NAMES =\n+          IntStream.rangeClosed(1, MAX_SERVERS)\n+                  .mapToObj(ServerDownIteratorStepTest::getManagedServerName).toArray(String[]::new);\n+\n+  @Nonnull\n+  private static String getManagedServerName(int n) {\n+    return MS_PREFIX + n;\n+  }\n+\n+  private final Domain domain = createDomain();\n+  private final DomainConfigurator configurator = DomainConfiguratorFactory.forDomain(domain);\n+  private final WlsDomainConfigSupport configSupport = new WlsDomainConfigSupport(DOMAIN_NAME);\n+\n+  private final Step nextStep = new TerminalStep();\n+  private final KubernetesTestSupport testSupport = new KubernetesTestSupport();\n+  private final List<Memento> mementos = new ArrayList<>();\n+  private DomainPresenceInfo domainPresenceInfo = createDomainPresenceInfoWithServers();\n+  private final WlsDomainConfig domainConfig = createDomainConfig();\n+\n+  private static WlsDomainConfig createDomainConfig() {\n+    WlsClusterConfig clusterConfig = new WlsClusterConfig(CLUSTER);\n+    for (String serverName : MANAGED_SERVER_NAMES) {\n+      clusterConfig.addServerConfig(new WlsServerConfig(serverName, \"domain1-\" + serverName, 8001));\n+    }\n+    return new WlsDomainConfig(\"base_domain\")\n+            .withAdminServer(ADMIN, \"domain1-admin-server\", 7001)\n+            .withCluster(clusterConfig);\n+  }\n+\n+  private DomainPresenceInfo createDomainPresenceInfoWithServers(String... serverNames) {\n+    DomainPresenceInfo dpi = new DomainPresenceInfo(domain);\n+    addServer(dpi, ADMIN);\n+    Arrays.asList(serverNames).forEach(serverName -> addServer(dpi, serverName));\n+    return dpi;\n+  }\n+\n+  private Domain createDomain() {\n+    return new Domain()\n+            .withApiVersion(KubernetesConstants.DOMAIN_VERSION)\n+            .withKind(KubernetesConstants.DOMAIN)\n+            .withMetadata(new V1ObjectMeta().namespace(NS).name(DOMAIN_NAME).uid(KUBERNETES_UID))\n+            .withSpec(createDomainSpec());\n+  }\n+\n+  private DomainSpec createDomainSpec() {\n+    return new DomainSpec()\n+            .withDomainUid(UID)\n+            .withWebLogicCredentialsSecret(new V1SecretReference().name(CREDENTIALS_SECRET_NAME))\n+            .withIncludeServerOutInPodLog(INCLUDE_SERVER_OUT_IN_POD_LOG)\n+            .withImage(LATEST_IMAGE);\n+  }\n+\n+  private static void addServer(DomainPresenceInfo domainPresenceInfo, String serverName) {\n+    if (serverName.equals(ADMIN)) {\n+      domainPresenceInfo.setServerPod(serverName, createReadyPod(serverName));\n+    } else {\n+      domainPresenceInfo.setServerPod(serverName, createPod(serverName));\n+    }\n+  }\n+\n+  private static V1Pod createReadyPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName))\n+            .spec(new V1PodSpec().nodeName(\"Node1\"))\n+            .status(new V1PodStatus().phase(\"Running\")\n+            .addConditionsItem(new V1PodCondition().type(\"Ready\").status(\"True\")));\n+  }\n+\n+  private static V1Pod createPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName));\n+  }\n+\n+  private static V1ObjectMeta withNames(V1ObjectMeta objectMeta, String serverName) {\n+    return objectMeta\n+            .name(LegalNames.toPodName(UID, serverName))\n+            .putLabelsItem(LabelConstants.SERVERNAME_LABEL, serverName);\n+  }\n+\n+  /**\n+   * Setup env for tests.\n+   * @throws NoSuchFieldException if TestStepFactory fails to install\n+   */\n+  @Before\n+  public void setUp() throws NoSuchFieldException {\n+    mementos.add(TestUtils.silenceOperatorLogger().ignoringLoggedExceptions(ApiException.class));\n+    mementos.add(TuningParametersStub.install());\n+    mementos.add(testSupport.install());\n+\n+    testSupport.defineResources(domain);\n+    testSupport\n+            .addToPacket(ProcessingConstants.DOMAIN_TOPOLOGY, domainConfig)\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    testSupport.addComponent(\n+            ProcessingConstants.PODWATCHER_COMPONENT_NAME,\n+            PodAwaiterStepFactory.class,\n+            new PodHelperTestBase.DelayedPodAwaiterStepFactory(1));\n+\n+  }\n+\n+  /**\n+   * Cleanup env after tests.\n+   * @throws Exception if test support failed\n+   */\n+  @After\n+  public void tearDown() throws Exception {\n+    for (Memento memento : mementos) {\n+      memento.revert();\n+    }\n+\n+    testSupport.throwOnCompletionFailure();\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf1_bothClusteredServersShutdownSequentially() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(1);\n+    addWlsCluster(CLUSTER, 8001, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+    testSupport.setTime(10, TimeUnit.SECONDS);\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2_bothClusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(1);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf0_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withReplicaCountOf0AndConcurrencyOf1_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2AndReplicaCount1_3clusteredServersShutdownIn2Threads() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(1);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2, MS3, MS4);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2,MS3,MS4);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    assertThat(MS2 + \" pod\", domainPresenceInfo.getServerPod(MS2), notNullValue());\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER, MS1, MS2, MS3, MS4));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS4), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS3), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.FALSE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+    testSupport.setTime(10, TimeUnit.SECONDS);\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2AndReplicaCount0_4clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2, MS3, MS4);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2,MS3,MS4);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER, MS1, MS2, MS3, MS4));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS4), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS3), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withMultipleClusters_differentClusterScheduleAndShutdownDifferently() {\n+    final String CLUSTER2 = \"cluster2\";\n+\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(0).withReplicas(1);\n+    configureCluster(CLUSTER2).withMaxConcurrentShutdown(1).withReplicas(1);\n+\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+    addWlsCluster(CLUSTER2, PORT, MS3, MS4);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2,MS3,MS4);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    List<ServerShutdownInfo> serverShutdownInfos =\n+            createServerShutdownInfosForCluster(CLUSTER, MS1, MS2);\n+    serverShutdownInfos.addAll(createServerShutdownInfosForCluster(CLUSTER2, MS3, MS4));\n+    invokeStepWithServerShutdownInfos(serverShutdownInfos);\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS4), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS3), is(Boolean.FALSE));\n+  }\n+\n+  @Test\n+  public void maxClusterConcurrentShutdown_doesNotApplyToNonClusteredServers() {\n+    domain.getSpec().setMaxClusterConcurrentShutdown(1);\n+\n+    addWlsServers(MS3, MS4);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS3,MS4);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfos(MS3, MS4));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS4), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS3), is(Boolean.TRUE));\n+  }\n+\n+  @NotNull", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8597bca2836390659420e4603a74f6f363c45a82"}, "originalPosition": 338}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDM4NDg4OnYy", "diffSide": "RIGHT", "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNDoxMjoxMFrOHLxGlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNDoxMjoxMFrOHLxGlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEwMDg4Ng==", "bodyText": "This code can be simplified:\n\n  @NotNull\n  private List<ServerShutdownInfo> createServerShutdownInfos(String... servers) {\n    return Arrays.stream(servers).map(this::createShutdownInfo).collect(Collectors.toList());\n  }\n\n  @Nonnull\n  private ServerShutdownInfo createShutdownInfo(String server) {\n    return new ServerShutdownInfo(configSupport.getWlsServer(server).getName(), null);\n  }", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482100886", "createdAt": "2020-09-02T14:12:10Z", "author": {"login": "russgold"}, "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "diffHunk": "@@ -0,0 +1,383 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.steps;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import javax.annotation.Nonnull;\n+\n+import com.meterware.simplestub.Memento;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodStatus;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.kubernetes.operator.KubernetesConstants;\n+import oracle.kubernetes.operator.LabelConstants;\n+import oracle.kubernetes.operator.PodAwaiterStepFactory;\n+import oracle.kubernetes.operator.ProcessingConstants;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo.ServerShutdownInfo;\n+import oracle.kubernetes.operator.helpers.KubernetesTestSupport;\n+import oracle.kubernetes.operator.helpers.LegalNames;\n+import oracle.kubernetes.operator.helpers.PodHelperTestBase;\n+import oracle.kubernetes.operator.helpers.TuningParametersStub;\n+import oracle.kubernetes.operator.utils.WlsDomainConfigSupport;\n+import oracle.kubernetes.operator.wlsconfig.WlsClusterConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsDomainConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsServerConfig;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.operator.work.TerminalStep;\n+import oracle.kubernetes.utils.TestUtils;\n+import oracle.kubernetes.weblogic.domain.ClusterConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfiguratorFactory;\n+import oracle.kubernetes.weblogic.domain.model.Domain;\n+import oracle.kubernetes.weblogic.domain.model.DomainSpec;\n+import org.hamcrest.junit.MatcherAssert;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.junit.MatcherAssert.assertThat;\n+\n+public class ServerDownIteratorStepTest {\n+\n+  protected static final String DOMAIN_NAME = \"domain1\";\n+  private static final String NS = \"namespace\";\n+  private static final String UID = \"uid1\";\n+  protected static final String KUBERNETES_UID = \"12345\";\n+  private static final String ADMIN = \"asName\";\n+  private static final String CLUSTER = \"cluster1\";\n+  private static final boolean INCLUDE_SERVER_OUT_IN_POD_LOG = true;\n+  private static final String CREDENTIALS_SECRET_NAME = \"webLogicCredentialsSecretName\";\n+  private static final String LATEST_IMAGE = \"image:latest\";\n+  private static final String MS_PREFIX = \"ms\";\n+  private static final String MS1 = MS_PREFIX + \"1\";\n+  private static final String MS2 = MS_PREFIX + \"2\";\n+  private static final String MS3 = MS_PREFIX + \"3\";\n+  private static final String MS4 = MS_PREFIX + \"4\";\n+  private static final int MAX_SERVERS = 5;\n+  private static final int PORT = 8001;\n+  private static final String[] MANAGED_SERVER_NAMES =\n+          IntStream.rangeClosed(1, MAX_SERVERS)\n+                  .mapToObj(ServerDownIteratorStepTest::getManagedServerName).toArray(String[]::new);\n+\n+  @Nonnull\n+  private static String getManagedServerName(int n) {\n+    return MS_PREFIX + n;\n+  }\n+\n+  private final Domain domain = createDomain();\n+  private final DomainConfigurator configurator = DomainConfiguratorFactory.forDomain(domain);\n+  private final WlsDomainConfigSupport configSupport = new WlsDomainConfigSupport(DOMAIN_NAME);\n+\n+  private final Step nextStep = new TerminalStep();\n+  private final KubernetesTestSupport testSupport = new KubernetesTestSupport();\n+  private final List<Memento> mementos = new ArrayList<>();\n+  private DomainPresenceInfo domainPresenceInfo = createDomainPresenceInfoWithServers();\n+  private final WlsDomainConfig domainConfig = createDomainConfig();\n+\n+  private static WlsDomainConfig createDomainConfig() {\n+    WlsClusterConfig clusterConfig = new WlsClusterConfig(CLUSTER);\n+    for (String serverName : MANAGED_SERVER_NAMES) {\n+      clusterConfig.addServerConfig(new WlsServerConfig(serverName, \"domain1-\" + serverName, 8001));\n+    }\n+    return new WlsDomainConfig(\"base_domain\")\n+            .withAdminServer(ADMIN, \"domain1-admin-server\", 7001)\n+            .withCluster(clusterConfig);\n+  }\n+\n+  private DomainPresenceInfo createDomainPresenceInfoWithServers(String... serverNames) {\n+    DomainPresenceInfo dpi = new DomainPresenceInfo(domain);\n+    addServer(dpi, ADMIN);\n+    Arrays.asList(serverNames).forEach(serverName -> addServer(dpi, serverName));\n+    return dpi;\n+  }\n+\n+  private Domain createDomain() {\n+    return new Domain()\n+            .withApiVersion(KubernetesConstants.DOMAIN_VERSION)\n+            .withKind(KubernetesConstants.DOMAIN)\n+            .withMetadata(new V1ObjectMeta().namespace(NS).name(DOMAIN_NAME).uid(KUBERNETES_UID))\n+            .withSpec(createDomainSpec());\n+  }\n+\n+  private DomainSpec createDomainSpec() {\n+    return new DomainSpec()\n+            .withDomainUid(UID)\n+            .withWebLogicCredentialsSecret(new V1SecretReference().name(CREDENTIALS_SECRET_NAME))\n+            .withIncludeServerOutInPodLog(INCLUDE_SERVER_OUT_IN_POD_LOG)\n+            .withImage(LATEST_IMAGE);\n+  }\n+\n+  private static void addServer(DomainPresenceInfo domainPresenceInfo, String serverName) {\n+    if (serverName.equals(ADMIN)) {\n+      domainPresenceInfo.setServerPod(serverName, createReadyPod(serverName));\n+    } else {\n+      domainPresenceInfo.setServerPod(serverName, createPod(serverName));\n+    }\n+  }\n+\n+  private static V1Pod createReadyPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName))\n+            .spec(new V1PodSpec().nodeName(\"Node1\"))\n+            .status(new V1PodStatus().phase(\"Running\")\n+            .addConditionsItem(new V1PodCondition().type(\"Ready\").status(\"True\")));\n+  }\n+\n+  private static V1Pod createPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName));\n+  }\n+\n+  private static V1ObjectMeta withNames(V1ObjectMeta objectMeta, String serverName) {\n+    return objectMeta\n+            .name(LegalNames.toPodName(UID, serverName))\n+            .putLabelsItem(LabelConstants.SERVERNAME_LABEL, serverName);\n+  }\n+\n+  /**\n+   * Setup env for tests.\n+   * @throws NoSuchFieldException if TestStepFactory fails to install\n+   */\n+  @Before\n+  public void setUp() throws NoSuchFieldException {\n+    mementos.add(TestUtils.silenceOperatorLogger().ignoringLoggedExceptions(ApiException.class));\n+    mementos.add(TuningParametersStub.install());\n+    mementos.add(testSupport.install());\n+\n+    testSupport.defineResources(domain);\n+    testSupport\n+            .addToPacket(ProcessingConstants.DOMAIN_TOPOLOGY, domainConfig)\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    testSupport.addComponent(\n+            ProcessingConstants.PODWATCHER_COMPONENT_NAME,\n+            PodAwaiterStepFactory.class,\n+            new PodHelperTestBase.DelayedPodAwaiterStepFactory(1));\n+\n+  }\n+\n+  /**\n+   * Cleanup env after tests.\n+   * @throws Exception if test support failed\n+   */\n+  @After\n+  public void tearDown() throws Exception {\n+    for (Memento memento : mementos) {\n+      memento.revert();\n+    }\n+\n+    testSupport.throwOnCompletionFailure();\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf1_bothClusteredServersShutdownSequentially() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(1);\n+    addWlsCluster(CLUSTER, 8001, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+    testSupport.setTime(10, TimeUnit.SECONDS);\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2_bothClusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(1);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf0_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withReplicaCountOf0AndConcurrencyOf1_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2AndReplicaCount1_3clusteredServersShutdownIn2Threads() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(1);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2, MS3, MS4);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2,MS3,MS4);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    assertThat(MS2 + \" pod\", domainPresenceInfo.getServerPod(MS2), notNullValue());\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER, MS1, MS2, MS3, MS4));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS4), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS3), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.FALSE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+    testSupport.setTime(10, TimeUnit.SECONDS);\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2AndReplicaCount0_4clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2, MS3, MS4);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2,MS3,MS4);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER, MS1, MS2, MS3, MS4));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS4), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS3), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withMultipleClusters_differentClusterScheduleAndShutdownDifferently() {\n+    final String CLUSTER2 = \"cluster2\";\n+\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(0).withReplicas(1);\n+    configureCluster(CLUSTER2).withMaxConcurrentShutdown(1).withReplicas(1);\n+\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+    addWlsCluster(CLUSTER2, PORT, MS3, MS4);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2,MS3,MS4);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    List<ServerShutdownInfo> serverShutdownInfos =\n+            createServerShutdownInfosForCluster(CLUSTER, MS1, MS2);\n+    serverShutdownInfos.addAll(createServerShutdownInfosForCluster(CLUSTER2, MS3, MS4));\n+    invokeStepWithServerShutdownInfos(serverShutdownInfos);\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS4), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS3), is(Boolean.FALSE));\n+  }\n+\n+  @Test\n+  public void maxClusterConcurrentShutdown_doesNotApplyToNonClusteredServers() {\n+    domain.getSpec().setMaxClusterConcurrentShutdown(1);\n+\n+    addWlsServers(MS3, MS4);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS3,MS4);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfos(MS3, MS4));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS4), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS3), is(Boolean.TRUE));\n+  }\n+\n+  @NotNull\n+  private List<ServerShutdownInfo> createServerShutdownInfosForCluster(String clusterName, String... servers) {\n+    List<ServerShutdownInfo> serverShutdownInfos = new ArrayList<>();\n+    Arrays.stream(servers).forEach(server ->\n+            serverShutdownInfos.add(\n+                    new ServerShutdownInfo(configSupport.getWlsServer(clusterName, server).getName(),\n+                            clusterName)\n+            )\n+    );\n+    return serverShutdownInfos;\n+  }\n+\n+  @NotNull", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8597bca2836390659420e4603a74f6f363c45a82"}, "originalPosition": 350}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDQzNDE4OnYy", "diffSide": "RIGHT", "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNDoyMjozMVrOHLxkgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNDoyMjozMVrOHLxkgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEwODU0Nw==", "bodyText": "This line that executes the code you're testing is repeated in each test, with the only real differences being that in some tests you create infos without a cluster, in some you create them with a cluster, and in one you create them for multiple clusters. As written now, it is hard at first glance to see what is going on.\nThis could be clarified in a number of ways. Maybe the cleanest would use a builder pattern, so that you could do something like.\ncreateShutdownInfos()\n    .forServers(MS1, MS2)\n    .forClusteredServers(CLUSTER, MS3, MS4)\n    .shutdown();\n\nThat would greatly improve readability of the tests. Also, please make sure to leave a blank line between the execution portion of each unit test and the assertions.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482108547", "createdAt": "2020-09-02T14:22:31Z", "author": {"login": "russgold"}, "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "diffHunk": "@@ -0,0 +1,383 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.steps;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import javax.annotation.Nonnull;\n+\n+import com.meterware.simplestub.Memento;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodStatus;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.kubernetes.operator.KubernetesConstants;\n+import oracle.kubernetes.operator.LabelConstants;\n+import oracle.kubernetes.operator.PodAwaiterStepFactory;\n+import oracle.kubernetes.operator.ProcessingConstants;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo.ServerShutdownInfo;\n+import oracle.kubernetes.operator.helpers.KubernetesTestSupport;\n+import oracle.kubernetes.operator.helpers.LegalNames;\n+import oracle.kubernetes.operator.helpers.PodHelperTestBase;\n+import oracle.kubernetes.operator.helpers.TuningParametersStub;\n+import oracle.kubernetes.operator.utils.WlsDomainConfigSupport;\n+import oracle.kubernetes.operator.wlsconfig.WlsClusterConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsDomainConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsServerConfig;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.operator.work.TerminalStep;\n+import oracle.kubernetes.utils.TestUtils;\n+import oracle.kubernetes.weblogic.domain.ClusterConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfiguratorFactory;\n+import oracle.kubernetes.weblogic.domain.model.Domain;\n+import oracle.kubernetes.weblogic.domain.model.DomainSpec;\n+import org.hamcrest.junit.MatcherAssert;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.junit.MatcherAssert.assertThat;\n+\n+public class ServerDownIteratorStepTest {\n+\n+  protected static final String DOMAIN_NAME = \"domain1\";\n+  private static final String NS = \"namespace\";\n+  private static final String UID = \"uid1\";\n+  protected static final String KUBERNETES_UID = \"12345\";\n+  private static final String ADMIN = \"asName\";\n+  private static final String CLUSTER = \"cluster1\";\n+  private static final boolean INCLUDE_SERVER_OUT_IN_POD_LOG = true;\n+  private static final String CREDENTIALS_SECRET_NAME = \"webLogicCredentialsSecretName\";\n+  private static final String LATEST_IMAGE = \"image:latest\";\n+  private static final String MS_PREFIX = \"ms\";\n+  private static final String MS1 = MS_PREFIX + \"1\";\n+  private static final String MS2 = MS_PREFIX + \"2\";\n+  private static final String MS3 = MS_PREFIX + \"3\";\n+  private static final String MS4 = MS_PREFIX + \"4\";\n+  private static final int MAX_SERVERS = 5;\n+  private static final int PORT = 8001;\n+  private static final String[] MANAGED_SERVER_NAMES =\n+          IntStream.rangeClosed(1, MAX_SERVERS)\n+                  .mapToObj(ServerDownIteratorStepTest::getManagedServerName).toArray(String[]::new);\n+\n+  @Nonnull\n+  private static String getManagedServerName(int n) {\n+    return MS_PREFIX + n;\n+  }\n+\n+  private final Domain domain = createDomain();\n+  private final DomainConfigurator configurator = DomainConfiguratorFactory.forDomain(domain);\n+  private final WlsDomainConfigSupport configSupport = new WlsDomainConfigSupport(DOMAIN_NAME);\n+\n+  private final Step nextStep = new TerminalStep();\n+  private final KubernetesTestSupport testSupport = new KubernetesTestSupport();\n+  private final List<Memento> mementos = new ArrayList<>();\n+  private DomainPresenceInfo domainPresenceInfo = createDomainPresenceInfoWithServers();\n+  private final WlsDomainConfig domainConfig = createDomainConfig();\n+\n+  private static WlsDomainConfig createDomainConfig() {\n+    WlsClusterConfig clusterConfig = new WlsClusterConfig(CLUSTER);\n+    for (String serverName : MANAGED_SERVER_NAMES) {\n+      clusterConfig.addServerConfig(new WlsServerConfig(serverName, \"domain1-\" + serverName, 8001));\n+    }\n+    return new WlsDomainConfig(\"base_domain\")\n+            .withAdminServer(ADMIN, \"domain1-admin-server\", 7001)\n+            .withCluster(clusterConfig);\n+  }\n+\n+  private DomainPresenceInfo createDomainPresenceInfoWithServers(String... serverNames) {\n+    DomainPresenceInfo dpi = new DomainPresenceInfo(domain);\n+    addServer(dpi, ADMIN);\n+    Arrays.asList(serverNames).forEach(serverName -> addServer(dpi, serverName));\n+    return dpi;\n+  }\n+\n+  private Domain createDomain() {\n+    return new Domain()\n+            .withApiVersion(KubernetesConstants.DOMAIN_VERSION)\n+            .withKind(KubernetesConstants.DOMAIN)\n+            .withMetadata(new V1ObjectMeta().namespace(NS).name(DOMAIN_NAME).uid(KUBERNETES_UID))\n+            .withSpec(createDomainSpec());\n+  }\n+\n+  private DomainSpec createDomainSpec() {\n+    return new DomainSpec()\n+            .withDomainUid(UID)\n+            .withWebLogicCredentialsSecret(new V1SecretReference().name(CREDENTIALS_SECRET_NAME))\n+            .withIncludeServerOutInPodLog(INCLUDE_SERVER_OUT_IN_POD_LOG)\n+            .withImage(LATEST_IMAGE);\n+  }\n+\n+  private static void addServer(DomainPresenceInfo domainPresenceInfo, String serverName) {\n+    if (serverName.equals(ADMIN)) {\n+      domainPresenceInfo.setServerPod(serverName, createReadyPod(serverName));\n+    } else {\n+      domainPresenceInfo.setServerPod(serverName, createPod(serverName));\n+    }\n+  }\n+\n+  private static V1Pod createReadyPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName))\n+            .spec(new V1PodSpec().nodeName(\"Node1\"))\n+            .status(new V1PodStatus().phase(\"Running\")\n+            .addConditionsItem(new V1PodCondition().type(\"Ready\").status(\"True\")));\n+  }\n+\n+  private static V1Pod createPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName));\n+  }\n+\n+  private static V1ObjectMeta withNames(V1ObjectMeta objectMeta, String serverName) {\n+    return objectMeta\n+            .name(LegalNames.toPodName(UID, serverName))\n+            .putLabelsItem(LabelConstants.SERVERNAME_LABEL, serverName);\n+  }\n+\n+  /**\n+   * Setup env for tests.\n+   * @throws NoSuchFieldException if TestStepFactory fails to install\n+   */\n+  @Before\n+  public void setUp() throws NoSuchFieldException {\n+    mementos.add(TestUtils.silenceOperatorLogger().ignoringLoggedExceptions(ApiException.class));\n+    mementos.add(TuningParametersStub.install());\n+    mementos.add(testSupport.install());\n+\n+    testSupport.defineResources(domain);\n+    testSupport\n+            .addToPacket(ProcessingConstants.DOMAIN_TOPOLOGY, domainConfig)\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    testSupport.addComponent(\n+            ProcessingConstants.PODWATCHER_COMPONENT_NAME,\n+            PodAwaiterStepFactory.class,\n+            new PodHelperTestBase.DelayedPodAwaiterStepFactory(1));\n+\n+  }\n+\n+  /**\n+   * Cleanup env after tests.\n+   * @throws Exception if test support failed\n+   */\n+  @After\n+  public void tearDown() throws Exception {\n+    for (Memento memento : mementos) {\n+      memento.revert();\n+    }\n+\n+    testSupport.throwOnCompletionFailure();\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf1_bothClusteredServersShutdownSequentially() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(1);\n+    addWlsCluster(CLUSTER, 8001, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8597bca2836390659420e4603a74f6f363c45a82"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDQ1MzUyOnYy", "diffSide": "RIGHT", "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNDoyNjoyNlrOHLxwrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNDoyNjoyNlrOHLxwrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExMTY2MA==", "bodyText": "Get in the habit of doing static imports for assertThat. Showing the class name doesn't help readability.\nIn addition, you invoke DomainPresenceInfo.isServerPodBeingDeleted a lot. It would be worthwhile to have a method that simply returns the names of all of the pods being deleted. That way you could do a single assert on the collection.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482111660", "createdAt": "2020-09-02T14:26:26Z", "author": {"login": "russgold"}, "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "diffHunk": "@@ -0,0 +1,383 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.steps;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import javax.annotation.Nonnull;\n+\n+import com.meterware.simplestub.Memento;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodStatus;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.kubernetes.operator.KubernetesConstants;\n+import oracle.kubernetes.operator.LabelConstants;\n+import oracle.kubernetes.operator.PodAwaiterStepFactory;\n+import oracle.kubernetes.operator.ProcessingConstants;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo.ServerShutdownInfo;\n+import oracle.kubernetes.operator.helpers.KubernetesTestSupport;\n+import oracle.kubernetes.operator.helpers.LegalNames;\n+import oracle.kubernetes.operator.helpers.PodHelperTestBase;\n+import oracle.kubernetes.operator.helpers.TuningParametersStub;\n+import oracle.kubernetes.operator.utils.WlsDomainConfigSupport;\n+import oracle.kubernetes.operator.wlsconfig.WlsClusterConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsDomainConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsServerConfig;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.operator.work.TerminalStep;\n+import oracle.kubernetes.utils.TestUtils;\n+import oracle.kubernetes.weblogic.domain.ClusterConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfiguratorFactory;\n+import oracle.kubernetes.weblogic.domain.model.Domain;\n+import oracle.kubernetes.weblogic.domain.model.DomainSpec;\n+import org.hamcrest.junit.MatcherAssert;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.junit.MatcherAssert.assertThat;\n+\n+public class ServerDownIteratorStepTest {\n+\n+  protected static final String DOMAIN_NAME = \"domain1\";\n+  private static final String NS = \"namespace\";\n+  private static final String UID = \"uid1\";\n+  protected static final String KUBERNETES_UID = \"12345\";\n+  private static final String ADMIN = \"asName\";\n+  private static final String CLUSTER = \"cluster1\";\n+  private static final boolean INCLUDE_SERVER_OUT_IN_POD_LOG = true;\n+  private static final String CREDENTIALS_SECRET_NAME = \"webLogicCredentialsSecretName\";\n+  private static final String LATEST_IMAGE = \"image:latest\";\n+  private static final String MS_PREFIX = \"ms\";\n+  private static final String MS1 = MS_PREFIX + \"1\";\n+  private static final String MS2 = MS_PREFIX + \"2\";\n+  private static final String MS3 = MS_PREFIX + \"3\";\n+  private static final String MS4 = MS_PREFIX + \"4\";\n+  private static final int MAX_SERVERS = 5;\n+  private static final int PORT = 8001;\n+  private static final String[] MANAGED_SERVER_NAMES =\n+          IntStream.rangeClosed(1, MAX_SERVERS)\n+                  .mapToObj(ServerDownIteratorStepTest::getManagedServerName).toArray(String[]::new);\n+\n+  @Nonnull\n+  private static String getManagedServerName(int n) {\n+    return MS_PREFIX + n;\n+  }\n+\n+  private final Domain domain = createDomain();\n+  private final DomainConfigurator configurator = DomainConfiguratorFactory.forDomain(domain);\n+  private final WlsDomainConfigSupport configSupport = new WlsDomainConfigSupport(DOMAIN_NAME);\n+\n+  private final Step nextStep = new TerminalStep();\n+  private final KubernetesTestSupport testSupport = new KubernetesTestSupport();\n+  private final List<Memento> mementos = new ArrayList<>();\n+  private DomainPresenceInfo domainPresenceInfo = createDomainPresenceInfoWithServers();\n+  private final WlsDomainConfig domainConfig = createDomainConfig();\n+\n+  private static WlsDomainConfig createDomainConfig() {\n+    WlsClusterConfig clusterConfig = new WlsClusterConfig(CLUSTER);\n+    for (String serverName : MANAGED_SERVER_NAMES) {\n+      clusterConfig.addServerConfig(new WlsServerConfig(serverName, \"domain1-\" + serverName, 8001));\n+    }\n+    return new WlsDomainConfig(\"base_domain\")\n+            .withAdminServer(ADMIN, \"domain1-admin-server\", 7001)\n+            .withCluster(clusterConfig);\n+  }\n+\n+  private DomainPresenceInfo createDomainPresenceInfoWithServers(String... serverNames) {\n+    DomainPresenceInfo dpi = new DomainPresenceInfo(domain);\n+    addServer(dpi, ADMIN);\n+    Arrays.asList(serverNames).forEach(serverName -> addServer(dpi, serverName));\n+    return dpi;\n+  }\n+\n+  private Domain createDomain() {\n+    return new Domain()\n+            .withApiVersion(KubernetesConstants.DOMAIN_VERSION)\n+            .withKind(KubernetesConstants.DOMAIN)\n+            .withMetadata(new V1ObjectMeta().namespace(NS).name(DOMAIN_NAME).uid(KUBERNETES_UID))\n+            .withSpec(createDomainSpec());\n+  }\n+\n+  private DomainSpec createDomainSpec() {\n+    return new DomainSpec()\n+            .withDomainUid(UID)\n+            .withWebLogicCredentialsSecret(new V1SecretReference().name(CREDENTIALS_SECRET_NAME))\n+            .withIncludeServerOutInPodLog(INCLUDE_SERVER_OUT_IN_POD_LOG)\n+            .withImage(LATEST_IMAGE);\n+  }\n+\n+  private static void addServer(DomainPresenceInfo domainPresenceInfo, String serverName) {\n+    if (serverName.equals(ADMIN)) {\n+      domainPresenceInfo.setServerPod(serverName, createReadyPod(serverName));\n+    } else {\n+      domainPresenceInfo.setServerPod(serverName, createPod(serverName));\n+    }\n+  }\n+\n+  private static V1Pod createReadyPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName))\n+            .spec(new V1PodSpec().nodeName(\"Node1\"))\n+            .status(new V1PodStatus().phase(\"Running\")\n+            .addConditionsItem(new V1PodCondition().type(\"Ready\").status(\"True\")));\n+  }\n+\n+  private static V1Pod createPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName));\n+  }\n+\n+  private static V1ObjectMeta withNames(V1ObjectMeta objectMeta, String serverName) {\n+    return objectMeta\n+            .name(LegalNames.toPodName(UID, serverName))\n+            .putLabelsItem(LabelConstants.SERVERNAME_LABEL, serverName);\n+  }\n+\n+  /**\n+   * Setup env for tests.\n+   * @throws NoSuchFieldException if TestStepFactory fails to install\n+   */\n+  @Before\n+  public void setUp() throws NoSuchFieldException {\n+    mementos.add(TestUtils.silenceOperatorLogger().ignoringLoggedExceptions(ApiException.class));\n+    mementos.add(TuningParametersStub.install());\n+    mementos.add(testSupport.install());\n+\n+    testSupport.defineResources(domain);\n+    testSupport\n+            .addToPacket(ProcessingConstants.DOMAIN_TOPOLOGY, domainConfig)\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    testSupport.addComponent(\n+            ProcessingConstants.PODWATCHER_COMPONENT_NAME,\n+            PodAwaiterStepFactory.class,\n+            new PodHelperTestBase.DelayedPodAwaiterStepFactory(1));\n+\n+  }\n+\n+  /**\n+   * Cleanup env after tests.\n+   * @throws Exception if test support failed\n+   */\n+  @After\n+  public void tearDown() throws Exception {\n+    for (Memento memento : mementos) {\n+      memento.revert();\n+    }\n+\n+    testSupport.throwOnCompletionFailure();\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf1_bothClusteredServersShutdownSequentially() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(1);\n+    addWlsCluster(CLUSTER, 8001, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8597bca2836390659420e4603a74f6f363c45a82"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDQ1OTA1OnYy", "diffSide": "RIGHT", "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNDoyNzoyNlrOHLxz9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNDoyNzoyNlrOHLxz9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExMjUwMg==", "bodyText": "Remove blank lines in the middle of your test setup, reserving them as dividers between setup, execution, and validation.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482112502", "createdAt": "2020-09-02T14:27:26Z", "author": {"login": "russgold"}, "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "diffHunk": "@@ -0,0 +1,383 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.steps;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import javax.annotation.Nonnull;\n+\n+import com.meterware.simplestub.Memento;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodStatus;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.kubernetes.operator.KubernetesConstants;\n+import oracle.kubernetes.operator.LabelConstants;\n+import oracle.kubernetes.operator.PodAwaiterStepFactory;\n+import oracle.kubernetes.operator.ProcessingConstants;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo.ServerShutdownInfo;\n+import oracle.kubernetes.operator.helpers.KubernetesTestSupport;\n+import oracle.kubernetes.operator.helpers.LegalNames;\n+import oracle.kubernetes.operator.helpers.PodHelperTestBase;\n+import oracle.kubernetes.operator.helpers.TuningParametersStub;\n+import oracle.kubernetes.operator.utils.WlsDomainConfigSupport;\n+import oracle.kubernetes.operator.wlsconfig.WlsClusterConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsDomainConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsServerConfig;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.operator.work.TerminalStep;\n+import oracle.kubernetes.utils.TestUtils;\n+import oracle.kubernetes.weblogic.domain.ClusterConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfiguratorFactory;\n+import oracle.kubernetes.weblogic.domain.model.Domain;\n+import oracle.kubernetes.weblogic.domain.model.DomainSpec;\n+import org.hamcrest.junit.MatcherAssert;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.junit.MatcherAssert.assertThat;\n+\n+public class ServerDownIteratorStepTest {\n+\n+  protected static final String DOMAIN_NAME = \"domain1\";\n+  private static final String NS = \"namespace\";\n+  private static final String UID = \"uid1\";\n+  protected static final String KUBERNETES_UID = \"12345\";\n+  private static final String ADMIN = \"asName\";\n+  private static final String CLUSTER = \"cluster1\";\n+  private static final boolean INCLUDE_SERVER_OUT_IN_POD_LOG = true;\n+  private static final String CREDENTIALS_SECRET_NAME = \"webLogicCredentialsSecretName\";\n+  private static final String LATEST_IMAGE = \"image:latest\";\n+  private static final String MS_PREFIX = \"ms\";\n+  private static final String MS1 = MS_PREFIX + \"1\";\n+  private static final String MS2 = MS_PREFIX + \"2\";\n+  private static final String MS3 = MS_PREFIX + \"3\";\n+  private static final String MS4 = MS_PREFIX + \"4\";\n+  private static final int MAX_SERVERS = 5;\n+  private static final int PORT = 8001;\n+  private static final String[] MANAGED_SERVER_NAMES =\n+          IntStream.rangeClosed(1, MAX_SERVERS)\n+                  .mapToObj(ServerDownIteratorStepTest::getManagedServerName).toArray(String[]::new);\n+\n+  @Nonnull\n+  private static String getManagedServerName(int n) {\n+    return MS_PREFIX + n;\n+  }\n+\n+  private final Domain domain = createDomain();\n+  private final DomainConfigurator configurator = DomainConfiguratorFactory.forDomain(domain);\n+  private final WlsDomainConfigSupport configSupport = new WlsDomainConfigSupport(DOMAIN_NAME);\n+\n+  private final Step nextStep = new TerminalStep();\n+  private final KubernetesTestSupport testSupport = new KubernetesTestSupport();\n+  private final List<Memento> mementos = new ArrayList<>();\n+  private DomainPresenceInfo domainPresenceInfo = createDomainPresenceInfoWithServers();\n+  private final WlsDomainConfig domainConfig = createDomainConfig();\n+\n+  private static WlsDomainConfig createDomainConfig() {\n+    WlsClusterConfig clusterConfig = new WlsClusterConfig(CLUSTER);\n+    for (String serverName : MANAGED_SERVER_NAMES) {\n+      clusterConfig.addServerConfig(new WlsServerConfig(serverName, \"domain1-\" + serverName, 8001));\n+    }\n+    return new WlsDomainConfig(\"base_domain\")\n+            .withAdminServer(ADMIN, \"domain1-admin-server\", 7001)\n+            .withCluster(clusterConfig);\n+  }\n+\n+  private DomainPresenceInfo createDomainPresenceInfoWithServers(String... serverNames) {\n+    DomainPresenceInfo dpi = new DomainPresenceInfo(domain);\n+    addServer(dpi, ADMIN);\n+    Arrays.asList(serverNames).forEach(serverName -> addServer(dpi, serverName));\n+    return dpi;\n+  }\n+\n+  private Domain createDomain() {\n+    return new Domain()\n+            .withApiVersion(KubernetesConstants.DOMAIN_VERSION)\n+            .withKind(KubernetesConstants.DOMAIN)\n+            .withMetadata(new V1ObjectMeta().namespace(NS).name(DOMAIN_NAME).uid(KUBERNETES_UID))\n+            .withSpec(createDomainSpec());\n+  }\n+\n+  private DomainSpec createDomainSpec() {\n+    return new DomainSpec()\n+            .withDomainUid(UID)\n+            .withWebLogicCredentialsSecret(new V1SecretReference().name(CREDENTIALS_SECRET_NAME))\n+            .withIncludeServerOutInPodLog(INCLUDE_SERVER_OUT_IN_POD_LOG)\n+            .withImage(LATEST_IMAGE);\n+  }\n+\n+  private static void addServer(DomainPresenceInfo domainPresenceInfo, String serverName) {\n+    if (serverName.equals(ADMIN)) {\n+      domainPresenceInfo.setServerPod(serverName, createReadyPod(serverName));\n+    } else {\n+      domainPresenceInfo.setServerPod(serverName, createPod(serverName));\n+    }\n+  }\n+\n+  private static V1Pod createReadyPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName))\n+            .spec(new V1PodSpec().nodeName(\"Node1\"))\n+            .status(new V1PodStatus().phase(\"Running\")\n+            .addConditionsItem(new V1PodCondition().type(\"Ready\").status(\"True\")));\n+  }\n+\n+  private static V1Pod createPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName));\n+  }\n+\n+  private static V1ObjectMeta withNames(V1ObjectMeta objectMeta, String serverName) {\n+    return objectMeta\n+            .name(LegalNames.toPodName(UID, serverName))\n+            .putLabelsItem(LabelConstants.SERVERNAME_LABEL, serverName);\n+  }\n+\n+  /**\n+   * Setup env for tests.\n+   * @throws NoSuchFieldException if TestStepFactory fails to install\n+   */\n+  @Before\n+  public void setUp() throws NoSuchFieldException {\n+    mementos.add(TestUtils.silenceOperatorLogger().ignoringLoggedExceptions(ApiException.class));\n+    mementos.add(TuningParametersStub.install());\n+    mementos.add(testSupport.install());\n+\n+    testSupport.defineResources(domain);\n+    testSupport\n+            .addToPacket(ProcessingConstants.DOMAIN_TOPOLOGY, domainConfig)\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    testSupport.addComponent(\n+            ProcessingConstants.PODWATCHER_COMPONENT_NAME,\n+            PodAwaiterStepFactory.class,\n+            new PodHelperTestBase.DelayedPodAwaiterStepFactory(1));\n+\n+  }\n+\n+  /**\n+   * Cleanup env after tests.\n+   * @throws Exception if test support failed\n+   */\n+  @After\n+  public void tearDown() throws Exception {\n+    for (Memento memento : mementos) {\n+      memento.revert();\n+    }\n+\n+    testSupport.throwOnCompletionFailure();\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf1_bothClusteredServersShutdownSequentially() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(1);\n+    addWlsCluster(CLUSTER, 8001, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+    testSupport.setTime(10, TimeUnit.SECONDS);\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2_bothClusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(1);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf0_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8597bca2836390659420e4603a74f6f363c45a82"}, "originalPosition": 219}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDQ3MTU2OnYy", "diffSide": "RIGHT", "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNDoyOTo0N1rOHLx7oA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzoyNjo0MlrOHMmhhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNDQ2NA==", "bodyText": "What is going on in this test? Why do the servers shut down concurrently with a concurrency of 1? There seems to be something important going on, and the name of the test doesn't clarify it.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482114464", "createdAt": "2020-09-02T14:29:47Z", "author": {"login": "russgold"}, "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "diffHunk": "@@ -0,0 +1,383 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.steps;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import javax.annotation.Nonnull;\n+\n+import com.meterware.simplestub.Memento;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodStatus;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.kubernetes.operator.KubernetesConstants;\n+import oracle.kubernetes.operator.LabelConstants;\n+import oracle.kubernetes.operator.PodAwaiterStepFactory;\n+import oracle.kubernetes.operator.ProcessingConstants;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo.ServerShutdownInfo;\n+import oracle.kubernetes.operator.helpers.KubernetesTestSupport;\n+import oracle.kubernetes.operator.helpers.LegalNames;\n+import oracle.kubernetes.operator.helpers.PodHelperTestBase;\n+import oracle.kubernetes.operator.helpers.TuningParametersStub;\n+import oracle.kubernetes.operator.utils.WlsDomainConfigSupport;\n+import oracle.kubernetes.operator.wlsconfig.WlsClusterConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsDomainConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsServerConfig;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.operator.work.TerminalStep;\n+import oracle.kubernetes.utils.TestUtils;\n+import oracle.kubernetes.weblogic.domain.ClusterConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfiguratorFactory;\n+import oracle.kubernetes.weblogic.domain.model.Domain;\n+import oracle.kubernetes.weblogic.domain.model.DomainSpec;\n+import org.hamcrest.junit.MatcherAssert;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.junit.MatcherAssert.assertThat;\n+\n+public class ServerDownIteratorStepTest {\n+\n+  protected static final String DOMAIN_NAME = \"domain1\";\n+  private static final String NS = \"namespace\";\n+  private static final String UID = \"uid1\";\n+  protected static final String KUBERNETES_UID = \"12345\";\n+  private static final String ADMIN = \"asName\";\n+  private static final String CLUSTER = \"cluster1\";\n+  private static final boolean INCLUDE_SERVER_OUT_IN_POD_LOG = true;\n+  private static final String CREDENTIALS_SECRET_NAME = \"webLogicCredentialsSecretName\";\n+  private static final String LATEST_IMAGE = \"image:latest\";\n+  private static final String MS_PREFIX = \"ms\";\n+  private static final String MS1 = MS_PREFIX + \"1\";\n+  private static final String MS2 = MS_PREFIX + \"2\";\n+  private static final String MS3 = MS_PREFIX + \"3\";\n+  private static final String MS4 = MS_PREFIX + \"4\";\n+  private static final int MAX_SERVERS = 5;\n+  private static final int PORT = 8001;\n+  private static final String[] MANAGED_SERVER_NAMES =\n+          IntStream.rangeClosed(1, MAX_SERVERS)\n+                  .mapToObj(ServerDownIteratorStepTest::getManagedServerName).toArray(String[]::new);\n+\n+  @Nonnull\n+  private static String getManagedServerName(int n) {\n+    return MS_PREFIX + n;\n+  }\n+\n+  private final Domain domain = createDomain();\n+  private final DomainConfigurator configurator = DomainConfiguratorFactory.forDomain(domain);\n+  private final WlsDomainConfigSupport configSupport = new WlsDomainConfigSupport(DOMAIN_NAME);\n+\n+  private final Step nextStep = new TerminalStep();\n+  private final KubernetesTestSupport testSupport = new KubernetesTestSupport();\n+  private final List<Memento> mementos = new ArrayList<>();\n+  private DomainPresenceInfo domainPresenceInfo = createDomainPresenceInfoWithServers();\n+  private final WlsDomainConfig domainConfig = createDomainConfig();\n+\n+  private static WlsDomainConfig createDomainConfig() {\n+    WlsClusterConfig clusterConfig = new WlsClusterConfig(CLUSTER);\n+    for (String serverName : MANAGED_SERVER_NAMES) {\n+      clusterConfig.addServerConfig(new WlsServerConfig(serverName, \"domain1-\" + serverName, 8001));\n+    }\n+    return new WlsDomainConfig(\"base_domain\")\n+            .withAdminServer(ADMIN, \"domain1-admin-server\", 7001)\n+            .withCluster(clusterConfig);\n+  }\n+\n+  private DomainPresenceInfo createDomainPresenceInfoWithServers(String... serverNames) {\n+    DomainPresenceInfo dpi = new DomainPresenceInfo(domain);\n+    addServer(dpi, ADMIN);\n+    Arrays.asList(serverNames).forEach(serverName -> addServer(dpi, serverName));\n+    return dpi;\n+  }\n+\n+  private Domain createDomain() {\n+    return new Domain()\n+            .withApiVersion(KubernetesConstants.DOMAIN_VERSION)\n+            .withKind(KubernetesConstants.DOMAIN)\n+            .withMetadata(new V1ObjectMeta().namespace(NS).name(DOMAIN_NAME).uid(KUBERNETES_UID))\n+            .withSpec(createDomainSpec());\n+  }\n+\n+  private DomainSpec createDomainSpec() {\n+    return new DomainSpec()\n+            .withDomainUid(UID)\n+            .withWebLogicCredentialsSecret(new V1SecretReference().name(CREDENTIALS_SECRET_NAME))\n+            .withIncludeServerOutInPodLog(INCLUDE_SERVER_OUT_IN_POD_LOG)\n+            .withImage(LATEST_IMAGE);\n+  }\n+\n+  private static void addServer(DomainPresenceInfo domainPresenceInfo, String serverName) {\n+    if (serverName.equals(ADMIN)) {\n+      domainPresenceInfo.setServerPod(serverName, createReadyPod(serverName));\n+    } else {\n+      domainPresenceInfo.setServerPod(serverName, createPod(serverName));\n+    }\n+  }\n+\n+  private static V1Pod createReadyPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName))\n+            .spec(new V1PodSpec().nodeName(\"Node1\"))\n+            .status(new V1PodStatus().phase(\"Running\")\n+            .addConditionsItem(new V1PodCondition().type(\"Ready\").status(\"True\")));\n+  }\n+\n+  private static V1Pod createPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName));\n+  }\n+\n+  private static V1ObjectMeta withNames(V1ObjectMeta objectMeta, String serverName) {\n+    return objectMeta\n+            .name(LegalNames.toPodName(UID, serverName))\n+            .putLabelsItem(LabelConstants.SERVERNAME_LABEL, serverName);\n+  }\n+\n+  /**\n+   * Setup env for tests.\n+   * @throws NoSuchFieldException if TestStepFactory fails to install\n+   */\n+  @Before\n+  public void setUp() throws NoSuchFieldException {\n+    mementos.add(TestUtils.silenceOperatorLogger().ignoringLoggedExceptions(ApiException.class));\n+    mementos.add(TuningParametersStub.install());\n+    mementos.add(testSupport.install());\n+\n+    testSupport.defineResources(domain);\n+    testSupport\n+            .addToPacket(ProcessingConstants.DOMAIN_TOPOLOGY, domainConfig)\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    testSupport.addComponent(\n+            ProcessingConstants.PODWATCHER_COMPONENT_NAME,\n+            PodAwaiterStepFactory.class,\n+            new PodHelperTestBase.DelayedPodAwaiterStepFactory(1));\n+\n+  }\n+\n+  /**\n+   * Cleanup env after tests.\n+   * @throws Exception if test support failed\n+   */\n+  @After\n+  public void tearDown() throws Exception {\n+    for (Memento memento : mementos) {\n+      memento.revert();\n+    }\n+\n+    testSupport.throwOnCompletionFailure();\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf1_bothClusteredServersShutdownSequentially() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(1);\n+    addWlsCluster(CLUSTER, 8001, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+    testSupport.setTime(10, TimeUnit.SECONDS);\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2_bothClusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(1);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf0_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withReplicaCountOf0AndConcurrencyOf1_clusteredServersShutdownConcurrently() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8597bca2836390659420e4603a74f6f363c45a82"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ0ODgyNg==", "bodyText": "OWLS-83136 has below requirement -\nIf a WL cluster shrinks to '0' (i.e. replica count is set to 0), then this indicates that the administrator isn't concerned about preserving replicated/volatile state, there's no need to shutdown one-at-a-time, and we should do a concurrent shutdown. We ignore the concurrency value when replica count is set to 0.\nI can look into changing the test name to clarify it. Please let me know if you have any suggestions.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482448826", "createdAt": "2020-09-02T20:50:42Z", "author": {"login": "ankedia"}, "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "diffHunk": "@@ -0,0 +1,383 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.steps;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import javax.annotation.Nonnull;\n+\n+import com.meterware.simplestub.Memento;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodStatus;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.kubernetes.operator.KubernetesConstants;\n+import oracle.kubernetes.operator.LabelConstants;\n+import oracle.kubernetes.operator.PodAwaiterStepFactory;\n+import oracle.kubernetes.operator.ProcessingConstants;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo.ServerShutdownInfo;\n+import oracle.kubernetes.operator.helpers.KubernetesTestSupport;\n+import oracle.kubernetes.operator.helpers.LegalNames;\n+import oracle.kubernetes.operator.helpers.PodHelperTestBase;\n+import oracle.kubernetes.operator.helpers.TuningParametersStub;\n+import oracle.kubernetes.operator.utils.WlsDomainConfigSupport;\n+import oracle.kubernetes.operator.wlsconfig.WlsClusterConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsDomainConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsServerConfig;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.operator.work.TerminalStep;\n+import oracle.kubernetes.utils.TestUtils;\n+import oracle.kubernetes.weblogic.domain.ClusterConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfiguratorFactory;\n+import oracle.kubernetes.weblogic.domain.model.Domain;\n+import oracle.kubernetes.weblogic.domain.model.DomainSpec;\n+import org.hamcrest.junit.MatcherAssert;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.junit.MatcherAssert.assertThat;\n+\n+public class ServerDownIteratorStepTest {\n+\n+  protected static final String DOMAIN_NAME = \"domain1\";\n+  private static final String NS = \"namespace\";\n+  private static final String UID = \"uid1\";\n+  protected static final String KUBERNETES_UID = \"12345\";\n+  private static final String ADMIN = \"asName\";\n+  private static final String CLUSTER = \"cluster1\";\n+  private static final boolean INCLUDE_SERVER_OUT_IN_POD_LOG = true;\n+  private static final String CREDENTIALS_SECRET_NAME = \"webLogicCredentialsSecretName\";\n+  private static final String LATEST_IMAGE = \"image:latest\";\n+  private static final String MS_PREFIX = \"ms\";\n+  private static final String MS1 = MS_PREFIX + \"1\";\n+  private static final String MS2 = MS_PREFIX + \"2\";\n+  private static final String MS3 = MS_PREFIX + \"3\";\n+  private static final String MS4 = MS_PREFIX + \"4\";\n+  private static final int MAX_SERVERS = 5;\n+  private static final int PORT = 8001;\n+  private static final String[] MANAGED_SERVER_NAMES =\n+          IntStream.rangeClosed(1, MAX_SERVERS)\n+                  .mapToObj(ServerDownIteratorStepTest::getManagedServerName).toArray(String[]::new);\n+\n+  @Nonnull\n+  private static String getManagedServerName(int n) {\n+    return MS_PREFIX + n;\n+  }\n+\n+  private final Domain domain = createDomain();\n+  private final DomainConfigurator configurator = DomainConfiguratorFactory.forDomain(domain);\n+  private final WlsDomainConfigSupport configSupport = new WlsDomainConfigSupport(DOMAIN_NAME);\n+\n+  private final Step nextStep = new TerminalStep();\n+  private final KubernetesTestSupport testSupport = new KubernetesTestSupport();\n+  private final List<Memento> mementos = new ArrayList<>();\n+  private DomainPresenceInfo domainPresenceInfo = createDomainPresenceInfoWithServers();\n+  private final WlsDomainConfig domainConfig = createDomainConfig();\n+\n+  private static WlsDomainConfig createDomainConfig() {\n+    WlsClusterConfig clusterConfig = new WlsClusterConfig(CLUSTER);\n+    for (String serverName : MANAGED_SERVER_NAMES) {\n+      clusterConfig.addServerConfig(new WlsServerConfig(serverName, \"domain1-\" + serverName, 8001));\n+    }\n+    return new WlsDomainConfig(\"base_domain\")\n+            .withAdminServer(ADMIN, \"domain1-admin-server\", 7001)\n+            .withCluster(clusterConfig);\n+  }\n+\n+  private DomainPresenceInfo createDomainPresenceInfoWithServers(String... serverNames) {\n+    DomainPresenceInfo dpi = new DomainPresenceInfo(domain);\n+    addServer(dpi, ADMIN);\n+    Arrays.asList(serverNames).forEach(serverName -> addServer(dpi, serverName));\n+    return dpi;\n+  }\n+\n+  private Domain createDomain() {\n+    return new Domain()\n+            .withApiVersion(KubernetesConstants.DOMAIN_VERSION)\n+            .withKind(KubernetesConstants.DOMAIN)\n+            .withMetadata(new V1ObjectMeta().namespace(NS).name(DOMAIN_NAME).uid(KUBERNETES_UID))\n+            .withSpec(createDomainSpec());\n+  }\n+\n+  private DomainSpec createDomainSpec() {\n+    return new DomainSpec()\n+            .withDomainUid(UID)\n+            .withWebLogicCredentialsSecret(new V1SecretReference().name(CREDENTIALS_SECRET_NAME))\n+            .withIncludeServerOutInPodLog(INCLUDE_SERVER_OUT_IN_POD_LOG)\n+            .withImage(LATEST_IMAGE);\n+  }\n+\n+  private static void addServer(DomainPresenceInfo domainPresenceInfo, String serverName) {\n+    if (serverName.equals(ADMIN)) {\n+      domainPresenceInfo.setServerPod(serverName, createReadyPod(serverName));\n+    } else {\n+      domainPresenceInfo.setServerPod(serverName, createPod(serverName));\n+    }\n+  }\n+\n+  private static V1Pod createReadyPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName))\n+            .spec(new V1PodSpec().nodeName(\"Node1\"))\n+            .status(new V1PodStatus().phase(\"Running\")\n+            .addConditionsItem(new V1PodCondition().type(\"Ready\").status(\"True\")));\n+  }\n+\n+  private static V1Pod createPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName));\n+  }\n+\n+  private static V1ObjectMeta withNames(V1ObjectMeta objectMeta, String serverName) {\n+    return objectMeta\n+            .name(LegalNames.toPodName(UID, serverName))\n+            .putLabelsItem(LabelConstants.SERVERNAME_LABEL, serverName);\n+  }\n+\n+  /**\n+   * Setup env for tests.\n+   * @throws NoSuchFieldException if TestStepFactory fails to install\n+   */\n+  @Before\n+  public void setUp() throws NoSuchFieldException {\n+    mementos.add(TestUtils.silenceOperatorLogger().ignoringLoggedExceptions(ApiException.class));\n+    mementos.add(TuningParametersStub.install());\n+    mementos.add(testSupport.install());\n+\n+    testSupport.defineResources(domain);\n+    testSupport\n+            .addToPacket(ProcessingConstants.DOMAIN_TOPOLOGY, domainConfig)\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    testSupport.addComponent(\n+            ProcessingConstants.PODWATCHER_COMPONENT_NAME,\n+            PodAwaiterStepFactory.class,\n+            new PodHelperTestBase.DelayedPodAwaiterStepFactory(1));\n+\n+  }\n+\n+  /**\n+   * Cleanup env after tests.\n+   * @throws Exception if test support failed\n+   */\n+  @After\n+  public void tearDown() throws Exception {\n+    for (Memento memento : mementos) {\n+      memento.revert();\n+    }\n+\n+    testSupport.throwOnCompletionFailure();\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf1_bothClusteredServersShutdownSequentially() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(1);\n+    addWlsCluster(CLUSTER, 8001, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+    testSupport.setTime(10, TimeUnit.SECONDS);\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2_bothClusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(1);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf0_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withReplicaCountOf0AndConcurrencyOf1_clusteredServersShutdownConcurrently() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNDQ2NA=="}, "originalCommit": {"oid": "8597bca2836390659420e4603a74f6f363c45a82"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk3NjEzNQ==", "bodyText": "How about whenClusterShutdown_concurrencySettingIsIgnored ? (replica count set to 0 means the cluster is shutting down, which is why we don't care about concurrency)", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482976135", "createdAt": "2020-09-03T13:26:42Z", "author": {"login": "russgold"}, "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "diffHunk": "@@ -0,0 +1,383 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.steps;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import javax.annotation.Nonnull;\n+\n+import com.meterware.simplestub.Memento;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodStatus;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.kubernetes.operator.KubernetesConstants;\n+import oracle.kubernetes.operator.LabelConstants;\n+import oracle.kubernetes.operator.PodAwaiterStepFactory;\n+import oracle.kubernetes.operator.ProcessingConstants;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo.ServerShutdownInfo;\n+import oracle.kubernetes.operator.helpers.KubernetesTestSupport;\n+import oracle.kubernetes.operator.helpers.LegalNames;\n+import oracle.kubernetes.operator.helpers.PodHelperTestBase;\n+import oracle.kubernetes.operator.helpers.TuningParametersStub;\n+import oracle.kubernetes.operator.utils.WlsDomainConfigSupport;\n+import oracle.kubernetes.operator.wlsconfig.WlsClusterConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsDomainConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsServerConfig;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.operator.work.TerminalStep;\n+import oracle.kubernetes.utils.TestUtils;\n+import oracle.kubernetes.weblogic.domain.ClusterConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfiguratorFactory;\n+import oracle.kubernetes.weblogic.domain.model.Domain;\n+import oracle.kubernetes.weblogic.domain.model.DomainSpec;\n+import org.hamcrest.junit.MatcherAssert;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.junit.MatcherAssert.assertThat;\n+\n+public class ServerDownIteratorStepTest {\n+\n+  protected static final String DOMAIN_NAME = \"domain1\";\n+  private static final String NS = \"namespace\";\n+  private static final String UID = \"uid1\";\n+  protected static final String KUBERNETES_UID = \"12345\";\n+  private static final String ADMIN = \"asName\";\n+  private static final String CLUSTER = \"cluster1\";\n+  private static final boolean INCLUDE_SERVER_OUT_IN_POD_LOG = true;\n+  private static final String CREDENTIALS_SECRET_NAME = \"webLogicCredentialsSecretName\";\n+  private static final String LATEST_IMAGE = \"image:latest\";\n+  private static final String MS_PREFIX = \"ms\";\n+  private static final String MS1 = MS_PREFIX + \"1\";\n+  private static final String MS2 = MS_PREFIX + \"2\";\n+  private static final String MS3 = MS_PREFIX + \"3\";\n+  private static final String MS4 = MS_PREFIX + \"4\";\n+  private static final int MAX_SERVERS = 5;\n+  private static final int PORT = 8001;\n+  private static final String[] MANAGED_SERVER_NAMES =\n+          IntStream.rangeClosed(1, MAX_SERVERS)\n+                  .mapToObj(ServerDownIteratorStepTest::getManagedServerName).toArray(String[]::new);\n+\n+  @Nonnull\n+  private static String getManagedServerName(int n) {\n+    return MS_PREFIX + n;\n+  }\n+\n+  private final Domain domain = createDomain();\n+  private final DomainConfigurator configurator = DomainConfiguratorFactory.forDomain(domain);\n+  private final WlsDomainConfigSupport configSupport = new WlsDomainConfigSupport(DOMAIN_NAME);\n+\n+  private final Step nextStep = new TerminalStep();\n+  private final KubernetesTestSupport testSupport = new KubernetesTestSupport();\n+  private final List<Memento> mementos = new ArrayList<>();\n+  private DomainPresenceInfo domainPresenceInfo = createDomainPresenceInfoWithServers();\n+  private final WlsDomainConfig domainConfig = createDomainConfig();\n+\n+  private static WlsDomainConfig createDomainConfig() {\n+    WlsClusterConfig clusterConfig = new WlsClusterConfig(CLUSTER);\n+    for (String serverName : MANAGED_SERVER_NAMES) {\n+      clusterConfig.addServerConfig(new WlsServerConfig(serverName, \"domain1-\" + serverName, 8001));\n+    }\n+    return new WlsDomainConfig(\"base_domain\")\n+            .withAdminServer(ADMIN, \"domain1-admin-server\", 7001)\n+            .withCluster(clusterConfig);\n+  }\n+\n+  private DomainPresenceInfo createDomainPresenceInfoWithServers(String... serverNames) {\n+    DomainPresenceInfo dpi = new DomainPresenceInfo(domain);\n+    addServer(dpi, ADMIN);\n+    Arrays.asList(serverNames).forEach(serverName -> addServer(dpi, serverName));\n+    return dpi;\n+  }\n+\n+  private Domain createDomain() {\n+    return new Domain()\n+            .withApiVersion(KubernetesConstants.DOMAIN_VERSION)\n+            .withKind(KubernetesConstants.DOMAIN)\n+            .withMetadata(new V1ObjectMeta().namespace(NS).name(DOMAIN_NAME).uid(KUBERNETES_UID))\n+            .withSpec(createDomainSpec());\n+  }\n+\n+  private DomainSpec createDomainSpec() {\n+    return new DomainSpec()\n+            .withDomainUid(UID)\n+            .withWebLogicCredentialsSecret(new V1SecretReference().name(CREDENTIALS_SECRET_NAME))\n+            .withIncludeServerOutInPodLog(INCLUDE_SERVER_OUT_IN_POD_LOG)\n+            .withImage(LATEST_IMAGE);\n+  }\n+\n+  private static void addServer(DomainPresenceInfo domainPresenceInfo, String serverName) {\n+    if (serverName.equals(ADMIN)) {\n+      domainPresenceInfo.setServerPod(serverName, createReadyPod(serverName));\n+    } else {\n+      domainPresenceInfo.setServerPod(serverName, createPod(serverName));\n+    }\n+  }\n+\n+  private static V1Pod createReadyPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName))\n+            .spec(new V1PodSpec().nodeName(\"Node1\"))\n+            .status(new V1PodStatus().phase(\"Running\")\n+            .addConditionsItem(new V1PodCondition().type(\"Ready\").status(\"True\")));\n+  }\n+\n+  private static V1Pod createPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName));\n+  }\n+\n+  private static V1ObjectMeta withNames(V1ObjectMeta objectMeta, String serverName) {\n+    return objectMeta\n+            .name(LegalNames.toPodName(UID, serverName))\n+            .putLabelsItem(LabelConstants.SERVERNAME_LABEL, serverName);\n+  }\n+\n+  /**\n+   * Setup env for tests.\n+   * @throws NoSuchFieldException if TestStepFactory fails to install\n+   */\n+  @Before\n+  public void setUp() throws NoSuchFieldException {\n+    mementos.add(TestUtils.silenceOperatorLogger().ignoringLoggedExceptions(ApiException.class));\n+    mementos.add(TuningParametersStub.install());\n+    mementos.add(testSupport.install());\n+\n+    testSupport.defineResources(domain);\n+    testSupport\n+            .addToPacket(ProcessingConstants.DOMAIN_TOPOLOGY, domainConfig)\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    testSupport.addComponent(\n+            ProcessingConstants.PODWATCHER_COMPONENT_NAME,\n+            PodAwaiterStepFactory.class,\n+            new PodHelperTestBase.DelayedPodAwaiterStepFactory(1));\n+\n+  }\n+\n+  /**\n+   * Cleanup env after tests.\n+   * @throws Exception if test support failed\n+   */\n+  @After\n+  public void tearDown() throws Exception {\n+    for (Memento memento : mementos) {\n+      memento.revert();\n+    }\n+\n+    testSupport.throwOnCompletionFailure();\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf1_bothClusteredServersShutdownSequentially() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(1);\n+    addWlsCluster(CLUSTER, 8001, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+    testSupport.setTime(10, TimeUnit.SECONDS);\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2_bothClusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(1);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf0_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withReplicaCountOf0AndConcurrencyOf1_clusteredServersShutdownConcurrently() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNDQ2NA=="}, "originalCommit": {"oid": "8597bca2836390659420e4603a74f6f363c45a82"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDQ3NzU2OnYy", "diffSide": "RIGHT", "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNDozMDo1N1rOHLx_fQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzozMzo0NFrOHMm05g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNTQ1Mw==", "bodyText": "What is going on in this test? Why do the servers shut down in separate threads? There seems to be something important going on, and the name of the test doesn't clarify it. Is this actually two separate cases? If so, perhaps it should be two tests.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482115453", "createdAt": "2020-09-02T14:30:57Z", "author": {"login": "russgold"}, "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "diffHunk": "@@ -0,0 +1,383 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.steps;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import javax.annotation.Nonnull;\n+\n+import com.meterware.simplestub.Memento;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodStatus;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.kubernetes.operator.KubernetesConstants;\n+import oracle.kubernetes.operator.LabelConstants;\n+import oracle.kubernetes.operator.PodAwaiterStepFactory;\n+import oracle.kubernetes.operator.ProcessingConstants;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo.ServerShutdownInfo;\n+import oracle.kubernetes.operator.helpers.KubernetesTestSupport;\n+import oracle.kubernetes.operator.helpers.LegalNames;\n+import oracle.kubernetes.operator.helpers.PodHelperTestBase;\n+import oracle.kubernetes.operator.helpers.TuningParametersStub;\n+import oracle.kubernetes.operator.utils.WlsDomainConfigSupport;\n+import oracle.kubernetes.operator.wlsconfig.WlsClusterConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsDomainConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsServerConfig;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.operator.work.TerminalStep;\n+import oracle.kubernetes.utils.TestUtils;\n+import oracle.kubernetes.weblogic.domain.ClusterConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfiguratorFactory;\n+import oracle.kubernetes.weblogic.domain.model.Domain;\n+import oracle.kubernetes.weblogic.domain.model.DomainSpec;\n+import org.hamcrest.junit.MatcherAssert;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.junit.MatcherAssert.assertThat;\n+\n+public class ServerDownIteratorStepTest {\n+\n+  protected static final String DOMAIN_NAME = \"domain1\";\n+  private static final String NS = \"namespace\";\n+  private static final String UID = \"uid1\";\n+  protected static final String KUBERNETES_UID = \"12345\";\n+  private static final String ADMIN = \"asName\";\n+  private static final String CLUSTER = \"cluster1\";\n+  private static final boolean INCLUDE_SERVER_OUT_IN_POD_LOG = true;\n+  private static final String CREDENTIALS_SECRET_NAME = \"webLogicCredentialsSecretName\";\n+  private static final String LATEST_IMAGE = \"image:latest\";\n+  private static final String MS_PREFIX = \"ms\";\n+  private static final String MS1 = MS_PREFIX + \"1\";\n+  private static final String MS2 = MS_PREFIX + \"2\";\n+  private static final String MS3 = MS_PREFIX + \"3\";\n+  private static final String MS4 = MS_PREFIX + \"4\";\n+  private static final int MAX_SERVERS = 5;\n+  private static final int PORT = 8001;\n+  private static final String[] MANAGED_SERVER_NAMES =\n+          IntStream.rangeClosed(1, MAX_SERVERS)\n+                  .mapToObj(ServerDownIteratorStepTest::getManagedServerName).toArray(String[]::new);\n+\n+  @Nonnull\n+  private static String getManagedServerName(int n) {\n+    return MS_PREFIX + n;\n+  }\n+\n+  private final Domain domain = createDomain();\n+  private final DomainConfigurator configurator = DomainConfiguratorFactory.forDomain(domain);\n+  private final WlsDomainConfigSupport configSupport = new WlsDomainConfigSupport(DOMAIN_NAME);\n+\n+  private final Step nextStep = new TerminalStep();\n+  private final KubernetesTestSupport testSupport = new KubernetesTestSupport();\n+  private final List<Memento> mementos = new ArrayList<>();\n+  private DomainPresenceInfo domainPresenceInfo = createDomainPresenceInfoWithServers();\n+  private final WlsDomainConfig domainConfig = createDomainConfig();\n+\n+  private static WlsDomainConfig createDomainConfig() {\n+    WlsClusterConfig clusterConfig = new WlsClusterConfig(CLUSTER);\n+    for (String serverName : MANAGED_SERVER_NAMES) {\n+      clusterConfig.addServerConfig(new WlsServerConfig(serverName, \"domain1-\" + serverName, 8001));\n+    }\n+    return new WlsDomainConfig(\"base_domain\")\n+            .withAdminServer(ADMIN, \"domain1-admin-server\", 7001)\n+            .withCluster(clusterConfig);\n+  }\n+\n+  private DomainPresenceInfo createDomainPresenceInfoWithServers(String... serverNames) {\n+    DomainPresenceInfo dpi = new DomainPresenceInfo(domain);\n+    addServer(dpi, ADMIN);\n+    Arrays.asList(serverNames).forEach(serverName -> addServer(dpi, serverName));\n+    return dpi;\n+  }\n+\n+  private Domain createDomain() {\n+    return new Domain()\n+            .withApiVersion(KubernetesConstants.DOMAIN_VERSION)\n+            .withKind(KubernetesConstants.DOMAIN)\n+            .withMetadata(new V1ObjectMeta().namespace(NS).name(DOMAIN_NAME).uid(KUBERNETES_UID))\n+            .withSpec(createDomainSpec());\n+  }\n+\n+  private DomainSpec createDomainSpec() {\n+    return new DomainSpec()\n+            .withDomainUid(UID)\n+            .withWebLogicCredentialsSecret(new V1SecretReference().name(CREDENTIALS_SECRET_NAME))\n+            .withIncludeServerOutInPodLog(INCLUDE_SERVER_OUT_IN_POD_LOG)\n+            .withImage(LATEST_IMAGE);\n+  }\n+\n+  private static void addServer(DomainPresenceInfo domainPresenceInfo, String serverName) {\n+    if (serverName.equals(ADMIN)) {\n+      domainPresenceInfo.setServerPod(serverName, createReadyPod(serverName));\n+    } else {\n+      domainPresenceInfo.setServerPod(serverName, createPod(serverName));\n+    }\n+  }\n+\n+  private static V1Pod createReadyPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName))\n+            .spec(new V1PodSpec().nodeName(\"Node1\"))\n+            .status(new V1PodStatus().phase(\"Running\")\n+            .addConditionsItem(new V1PodCondition().type(\"Ready\").status(\"True\")));\n+  }\n+\n+  private static V1Pod createPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName));\n+  }\n+\n+  private static V1ObjectMeta withNames(V1ObjectMeta objectMeta, String serverName) {\n+    return objectMeta\n+            .name(LegalNames.toPodName(UID, serverName))\n+            .putLabelsItem(LabelConstants.SERVERNAME_LABEL, serverName);\n+  }\n+\n+  /**\n+   * Setup env for tests.\n+   * @throws NoSuchFieldException if TestStepFactory fails to install\n+   */\n+  @Before\n+  public void setUp() throws NoSuchFieldException {\n+    mementos.add(TestUtils.silenceOperatorLogger().ignoringLoggedExceptions(ApiException.class));\n+    mementos.add(TuningParametersStub.install());\n+    mementos.add(testSupport.install());\n+\n+    testSupport.defineResources(domain);\n+    testSupport\n+            .addToPacket(ProcessingConstants.DOMAIN_TOPOLOGY, domainConfig)\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    testSupport.addComponent(\n+            ProcessingConstants.PODWATCHER_COMPONENT_NAME,\n+            PodAwaiterStepFactory.class,\n+            new PodHelperTestBase.DelayedPodAwaiterStepFactory(1));\n+\n+  }\n+\n+  /**\n+   * Cleanup env after tests.\n+   * @throws Exception if test support failed\n+   */\n+  @After\n+  public void tearDown() throws Exception {\n+    for (Memento memento : mementos) {\n+      memento.revert();\n+    }\n+\n+    testSupport.throwOnCompletionFailure();\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf1_bothClusteredServersShutdownSequentially() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(1);\n+    addWlsCluster(CLUSTER, 8001, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+    testSupport.setTime(10, TimeUnit.SECONDS);\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2_bothClusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(1);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf0_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withReplicaCountOf0AndConcurrencyOf1_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2AndReplicaCount1_3clusteredServersShutdownIn2Threads() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8597bca2836390659420e4603a74f6f363c45a82"}, "originalPosition": 250}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ3ODMzNQ==", "bodyText": "It's meant to test that 3rd clustered server is terminated only after one of the previous two servers is completely shutdown (since concurrency is 2). I'll change the name to  withConcurrencyOf2AndReplicaCount1_3rdClusteredServerIsShutdownAfterPreviousPodTerminated(). Please let me know if this is not clear or if you have any suggestions.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482478335", "createdAt": "2020-09-02T21:14:20Z", "author": {"login": "ankedia"}, "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "diffHunk": "@@ -0,0 +1,383 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.steps;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import javax.annotation.Nonnull;\n+\n+import com.meterware.simplestub.Memento;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodStatus;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.kubernetes.operator.KubernetesConstants;\n+import oracle.kubernetes.operator.LabelConstants;\n+import oracle.kubernetes.operator.PodAwaiterStepFactory;\n+import oracle.kubernetes.operator.ProcessingConstants;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo.ServerShutdownInfo;\n+import oracle.kubernetes.operator.helpers.KubernetesTestSupport;\n+import oracle.kubernetes.operator.helpers.LegalNames;\n+import oracle.kubernetes.operator.helpers.PodHelperTestBase;\n+import oracle.kubernetes.operator.helpers.TuningParametersStub;\n+import oracle.kubernetes.operator.utils.WlsDomainConfigSupport;\n+import oracle.kubernetes.operator.wlsconfig.WlsClusterConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsDomainConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsServerConfig;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.operator.work.TerminalStep;\n+import oracle.kubernetes.utils.TestUtils;\n+import oracle.kubernetes.weblogic.domain.ClusterConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfiguratorFactory;\n+import oracle.kubernetes.weblogic.domain.model.Domain;\n+import oracle.kubernetes.weblogic.domain.model.DomainSpec;\n+import org.hamcrest.junit.MatcherAssert;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.junit.MatcherAssert.assertThat;\n+\n+public class ServerDownIteratorStepTest {\n+\n+  protected static final String DOMAIN_NAME = \"domain1\";\n+  private static final String NS = \"namespace\";\n+  private static final String UID = \"uid1\";\n+  protected static final String KUBERNETES_UID = \"12345\";\n+  private static final String ADMIN = \"asName\";\n+  private static final String CLUSTER = \"cluster1\";\n+  private static final boolean INCLUDE_SERVER_OUT_IN_POD_LOG = true;\n+  private static final String CREDENTIALS_SECRET_NAME = \"webLogicCredentialsSecretName\";\n+  private static final String LATEST_IMAGE = \"image:latest\";\n+  private static final String MS_PREFIX = \"ms\";\n+  private static final String MS1 = MS_PREFIX + \"1\";\n+  private static final String MS2 = MS_PREFIX + \"2\";\n+  private static final String MS3 = MS_PREFIX + \"3\";\n+  private static final String MS4 = MS_PREFIX + \"4\";\n+  private static final int MAX_SERVERS = 5;\n+  private static final int PORT = 8001;\n+  private static final String[] MANAGED_SERVER_NAMES =\n+          IntStream.rangeClosed(1, MAX_SERVERS)\n+                  .mapToObj(ServerDownIteratorStepTest::getManagedServerName).toArray(String[]::new);\n+\n+  @Nonnull\n+  private static String getManagedServerName(int n) {\n+    return MS_PREFIX + n;\n+  }\n+\n+  private final Domain domain = createDomain();\n+  private final DomainConfigurator configurator = DomainConfiguratorFactory.forDomain(domain);\n+  private final WlsDomainConfigSupport configSupport = new WlsDomainConfigSupport(DOMAIN_NAME);\n+\n+  private final Step nextStep = new TerminalStep();\n+  private final KubernetesTestSupport testSupport = new KubernetesTestSupport();\n+  private final List<Memento> mementos = new ArrayList<>();\n+  private DomainPresenceInfo domainPresenceInfo = createDomainPresenceInfoWithServers();\n+  private final WlsDomainConfig domainConfig = createDomainConfig();\n+\n+  private static WlsDomainConfig createDomainConfig() {\n+    WlsClusterConfig clusterConfig = new WlsClusterConfig(CLUSTER);\n+    for (String serverName : MANAGED_SERVER_NAMES) {\n+      clusterConfig.addServerConfig(new WlsServerConfig(serverName, \"domain1-\" + serverName, 8001));\n+    }\n+    return new WlsDomainConfig(\"base_domain\")\n+            .withAdminServer(ADMIN, \"domain1-admin-server\", 7001)\n+            .withCluster(clusterConfig);\n+  }\n+\n+  private DomainPresenceInfo createDomainPresenceInfoWithServers(String... serverNames) {\n+    DomainPresenceInfo dpi = new DomainPresenceInfo(domain);\n+    addServer(dpi, ADMIN);\n+    Arrays.asList(serverNames).forEach(serverName -> addServer(dpi, serverName));\n+    return dpi;\n+  }\n+\n+  private Domain createDomain() {\n+    return new Domain()\n+            .withApiVersion(KubernetesConstants.DOMAIN_VERSION)\n+            .withKind(KubernetesConstants.DOMAIN)\n+            .withMetadata(new V1ObjectMeta().namespace(NS).name(DOMAIN_NAME).uid(KUBERNETES_UID))\n+            .withSpec(createDomainSpec());\n+  }\n+\n+  private DomainSpec createDomainSpec() {\n+    return new DomainSpec()\n+            .withDomainUid(UID)\n+            .withWebLogicCredentialsSecret(new V1SecretReference().name(CREDENTIALS_SECRET_NAME))\n+            .withIncludeServerOutInPodLog(INCLUDE_SERVER_OUT_IN_POD_LOG)\n+            .withImage(LATEST_IMAGE);\n+  }\n+\n+  private static void addServer(DomainPresenceInfo domainPresenceInfo, String serverName) {\n+    if (serverName.equals(ADMIN)) {\n+      domainPresenceInfo.setServerPod(serverName, createReadyPod(serverName));\n+    } else {\n+      domainPresenceInfo.setServerPod(serverName, createPod(serverName));\n+    }\n+  }\n+\n+  private static V1Pod createReadyPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName))\n+            .spec(new V1PodSpec().nodeName(\"Node1\"))\n+            .status(new V1PodStatus().phase(\"Running\")\n+            .addConditionsItem(new V1PodCondition().type(\"Ready\").status(\"True\")));\n+  }\n+\n+  private static V1Pod createPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName));\n+  }\n+\n+  private static V1ObjectMeta withNames(V1ObjectMeta objectMeta, String serverName) {\n+    return objectMeta\n+            .name(LegalNames.toPodName(UID, serverName))\n+            .putLabelsItem(LabelConstants.SERVERNAME_LABEL, serverName);\n+  }\n+\n+  /**\n+   * Setup env for tests.\n+   * @throws NoSuchFieldException if TestStepFactory fails to install\n+   */\n+  @Before\n+  public void setUp() throws NoSuchFieldException {\n+    mementos.add(TestUtils.silenceOperatorLogger().ignoringLoggedExceptions(ApiException.class));\n+    mementos.add(TuningParametersStub.install());\n+    mementos.add(testSupport.install());\n+\n+    testSupport.defineResources(domain);\n+    testSupport\n+            .addToPacket(ProcessingConstants.DOMAIN_TOPOLOGY, domainConfig)\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    testSupport.addComponent(\n+            ProcessingConstants.PODWATCHER_COMPONENT_NAME,\n+            PodAwaiterStepFactory.class,\n+            new PodHelperTestBase.DelayedPodAwaiterStepFactory(1));\n+\n+  }\n+\n+  /**\n+   * Cleanup env after tests.\n+   * @throws Exception if test support failed\n+   */\n+  @After\n+  public void tearDown() throws Exception {\n+    for (Memento memento : mementos) {\n+      memento.revert();\n+    }\n+\n+    testSupport.throwOnCompletionFailure();\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf1_bothClusteredServersShutdownSequentially() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(1);\n+    addWlsCluster(CLUSTER, 8001, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+    testSupport.setTime(10, TimeUnit.SECONDS);\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2_bothClusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(1);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf0_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withReplicaCountOf0AndConcurrencyOf1_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2AndReplicaCount1_3clusteredServersShutdownIn2Threads() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNTQ1Mw=="}, "originalCommit": {"oid": "8597bca2836390659420e4603a74f6f363c45a82"}, "originalPosition": 250}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk4MTA5NA==", "bodyText": "The problem with the name is that it doesn't really inform the reader of what is going on. The point, apparently, is that the concurrency setting limits the number of simultaneous servers shutting down. The replica count is only relevant in that you have reduced it.\nSo maybe something like, whenMaxConcurrentShutdownSet_limitNumberOfServersShuttingDownAtOnce", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482981094", "createdAt": "2020-09-03T13:33:44Z", "author": {"login": "russgold"}, "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "diffHunk": "@@ -0,0 +1,383 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.steps;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import javax.annotation.Nonnull;\n+\n+import com.meterware.simplestub.Memento;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodStatus;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.kubernetes.operator.KubernetesConstants;\n+import oracle.kubernetes.operator.LabelConstants;\n+import oracle.kubernetes.operator.PodAwaiterStepFactory;\n+import oracle.kubernetes.operator.ProcessingConstants;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo.ServerShutdownInfo;\n+import oracle.kubernetes.operator.helpers.KubernetesTestSupport;\n+import oracle.kubernetes.operator.helpers.LegalNames;\n+import oracle.kubernetes.operator.helpers.PodHelperTestBase;\n+import oracle.kubernetes.operator.helpers.TuningParametersStub;\n+import oracle.kubernetes.operator.utils.WlsDomainConfigSupport;\n+import oracle.kubernetes.operator.wlsconfig.WlsClusterConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsDomainConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsServerConfig;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.operator.work.TerminalStep;\n+import oracle.kubernetes.utils.TestUtils;\n+import oracle.kubernetes.weblogic.domain.ClusterConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfiguratorFactory;\n+import oracle.kubernetes.weblogic.domain.model.Domain;\n+import oracle.kubernetes.weblogic.domain.model.DomainSpec;\n+import org.hamcrest.junit.MatcherAssert;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.junit.MatcherAssert.assertThat;\n+\n+public class ServerDownIteratorStepTest {\n+\n+  protected static final String DOMAIN_NAME = \"domain1\";\n+  private static final String NS = \"namespace\";\n+  private static final String UID = \"uid1\";\n+  protected static final String KUBERNETES_UID = \"12345\";\n+  private static final String ADMIN = \"asName\";\n+  private static final String CLUSTER = \"cluster1\";\n+  private static final boolean INCLUDE_SERVER_OUT_IN_POD_LOG = true;\n+  private static final String CREDENTIALS_SECRET_NAME = \"webLogicCredentialsSecretName\";\n+  private static final String LATEST_IMAGE = \"image:latest\";\n+  private static final String MS_PREFIX = \"ms\";\n+  private static final String MS1 = MS_PREFIX + \"1\";\n+  private static final String MS2 = MS_PREFIX + \"2\";\n+  private static final String MS3 = MS_PREFIX + \"3\";\n+  private static final String MS4 = MS_PREFIX + \"4\";\n+  private static final int MAX_SERVERS = 5;\n+  private static final int PORT = 8001;\n+  private static final String[] MANAGED_SERVER_NAMES =\n+          IntStream.rangeClosed(1, MAX_SERVERS)\n+                  .mapToObj(ServerDownIteratorStepTest::getManagedServerName).toArray(String[]::new);\n+\n+  @Nonnull\n+  private static String getManagedServerName(int n) {\n+    return MS_PREFIX + n;\n+  }\n+\n+  private final Domain domain = createDomain();\n+  private final DomainConfigurator configurator = DomainConfiguratorFactory.forDomain(domain);\n+  private final WlsDomainConfigSupport configSupport = new WlsDomainConfigSupport(DOMAIN_NAME);\n+\n+  private final Step nextStep = new TerminalStep();\n+  private final KubernetesTestSupport testSupport = new KubernetesTestSupport();\n+  private final List<Memento> mementos = new ArrayList<>();\n+  private DomainPresenceInfo domainPresenceInfo = createDomainPresenceInfoWithServers();\n+  private final WlsDomainConfig domainConfig = createDomainConfig();\n+\n+  private static WlsDomainConfig createDomainConfig() {\n+    WlsClusterConfig clusterConfig = new WlsClusterConfig(CLUSTER);\n+    for (String serverName : MANAGED_SERVER_NAMES) {\n+      clusterConfig.addServerConfig(new WlsServerConfig(serverName, \"domain1-\" + serverName, 8001));\n+    }\n+    return new WlsDomainConfig(\"base_domain\")\n+            .withAdminServer(ADMIN, \"domain1-admin-server\", 7001)\n+            .withCluster(clusterConfig);\n+  }\n+\n+  private DomainPresenceInfo createDomainPresenceInfoWithServers(String... serverNames) {\n+    DomainPresenceInfo dpi = new DomainPresenceInfo(domain);\n+    addServer(dpi, ADMIN);\n+    Arrays.asList(serverNames).forEach(serverName -> addServer(dpi, serverName));\n+    return dpi;\n+  }\n+\n+  private Domain createDomain() {\n+    return new Domain()\n+            .withApiVersion(KubernetesConstants.DOMAIN_VERSION)\n+            .withKind(KubernetesConstants.DOMAIN)\n+            .withMetadata(new V1ObjectMeta().namespace(NS).name(DOMAIN_NAME).uid(KUBERNETES_UID))\n+            .withSpec(createDomainSpec());\n+  }\n+\n+  private DomainSpec createDomainSpec() {\n+    return new DomainSpec()\n+            .withDomainUid(UID)\n+            .withWebLogicCredentialsSecret(new V1SecretReference().name(CREDENTIALS_SECRET_NAME))\n+            .withIncludeServerOutInPodLog(INCLUDE_SERVER_OUT_IN_POD_LOG)\n+            .withImage(LATEST_IMAGE);\n+  }\n+\n+  private static void addServer(DomainPresenceInfo domainPresenceInfo, String serverName) {\n+    if (serverName.equals(ADMIN)) {\n+      domainPresenceInfo.setServerPod(serverName, createReadyPod(serverName));\n+    } else {\n+      domainPresenceInfo.setServerPod(serverName, createPod(serverName));\n+    }\n+  }\n+\n+  private static V1Pod createReadyPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName))\n+            .spec(new V1PodSpec().nodeName(\"Node1\"))\n+            .status(new V1PodStatus().phase(\"Running\")\n+            .addConditionsItem(new V1PodCondition().type(\"Ready\").status(\"True\")));\n+  }\n+\n+  private static V1Pod createPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName));\n+  }\n+\n+  private static V1ObjectMeta withNames(V1ObjectMeta objectMeta, String serverName) {\n+    return objectMeta\n+            .name(LegalNames.toPodName(UID, serverName))\n+            .putLabelsItem(LabelConstants.SERVERNAME_LABEL, serverName);\n+  }\n+\n+  /**\n+   * Setup env for tests.\n+   * @throws NoSuchFieldException if TestStepFactory fails to install\n+   */\n+  @Before\n+  public void setUp() throws NoSuchFieldException {\n+    mementos.add(TestUtils.silenceOperatorLogger().ignoringLoggedExceptions(ApiException.class));\n+    mementos.add(TuningParametersStub.install());\n+    mementos.add(testSupport.install());\n+\n+    testSupport.defineResources(domain);\n+    testSupport\n+            .addToPacket(ProcessingConstants.DOMAIN_TOPOLOGY, domainConfig)\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    testSupport.addComponent(\n+            ProcessingConstants.PODWATCHER_COMPONENT_NAME,\n+            PodAwaiterStepFactory.class,\n+            new PodHelperTestBase.DelayedPodAwaiterStepFactory(1));\n+\n+  }\n+\n+  /**\n+   * Cleanup env after tests.\n+   * @throws Exception if test support failed\n+   */\n+  @After\n+  public void tearDown() throws Exception {\n+    for (Memento memento : mementos) {\n+      memento.revert();\n+    }\n+\n+    testSupport.throwOnCompletionFailure();\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf1_bothClusteredServersShutdownSequentially() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(1);\n+    addWlsCluster(CLUSTER, 8001, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+    testSupport.setTime(10, TimeUnit.SECONDS);\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2_bothClusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(1);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf0_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withReplicaCountOf0AndConcurrencyOf1_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2AndReplicaCount1_3clusteredServersShutdownIn2Threads() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNTQ1Mw=="}, "originalCommit": {"oid": "8597bca2836390659420e4603a74f6f363c45a82"}, "originalPosition": 250}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDQ4NDMxOnYy", "diffSide": "RIGHT", "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNDozMjoxOVrOHLyDrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzozNjo0N1rOHMm8_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjUyNw==", "bodyText": "What is going on in this test? What is the significance of the concurrency of 2, here? The name doesn't explain.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482116527", "createdAt": "2020-09-02T14:32:19Z", "author": {"login": "russgold"}, "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "diffHunk": "@@ -0,0 +1,383 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.steps;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import javax.annotation.Nonnull;\n+\n+import com.meterware.simplestub.Memento;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodStatus;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.kubernetes.operator.KubernetesConstants;\n+import oracle.kubernetes.operator.LabelConstants;\n+import oracle.kubernetes.operator.PodAwaiterStepFactory;\n+import oracle.kubernetes.operator.ProcessingConstants;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo.ServerShutdownInfo;\n+import oracle.kubernetes.operator.helpers.KubernetesTestSupport;\n+import oracle.kubernetes.operator.helpers.LegalNames;\n+import oracle.kubernetes.operator.helpers.PodHelperTestBase;\n+import oracle.kubernetes.operator.helpers.TuningParametersStub;\n+import oracle.kubernetes.operator.utils.WlsDomainConfigSupport;\n+import oracle.kubernetes.operator.wlsconfig.WlsClusterConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsDomainConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsServerConfig;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.operator.work.TerminalStep;\n+import oracle.kubernetes.utils.TestUtils;\n+import oracle.kubernetes.weblogic.domain.ClusterConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfiguratorFactory;\n+import oracle.kubernetes.weblogic.domain.model.Domain;\n+import oracle.kubernetes.weblogic.domain.model.DomainSpec;\n+import org.hamcrest.junit.MatcherAssert;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.junit.MatcherAssert.assertThat;\n+\n+public class ServerDownIteratorStepTest {\n+\n+  protected static final String DOMAIN_NAME = \"domain1\";\n+  private static final String NS = \"namespace\";\n+  private static final String UID = \"uid1\";\n+  protected static final String KUBERNETES_UID = \"12345\";\n+  private static final String ADMIN = \"asName\";\n+  private static final String CLUSTER = \"cluster1\";\n+  private static final boolean INCLUDE_SERVER_OUT_IN_POD_LOG = true;\n+  private static final String CREDENTIALS_SECRET_NAME = \"webLogicCredentialsSecretName\";\n+  private static final String LATEST_IMAGE = \"image:latest\";\n+  private static final String MS_PREFIX = \"ms\";\n+  private static final String MS1 = MS_PREFIX + \"1\";\n+  private static final String MS2 = MS_PREFIX + \"2\";\n+  private static final String MS3 = MS_PREFIX + \"3\";\n+  private static final String MS4 = MS_PREFIX + \"4\";\n+  private static final int MAX_SERVERS = 5;\n+  private static final int PORT = 8001;\n+  private static final String[] MANAGED_SERVER_NAMES =\n+          IntStream.rangeClosed(1, MAX_SERVERS)\n+                  .mapToObj(ServerDownIteratorStepTest::getManagedServerName).toArray(String[]::new);\n+\n+  @Nonnull\n+  private static String getManagedServerName(int n) {\n+    return MS_PREFIX + n;\n+  }\n+\n+  private final Domain domain = createDomain();\n+  private final DomainConfigurator configurator = DomainConfiguratorFactory.forDomain(domain);\n+  private final WlsDomainConfigSupport configSupport = new WlsDomainConfigSupport(DOMAIN_NAME);\n+\n+  private final Step nextStep = new TerminalStep();\n+  private final KubernetesTestSupport testSupport = new KubernetesTestSupport();\n+  private final List<Memento> mementos = new ArrayList<>();\n+  private DomainPresenceInfo domainPresenceInfo = createDomainPresenceInfoWithServers();\n+  private final WlsDomainConfig domainConfig = createDomainConfig();\n+\n+  private static WlsDomainConfig createDomainConfig() {\n+    WlsClusterConfig clusterConfig = new WlsClusterConfig(CLUSTER);\n+    for (String serverName : MANAGED_SERVER_NAMES) {\n+      clusterConfig.addServerConfig(new WlsServerConfig(serverName, \"domain1-\" + serverName, 8001));\n+    }\n+    return new WlsDomainConfig(\"base_domain\")\n+            .withAdminServer(ADMIN, \"domain1-admin-server\", 7001)\n+            .withCluster(clusterConfig);\n+  }\n+\n+  private DomainPresenceInfo createDomainPresenceInfoWithServers(String... serverNames) {\n+    DomainPresenceInfo dpi = new DomainPresenceInfo(domain);\n+    addServer(dpi, ADMIN);\n+    Arrays.asList(serverNames).forEach(serverName -> addServer(dpi, serverName));\n+    return dpi;\n+  }\n+\n+  private Domain createDomain() {\n+    return new Domain()\n+            .withApiVersion(KubernetesConstants.DOMAIN_VERSION)\n+            .withKind(KubernetesConstants.DOMAIN)\n+            .withMetadata(new V1ObjectMeta().namespace(NS).name(DOMAIN_NAME).uid(KUBERNETES_UID))\n+            .withSpec(createDomainSpec());\n+  }\n+\n+  private DomainSpec createDomainSpec() {\n+    return new DomainSpec()\n+            .withDomainUid(UID)\n+            .withWebLogicCredentialsSecret(new V1SecretReference().name(CREDENTIALS_SECRET_NAME))\n+            .withIncludeServerOutInPodLog(INCLUDE_SERVER_OUT_IN_POD_LOG)\n+            .withImage(LATEST_IMAGE);\n+  }\n+\n+  private static void addServer(DomainPresenceInfo domainPresenceInfo, String serverName) {\n+    if (serverName.equals(ADMIN)) {\n+      domainPresenceInfo.setServerPod(serverName, createReadyPod(serverName));\n+    } else {\n+      domainPresenceInfo.setServerPod(serverName, createPod(serverName));\n+    }\n+  }\n+\n+  private static V1Pod createReadyPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName))\n+            .spec(new V1PodSpec().nodeName(\"Node1\"))\n+            .status(new V1PodStatus().phase(\"Running\")\n+            .addConditionsItem(new V1PodCondition().type(\"Ready\").status(\"True\")));\n+  }\n+\n+  private static V1Pod createPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName));\n+  }\n+\n+  private static V1ObjectMeta withNames(V1ObjectMeta objectMeta, String serverName) {\n+    return objectMeta\n+            .name(LegalNames.toPodName(UID, serverName))\n+            .putLabelsItem(LabelConstants.SERVERNAME_LABEL, serverName);\n+  }\n+\n+  /**\n+   * Setup env for tests.\n+   * @throws NoSuchFieldException if TestStepFactory fails to install\n+   */\n+  @Before\n+  public void setUp() throws NoSuchFieldException {\n+    mementos.add(TestUtils.silenceOperatorLogger().ignoringLoggedExceptions(ApiException.class));\n+    mementos.add(TuningParametersStub.install());\n+    mementos.add(testSupport.install());\n+\n+    testSupport.defineResources(domain);\n+    testSupport\n+            .addToPacket(ProcessingConstants.DOMAIN_TOPOLOGY, domainConfig)\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    testSupport.addComponent(\n+            ProcessingConstants.PODWATCHER_COMPONENT_NAME,\n+            PodAwaiterStepFactory.class,\n+            new PodHelperTestBase.DelayedPodAwaiterStepFactory(1));\n+\n+  }\n+\n+  /**\n+   * Cleanup env after tests.\n+   * @throws Exception if test support failed\n+   */\n+  @After\n+  public void tearDown() throws Exception {\n+    for (Memento memento : mementos) {\n+      memento.revert();\n+    }\n+\n+    testSupport.throwOnCompletionFailure();\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf1_bothClusteredServersShutdownSequentially() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(1);\n+    addWlsCluster(CLUSTER, 8001, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+    testSupport.setTime(10, TimeUnit.SECONDS);\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2_bothClusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(1);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf0_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withReplicaCountOf0AndConcurrencyOf1_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2AndReplicaCount1_3clusteredServersShutdownIn2Threads() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(1);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2, MS3, MS4);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2,MS3,MS4);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    assertThat(MS2 + \" pod\", domainPresenceInfo.getServerPod(MS2), notNullValue());\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER, MS1, MS2, MS3, MS4));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS4), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS3), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.FALSE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+    testSupport.setTime(10, TimeUnit.SECONDS);\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2AndReplicaCount0_4clusteredServersShutdownConcurrently() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8597bca2836390659420e4603a74f6f363c45a82"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ3NDMyOQ==", "bodyText": "This test is similar to withReplicaCountOf0AndConcurrencyOf1_clusteredServersShutdownConcurrently(). When replica count is set to 0, it indicates that the administrator isn't concerned about preserving replicated/volatile state, there's no need to shutdown one-at-a-time. We ignore the concurrency value in when replica count is set to 0.  This test has 4 servers and concurrency value is set to 2 (as opposed to 2 servers and concurrency of 1 in withReplicaCountOf0AndConcurrencyOf1_clusteredServersShutdownConcurrently()).", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482474329", "createdAt": "2020-09-02T21:09:51Z", "author": {"login": "ankedia"}, "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "diffHunk": "@@ -0,0 +1,383 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.steps;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import javax.annotation.Nonnull;\n+\n+import com.meterware.simplestub.Memento;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodStatus;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.kubernetes.operator.KubernetesConstants;\n+import oracle.kubernetes.operator.LabelConstants;\n+import oracle.kubernetes.operator.PodAwaiterStepFactory;\n+import oracle.kubernetes.operator.ProcessingConstants;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo.ServerShutdownInfo;\n+import oracle.kubernetes.operator.helpers.KubernetesTestSupport;\n+import oracle.kubernetes.operator.helpers.LegalNames;\n+import oracle.kubernetes.operator.helpers.PodHelperTestBase;\n+import oracle.kubernetes.operator.helpers.TuningParametersStub;\n+import oracle.kubernetes.operator.utils.WlsDomainConfigSupport;\n+import oracle.kubernetes.operator.wlsconfig.WlsClusterConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsDomainConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsServerConfig;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.operator.work.TerminalStep;\n+import oracle.kubernetes.utils.TestUtils;\n+import oracle.kubernetes.weblogic.domain.ClusterConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfiguratorFactory;\n+import oracle.kubernetes.weblogic.domain.model.Domain;\n+import oracle.kubernetes.weblogic.domain.model.DomainSpec;\n+import org.hamcrest.junit.MatcherAssert;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.junit.MatcherAssert.assertThat;\n+\n+public class ServerDownIteratorStepTest {\n+\n+  protected static final String DOMAIN_NAME = \"domain1\";\n+  private static final String NS = \"namespace\";\n+  private static final String UID = \"uid1\";\n+  protected static final String KUBERNETES_UID = \"12345\";\n+  private static final String ADMIN = \"asName\";\n+  private static final String CLUSTER = \"cluster1\";\n+  private static final boolean INCLUDE_SERVER_OUT_IN_POD_LOG = true;\n+  private static final String CREDENTIALS_SECRET_NAME = \"webLogicCredentialsSecretName\";\n+  private static final String LATEST_IMAGE = \"image:latest\";\n+  private static final String MS_PREFIX = \"ms\";\n+  private static final String MS1 = MS_PREFIX + \"1\";\n+  private static final String MS2 = MS_PREFIX + \"2\";\n+  private static final String MS3 = MS_PREFIX + \"3\";\n+  private static final String MS4 = MS_PREFIX + \"4\";\n+  private static final int MAX_SERVERS = 5;\n+  private static final int PORT = 8001;\n+  private static final String[] MANAGED_SERVER_NAMES =\n+          IntStream.rangeClosed(1, MAX_SERVERS)\n+                  .mapToObj(ServerDownIteratorStepTest::getManagedServerName).toArray(String[]::new);\n+\n+  @Nonnull\n+  private static String getManagedServerName(int n) {\n+    return MS_PREFIX + n;\n+  }\n+\n+  private final Domain domain = createDomain();\n+  private final DomainConfigurator configurator = DomainConfiguratorFactory.forDomain(domain);\n+  private final WlsDomainConfigSupport configSupport = new WlsDomainConfigSupport(DOMAIN_NAME);\n+\n+  private final Step nextStep = new TerminalStep();\n+  private final KubernetesTestSupport testSupport = new KubernetesTestSupport();\n+  private final List<Memento> mementos = new ArrayList<>();\n+  private DomainPresenceInfo domainPresenceInfo = createDomainPresenceInfoWithServers();\n+  private final WlsDomainConfig domainConfig = createDomainConfig();\n+\n+  private static WlsDomainConfig createDomainConfig() {\n+    WlsClusterConfig clusterConfig = new WlsClusterConfig(CLUSTER);\n+    for (String serverName : MANAGED_SERVER_NAMES) {\n+      clusterConfig.addServerConfig(new WlsServerConfig(serverName, \"domain1-\" + serverName, 8001));\n+    }\n+    return new WlsDomainConfig(\"base_domain\")\n+            .withAdminServer(ADMIN, \"domain1-admin-server\", 7001)\n+            .withCluster(clusterConfig);\n+  }\n+\n+  private DomainPresenceInfo createDomainPresenceInfoWithServers(String... serverNames) {\n+    DomainPresenceInfo dpi = new DomainPresenceInfo(domain);\n+    addServer(dpi, ADMIN);\n+    Arrays.asList(serverNames).forEach(serverName -> addServer(dpi, serverName));\n+    return dpi;\n+  }\n+\n+  private Domain createDomain() {\n+    return new Domain()\n+            .withApiVersion(KubernetesConstants.DOMAIN_VERSION)\n+            .withKind(KubernetesConstants.DOMAIN)\n+            .withMetadata(new V1ObjectMeta().namespace(NS).name(DOMAIN_NAME).uid(KUBERNETES_UID))\n+            .withSpec(createDomainSpec());\n+  }\n+\n+  private DomainSpec createDomainSpec() {\n+    return new DomainSpec()\n+            .withDomainUid(UID)\n+            .withWebLogicCredentialsSecret(new V1SecretReference().name(CREDENTIALS_SECRET_NAME))\n+            .withIncludeServerOutInPodLog(INCLUDE_SERVER_OUT_IN_POD_LOG)\n+            .withImage(LATEST_IMAGE);\n+  }\n+\n+  private static void addServer(DomainPresenceInfo domainPresenceInfo, String serverName) {\n+    if (serverName.equals(ADMIN)) {\n+      domainPresenceInfo.setServerPod(serverName, createReadyPod(serverName));\n+    } else {\n+      domainPresenceInfo.setServerPod(serverName, createPod(serverName));\n+    }\n+  }\n+\n+  private static V1Pod createReadyPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName))\n+            .spec(new V1PodSpec().nodeName(\"Node1\"))\n+            .status(new V1PodStatus().phase(\"Running\")\n+            .addConditionsItem(new V1PodCondition().type(\"Ready\").status(\"True\")));\n+  }\n+\n+  private static V1Pod createPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName));\n+  }\n+\n+  private static V1ObjectMeta withNames(V1ObjectMeta objectMeta, String serverName) {\n+    return objectMeta\n+            .name(LegalNames.toPodName(UID, serverName))\n+            .putLabelsItem(LabelConstants.SERVERNAME_LABEL, serverName);\n+  }\n+\n+  /**\n+   * Setup env for tests.\n+   * @throws NoSuchFieldException if TestStepFactory fails to install\n+   */\n+  @Before\n+  public void setUp() throws NoSuchFieldException {\n+    mementos.add(TestUtils.silenceOperatorLogger().ignoringLoggedExceptions(ApiException.class));\n+    mementos.add(TuningParametersStub.install());\n+    mementos.add(testSupport.install());\n+\n+    testSupport.defineResources(domain);\n+    testSupport\n+            .addToPacket(ProcessingConstants.DOMAIN_TOPOLOGY, domainConfig)\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    testSupport.addComponent(\n+            ProcessingConstants.PODWATCHER_COMPONENT_NAME,\n+            PodAwaiterStepFactory.class,\n+            new PodHelperTestBase.DelayedPodAwaiterStepFactory(1));\n+\n+  }\n+\n+  /**\n+   * Cleanup env after tests.\n+   * @throws Exception if test support failed\n+   */\n+  @After\n+  public void tearDown() throws Exception {\n+    for (Memento memento : mementos) {\n+      memento.revert();\n+    }\n+\n+    testSupport.throwOnCompletionFailure();\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf1_bothClusteredServersShutdownSequentially() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(1);\n+    addWlsCluster(CLUSTER, 8001, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+    testSupport.setTime(10, TimeUnit.SECONDS);\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2_bothClusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(1);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf0_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withReplicaCountOf0AndConcurrencyOf1_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2AndReplicaCount1_3clusteredServersShutdownIn2Threads() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(1);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2, MS3, MS4);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2,MS3,MS4);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    assertThat(MS2 + \" pod\", domainPresenceInfo.getServerPod(MS2), notNullValue());\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER, MS1, MS2, MS3, MS4));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS4), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS3), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.FALSE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+    testSupport.setTime(10, TimeUnit.SECONDS);\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2AndReplicaCount0_4clusteredServersShutdownConcurrently() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjUyNw=="}, "originalCommit": {"oid": "8597bca2836390659420e4603a74f6f363c45a82"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk4MzE2Ng==", "bodyText": "So it tests the same thing, only with multiple clusters? Use more or less the same wording suggested above, then, only indicate multiple clusters. I'm not sure how much this adds. Was any additional code needed to make this pass that wasn't needed for the other test?\nOTOH, it might be interesting to prove that you can shut down one cluster without pay attention to concurrency limits while simultaneously shrinking another cluster and have that one pay attention to those limits.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482983166", "createdAt": "2020-09-03T13:36:47Z", "author": {"login": "russgold"}, "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "diffHunk": "@@ -0,0 +1,383 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.steps;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import javax.annotation.Nonnull;\n+\n+import com.meterware.simplestub.Memento;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodStatus;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.kubernetes.operator.KubernetesConstants;\n+import oracle.kubernetes.operator.LabelConstants;\n+import oracle.kubernetes.operator.PodAwaiterStepFactory;\n+import oracle.kubernetes.operator.ProcessingConstants;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo.ServerShutdownInfo;\n+import oracle.kubernetes.operator.helpers.KubernetesTestSupport;\n+import oracle.kubernetes.operator.helpers.LegalNames;\n+import oracle.kubernetes.operator.helpers.PodHelperTestBase;\n+import oracle.kubernetes.operator.helpers.TuningParametersStub;\n+import oracle.kubernetes.operator.utils.WlsDomainConfigSupport;\n+import oracle.kubernetes.operator.wlsconfig.WlsClusterConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsDomainConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsServerConfig;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.operator.work.TerminalStep;\n+import oracle.kubernetes.utils.TestUtils;\n+import oracle.kubernetes.weblogic.domain.ClusterConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfiguratorFactory;\n+import oracle.kubernetes.weblogic.domain.model.Domain;\n+import oracle.kubernetes.weblogic.domain.model.DomainSpec;\n+import org.hamcrest.junit.MatcherAssert;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.junit.MatcherAssert.assertThat;\n+\n+public class ServerDownIteratorStepTest {\n+\n+  protected static final String DOMAIN_NAME = \"domain1\";\n+  private static final String NS = \"namespace\";\n+  private static final String UID = \"uid1\";\n+  protected static final String KUBERNETES_UID = \"12345\";\n+  private static final String ADMIN = \"asName\";\n+  private static final String CLUSTER = \"cluster1\";\n+  private static final boolean INCLUDE_SERVER_OUT_IN_POD_LOG = true;\n+  private static final String CREDENTIALS_SECRET_NAME = \"webLogicCredentialsSecretName\";\n+  private static final String LATEST_IMAGE = \"image:latest\";\n+  private static final String MS_PREFIX = \"ms\";\n+  private static final String MS1 = MS_PREFIX + \"1\";\n+  private static final String MS2 = MS_PREFIX + \"2\";\n+  private static final String MS3 = MS_PREFIX + \"3\";\n+  private static final String MS4 = MS_PREFIX + \"4\";\n+  private static final int MAX_SERVERS = 5;\n+  private static final int PORT = 8001;\n+  private static final String[] MANAGED_SERVER_NAMES =\n+          IntStream.rangeClosed(1, MAX_SERVERS)\n+                  .mapToObj(ServerDownIteratorStepTest::getManagedServerName).toArray(String[]::new);\n+\n+  @Nonnull\n+  private static String getManagedServerName(int n) {\n+    return MS_PREFIX + n;\n+  }\n+\n+  private final Domain domain = createDomain();\n+  private final DomainConfigurator configurator = DomainConfiguratorFactory.forDomain(domain);\n+  private final WlsDomainConfigSupport configSupport = new WlsDomainConfigSupport(DOMAIN_NAME);\n+\n+  private final Step nextStep = new TerminalStep();\n+  private final KubernetesTestSupport testSupport = new KubernetesTestSupport();\n+  private final List<Memento> mementos = new ArrayList<>();\n+  private DomainPresenceInfo domainPresenceInfo = createDomainPresenceInfoWithServers();\n+  private final WlsDomainConfig domainConfig = createDomainConfig();\n+\n+  private static WlsDomainConfig createDomainConfig() {\n+    WlsClusterConfig clusterConfig = new WlsClusterConfig(CLUSTER);\n+    for (String serverName : MANAGED_SERVER_NAMES) {\n+      clusterConfig.addServerConfig(new WlsServerConfig(serverName, \"domain1-\" + serverName, 8001));\n+    }\n+    return new WlsDomainConfig(\"base_domain\")\n+            .withAdminServer(ADMIN, \"domain1-admin-server\", 7001)\n+            .withCluster(clusterConfig);\n+  }\n+\n+  private DomainPresenceInfo createDomainPresenceInfoWithServers(String... serverNames) {\n+    DomainPresenceInfo dpi = new DomainPresenceInfo(domain);\n+    addServer(dpi, ADMIN);\n+    Arrays.asList(serverNames).forEach(serverName -> addServer(dpi, serverName));\n+    return dpi;\n+  }\n+\n+  private Domain createDomain() {\n+    return new Domain()\n+            .withApiVersion(KubernetesConstants.DOMAIN_VERSION)\n+            .withKind(KubernetesConstants.DOMAIN)\n+            .withMetadata(new V1ObjectMeta().namespace(NS).name(DOMAIN_NAME).uid(KUBERNETES_UID))\n+            .withSpec(createDomainSpec());\n+  }\n+\n+  private DomainSpec createDomainSpec() {\n+    return new DomainSpec()\n+            .withDomainUid(UID)\n+            .withWebLogicCredentialsSecret(new V1SecretReference().name(CREDENTIALS_SECRET_NAME))\n+            .withIncludeServerOutInPodLog(INCLUDE_SERVER_OUT_IN_POD_LOG)\n+            .withImage(LATEST_IMAGE);\n+  }\n+\n+  private static void addServer(DomainPresenceInfo domainPresenceInfo, String serverName) {\n+    if (serverName.equals(ADMIN)) {\n+      domainPresenceInfo.setServerPod(serverName, createReadyPod(serverName));\n+    } else {\n+      domainPresenceInfo.setServerPod(serverName, createPod(serverName));\n+    }\n+  }\n+\n+  private static V1Pod createReadyPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName))\n+            .spec(new V1PodSpec().nodeName(\"Node1\"))\n+            .status(new V1PodStatus().phase(\"Running\")\n+            .addConditionsItem(new V1PodCondition().type(\"Ready\").status(\"True\")));\n+  }\n+\n+  private static V1Pod createPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName));\n+  }\n+\n+  private static V1ObjectMeta withNames(V1ObjectMeta objectMeta, String serverName) {\n+    return objectMeta\n+            .name(LegalNames.toPodName(UID, serverName))\n+            .putLabelsItem(LabelConstants.SERVERNAME_LABEL, serverName);\n+  }\n+\n+  /**\n+   * Setup env for tests.\n+   * @throws NoSuchFieldException if TestStepFactory fails to install\n+   */\n+  @Before\n+  public void setUp() throws NoSuchFieldException {\n+    mementos.add(TestUtils.silenceOperatorLogger().ignoringLoggedExceptions(ApiException.class));\n+    mementos.add(TuningParametersStub.install());\n+    mementos.add(testSupport.install());\n+\n+    testSupport.defineResources(domain);\n+    testSupport\n+            .addToPacket(ProcessingConstants.DOMAIN_TOPOLOGY, domainConfig)\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    testSupport.addComponent(\n+            ProcessingConstants.PODWATCHER_COMPONENT_NAME,\n+            PodAwaiterStepFactory.class,\n+            new PodHelperTestBase.DelayedPodAwaiterStepFactory(1));\n+\n+  }\n+\n+  /**\n+   * Cleanup env after tests.\n+   * @throws Exception if test support failed\n+   */\n+  @After\n+  public void tearDown() throws Exception {\n+    for (Memento memento : mementos) {\n+      memento.revert();\n+    }\n+\n+    testSupport.throwOnCompletionFailure();\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf1_bothClusteredServersShutdownSequentially() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(1);\n+    addWlsCluster(CLUSTER, 8001, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+    testSupport.setTime(10, TimeUnit.SECONDS);\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2_bothClusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(1);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf0_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withReplicaCountOf0AndConcurrencyOf1_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2AndReplicaCount1_3clusteredServersShutdownIn2Threads() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(1);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2, MS3, MS4);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2,MS3,MS4);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    assertThat(MS2 + \" pod\", domainPresenceInfo.getServerPod(MS2), notNullValue());\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER, MS1, MS2, MS3, MS4));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS4), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS3), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.FALSE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+    testSupport.setTime(10, TimeUnit.SECONDS);\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2AndReplicaCount0_4clusteredServersShutdownConcurrently() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjUyNw=="}, "originalCommit": {"oid": "8597bca2836390659420e4603a74f6f363c45a82"}, "originalPosition": 275}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDUzOTkyOnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/CallBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNDo0NDoxNFrOHLynOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNDo0NDoxNFrOHLynOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEyNTYyNA==", "bodyText": "The ability to add a custom retry strategy seems pretty general and you seem to be adding a fair bit of code to make it work only for the deletePod case. A better pattern, I think, would be to add a withRetryStrategy method to CallBuilder, analogous to withFieldSelector and withLabelSelectors and pass it along in that fashion. That way it could be used in other cases. At least look at how difficult that would be to do.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482125624", "createdAt": "2020-09-02T14:44:14Z", "author": {"login": "russgold"}, "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/CallBuilder.java", "diffHunk": "@@ -1183,6 +1184,29 @@ public Step deletePodAsync(\n         responseStep, new RequestParams(\"deletePod\", namespace, name, deleteOptions, domainUid), deletePod);\n   }\n \n+  /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8597bca2836390659420e4603a74f6f363c45a82"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNTQ0NDAxOnYy", "diffSide": "RIGHT", "path": "docs/domains/Domain.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxODoxODoyNFrOHL7lzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwMToxNToyMFrOHMRu2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI3MjcxOA==", "bodyText": "How about:\nThe default maximum WebLogic Server instances that a cluster will shutdown in parallel when it is being partially shutdown by lowering its replica count. You can override this default on a per cluster basis by setting the cluster's maxConcurrentShutdown attribute. A value of 0 means there is no limit. Defaults to 1.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482272718", "createdAt": "2020-09-02T18:18:24Z", "author": {"login": "tbarnes-us"}, "path": "docs/domains/Domain.json", "diffHunk": "@@ -354,6 +359,11 @@\n           \"type\": \"number\",\n           \"minimum\": 0\n         },\n+        \"maxClusterConcurrentShutdown\": {\n+          \"description\": \"The maximum number of cluster member Managed Server instances that the operator will shutdown in parallel for a given cluster, if `maxConcurrentShutdown` is not specified for a specific cluster under the `clusters` field. A value of 0 means there is no configured limit. Defaults to 1.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8597bca2836390659420e4603a74f6f363c45a82"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYzNTQ4MQ==", "bodyText": "I have made changes in DomainSpec.java to use above wordings. Please let me know if I missed something. Thanks.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482635481", "createdAt": "2020-09-03T01:15:20Z", "author": {"login": "ankedia"}, "path": "docs/domains/Domain.json", "diffHunk": "@@ -354,6 +359,11 @@\n           \"type\": \"number\",\n           \"minimum\": 0\n         },\n+        \"maxClusterConcurrentShutdown\": {\n+          \"description\": \"The maximum number of cluster member Managed Server instances that the operator will shutdown in parallel for a given cluster, if `maxConcurrentShutdown` is not specified for a specific cluster under the `clusters` field. A value of 0 means there is no configured limit. Defaults to 1.\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI3MjcxOA=="}, "originalCommit": {"oid": "8597bca2836390659420e4603a74f6f363c45a82"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNTQ3MzU3OnYy", "diffSide": "RIGHT", "path": "docs/domains/Domain.json", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxODoyMzozN1rOHL74uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwMToxMTozOFrOHMRqyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI3NzU2Mw==", "bodyText": "How about:\nThe maximum WebLogic Server instances that will shutdown in parallel for this cluster when it is being partially shutdown by lowering its replica count. A value of 0 means there is no limit. Defaults to spec.maxClusterConcurrentShutdown (which in turn defaults to 1).", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482277563", "createdAt": "2020-09-02T18:23:37Z", "author": {"login": "tbarnes-us"}, "path": "docs/domains/Domain.json", "diffHunk": "@@ -117,6 +117,11 @@\n           \"description\": \"Customization affecting Kubernetes Service generated for this WebLogic cluster.\",\n           \"$ref\": \"#/definitions/KubernetesResource\"\n         },\n+        \"maxConcurrentShutdown\": {\n+          \"description\": \"The maximum number of Managed Servers instances that the operator will shutdown in parallel for this cluster in response to a change in the `replicas` count. If more Managed Server instances must be shutdown, the operator will wait until a Managed Server Pod is terminated before shutting down the next Managed Server instance. A value of 0 means all Managed Server instances will shutdown in parallel. Defaults to 1.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8597bca2836390659420e4603a74f6f363c45a82"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ1NzI2OA==", "bodyText": "You know these are generated, right? The best place to comment is Cluster.java.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482457268", "createdAt": "2020-09-02T20:56:39Z", "author": {"login": "russgold"}, "path": "docs/domains/Domain.json", "diffHunk": "@@ -117,6 +117,11 @@\n           \"description\": \"Customization affecting Kubernetes Service generated for this WebLogic cluster.\",\n           \"$ref\": \"#/definitions/KubernetesResource\"\n         },\n+        \"maxConcurrentShutdown\": {\n+          \"description\": \"The maximum number of Managed Servers instances that the operator will shutdown in parallel for this cluster in response to a change in the `replicas` count. If more Managed Server instances must be shutdown, the operator will wait until a Managed Server Pod is terminated before shutting down the next Managed Server instance. A value of 0 means all Managed Server instances will shutdown in parallel. Defaults to 1.\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI3NzU2Mw=="}, "originalCommit": {"oid": "8597bca2836390659420e4603a74f6f363c45a82"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjUyNDgxOA==", "bodyText": "Yah yah - I was being lazy - you caught me.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482524818", "createdAt": "2020-09-02T22:11:07Z", "author": {"login": "tbarnes-us"}, "path": "docs/domains/Domain.json", "diffHunk": "@@ -117,6 +117,11 @@\n           \"description\": \"Customization affecting Kubernetes Service generated for this WebLogic cluster.\",\n           \"$ref\": \"#/definitions/KubernetesResource\"\n         },\n+        \"maxConcurrentShutdown\": {\n+          \"description\": \"The maximum number of Managed Servers instances that the operator will shutdown in parallel for this cluster in response to a change in the `replicas` count. If more Managed Server instances must be shutdown, the operator will wait until a Managed Server Pod is terminated before shutting down the next Managed Server instance. A value of 0 means all Managed Server instances will shutdown in parallel. Defaults to 1.\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI3NzU2Mw=="}, "originalCommit": {"oid": "8597bca2836390659420e4603a74f6f363c45a82"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYzNDQ0Mw==", "bodyText": "I have made changes in Cluster.java to use above wordings. Please let me know if I missed something. Thanks.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482634443", "createdAt": "2020-09-03T01:11:38Z", "author": {"login": "ankedia"}, "path": "docs/domains/Domain.json", "diffHunk": "@@ -117,6 +117,11 @@\n           \"description\": \"Customization affecting Kubernetes Service generated for this WebLogic cluster.\",\n           \"$ref\": \"#/definitions/KubernetesResource\"\n         },\n+        \"maxConcurrentShutdown\": {\n+          \"description\": \"The maximum number of Managed Servers instances that the operator will shutdown in parallel for this cluster in response to a change in the `replicas` count. If more Managed Server instances must be shutdown, the operator will wait until a Managed Server Pod is terminated before shutting down the next Managed Server instance. A value of 0 means all Managed Server instances will shutdown in parallel. Defaults to 1.\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI3NzU2Mw=="}, "originalCommit": {"oid": "8597bca2836390659420e4603a74f6f363c45a82"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTg4ODgxOnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/weblogic/domain/model/DomainSpec.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzo0Nzo1OFrOHMncBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOToyODo0NFrOHM0ljg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk5MTExMA==", "bodyText": "A simpler way to do this would be:\nreturn Optional.ofNullable(cluster).map(Cluster::getMaxConcurrentShutdown).orElse(getMaxClusterConcurrentShutdown());\n\nwhere getMaxClusterConcurrentShutdown()", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482991110", "createdAt": "2020-09-03T13:47:58Z", "author": {"login": "russgold"}, "path": "operator/src/main/java/oracle/kubernetes/weblogic/domain/model/DomainSpec.java", "diffHunk": "@@ -958,6 +975,20 @@ public void setMaxClusterConcurrentStartup(Integer maxClusterConcurrentStartup)\n     this.maxClusterConcurrentStartup = maxClusterConcurrentStartup;\n   }\n \n+  private int getMaxConcurrentShutdownFor(Cluster cluster) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6fdd72d13cf7f40920b50b636fd5a8f3b1538cd"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNTI0NA==", "bodyText": "Fixed.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r483205244", "createdAt": "2020-09-03T19:26:01Z", "author": {"login": "ankedia"}, "path": "operator/src/main/java/oracle/kubernetes/weblogic/domain/model/DomainSpec.java", "diffHunk": "@@ -958,6 +975,20 @@ public void setMaxClusterConcurrentStartup(Integer maxClusterConcurrentStartup)\n     this.maxClusterConcurrentStartup = maxClusterConcurrentStartup;\n   }\n \n+  private int getMaxConcurrentShutdownFor(Cluster cluster) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk5MTExMA=="}, "originalCommit": {"oid": "b6fdd72d13cf7f40920b50b636fd5a8f3b1538cd"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNjU0Mg==", "bodyText": "Fixed.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r483206542", "createdAt": "2020-09-03T19:28:44Z", "author": {"login": "ankedia"}, "path": "operator/src/main/java/oracle/kubernetes/weblogic/domain/model/DomainSpec.java", "diffHunk": "@@ -958,6 +975,20 @@ public void setMaxClusterConcurrentStartup(Integer maxClusterConcurrentStartup)\n     this.maxClusterConcurrentStartup = maxClusterConcurrentStartup;\n   }\n \n+  private int getMaxConcurrentShutdownFor(Cluster cluster) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk5MTExMA=="}, "originalCommit": {"oid": "b6fdd72d13cf7f40920b50b636fd5a8f3b1538cd"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTkwMDQ3OnYy", "diffSide": "RIGHT", "path": "operator/src/test/java/oracle/kubernetes/weblogic/domain/DomainTestBase.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzo1MDozMlrOHMnjRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOToyODo1OFrOHM0l5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk5Mjk2Ng==", "bodyText": "This line should not be needed. The point is that the cluster is not configured.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482992966", "createdAt": "2020-09-03T13:50:32Z", "author": {"login": "russgold"}, "path": "operator/src/test/java/oracle/kubernetes/weblogic/domain/DomainTestBase.java", "diffHunk": "@@ -400,6 +401,46 @@ public void whenBothClusterAndDomainSpecified_maxConcurrentStartupFromCluster()\n         equalTo(1));\n   }\n \n+  @Test\n+  public void afterMaxConcurrentShutdownSetForCluster_canReadIt() {\n+    configureCluster(\"cluster1\").withMaxConcurrentShutdown(3);\n+\n+    assertThat(domain.getMaxConcurrentShutdown(\"cluster1\"), equalTo(3));\n+  }\n+\n+  @Test\n+  public void whenNotSpecified_maxConcurrentShutdownHasDefault() {\n+    configureCluster(\"cluster1\");\n+    configureDomain(domain).withMaxConcurrentShutdown(null);\n+\n+    assertThat(domain.getMaxConcurrentShutdown(\"cluster1\"),\n+            equalTo(DEFAULT_MAX_CLUSTER_CONCURRENT_SHUTDOWN));\n+  }\n+\n+  @Test\n+  public void whenNotSpecified_maxConcurrentShutdownFromDomain() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6fdd72d13cf7f40920b50b636fd5a8f3b1538cd"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNTM3MA==", "bodyText": "Fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r483205370", "createdAt": "2020-09-03T19:26:17Z", "author": {"login": "ankedia"}, "path": "operator/src/test/java/oracle/kubernetes/weblogic/domain/DomainTestBase.java", "diffHunk": "@@ -400,6 +401,46 @@ public void whenBothClusterAndDomainSpecified_maxConcurrentStartupFromCluster()\n         equalTo(1));\n   }\n \n+  @Test\n+  public void afterMaxConcurrentShutdownSetForCluster_canReadIt() {\n+    configureCluster(\"cluster1\").withMaxConcurrentShutdown(3);\n+\n+    assertThat(domain.getMaxConcurrentShutdown(\"cluster1\"), equalTo(3));\n+  }\n+\n+  @Test\n+  public void whenNotSpecified_maxConcurrentShutdownHasDefault() {\n+    configureCluster(\"cluster1\");\n+    configureDomain(domain).withMaxConcurrentShutdown(null);\n+\n+    assertThat(domain.getMaxConcurrentShutdown(\"cluster1\"),\n+            equalTo(DEFAULT_MAX_CLUSTER_CONCURRENT_SHUTDOWN));\n+  }\n+\n+  @Test\n+  public void whenNotSpecified_maxConcurrentShutdownFromDomain() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk5Mjk2Ng=="}, "originalCommit": {"oid": "b6fdd72d13cf7f40920b50b636fd5a8f3b1538cd"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNjYzMQ==", "bodyText": "Fixed.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r483206631", "createdAt": "2020-09-03T19:28:58Z", "author": {"login": "ankedia"}, "path": "operator/src/test/java/oracle/kubernetes/weblogic/domain/DomainTestBase.java", "diffHunk": "@@ -400,6 +401,46 @@ public void whenBothClusterAndDomainSpecified_maxConcurrentStartupFromCluster()\n         equalTo(1));\n   }\n \n+  @Test\n+  public void afterMaxConcurrentShutdownSetForCluster_canReadIt() {\n+    configureCluster(\"cluster1\").withMaxConcurrentShutdown(3);\n+\n+    assertThat(domain.getMaxConcurrentShutdown(\"cluster1\"), equalTo(3));\n+  }\n+\n+  @Test\n+  public void whenNotSpecified_maxConcurrentShutdownHasDefault() {\n+    configureCluster(\"cluster1\");\n+    configureDomain(domain).withMaxConcurrentShutdown(null);\n+\n+    assertThat(domain.getMaxConcurrentShutdown(\"cluster1\"),\n+            equalTo(DEFAULT_MAX_CLUSTER_CONCURRENT_SHUTDOWN));\n+  }\n+\n+  @Test\n+  public void whenNotSpecified_maxConcurrentShutdownFromDomain() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk5Mjk2Ng=="}, "originalCommit": {"oid": "b6fdd72d13cf7f40920b50b636fd5a8f3b1538cd"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNDkzMjM5OnYy", "diffSide": "RIGHT", "path": "docs/domains/Domain.json", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxODowNDo1N1rOHNXVog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxODowNDo1N1rOHNXVog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc3NTkwNg==", "bodyText": "@rosemarymarano, can you please also review this description? Thanks. A couple of proposed edits on this description... 1. \"The maximum\" -> \"The maximum number of\". 2. \"shutdown\" -> \"shut down\". As a verb, it's \"shut down\", while \"shutdown\" is a noun. 3. \"count.A value\" -> \"count. A value\" (add space) 4. \" (which in turn defaults to 1)\" -> \", which defaults to 1\".", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r483775906", "createdAt": "2020-09-04T18:04:57Z", "author": {"login": "rjeberhard"}, "path": "docs/domains/Domain.json", "diffHunk": "@@ -117,6 +117,11 @@\n           \"description\": \"Customization affecting Kubernetes Service generated for this WebLogic cluster.\",\n           \"$ref\": \"#/definitions/KubernetesResource\"\n         },\n+        \"maxConcurrentShutdown\": {\n+          \"description\": \"The maximum WebLogic Server instances that will shutdown in parallel for this cluster when it is being partially shutdown by lowering its replica count.A value of 0 means there is no limit. Defaults to `spec.maxClusterConcurrentShutdown` (which in turn defaults to 1).\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "147e5dd66aaba6663c4862a47f9734b1b2753123"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNDk1MjUwOnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/weblogic/domain/model/DomainSpec.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxODoxMjowMVrOHNXhvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxODoxMjowMVrOHNXhvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc3OTAwNg==", "bodyText": "Surprisingly, this text is slightly different. \"The default maximum number of \". \"shutdown\" -> \"shut down\". \"attribute\" -> \"field\". \"Defaults to 1.\" (add period).", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r483779006", "createdAt": "2020-09-04T18:12:01Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/weblogic/domain/model/DomainSpec.java", "diffHunk": "@@ -208,6 +209,15 @@\n   @Range(minimum = 0)\n   private Integer maxClusterConcurrentStartup;\n \n+  @Description(\n+          \"The default maximum WebLogic Server instances that a cluster will shutdown in parallel when it is being \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "147e5dd66aaba6663c4862a47f9734b1b2753123"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNDk1NzM2OnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/weblogic/domain/model/DomainSpec.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxODoxMzo0OFrOHNXkmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxODoxMzo0OFrOHNXkmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc3OTczOQ==", "bodyText": "Missing change to toString()", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r483779739", "createdAt": "2020-09-04T18:13:48Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/weblogic/domain/model/DomainSpec.java", "diffHunk": "@@ -886,7 +902,8 @@ public boolean equals(Object other) {\n             .append(configOverrides, rhs.configOverrides)\n             .append(configOverrideSecrets, rhs.configOverrideSecrets)\n             .append(isAllowReplicasBelowMinDynClusterSize(), rhs.isAllowReplicasBelowMinDynClusterSize())\n-            .append(getMaxClusterConcurrentStartup(), rhs.getMaxClusterConcurrentStartup());\n+            .append(getMaxClusterConcurrentStartup(), rhs.getMaxClusterConcurrentStartup())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "147e5dd66aaba6663c4862a47f9734b1b2753123"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNDk1ODgwOnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/weblogic/domain/model/Cluster.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxODoxNDoyMVrOHNXlhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxODoxNDoyMVrOHNXlhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc3OTk3Mg==", "bodyText": "Missing change to toString()", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r483779972", "createdAt": "2020-09-04T18:14:21Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/weblogic/domain/model/Cluster.java", "diffHunk": "@@ -224,6 +241,7 @@ public boolean equals(Object o) {\n         .append(maxUnavailable, cluster.maxUnavailable)\n         .append(allowReplicasBelowMinDynClusterSize, cluster.allowReplicasBelowMinDynClusterSize)\n         .append(maxConcurrentStartup, cluster.maxConcurrentStartup)\n+        .append(maxConcurrentShutdown, cluster.maxConcurrentShutdown)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "147e5dd66aaba6663c4862a47f9734b1b2753123"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNDk2MzYwOnYy", "diffSide": "RIGHT", "path": "docs/domains/Domain.json", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxODoxNTo1NFrOHNXoPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxODoxNTo1NFrOHNXoPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc4MDY3MQ==", "bodyText": "I agree with all the edits you proposed.\nThe maximum WebLogic Server instances -> The maximum number of WebLogic Server instances\nshutdown  -> shut down (globally, shut down (v), shutdown (n) )\nSpace needed after count.\nwhich in turn defaults to 1 -> which defaults to 1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r483780671", "createdAt": "2020-09-04T18:15:54Z", "author": {"login": "rosemarymarano"}, "path": "docs/domains/Domain.json", "diffHunk": "@@ -117,6 +117,11 @@\n           \"description\": \"Customization affecting Kubernetes Service generated for this WebLogic cluster.\",\n           \"$ref\": \"#/definitions/KubernetesResource\"\n         },\n+        \"maxConcurrentShutdown\": {\n+          \"description\": \"The maximum WebLogic Server instances that will shutdown in parallel for this cluster when it is being partially shutdown by lowering its replica count.A value of 0 means there is no limit. Defaults to `spec.maxClusterConcurrentShutdown` (which in turn defaults to 1).\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "147e5dd66aaba6663c4862a47f9734b1b2753123"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNDk3MjU4OnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/weblogic/domain/model/Cluster.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxODoxOTozM1rOHNXtzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxODoxOTozM1rOHNXtzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc4MjA5Mw==", "bodyText": "\"The maximum number of WebLogic\". \"shutdown\" -> \"shut down\". \"count. \" (add space). Add a comma after \"spec.maxClusterConcurrentShutdown\" and then change \"(which in turn defaults to 1).\" to \"which defaults to 1.\"", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r483782093", "createdAt": "2020-09-04T18:19:33Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/weblogic/domain/model/Cluster.java", "diffHunk": "@@ -88,6 +88,15 @@\n   @Range(minimum = 0)\n   private Integer maxConcurrentStartup;\n \n+  @Description(\n+          \"The maximum WebLogic Server instances that will shutdown in parallel \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "147e5dd66aaba6663c4862a47f9734b1b2753123"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNDk4MDE3OnYy", "diffSide": "RIGHT", "path": "docs/domains/Domain.json", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxODoyMjoxMFrOHNXyWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxODoyMjoxMFrOHNXyWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc4MzI1Nw==", "bodyText": "The default maximum WebLogic Server instances -> The default maximum number of WebLogic Server instances\nshutdown -> shut down\nDefaults to 1\", -> Defaults to 1.\",", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r483783257", "createdAt": "2020-09-04T18:22:10Z", "author": {"login": "rosemarymarano"}, "path": "docs/domains/Domain.json", "diffHunk": "@@ -354,6 +359,11 @@\n           \"type\": \"number\",\n           \"minimum\": 0\n         },\n+        \"maxClusterConcurrentShutdown\": {\n+          \"description\": \"The default maximum WebLogic Server instances that a cluster will shutdown in parallel when it is being partially shutdown by lowering its replica count. You can override this default on a per cluster basis by setting the cluster\\u0027s `maxConcurrentShutdown` attribute. A value of 0 means there is no limit. Defaults to 1\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "147e5dd66aaba6663c4862a47f9734b1b2753123"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNDk4NTYxOnYy", "diffSide": "RIGHT", "path": "docs/domains/Domain.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxODoyNDozMlrOHNX15g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxODoyNDozMlrOHNX15g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc4NDE2Ng==", "bodyText": "default maximum WebLogic Server instances -> default maximum number of WebLogic Server instances\nshutdown -> shut down (globally)\nDefaults to 1-> Defaults to 1.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r483784166", "createdAt": "2020-09-04T18:24:32Z", "author": {"login": "rosemarymarano"}, "path": "docs/domains/Domain.md", "diffHunk": "@@ -34,6 +34,7 @@ The specification of the operation of the WebLogic domain. Required.\n | `logHome` | string | The directory in a server's container in which to store the domain, Node Manager, server logs, server *.out, introspector .out, and optionally HTTP access log files if `httpAccessLogInLogHome` is true. Ignored if `logHomeEnabled` is false. |\n | `logHomeEnabled` | Boolean | Specifies whether the log home folder is enabled. Defaults to true if `domainHomeSourceType` is PersistentVolume; false, otherwise. |\n | `managedServers` | array of [Managed Server](#managed-server) | Lifecycle options for individual Managed Servers, including Java options, environment variables, additional Pod content, and the ability to explicitly start, stop, or restart a named server instance. The `serverName` field of each entry must match a Managed Server that already exists in the WebLogic domain configuration or that matches a dynamic cluster member based on the server template. |\n+| `maxClusterConcurrentShutdown` | number | The default maximum WebLogic Server instances that a cluster will shutdown in parallel when it is being partially shutdown by lowering its replica count. You can override this default on a per cluster basis by setting the cluster's `maxConcurrentShutdown` attribute. A value of 0 means there is no limit. Defaults to 1 |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "147e5dd66aaba6663c4862a47f9734b1b2753123"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNDk5MjY2OnYy", "diffSide": "RIGHT", "path": "docs/domains/Domain.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxODoyNzowNlrOHNX6PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxODoyNzowNlrOHNX6PQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc4NTI3Nw==", "bodyText": "The maximum WebLogic Server instances -> The maximum number of WebLogic Server instances\nshutdown -> shut down (globally, shut down (v), shutdown (n) )\nSpace needed after count.\nwhich in turn defaults to 1 -> which defaults to 1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r483785277", "createdAt": "2020-09-04T18:27:06Z", "author": {"login": "rosemarymarano"}, "path": "docs/domains/Domain.md", "diffHunk": "@@ -75,6 +76,7 @@ The current status of the operation of the WebLogic domain. Updated automaticall\n | `allowReplicasBelowMinDynClusterSize` | Boolean | Specifies whether the number of running cluster members is allowed to drop below the minimum dynamic cluster size configured in the WebLogic domain configuration. Otherwise, the operator will ensure that the number of running cluster members is not less than the minimum dynamic cluster setting. This setting applies to dynamic clusters only. Defaults to true. |\n | `clusterName` | string | The name of the cluster. This value must match the name of a WebLogic cluster already defined in the WebLogic domain configuration. Required. |\n | `clusterService` | [Kubernetes Resource](#kubernetes-resource) | Customization affecting Kubernetes Service generated for this WebLogic cluster. |\n+| `maxConcurrentShutdown` | number | The maximum WebLogic Server instances that will shutdown in parallel for this cluster when it is being partially shutdown by lowering its replica count.A value of 0 means there is no limit. Defaults to `spec.maxClusterConcurrentShutdown` (which in turn defaults to 1). |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "147e5dd66aaba6663c4862a47f9734b1b2753123"}, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3916, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}