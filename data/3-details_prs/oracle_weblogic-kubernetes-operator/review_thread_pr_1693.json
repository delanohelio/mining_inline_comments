{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1Mzg3OTE1", "number": 1693, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwMzo1ODo1NFrOEBJ0Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwNDowNjowNVrOEBJ1OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NjQ0ODY3OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwMzo1ODo1NFrOGc2kDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNjo0NzowMVrOGd6vPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwNzI3OA==", "bodyText": "Can we add a TestConstant for APPDIR instead of \"../src/\"", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1693#discussion_r432907278", "createdAt": "2020-05-31T03:58:54Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -306,6 +334,47 @@ public void testDomainInPvUsingWlst() {\n       return adminNodePortAccessible(serviceNodePort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n     }, \"Access to admin server node port failed\");\n     assertTrue(loginSuccessful, \"Console login validation failed\");\n+\n+    logger.info(\"Getting node port for T3 channel\");\n+    int t3channelNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(wlstDomainNamespace, adminServerPodName + \"-external\", \"t3channel\"),\n+        \"Getting admin server t3channel node port failed\");\n+    assertNotEquals(-1, t3ChannelPort, \"admin server t3channelport is not valid\");\n+\n+    //create ingress controller\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domainUid, wlstDomainNamespace);\n+    createIngressForDomainAndVerify(domainUid, wlstDomainNamespace, clusterNameMsPortMap);\n+\n+    //deploy application\n+    Path archivePath = Paths.get(ITTESTS_DIR, \"../src/integration-tests/apps/testwebapp.war\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "846eb57b3ea476e8a0642cb09bbc527606e92985"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ3MDU4OA==", "bodyText": "We already have a APP_DIR which is pointing to \"user.dir\" + /src/test/resources/apps\nIf I had to use that constant it will look like\nPaths.get(APP_DIR, \"../../../../../../src/integration-tests/apps/testwebapp.war\");", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1693#discussion_r433470588", "createdAt": "2020-06-01T20:27:03Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -306,6 +334,47 @@ public void testDomainInPvUsingWlst() {\n       return adminNodePortAccessible(serviceNodePort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n     }, \"Access to admin server node port failed\");\n     assertTrue(loginSuccessful, \"Console login validation failed\");\n+\n+    logger.info(\"Getting node port for T3 channel\");\n+    int t3channelNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(wlstDomainNamespace, adminServerPodName + \"-external\", \"t3channel\"),\n+        \"Getting admin server t3channel node port failed\");\n+    assertNotEquals(-1, t3ChannelPort, \"admin server t3channelport is not valid\");\n+\n+    //create ingress controller\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domainUid, wlstDomainNamespace);\n+    createIngressForDomainAndVerify(domainUid, wlstDomainNamespace, clusterNameMsPortMap);\n+\n+    //deploy application\n+    Path archivePath = Paths.get(ITTESTS_DIR, \"../src/integration-tests/apps/testwebapp.war\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwNzI3OA=="}, "originalCommit": {"oid": "846eb57b3ea476e8a0642cb09bbc527606e92985"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAyNDI1Mg==", "bodyText": "discussed this with Pani, agreed on no changes needed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1693#discussion_r434024252", "createdAt": "2020-06-02T16:47:01Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -306,6 +334,47 @@ public void testDomainInPvUsingWlst() {\n       return adminNodePortAccessible(serviceNodePort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n     }, \"Access to admin server node port failed\");\n     assertTrue(loginSuccessful, \"Console login validation failed\");\n+\n+    logger.info(\"Getting node port for T3 channel\");\n+    int t3channelNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(wlstDomainNamespace, adminServerPodName + \"-external\", \"t3channel\"),\n+        \"Getting admin server t3channel node port failed\");\n+    assertNotEquals(-1, t3ChannelPort, \"admin server t3channelport is not valid\");\n+\n+    //create ingress controller\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domainUid, wlstDomainNamespace);\n+    createIngressForDomainAndVerify(domainUid, wlstDomainNamespace, clusterNameMsPortMap);\n+\n+    //deploy application\n+    Path archivePath = Paths.get(ITTESTS_DIR, \"../src/integration-tests/apps/testwebapp.war\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwNzI3OA=="}, "originalCommit": {"oid": "846eb57b3ea476e8a0642cb09bbc527606e92985"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NjQ1MTEyOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DeployUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwNDowNjowNVrOGc2lUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNjo0Njo0MFrOGd6uYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwNzYwMg==", "bodyText": "Can u change modify the name of function to be specific instead of generic deploy()  e.g. deployUsingWlst()", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1693#discussion_r432907602", "createdAt": "2020-05-31T04:06:05Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DeployUtil.java", "diffHunk": "@@ -0,0 +1,265 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Utility class to deploy application to WebLogic server.\n+ */\n+public class DeployUtil {\n+\n+  private static String image;\n+  private static boolean isUseSecret;\n+  private static final String MOUNT_POINT = \"/deployScripts/\";\n+  private static final String DEPLOY_SCRIPT = \"application_deployment.py\";\n+  private static final String DOMAIN_PROPERTIES = \"domain.properties\";\n+\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Deploy application.\n+   *\n+   * @param host name of the admin server host\n+   * @param port default channel node port of admin server\n+   * @param userName admin server user name\n+   * @param password admin server password\n+   * @param targets comma separated list of targets to deploy applications\n+   * @param archivePath local path of the application archive\n+   * @param namespace name of the namespace in which WebLogic server pods running\n+   */\n+  public static void deployApplication(String host, String port, String userName,\n+      String password, String targets, Path archivePath, String namespace) {\n+\n+    setImage(namespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = assertDoesNotThrow(() -> File.createTempFile(\"domain\", \"properties\"),\n+        \"Creating domain properties file failed\");\n+    Properties p = new Properties();\n+    p.setProperty(\"node_archive_path\", MOUNT_POINT + archivePath.getFileName());\n+    p.setProperty(\"admin_host\", host);\n+    p.setProperty(\"admin_port\", port);\n+    p.setProperty(\"admin_username\", userName);\n+    p.setProperty(\"admin_password\", password);\n+    p.setProperty(\"targets\", targets);\n+    assertDoesNotThrow(() -> p.store(new FileOutputStream(domainPropertiesFile), \"wlst properties file\"),\n+        \"Failed to write the domain properties to file\");\n+\n+    // WLST py script for deploying application\n+    Path deployScript = Paths.get(RESOURCE_DIR, \"python-scripts\", DEPLOY_SCRIPT);\n+\n+    logger.info(\"Creating a config map to hold deployment files\");\n+    String deployScriptConfigMapName = \"create-deploy-scripts-cm\";\n+\n+    Map<String, String> data = new HashMap<>();\n+    Map<String, byte[]> binaryData = new HashMap<>();\n+    assertDoesNotThrow(() -> {\n+      data.put(DEPLOY_SCRIPT, Files.readString(deployScript));\n+      data.put(DOMAIN_PROPERTIES, Files.readString(domainPropertiesFile.toPath()));\n+      binaryData.put(archivePath.getFileName().toString(),\n+          Base64.getMimeEncoder().encode(Files.readAllBytes(archivePath)));\n+    });\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .name(deployScriptConfigMapName)\n+        .namespace(namespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .binaryData(binaryData)\n+        .metadata(meta);\n+\n+    assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Failed to create configmap %s with files\", configMap));\n+\n+    // deploy application with deploy scripts and domain properties on persistent volume\n+    deploy(namespace, deployScriptConfigMapName);\n+  }\n+\n+  /**\n+   * Deploy application by creating a job.\n+   *\n+   * @param namespace namespace in which to create job\n+   * @param deployScriptConfigMapName configmap containing deployment scripts\n+   */\n+  private static void deploy(String namespace, String deployScriptConfigMapName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "846eb57b3ea476e8a0642cb09bbc527606e92985"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAyNDAzMg==", "bodyText": "changed the method name", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1693#discussion_r434024032", "createdAt": "2020-06-02T16:46:40Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DeployUtil.java", "diffHunk": "@@ -0,0 +1,265 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Utility class to deploy application to WebLogic server.\n+ */\n+public class DeployUtil {\n+\n+  private static String image;\n+  private static boolean isUseSecret;\n+  private static final String MOUNT_POINT = \"/deployScripts/\";\n+  private static final String DEPLOY_SCRIPT = \"application_deployment.py\";\n+  private static final String DOMAIN_PROPERTIES = \"domain.properties\";\n+\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Deploy application.\n+   *\n+   * @param host name of the admin server host\n+   * @param port default channel node port of admin server\n+   * @param userName admin server user name\n+   * @param password admin server password\n+   * @param targets comma separated list of targets to deploy applications\n+   * @param archivePath local path of the application archive\n+   * @param namespace name of the namespace in which WebLogic server pods running\n+   */\n+  public static void deployApplication(String host, String port, String userName,\n+      String password, String targets, Path archivePath, String namespace) {\n+\n+    setImage(namespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = assertDoesNotThrow(() -> File.createTempFile(\"domain\", \"properties\"),\n+        \"Creating domain properties file failed\");\n+    Properties p = new Properties();\n+    p.setProperty(\"node_archive_path\", MOUNT_POINT + archivePath.getFileName());\n+    p.setProperty(\"admin_host\", host);\n+    p.setProperty(\"admin_port\", port);\n+    p.setProperty(\"admin_username\", userName);\n+    p.setProperty(\"admin_password\", password);\n+    p.setProperty(\"targets\", targets);\n+    assertDoesNotThrow(() -> p.store(new FileOutputStream(domainPropertiesFile), \"wlst properties file\"),\n+        \"Failed to write the domain properties to file\");\n+\n+    // WLST py script for deploying application\n+    Path deployScript = Paths.get(RESOURCE_DIR, \"python-scripts\", DEPLOY_SCRIPT);\n+\n+    logger.info(\"Creating a config map to hold deployment files\");\n+    String deployScriptConfigMapName = \"create-deploy-scripts-cm\";\n+\n+    Map<String, String> data = new HashMap<>();\n+    Map<String, byte[]> binaryData = new HashMap<>();\n+    assertDoesNotThrow(() -> {\n+      data.put(DEPLOY_SCRIPT, Files.readString(deployScript));\n+      data.put(DOMAIN_PROPERTIES, Files.readString(domainPropertiesFile.toPath()));\n+      binaryData.put(archivePath.getFileName().toString(),\n+          Base64.getMimeEncoder().encode(Files.readAllBytes(archivePath)));\n+    });\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .name(deployScriptConfigMapName)\n+        .namespace(namespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .binaryData(binaryData)\n+        .metadata(meta);\n+\n+    assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Failed to create configmap %s with files\", configMap));\n+\n+    // deploy application with deploy scripts and domain properties on persistent volume\n+    deploy(namespace, deployScriptConfigMapName);\n+  }\n+\n+  /**\n+   * Deploy application by creating a job.\n+   *\n+   * @param namespace namespace in which to create job\n+   * @param deployScriptConfigMapName configmap containing deployment scripts\n+   */\n+  private static void deploy(String namespace, String deployScriptConfigMapName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwNzYwMg=="}, "originalCommit": {"oid": "846eb57b3ea476e8a0642cb09bbc527606e92985"}, "originalPosition": 141}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4282, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}