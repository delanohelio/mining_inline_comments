{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2OTg1NDU1", "number": 1643, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMjowNDoyOVrOD712zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNzoxMToxMVrOD9e5_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDc0OTU4OnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/operator/ProcessingConstants.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMjowNDoyOVrOGUanEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwMDoyMDowOFrOGVH6OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2MDY4OA==", "bodyText": "Very small thing ;)... This constant must be many places.  Do we need another? I bet it's available on the HTTP client classes.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r424060688", "createdAt": "2020-05-12T22:04:29Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/ProcessingConstants.java", "diffHunk": "@@ -34,4 +34,8 @@\n   public static final String DOMAIN_INTROSPECT_VERSION = \"weblogic.domainIntrospectVersion\";\n   public static final String DOMAIN_INPUTS_HASH = \"weblogic.domainInputsHash\";\n   public static final String REMAINING_SERVERS_HEALTH_TO_READ = \"serverHealthRead\";\n+  \n+  public static final String KEY = \"encodedCredentials\";\n+  public static final String RESULT = \"httpResult\";\n+  public static final int HTTP_OK = 200;  ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f946f7ed845d48269b098e19f05c21460842b113"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgwMjg3Mw==", "bodyText": "Fixed, Using HTTP_OK constant from HttpURLConnection class. Thanks.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r424802873", "createdAt": "2020-05-14T00:20:08Z", "author": {"login": "ankedia"}, "path": "operator/src/main/java/oracle/kubernetes/operator/ProcessingConstants.java", "diffHunk": "@@ -34,4 +34,8 @@\n   public static final String DOMAIN_INTROSPECT_VERSION = \"weblogic.domainIntrospectVersion\";\n   public static final String DOMAIN_INPUTS_HASH = \"weblogic.domainInputsHash\";\n   public static final String REMAINING_SERVERS_HEALTH_TO_READ = \"serverHealthRead\";\n+  \n+  public static final String KEY = \"encodedCredentials\";\n+  public static final String RESULT = \"httpResult\";\n+  public static final int HTTP_OK = 200;  ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2MDY4OA=="}, "originalCommit": {"oid": "f946f7ed845d48269b098e19f05c21460842b113"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDc1MTM1OnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/HttpClientFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMjowNTowNVrOGUaoIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMzo0NToyNFrOGUcwIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2MDk2Mw==", "bodyText": "New file... \"2018, 2020,\" -> \"2020,\"", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r424060963", "createdAt": "2020-05-12T22:05:05Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/HttpClientFactory.java", "diffHunk": "@@ -0,0 +1,9 @@\n+// Copyright (c) 2018, 2020, Oracle Corporation and/or its affiliates.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f946f7ed845d48269b098e19f05c21460842b113"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5NTc3OQ==", "bodyText": "Fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r424095779", "createdAt": "2020-05-12T23:45:24Z", "author": {"login": "ankedia"}, "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/HttpClientFactory.java", "diffHunk": "@@ -0,0 +1,9 @@\n+// Copyright (c) 2018, 2020, Oracle Corporation and/or its affiliates.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2MDk2Mw=="}, "originalCommit": {"oid": "f946f7ed845d48269b098e19f05c21460842b113"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDc2MzkzOnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/HttpClientPool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMjoxMDowOVrOGUawFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMzo0NTozOFrOGUcwhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2Mjk5OA==", "bodyText": "Same... new file.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r424062998", "createdAt": "2020-05-12T22:10:09Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/HttpClientPool.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) 2017, 2020, Oracle Corporation and/or its affiliates.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f946f7ed845d48269b098e19f05c21460842b113"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5NTg3Ng==", "bodyText": "Fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r424095876", "createdAt": "2020-05-12T23:45:38Z", "author": {"login": "ankedia"}, "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/HttpClientPool.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) 2017, 2020, Oracle Corporation and/or its affiliates.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2Mjk5OA=="}, "originalCommit": {"oid": "f946f7ed845d48269b098e19f05c21460842b113"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDc2Njc4OnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/HttpClientPool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMjoxMTowNlrOGUaxzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMzo0NTo1NVrOGUcw2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2MzQzOQ==", "bodyText": "This is copy/paste from K8s master logic... Not needed here.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r424063439", "createdAt": "2020-05-12T22:11:06Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/HttpClientPool.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) 2017, 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.helpers;\n+\n+import java.net.http.HttpClient;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import oracle.kubernetes.operator.logging.LoggingFacade;\n+import oracle.kubernetes.operator.logging.LoggingFactory;\n+import oracle.kubernetes.operator.logging.MessageKeys;\n+import oracle.kubernetes.operator.work.Container;\n+import oracle.kubernetes.operator.work.ContainerResolver;\n+\n+public class HttpClientPool extends Pool<HttpClient> {\n+  private static final LoggingFacade LOGGER = LoggingFactory.getLogger(\"Operator\", \"Operator\");\n+  private static final HttpClientFactory FACTORY = new DefaultClientFactory();\n+  private static HttpClientPool SINGLETON = new HttpClientPool();\n+  private static ThreadFactory threadFactory;\n+  private final AtomicBoolean isFirst = new AtomicBoolean(true);\n+\n+  // HttpClient instance that will be shared\n+  private final AtomicReference<HttpClient> instance = new AtomicReference<>();\n+\n+  public static void initialize(ThreadFactory threadFactory) {\n+    HttpClientPool.threadFactory = threadFactory;\n+  }\n+\n+  private static Runnable wrapRunnable(Runnable r) {\n+    return new Runnable() {\n+      @Override\n+      public void run() {\n+        try {\n+          r.run();\n+        } catch (Throwable t) {\n+          // These will almost always be spurious exceptions\n+          LOGGER.finer(MessageKeys.EXCEPTION, t);\n+        }\n+      }\n+    };\n+  }\n+\n+  public static HttpClientPool getInstance() {\n+    return SINGLETON;\n+  }\n+\n+  @Override\n+  protected HttpClient create() {\n+    return instance.updateAndGet(\n+        prev -> {\n+          return prev != null ? prev : getHttpClient();\n+        });\n+  }\n+\n+  private HttpClient getHttpClient() {\n+    LOGGER.entering();\n+\n+    HttpClient httpClient = null;\n+    try {\n+      HttpClientFactory factory = null;\n+      Container c = ContainerResolver.getInstance().getContainer();\n+      if (c != null) {\n+        factory = c.getSpi(HttpClientFactory.class);\n+      }\n+      if (factory == null) {\n+        factory = FACTORY;\n+      }\n+\n+      httpClient = factory.get();\n+    } catch (Throwable e) {\n+      LOGGER.warning(MessageKeys.EXCEPTION, e);\n+    }\n+\n+    if (isFirst.compareAndSet(true, false)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f946f7ed845d48269b098e19f05c21460842b113"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5NTk2Mg==", "bodyText": "Fixed. Thanks.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r424095962", "createdAt": "2020-05-12T23:45:55Z", "author": {"login": "ankedia"}, "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/HttpClientPool.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) 2017, 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.helpers;\n+\n+import java.net.http.HttpClient;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import oracle.kubernetes.operator.logging.LoggingFacade;\n+import oracle.kubernetes.operator.logging.LoggingFactory;\n+import oracle.kubernetes.operator.logging.MessageKeys;\n+import oracle.kubernetes.operator.work.Container;\n+import oracle.kubernetes.operator.work.ContainerResolver;\n+\n+public class HttpClientPool extends Pool<HttpClient> {\n+  private static final LoggingFacade LOGGER = LoggingFactory.getLogger(\"Operator\", \"Operator\");\n+  private static final HttpClientFactory FACTORY = new DefaultClientFactory();\n+  private static HttpClientPool SINGLETON = new HttpClientPool();\n+  private static ThreadFactory threadFactory;\n+  private final AtomicBoolean isFirst = new AtomicBoolean(true);\n+\n+  // HttpClient instance that will be shared\n+  private final AtomicReference<HttpClient> instance = new AtomicReference<>();\n+\n+  public static void initialize(ThreadFactory threadFactory) {\n+    HttpClientPool.threadFactory = threadFactory;\n+  }\n+\n+  private static Runnable wrapRunnable(Runnable r) {\n+    return new Runnable() {\n+      @Override\n+      public void run() {\n+        try {\n+          r.run();\n+        } catch (Throwable t) {\n+          // These will almost always be spurious exceptions\n+          LOGGER.finer(MessageKeys.EXCEPTION, t);\n+        }\n+      }\n+    };\n+  }\n+\n+  public static HttpClientPool getInstance() {\n+    return SINGLETON;\n+  }\n+\n+  @Override\n+  protected HttpClient create() {\n+    return instance.updateAndGet(\n+        prev -> {\n+          return prev != null ? prev : getHttpClient();\n+        });\n+  }\n+\n+  private HttpClient getHttpClient() {\n+    LOGGER.entering();\n+\n+    HttpClient httpClient = null;\n+    try {\n+      HttpClientFactory factory = null;\n+      Container c = ContainerResolver.getInstance().getContainer();\n+      if (c != null) {\n+        factory = c.getSpi(HttpClientFactory.class);\n+      }\n+      if (factory == null) {\n+        factory = FACTORY;\n+      }\n+\n+      httpClient = factory.get();\n+    } catch (Throwable e) {\n+      LOGGER.warning(MessageKeys.EXCEPTION, e);\n+    }\n+\n+    if (isFirst.compareAndSet(true, false)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2MzQzOQ=="}, "originalCommit": {"oid": "f946f7ed845d48269b098e19f05c21460842b113"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDc3NzE3OnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/HttpClientPool.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMjoxNToxOFrOGUa4bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMzoxMTozMFrOGXKaPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2NTEzNQ==", "bodyText": "Trying to figure out what you're doing here.  I thought you wanted to pool HttpClient instances, but you are creating a single instance and returning it every time.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r424065135", "createdAt": "2020-05-12T22:15:18Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/HttpClientPool.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) 2017, 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.helpers;\n+\n+import java.net.http.HttpClient;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import oracle.kubernetes.operator.logging.LoggingFacade;\n+import oracle.kubernetes.operator.logging.LoggingFactory;\n+import oracle.kubernetes.operator.logging.MessageKeys;\n+import oracle.kubernetes.operator.work.Container;\n+import oracle.kubernetes.operator.work.ContainerResolver;\n+\n+public class HttpClientPool extends Pool<HttpClient> {\n+  private static final LoggingFacade LOGGER = LoggingFactory.getLogger(\"Operator\", \"Operator\");\n+  private static final HttpClientFactory FACTORY = new DefaultClientFactory();\n+  private static HttpClientPool SINGLETON = new HttpClientPool();\n+  private static ThreadFactory threadFactory;\n+  private final AtomicBoolean isFirst = new AtomicBoolean(true);\n+\n+  // HttpClient instance that will be shared\n+  private final AtomicReference<HttpClient> instance = new AtomicReference<>();\n+\n+  public static void initialize(ThreadFactory threadFactory) {\n+    HttpClientPool.threadFactory = threadFactory;\n+  }\n+\n+  private static Runnable wrapRunnable(Runnable r) {\n+    return new Runnable() {\n+      @Override\n+      public void run() {\n+        try {\n+          r.run();\n+        } catch (Throwable t) {\n+          // These will almost always be spurious exceptions\n+          LOGGER.finer(MessageKeys.EXCEPTION, t);\n+        }\n+      }\n+    };\n+  }\n+\n+  public static HttpClientPool getInstance() {\n+    return SINGLETON;\n+  }\n+\n+  @Override\n+  protected HttpClient create() {\n+    return instance.updateAndGet(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f946f7ed845d48269b098e19f05c21460842b113"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEwMDAyOA==", "bodyText": "I was modeling this based on the existing ClientPool class implementation in helper package.  JDK11 http client and request objects are thread-safe and can be safely shared. So I thought creating a single instance and sharing it every time should be fine. In my testing, it seem to work fine. Please let me know if you see any issues with this or if any changes are needed. Thanks.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r424100028", "createdAt": "2020-05-12T23:59:50Z", "author": {"login": "ankedia"}, "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/HttpClientPool.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) 2017, 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.helpers;\n+\n+import java.net.http.HttpClient;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import oracle.kubernetes.operator.logging.LoggingFacade;\n+import oracle.kubernetes.operator.logging.LoggingFactory;\n+import oracle.kubernetes.operator.logging.MessageKeys;\n+import oracle.kubernetes.operator.work.Container;\n+import oracle.kubernetes.operator.work.ContainerResolver;\n+\n+public class HttpClientPool extends Pool<HttpClient> {\n+  private static final LoggingFacade LOGGER = LoggingFactory.getLogger(\"Operator\", \"Operator\");\n+  private static final HttpClientFactory FACTORY = new DefaultClientFactory();\n+  private static HttpClientPool SINGLETON = new HttpClientPool();\n+  private static ThreadFactory threadFactory;\n+  private final AtomicBoolean isFirst = new AtomicBoolean(true);\n+\n+  // HttpClient instance that will be shared\n+  private final AtomicReference<HttpClient> instance = new AtomicReference<>();\n+\n+  public static void initialize(ThreadFactory threadFactory) {\n+    HttpClientPool.threadFactory = threadFactory;\n+  }\n+\n+  private static Runnable wrapRunnable(Runnable r) {\n+    return new Runnable() {\n+      @Override\n+      public void run() {\n+        try {\n+          r.run();\n+        } catch (Throwable t) {\n+          // These will almost always be spurious exceptions\n+          LOGGER.finer(MessageKeys.EXCEPTION, t);\n+        }\n+      }\n+    };\n+  }\n+\n+  public static HttpClientPool getInstance() {\n+    return SINGLETON;\n+  }\n+\n+  @Override\n+  protected HttpClient create() {\n+    return instance.updateAndGet(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2NTEzNQ=="}, "originalCommit": {"oid": "f946f7ed845d48269b098e19f05c21460842b113"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3MjE3OA==", "bodyText": "As above, let's rid of this class.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r426772178", "createdAt": "2020-05-18T17:04:53Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/HttpClientPool.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) 2017, 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.helpers;\n+\n+import java.net.http.HttpClient;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import oracle.kubernetes.operator.logging.LoggingFacade;\n+import oracle.kubernetes.operator.logging.LoggingFactory;\n+import oracle.kubernetes.operator.logging.MessageKeys;\n+import oracle.kubernetes.operator.work.Container;\n+import oracle.kubernetes.operator.work.ContainerResolver;\n+\n+public class HttpClientPool extends Pool<HttpClient> {\n+  private static final LoggingFacade LOGGER = LoggingFactory.getLogger(\"Operator\", \"Operator\");\n+  private static final HttpClientFactory FACTORY = new DefaultClientFactory();\n+  private static HttpClientPool SINGLETON = new HttpClientPool();\n+  private static ThreadFactory threadFactory;\n+  private final AtomicBoolean isFirst = new AtomicBoolean(true);\n+\n+  // HttpClient instance that will be shared\n+  private final AtomicReference<HttpClient> instance = new AtomicReference<>();\n+\n+  public static void initialize(ThreadFactory threadFactory) {\n+    HttpClientPool.threadFactory = threadFactory;\n+  }\n+\n+  private static Runnable wrapRunnable(Runnable r) {\n+    return new Runnable() {\n+      @Override\n+      public void run() {\n+        try {\n+          r.run();\n+        } catch (Throwable t) {\n+          // These will almost always be spurious exceptions\n+          LOGGER.finer(MessageKeys.EXCEPTION, t);\n+        }\n+      }\n+    };\n+  }\n+\n+  public static HttpClientPool getInstance() {\n+    return SINGLETON;\n+  }\n+\n+  @Override\n+  protected HttpClient create() {\n+    return instance.updateAndGet(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2NTEzNQ=="}, "originalCommit": {"oid": "f946f7ed845d48269b098e19f05c21460842b113"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk0MDk4OA==", "bodyText": "Removed in commit ba303f0. Thanks.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r426940988", "createdAt": "2020-05-18T23:11:30Z", "author": {"login": "ankedia"}, "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/HttpClientPool.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) 2017, 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.helpers;\n+\n+import java.net.http.HttpClient;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import oracle.kubernetes.operator.logging.LoggingFacade;\n+import oracle.kubernetes.operator.logging.LoggingFactory;\n+import oracle.kubernetes.operator.logging.MessageKeys;\n+import oracle.kubernetes.operator.work.Container;\n+import oracle.kubernetes.operator.work.ContainerResolver;\n+\n+public class HttpClientPool extends Pool<HttpClient> {\n+  private static final LoggingFacade LOGGER = LoggingFactory.getLogger(\"Operator\", \"Operator\");\n+  private static final HttpClientFactory FACTORY = new DefaultClientFactory();\n+  private static HttpClientPool SINGLETON = new HttpClientPool();\n+  private static ThreadFactory threadFactory;\n+  private final AtomicBoolean isFirst = new AtomicBoolean(true);\n+\n+  // HttpClient instance that will be shared\n+  private final AtomicReference<HttpClient> instance = new AtomicReference<>();\n+\n+  public static void initialize(ThreadFactory threadFactory) {\n+    HttpClientPool.threadFactory = threadFactory;\n+  }\n+\n+  private static Runnable wrapRunnable(Runnable r) {\n+    return new Runnable() {\n+      @Override\n+      public void run() {\n+        try {\n+          r.run();\n+        } catch (Throwable t) {\n+          // These will almost always be spurious exceptions\n+          LOGGER.finer(MessageKeys.EXCEPTION, t);\n+        }\n+      }\n+    };\n+  }\n+\n+  public static HttpClientPool getInstance() {\n+    return SINGLETON;\n+  }\n+\n+  @Override\n+  protected HttpClient create() {\n+    return instance.updateAndGet(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2NTEzNQ=="}, "originalCommit": {"oid": "f946f7ed845d48269b098e19f05c21460842b113"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDc4ODA5OnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ReadHealthStep.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMjoyMDowMlrOGUa_Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwMDowMzoxMlrOGUdERQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2Njg4Nw==", "bodyText": "probably want Throwable here", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r424066887", "createdAt": "2020-05-12T22:20:02Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ReadHealthStep.java", "diffHunk": "@@ -128,47 +242,62 @@ public NextAction apply(Packet packet) {\n           serverConfig = findServerConfig(cluster, serverName);\n         }\n \n-        if (httpClient == null) {\n+        if (encodedCredentials == null) {\n           LOGGER.info(\n               (LoggingFilter) packet.get(LoggingFilter.LOGGING_FILTER_PACKET_KEY),\n               MessageKeys.WLS_HEALTH_READ_FAILED_NO_HTTPCLIENT,\n               packet.get(ProcessingConstants.SERVER_NAME));\n         } else {\n \n           String serviceUrl =\n-              HttpClient.getServiceUrl(\n+              getServiceUrl(\n                   service,\n                   pod,\n                   serverConfig.getAdminProtocolChannelName(),\n                   serverConfig.getListenPort());\n           if (serviceUrl != null) {\n-            Result result =\n-                httpClient.executePostUrlOnServiceClusterIP(\n-                    getRetrieveHealthSearchUrl(),\n-                    serviceUrl,\n-                    getRetrieveHealthSearchPayload(),\n-                    false);\n-\n-            Pair<String, ServerHealth> pair = createServerHealthFromResult(result);\n-\n-            String state = pair.getLeft();\n-            if (state != null && !state.isEmpty()) {\n-              ConcurrentMap<String, String> serverStateMap =\n-                  (ConcurrentMap<String, String>) packet.get(SERVER_STATE_MAP);\n-              info.updateLastKnownServerStatus(serverName, state);\n-              serverStateMap.put(serverName, state);\n-            }\n-\n-            @SuppressWarnings(\"unchecked\")\n-            ConcurrentMap<String, ServerHealth> serverHealthMap =\n-                (ConcurrentMap<String, ServerHealth>)\n-                    packet.get(ProcessingConstants.SERVER_HEALTH_MAP);\n-\n-            serverHealthMap.put(\n-                (String) packet.get(ProcessingConstants.SERVER_NAME), pair.getRight());\n-            AtomicInteger remainingServersHealthToRead =\n-                packet.getValue(ProcessingConstants.REMAINING_SERVERS_HEALTH_TO_READ);\n-            remainingServersHealthToRead.getAndDecrement();\n+            return doSuspend(\n+                (fiber) -> {\n+                  try {\n+                    String url = serviceUrl + getRetrieveHealthSearchUrl();\n+                    HttpRequest request =\n+                        HttpRequest.newBuilder()\n+                            .uri(URI.create(url))\n+                            .timeout(Duration.ofSeconds(HTTP_TIMEOUT_SECONDS))\n+                            .header(\"Authorization\", \"Basic \" + encodedCredentials)\n+                            .header(\"Accept\", \"application/json\")\n+                            .header(\"Content-Type\", \"application/json\")\n+                            .header(\"X-Requested-By\", \"WebLogic Operator\")\n+                            .POST(\n+                                HttpRequest.BodyPublishers.ofString(\n+                                    getRetrieveHealthSearchPayload()))\n+                            .build();\n+                    httpClient\n+                        .sendAsync(request, HttpResponse.BodyHandlers.ofString())\n+                        .thenApply(\n+                            response ->\n+                                new Result(\n+                                    response.body(),\n+                                    response.statusCode(),\n+                                    response.statusCode() == ProcessingConstants.HTTP_OK))\n+                        .whenComplete(\n+                            (input, exception) -> {\n+                              if (exception != null) {\n+                                LOGGER.severe(\n+                                    MessageKeys.HTTP_METHOD_FAILED,\n+                                    \"POST\",\n+                                    url,\n+                                    input.getResponse());\n+                              } else {\n+                                packet.put(ProcessingConstants.RESULT, input);\n+                              }\n+                              fiber.resume(packet);\n+                            });\n+                  } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f946f7ed845d48269b098e19f05c21460842b113"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEwMDkzMw==", "bodyText": "yes, changed to throwable. Thanks.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r424100933", "createdAt": "2020-05-13T00:03:12Z", "author": {"login": "ankedia"}, "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ReadHealthStep.java", "diffHunk": "@@ -128,47 +242,62 @@ public NextAction apply(Packet packet) {\n           serverConfig = findServerConfig(cluster, serverName);\n         }\n \n-        if (httpClient == null) {\n+        if (encodedCredentials == null) {\n           LOGGER.info(\n               (LoggingFilter) packet.get(LoggingFilter.LOGGING_FILTER_PACKET_KEY),\n               MessageKeys.WLS_HEALTH_READ_FAILED_NO_HTTPCLIENT,\n               packet.get(ProcessingConstants.SERVER_NAME));\n         } else {\n \n           String serviceUrl =\n-              HttpClient.getServiceUrl(\n+              getServiceUrl(\n                   service,\n                   pod,\n                   serverConfig.getAdminProtocolChannelName(),\n                   serverConfig.getListenPort());\n           if (serviceUrl != null) {\n-            Result result =\n-                httpClient.executePostUrlOnServiceClusterIP(\n-                    getRetrieveHealthSearchUrl(),\n-                    serviceUrl,\n-                    getRetrieveHealthSearchPayload(),\n-                    false);\n-\n-            Pair<String, ServerHealth> pair = createServerHealthFromResult(result);\n-\n-            String state = pair.getLeft();\n-            if (state != null && !state.isEmpty()) {\n-              ConcurrentMap<String, String> serverStateMap =\n-                  (ConcurrentMap<String, String>) packet.get(SERVER_STATE_MAP);\n-              info.updateLastKnownServerStatus(serverName, state);\n-              serverStateMap.put(serverName, state);\n-            }\n-\n-            @SuppressWarnings(\"unchecked\")\n-            ConcurrentMap<String, ServerHealth> serverHealthMap =\n-                (ConcurrentMap<String, ServerHealth>)\n-                    packet.get(ProcessingConstants.SERVER_HEALTH_MAP);\n-\n-            serverHealthMap.put(\n-                (String) packet.get(ProcessingConstants.SERVER_NAME), pair.getRight());\n-            AtomicInteger remainingServersHealthToRead =\n-                packet.getValue(ProcessingConstants.REMAINING_SERVERS_HEALTH_TO_READ);\n-            remainingServersHealthToRead.getAndDecrement();\n+            return doSuspend(\n+                (fiber) -> {\n+                  try {\n+                    String url = serviceUrl + getRetrieveHealthSearchUrl();\n+                    HttpRequest request =\n+                        HttpRequest.newBuilder()\n+                            .uri(URI.create(url))\n+                            .timeout(Duration.ofSeconds(HTTP_TIMEOUT_SECONDS))\n+                            .header(\"Authorization\", \"Basic \" + encodedCredentials)\n+                            .header(\"Accept\", \"application/json\")\n+                            .header(\"Content-Type\", \"application/json\")\n+                            .header(\"X-Requested-By\", \"WebLogic Operator\")\n+                            .POST(\n+                                HttpRequest.BodyPublishers.ofString(\n+                                    getRetrieveHealthSearchPayload()))\n+                            .build();\n+                    httpClient\n+                        .sendAsync(request, HttpResponse.BodyHandlers.ofString())\n+                        .thenApply(\n+                            response ->\n+                                new Result(\n+                                    response.body(),\n+                                    response.statusCode(),\n+                                    response.statusCode() == ProcessingConstants.HTTP_OK))\n+                        .whenComplete(\n+                            (input, exception) -> {\n+                              if (exception != null) {\n+                                LOGGER.severe(\n+                                    MessageKeys.HTTP_METHOD_FAILED,\n+                                    \"POST\",\n+                                    url,\n+                                    input.getResponse());\n+                              } else {\n+                                packet.put(ProcessingConstants.RESULT, input);\n+                              }\n+                              fiber.resume(packet);\n+                            });\n+                  } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2Njg4Nw=="}, "originalCommit": {"oid": "f946f7ed845d48269b098e19f05c21460842b113"}, "originalPosition": 257}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDc5MDA0OnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ReadHealthStep.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMjoyMDo1MlrOGUbAgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxODowMjowNVrOGU9VVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2NzIwMg==", "bodyText": "Is there any support for a timeout?  What if the response never comes back?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r424067202", "createdAt": "2020-05-12T22:20:52Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ReadHealthStep.java", "diffHunk": "@@ -128,47 +242,62 @@ public NextAction apply(Packet packet) {\n           serverConfig = findServerConfig(cluster, serverName);\n         }\n \n-        if (httpClient == null) {\n+        if (encodedCredentials == null) {\n           LOGGER.info(\n               (LoggingFilter) packet.get(LoggingFilter.LOGGING_FILTER_PACKET_KEY),\n               MessageKeys.WLS_HEALTH_READ_FAILED_NO_HTTPCLIENT,\n               packet.get(ProcessingConstants.SERVER_NAME));\n         } else {\n \n           String serviceUrl =\n-              HttpClient.getServiceUrl(\n+              getServiceUrl(\n                   service,\n                   pod,\n                   serverConfig.getAdminProtocolChannelName(),\n                   serverConfig.getListenPort());\n           if (serviceUrl != null) {\n-            Result result =\n-                httpClient.executePostUrlOnServiceClusterIP(\n-                    getRetrieveHealthSearchUrl(),\n-                    serviceUrl,\n-                    getRetrieveHealthSearchPayload(),\n-                    false);\n-\n-            Pair<String, ServerHealth> pair = createServerHealthFromResult(result);\n-\n-            String state = pair.getLeft();\n-            if (state != null && !state.isEmpty()) {\n-              ConcurrentMap<String, String> serverStateMap =\n-                  (ConcurrentMap<String, String>) packet.get(SERVER_STATE_MAP);\n-              info.updateLastKnownServerStatus(serverName, state);\n-              serverStateMap.put(serverName, state);\n-            }\n-\n-            @SuppressWarnings(\"unchecked\")\n-            ConcurrentMap<String, ServerHealth> serverHealthMap =\n-                (ConcurrentMap<String, ServerHealth>)\n-                    packet.get(ProcessingConstants.SERVER_HEALTH_MAP);\n-\n-            serverHealthMap.put(\n-                (String) packet.get(ProcessingConstants.SERVER_NAME), pair.getRight());\n-            AtomicInteger remainingServersHealthToRead =\n-                packet.getValue(ProcessingConstants.REMAINING_SERVERS_HEALTH_TO_READ);\n-            remainingServersHealthToRead.getAndDecrement();\n+            return doSuspend(\n+                (fiber) -> {\n+                  try {\n+                    String url = serviceUrl + getRetrieveHealthSearchUrl();\n+                    HttpRequest request =\n+                        HttpRequest.newBuilder()\n+                            .uri(URI.create(url))\n+                            .timeout(Duration.ofSeconds(HTTP_TIMEOUT_SECONDS))\n+                            .header(\"Authorization\", \"Basic \" + encodedCredentials)\n+                            .header(\"Accept\", \"application/json\")\n+                            .header(\"Content-Type\", \"application/json\")\n+                            .header(\"X-Requested-By\", \"WebLogic Operator\")\n+                            .POST(\n+                                HttpRequest.BodyPublishers.ofString(\n+                                    getRetrieveHealthSearchPayload()))\n+                            .build();\n+                    httpClient\n+                        .sendAsync(request, HttpResponse.BodyHandlers.ofString())\n+                        .thenApply(\n+                            response ->\n+                                new Result(\n+                                    response.body(),\n+                                    response.statusCode(),\n+                                    response.statusCode() == ProcessingConstants.HTTP_OK))\n+                        .whenComplete(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f946f7ed845d48269b098e19f05c21460842b113"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2NzQxNg==", "bodyText": "Also, I don't yet understand the flow if the result is not HTTP_OK.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r424067416", "createdAt": "2020-05-12T22:21:29Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ReadHealthStep.java", "diffHunk": "@@ -128,47 +242,62 @@ public NextAction apply(Packet packet) {\n           serverConfig = findServerConfig(cluster, serverName);\n         }\n \n-        if (httpClient == null) {\n+        if (encodedCredentials == null) {\n           LOGGER.info(\n               (LoggingFilter) packet.get(LoggingFilter.LOGGING_FILTER_PACKET_KEY),\n               MessageKeys.WLS_HEALTH_READ_FAILED_NO_HTTPCLIENT,\n               packet.get(ProcessingConstants.SERVER_NAME));\n         } else {\n \n           String serviceUrl =\n-              HttpClient.getServiceUrl(\n+              getServiceUrl(\n                   service,\n                   pod,\n                   serverConfig.getAdminProtocolChannelName(),\n                   serverConfig.getListenPort());\n           if (serviceUrl != null) {\n-            Result result =\n-                httpClient.executePostUrlOnServiceClusterIP(\n-                    getRetrieveHealthSearchUrl(),\n-                    serviceUrl,\n-                    getRetrieveHealthSearchPayload(),\n-                    false);\n-\n-            Pair<String, ServerHealth> pair = createServerHealthFromResult(result);\n-\n-            String state = pair.getLeft();\n-            if (state != null && !state.isEmpty()) {\n-              ConcurrentMap<String, String> serverStateMap =\n-                  (ConcurrentMap<String, String>) packet.get(SERVER_STATE_MAP);\n-              info.updateLastKnownServerStatus(serverName, state);\n-              serverStateMap.put(serverName, state);\n-            }\n-\n-            @SuppressWarnings(\"unchecked\")\n-            ConcurrentMap<String, ServerHealth> serverHealthMap =\n-                (ConcurrentMap<String, ServerHealth>)\n-                    packet.get(ProcessingConstants.SERVER_HEALTH_MAP);\n-\n-            serverHealthMap.put(\n-                (String) packet.get(ProcessingConstants.SERVER_NAME), pair.getRight());\n-            AtomicInteger remainingServersHealthToRead =\n-                packet.getValue(ProcessingConstants.REMAINING_SERVERS_HEALTH_TO_READ);\n-            remainingServersHealthToRead.getAndDecrement();\n+            return doSuspend(\n+                (fiber) -> {\n+                  try {\n+                    String url = serviceUrl + getRetrieveHealthSearchUrl();\n+                    HttpRequest request =\n+                        HttpRequest.newBuilder()\n+                            .uri(URI.create(url))\n+                            .timeout(Duration.ofSeconds(HTTP_TIMEOUT_SECONDS))\n+                            .header(\"Authorization\", \"Basic \" + encodedCredentials)\n+                            .header(\"Accept\", \"application/json\")\n+                            .header(\"Content-Type\", \"application/json\")\n+                            .header(\"X-Requested-By\", \"WebLogic Operator\")\n+                            .POST(\n+                                HttpRequest.BodyPublishers.ofString(\n+                                    getRetrieveHealthSearchPayload()))\n+                            .build();\n+                    httpClient\n+                        .sendAsync(request, HttpResponse.BodyHandlers.ofString())\n+                        .thenApply(\n+                            response ->\n+                                new Result(\n+                                    response.body(),\n+                                    response.statusCode(),\n+                                    response.statusCode() == ProcessingConstants.HTTP_OK))\n+                        .whenComplete(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2NzIwMg=="}, "originalCommit": {"oid": "f946f7ed845d48269b098e19f05c21460842b113"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEwMjEwNQ==", "bodyText": "Is there any support for a timeout? What if the response never comes back?\nTimeout is set on request object and it's currently set to 1 min. I'll test the negative case to make sure request times out after specified duration and doesn't hang forever. Please let me know if current timeout value needs to be changed.\n\n                    HttpRequest.newBuilder()\n                        .uri(URI.create(url))\n                        .timeout(Duration.ofSeconds(HTTP_TIMEOUT_SECONDS))", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r424102105", "createdAt": "2020-05-13T00:07:49Z", "author": {"login": "ankedia"}, "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ReadHealthStep.java", "diffHunk": "@@ -128,47 +242,62 @@ public NextAction apply(Packet packet) {\n           serverConfig = findServerConfig(cluster, serverName);\n         }\n \n-        if (httpClient == null) {\n+        if (encodedCredentials == null) {\n           LOGGER.info(\n               (LoggingFilter) packet.get(LoggingFilter.LOGGING_FILTER_PACKET_KEY),\n               MessageKeys.WLS_HEALTH_READ_FAILED_NO_HTTPCLIENT,\n               packet.get(ProcessingConstants.SERVER_NAME));\n         } else {\n \n           String serviceUrl =\n-              HttpClient.getServiceUrl(\n+              getServiceUrl(\n                   service,\n                   pod,\n                   serverConfig.getAdminProtocolChannelName(),\n                   serverConfig.getListenPort());\n           if (serviceUrl != null) {\n-            Result result =\n-                httpClient.executePostUrlOnServiceClusterIP(\n-                    getRetrieveHealthSearchUrl(),\n-                    serviceUrl,\n-                    getRetrieveHealthSearchPayload(),\n-                    false);\n-\n-            Pair<String, ServerHealth> pair = createServerHealthFromResult(result);\n-\n-            String state = pair.getLeft();\n-            if (state != null && !state.isEmpty()) {\n-              ConcurrentMap<String, String> serverStateMap =\n-                  (ConcurrentMap<String, String>) packet.get(SERVER_STATE_MAP);\n-              info.updateLastKnownServerStatus(serverName, state);\n-              serverStateMap.put(serverName, state);\n-            }\n-\n-            @SuppressWarnings(\"unchecked\")\n-            ConcurrentMap<String, ServerHealth> serverHealthMap =\n-                (ConcurrentMap<String, ServerHealth>)\n-                    packet.get(ProcessingConstants.SERVER_HEALTH_MAP);\n-\n-            serverHealthMap.put(\n-                (String) packet.get(ProcessingConstants.SERVER_NAME), pair.getRight());\n-            AtomicInteger remainingServersHealthToRead =\n-                packet.getValue(ProcessingConstants.REMAINING_SERVERS_HEALTH_TO_READ);\n-            remainingServersHealthToRead.getAndDecrement();\n+            return doSuspend(\n+                (fiber) -> {\n+                  try {\n+                    String url = serviceUrl + getRetrieveHealthSearchUrl();\n+                    HttpRequest request =\n+                        HttpRequest.newBuilder()\n+                            .uri(URI.create(url))\n+                            .timeout(Duration.ofSeconds(HTTP_TIMEOUT_SECONDS))\n+                            .header(\"Authorization\", \"Basic \" + encodedCredentials)\n+                            .header(\"Accept\", \"application/json\")\n+                            .header(\"Content-Type\", \"application/json\")\n+                            .header(\"X-Requested-By\", \"WebLogic Operator\")\n+                            .POST(\n+                                HttpRequest.BodyPublishers.ofString(\n+                                    getRetrieveHealthSearchPayload()))\n+                            .build();\n+                    httpClient\n+                        .sendAsync(request, HttpResponse.BodyHandlers.ofString())\n+                        .thenApply(\n+                            response ->\n+                                new Result(\n+                                    response.body(),\n+                                    response.statusCode(),\n+                                    response.statusCode() == ProcessingConstants.HTTP_OK))\n+                        .whenComplete(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2NzIwMg=="}, "originalCommit": {"oid": "f946f7ed845d48269b098e19f05c21460842b113"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYyOTU5MA==", "bodyText": "I have tested the negative cases where request times out due to HttpConnectTimeoutException and result is not HTTP_OK. I have also made some other changes for flow where result is not HTTP_OK. Hope this make flow more readable. Please let me know if you want to discuss this on a call. Thanks.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r424629590", "createdAt": "2020-05-13T18:02:05Z", "author": {"login": "ankedia"}, "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ReadHealthStep.java", "diffHunk": "@@ -128,47 +242,62 @@ public NextAction apply(Packet packet) {\n           serverConfig = findServerConfig(cluster, serverName);\n         }\n \n-        if (httpClient == null) {\n+        if (encodedCredentials == null) {\n           LOGGER.info(\n               (LoggingFilter) packet.get(LoggingFilter.LOGGING_FILTER_PACKET_KEY),\n               MessageKeys.WLS_HEALTH_READ_FAILED_NO_HTTPCLIENT,\n               packet.get(ProcessingConstants.SERVER_NAME));\n         } else {\n \n           String serviceUrl =\n-              HttpClient.getServiceUrl(\n+              getServiceUrl(\n                   service,\n                   pod,\n                   serverConfig.getAdminProtocolChannelName(),\n                   serverConfig.getListenPort());\n           if (serviceUrl != null) {\n-            Result result =\n-                httpClient.executePostUrlOnServiceClusterIP(\n-                    getRetrieveHealthSearchUrl(),\n-                    serviceUrl,\n-                    getRetrieveHealthSearchPayload(),\n-                    false);\n-\n-            Pair<String, ServerHealth> pair = createServerHealthFromResult(result);\n-\n-            String state = pair.getLeft();\n-            if (state != null && !state.isEmpty()) {\n-              ConcurrentMap<String, String> serverStateMap =\n-                  (ConcurrentMap<String, String>) packet.get(SERVER_STATE_MAP);\n-              info.updateLastKnownServerStatus(serverName, state);\n-              serverStateMap.put(serverName, state);\n-            }\n-\n-            @SuppressWarnings(\"unchecked\")\n-            ConcurrentMap<String, ServerHealth> serverHealthMap =\n-                (ConcurrentMap<String, ServerHealth>)\n-                    packet.get(ProcessingConstants.SERVER_HEALTH_MAP);\n-\n-            serverHealthMap.put(\n-                (String) packet.get(ProcessingConstants.SERVER_NAME), pair.getRight());\n-            AtomicInteger remainingServersHealthToRead =\n-                packet.getValue(ProcessingConstants.REMAINING_SERVERS_HEALTH_TO_READ);\n-            remainingServersHealthToRead.getAndDecrement();\n+            return doSuspend(\n+                (fiber) -> {\n+                  try {\n+                    String url = serviceUrl + getRetrieveHealthSearchUrl();\n+                    HttpRequest request =\n+                        HttpRequest.newBuilder()\n+                            .uri(URI.create(url))\n+                            .timeout(Duration.ofSeconds(HTTP_TIMEOUT_SECONDS))\n+                            .header(\"Authorization\", \"Basic \" + encodedCredentials)\n+                            .header(\"Accept\", \"application/json\")\n+                            .header(\"Content-Type\", \"application/json\")\n+                            .header(\"X-Requested-By\", \"WebLogic Operator\")\n+                            .POST(\n+                                HttpRequest.BodyPublishers.ofString(\n+                                    getRetrieveHealthSearchPayload()))\n+                            .build();\n+                    httpClient\n+                        .sendAsync(request, HttpResponse.BodyHandlers.ofString())\n+                        .thenApply(\n+                            response ->\n+                                new Result(\n+                                    response.body(),\n+                                    response.statusCode(),\n+                                    response.statusCode() == ProcessingConstants.HTTP_OK))\n+                        .whenComplete(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2NzIwMg=="}, "originalCommit": {"oid": "f946f7ed845d48269b098e19f05c21460842b113"}, "originalPosition": 244}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDc5NDYwOnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ReadHealthStep.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMjoyMjo1MVrOGUbDkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwMDoyNjoxNlrOGVIBAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2Nzk4Ng==", "bodyText": "I know you probably copied this method, but this text doesn't describe what the method is doing. It looks like it's figuring out the URL of where the server can receive admin traffic.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r424067986", "createdAt": "2020-05-12T22:22:51Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ReadHealthStep.java", "diffHunk": "@@ -183,15 +312,114 @@ public NextAction apply(Packet packet) {\n       }\n     }\n \n+    /**\n+     * Returns the URL to access the Service; using the Service clusterIP and port. If the service", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f946f7ed845d48269b098e19f05c21460842b113"}, "originalPosition": 270}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgwNDYxMQ==", "bodyText": "This method was originally in HttpClient class and I just moved it to ReadHealthStep class (since HttpClient class was removed). I discussed the Java doc text with Anthony and have changed it based on that discussion. Please let me know if this is not clear enough.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r424804611", "createdAt": "2020-05-14T00:26:16Z", "author": {"login": "ankedia"}, "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ReadHealthStep.java", "diffHunk": "@@ -183,15 +312,114 @@ public NextAction apply(Packet packet) {\n       }\n     }\n \n+    /**\n+     * Returns the URL to access the Service; using the Service clusterIP and port. If the service", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2Nzk4Ng=="}, "originalCommit": {"oid": "f946f7ed845d48269b098e19f05c21460842b113"}, "originalPosition": 270}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDgyNTE0OnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ReadHealthStep.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMjozNjoyMlrOGUbWjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwMDoxODo1N1rOGVH4-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3Mjg0NQ==", "bodyText": "The EncodeCredentialsForServerStep is just creating a readSecret step and then call doNext(). Can it be removed and instead we call SecretHelper.getSecretData() here?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r424072845", "createdAt": "2020-05-12T22:36:22Z", "author": {"login": "alai8"}, "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ReadHealthStep.java", "diffHunk": "@@ -89,13 +103,110 @@ public NextAction apply(Packet packet) {\n     V1Pod pod = info.getServerPod(serverName);\n     if (service != null) {\n       Step getClient =\n-          HttpClient.createAuthenticatedClientForServer(\n-              namespace, secretName, new ReadHealthWithHttpClientStep(service, pod, getNext()));\n+          getEncodedCredentialsForServer(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f946f7ed845d48269b098e19f05c21460842b113"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgwMjU1NA==", "bodyText": "Fixed. Thanks.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r424802554", "createdAt": "2020-05-14T00:18:57Z", "author": {"login": "ankedia"}, "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ReadHealthStep.java", "diffHunk": "@@ -89,13 +103,110 @@ public NextAction apply(Packet packet) {\n     V1Pod pod = info.getServerPod(serverName);\n     if (service != null) {\n       Step getClient =\n-          HttpClient.createAuthenticatedClientForServer(\n-              namespace, secretName, new ReadHealthWithHttpClientStep(service, pod, getNext()));\n+          getEncodedCredentialsForServer(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3Mjg0NQ=="}, "originalCommit": {"oid": "f946f7ed845d48269b098e19f05c21460842b113"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzkyMzM2OnYy", "diffSide": "RIGHT", "path": "docs/charts/index.yaml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNjo1OTo0M1rOGW_8Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjoxMDozMlrOGXJHlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc2OTQzMQ==", "bodyText": "If you merge in latest from develop, do changes to this file and the tgz file go away? These shouldn't be part of your change.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r426769431", "createdAt": "2020-05-18T16:59:43Z", "author": {"login": "rjeberhard"}, "path": "docs/charts/index.yaml", "diffHunk": "@@ -2,68 +2,68 @@ apiVersion: v1\n entries:\n   weblogic-operator:\n   - apiVersion: v1\n-    created: 2020-03-21T22:03:53.042035124Z\n+    created: 2020-05-14T14:50:06.509204738-04:00", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dca3bbd002a4aa7c3cf6eb459bb55e75788388b7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkxOTgyOQ==", "bodyText": "I merged in the starting version.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r426919829", "createdAt": "2020-05-18T22:10:32Z", "author": {"login": "russgold"}, "path": "docs/charts/index.yaml", "diffHunk": "@@ -2,68 +2,68 @@ apiVersion: v1\n entries:\n   weblogic-operator:\n   - apiVersion: v1\n-    created: 2020-03-21T22:03:53.042035124Z\n+    created: 2020-05-14T14:50:06.509204738-04:00", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc2OTQzMQ=="}, "originalCommit": {"oid": "dca3bbd002a4aa7c3cf6eb459bb55e75788388b7"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzkyNTIxOnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/operator/ProcessingConstants.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNzowMDoxM1rOGW_9QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMzoxMjoxNlrOGXKbDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc2OTcyOQ==", "bodyText": "You need a better constant name.  Why not ENCODED_CREDENTIALS?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r426769729", "createdAt": "2020-05-18T17:00:13Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/ProcessingConstants.java", "diffHunk": "@@ -34,4 +34,6 @@\n   public static final String DOMAIN_INTROSPECT_VERSION = \"weblogic.domainIntrospectVersion\";\n   public static final String DOMAIN_INPUTS_HASH = \"weblogic.domainInputsHash\";\n   public static final String REMAINING_SERVERS_HEALTH_TO_READ = \"serverHealthRead\";\n+\n+  public static final String KEY = \"encodedCredentials\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dca3bbd002a4aa7c3cf6eb459bb55e75788388b7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1MTA3MA==", "bodyText": "You need a better constant name. Why not ENCODED_CREDENTIALS?\n\nYes, I'll change it to ENCODED_CREDENTIALS. The constant name was previously used to store httpClient instance in packet and I was lazy to use same name for encoded credentials", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r426851070", "createdAt": "2020-05-18T19:36:34Z", "author": {"login": "ankedia"}, "path": "operator/src/main/java/oracle/kubernetes/operator/ProcessingConstants.java", "diffHunk": "@@ -34,4 +34,6 @@\n   public static final String DOMAIN_INTROSPECT_VERSION = \"weblogic.domainIntrospectVersion\";\n   public static final String DOMAIN_INPUTS_HASH = \"weblogic.domainInputsHash\";\n   public static final String REMAINING_SERVERS_HEALTH_TO_READ = \"serverHealthRead\";\n+\n+  public static final String KEY = \"encodedCredentials\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc2OTcyOQ=="}, "originalCommit": {"oid": "dca3bbd002a4aa7c3cf6eb459bb55e75788388b7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk0MTE5OA==", "bodyText": "Fixed in commit ba303f0.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r426941198", "createdAt": "2020-05-18T23:12:16Z", "author": {"login": "ankedia"}, "path": "operator/src/main/java/oracle/kubernetes/operator/ProcessingConstants.java", "diffHunk": "@@ -34,4 +34,6 @@\n   public static final String DOMAIN_INTROSPECT_VERSION = \"weblogic.domainIntrospectVersion\";\n   public static final String DOMAIN_INPUTS_HASH = \"weblogic.domainInputsHash\";\n   public static final String REMAINING_SERVERS_HEALTH_TO_READ = \"serverHealthRead\";\n+\n+  public static final String KEY = \"encodedCredentials\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc2OTcyOQ=="}, "originalCommit": {"oid": "dca3bbd002a4aa7c3cf6eb459bb55e75788388b7"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzkyNzQ0OnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/operator/calls/AsyncRequestStep.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNzowMDo1NFrOGW_-sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjo0MjoyMlrOGXJzgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3MDA5OQ==", "bodyText": "JavaDoc.  What is the \"cont\" parameter?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r426770099", "createdAt": "2020-05-18T17:00:54Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/calls/AsyncRequestStep.java", "diffHunk": "@@ -123,6 +126,90 @@ public void listenTimeoutDoubled() {\n     timeoutSeconds *= 2;\n   }\n \n+  class AsyncRequestStepProcessing {\n+\n+    final Packet packet;\n+    final RetryStrategy retryStrategy;\n+    final String cont;\n+    final AtomicBoolean didResume = new AtomicBoolean(false);\n+    final ApiClient client;\n+\n+    public AsyncRequestStepProcessing(Packet packet, RetryStrategy retry, String cont) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dca3bbd002a4aa7c3cf6eb459bb55e75788388b7"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg0NDEzNg==", "bodyText": "It's the same one the K8s APIs use, apparently having to do with continuing requests. Do you have a recommendation on a better name? Should I put the underscore before it, as some k8s code seems to?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r426844136", "createdAt": "2020-05-18T19:22:23Z", "author": {"login": "russgold"}, "path": "operator/src/main/java/oracle/kubernetes/operator/calls/AsyncRequestStep.java", "diffHunk": "@@ -123,6 +126,90 @@ public void listenTimeoutDoubled() {\n     timeoutSeconds *= 2;\n   }\n \n+  class AsyncRequestStepProcessing {\n+\n+    final Packet packet;\n+    final RetryStrategy retryStrategy;\n+    final String cont;\n+    final AtomicBoolean didResume = new AtomicBoolean(false);\n+    final ApiClient client;\n+\n+    public AsyncRequestStepProcessing(Packet packet, RetryStrategy retry, String cont) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3MDA5OQ=="}, "originalCommit": {"oid": "dca3bbd002a4aa7c3cf6eb459bb55e75788388b7"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2NjI0Mg==", "bodyText": "I'm okay with \"cont\" if I know what it is.  This is a cursor so that you can iterate over a long list.  Say, you had a namespace with 10,000 domains.  You could do a list and say give me the first 200, and then use the cont parameter to ask for the next 200 and so on. I can't understand why it's on this method though.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r426866242", "createdAt": "2020-05-18T20:08:16Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/calls/AsyncRequestStep.java", "diffHunk": "@@ -123,6 +126,90 @@ public void listenTimeoutDoubled() {\n     timeoutSeconds *= 2;\n   }\n \n+  class AsyncRequestStepProcessing {\n+\n+    final Packet packet;\n+    final RetryStrategy retryStrategy;\n+    final String cont;\n+    final AtomicBoolean didResume = new AtomicBoolean(false);\n+    final ApiClient client;\n+\n+    public AsyncRequestStepProcessing(Packet packet, RetryStrategy retry, String cont) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3MDA5OQ=="}, "originalCommit": {"oid": "dca3bbd002a4aa7c3cf6eb459bb55e75788388b7"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMTA2Nw==", "bodyText": "It's needed for this call:\n    // Create a call to Kubernetes that we can cancel if it doesn't succeed in time.\n    private CancellableCall createCall(AsyncFiber fiber) throws ApiException {\n      return factory.generate(requestParams, client, cont, new ApiCallbackImpl(this, fiber));\n    }\n\nThat was in the original version of the class, and I don't see an easy way to get rid of it.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r426921067", "createdAt": "2020-05-18T22:13:50Z", "author": {"login": "russgold"}, "path": "operator/src/main/java/oracle/kubernetes/operator/calls/AsyncRequestStep.java", "diffHunk": "@@ -123,6 +126,90 @@ public void listenTimeoutDoubled() {\n     timeoutSeconds *= 2;\n   }\n \n+  class AsyncRequestStepProcessing {\n+\n+    final Packet packet;\n+    final RetryStrategy retryStrategy;\n+    final String cont;\n+    final AtomicBoolean didResume = new AtomicBoolean(false);\n+    final ApiClient client;\n+\n+    public AsyncRequestStepProcessing(Packet packet, RetryStrategy retry, String cont) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3MDA5OQ=="}, "originalCommit": {"oid": "dca3bbd002a4aa7c3cf6eb459bb55e75788388b7"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzMTA3Mw==", "bodyText": "Okay, resolving this issue.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r426931073", "createdAt": "2020-05-18T22:42:22Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/calls/AsyncRequestStep.java", "diffHunk": "@@ -123,6 +126,90 @@ public void listenTimeoutDoubled() {\n     timeoutSeconds *= 2;\n   }\n \n+  class AsyncRequestStepProcessing {\n+\n+    final Packet packet;\n+    final RetryStrategy retryStrategy;\n+    final String cont;\n+    final AtomicBoolean didResume = new AtomicBoolean(false);\n+    final ApiClient client;\n+\n+    public AsyncRequestStepProcessing(Packet packet, RetryStrategy retry, String cont) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3MDA5OQ=="}, "originalCommit": {"oid": "dca3bbd002a4aa7c3cf6eb459bb55e75788388b7"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzkzNzgxOnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/HttpClientPool.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNzowNDoxM1rOGXAFag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMzoxMzowM1rOGXKcCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3MTgxOA==", "bodyText": "I think this class is unnecessary because you don't actually pool HttpClient.  Instead, you can share a single instance.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r426771818", "createdAt": "2020-05-18T17:04:13Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/HttpClientPool.java", "diffHunk": "@@ -0,0 +1,114 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dca3bbd002a4aa7c3cf6eb459bb55e75788388b7"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkxMDE0Mg==", "bodyText": "ok, I'll remove HttpClientPool and HttpClientFactory classes. I will introduce a static final variable in HttpAsyncRequestStep.java (below) and use that to invoke async send in \"createFuture\" method. Wanted to confirm if this is the right approach before committing the changes. Thanks.\nprivate static final HttpClient httpClient = HttpClient.newBuilder().build();\nprivate static CompletableFuture<HttpResponse> createFuture(HttpRequest request) {\nreturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString());\n}", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r426910142", "createdAt": "2020-05-18T21:45:27Z", "author": {"login": "ankedia"}, "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/HttpClientPool.java", "diffHunk": "@@ -0,0 +1,114 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3MTgxOA=="}, "originalCommit": {"oid": "dca3bbd002a4aa7c3cf6eb459bb55e75788388b7"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzMTYyOA==", "bodyText": "Yes, looks good.\nThe pool you copied this from is also no longer needed, but removing that is technical debt. When the underlying HTTP client implementation was OkHttp 2.x, the pooling was needed, but OkHttp 3.x has its own internal pooling.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r426931628", "createdAt": "2020-05-18T22:44:06Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/HttpClientPool.java", "diffHunk": "@@ -0,0 +1,114 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3MTgxOA=="}, "originalCommit": {"oid": "dca3bbd002a4aa7c3cf6eb459bb55e75788388b7"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk0MTQ0OA==", "bodyText": "ok, got it. I merged change based on above comments in ba303f0.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r426941448", "createdAt": "2020-05-18T23:13:03Z", "author": {"login": "ankedia"}, "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/HttpClientPool.java", "diffHunk": "@@ -0,0 +1,114 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3MTgxOA=="}, "originalCommit": {"oid": "dca3bbd002a4aa7c3cf6eb459bb55e75788388b7"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1Nzk1NTUzOnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/operator/http/HttpAsyncRequestStep.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNzowOTozN1rOGXAQ6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxOToyMjo0NFrOGXEgkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3NDc2Mw==", "bodyText": "What is the full set of tasks in the steps for this fiber? This says that if the HTTP request times-out, then the full fiber stops.  If this fiber is only reading the status for one server than this is fine. If the fiber is running through a set of servers then none of them will have status updated. If might make more sense to resume the fiber and have the next step (that processes the result) handle that there is no data.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r426774763", "createdAt": "2020-05-18T17:09:37Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/http/HttpAsyncRequestStep.java", "diffHunk": "@@ -0,0 +1,122 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.http;\n+\n+import java.net.HttpURLConnection;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import oracle.kubernetes.operator.helpers.HttpClientPool;\n+import oracle.kubernetes.operator.logging.LoggingFacade;\n+import oracle.kubernetes.operator.logging.LoggingFactory;\n+import oracle.kubernetes.operator.logging.MessageKeys;\n+import oracle.kubernetes.operator.work.AsyncFiber;\n+import oracle.kubernetes.operator.work.NextAction;\n+import oracle.kubernetes.operator.work.Packet;\n+import oracle.kubernetes.operator.work.Step;\n+\n+/**\n+ * An asynchronous step to handle http requests.\n+ */\n+public class HttpAsyncRequestStep extends Step {\n+\n+  interface FutureFactory {\n+    CompletableFuture<HttpResponse<String>> createFuture(HttpRequest request);\n+  }\n+\n+  private static final LoggingFacade LOGGER = LoggingFactory.getLogger(\"Operator\", \"Operator\");\n+  private static FutureFactory DEFAULT_FACTORY = HttpAsyncRequestStep::createFuture;\n+\n+  private static final long DEFAULT_TIMEOUT_SECONDS = 5;\n+\n+  private static FutureFactory factory = DEFAULT_FACTORY;\n+  private final HttpRequest request;\n+  private long timeoutSeconds = DEFAULT_TIMEOUT_SECONDS;\n+\n+  private HttpAsyncRequestStep(HttpRequest request, HttpResponseStep responseStep) {\n+    super(responseStep);\n+    this.request = request;\n+  }\n+\n+  /**\n+   * Creates a step to send a GET request to a server. If a response is received, processing\n+   * continues with the response step. If none is received within the timeout, the fiber is terminated.\n+   * @param url the URL of the targeted server\n+   * @param responseStep the step to handle the response\n+   * @return a new step to run as part of a fiber, linked to the response step\n+   */\n+  public static HttpAsyncRequestStep createGetRequest(String url, HttpResponseStep responseStep) {\n+    HttpRequest request = HttpRequest.newBuilder(URI.create(url)).GET().build();\n+    return create(request, responseStep);\n+  }\n+\n+  /**\n+   * Creates a step to send a request to a server. If a response is received, processing\n+   * continues with the response step. If none is received within the timeout, the fiber is terminated.\n+   * @param request the http request to send\n+   * @param responseStep the step to handle the response\n+   * @return a new step to run as part of a fiber, linked to the response step\n+   */\n+  public static HttpAsyncRequestStep create(HttpRequest request, HttpResponseStep responseStep) {\n+    return new HttpAsyncRequestStep(request, responseStep);\n+  }\n+\n+  /**\n+   * Overrides the default timeout for this request.\n+   * @param timeoutSeconds the new timeout, in seconds\n+   * @return this step\n+   */\n+  public HttpAsyncRequestStep withTimeoutSeconds(long timeoutSeconds) {\n+    this.timeoutSeconds = timeoutSeconds;\n+    return this;\n+  }\n+\n+  @Override\n+  public NextAction apply(Packet packet) {\n+    AsyncProcessing processing = new AsyncProcessing(packet);\n+    return doSuspend(processing::process);\n+  }\n+\n+  class AsyncProcessing {\n+    private Packet packet;\n+    private CompletableFuture<HttpResponse<String>> future;\n+\n+    AsyncProcessing(Packet packet) {\n+      this.packet = packet;\n+    }\n+\n+    void process(AsyncFiber fiber) {\n+      future = factory.createFuture(request);\n+      future.whenComplete((response, throwable) -> resume(fiber, response, throwable));\n+      fiber.scheduleOnce(timeoutSeconds, TimeUnit.SECONDS, () -> checkTimeout(fiber));\n+    }\n+\n+    private void checkTimeout(AsyncFiber fiber) {\n+      if (!future.isDone()) {\n+        fiber.terminate(new RuntimeException(\"timeout\"), packet);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dca3bbd002a4aa7c3cf6eb459bb55e75788388b7"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg0NDMwNQ==", "bodyText": "Agreed. I will add a commit that changes this behavior.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r426844305", "createdAt": "2020-05-18T19:22:44Z", "author": {"login": "russgold"}, "path": "operator/src/main/java/oracle/kubernetes/operator/http/HttpAsyncRequestStep.java", "diffHunk": "@@ -0,0 +1,122 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.http;\n+\n+import java.net.HttpURLConnection;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import oracle.kubernetes.operator.helpers.HttpClientPool;\n+import oracle.kubernetes.operator.logging.LoggingFacade;\n+import oracle.kubernetes.operator.logging.LoggingFactory;\n+import oracle.kubernetes.operator.logging.MessageKeys;\n+import oracle.kubernetes.operator.work.AsyncFiber;\n+import oracle.kubernetes.operator.work.NextAction;\n+import oracle.kubernetes.operator.work.Packet;\n+import oracle.kubernetes.operator.work.Step;\n+\n+/**\n+ * An asynchronous step to handle http requests.\n+ */\n+public class HttpAsyncRequestStep extends Step {\n+\n+  interface FutureFactory {\n+    CompletableFuture<HttpResponse<String>> createFuture(HttpRequest request);\n+  }\n+\n+  private static final LoggingFacade LOGGER = LoggingFactory.getLogger(\"Operator\", \"Operator\");\n+  private static FutureFactory DEFAULT_FACTORY = HttpAsyncRequestStep::createFuture;\n+\n+  private static final long DEFAULT_TIMEOUT_SECONDS = 5;\n+\n+  private static FutureFactory factory = DEFAULT_FACTORY;\n+  private final HttpRequest request;\n+  private long timeoutSeconds = DEFAULT_TIMEOUT_SECONDS;\n+\n+  private HttpAsyncRequestStep(HttpRequest request, HttpResponseStep responseStep) {\n+    super(responseStep);\n+    this.request = request;\n+  }\n+\n+  /**\n+   * Creates a step to send a GET request to a server. If a response is received, processing\n+   * continues with the response step. If none is received within the timeout, the fiber is terminated.\n+   * @param url the URL of the targeted server\n+   * @param responseStep the step to handle the response\n+   * @return a new step to run as part of a fiber, linked to the response step\n+   */\n+  public static HttpAsyncRequestStep createGetRequest(String url, HttpResponseStep responseStep) {\n+    HttpRequest request = HttpRequest.newBuilder(URI.create(url)).GET().build();\n+    return create(request, responseStep);\n+  }\n+\n+  /**\n+   * Creates a step to send a request to a server. If a response is received, processing\n+   * continues with the response step. If none is received within the timeout, the fiber is terminated.\n+   * @param request the http request to send\n+   * @param responseStep the step to handle the response\n+   * @return a new step to run as part of a fiber, linked to the response step\n+   */\n+  public static HttpAsyncRequestStep create(HttpRequest request, HttpResponseStep responseStep) {\n+    return new HttpAsyncRequestStep(request, responseStep);\n+  }\n+\n+  /**\n+   * Overrides the default timeout for this request.\n+   * @param timeoutSeconds the new timeout, in seconds\n+   * @return this step\n+   */\n+  public HttpAsyncRequestStep withTimeoutSeconds(long timeoutSeconds) {\n+    this.timeoutSeconds = timeoutSeconds;\n+    return this;\n+  }\n+\n+  @Override\n+  public NextAction apply(Packet packet) {\n+    AsyncProcessing processing = new AsyncProcessing(packet);\n+    return doSuspend(processing::process);\n+  }\n+\n+  class AsyncProcessing {\n+    private Packet packet;\n+    private CompletableFuture<HttpResponse<String>> future;\n+\n+    AsyncProcessing(Packet packet) {\n+      this.packet = packet;\n+    }\n+\n+    void process(AsyncFiber fiber) {\n+      future = factory.createFuture(request);\n+      future.whenComplete((response, throwable) -> resume(fiber, response, throwable));\n+      fiber.scheduleOnce(timeoutSeconds, TimeUnit.SECONDS, () -> checkTimeout(fiber));\n+    }\n+\n+    private void checkTimeout(AsyncFiber fiber) {\n+      if (!future.isDone()) {\n+        fiber.terminate(new RuntimeException(\"timeout\"), packet);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3NDc2Mw=="}, "originalCommit": {"oid": "dca3bbd002a4aa7c3cf6eb459bb55e75788388b7"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1Nzk2MDkzOnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/operator/http/HttpResponseStep.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNzoxMToxMVrOGXAUPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxOToyNDowNlrOGXEjMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3NTYxNA==", "bodyText": "Looks like this code already handles no response.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r426775614", "createdAt": "2020-05-18T17:11:11Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/http/HttpResponseStep.java", "diffHunk": "@@ -0,0 +1,65 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.http;\n+\n+import java.net.HttpURLConnection;\n+import java.net.http.HttpResponse;\n+import java.util.Optional;\n+\n+import oracle.kubernetes.operator.work.Component;\n+import oracle.kubernetes.operator.work.NextAction;\n+import oracle.kubernetes.operator.work.Packet;\n+import oracle.kubernetes.operator.work.Step;\n+\n+public abstract class HttpResponseStep extends Step {\n+  static final String RESPONSE = \"httpResponse\";\n+\n+  public HttpResponseStep(Step next) {\n+    super(next);\n+  }\n+\n+  @Override\n+  public NextAction apply(Packet packet) {\n+    return Optional.ofNullable(getResponse(packet)).map(r -> doApply(packet, r)).orElse(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dca3bbd002a4aa7c3cf6eb459bb55e75788388b7"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg0NDk3Ng==", "bodyText": "Agreed, although it returns null, which doesn't work. Fixing that as well.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1643#discussion_r426844976", "createdAt": "2020-05-18T19:24:06Z", "author": {"login": "russgold"}, "path": "operator/src/main/java/oracle/kubernetes/operator/http/HttpResponseStep.java", "diffHunk": "@@ -0,0 +1,65 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.http;\n+\n+import java.net.HttpURLConnection;\n+import java.net.http.HttpResponse;\n+import java.util.Optional;\n+\n+import oracle.kubernetes.operator.work.Component;\n+import oracle.kubernetes.operator.work.NextAction;\n+import oracle.kubernetes.operator.work.Packet;\n+import oracle.kubernetes.operator.work.Step;\n+\n+public abstract class HttpResponseStep extends Step {\n+  static final String RESPONSE = \"httpResponse\";\n+\n+  public HttpResponseStep(Step next) {\n+    super(next);\n+  }\n+\n+  @Override\n+  public NextAction apply(Packet packet) {\n+    return Optional.ofNullable(getResponse(packet)).map(r -> doApply(packet, r)).orElse(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3NTYxNA=="}, "originalCommit": {"oid": "dca3bbd002a4aa7c3cf6eb459bb55e75788388b7"}, "originalPosition": 24}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4550, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}