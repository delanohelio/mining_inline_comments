{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwMzYwMDMz", "number": 1768, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMzo0Mzo0M1rOEJI02w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMjo1NTozOFrOEKr8vA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MDE3MjQzOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMzo0Mzo0M1rOGphbMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMDozNToyM1rOGpt8_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE5MjQzNQ==", "bodyText": "This is not a bug. The overrides will only be applied following introspection. We are clarifying the rules about when introspection will happen. Russ has pending PR #1746 where we've clarified the rules as follows:\n\nOn restartVersion change, all affected pods are restarted in all modes\nOn introspectVersion change, introspection is redone in all modes. For model-in-image, if the introspection generates a new domain home then any running servers will be rolled to the new domain home.\nIntrospection will also occur if there is no current introspection-results config map or if the domain presently has zero server instances running and is now starting a server.\nFor model-in-image only, introspection will also run for every \u2018make-right\u2019 flow in which it is determined that a server pod must be updated. In particular, that entails rerunning from the start of the step chain, and this time running the introspector.\nIf introspection fails, the domain resource status must reflect the failure; however, the \u2018make-right\u2019 flow otherwise stops and any currently running pods are left intact.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r446192435", "createdAt": "2020-06-26T13:43:43Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "diffHunk": "@@ -0,0 +1,1056 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownDomain;\n+import static oracle.weblogic.kubernetes.actions.TestActions.startDomain;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.MySQLDBUtils.createMySQLDB;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static oracle.weblogic.kubernetes.utils.WLSTUtils.executeWLSTScript;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests related to overrideDistributionStrategy attribute.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the overrideDistributionStrategy applies the overrides accordingly to the value set\")\n+@IntegrationTest\n+public class ItConfigDistributionStrategy {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path clusterViewAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  static int mysqlDBPort1;\n+  static int mysqlDBPort2;\n+  static String dsUrl1;\n+  static String dsUrl2;\n+\n+  String dsName = \"JdbcTestDataSource-0\";\n+  String dsSecret = domainUid.concat(\"-mysql-secrets\");\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for Introspect Version WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // build the clusterview application\n+    Path distDir = buildApplication(Paths.get(APP_DIR, \"clusterview\"),\n+        null, null, \"dist\", domainNamespace);\n+    clusterViewAppPath = Paths.get(distDir.toString(), \"clusterview.war\");\n+    assertTrue(clusterViewAppPath.toFile().exists(), \"Application archive is not available\");\n+\n+    //start two MySQL database instances\n+    mysqlDBPort1 = getNextFreePort(30000, 32767);\n+    createMySQLDB(\"mysqldb-1\", \"root\", \"root123\", mysqlDBPort1, domainNamespace);\n+    mysqlDBPort2 = getNextFreePort(31000, 32767);\n+    createMySQLDB(\"mysqldb-2\", \"root\", \"root456\", mysqlDBPort2, domainNamespace);\n+\n+    dsUrl1 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort1;\n+    dsUrl2 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort2;\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    } else {\n+      // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+\n+    //create and start WebLogic domain\n+    createDomain();\n+    //create a jdbc resource targeted to cluster\n+    createJdbcDataSource(\"root\", \"root123\", mysqlDBPort1);\n+    //deploy application to view server configuration\n+    deployApplication();\n+\n+  }\n+\n+  /**\n+   * Verify the default config before starting any test.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    String maxMessageSize = \"10000000\";\n+    String cpMaxCapacity = \"15\";\n+    String dsUrl = dsUrl1;\n+    verifyConfig(maxMessageSize, cpMaxCapacity, dsUrl, false);\n+\n+  }\n+\n+  /**\n+   * Delete the overrides, secrets and restart domain to get clean state.\n+   */\n+  @AfterEach\n+  public void afterEach() {\n+    deleteConfigMap(overridecm, domainNamespace);\n+    deleteSecret(dsSecret, domainNamespace);\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\"},\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+    restartDomain();\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden dynamically when\n+   * /spec/configuration/overrideDistributionStrategy: field is not set. By default it should be DYNAMIC.\n+   *\n+   * <p>Test sets the /spec/configuration/overridesConfigMap and /spec/configuration/secrets with new configuration\n+   * and new secrets.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are updated\n+   * as expected.\n+   */\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy set to DEFAULT\")\n+  public void testDefaultOverride() {\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    //create config override map and secrets\n+    setupCustomConfigOverrides();\n+\n+    //patch the domain resource with overridesConfigMap, secrets and introspectVersion\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\", \\\"value\\\": [\\\"\" + dsSecret + \"\\\"]  },\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"1\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //print the configuration overrides without asserting\n+    verifyConfig(null, null, null, true);\n+\n+    //workaround for bug - setting overridesConfigMap doesn't apply overrides dynamically, needs restart of server pods", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d793e632fa943aa9202ff865e40398ec2a4f8b2"}, "originalPosition": 307}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM5NzUxMw==", "bodyText": "I still see it is not getting overridden even after waiting for significant amount of time.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r446397513", "createdAt": "2020-06-26T20:34:54Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "diffHunk": "@@ -0,0 +1,1056 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownDomain;\n+import static oracle.weblogic.kubernetes.actions.TestActions.startDomain;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.MySQLDBUtils.createMySQLDB;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static oracle.weblogic.kubernetes.utils.WLSTUtils.executeWLSTScript;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests related to overrideDistributionStrategy attribute.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the overrideDistributionStrategy applies the overrides accordingly to the value set\")\n+@IntegrationTest\n+public class ItConfigDistributionStrategy {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path clusterViewAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  static int mysqlDBPort1;\n+  static int mysqlDBPort2;\n+  static String dsUrl1;\n+  static String dsUrl2;\n+\n+  String dsName = \"JdbcTestDataSource-0\";\n+  String dsSecret = domainUid.concat(\"-mysql-secrets\");\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for Introspect Version WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // build the clusterview application\n+    Path distDir = buildApplication(Paths.get(APP_DIR, \"clusterview\"),\n+        null, null, \"dist\", domainNamespace);\n+    clusterViewAppPath = Paths.get(distDir.toString(), \"clusterview.war\");\n+    assertTrue(clusterViewAppPath.toFile().exists(), \"Application archive is not available\");\n+\n+    //start two MySQL database instances\n+    mysqlDBPort1 = getNextFreePort(30000, 32767);\n+    createMySQLDB(\"mysqldb-1\", \"root\", \"root123\", mysqlDBPort1, domainNamespace);\n+    mysqlDBPort2 = getNextFreePort(31000, 32767);\n+    createMySQLDB(\"mysqldb-2\", \"root\", \"root456\", mysqlDBPort2, domainNamespace);\n+\n+    dsUrl1 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort1;\n+    dsUrl2 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort2;\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    } else {\n+      // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+\n+    //create and start WebLogic domain\n+    createDomain();\n+    //create a jdbc resource targeted to cluster\n+    createJdbcDataSource(\"root\", \"root123\", mysqlDBPort1);\n+    //deploy application to view server configuration\n+    deployApplication();\n+\n+  }\n+\n+  /**\n+   * Verify the default config before starting any test.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    String maxMessageSize = \"10000000\";\n+    String cpMaxCapacity = \"15\";\n+    String dsUrl = dsUrl1;\n+    verifyConfig(maxMessageSize, cpMaxCapacity, dsUrl, false);\n+\n+  }\n+\n+  /**\n+   * Delete the overrides, secrets and restart domain to get clean state.\n+   */\n+  @AfterEach\n+  public void afterEach() {\n+    deleteConfigMap(overridecm, domainNamespace);\n+    deleteSecret(dsSecret, domainNamespace);\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\"},\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+    restartDomain();\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden dynamically when\n+   * /spec/configuration/overrideDistributionStrategy: field is not set. By default it should be DYNAMIC.\n+   *\n+   * <p>Test sets the /spec/configuration/overridesConfigMap and /spec/configuration/secrets with new configuration\n+   * and new secrets.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are updated\n+   * as expected.\n+   */\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy set to DEFAULT\")\n+  public void testDefaultOverride() {\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    //create config override map and secrets\n+    setupCustomConfigOverrides();\n+\n+    //patch the domain resource with overridesConfigMap, secrets and introspectVersion\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\", \\\"value\\\": [\\\"\" + dsSecret + \"\\\"]  },\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"1\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //print the configuration overrides without asserting\n+    verifyConfig(null, null, null, true);\n+\n+    //workaround for bug - setting overridesConfigMap doesn't apply overrides dynamically, needs restart of server pods", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE5MjQzNQ=="}, "originalCommit": {"oid": "6d793e632fa943aa9202ff865e40398ec2a4f8b2"}, "originalPosition": 307}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM5NzY5Mw==", "bodyText": "https://build.weblogick8s.org:8443/job/weblogic-kubernetes-operator-kind-new/548/console", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r446397693", "createdAt": "2020-06-26T20:35:23Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "diffHunk": "@@ -0,0 +1,1056 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownDomain;\n+import static oracle.weblogic.kubernetes.actions.TestActions.startDomain;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.MySQLDBUtils.createMySQLDB;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static oracle.weblogic.kubernetes.utils.WLSTUtils.executeWLSTScript;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests related to overrideDistributionStrategy attribute.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the overrideDistributionStrategy applies the overrides accordingly to the value set\")\n+@IntegrationTest\n+public class ItConfigDistributionStrategy {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path clusterViewAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  static int mysqlDBPort1;\n+  static int mysqlDBPort2;\n+  static String dsUrl1;\n+  static String dsUrl2;\n+\n+  String dsName = \"JdbcTestDataSource-0\";\n+  String dsSecret = domainUid.concat(\"-mysql-secrets\");\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for Introspect Version WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // build the clusterview application\n+    Path distDir = buildApplication(Paths.get(APP_DIR, \"clusterview\"),\n+        null, null, \"dist\", domainNamespace);\n+    clusterViewAppPath = Paths.get(distDir.toString(), \"clusterview.war\");\n+    assertTrue(clusterViewAppPath.toFile().exists(), \"Application archive is not available\");\n+\n+    //start two MySQL database instances\n+    mysqlDBPort1 = getNextFreePort(30000, 32767);\n+    createMySQLDB(\"mysqldb-1\", \"root\", \"root123\", mysqlDBPort1, domainNamespace);\n+    mysqlDBPort2 = getNextFreePort(31000, 32767);\n+    createMySQLDB(\"mysqldb-2\", \"root\", \"root456\", mysqlDBPort2, domainNamespace);\n+\n+    dsUrl1 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort1;\n+    dsUrl2 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort2;\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    } else {\n+      // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+\n+    //create and start WebLogic domain\n+    createDomain();\n+    //create a jdbc resource targeted to cluster\n+    createJdbcDataSource(\"root\", \"root123\", mysqlDBPort1);\n+    //deploy application to view server configuration\n+    deployApplication();\n+\n+  }\n+\n+  /**\n+   * Verify the default config before starting any test.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    String maxMessageSize = \"10000000\";\n+    String cpMaxCapacity = \"15\";\n+    String dsUrl = dsUrl1;\n+    verifyConfig(maxMessageSize, cpMaxCapacity, dsUrl, false);\n+\n+  }\n+\n+  /**\n+   * Delete the overrides, secrets and restart domain to get clean state.\n+   */\n+  @AfterEach\n+  public void afterEach() {\n+    deleteConfigMap(overridecm, domainNamespace);\n+    deleteSecret(dsSecret, domainNamespace);\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\"},\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+    restartDomain();\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden dynamically when\n+   * /spec/configuration/overrideDistributionStrategy: field is not set. By default it should be DYNAMIC.\n+   *\n+   * <p>Test sets the /spec/configuration/overridesConfigMap and /spec/configuration/secrets with new configuration\n+   * and new secrets.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are updated\n+   * as expected.\n+   */\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy set to DEFAULT\")\n+  public void testDefaultOverride() {\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    //create config override map and secrets\n+    setupCustomConfigOverrides();\n+\n+    //patch the domain resource with overridesConfigMap, secrets and introspectVersion\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\", \\\"value\\\": [\\\"\" + dsSecret + \"\\\"]  },\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"1\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //print the configuration overrides without asserting\n+    verifyConfig(null, null, null, true);\n+\n+    //workaround for bug - setting overridesConfigMap doesn't apply overrides dynamically, needs restart of server pods", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE5MjQzNQ=="}, "originalCommit": {"oid": "6d793e632fa943aa9202ff865e40398ec2a4f8b2"}, "originalPosition": 307}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MDc0ODg5OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNjoyOTowOVrOGpnK7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxOTozMDozNVrOGpsWxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI4NjU3NA==", "bodyText": "fix comment - restart to start", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r446286574", "createdAt": "2020-06-26T16:29:09Z", "author": {"login": "bhavaniravichandran"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "diffHunk": "@@ -529,7 +529,7 @@ private void restartDomain1AndVerifyNoImpactOnDomain2() {\n \n     // restart domain1\n     logger.info(\"Restarting domain1\");\n-    assertTrue(restartDomain(domain1Uid, domain1Namespace),\n+    assertTrue(startDomain(domain1Uid, domain1Namespace),\n         String.format(\"restart domain %s in namespace %s failed\", domain1Uid, domain1Namespace));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d793e632fa943aa9202ff865e40398ec2a4f8b2"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM3MTUyNA==", "bodyText": "Fixed.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r446371524", "createdAt": "2020-06-26T19:30:35Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "diffHunk": "@@ -529,7 +529,7 @@ private void restartDomain1AndVerifyNoImpactOnDomain2() {\n \n     // restart domain1\n     logger.info(\"Restarting domain1\");\n-    assertTrue(restartDomain(domain1Uid, domain1Namespace),\n+    assertTrue(startDomain(domain1Uid, domain1Namespace),\n         String.format(\"restart domain %s in namespace %s failed\", domain1Uid, domain1Namespace));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI4NjU3NA=="}, "originalCommit": {"oid": "6d793e632fa943aa9202ff865e40398ec2a4f8b2"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MDc1ODcxOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/MySQLDBUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNjozMjoyMFrOGpnRSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxOTozMTo1N1rOGpsY_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI4ODIwMg==", "bodyText": "Change it to createDBService? When called from a test, it will be clear that a db service is being created.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r446288202", "createdAt": "2020-06-26T16:32:20Z", "author": {"login": "bhavaniravichandran"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/MySQLDBUtils.java", "diffHunk": "@@ -0,0 +1,130 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1EnvVarSource;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretKeySelector;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to create MySQL database.\n+ */\n+public class MySQLDBUtils {\n+\n+  /**\n+   * Create and start a MySQL database pod.\n+   *\n+   * @param name      name of the db pod\n+   * @param user      username for the database\n+   * @param password  password for the database\n+   * @param nodePort  node port of db service\n+   * @param namespace name of the namespace in which to create MySQL database\n+   */\n+  public static void createMySQLDB(String name, String user, String password, int nodePort, String namespace) {\n+\n+    String uniqueName = Namespace.uniqueName();\n+    String secretName = name.concat(\"-secret-\").concat(uniqueName);\n+    String serviceName = name.concat(\"-external-\").concat(uniqueName);\n+\n+    createSecret(secretName, user, password, namespace);\n+    createService(serviceName, name, namespace, nodePort);\n+    startMySQLDB(name, secretName, namespace);\n+\n+  }\n+\n+  //create the database pod\n+  private static void startMySQLDB(String name, String secretName, String namespace) {\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"app\", name);\n+    V1Pod mysqlPod = new V1Pod()\n+        .metadata(new V1ObjectMeta()\n+            .name(name)\n+            .namespace(namespace)\n+            .labels(labels))\n+        .spec(new V1PodSpec()\n+            .terminationGracePeriodSeconds(5L)\n+            .containers(Arrays.asList(new V1Container()\n+                .image(\"mysql:5.6\")\n+                .name(\"mysql\")\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"MYSQL_ROOT_PASSWORD\")\n+                    .valueFrom(new V1EnvVarSource()\n+                        .secretKeyRef(new V1SecretKeySelector()\n+                            .name(secretName)\n+                            .key(\"root-password\"))))\n+                .ports(Arrays.asList(new V1ContainerPort()\n+                    .name(\"mysql\")\n+                    .containerPort(3306))))));\n+    V1Pod pod = assertDoesNotThrow(() -> Kubernetes.createPod(namespace, mysqlPod));\n+    CommonTestUtils.checkPodReady(pod.getMetadata().getName(), null, namespace);\n+  }\n+\n+  //create services for MySQL database\n+  private static void createService(String serviceName, String selectorName, String namespace, int port) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d793e632fa943aa9202ff865e40398ec2a4f8b2"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM3MjA5NQ==", "bodyText": "fixed.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r446372095", "createdAt": "2020-06-26T19:31:57Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/MySQLDBUtils.java", "diffHunk": "@@ -0,0 +1,130 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1EnvVarSource;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretKeySelector;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to create MySQL database.\n+ */\n+public class MySQLDBUtils {\n+\n+  /**\n+   * Create and start a MySQL database pod.\n+   *\n+   * @param name      name of the db pod\n+   * @param user      username for the database\n+   * @param password  password for the database\n+   * @param nodePort  node port of db service\n+   * @param namespace name of the namespace in which to create MySQL database\n+   */\n+  public static void createMySQLDB(String name, String user, String password, int nodePort, String namespace) {\n+\n+    String uniqueName = Namespace.uniqueName();\n+    String secretName = name.concat(\"-secret-\").concat(uniqueName);\n+    String serviceName = name.concat(\"-external-\").concat(uniqueName);\n+\n+    createSecret(secretName, user, password, namespace);\n+    createService(serviceName, name, namespace, nodePort);\n+    startMySQLDB(name, secretName, namespace);\n+\n+  }\n+\n+  //create the database pod\n+  private static void startMySQLDB(String name, String secretName, String namespace) {\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"app\", name);\n+    V1Pod mysqlPod = new V1Pod()\n+        .metadata(new V1ObjectMeta()\n+            .name(name)\n+            .namespace(namespace)\n+            .labels(labels))\n+        .spec(new V1PodSpec()\n+            .terminationGracePeriodSeconds(5L)\n+            .containers(Arrays.asList(new V1Container()\n+                .image(\"mysql:5.6\")\n+                .name(\"mysql\")\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"MYSQL_ROOT_PASSWORD\")\n+                    .valueFrom(new V1EnvVarSource()\n+                        .secretKeyRef(new V1SecretKeySelector()\n+                            .name(secretName)\n+                            .key(\"root-password\"))))\n+                .ports(Arrays.asList(new V1ContainerPort()\n+                    .name(\"mysql\")\n+                    .containerPort(3306))))));\n+    V1Pod pod = assertDoesNotThrow(() -> Kubernetes.createPod(namespace, mysqlPod));\n+    CommonTestUtils.checkPodReady(pod.getMetadata().getName(), null, namespace);\n+  }\n+\n+  //create services for MySQL database\n+  private static void createService(String serviceName, String selectorName, String namespace, int port) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI4ODIwMg=="}, "originalCommit": {"oid": "6d793e632fa943aa9202ff865e40398ec2a4f8b2"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MDc2MTcwOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/MySQLDBUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNjozMzoxMFrOGpnTFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxOTozMjowNFrOGpsZMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI4ODY2MA==", "bodyText": "createDBSecret?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r446288660", "createdAt": "2020-06-26T16:33:10Z", "author": {"login": "bhavaniravichandran"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/MySQLDBUtils.java", "diffHunk": "@@ -0,0 +1,130 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1EnvVarSource;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretKeySelector;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to create MySQL database.\n+ */\n+public class MySQLDBUtils {\n+\n+  /**\n+   * Create and start a MySQL database pod.\n+   *\n+   * @param name      name of the db pod\n+   * @param user      username for the database\n+   * @param password  password for the database\n+   * @param nodePort  node port of db service\n+   * @param namespace name of the namespace in which to create MySQL database\n+   */\n+  public static void createMySQLDB(String name, String user, String password, int nodePort, String namespace) {\n+\n+    String uniqueName = Namespace.uniqueName();\n+    String secretName = name.concat(\"-secret-\").concat(uniqueName);\n+    String serviceName = name.concat(\"-external-\").concat(uniqueName);\n+\n+    createSecret(secretName, user, password, namespace);\n+    createService(serviceName, name, namespace, nodePort);\n+    startMySQLDB(name, secretName, namespace);\n+\n+  }\n+\n+  //create the database pod\n+  private static void startMySQLDB(String name, String secretName, String namespace) {\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"app\", name);\n+    V1Pod mysqlPod = new V1Pod()\n+        .metadata(new V1ObjectMeta()\n+            .name(name)\n+            .namespace(namespace)\n+            .labels(labels))\n+        .spec(new V1PodSpec()\n+            .terminationGracePeriodSeconds(5L)\n+            .containers(Arrays.asList(new V1Container()\n+                .image(\"mysql:5.6\")\n+                .name(\"mysql\")\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"MYSQL_ROOT_PASSWORD\")\n+                    .valueFrom(new V1EnvVarSource()\n+                        .secretKeyRef(new V1SecretKeySelector()\n+                            .name(secretName)\n+                            .key(\"root-password\"))))\n+                .ports(Arrays.asList(new V1ContainerPort()\n+                    .name(\"mysql\")\n+                    .containerPort(3306))))));\n+    V1Pod pod = assertDoesNotThrow(() -> Kubernetes.createPod(namespace, mysqlPod));\n+    CommonTestUtils.checkPodReady(pod.getMetadata().getName(), null, namespace);\n+  }\n+\n+  //create services for MySQL database\n+  private static void createService(String serviceName, String selectorName, String namespace, int port) {\n+\n+    boolean service = false;\n+    try {\n+      Map<String, String> selector = new HashMap<>();\n+      selector.put(\"app\", selectorName);\n+      service = TestActions.createService(new V1Service()\n+          .metadata(new V1ObjectMeta()\n+              .name(serviceName)\n+              .namespace(namespace))\n+          .spec(new V1ServiceSpec()\n+              .type(\"NodePort\")\n+              .ports(Arrays.asList(new V1ServicePort()\n+                  .port(3306)\n+                  .protocol(\"TCP\")\n+                  .targetPort(new IntOrString(3306))\n+                  .nodePort(port)))\n+              .selector(selector)));\n+    } catch (ApiException ex) {\n+      Logger.getLogger(MySQLDBUtils.class.getName()).log(Level.SEVERE, null, ex);\n+    }\n+    assertTrue(service, \"Service creation for mysql failed\");\n+  }\n+\n+  //create secrets\n+  private static void createSecret(String secretName, String user, String password, String namespace) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d793e632fa943aa9202ff865e40398ec2a4f8b2"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM3MjE0NA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r446372144", "createdAt": "2020-06-26T19:32:04Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/MySQLDBUtils.java", "diffHunk": "@@ -0,0 +1,130 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1EnvVarSource;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretKeySelector;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to create MySQL database.\n+ */\n+public class MySQLDBUtils {\n+\n+  /**\n+   * Create and start a MySQL database pod.\n+   *\n+   * @param name      name of the db pod\n+   * @param user      username for the database\n+   * @param password  password for the database\n+   * @param nodePort  node port of db service\n+   * @param namespace name of the namespace in which to create MySQL database\n+   */\n+  public static void createMySQLDB(String name, String user, String password, int nodePort, String namespace) {\n+\n+    String uniqueName = Namespace.uniqueName();\n+    String secretName = name.concat(\"-secret-\").concat(uniqueName);\n+    String serviceName = name.concat(\"-external-\").concat(uniqueName);\n+\n+    createSecret(secretName, user, password, namespace);\n+    createService(serviceName, name, namespace, nodePort);\n+    startMySQLDB(name, secretName, namespace);\n+\n+  }\n+\n+  //create the database pod\n+  private static void startMySQLDB(String name, String secretName, String namespace) {\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"app\", name);\n+    V1Pod mysqlPod = new V1Pod()\n+        .metadata(new V1ObjectMeta()\n+            .name(name)\n+            .namespace(namespace)\n+            .labels(labels))\n+        .spec(new V1PodSpec()\n+            .terminationGracePeriodSeconds(5L)\n+            .containers(Arrays.asList(new V1Container()\n+                .image(\"mysql:5.6\")\n+                .name(\"mysql\")\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"MYSQL_ROOT_PASSWORD\")\n+                    .valueFrom(new V1EnvVarSource()\n+                        .secretKeyRef(new V1SecretKeySelector()\n+                            .name(secretName)\n+                            .key(\"root-password\"))))\n+                .ports(Arrays.asList(new V1ContainerPort()\n+                    .name(\"mysql\")\n+                    .containerPort(3306))))));\n+    V1Pod pod = assertDoesNotThrow(() -> Kubernetes.createPod(namespace, mysqlPod));\n+    CommonTestUtils.checkPodReady(pod.getMetadata().getName(), null, namespace);\n+  }\n+\n+  //create services for MySQL database\n+  private static void createService(String serviceName, String selectorName, String namespace, int port) {\n+\n+    boolean service = false;\n+    try {\n+      Map<String, String> selector = new HashMap<>();\n+      selector.put(\"app\", selectorName);\n+      service = TestActions.createService(new V1Service()\n+          .metadata(new V1ObjectMeta()\n+              .name(serviceName)\n+              .namespace(namespace))\n+          .spec(new V1ServiceSpec()\n+              .type(\"NodePort\")\n+              .ports(Arrays.asList(new V1ServicePort()\n+                  .port(3306)\n+                  .protocol(\"TCP\")\n+                  .targetPort(new IntOrString(3306))\n+                  .nodePort(port)))\n+              .selector(selector)));\n+    } catch (ApiException ex) {\n+      Logger.getLogger(MySQLDBUtils.class.getName()).log(Level.SEVERE, null, ex);\n+    }\n+    assertTrue(service, \"Service creation for mysql failed\");\n+  }\n+\n+  //create secrets\n+  private static void createSecret(String secretName, String user, String password, String namespace) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI4ODY2MA=="}, "originalCommit": {"oid": "6d793e632fa943aa9202ff865e40398ec2a4f8b2"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MDgzNzk3OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNjo1NjoxN1rOGpoDCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxOToyOTozMFrOGpsU0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMwMDkzNg==", "bodyText": "Shouldn't this be in utils?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r446300936", "createdAt": "2020-06-26T16:56:17Z", "author": {"login": "bhavaniravichandran"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "diffHunk": "@@ -0,0 +1,1056 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownDomain;\n+import static oracle.weblogic.kubernetes.actions.TestActions.startDomain;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.MySQLDBUtils.createMySQLDB;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static oracle.weblogic.kubernetes.utils.WLSTUtils.executeWLSTScript;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests related to overrideDistributionStrategy attribute.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the overrideDistributionStrategy applies the overrides accordingly to the value set\")\n+@IntegrationTest\n+public class ItConfigDistributionStrategy {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path clusterViewAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  static int mysqlDBPort1;\n+  static int mysqlDBPort2;\n+  static String dsUrl1;\n+  static String dsUrl2;\n+\n+  String dsName = \"JdbcTestDataSource-0\";\n+  String dsSecret = domainUid.concat(\"-mysql-secrets\");\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for Introspect Version WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // build the clusterview application\n+    Path distDir = buildApplication(Paths.get(APP_DIR, \"clusterview\"),\n+        null, null, \"dist\", domainNamespace);\n+    clusterViewAppPath = Paths.get(distDir.toString(), \"clusterview.war\");\n+    assertTrue(clusterViewAppPath.toFile().exists(), \"Application archive is not available\");\n+\n+    //start two MySQL database instances\n+    mysqlDBPort1 = getNextFreePort(30000, 32767);\n+    createMySQLDB(\"mysqldb-1\", \"root\", \"root123\", mysqlDBPort1, domainNamespace);\n+    mysqlDBPort2 = getNextFreePort(31000, 32767);\n+    createMySQLDB(\"mysqldb-2\", \"root\", \"root456\", mysqlDBPort2, domainNamespace);\n+\n+    dsUrl1 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort1;\n+    dsUrl2 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort2;\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    } else {\n+      // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+\n+    //create and start WebLogic domain\n+    createDomain();\n+    //create a jdbc resource targeted to cluster\n+    createJdbcDataSource(\"root\", \"root123\", mysqlDBPort1);\n+    //deploy application to view server configuration\n+    deployApplication();\n+\n+  }\n+\n+  /**\n+   * Verify the default config before starting any test.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    String maxMessageSize = \"10000000\";\n+    String cpMaxCapacity = \"15\";\n+    String dsUrl = dsUrl1;\n+    verifyConfig(maxMessageSize, cpMaxCapacity, dsUrl, false);\n+\n+  }\n+\n+  /**\n+   * Delete the overrides, secrets and restart domain to get clean state.\n+   */\n+  @AfterEach\n+  public void afterEach() {\n+    deleteConfigMap(overridecm, domainNamespace);\n+    deleteSecret(dsSecret, domainNamespace);\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\"},\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+    restartDomain();\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden dynamically when\n+   * /spec/configuration/overrideDistributionStrategy: field is not set. By default it should be DYNAMIC.\n+   *\n+   * <p>Test sets the /spec/configuration/overridesConfigMap and /spec/configuration/secrets with new configuration\n+   * and new secrets.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are updated\n+   * as expected.\n+   */\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy set to DEFAULT\")\n+  public void testDefaultOverride() {\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    //create config override map and secrets\n+    setupCustomConfigOverrides();\n+\n+    //patch the domain resource with overridesConfigMap, secrets and introspectVersion\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\", \\\"value\\\": [\\\"\" + dsSecret + \"\\\"]  },\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"1\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //print the configuration overrides without asserting\n+    verifyConfig(null, null, null, true);\n+\n+    //workaround for bug - setting overridesConfigMap doesn't apply overrides dynamically, needs restart of server pods\n+    restartDomain(); // remove after the above bug is fixed\n+\n+    verifyConfigOverrides();\n+  }\n+\n+  /**\n+   * Test server configuration and datasource configurations are dynamically overridden when\n+   * /spec/configuration/overrideDistributionStrategy is set to DYNAMIC.\n+   *\n+   * <p>Test sets the above field to DYNAMIC and overrides the /spec/configuration/overridesConfigMap and\n+   * /spec/configuration/secrets with new configuration and new secrets.\n+   *\n+   * <p>Verifies after introspector runs and the server configuration and JDBC datasource configurations are\n+   * updated as expected.\n+   */\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value DYNAMIC\")\n+  public void testDynamicOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: DYNAMIC\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"DYNAMIC\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?\n+    restartDomain(); // if above is a bug, remove this after the above bug is fixed\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    //create config override map and secrets\n+    setupCustomConfigOverrides();\n+\n+    //patch the domain resource with overridesConfigMap, secrets and introspectVersion\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\", \\\"value\\\": [\\\"\" + dsSecret + \"\\\"]  },\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"2\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //print the configuration overrides without asserting\n+    verifyConfig(null, null, null, true);\n+\n+    //workaround for bug - setting overridesConfigMap doesn't apply overrides dynamically, needs restart of server pods\n+    restartDomain(); // remove after the above bug is fixed\n+\n+    verifyConfigOverrides();\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden on restart of pods when\n+   * /spec/configuration/overrideDistributionStrategy is set to ON_RESTART.\n+   *\n+   * <p>Test sets the above field to ON_RESTART and overrides the /spec/configuration/overridesConfigMap and\n+   * /spec/configuration/secrets with new configuration and new secrets.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are\n+   * not updated. After domain restart the overrides are applied.\n+   */\n+  @Order(3)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value ON_RESTART\")\n+  public void testOnRestartOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: ON_RESTART\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"ON_RESTART\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?\n+    restartDomain(); // if above is a bug, remove this after the above bug is fixed\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    //create config override map and secrets\n+    setupCustomConfigOverrides();\n+\n+    //patch the domain resource with overridesConfigMap, secrets and introspectVersion\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\", \\\"value\\\": [\\\"\" + dsSecret + \"\\\"]  },\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"4\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //print the configuration overrides without asserting\n+    verifyConfig(null, null, null, true);\n+\n+    //verify the overrides are not applied\n+    verifyConfig(\"10000000\", \"15\", dsUrl1, false);\n+\n+    //restart domain for the distributionstrategy to take effect\n+    restartDomain();\n+\n+    //verify on restart the overrides are applied\n+    verifyConfigOverrides();\n+  }\n+\n+  /**\n+   * Test patching the domain with values for /spec/configuration/overrideDistributionStrategy field\n+   * anything other than DYNAMIC or ON_RESTART fails.\n+   *\n+   * <p>Test tries to set the above field to RESTART and asserts the patching fails.\n+   */\n+  @Order(4)\n+  @Test\n+  @DisplayName(\"Test invalid overrideDistributionStrategy value RESTART\")\n+  public void testOverrideNegative() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: RESTART\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"RESTART\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertFalse(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Patch domain with invalid overrideDistributionStrategy succeeded.\");\n+\n+    //verify the overrides are not applied and original configuration is still effective\n+    verifyConfig(\"10000000\", \"15\", dsUrl1, false);\n+  }\n+\n+  //verify the configuration overrides for server and JDBC datasource\n+  private void verifyConfigOverrides() {\n+\n+    String maxMessageSize = \"78787878\";\n+    String cpMaxCapacity = \"12\";\n+    String dsUrl = dsUrl2;\n+    verifyConfig(maxMessageSize, cpMaxCapacity, dsUrl, false);\n+  }\n+\n+  //use the http client and access the clusterview application to get server configuration\n+  //and JDBC datasource configuration.\n+  private void verifyConfig(String maxMessageSize, String cpMaxCapacity, String dsUrl, boolean debug) {\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(domainNamespace, adminServerPodName\n+            + \"-external\",\n+            \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    //verify server attribute MaxMessageSize\n+    String appURI = \"/clusterview/ConfigServlet?\"\n+        + \"attributeTest=true&\"\n+        + \"serverType=adminserver&\"\n+        + \"serverName=\" + adminServerName;\n+    String url = \"http://\" + K8S_NODEPORT_HOST + \":\" + serviceNodePort + appURI;\n+    HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(url, true));\n+\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    if (!debug) {\n+      assertTrue(response.body().contains(maxMessageSize), \"Didn't get MaxMessageSize=\" + maxMessageSize);\n+    }\n+\n+    //verify datasource attributes\n+    appURI = \"/clusterview/ConfigServlet?\"\n+        + \"resTest=true&\"\n+        + \"resName=\" + dsName;\n+    String dsurl = \"http://\" + K8S_NODEPORT_HOST + \":\" + serviceNodePort + appURI;\n+    response = assertDoesNotThrow(() -> OracleHttpClient.get(dsurl, true));\n+\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    if (!debug) {\n+      assertTrue(response.body().contains(\"getMaxCapacity:\" + cpMaxCapacity),\n+          \"Did get getMaxCapacity:\" + cpMaxCapacity);\n+      assertTrue(response.body().contains(\"Url:\" + dsUrl), \"Didn't get Url:\" + dsUrl);\n+    }\n+\n+    //test connection pool\n+    appURI = \"/clusterview/ConfigServlet?\"\n+        + \"dsTest=true&\"\n+        + \"dsName=\" + dsName + \"&\"\n+        + \"serverName=\" + managedServerNameBase + 1;\n+    String dstesturl = \"http://\" + K8S_NODEPORT_HOST + \":\" + serviceNodePort + appURI;\n+    response = assertDoesNotThrow(() -> OracleHttpClient.get(dstesturl, true));\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    if (!debug) {\n+      assertTrue(response.body().contains(\"Connection successful\"), \"Didn't get Connection successful\");\n+    }\n+  }\n+\n+  //store pod creation timestamps for podstate check\n+  private void storePodCreationTimestamps() {\n+    // get the pod creation time stamps\n+    podTimestamps = new LinkedHashMap<>();\n+    // get the creation time of the admin server pod before patching\n+    DateTime adminPodCreationTime = getPodCreationTime(domainNamespace, adminServerPodName);\n+    podTimestamps.put(adminServerPodName, adminPodCreationTime);\n+    // get the creation time of the managed server pods before patching\n+    for (int i = 1; i <= replicaCount; i++) {\n+      podTimestamps.put(managedServerPodNamePrefix + i,\n+          getPodCreationTime(domainNamespace, managedServerPodNamePrefix + i));\n+    }\n+  }\n+\n+  //check if the pods are restarted by comparing the pod creationtimestamp.\n+  private void verifyPodsStateNotChanged() {\n+    logger.info(\"Verifying the WebLogic server pod states are not changed\");\n+    for (Map.Entry<String, DateTime> entry : podTimestamps.entrySet()) {\n+      String podName = (String) entry.getKey();\n+      DateTime creationTimestamp = (DateTime) entry.getValue();\n+      assertTrue(podStateNotChanged(podName, domainUid, domainNamespace,\n+          creationTimestamp), \"Pod is restarted\");\n+    }\n+  }\n+\n+  //verify the introspector pod is created and run\n+  private void verifyIntrospectorRuns() {\n+    //verify the introspector pod is created and runs\n+    logger.info(\"Verifying introspector pod is created, runs and deleted\");\n+    String introspectPodName = domainUid + \"-\" + \"introspect-domain-job\";\n+    checkPodExists(introspectPodName, domainUid, domainNamespace);\n+    checkPodDoesNotExist(introspectPodName, domainUid, domainNamespace);\n+  }\n+\n+  //method to create custom configuration overrides\n+  private void setupCustomConfigOverrides() {\n+    logger.info(\"Creating config overrides\");\n+\n+    //create new secrets for jdbc datasource\n+    Map<String, String> secretMap = new HashMap<>();\n+    secretMap.put(\"dbusername\", \"root\");\n+    secretMap.put(\"dbpassword\", \"root456\");\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(dsSecret)\n+            .namespace(domainNamespace))\n+        .stringData(secretMap)), \"Creating secret for datasource failed.\");\n+    assertTrue(secretCreated, String.format(\"creating secret failed %s\", dsSecret));\n+\n+    //copy the template datasource file for override after replacing JDBC_URL with new datasource url\n+    Path srcDsOverrideFile = Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-0.xml\");\n+    Path dstDsOverrideFile = Paths.get(WORK_DIR, \"jdbc-JdbcTestDataSource-0.xml\");\n+    String tempString = assertDoesNotThrow(()\n+        -> Files.readString(srcDsOverrideFile).replaceAll(\"JDBC_URL\", dsUrl2));\n+    assertDoesNotThrow(()\n+        -> Files.write(dstDsOverrideFile, tempString.getBytes(StandardCharsets.UTF_8)));\n+\n+    //create custom config override map with all the files\n+    ArrayList<Path> configfiles = new ArrayList<>();\n+    configfiles.add(dstDsOverrideFile);\n+    configfiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    configfiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+    createConfigMapFromFiles(overridecm, configfiles, domainNamespace);\n+\n+  }\n+\n+  //create a standard WebLogic domain.\n+  private void createDomain() {\n+\n+    // create WebLogic domain credential secret\n+    createSecretWithUsernamePassword(wlSecretName, domainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, domainNamespace);\n+\n+    t3ChannelPort = getNextFreePort(30000, 32767);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = assertDoesNotThrow(()\n+        -> File.createTempFile(\"domain\", \"properties\"),\n+        \"Failed to create domain properties file\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", Integer.toString(managedServerPort));\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"2\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    assertDoesNotThrow(()\n+        -> p.store(new FileOutputStream(domainPropertiesFile), \"domain properties file\"),\n+        \"Failed to write domain properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, domainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .configuration(new Configuration()\n+                .overrideDistributionStrategy(\"DYNAMIC\"))\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid) // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    createDomainAndVerify(domain, domainNamespace);\n+\n+    // verify the admin server service created\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // verify admin server pod is ready\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPodNamePrefix + i, domainNamespace);\n+    }\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  //deploy application clusterview.war to domain\n+  private void deployApplication() {\n+    logger.info(\"Getting node port for T3 channel\");\n+    int t3channelNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"t3channel\"),\n+        \"Getting admin server t3channel node port failed\");\n+    assertNotEquals(-1, t3ChannelPort, \"admin server t3channelport is not valid\");\n+\n+    //deploy application\n+    logger.info(\"Deploying webapp {0} to domain\", clusterViewAppPath);\n+    deployUsingWlst(K8S_NODEPORT_HOST, Integer.toString(t3channelNodePort),\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, clusterName + \",\" + adminServerName, clusterViewAppPath,\n+        domainNamespace);\n+  }\n+\n+  //restart pods by manipulating the serverStartPolicy to NEVER and IF_NEEDED\n+  private void restartDomain() {\n+    logger.info(\"Restarting domain {0}\", domainNamespace);\n+    shutdownDomain(domainUid, domainNamespace);\n+\n+    logger.info(\"Checking for admin server pod shutdown\");\n+    checkPodDoesNotExist(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Checking managed server pods were shutdown\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodDoesNotExist(managedServerPodNamePrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    startDomain(domainUid, domainNamespace);\n+    logger.info(\"Checking for admin server pod readiness\");\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Checking for managed servers pod readiness\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodReady(managedServerPodNamePrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  //create a JDBC datasource targeted to cluster.\n+  private void createJdbcDataSource(String user, String password, int mySQLNodePort) {\n+\n+    try {\n+      String jdbcDsUrl = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mySQLNodePort;\n+\n+      // create a temporary WebLogic domain property file\n+      File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+      Properties p = new Properties();\n+      p.setProperty(\"admin_host\", K8S_NODEPORT_HOST);\n+      p.setProperty(\"admin_port\", Integer.toString(t3ChannelPort));\n+      p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+      p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+      p.setProperty(\"dsName\", dsName);\n+      p.setProperty(\"dsUrl\", jdbcDsUrl);\n+      p.setProperty(\"dsDriver\", \"com.mysql.cj.jdbc.Driver\");\n+      p.setProperty(\"dsUser\", user);\n+      p.setProperty(\"dsPassword\", password);\n+      p.setProperty(\"dsTarget\", clusterName);\n+      p.store(new FileOutputStream(domainPropertiesFile), \"domain properties file\");\n+\n+      // WLST script for creating jdbc datasource\n+      Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"create-jdbc-resource.py\");\n+      executeWLSTScript(wlstScript, domainPropertiesFile.toPath(), domainNamespace);\n+    } catch (IOException ex) {\n+      logger.severe(ex.getMessage());\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain on a persistent volume by doing the following. Create a configmap containing WLST script\n+   * and property file. Create a Kubernetes job to create domain on persistent volume.\n+   *\n+   * @param wlstScriptFile python script to create domain\n+   * @param domainPropertiesFile properties file containing domain configuration\n+   * @param pvName name of the persistent volume to create domain in\n+   * @param pvcName name of the persistent volume claim\n+   * @param namespace name of the domain namespace in which the job is created\n+   */\n+  private void createDomainOnPVUsingWlst(Path wlstScriptFile, Path domainPropertiesFile,\n+      String pvName, String pvcName, String namespace) {\n+    logger.info(\"Preparing to run create domain job using WLST\");\n+\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(wlstScriptFile);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Creating a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles, namespace),\n+        \"Create configmap for domain creation failed\");\n+\n+    // create a V1Container with specific scripts and properties for creating domain\n+    V1Container jobCreationContainer = new V1Container()\n+        .addCommandItem(\"/bin/sh\")\n+        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+        .addArgsItem(\"/u01/weblogic/\" + wlstScriptFile.getFileName()) //wlst.sh\n+        // script\n+        .addArgsItem(\"-skipWLSModuleScanning\")\n+        .addArgsItem(\"-loadProperties\")\n+        .addArgsItem(\"/u01/weblogic/\" + domainPropertiesFile.getFileName());\n+    //domain property file\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    createDomainJob(pvName, pvcName, domainScriptConfigMapName, namespace, jobCreationContainer);\n+\n+  }\n+\n+  /**\n+   * Create configmap containing domain creation scripts.\n+   *\n+   * @param configMapName name of the configmap to create\n+   * @param files files to add in configmap\n+   * @param namespace name of the namespace in which to create configmap\n+   * @throws IOException when reading the domain script files fail\n+   * @throws ApiException if create configmap fails\n+   */\n+  private void createConfigMapForDomainCreation(String configMapName, List<Path> files, String namespace)\n+      throws ApiException, IOException {\n+    logger.info(\"Creating configmap {0}\", configMapName);\n+\n+    Path domainScriptsDir = Files.createDirectories(\n+        Paths.get(TestConstants.LOGS_DIR, this.getClass().getSimpleName(), namespace));\n+\n+    // add domain creation scripts and properties files to the configmap\n+    Map<String, String> data = new HashMap<>();\n+    for (Path file : files) {\n+      logger.info(\"Adding file {0} in configmap\", file);\n+      data.put(file.getFileName().toString(), Files.readString(file));\n+      logger.info(\"Making a copy of file {0} to {1} for diagnostic purposes\", file,\n+          domainScriptsDir.resolve(file.getFileName()));\n+      Files.copy(file, domainScriptsDir.resolve(file.getFileName()));\n+    }\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .name(configMapName)\n+        .namespace(namespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Failed to create configmap %s with files %s\", configMapName, files));\n+    assertTrue(cmCreated, String.format(\"Failed while creating ConfigMap %s\", configMapName));\n+  }\n+\n+  /**\n+   * Create a job to create a domain in persistent volume.\n+   *\n+   * @param pvName name of the persistent volume to create domain in\n+   * @param pvcName name of the persistent volume claim\n+   * @param domainScriptCM configmap holding domain creation script files\n+   * @param namespace name of the domain namespace in which the job is created\n+   * @param jobContainer V1Container with job commands to create domain\n+   */\n+  private void createDomainJob(String pvName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d793e632fa943aa9202ff865e40398ec2a4f8b2"}, "originalPosition": 859}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM3MTAyNQ==", "bodyText": "yeah lot of the code can be moved to utils. For now I will keep this here.\nLater on I will create a JIRA for refactoring all IT classes which has these methods.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r446371025", "createdAt": "2020-06-26T19:29:30Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "diffHunk": "@@ -0,0 +1,1056 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownDomain;\n+import static oracle.weblogic.kubernetes.actions.TestActions.startDomain;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.MySQLDBUtils.createMySQLDB;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static oracle.weblogic.kubernetes.utils.WLSTUtils.executeWLSTScript;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests related to overrideDistributionStrategy attribute.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the overrideDistributionStrategy applies the overrides accordingly to the value set\")\n+@IntegrationTest\n+public class ItConfigDistributionStrategy {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path clusterViewAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  static int mysqlDBPort1;\n+  static int mysqlDBPort2;\n+  static String dsUrl1;\n+  static String dsUrl2;\n+\n+  String dsName = \"JdbcTestDataSource-0\";\n+  String dsSecret = domainUid.concat(\"-mysql-secrets\");\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for Introspect Version WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // build the clusterview application\n+    Path distDir = buildApplication(Paths.get(APP_DIR, \"clusterview\"),\n+        null, null, \"dist\", domainNamespace);\n+    clusterViewAppPath = Paths.get(distDir.toString(), \"clusterview.war\");\n+    assertTrue(clusterViewAppPath.toFile().exists(), \"Application archive is not available\");\n+\n+    //start two MySQL database instances\n+    mysqlDBPort1 = getNextFreePort(30000, 32767);\n+    createMySQLDB(\"mysqldb-1\", \"root\", \"root123\", mysqlDBPort1, domainNamespace);\n+    mysqlDBPort2 = getNextFreePort(31000, 32767);\n+    createMySQLDB(\"mysqldb-2\", \"root\", \"root456\", mysqlDBPort2, domainNamespace);\n+\n+    dsUrl1 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort1;\n+    dsUrl2 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort2;\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    } else {\n+      // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+\n+    //create and start WebLogic domain\n+    createDomain();\n+    //create a jdbc resource targeted to cluster\n+    createJdbcDataSource(\"root\", \"root123\", mysqlDBPort1);\n+    //deploy application to view server configuration\n+    deployApplication();\n+\n+  }\n+\n+  /**\n+   * Verify the default config before starting any test.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    String maxMessageSize = \"10000000\";\n+    String cpMaxCapacity = \"15\";\n+    String dsUrl = dsUrl1;\n+    verifyConfig(maxMessageSize, cpMaxCapacity, dsUrl, false);\n+\n+  }\n+\n+  /**\n+   * Delete the overrides, secrets and restart domain to get clean state.\n+   */\n+  @AfterEach\n+  public void afterEach() {\n+    deleteConfigMap(overridecm, domainNamespace);\n+    deleteSecret(dsSecret, domainNamespace);\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\"},\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+    restartDomain();\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden dynamically when\n+   * /spec/configuration/overrideDistributionStrategy: field is not set. By default it should be DYNAMIC.\n+   *\n+   * <p>Test sets the /spec/configuration/overridesConfigMap and /spec/configuration/secrets with new configuration\n+   * and new secrets.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are updated\n+   * as expected.\n+   */\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy set to DEFAULT\")\n+  public void testDefaultOverride() {\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    //create config override map and secrets\n+    setupCustomConfigOverrides();\n+\n+    //patch the domain resource with overridesConfigMap, secrets and introspectVersion\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\", \\\"value\\\": [\\\"\" + dsSecret + \"\\\"]  },\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"1\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //print the configuration overrides without asserting\n+    verifyConfig(null, null, null, true);\n+\n+    //workaround for bug - setting overridesConfigMap doesn't apply overrides dynamically, needs restart of server pods\n+    restartDomain(); // remove after the above bug is fixed\n+\n+    verifyConfigOverrides();\n+  }\n+\n+  /**\n+   * Test server configuration and datasource configurations are dynamically overridden when\n+   * /spec/configuration/overrideDistributionStrategy is set to DYNAMIC.\n+   *\n+   * <p>Test sets the above field to DYNAMIC and overrides the /spec/configuration/overridesConfigMap and\n+   * /spec/configuration/secrets with new configuration and new secrets.\n+   *\n+   * <p>Verifies after introspector runs and the server configuration and JDBC datasource configurations are\n+   * updated as expected.\n+   */\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value DYNAMIC\")\n+  public void testDynamicOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: DYNAMIC\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"DYNAMIC\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?\n+    restartDomain(); // if above is a bug, remove this after the above bug is fixed\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    //create config override map and secrets\n+    setupCustomConfigOverrides();\n+\n+    //patch the domain resource with overridesConfigMap, secrets and introspectVersion\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\", \\\"value\\\": [\\\"\" + dsSecret + \"\\\"]  },\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"2\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //print the configuration overrides without asserting\n+    verifyConfig(null, null, null, true);\n+\n+    //workaround for bug - setting overridesConfigMap doesn't apply overrides dynamically, needs restart of server pods\n+    restartDomain(); // remove after the above bug is fixed\n+\n+    verifyConfigOverrides();\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden on restart of pods when\n+   * /spec/configuration/overrideDistributionStrategy is set to ON_RESTART.\n+   *\n+   * <p>Test sets the above field to ON_RESTART and overrides the /spec/configuration/overridesConfigMap and\n+   * /spec/configuration/secrets with new configuration and new secrets.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are\n+   * not updated. After domain restart the overrides are applied.\n+   */\n+  @Order(3)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value ON_RESTART\")\n+  public void testOnRestartOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: ON_RESTART\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"ON_RESTART\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?\n+    restartDomain(); // if above is a bug, remove this after the above bug is fixed\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    //create config override map and secrets\n+    setupCustomConfigOverrides();\n+\n+    //patch the domain resource with overridesConfigMap, secrets and introspectVersion\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\", \\\"value\\\": [\\\"\" + dsSecret + \"\\\"]  },\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"4\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //print the configuration overrides without asserting\n+    verifyConfig(null, null, null, true);\n+\n+    //verify the overrides are not applied\n+    verifyConfig(\"10000000\", \"15\", dsUrl1, false);\n+\n+    //restart domain for the distributionstrategy to take effect\n+    restartDomain();\n+\n+    //verify on restart the overrides are applied\n+    verifyConfigOverrides();\n+  }\n+\n+  /**\n+   * Test patching the domain with values for /spec/configuration/overrideDistributionStrategy field\n+   * anything other than DYNAMIC or ON_RESTART fails.\n+   *\n+   * <p>Test tries to set the above field to RESTART and asserts the patching fails.\n+   */\n+  @Order(4)\n+  @Test\n+  @DisplayName(\"Test invalid overrideDistributionStrategy value RESTART\")\n+  public void testOverrideNegative() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: RESTART\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"RESTART\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertFalse(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Patch domain with invalid overrideDistributionStrategy succeeded.\");\n+\n+    //verify the overrides are not applied and original configuration is still effective\n+    verifyConfig(\"10000000\", \"15\", dsUrl1, false);\n+  }\n+\n+  //verify the configuration overrides for server and JDBC datasource\n+  private void verifyConfigOverrides() {\n+\n+    String maxMessageSize = \"78787878\";\n+    String cpMaxCapacity = \"12\";\n+    String dsUrl = dsUrl2;\n+    verifyConfig(maxMessageSize, cpMaxCapacity, dsUrl, false);\n+  }\n+\n+  //use the http client and access the clusterview application to get server configuration\n+  //and JDBC datasource configuration.\n+  private void verifyConfig(String maxMessageSize, String cpMaxCapacity, String dsUrl, boolean debug) {\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(domainNamespace, adminServerPodName\n+            + \"-external\",\n+            \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    //verify server attribute MaxMessageSize\n+    String appURI = \"/clusterview/ConfigServlet?\"\n+        + \"attributeTest=true&\"\n+        + \"serverType=adminserver&\"\n+        + \"serverName=\" + adminServerName;\n+    String url = \"http://\" + K8S_NODEPORT_HOST + \":\" + serviceNodePort + appURI;\n+    HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(url, true));\n+\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    if (!debug) {\n+      assertTrue(response.body().contains(maxMessageSize), \"Didn't get MaxMessageSize=\" + maxMessageSize);\n+    }\n+\n+    //verify datasource attributes\n+    appURI = \"/clusterview/ConfigServlet?\"\n+        + \"resTest=true&\"\n+        + \"resName=\" + dsName;\n+    String dsurl = \"http://\" + K8S_NODEPORT_HOST + \":\" + serviceNodePort + appURI;\n+    response = assertDoesNotThrow(() -> OracleHttpClient.get(dsurl, true));\n+\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    if (!debug) {\n+      assertTrue(response.body().contains(\"getMaxCapacity:\" + cpMaxCapacity),\n+          \"Did get getMaxCapacity:\" + cpMaxCapacity);\n+      assertTrue(response.body().contains(\"Url:\" + dsUrl), \"Didn't get Url:\" + dsUrl);\n+    }\n+\n+    //test connection pool\n+    appURI = \"/clusterview/ConfigServlet?\"\n+        + \"dsTest=true&\"\n+        + \"dsName=\" + dsName + \"&\"\n+        + \"serverName=\" + managedServerNameBase + 1;\n+    String dstesturl = \"http://\" + K8S_NODEPORT_HOST + \":\" + serviceNodePort + appURI;\n+    response = assertDoesNotThrow(() -> OracleHttpClient.get(dstesturl, true));\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    if (!debug) {\n+      assertTrue(response.body().contains(\"Connection successful\"), \"Didn't get Connection successful\");\n+    }\n+  }\n+\n+  //store pod creation timestamps for podstate check\n+  private void storePodCreationTimestamps() {\n+    // get the pod creation time stamps\n+    podTimestamps = new LinkedHashMap<>();\n+    // get the creation time of the admin server pod before patching\n+    DateTime adminPodCreationTime = getPodCreationTime(domainNamespace, adminServerPodName);\n+    podTimestamps.put(adminServerPodName, adminPodCreationTime);\n+    // get the creation time of the managed server pods before patching\n+    for (int i = 1; i <= replicaCount; i++) {\n+      podTimestamps.put(managedServerPodNamePrefix + i,\n+          getPodCreationTime(domainNamespace, managedServerPodNamePrefix + i));\n+    }\n+  }\n+\n+  //check if the pods are restarted by comparing the pod creationtimestamp.\n+  private void verifyPodsStateNotChanged() {\n+    logger.info(\"Verifying the WebLogic server pod states are not changed\");\n+    for (Map.Entry<String, DateTime> entry : podTimestamps.entrySet()) {\n+      String podName = (String) entry.getKey();\n+      DateTime creationTimestamp = (DateTime) entry.getValue();\n+      assertTrue(podStateNotChanged(podName, domainUid, domainNamespace,\n+          creationTimestamp), \"Pod is restarted\");\n+    }\n+  }\n+\n+  //verify the introspector pod is created and run\n+  private void verifyIntrospectorRuns() {\n+    //verify the introspector pod is created and runs\n+    logger.info(\"Verifying introspector pod is created, runs and deleted\");\n+    String introspectPodName = domainUid + \"-\" + \"introspect-domain-job\";\n+    checkPodExists(introspectPodName, domainUid, domainNamespace);\n+    checkPodDoesNotExist(introspectPodName, domainUid, domainNamespace);\n+  }\n+\n+  //method to create custom configuration overrides\n+  private void setupCustomConfigOverrides() {\n+    logger.info(\"Creating config overrides\");\n+\n+    //create new secrets for jdbc datasource\n+    Map<String, String> secretMap = new HashMap<>();\n+    secretMap.put(\"dbusername\", \"root\");\n+    secretMap.put(\"dbpassword\", \"root456\");\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(dsSecret)\n+            .namespace(domainNamespace))\n+        .stringData(secretMap)), \"Creating secret for datasource failed.\");\n+    assertTrue(secretCreated, String.format(\"creating secret failed %s\", dsSecret));\n+\n+    //copy the template datasource file for override after replacing JDBC_URL with new datasource url\n+    Path srcDsOverrideFile = Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-0.xml\");\n+    Path dstDsOverrideFile = Paths.get(WORK_DIR, \"jdbc-JdbcTestDataSource-0.xml\");\n+    String tempString = assertDoesNotThrow(()\n+        -> Files.readString(srcDsOverrideFile).replaceAll(\"JDBC_URL\", dsUrl2));\n+    assertDoesNotThrow(()\n+        -> Files.write(dstDsOverrideFile, tempString.getBytes(StandardCharsets.UTF_8)));\n+\n+    //create custom config override map with all the files\n+    ArrayList<Path> configfiles = new ArrayList<>();\n+    configfiles.add(dstDsOverrideFile);\n+    configfiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    configfiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+    createConfigMapFromFiles(overridecm, configfiles, domainNamespace);\n+\n+  }\n+\n+  //create a standard WebLogic domain.\n+  private void createDomain() {\n+\n+    // create WebLogic domain credential secret\n+    createSecretWithUsernamePassword(wlSecretName, domainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, domainNamespace);\n+\n+    t3ChannelPort = getNextFreePort(30000, 32767);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = assertDoesNotThrow(()\n+        -> File.createTempFile(\"domain\", \"properties\"),\n+        \"Failed to create domain properties file\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", Integer.toString(managedServerPort));\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"2\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    assertDoesNotThrow(()\n+        -> p.store(new FileOutputStream(domainPropertiesFile), \"domain properties file\"),\n+        \"Failed to write domain properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, domainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .configuration(new Configuration()\n+                .overrideDistributionStrategy(\"DYNAMIC\"))\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid) // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    createDomainAndVerify(domain, domainNamespace);\n+\n+    // verify the admin server service created\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // verify admin server pod is ready\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPodNamePrefix + i, domainNamespace);\n+    }\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  //deploy application clusterview.war to domain\n+  private void deployApplication() {\n+    logger.info(\"Getting node port for T3 channel\");\n+    int t3channelNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"t3channel\"),\n+        \"Getting admin server t3channel node port failed\");\n+    assertNotEquals(-1, t3ChannelPort, \"admin server t3channelport is not valid\");\n+\n+    //deploy application\n+    logger.info(\"Deploying webapp {0} to domain\", clusterViewAppPath);\n+    deployUsingWlst(K8S_NODEPORT_HOST, Integer.toString(t3channelNodePort),\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, clusterName + \",\" + adminServerName, clusterViewAppPath,\n+        domainNamespace);\n+  }\n+\n+  //restart pods by manipulating the serverStartPolicy to NEVER and IF_NEEDED\n+  private void restartDomain() {\n+    logger.info(\"Restarting domain {0}\", domainNamespace);\n+    shutdownDomain(domainUid, domainNamespace);\n+\n+    logger.info(\"Checking for admin server pod shutdown\");\n+    checkPodDoesNotExist(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Checking managed server pods were shutdown\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodDoesNotExist(managedServerPodNamePrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    startDomain(domainUid, domainNamespace);\n+    logger.info(\"Checking for admin server pod readiness\");\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Checking for managed servers pod readiness\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodReady(managedServerPodNamePrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  //create a JDBC datasource targeted to cluster.\n+  private void createJdbcDataSource(String user, String password, int mySQLNodePort) {\n+\n+    try {\n+      String jdbcDsUrl = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mySQLNodePort;\n+\n+      // create a temporary WebLogic domain property file\n+      File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+      Properties p = new Properties();\n+      p.setProperty(\"admin_host\", K8S_NODEPORT_HOST);\n+      p.setProperty(\"admin_port\", Integer.toString(t3ChannelPort));\n+      p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+      p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+      p.setProperty(\"dsName\", dsName);\n+      p.setProperty(\"dsUrl\", jdbcDsUrl);\n+      p.setProperty(\"dsDriver\", \"com.mysql.cj.jdbc.Driver\");\n+      p.setProperty(\"dsUser\", user);\n+      p.setProperty(\"dsPassword\", password);\n+      p.setProperty(\"dsTarget\", clusterName);\n+      p.store(new FileOutputStream(domainPropertiesFile), \"domain properties file\");\n+\n+      // WLST script for creating jdbc datasource\n+      Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"create-jdbc-resource.py\");\n+      executeWLSTScript(wlstScript, domainPropertiesFile.toPath(), domainNamespace);\n+    } catch (IOException ex) {\n+      logger.severe(ex.getMessage());\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain on a persistent volume by doing the following. Create a configmap containing WLST script\n+   * and property file. Create a Kubernetes job to create domain on persistent volume.\n+   *\n+   * @param wlstScriptFile python script to create domain\n+   * @param domainPropertiesFile properties file containing domain configuration\n+   * @param pvName name of the persistent volume to create domain in\n+   * @param pvcName name of the persistent volume claim\n+   * @param namespace name of the domain namespace in which the job is created\n+   */\n+  private void createDomainOnPVUsingWlst(Path wlstScriptFile, Path domainPropertiesFile,\n+      String pvName, String pvcName, String namespace) {\n+    logger.info(\"Preparing to run create domain job using WLST\");\n+\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(wlstScriptFile);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Creating a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles, namespace),\n+        \"Create configmap for domain creation failed\");\n+\n+    // create a V1Container with specific scripts and properties for creating domain\n+    V1Container jobCreationContainer = new V1Container()\n+        .addCommandItem(\"/bin/sh\")\n+        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+        .addArgsItem(\"/u01/weblogic/\" + wlstScriptFile.getFileName()) //wlst.sh\n+        // script\n+        .addArgsItem(\"-skipWLSModuleScanning\")\n+        .addArgsItem(\"-loadProperties\")\n+        .addArgsItem(\"/u01/weblogic/\" + domainPropertiesFile.getFileName());\n+    //domain property file\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    createDomainJob(pvName, pvcName, domainScriptConfigMapName, namespace, jobCreationContainer);\n+\n+  }\n+\n+  /**\n+   * Create configmap containing domain creation scripts.\n+   *\n+   * @param configMapName name of the configmap to create\n+   * @param files files to add in configmap\n+   * @param namespace name of the namespace in which to create configmap\n+   * @throws IOException when reading the domain script files fail\n+   * @throws ApiException if create configmap fails\n+   */\n+  private void createConfigMapForDomainCreation(String configMapName, List<Path> files, String namespace)\n+      throws ApiException, IOException {\n+    logger.info(\"Creating configmap {0}\", configMapName);\n+\n+    Path domainScriptsDir = Files.createDirectories(\n+        Paths.get(TestConstants.LOGS_DIR, this.getClass().getSimpleName(), namespace));\n+\n+    // add domain creation scripts and properties files to the configmap\n+    Map<String, String> data = new HashMap<>();\n+    for (Path file : files) {\n+      logger.info(\"Adding file {0} in configmap\", file);\n+      data.put(file.getFileName().toString(), Files.readString(file));\n+      logger.info(\"Making a copy of file {0} to {1} for diagnostic purposes\", file,\n+          domainScriptsDir.resolve(file.getFileName()));\n+      Files.copy(file, domainScriptsDir.resolve(file.getFileName()));\n+    }\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .name(configMapName)\n+        .namespace(namespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Failed to create configmap %s with files %s\", configMapName, files));\n+    assertTrue(cmCreated, String.format(\"Failed while creating ConfigMap %s\", configMapName));\n+  }\n+\n+  /**\n+   * Create a job to create a domain in persistent volume.\n+   *\n+   * @param pvName name of the persistent volume to create domain in\n+   * @param pvcName name of the persistent volume claim\n+   * @param domainScriptCM configmap holding domain creation script files\n+   * @param namespace name of the domain namespace in which the job is created\n+   * @param jobContainer V1Container with job commands to create domain\n+   */\n+  private void createDomainJob(String pvName,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMwMDkzNg=="}, "originalCommit": {"oid": "6d793e632fa943aa9202ff865e40398ec2a4f8b2"}, "originalPosition": 859}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MTI4NzU1OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/MySQLDBUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxOTozNjo1M1rOGpsgxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxOTo1NjoxNFrOGps_FQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM3NDA4NA==", "bodyText": "should we have have image as param in case we use different versions?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r446374084", "createdAt": "2020-06-26T19:36:53Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/MySQLDBUtils.java", "diffHunk": "@@ -0,0 +1,130 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1EnvVarSource;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretKeySelector;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to create MySQL database.\n+ */\n+public class MySQLDBUtils {\n+\n+  /**\n+   * Create and start a MySQL database pod.\n+   *\n+   * @param name      name of the db pod\n+   * @param user      username for the database\n+   * @param password  password for the database\n+   * @param nodePort  node port of db service\n+   * @param namespace name of the namespace in which to create MySQL database\n+   */\n+  public static void createMySQLDB(String name, String user, String password, int nodePort, String namespace) {\n+\n+    String uniqueName = Namespace.uniqueName();\n+    String secretName = name.concat(\"-secret-\").concat(uniqueName);\n+    String serviceName = name.concat(\"-external-\").concat(uniqueName);\n+\n+    createSecret(secretName, user, password, namespace);\n+    createService(serviceName, name, namespace, nodePort);\n+    startMySQLDB(name, secretName, namespace);\n+\n+  }\n+\n+  //create the database pod\n+  private static void startMySQLDB(String name, String secretName, String namespace) {\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"app\", name);\n+    V1Pod mysqlPod = new V1Pod()\n+        .metadata(new V1ObjectMeta()\n+            .name(name)\n+            .namespace(namespace)\n+            .labels(labels))\n+        .spec(new V1PodSpec()\n+            .terminationGracePeriodSeconds(5L)\n+            .containers(Arrays.asList(new V1Container()\n+                .image(\"mysql:5.6\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e951c3665bf47d99efd34675674e8bbe0bc8d390"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM4MTg0NQ==", "bodyText": "Good suggestion. Added a new param for taking the MySQL image version.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r446381845", "createdAt": "2020-06-26T19:56:14Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/MySQLDBUtils.java", "diffHunk": "@@ -0,0 +1,130 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1EnvVarSource;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretKeySelector;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to create MySQL database.\n+ */\n+public class MySQLDBUtils {\n+\n+  /**\n+   * Create and start a MySQL database pod.\n+   *\n+   * @param name      name of the db pod\n+   * @param user      username for the database\n+   * @param password  password for the database\n+   * @param nodePort  node port of db service\n+   * @param namespace name of the namespace in which to create MySQL database\n+   */\n+  public static void createMySQLDB(String name, String user, String password, int nodePort, String namespace) {\n+\n+    String uniqueName = Namespace.uniqueName();\n+    String secretName = name.concat(\"-secret-\").concat(uniqueName);\n+    String serviceName = name.concat(\"-external-\").concat(uniqueName);\n+\n+    createSecret(secretName, user, password, namespace);\n+    createService(serviceName, name, namespace, nodePort);\n+    startMySQLDB(name, secretName, namespace);\n+\n+  }\n+\n+  //create the database pod\n+  private static void startMySQLDB(String name, String secretName, String namespace) {\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"app\", name);\n+    V1Pod mysqlPod = new V1Pod()\n+        .metadata(new V1ObjectMeta()\n+            .name(name)\n+            .namespace(namespace)\n+            .labels(labels))\n+        .spec(new V1PodSpec()\n+            .terminationGracePeriodSeconds(5L)\n+            .containers(Arrays.asList(new V1Container()\n+                .image(\"mysql:5.6\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM3NDA4NA=="}, "originalCommit": {"oid": "e951c3665bf47d99efd34675674e8bbe0bc8d390"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NjM2MjI5OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIntrospectVersion.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMjozMTo0MlrOGr3ZAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMzo0NzoxNFrOGr4ysg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY0OTQ3Mw==", "bodyText": "Can we get the current  Introspect version  and bump it instead of hard-coding to 4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r448649473", "createdAt": "2020-07-01T22:31:42Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIntrospectVersion.java", "diffHunk": "@@ -613,6 +614,98 @@ public void testDomainIntrospectVersionRolling() {\n \n   }\n \n+  /**\n+   * Test, a new cluster can be created using online WLST change and new server pods can be brought\n+   * up by patching domain resource with new cluster info and running the introspector.\n+   */\n+  @Order(3)\n+  @Test\n+  @DisplayName(\"Test new cluster creation on demand using WLST and introspection\")\n+  public void testCreateNewCluster() {\n+\n+    final String domainUid = \"mydomain\";\n+    final String clusterName = \"cl2\";\n+\n+    final String adminServerName = \"admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+\n+    final String managedServerNameBase = \"cl2-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+    final int replicaCount = 2;\n+\n+    logger.info(\"Getting node port for default channel\");\n+    int adminServerT3Port = getServiceNodePort(introDomainNamespace, adminServerPodName + \"-external\", \"t3channel\");\n+\n+    // create a temporary WebLogic WLST property file\n+    File wlstPropertiesFile = assertDoesNotThrow(() -> File.createTempFile(\"wlst\", \"properties\"),\n+        \"Creating WLST properties file failed\");\n+    Properties p = new Properties();\n+    p.setProperty(\"admin_host\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_port\", Integer.toString(adminServerT3Port));\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"test_name\", \"create_cluster\");\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"server_prefix\", managedServerNameBase);\n+    p.setProperty(\"server_count\", \"3\");\n+    assertDoesNotThrow(() -> p.store(new FileOutputStream(wlstPropertiesFile), \"wlst properties file\"),\n+        \"Failed to write the WLST properties to file\");\n+\n+    // changet the admin server port to a different value to force pod restart\n+    Path configScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"introspect_version_script.py\");\n+    executeWLSTScript(configScript, wlstPropertiesFile.toPath(), introDomainNamespace);\n+\n+    logger.info(\"patch the domain resource with new cluster and introspectVersion\");\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\",\\\"path\\\": \\\"/spec/clusters/-\\\", \\\"value\\\": \"\n+        + \"    {\\\"clusterName\\\" : \\\"\" + clusterName + \"\\\", \\\"replicas\\\": 2, \\\"serverStartState\\\": \\\"RUNNING\\\"}\"\n+        + \"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"4\\\"}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed1e738b6d6e8ede701e73a7f95bcf26e057a4f4"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY3MjQzNA==", "bodyText": "Good point. Added a new utility method getNextIntrospectVersion to auto increment the introspectVersion.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r448672434", "createdAt": "2020-07-01T23:47:14Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIntrospectVersion.java", "diffHunk": "@@ -613,6 +614,98 @@ public void testDomainIntrospectVersionRolling() {\n \n   }\n \n+  /**\n+   * Test, a new cluster can be created using online WLST change and new server pods can be brought\n+   * up by patching domain resource with new cluster info and running the introspector.\n+   */\n+  @Order(3)\n+  @Test\n+  @DisplayName(\"Test new cluster creation on demand using WLST and introspection\")\n+  public void testCreateNewCluster() {\n+\n+    final String domainUid = \"mydomain\";\n+    final String clusterName = \"cl2\";\n+\n+    final String adminServerName = \"admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+\n+    final String managedServerNameBase = \"cl2-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+    final int replicaCount = 2;\n+\n+    logger.info(\"Getting node port for default channel\");\n+    int adminServerT3Port = getServiceNodePort(introDomainNamespace, adminServerPodName + \"-external\", \"t3channel\");\n+\n+    // create a temporary WebLogic WLST property file\n+    File wlstPropertiesFile = assertDoesNotThrow(() -> File.createTempFile(\"wlst\", \"properties\"),\n+        \"Creating WLST properties file failed\");\n+    Properties p = new Properties();\n+    p.setProperty(\"admin_host\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_port\", Integer.toString(adminServerT3Port));\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"test_name\", \"create_cluster\");\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"server_prefix\", managedServerNameBase);\n+    p.setProperty(\"server_count\", \"3\");\n+    assertDoesNotThrow(() -> p.store(new FileOutputStream(wlstPropertiesFile), \"wlst properties file\"),\n+        \"Failed to write the WLST properties to file\");\n+\n+    // changet the admin server port to a different value to force pod restart\n+    Path configScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"introspect_version_script.py\");\n+    executeWLSTScript(configScript, wlstPropertiesFile.toPath(), introDomainNamespace);\n+\n+    logger.info(\"patch the domain resource with new cluster and introspectVersion\");\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\",\\\"path\\\": \\\"/spec/clusters/-\\\", \\\"value\\\": \"\n+        + \"    {\\\"clusterName\\\" : \\\"\" + clusterName + \"\\\", \\\"replicas\\\": 2, \\\"serverStartState\\\": \\\"RUNNING\\\"}\"\n+        + \"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"4\\\"}\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY0OTQ3Mw=="}, "originalCommit": {"oid": "ed1e738b6d6e8ede701e73a7f95bcf26e057a4f4"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NjM3NDc0OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIntrospectVersion.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMjozNzoxNFrOGr3gTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMzoyMTo0OFrOGr4VfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY1MTM0Mw==", "bodyText": "May be modify the description step-by-step\na. Create new WebLogic Cluster using WLST\nb. Patch the Domain Resource\nc. Update the Introspector version\nd. Make sure the Servers in the new WebLogic cluster comes up with out any affect to  running  servers on pre-existing WebLogic cluster", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r448651343", "createdAt": "2020-07-01T22:37:14Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIntrospectVersion.java", "diffHunk": "@@ -613,6 +614,98 @@ public void testDomainIntrospectVersionRolling() {\n \n   }\n \n+  /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed1e738b6d6e8ede701e73a7f95bcf26e057a4f4"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY2NDk1Ng==", "bodyText": "Good writeup. Modified javadoc.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r448664956", "createdAt": "2020-07-01T23:21:48Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIntrospectVersion.java", "diffHunk": "@@ -613,6 +614,98 @@ public void testDomainIntrospectVersionRolling() {\n \n   }\n \n+  /**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY1MTM0Mw=="}, "originalCommit": {"oid": "ed1e738b6d6e8ede701e73a7f95bcf26e057a4f4"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NjM4NDk3OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMjo0MjoxM1rOGr3mfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMzoxMzozM1rOGr4MPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY1MjkyNw==", "bodyText": "Add a TODO comment to make it visible", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r448652927", "createdAt": "2020-07-01T22:42:13Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "diffHunk": "@@ -0,0 +1,1148 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownDomain;\n+import static oracle.weblogic.kubernetes.actions.TestActions.startDomain;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.MySQLDBUtils.createMySQLDB;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static oracle.weblogic.kubernetes.utils.WLSTUtils.executeWLSTScript;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests related to overrideDistributionStrategy attribute.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the overrideDistributionStrategy applies the overrides accordingly to the value set\")\n+@IntegrationTest\n+public class ItConfigDistributionStrategy {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path clusterViewAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  static int mysqlDBPort1;\n+  static int mysqlDBPort2;\n+  static String dsUrl1;\n+  static String dsUrl2;\n+\n+  String dsName0 = \"JdbcTestDataSource-0\";\n+  String dsName1 = \"JdbcTestDataSource-1\";\n+  String dsSecret = domainUid.concat(\"-mysql-secret\");\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   * Creates 2 MySQL database instances.\n+   * Creates and starts WebLogic domain containing 2 instances in dynamic cluser.\n+   * Creates 2 JDBC data sources targeted to cluster.\n+   * Deploys clusterview application to cluster and admin targets.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for domain namspace\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+\n+    // build the clusterview application\n+    Path distDir = buildApplication(Paths.get(APP_DIR, \"clusterview\"),\n+        null, null, \"dist\", domainNamespace);\n+    clusterViewAppPath = Paths.get(distDir.toString(), \"clusterview.war\");\n+    assertTrue(clusterViewAppPath.toFile().exists(), \"Application archive is not available\");\n+\n+    //start two MySQL database instances\n+    mysqlDBPort1 = getNextFreePort(30000, 32767);\n+    createMySQLDB(\"mysqldb-1\", \"root\", \"root123\", mysqlDBPort1, domainNamespace, null);\n+    mysqlDBPort2 = getNextFreePort(31000, 32767);\n+    createMySQLDB(\"mysqldb-2\", \"root\", \"root456\", mysqlDBPort2, domainNamespace, null);\n+\n+    dsUrl1 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort1;\n+    dsUrl2 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort2;\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    } else {\n+      // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+\n+    //create and start WebLogic domain\n+    createDomain();\n+    //create a jdbc resource targeted to cluster\n+    createJdbcDataSource(dsName0, \"root\", \"root123\", mysqlDBPort1);\n+    createJdbcDataSource(dsName1, \"root\", \"root123\", mysqlDBPort1);\n+    //deploy application to view server configuration\n+    deployApplication(clusterName + \",\" + adminServerName);\n+\n+  }\n+\n+  /**\n+   * Verify the default config before starting any test.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    //check configuration values before override\n+    verifyConfigXMLOverride(false);\n+    verifyResourceJDBC0Override(false);\n+  }\n+\n+  /**\n+   * Delete the overrides and restart domain to get clean state.\n+   */\n+  @AfterEach\n+  public void afterEach() {\n+    deleteConfigMap(overridecm, domainNamespace);\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\"},\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+    restartDomain();\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden dynamically when\n+   * /spec/configuration/overrideDistributionStrategy: field is not set. By default it should be DYNAMIC.\n+   *\n+   * <p>Test sets the /spec/configuration/overridesConfigMap and with new configuration for config.xml and datasources.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are updated\n+   * as expected.\n+   */\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy set to DEFAULT\")\n+  public void testDefaultOverride() {\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap and introspectVersion\");\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"1\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC0Override(true);\n+  }\n+\n+  /**\n+   * Test server configuration and datasource configurations are dynamically overridden when\n+   * /spec/configuration/overrideDistributionStrategy is set to DYNAMIC.\n+   *\n+   * <p>Test sets the above field to DYNAMIC and overrides the /spec/configuration/overridesConfigMap\n+   * with new configuration.\n+   *\n+   * <p>Verifies after introspector runs and the server configuration and JDBC datasource configurations are\n+   * updated as expected.\n+   */\n+  @Disabled\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value DYNAMIC\")\n+  public void testDynamicOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: DYNAMIC\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"DYNAMIC\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed1e738b6d6e8ede701e73a7f95bcf26e057a4f4"}, "originalPosition": 353}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY2MjU5MQ==", "bodyText": "Added a TODO comment", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r448662591", "createdAt": "2020-07-01T23:13:33Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "diffHunk": "@@ -0,0 +1,1148 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownDomain;\n+import static oracle.weblogic.kubernetes.actions.TestActions.startDomain;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.MySQLDBUtils.createMySQLDB;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static oracle.weblogic.kubernetes.utils.WLSTUtils.executeWLSTScript;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests related to overrideDistributionStrategy attribute.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the overrideDistributionStrategy applies the overrides accordingly to the value set\")\n+@IntegrationTest\n+public class ItConfigDistributionStrategy {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path clusterViewAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  static int mysqlDBPort1;\n+  static int mysqlDBPort2;\n+  static String dsUrl1;\n+  static String dsUrl2;\n+\n+  String dsName0 = \"JdbcTestDataSource-0\";\n+  String dsName1 = \"JdbcTestDataSource-1\";\n+  String dsSecret = domainUid.concat(\"-mysql-secret\");\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   * Creates 2 MySQL database instances.\n+   * Creates and starts WebLogic domain containing 2 instances in dynamic cluser.\n+   * Creates 2 JDBC data sources targeted to cluster.\n+   * Deploys clusterview application to cluster and admin targets.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for domain namspace\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+\n+    // build the clusterview application\n+    Path distDir = buildApplication(Paths.get(APP_DIR, \"clusterview\"),\n+        null, null, \"dist\", domainNamespace);\n+    clusterViewAppPath = Paths.get(distDir.toString(), \"clusterview.war\");\n+    assertTrue(clusterViewAppPath.toFile().exists(), \"Application archive is not available\");\n+\n+    //start two MySQL database instances\n+    mysqlDBPort1 = getNextFreePort(30000, 32767);\n+    createMySQLDB(\"mysqldb-1\", \"root\", \"root123\", mysqlDBPort1, domainNamespace, null);\n+    mysqlDBPort2 = getNextFreePort(31000, 32767);\n+    createMySQLDB(\"mysqldb-2\", \"root\", \"root456\", mysqlDBPort2, domainNamespace, null);\n+\n+    dsUrl1 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort1;\n+    dsUrl2 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort2;\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    } else {\n+      // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+\n+    //create and start WebLogic domain\n+    createDomain();\n+    //create a jdbc resource targeted to cluster\n+    createJdbcDataSource(dsName0, \"root\", \"root123\", mysqlDBPort1);\n+    createJdbcDataSource(dsName1, \"root\", \"root123\", mysqlDBPort1);\n+    //deploy application to view server configuration\n+    deployApplication(clusterName + \",\" + adminServerName);\n+\n+  }\n+\n+  /**\n+   * Verify the default config before starting any test.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    //check configuration values before override\n+    verifyConfigXMLOverride(false);\n+    verifyResourceJDBC0Override(false);\n+  }\n+\n+  /**\n+   * Delete the overrides and restart domain to get clean state.\n+   */\n+  @AfterEach\n+  public void afterEach() {\n+    deleteConfigMap(overridecm, domainNamespace);\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\"},\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+    restartDomain();\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden dynamically when\n+   * /spec/configuration/overrideDistributionStrategy: field is not set. By default it should be DYNAMIC.\n+   *\n+   * <p>Test sets the /spec/configuration/overridesConfigMap and with new configuration for config.xml and datasources.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are updated\n+   * as expected.\n+   */\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy set to DEFAULT\")\n+  public void testDefaultOverride() {\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap and introspectVersion\");\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"1\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC0Override(true);\n+  }\n+\n+  /**\n+   * Test server configuration and datasource configurations are dynamically overridden when\n+   * /spec/configuration/overrideDistributionStrategy is set to DYNAMIC.\n+   *\n+   * <p>Test sets the above field to DYNAMIC and overrides the /spec/configuration/overridesConfigMap\n+   * with new configuration.\n+   *\n+   * <p>Verifies after introspector runs and the server configuration and JDBC datasource configurations are\n+   * updated as expected.\n+   */\n+  @Disabled\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value DYNAMIC\")\n+  public void testDynamicOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: DYNAMIC\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"DYNAMIC\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY1MjkyNw=="}, "originalCommit": {"oid": "ed1e738b6d6e8ede701e73a7f95bcf26e057a4f4"}, "originalPosition": 353}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NjM4NzY2OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMjo0MzozNFrOGr3oLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMzoxMzo0MFrOGr4MVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY1MzM1OQ==", "bodyText": "add TODO Comments or the BUG/JIRA Number", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r448653359", "createdAt": "2020-07-01T22:43:34Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "diffHunk": "@@ -0,0 +1,1148 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownDomain;\n+import static oracle.weblogic.kubernetes.actions.TestActions.startDomain;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.MySQLDBUtils.createMySQLDB;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static oracle.weblogic.kubernetes.utils.WLSTUtils.executeWLSTScript;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests related to overrideDistributionStrategy attribute.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the overrideDistributionStrategy applies the overrides accordingly to the value set\")\n+@IntegrationTest\n+public class ItConfigDistributionStrategy {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path clusterViewAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  static int mysqlDBPort1;\n+  static int mysqlDBPort2;\n+  static String dsUrl1;\n+  static String dsUrl2;\n+\n+  String dsName0 = \"JdbcTestDataSource-0\";\n+  String dsName1 = \"JdbcTestDataSource-1\";\n+  String dsSecret = domainUid.concat(\"-mysql-secret\");\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   * Creates 2 MySQL database instances.\n+   * Creates and starts WebLogic domain containing 2 instances in dynamic cluser.\n+   * Creates 2 JDBC data sources targeted to cluster.\n+   * Deploys clusterview application to cluster and admin targets.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for domain namspace\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+\n+    // build the clusterview application\n+    Path distDir = buildApplication(Paths.get(APP_DIR, \"clusterview\"),\n+        null, null, \"dist\", domainNamespace);\n+    clusterViewAppPath = Paths.get(distDir.toString(), \"clusterview.war\");\n+    assertTrue(clusterViewAppPath.toFile().exists(), \"Application archive is not available\");\n+\n+    //start two MySQL database instances\n+    mysqlDBPort1 = getNextFreePort(30000, 32767);\n+    createMySQLDB(\"mysqldb-1\", \"root\", \"root123\", mysqlDBPort1, domainNamespace, null);\n+    mysqlDBPort2 = getNextFreePort(31000, 32767);\n+    createMySQLDB(\"mysqldb-2\", \"root\", \"root456\", mysqlDBPort2, domainNamespace, null);\n+\n+    dsUrl1 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort1;\n+    dsUrl2 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort2;\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    } else {\n+      // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+\n+    //create and start WebLogic domain\n+    createDomain();\n+    //create a jdbc resource targeted to cluster\n+    createJdbcDataSource(dsName0, \"root\", \"root123\", mysqlDBPort1);\n+    createJdbcDataSource(dsName1, \"root\", \"root123\", mysqlDBPort1);\n+    //deploy application to view server configuration\n+    deployApplication(clusterName + \",\" + adminServerName);\n+\n+  }\n+\n+  /**\n+   * Verify the default config before starting any test.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    //check configuration values before override\n+    verifyConfigXMLOverride(false);\n+    verifyResourceJDBC0Override(false);\n+  }\n+\n+  /**\n+   * Delete the overrides and restart domain to get clean state.\n+   */\n+  @AfterEach\n+  public void afterEach() {\n+    deleteConfigMap(overridecm, domainNamespace);\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\"},\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+    restartDomain();\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden dynamically when\n+   * /spec/configuration/overrideDistributionStrategy: field is not set. By default it should be DYNAMIC.\n+   *\n+   * <p>Test sets the /spec/configuration/overridesConfigMap and with new configuration for config.xml and datasources.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are updated\n+   * as expected.\n+   */\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy set to DEFAULT\")\n+  public void testDefaultOverride() {\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap and introspectVersion\");\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"1\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC0Override(true);\n+  }\n+\n+  /**\n+   * Test server configuration and datasource configurations are dynamically overridden when\n+   * /spec/configuration/overrideDistributionStrategy is set to DYNAMIC.\n+   *\n+   * <p>Test sets the above field to DYNAMIC and overrides the /spec/configuration/overridesConfigMap\n+   * with new configuration.\n+   *\n+   * <p>Verifies after introspector runs and the server configuration and JDBC datasource configurations are\n+   * updated as expected.\n+   */\n+  @Disabled\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value DYNAMIC\")\n+  public void testDynamicOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: DYNAMIC\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"DYNAMIC\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?\n+    restartDomain(); // if above is a bug, remove this after the above bug is fixed\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap, secrets , cluster and introspectVersion\");\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"2\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC0Override(true);\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden on restart of pods when\n+   * /spec/configuration/overrideDistributionStrategy is set to ON_RESTART.\n+   *\n+   * <p>Test sets the above field to ON_RESTART and overrides the /spec/configuration/overridesConfigMap and\n+   * /spec/configuration/secrets with new configuration and new secrets.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are not\n+   * updated. Verifies the overrides are applied only after a domain restart.\n+   */\n+  @Disabled\n+  @Order(3)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value ON_RESTART\")\n+  public void testOnRestartOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: ON_RESTART\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"ON_RESTART\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed1e738b6d6e8ede701e73a7f95bcf26e057a4f4"}, "originalPosition": 421}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY2MjYxNA==", "bodyText": "Added a TODO comment", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r448662614", "createdAt": "2020-07-01T23:13:40Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "diffHunk": "@@ -0,0 +1,1148 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownDomain;\n+import static oracle.weblogic.kubernetes.actions.TestActions.startDomain;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.MySQLDBUtils.createMySQLDB;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static oracle.weblogic.kubernetes.utils.WLSTUtils.executeWLSTScript;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests related to overrideDistributionStrategy attribute.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the overrideDistributionStrategy applies the overrides accordingly to the value set\")\n+@IntegrationTest\n+public class ItConfigDistributionStrategy {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path clusterViewAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  static int mysqlDBPort1;\n+  static int mysqlDBPort2;\n+  static String dsUrl1;\n+  static String dsUrl2;\n+\n+  String dsName0 = \"JdbcTestDataSource-0\";\n+  String dsName1 = \"JdbcTestDataSource-1\";\n+  String dsSecret = domainUid.concat(\"-mysql-secret\");\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   * Creates 2 MySQL database instances.\n+   * Creates and starts WebLogic domain containing 2 instances in dynamic cluser.\n+   * Creates 2 JDBC data sources targeted to cluster.\n+   * Deploys clusterview application to cluster and admin targets.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for domain namspace\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+\n+    // build the clusterview application\n+    Path distDir = buildApplication(Paths.get(APP_DIR, \"clusterview\"),\n+        null, null, \"dist\", domainNamespace);\n+    clusterViewAppPath = Paths.get(distDir.toString(), \"clusterview.war\");\n+    assertTrue(clusterViewAppPath.toFile().exists(), \"Application archive is not available\");\n+\n+    //start two MySQL database instances\n+    mysqlDBPort1 = getNextFreePort(30000, 32767);\n+    createMySQLDB(\"mysqldb-1\", \"root\", \"root123\", mysqlDBPort1, domainNamespace, null);\n+    mysqlDBPort2 = getNextFreePort(31000, 32767);\n+    createMySQLDB(\"mysqldb-2\", \"root\", \"root456\", mysqlDBPort2, domainNamespace, null);\n+\n+    dsUrl1 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort1;\n+    dsUrl2 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort2;\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    } else {\n+      // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+\n+    //create and start WebLogic domain\n+    createDomain();\n+    //create a jdbc resource targeted to cluster\n+    createJdbcDataSource(dsName0, \"root\", \"root123\", mysqlDBPort1);\n+    createJdbcDataSource(dsName1, \"root\", \"root123\", mysqlDBPort1);\n+    //deploy application to view server configuration\n+    deployApplication(clusterName + \",\" + adminServerName);\n+\n+  }\n+\n+  /**\n+   * Verify the default config before starting any test.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    //check configuration values before override\n+    verifyConfigXMLOverride(false);\n+    verifyResourceJDBC0Override(false);\n+  }\n+\n+  /**\n+   * Delete the overrides and restart domain to get clean state.\n+   */\n+  @AfterEach\n+  public void afterEach() {\n+    deleteConfigMap(overridecm, domainNamespace);\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\"},\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+    restartDomain();\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden dynamically when\n+   * /spec/configuration/overrideDistributionStrategy: field is not set. By default it should be DYNAMIC.\n+   *\n+   * <p>Test sets the /spec/configuration/overridesConfigMap and with new configuration for config.xml and datasources.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are updated\n+   * as expected.\n+   */\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy set to DEFAULT\")\n+  public void testDefaultOverride() {\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap and introspectVersion\");\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"1\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC0Override(true);\n+  }\n+\n+  /**\n+   * Test server configuration and datasource configurations are dynamically overridden when\n+   * /spec/configuration/overrideDistributionStrategy is set to DYNAMIC.\n+   *\n+   * <p>Test sets the above field to DYNAMIC and overrides the /spec/configuration/overridesConfigMap\n+   * with new configuration.\n+   *\n+   * <p>Verifies after introspector runs and the server configuration and JDBC datasource configurations are\n+   * updated as expected.\n+   */\n+  @Disabled\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value DYNAMIC\")\n+  public void testDynamicOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: DYNAMIC\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"DYNAMIC\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?\n+    restartDomain(); // if above is a bug, remove this after the above bug is fixed\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap, secrets , cluster and introspectVersion\");\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"2\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC0Override(true);\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden on restart of pods when\n+   * /spec/configuration/overrideDistributionStrategy is set to ON_RESTART.\n+   *\n+   * <p>Test sets the above field to ON_RESTART and overrides the /spec/configuration/overridesConfigMap and\n+   * /spec/configuration/secrets with new configuration and new secrets.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are not\n+   * updated. Verifies the overrides are applied only after a domain restart.\n+   */\n+  @Disabled\n+  @Order(3)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value ON_RESTART\")\n+  public void testOnRestartOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: ON_RESTART\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"ON_RESTART\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY1MzM1OQ=="}, "originalCommit": {"oid": "ed1e738b6d6e8ede701e73a7f95bcf26e057a4f4"}, "originalPosition": 421}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NjM5MTUxOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMjo0NToyMFrOGr3qYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwMDowNDoyNlrOGr5E9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY1MzkyMg==", "bodyText": "Is it not a unit test candidate ?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r448653922", "createdAt": "2020-07-01T22:45:20Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "diffHunk": "@@ -0,0 +1,1148 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownDomain;\n+import static oracle.weblogic.kubernetes.actions.TestActions.startDomain;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.MySQLDBUtils.createMySQLDB;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static oracle.weblogic.kubernetes.utils.WLSTUtils.executeWLSTScript;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests related to overrideDistributionStrategy attribute.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the overrideDistributionStrategy applies the overrides accordingly to the value set\")\n+@IntegrationTest\n+public class ItConfigDistributionStrategy {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path clusterViewAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  static int mysqlDBPort1;\n+  static int mysqlDBPort2;\n+  static String dsUrl1;\n+  static String dsUrl2;\n+\n+  String dsName0 = \"JdbcTestDataSource-0\";\n+  String dsName1 = \"JdbcTestDataSource-1\";\n+  String dsSecret = domainUid.concat(\"-mysql-secret\");\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   * Creates 2 MySQL database instances.\n+   * Creates and starts WebLogic domain containing 2 instances in dynamic cluser.\n+   * Creates 2 JDBC data sources targeted to cluster.\n+   * Deploys clusterview application to cluster and admin targets.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for domain namspace\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+\n+    // build the clusterview application\n+    Path distDir = buildApplication(Paths.get(APP_DIR, \"clusterview\"),\n+        null, null, \"dist\", domainNamespace);\n+    clusterViewAppPath = Paths.get(distDir.toString(), \"clusterview.war\");\n+    assertTrue(clusterViewAppPath.toFile().exists(), \"Application archive is not available\");\n+\n+    //start two MySQL database instances\n+    mysqlDBPort1 = getNextFreePort(30000, 32767);\n+    createMySQLDB(\"mysqldb-1\", \"root\", \"root123\", mysqlDBPort1, domainNamespace, null);\n+    mysqlDBPort2 = getNextFreePort(31000, 32767);\n+    createMySQLDB(\"mysqldb-2\", \"root\", \"root456\", mysqlDBPort2, domainNamespace, null);\n+\n+    dsUrl1 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort1;\n+    dsUrl2 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort2;\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    } else {\n+      // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+\n+    //create and start WebLogic domain\n+    createDomain();\n+    //create a jdbc resource targeted to cluster\n+    createJdbcDataSource(dsName0, \"root\", \"root123\", mysqlDBPort1);\n+    createJdbcDataSource(dsName1, \"root\", \"root123\", mysqlDBPort1);\n+    //deploy application to view server configuration\n+    deployApplication(clusterName + \",\" + adminServerName);\n+\n+  }\n+\n+  /**\n+   * Verify the default config before starting any test.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    //check configuration values before override\n+    verifyConfigXMLOverride(false);\n+    verifyResourceJDBC0Override(false);\n+  }\n+\n+  /**\n+   * Delete the overrides and restart domain to get clean state.\n+   */\n+  @AfterEach\n+  public void afterEach() {\n+    deleteConfigMap(overridecm, domainNamespace);\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\"},\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+    restartDomain();\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden dynamically when\n+   * /spec/configuration/overrideDistributionStrategy: field is not set. By default it should be DYNAMIC.\n+   *\n+   * <p>Test sets the /spec/configuration/overridesConfigMap and with new configuration for config.xml and datasources.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are updated\n+   * as expected.\n+   */\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy set to DEFAULT\")\n+  public void testDefaultOverride() {\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap and introspectVersion\");\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"1\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC0Override(true);\n+  }\n+\n+  /**\n+   * Test server configuration and datasource configurations are dynamically overridden when\n+   * /spec/configuration/overrideDistributionStrategy is set to DYNAMIC.\n+   *\n+   * <p>Test sets the above field to DYNAMIC and overrides the /spec/configuration/overridesConfigMap\n+   * with new configuration.\n+   *\n+   * <p>Verifies after introspector runs and the server configuration and JDBC datasource configurations are\n+   * updated as expected.\n+   */\n+  @Disabled\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value DYNAMIC\")\n+  public void testDynamicOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: DYNAMIC\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"DYNAMIC\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?\n+    restartDomain(); // if above is a bug, remove this after the above bug is fixed\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap, secrets , cluster and introspectVersion\");\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"2\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC0Override(true);\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden on restart of pods when\n+   * /spec/configuration/overrideDistributionStrategy is set to ON_RESTART.\n+   *\n+   * <p>Test sets the above field to ON_RESTART and overrides the /spec/configuration/overridesConfigMap and\n+   * /spec/configuration/secrets with new configuration and new secrets.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are not\n+   * updated. Verifies the overrides are applied only after a domain restart.\n+   */\n+  @Disabled\n+  @Order(3)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value ON_RESTART\")\n+  public void testOnRestartOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: ON_RESTART\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"ON_RESTART\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?\n+    restartDomain(); // if above is a bug, remove this after the above bug is fixed\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    logger.info(\"Creating secrets for JDBC datasource overrides\");\n+    //create new secrets for jdbc datasource\n+    Map<String, String> secretMap = new HashMap<>();\n+    secretMap.put(\"dbusername\", \"root\");\n+    secretMap.put(\"dbpassword\", \"root456\");\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(dsSecret)\n+            .namespace(domainNamespace))\n+        .stringData(secretMap)), \"Creating secret for datasource failed.\");\n+    assertTrue(secretCreated, String.format(\"creating secret failed %s\", dsSecret));\n+\n+    //copy the template datasource file for override after replacing JDBC_URL with new datasource url\n+    Path srcDsOverrideFile = Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-1.xml\");\n+    Path dstDsOverrideFile = Paths.get(WORK_DIR, \"jdbc-JdbcTestDataSource-1.xml\");\n+    String tempString = assertDoesNotThrow(()\n+        -> Files.readString(srcDsOverrideFile).replaceAll(\"JDBC_URL\", dsUrl2));\n+    assertDoesNotThrow(()\n+        -> Files.write(dstDsOverrideFile, tempString.getBytes(StandardCharsets.UTF_8)));\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(dstDsOverrideFile);\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    //patch the domain resource with overridesConfigMap, secrets and introspectVersion\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\", \\\"value\\\": [\\\"\" + dsSecret + \"\\\"]  },\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"3\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    try {\n+      //wait for a minute to see if the overrides are not applied\n+      TimeUnit.MINUTES.sleep(1);\n+    } catch (InterruptedException ex) {\n+      //ignore\n+    }\n+\n+    //verify the overrides are not applied\n+    verifyConfigXMLOverride(false);\n+    verifyResourceJDBC0Override(false);\n+\n+    //restart domain for the distributionstrategy to take effect\n+    restartDomain();\n+\n+    //verify on restart the overrides are applied\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC1Override(true);\n+\n+    //cleanup secret\n+    deleteSecret(dsSecret, domainNamespace);\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+  }\n+\n+  /**\n+   * Test patching the domain with values for /spec/configuration/overrideDistributionStrategy field anything other than\n+   * DYNAMIC or ON_RESTART fails.\n+   *\n+   * <p>Test tries to set the above field to RESTART and asserts the patching fails.\n+   */\n+  @Disabled\n+  @Order(4)\n+  @Test\n+  @DisplayName(\"Test invalid overrideDistributionStrategy value RESTART\")\n+  public void testOverrideNegative() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: RESTART", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed1e738b6d6e8ede701e73a7f95bcf26e057a4f4"}, "originalPosition": 512}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY2Mjc2Mg==", "bodyText": "may be, but it doesn't take much time to run this test, so covering it.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r448662762", "createdAt": "2020-07-01T23:14:14Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "diffHunk": "@@ -0,0 +1,1148 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownDomain;\n+import static oracle.weblogic.kubernetes.actions.TestActions.startDomain;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.MySQLDBUtils.createMySQLDB;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static oracle.weblogic.kubernetes.utils.WLSTUtils.executeWLSTScript;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests related to overrideDistributionStrategy attribute.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the overrideDistributionStrategy applies the overrides accordingly to the value set\")\n+@IntegrationTest\n+public class ItConfigDistributionStrategy {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path clusterViewAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  static int mysqlDBPort1;\n+  static int mysqlDBPort2;\n+  static String dsUrl1;\n+  static String dsUrl2;\n+\n+  String dsName0 = \"JdbcTestDataSource-0\";\n+  String dsName1 = \"JdbcTestDataSource-1\";\n+  String dsSecret = domainUid.concat(\"-mysql-secret\");\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   * Creates 2 MySQL database instances.\n+   * Creates and starts WebLogic domain containing 2 instances in dynamic cluser.\n+   * Creates 2 JDBC data sources targeted to cluster.\n+   * Deploys clusterview application to cluster and admin targets.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for domain namspace\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+\n+    // build the clusterview application\n+    Path distDir = buildApplication(Paths.get(APP_DIR, \"clusterview\"),\n+        null, null, \"dist\", domainNamespace);\n+    clusterViewAppPath = Paths.get(distDir.toString(), \"clusterview.war\");\n+    assertTrue(clusterViewAppPath.toFile().exists(), \"Application archive is not available\");\n+\n+    //start two MySQL database instances\n+    mysqlDBPort1 = getNextFreePort(30000, 32767);\n+    createMySQLDB(\"mysqldb-1\", \"root\", \"root123\", mysqlDBPort1, domainNamespace, null);\n+    mysqlDBPort2 = getNextFreePort(31000, 32767);\n+    createMySQLDB(\"mysqldb-2\", \"root\", \"root456\", mysqlDBPort2, domainNamespace, null);\n+\n+    dsUrl1 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort1;\n+    dsUrl2 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort2;\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    } else {\n+      // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+\n+    //create and start WebLogic domain\n+    createDomain();\n+    //create a jdbc resource targeted to cluster\n+    createJdbcDataSource(dsName0, \"root\", \"root123\", mysqlDBPort1);\n+    createJdbcDataSource(dsName1, \"root\", \"root123\", mysqlDBPort1);\n+    //deploy application to view server configuration\n+    deployApplication(clusterName + \",\" + adminServerName);\n+\n+  }\n+\n+  /**\n+   * Verify the default config before starting any test.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    //check configuration values before override\n+    verifyConfigXMLOverride(false);\n+    verifyResourceJDBC0Override(false);\n+  }\n+\n+  /**\n+   * Delete the overrides and restart domain to get clean state.\n+   */\n+  @AfterEach\n+  public void afterEach() {\n+    deleteConfigMap(overridecm, domainNamespace);\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\"},\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+    restartDomain();\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden dynamically when\n+   * /spec/configuration/overrideDistributionStrategy: field is not set. By default it should be DYNAMIC.\n+   *\n+   * <p>Test sets the /spec/configuration/overridesConfigMap and with new configuration for config.xml and datasources.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are updated\n+   * as expected.\n+   */\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy set to DEFAULT\")\n+  public void testDefaultOverride() {\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap and introspectVersion\");\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"1\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC0Override(true);\n+  }\n+\n+  /**\n+   * Test server configuration and datasource configurations are dynamically overridden when\n+   * /spec/configuration/overrideDistributionStrategy is set to DYNAMIC.\n+   *\n+   * <p>Test sets the above field to DYNAMIC and overrides the /spec/configuration/overridesConfigMap\n+   * with new configuration.\n+   *\n+   * <p>Verifies after introspector runs and the server configuration and JDBC datasource configurations are\n+   * updated as expected.\n+   */\n+  @Disabled\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value DYNAMIC\")\n+  public void testDynamicOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: DYNAMIC\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"DYNAMIC\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?\n+    restartDomain(); // if above is a bug, remove this after the above bug is fixed\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap, secrets , cluster and introspectVersion\");\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"2\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC0Override(true);\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden on restart of pods when\n+   * /spec/configuration/overrideDistributionStrategy is set to ON_RESTART.\n+   *\n+   * <p>Test sets the above field to ON_RESTART and overrides the /spec/configuration/overridesConfigMap and\n+   * /spec/configuration/secrets with new configuration and new secrets.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are not\n+   * updated. Verifies the overrides are applied only after a domain restart.\n+   */\n+  @Disabled\n+  @Order(3)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value ON_RESTART\")\n+  public void testOnRestartOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: ON_RESTART\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"ON_RESTART\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?\n+    restartDomain(); // if above is a bug, remove this after the above bug is fixed\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    logger.info(\"Creating secrets for JDBC datasource overrides\");\n+    //create new secrets for jdbc datasource\n+    Map<String, String> secretMap = new HashMap<>();\n+    secretMap.put(\"dbusername\", \"root\");\n+    secretMap.put(\"dbpassword\", \"root456\");\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(dsSecret)\n+            .namespace(domainNamespace))\n+        .stringData(secretMap)), \"Creating secret for datasource failed.\");\n+    assertTrue(secretCreated, String.format(\"creating secret failed %s\", dsSecret));\n+\n+    //copy the template datasource file for override after replacing JDBC_URL with new datasource url\n+    Path srcDsOverrideFile = Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-1.xml\");\n+    Path dstDsOverrideFile = Paths.get(WORK_DIR, \"jdbc-JdbcTestDataSource-1.xml\");\n+    String tempString = assertDoesNotThrow(()\n+        -> Files.readString(srcDsOverrideFile).replaceAll(\"JDBC_URL\", dsUrl2));\n+    assertDoesNotThrow(()\n+        -> Files.write(dstDsOverrideFile, tempString.getBytes(StandardCharsets.UTF_8)));\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(dstDsOverrideFile);\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    //patch the domain resource with overridesConfigMap, secrets and introspectVersion\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\", \\\"value\\\": [\\\"\" + dsSecret + \"\\\"]  },\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"3\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    try {\n+      //wait for a minute to see if the overrides are not applied\n+      TimeUnit.MINUTES.sleep(1);\n+    } catch (InterruptedException ex) {\n+      //ignore\n+    }\n+\n+    //verify the overrides are not applied\n+    verifyConfigXMLOverride(false);\n+    verifyResourceJDBC0Override(false);\n+\n+    //restart domain for the distributionstrategy to take effect\n+    restartDomain();\n+\n+    //verify on restart the overrides are applied\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC1Override(true);\n+\n+    //cleanup secret\n+    deleteSecret(dsSecret, domainNamespace);\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+  }\n+\n+  /**\n+   * Test patching the domain with values for /spec/configuration/overrideDistributionStrategy field anything other than\n+   * DYNAMIC or ON_RESTART fails.\n+   *\n+   * <p>Test tries to set the above field to RESTART and asserts the patching fails.\n+   */\n+  @Disabled\n+  @Order(4)\n+  @Test\n+  @DisplayName(\"Test invalid overrideDistributionStrategy value RESTART\")\n+  public void testOverrideNegative() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: RESTART", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY1MzkyMg=="}, "originalCommit": {"oid": "ed1e738b6d6e8ede701e73a7f95bcf26e057a4f4"}, "originalPosition": 512}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY3NzEwOA==", "bodyText": "ok", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r448677108", "createdAt": "2020-07-02T00:04:26Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "diffHunk": "@@ -0,0 +1,1148 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownDomain;\n+import static oracle.weblogic.kubernetes.actions.TestActions.startDomain;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.MySQLDBUtils.createMySQLDB;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static oracle.weblogic.kubernetes.utils.WLSTUtils.executeWLSTScript;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests related to overrideDistributionStrategy attribute.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the overrideDistributionStrategy applies the overrides accordingly to the value set\")\n+@IntegrationTest\n+public class ItConfigDistributionStrategy {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path clusterViewAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  static int mysqlDBPort1;\n+  static int mysqlDBPort2;\n+  static String dsUrl1;\n+  static String dsUrl2;\n+\n+  String dsName0 = \"JdbcTestDataSource-0\";\n+  String dsName1 = \"JdbcTestDataSource-1\";\n+  String dsSecret = domainUid.concat(\"-mysql-secret\");\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   * Creates 2 MySQL database instances.\n+   * Creates and starts WebLogic domain containing 2 instances in dynamic cluser.\n+   * Creates 2 JDBC data sources targeted to cluster.\n+   * Deploys clusterview application to cluster and admin targets.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for domain namspace\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+\n+    // build the clusterview application\n+    Path distDir = buildApplication(Paths.get(APP_DIR, \"clusterview\"),\n+        null, null, \"dist\", domainNamespace);\n+    clusterViewAppPath = Paths.get(distDir.toString(), \"clusterview.war\");\n+    assertTrue(clusterViewAppPath.toFile().exists(), \"Application archive is not available\");\n+\n+    //start two MySQL database instances\n+    mysqlDBPort1 = getNextFreePort(30000, 32767);\n+    createMySQLDB(\"mysqldb-1\", \"root\", \"root123\", mysqlDBPort1, domainNamespace, null);\n+    mysqlDBPort2 = getNextFreePort(31000, 32767);\n+    createMySQLDB(\"mysqldb-2\", \"root\", \"root456\", mysqlDBPort2, domainNamespace, null);\n+\n+    dsUrl1 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort1;\n+    dsUrl2 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort2;\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    } else {\n+      // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+\n+    //create and start WebLogic domain\n+    createDomain();\n+    //create a jdbc resource targeted to cluster\n+    createJdbcDataSource(dsName0, \"root\", \"root123\", mysqlDBPort1);\n+    createJdbcDataSource(dsName1, \"root\", \"root123\", mysqlDBPort1);\n+    //deploy application to view server configuration\n+    deployApplication(clusterName + \",\" + adminServerName);\n+\n+  }\n+\n+  /**\n+   * Verify the default config before starting any test.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    //check configuration values before override\n+    verifyConfigXMLOverride(false);\n+    verifyResourceJDBC0Override(false);\n+  }\n+\n+  /**\n+   * Delete the overrides and restart domain to get clean state.\n+   */\n+  @AfterEach\n+  public void afterEach() {\n+    deleteConfigMap(overridecm, domainNamespace);\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\"},\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+    restartDomain();\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden dynamically when\n+   * /spec/configuration/overrideDistributionStrategy: field is not set. By default it should be DYNAMIC.\n+   *\n+   * <p>Test sets the /spec/configuration/overridesConfigMap and with new configuration for config.xml and datasources.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are updated\n+   * as expected.\n+   */\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy set to DEFAULT\")\n+  public void testDefaultOverride() {\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap and introspectVersion\");\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"1\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC0Override(true);\n+  }\n+\n+  /**\n+   * Test server configuration and datasource configurations are dynamically overridden when\n+   * /spec/configuration/overrideDistributionStrategy is set to DYNAMIC.\n+   *\n+   * <p>Test sets the above field to DYNAMIC and overrides the /spec/configuration/overridesConfigMap\n+   * with new configuration.\n+   *\n+   * <p>Verifies after introspector runs and the server configuration and JDBC datasource configurations are\n+   * updated as expected.\n+   */\n+  @Disabled\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value DYNAMIC\")\n+  public void testDynamicOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: DYNAMIC\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"DYNAMIC\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?\n+    restartDomain(); // if above is a bug, remove this after the above bug is fixed\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap, secrets , cluster and introspectVersion\");\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"2\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC0Override(true);\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden on restart of pods when\n+   * /spec/configuration/overrideDistributionStrategy is set to ON_RESTART.\n+   *\n+   * <p>Test sets the above field to ON_RESTART and overrides the /spec/configuration/overridesConfigMap and\n+   * /spec/configuration/secrets with new configuration and new secrets.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are not\n+   * updated. Verifies the overrides are applied only after a domain restart.\n+   */\n+  @Disabled\n+  @Order(3)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value ON_RESTART\")\n+  public void testOnRestartOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: ON_RESTART\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"ON_RESTART\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?\n+    restartDomain(); // if above is a bug, remove this after the above bug is fixed\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    logger.info(\"Creating secrets for JDBC datasource overrides\");\n+    //create new secrets for jdbc datasource\n+    Map<String, String> secretMap = new HashMap<>();\n+    secretMap.put(\"dbusername\", \"root\");\n+    secretMap.put(\"dbpassword\", \"root456\");\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(dsSecret)\n+            .namespace(domainNamespace))\n+        .stringData(secretMap)), \"Creating secret for datasource failed.\");\n+    assertTrue(secretCreated, String.format(\"creating secret failed %s\", dsSecret));\n+\n+    //copy the template datasource file for override after replacing JDBC_URL with new datasource url\n+    Path srcDsOverrideFile = Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-1.xml\");\n+    Path dstDsOverrideFile = Paths.get(WORK_DIR, \"jdbc-JdbcTestDataSource-1.xml\");\n+    String tempString = assertDoesNotThrow(()\n+        -> Files.readString(srcDsOverrideFile).replaceAll(\"JDBC_URL\", dsUrl2));\n+    assertDoesNotThrow(()\n+        -> Files.write(dstDsOverrideFile, tempString.getBytes(StandardCharsets.UTF_8)));\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(dstDsOverrideFile);\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    //patch the domain resource with overridesConfigMap, secrets and introspectVersion\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\", \\\"value\\\": [\\\"\" + dsSecret + \"\\\"]  },\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"3\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    try {\n+      //wait for a minute to see if the overrides are not applied\n+      TimeUnit.MINUTES.sleep(1);\n+    } catch (InterruptedException ex) {\n+      //ignore\n+    }\n+\n+    //verify the overrides are not applied\n+    verifyConfigXMLOverride(false);\n+    verifyResourceJDBC0Override(false);\n+\n+    //restart domain for the distributionstrategy to take effect\n+    restartDomain();\n+\n+    //verify on restart the overrides are applied\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC1Override(true);\n+\n+    //cleanup secret\n+    deleteSecret(dsSecret, domainNamespace);\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+  }\n+\n+  /**\n+   * Test patching the domain with values for /spec/configuration/overrideDistributionStrategy field anything other than\n+   * DYNAMIC or ON_RESTART fails.\n+   *\n+   * <p>Test tries to set the above field to RESTART and asserts the patching fails.\n+   */\n+  @Disabled\n+  @Order(4)\n+  @Test\n+  @DisplayName(\"Test invalid overrideDistributionStrategy value RESTART\")\n+  public void testOverrideNegative() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: RESTART", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY1MzkyMg=="}, "originalCommit": {"oid": "ed1e738b6d6e8ede701e73a7f95bcf26e057a4f4"}, "originalPosition": 512}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NjM5OTYzOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMjo0OToyOFrOGr3vVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMzoxNToyNlrOGr4OWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY1NTE4OQ==", "bodyText": "Does the test depends on the Debug Flags output during result verification ?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r448655189", "createdAt": "2020-07-01T22:49:28Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "diffHunk": "@@ -0,0 +1,1148 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownDomain;\n+import static oracle.weblogic.kubernetes.actions.TestActions.startDomain;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.MySQLDBUtils.createMySQLDB;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static oracle.weblogic.kubernetes.utils.WLSTUtils.executeWLSTScript;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests related to overrideDistributionStrategy attribute.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the overrideDistributionStrategy applies the overrides accordingly to the value set\")\n+@IntegrationTest\n+public class ItConfigDistributionStrategy {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path clusterViewAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  static int mysqlDBPort1;\n+  static int mysqlDBPort2;\n+  static String dsUrl1;\n+  static String dsUrl2;\n+\n+  String dsName0 = \"JdbcTestDataSource-0\";\n+  String dsName1 = \"JdbcTestDataSource-1\";\n+  String dsSecret = domainUid.concat(\"-mysql-secret\");\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   * Creates 2 MySQL database instances.\n+   * Creates and starts WebLogic domain containing 2 instances in dynamic cluser.\n+   * Creates 2 JDBC data sources targeted to cluster.\n+   * Deploys clusterview application to cluster and admin targets.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for domain namspace\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+\n+    // build the clusterview application\n+    Path distDir = buildApplication(Paths.get(APP_DIR, \"clusterview\"),\n+        null, null, \"dist\", domainNamespace);\n+    clusterViewAppPath = Paths.get(distDir.toString(), \"clusterview.war\");\n+    assertTrue(clusterViewAppPath.toFile().exists(), \"Application archive is not available\");\n+\n+    //start two MySQL database instances\n+    mysqlDBPort1 = getNextFreePort(30000, 32767);\n+    createMySQLDB(\"mysqldb-1\", \"root\", \"root123\", mysqlDBPort1, domainNamespace, null);\n+    mysqlDBPort2 = getNextFreePort(31000, 32767);\n+    createMySQLDB(\"mysqldb-2\", \"root\", \"root456\", mysqlDBPort2, domainNamespace, null);\n+\n+    dsUrl1 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort1;\n+    dsUrl2 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort2;\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    } else {\n+      // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+\n+    //create and start WebLogic domain\n+    createDomain();\n+    //create a jdbc resource targeted to cluster\n+    createJdbcDataSource(dsName0, \"root\", \"root123\", mysqlDBPort1);\n+    createJdbcDataSource(dsName1, \"root\", \"root123\", mysqlDBPort1);\n+    //deploy application to view server configuration\n+    deployApplication(clusterName + \",\" + adminServerName);\n+\n+  }\n+\n+  /**\n+   * Verify the default config before starting any test.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    //check configuration values before override\n+    verifyConfigXMLOverride(false);\n+    verifyResourceJDBC0Override(false);\n+  }\n+\n+  /**\n+   * Delete the overrides and restart domain to get clean state.\n+   */\n+  @AfterEach\n+  public void afterEach() {\n+    deleteConfigMap(overridecm, domainNamespace);\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\"},\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+    restartDomain();\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden dynamically when\n+   * /spec/configuration/overrideDistributionStrategy: field is not set. By default it should be DYNAMIC.\n+   *\n+   * <p>Test sets the /spec/configuration/overridesConfigMap and with new configuration for config.xml and datasources.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are updated\n+   * as expected.\n+   */\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy set to DEFAULT\")\n+  public void testDefaultOverride() {\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap and introspectVersion\");\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"1\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC0Override(true);\n+  }\n+\n+  /**\n+   * Test server configuration and datasource configurations are dynamically overridden when\n+   * /spec/configuration/overrideDistributionStrategy is set to DYNAMIC.\n+   *\n+   * <p>Test sets the above field to DYNAMIC and overrides the /spec/configuration/overridesConfigMap\n+   * with new configuration.\n+   *\n+   * <p>Verifies after introspector runs and the server configuration and JDBC datasource configurations are\n+   * updated as expected.\n+   */\n+  @Disabled\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value DYNAMIC\")\n+  public void testDynamicOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: DYNAMIC\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"DYNAMIC\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?\n+    restartDomain(); // if above is a bug, remove this after the above bug is fixed\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap, secrets , cluster and introspectVersion\");\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"2\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC0Override(true);\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden on restart of pods when\n+   * /spec/configuration/overrideDistributionStrategy is set to ON_RESTART.\n+   *\n+   * <p>Test sets the above field to ON_RESTART and overrides the /spec/configuration/overridesConfigMap and\n+   * /spec/configuration/secrets with new configuration and new secrets.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are not\n+   * updated. Verifies the overrides are applied only after a domain restart.\n+   */\n+  @Disabled\n+  @Order(3)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value ON_RESTART\")\n+  public void testOnRestartOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: ON_RESTART\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"ON_RESTART\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?\n+    restartDomain(); // if above is a bug, remove this after the above bug is fixed\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    logger.info(\"Creating secrets for JDBC datasource overrides\");\n+    //create new secrets for jdbc datasource\n+    Map<String, String> secretMap = new HashMap<>();\n+    secretMap.put(\"dbusername\", \"root\");\n+    secretMap.put(\"dbpassword\", \"root456\");\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(dsSecret)\n+            .namespace(domainNamespace))\n+        .stringData(secretMap)), \"Creating secret for datasource failed.\");\n+    assertTrue(secretCreated, String.format(\"creating secret failed %s\", dsSecret));\n+\n+    //copy the template datasource file for override after replacing JDBC_URL with new datasource url\n+    Path srcDsOverrideFile = Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-1.xml\");\n+    Path dstDsOverrideFile = Paths.get(WORK_DIR, \"jdbc-JdbcTestDataSource-1.xml\");\n+    String tempString = assertDoesNotThrow(()\n+        -> Files.readString(srcDsOverrideFile).replaceAll(\"JDBC_URL\", dsUrl2));\n+    assertDoesNotThrow(()\n+        -> Files.write(dstDsOverrideFile, tempString.getBytes(StandardCharsets.UTF_8)));\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(dstDsOverrideFile);\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    //patch the domain resource with overridesConfigMap, secrets and introspectVersion\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\", \\\"value\\\": [\\\"\" + dsSecret + \"\\\"]  },\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"3\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    try {\n+      //wait for a minute to see if the overrides are not applied\n+      TimeUnit.MINUTES.sleep(1);\n+    } catch (InterruptedException ex) {\n+      //ignore\n+    }\n+\n+    //verify the overrides are not applied\n+    verifyConfigXMLOverride(false);\n+    verifyResourceJDBC0Override(false);\n+\n+    //restart domain for the distributionstrategy to take effect\n+    restartDomain();\n+\n+    //verify on restart the overrides are applied\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC1Override(true);\n+\n+    //cleanup secret\n+    deleteSecret(dsSecret, domainNamespace);\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+  }\n+\n+  /**\n+   * Test patching the domain with values for /spec/configuration/overrideDistributionStrategy field anything other than\n+   * DYNAMIC or ON_RESTART fails.\n+   *\n+   * <p>Test tries to set the above field to RESTART and asserts the patching fails.\n+   */\n+  @Disabled\n+  @Order(4)\n+  @Test\n+  @DisplayName(\"Test invalid overrideDistributionStrategy value RESTART\")\n+  public void testOverrideNegative() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: RESTART\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"RESTART\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertFalse(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Patch domain with invalid overrideDistributionStrategy succeeded.\");\n+\n+    //verify the overrides are not applied and original configuration is still effective\n+    verifyConfigXMLOverride(false);\n+  }\n+\n+  private Callable<Boolean> configUpdated() {\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(domainNamespace, adminServerPodName\n+            + \"-external\",\n+            \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    //verify server attribute MaxMessageSize\n+    String appURI = \"/clusterview/ConfigServlet?\"\n+        + \"attributeTest=true&\"\n+        + \"serverType=adminserver&\"\n+        + \"serverName=\" + adminServerName;\n+    String url = \"http://\" + K8S_NODEPORT_HOST + \":\" + serviceNodePort + appURI;\n+\n+    String maxMessageSize = \"78787878\";\n+    return (()\n+        -> {\n+      HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(url, true));\n+      assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+      return response.body().contains(\"MaxMessageSize=\".concat(maxMessageSize));\n+    });\n+  }\n+\n+  private void verifyConfigXMLOverride(boolean configUpdated) {\n+\n+    int port = getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+    String baseUri = \"http://\" + K8S_NODEPORT_HOST + \":\" + port + \"/clusterview/\";\n+\n+    //verify server attribute MaxMessageSize to be equal to 78787878\n+    String configUri = \"ConfigServlet?\"\n+        + \"attributeTest=true\"\n+        + \"&serverType=adminserver\"\n+        + \"&serverName=\" + adminServerName;\n+    HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(baseUri + configUri, true));\n+\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    if (configUpdated) {\n+      assertTrue(response.body().contains(\"MaxMessageSize=78787878\"), \"Didn't get MaxMessageSize=78787878\");\n+    } else {\n+      assertTrue(response.body().contains(\"MaxMessageSize=10000000\"), \"Didn't get MaxMessageSize=10000000\");\n+    }\n+\n+  }\n+\n+  //use the http client and access the clusterview application to get server configuration\n+  //and JDBC datasource configuration.\n+  private void verifyResourceJDBC0Override(boolean configUpdated) {\n+\n+    // get admin server node port and construct a base url for clusterview app\n+    int port = getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+    String baseUri = \"http://\" + K8S_NODEPORT_HOST + \":\" + port + \"/clusterview/ConfigServlet?\";\n+\n+    //verify datasource attributes of JdbcTestDataSource-0\n+    String appURI = \"resTest=true&resName=\" + dsName0;\n+    String dsOverrideTestUrl = baseUri + appURI;\n+    HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(dsOverrideTestUrl, true));\n+\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    if (configUpdated) {\n+      assertTrue(response.body().contains(\"getMaxCapacity:12\"), \"Did get getMaxCapacity:12\");\n+      assertTrue(response.body().contains(\"getInitialCapacity:2\"), \"Did get getInitialCapacity:2\");\n+    } else {\n+      assertTrue(response.body().contains(\"getMaxCapacity:15\"), \"Did get getMaxCapacity:15\");\n+      assertTrue(response.body().contains(\"getInitialCapacity:1\"), \"Did get getInitialCapacity:1\");\n+    }\n+\n+    //test connection pool in all managed servers of dynamic cluster\n+    for (int i = 1; i <= replicaCount; i++) {\n+      appURI = \"dsTest=true&dsName=\" + dsName0 + \"&\" + \"serverName=\" + managedServerNameBase + i;\n+      String dsConnectionPoolTestUrl = baseUri + appURI;\n+      response = assertDoesNotThrow(() -> OracleHttpClient.get(dsConnectionPoolTestUrl, true));\n+      assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+      assertTrue(response.body().contains(\"Connection successful\"), \"Didn't get Connection successful\");\n+    }\n+  }\n+\n+  //use the http client and access the clusterview application to get server configuration\n+  //and JDBC datasource configuration.\n+  private void verifyResourceJDBC1Override(boolean configUpdated) {\n+\n+    // get admin server node port and construct a base url for clusterview app\n+    int port = getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+    String baseUri = \"http://\" + K8S_NODEPORT_HOST + \":\" + port + \"/clusterview/ConfigServlet?\";\n+\n+    //verify datasource attributes of JdbcTestDataSource-0\n+    String appURI = \"resTest=true&resName=\" + dsName1;\n+    String dsOverrideTestUrl = baseUri + appURI;\n+    HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(dsOverrideTestUrl, true));\n+\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    if (configUpdated) {\n+      assertTrue(response.body().contains(\"getMaxCapacity:10\"), \"Did get getMaxCapacity:10\");\n+      assertTrue(response.body().contains(\"getInitialCapacity:4\"), \"Did get getInitialCapacity:4\");\n+      assertTrue(response.body().contains(\"Url:\" + dsUrl2), \"Didn't get Url:\" + dsUrl2);\n+    } else {\n+      assertTrue(response.body().contains(\"getMaxCapacity:15\"), \"Did get getMaxCapacity:15\");\n+      assertTrue(response.body().contains(\"getInitialCapacity:1\"), \"Did get getInitialCapacity:1\");\n+      assertTrue(response.body().contains(\"Url:\" + dsUrl1), \"Didn't get Url:\" + dsUrl1);\n+    }\n+\n+    //test connection pool in all managed servers of dynamic cluster\n+    for (int i = 1; i <= replicaCount; i++) {\n+      appURI = \"dsTest=true&dsName=\" + dsName1 + \"&\" + \"serverName=\" + managedServerNameBase + i;\n+      String dsConnectionPoolTestUrl = baseUri + appURI;\n+      response = assertDoesNotThrow(() -> OracleHttpClient.get(dsConnectionPoolTestUrl, true));\n+      assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+      assertTrue(response.body().contains(\"Connection successful\"), \"Didn't get Connection successful\");\n+    }\n+  }\n+\n+  //store pod creation timestamps for podstate check\n+  private void storePodCreationTimestamps() {\n+    // get the pod creation time stamps\n+    podTimestamps = new LinkedHashMap<>();\n+    // get the creation time of the admin server pod before patching\n+    DateTime adminPodCreationTime = getPodCreationTime(domainNamespace, adminServerPodName);\n+    podTimestamps.put(adminServerPodName, adminPodCreationTime);\n+    // get the creation time of the managed server pods before patching\n+    for (int i = 1; i <= replicaCount; i++) {\n+      podTimestamps.put(managedServerPodNamePrefix + i,\n+          getPodCreationTime(domainNamespace, managedServerPodNamePrefix + i));\n+    }\n+  }\n+\n+  //check if the pods are restarted by comparing the pod creationtimestamp.\n+  private void verifyPodsStateNotChanged() {\n+    logger.info(\"Verifying the WebLogic server pod states are not changed\");\n+    for (Map.Entry<String, DateTime> entry : podTimestamps.entrySet()) {\n+      String podName = (String) entry.getKey();\n+      DateTime creationTimestamp = (DateTime) entry.getValue();\n+      assertTrue(podStateNotChanged(podName, domainUid, domainNamespace,\n+          creationTimestamp), \"Pod is restarted\");\n+    }\n+  }\n+\n+  //verify the introspector pod is created and run\n+  private void verifyIntrospectorRuns() {\n+    //verify the introspector pod is created and runs\n+    logger.info(\"Verifying introspector pod is created, runs and deleted\");\n+    String introspectPodName = domainUid + \"-\" + \"introspect-domain-job\";\n+    checkPodExists(introspectPodName, domainUid, domainNamespace);\n+    checkPodDoesNotExist(introspectPodName, domainUid, domainNamespace);\n+  }\n+\n+  //create a standard WebLogic domain.\n+  private void createDomain() {\n+\n+    // create WebLogic domain credential secret\n+    createSecretWithUsernamePassword(wlSecretName, domainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, domainNamespace);\n+\n+    t3ChannelPort = getNextFreePort(30000, 32767);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = assertDoesNotThrow(()\n+        -> File.createTempFile(\"domain\", \".properties\"),\n+        \"Failed to create domain properties file\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", Integer.toString(managedServerPort));\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"2\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    assertDoesNotThrow(()\n+        -> p.store(new FileOutputStream(domainPropertiesFile), \"domain properties file\"),\n+        \"Failed to write domain properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, domainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .configuration(new Configuration()\n+                .overrideDistributionStrategy(\"DYNAMIC\"))\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid) // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.debug.DebugSituationalConfig=true\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed1e738b6d6e8ede701e73a7f95bcf26e057a4f4"}, "originalPosition": 746}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY2MzEzMQ==", "bodyText": "No, the test doesn't depend on it for verifying overrides. But when it fails the logs will be useful to debug.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r448663131", "createdAt": "2020-07-01T23:15:26Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "diffHunk": "@@ -0,0 +1,1148 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownDomain;\n+import static oracle.weblogic.kubernetes.actions.TestActions.startDomain;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.MySQLDBUtils.createMySQLDB;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static oracle.weblogic.kubernetes.utils.WLSTUtils.executeWLSTScript;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests related to overrideDistributionStrategy attribute.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the overrideDistributionStrategy applies the overrides accordingly to the value set\")\n+@IntegrationTest\n+public class ItConfigDistributionStrategy {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path clusterViewAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  static int mysqlDBPort1;\n+  static int mysqlDBPort2;\n+  static String dsUrl1;\n+  static String dsUrl2;\n+\n+  String dsName0 = \"JdbcTestDataSource-0\";\n+  String dsName1 = \"JdbcTestDataSource-1\";\n+  String dsSecret = domainUid.concat(\"-mysql-secret\");\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   * Creates 2 MySQL database instances.\n+   * Creates and starts WebLogic domain containing 2 instances in dynamic cluser.\n+   * Creates 2 JDBC data sources targeted to cluster.\n+   * Deploys clusterview application to cluster and admin targets.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for domain namspace\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+\n+    // build the clusterview application\n+    Path distDir = buildApplication(Paths.get(APP_DIR, \"clusterview\"),\n+        null, null, \"dist\", domainNamespace);\n+    clusterViewAppPath = Paths.get(distDir.toString(), \"clusterview.war\");\n+    assertTrue(clusterViewAppPath.toFile().exists(), \"Application archive is not available\");\n+\n+    //start two MySQL database instances\n+    mysqlDBPort1 = getNextFreePort(30000, 32767);\n+    createMySQLDB(\"mysqldb-1\", \"root\", \"root123\", mysqlDBPort1, domainNamespace, null);\n+    mysqlDBPort2 = getNextFreePort(31000, 32767);\n+    createMySQLDB(\"mysqldb-2\", \"root\", \"root456\", mysqlDBPort2, domainNamespace, null);\n+\n+    dsUrl1 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort1;\n+    dsUrl2 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort2;\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    } else {\n+      // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+\n+    //create and start WebLogic domain\n+    createDomain();\n+    //create a jdbc resource targeted to cluster\n+    createJdbcDataSource(dsName0, \"root\", \"root123\", mysqlDBPort1);\n+    createJdbcDataSource(dsName1, \"root\", \"root123\", mysqlDBPort1);\n+    //deploy application to view server configuration\n+    deployApplication(clusterName + \",\" + adminServerName);\n+\n+  }\n+\n+  /**\n+   * Verify the default config before starting any test.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    //check configuration values before override\n+    verifyConfigXMLOverride(false);\n+    verifyResourceJDBC0Override(false);\n+  }\n+\n+  /**\n+   * Delete the overrides and restart domain to get clean state.\n+   */\n+  @AfterEach\n+  public void afterEach() {\n+    deleteConfigMap(overridecm, domainNamespace);\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\"},\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+    restartDomain();\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden dynamically when\n+   * /spec/configuration/overrideDistributionStrategy: field is not set. By default it should be DYNAMIC.\n+   *\n+   * <p>Test sets the /spec/configuration/overridesConfigMap and with new configuration for config.xml and datasources.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are updated\n+   * as expected.\n+   */\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy set to DEFAULT\")\n+  public void testDefaultOverride() {\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap and introspectVersion\");\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"1\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC0Override(true);\n+  }\n+\n+  /**\n+   * Test server configuration and datasource configurations are dynamically overridden when\n+   * /spec/configuration/overrideDistributionStrategy is set to DYNAMIC.\n+   *\n+   * <p>Test sets the above field to DYNAMIC and overrides the /spec/configuration/overridesConfigMap\n+   * with new configuration.\n+   *\n+   * <p>Verifies after introspector runs and the server configuration and JDBC datasource configurations are\n+   * updated as expected.\n+   */\n+  @Disabled\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value DYNAMIC\")\n+  public void testDynamicOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: DYNAMIC\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"DYNAMIC\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?\n+    restartDomain(); // if above is a bug, remove this after the above bug is fixed\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap, secrets , cluster and introspectVersion\");\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"2\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC0Override(true);\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden on restart of pods when\n+   * /spec/configuration/overrideDistributionStrategy is set to ON_RESTART.\n+   *\n+   * <p>Test sets the above field to ON_RESTART and overrides the /spec/configuration/overridesConfigMap and\n+   * /spec/configuration/secrets with new configuration and new secrets.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are not\n+   * updated. Verifies the overrides are applied only after a domain restart.\n+   */\n+  @Disabled\n+  @Order(3)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value ON_RESTART\")\n+  public void testOnRestartOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: ON_RESTART\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"ON_RESTART\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?\n+    restartDomain(); // if above is a bug, remove this after the above bug is fixed\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    logger.info(\"Creating secrets for JDBC datasource overrides\");\n+    //create new secrets for jdbc datasource\n+    Map<String, String> secretMap = new HashMap<>();\n+    secretMap.put(\"dbusername\", \"root\");\n+    secretMap.put(\"dbpassword\", \"root456\");\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(dsSecret)\n+            .namespace(domainNamespace))\n+        .stringData(secretMap)), \"Creating secret for datasource failed.\");\n+    assertTrue(secretCreated, String.format(\"creating secret failed %s\", dsSecret));\n+\n+    //copy the template datasource file for override after replacing JDBC_URL with new datasource url\n+    Path srcDsOverrideFile = Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-1.xml\");\n+    Path dstDsOverrideFile = Paths.get(WORK_DIR, \"jdbc-JdbcTestDataSource-1.xml\");\n+    String tempString = assertDoesNotThrow(()\n+        -> Files.readString(srcDsOverrideFile).replaceAll(\"JDBC_URL\", dsUrl2));\n+    assertDoesNotThrow(()\n+        -> Files.write(dstDsOverrideFile, tempString.getBytes(StandardCharsets.UTF_8)));\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(dstDsOverrideFile);\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    //patch the domain resource with overridesConfigMap, secrets and introspectVersion\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\", \\\"value\\\": [\\\"\" + dsSecret + \"\\\"]  },\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"3\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    try {\n+      //wait for a minute to see if the overrides are not applied\n+      TimeUnit.MINUTES.sleep(1);\n+    } catch (InterruptedException ex) {\n+      //ignore\n+    }\n+\n+    //verify the overrides are not applied\n+    verifyConfigXMLOverride(false);\n+    verifyResourceJDBC0Override(false);\n+\n+    //restart domain for the distributionstrategy to take effect\n+    restartDomain();\n+\n+    //verify on restart the overrides are applied\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC1Override(true);\n+\n+    //cleanup secret\n+    deleteSecret(dsSecret, domainNamespace);\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+  }\n+\n+  /**\n+   * Test patching the domain with values for /spec/configuration/overrideDistributionStrategy field anything other than\n+   * DYNAMIC or ON_RESTART fails.\n+   *\n+   * <p>Test tries to set the above field to RESTART and asserts the patching fails.\n+   */\n+  @Disabled\n+  @Order(4)\n+  @Test\n+  @DisplayName(\"Test invalid overrideDistributionStrategy value RESTART\")\n+  public void testOverrideNegative() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: RESTART\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"RESTART\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertFalse(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Patch domain with invalid overrideDistributionStrategy succeeded.\");\n+\n+    //verify the overrides are not applied and original configuration is still effective\n+    verifyConfigXMLOverride(false);\n+  }\n+\n+  private Callable<Boolean> configUpdated() {\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(domainNamespace, adminServerPodName\n+            + \"-external\",\n+            \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    //verify server attribute MaxMessageSize\n+    String appURI = \"/clusterview/ConfigServlet?\"\n+        + \"attributeTest=true&\"\n+        + \"serverType=adminserver&\"\n+        + \"serverName=\" + adminServerName;\n+    String url = \"http://\" + K8S_NODEPORT_HOST + \":\" + serviceNodePort + appURI;\n+\n+    String maxMessageSize = \"78787878\";\n+    return (()\n+        -> {\n+      HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(url, true));\n+      assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+      return response.body().contains(\"MaxMessageSize=\".concat(maxMessageSize));\n+    });\n+  }\n+\n+  private void verifyConfigXMLOverride(boolean configUpdated) {\n+\n+    int port = getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+    String baseUri = \"http://\" + K8S_NODEPORT_HOST + \":\" + port + \"/clusterview/\";\n+\n+    //verify server attribute MaxMessageSize to be equal to 78787878\n+    String configUri = \"ConfigServlet?\"\n+        + \"attributeTest=true\"\n+        + \"&serverType=adminserver\"\n+        + \"&serverName=\" + adminServerName;\n+    HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(baseUri + configUri, true));\n+\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    if (configUpdated) {\n+      assertTrue(response.body().contains(\"MaxMessageSize=78787878\"), \"Didn't get MaxMessageSize=78787878\");\n+    } else {\n+      assertTrue(response.body().contains(\"MaxMessageSize=10000000\"), \"Didn't get MaxMessageSize=10000000\");\n+    }\n+\n+  }\n+\n+  //use the http client and access the clusterview application to get server configuration\n+  //and JDBC datasource configuration.\n+  private void verifyResourceJDBC0Override(boolean configUpdated) {\n+\n+    // get admin server node port and construct a base url for clusterview app\n+    int port = getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+    String baseUri = \"http://\" + K8S_NODEPORT_HOST + \":\" + port + \"/clusterview/ConfigServlet?\";\n+\n+    //verify datasource attributes of JdbcTestDataSource-0\n+    String appURI = \"resTest=true&resName=\" + dsName0;\n+    String dsOverrideTestUrl = baseUri + appURI;\n+    HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(dsOverrideTestUrl, true));\n+\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    if (configUpdated) {\n+      assertTrue(response.body().contains(\"getMaxCapacity:12\"), \"Did get getMaxCapacity:12\");\n+      assertTrue(response.body().contains(\"getInitialCapacity:2\"), \"Did get getInitialCapacity:2\");\n+    } else {\n+      assertTrue(response.body().contains(\"getMaxCapacity:15\"), \"Did get getMaxCapacity:15\");\n+      assertTrue(response.body().contains(\"getInitialCapacity:1\"), \"Did get getInitialCapacity:1\");\n+    }\n+\n+    //test connection pool in all managed servers of dynamic cluster\n+    for (int i = 1; i <= replicaCount; i++) {\n+      appURI = \"dsTest=true&dsName=\" + dsName0 + \"&\" + \"serverName=\" + managedServerNameBase + i;\n+      String dsConnectionPoolTestUrl = baseUri + appURI;\n+      response = assertDoesNotThrow(() -> OracleHttpClient.get(dsConnectionPoolTestUrl, true));\n+      assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+      assertTrue(response.body().contains(\"Connection successful\"), \"Didn't get Connection successful\");\n+    }\n+  }\n+\n+  //use the http client and access the clusterview application to get server configuration\n+  //and JDBC datasource configuration.\n+  private void verifyResourceJDBC1Override(boolean configUpdated) {\n+\n+    // get admin server node port and construct a base url for clusterview app\n+    int port = getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+    String baseUri = \"http://\" + K8S_NODEPORT_HOST + \":\" + port + \"/clusterview/ConfigServlet?\";\n+\n+    //verify datasource attributes of JdbcTestDataSource-0\n+    String appURI = \"resTest=true&resName=\" + dsName1;\n+    String dsOverrideTestUrl = baseUri + appURI;\n+    HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(dsOverrideTestUrl, true));\n+\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    if (configUpdated) {\n+      assertTrue(response.body().contains(\"getMaxCapacity:10\"), \"Did get getMaxCapacity:10\");\n+      assertTrue(response.body().contains(\"getInitialCapacity:4\"), \"Did get getInitialCapacity:4\");\n+      assertTrue(response.body().contains(\"Url:\" + dsUrl2), \"Didn't get Url:\" + dsUrl2);\n+    } else {\n+      assertTrue(response.body().contains(\"getMaxCapacity:15\"), \"Did get getMaxCapacity:15\");\n+      assertTrue(response.body().contains(\"getInitialCapacity:1\"), \"Did get getInitialCapacity:1\");\n+      assertTrue(response.body().contains(\"Url:\" + dsUrl1), \"Didn't get Url:\" + dsUrl1);\n+    }\n+\n+    //test connection pool in all managed servers of dynamic cluster\n+    for (int i = 1; i <= replicaCount; i++) {\n+      appURI = \"dsTest=true&dsName=\" + dsName1 + \"&\" + \"serverName=\" + managedServerNameBase + i;\n+      String dsConnectionPoolTestUrl = baseUri + appURI;\n+      response = assertDoesNotThrow(() -> OracleHttpClient.get(dsConnectionPoolTestUrl, true));\n+      assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+      assertTrue(response.body().contains(\"Connection successful\"), \"Didn't get Connection successful\");\n+    }\n+  }\n+\n+  //store pod creation timestamps for podstate check\n+  private void storePodCreationTimestamps() {\n+    // get the pod creation time stamps\n+    podTimestamps = new LinkedHashMap<>();\n+    // get the creation time of the admin server pod before patching\n+    DateTime adminPodCreationTime = getPodCreationTime(domainNamespace, adminServerPodName);\n+    podTimestamps.put(adminServerPodName, adminPodCreationTime);\n+    // get the creation time of the managed server pods before patching\n+    for (int i = 1; i <= replicaCount; i++) {\n+      podTimestamps.put(managedServerPodNamePrefix + i,\n+          getPodCreationTime(domainNamespace, managedServerPodNamePrefix + i));\n+    }\n+  }\n+\n+  //check if the pods are restarted by comparing the pod creationtimestamp.\n+  private void verifyPodsStateNotChanged() {\n+    logger.info(\"Verifying the WebLogic server pod states are not changed\");\n+    for (Map.Entry<String, DateTime> entry : podTimestamps.entrySet()) {\n+      String podName = (String) entry.getKey();\n+      DateTime creationTimestamp = (DateTime) entry.getValue();\n+      assertTrue(podStateNotChanged(podName, domainUid, domainNamespace,\n+          creationTimestamp), \"Pod is restarted\");\n+    }\n+  }\n+\n+  //verify the introspector pod is created and run\n+  private void verifyIntrospectorRuns() {\n+    //verify the introspector pod is created and runs\n+    logger.info(\"Verifying introspector pod is created, runs and deleted\");\n+    String introspectPodName = domainUid + \"-\" + \"introspect-domain-job\";\n+    checkPodExists(introspectPodName, domainUid, domainNamespace);\n+    checkPodDoesNotExist(introspectPodName, domainUid, domainNamespace);\n+  }\n+\n+  //create a standard WebLogic domain.\n+  private void createDomain() {\n+\n+    // create WebLogic domain credential secret\n+    createSecretWithUsernamePassword(wlSecretName, domainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, domainNamespace);\n+\n+    t3ChannelPort = getNextFreePort(30000, 32767);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = assertDoesNotThrow(()\n+        -> File.createTempFile(\"domain\", \".properties\"),\n+        \"Failed to create domain properties file\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", Integer.toString(managedServerPort));\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"2\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    assertDoesNotThrow(()\n+        -> p.store(new FileOutputStream(domainPropertiesFile), \"domain properties file\"),\n+        \"Failed to write domain properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, domainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .configuration(new Configuration()\n+                .overrideDistributionStrategy(\"DYNAMIC\"))\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid) // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.debug.DebugSituationalConfig=true\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY1NTE4OQ=="}, "originalCommit": {"oid": "ed1e738b6d6e8ede701e73a7f95bcf26e057a4f4"}, "originalPosition": 746}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NjQxMDU3OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMjo1NDozMVrOGr316g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMzoxNjoxOVrOGr4PdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY1Njg3NA==", "bodyText": "A good candidate for common Test Utility. May be we can comeback to refactor", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r448656874", "createdAt": "2020-07-01T22:54:31Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "diffHunk": "@@ -0,0 +1,1148 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownDomain;\n+import static oracle.weblogic.kubernetes.actions.TestActions.startDomain;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.MySQLDBUtils.createMySQLDB;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static oracle.weblogic.kubernetes.utils.WLSTUtils.executeWLSTScript;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests related to overrideDistributionStrategy attribute.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the overrideDistributionStrategy applies the overrides accordingly to the value set\")\n+@IntegrationTest\n+public class ItConfigDistributionStrategy {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path clusterViewAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  static int mysqlDBPort1;\n+  static int mysqlDBPort2;\n+  static String dsUrl1;\n+  static String dsUrl2;\n+\n+  String dsName0 = \"JdbcTestDataSource-0\";\n+  String dsName1 = \"JdbcTestDataSource-1\";\n+  String dsSecret = domainUid.concat(\"-mysql-secret\");\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   * Creates 2 MySQL database instances.\n+   * Creates and starts WebLogic domain containing 2 instances in dynamic cluser.\n+   * Creates 2 JDBC data sources targeted to cluster.\n+   * Deploys clusterview application to cluster and admin targets.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for domain namspace\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+\n+    // build the clusterview application\n+    Path distDir = buildApplication(Paths.get(APP_DIR, \"clusterview\"),\n+        null, null, \"dist\", domainNamespace);\n+    clusterViewAppPath = Paths.get(distDir.toString(), \"clusterview.war\");\n+    assertTrue(clusterViewAppPath.toFile().exists(), \"Application archive is not available\");\n+\n+    //start two MySQL database instances\n+    mysqlDBPort1 = getNextFreePort(30000, 32767);\n+    createMySQLDB(\"mysqldb-1\", \"root\", \"root123\", mysqlDBPort1, domainNamespace, null);\n+    mysqlDBPort2 = getNextFreePort(31000, 32767);\n+    createMySQLDB(\"mysqldb-2\", \"root\", \"root456\", mysqlDBPort2, domainNamespace, null);\n+\n+    dsUrl1 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort1;\n+    dsUrl2 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort2;\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    } else {\n+      // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+\n+    //create and start WebLogic domain\n+    createDomain();\n+    //create a jdbc resource targeted to cluster\n+    createJdbcDataSource(dsName0, \"root\", \"root123\", mysqlDBPort1);\n+    createJdbcDataSource(dsName1, \"root\", \"root123\", mysqlDBPort1);\n+    //deploy application to view server configuration\n+    deployApplication(clusterName + \",\" + adminServerName);\n+\n+  }\n+\n+  /**\n+   * Verify the default config before starting any test.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    //check configuration values before override\n+    verifyConfigXMLOverride(false);\n+    verifyResourceJDBC0Override(false);\n+  }\n+\n+  /**\n+   * Delete the overrides and restart domain to get clean state.\n+   */\n+  @AfterEach\n+  public void afterEach() {\n+    deleteConfigMap(overridecm, domainNamespace);\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\"},\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+    restartDomain();\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden dynamically when\n+   * /spec/configuration/overrideDistributionStrategy: field is not set. By default it should be DYNAMIC.\n+   *\n+   * <p>Test sets the /spec/configuration/overridesConfigMap and with new configuration for config.xml and datasources.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are updated\n+   * as expected.\n+   */\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy set to DEFAULT\")\n+  public void testDefaultOverride() {\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap and introspectVersion\");\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"1\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC0Override(true);\n+  }\n+\n+  /**\n+   * Test server configuration and datasource configurations are dynamically overridden when\n+   * /spec/configuration/overrideDistributionStrategy is set to DYNAMIC.\n+   *\n+   * <p>Test sets the above field to DYNAMIC and overrides the /spec/configuration/overridesConfigMap\n+   * with new configuration.\n+   *\n+   * <p>Verifies after introspector runs and the server configuration and JDBC datasource configurations are\n+   * updated as expected.\n+   */\n+  @Disabled\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value DYNAMIC\")\n+  public void testDynamicOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: DYNAMIC\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"DYNAMIC\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?\n+    restartDomain(); // if above is a bug, remove this after the above bug is fixed\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap, secrets , cluster and introspectVersion\");\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"2\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC0Override(true);\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden on restart of pods when\n+   * /spec/configuration/overrideDistributionStrategy is set to ON_RESTART.\n+   *\n+   * <p>Test sets the above field to ON_RESTART and overrides the /spec/configuration/overridesConfigMap and\n+   * /spec/configuration/secrets with new configuration and new secrets.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are not\n+   * updated. Verifies the overrides are applied only after a domain restart.\n+   */\n+  @Disabled\n+  @Order(3)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value ON_RESTART\")\n+  public void testOnRestartOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: ON_RESTART\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"ON_RESTART\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?\n+    restartDomain(); // if above is a bug, remove this after the above bug is fixed\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    logger.info(\"Creating secrets for JDBC datasource overrides\");\n+    //create new secrets for jdbc datasource\n+    Map<String, String> secretMap = new HashMap<>();\n+    secretMap.put(\"dbusername\", \"root\");\n+    secretMap.put(\"dbpassword\", \"root456\");\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(dsSecret)\n+            .namespace(domainNamespace))\n+        .stringData(secretMap)), \"Creating secret for datasource failed.\");\n+    assertTrue(secretCreated, String.format(\"creating secret failed %s\", dsSecret));\n+\n+    //copy the template datasource file for override after replacing JDBC_URL with new datasource url\n+    Path srcDsOverrideFile = Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-1.xml\");\n+    Path dstDsOverrideFile = Paths.get(WORK_DIR, \"jdbc-JdbcTestDataSource-1.xml\");\n+    String tempString = assertDoesNotThrow(()\n+        -> Files.readString(srcDsOverrideFile).replaceAll(\"JDBC_URL\", dsUrl2));\n+    assertDoesNotThrow(()\n+        -> Files.write(dstDsOverrideFile, tempString.getBytes(StandardCharsets.UTF_8)));\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(dstDsOverrideFile);\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    //patch the domain resource with overridesConfigMap, secrets and introspectVersion\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\", \\\"value\\\": [\\\"\" + dsSecret + \"\\\"]  },\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"3\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    try {\n+      //wait for a minute to see if the overrides are not applied\n+      TimeUnit.MINUTES.sleep(1);\n+    } catch (InterruptedException ex) {\n+      //ignore\n+    }\n+\n+    //verify the overrides are not applied\n+    verifyConfigXMLOverride(false);\n+    verifyResourceJDBC0Override(false);\n+\n+    //restart domain for the distributionstrategy to take effect\n+    restartDomain();\n+\n+    //verify on restart the overrides are applied\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC1Override(true);\n+\n+    //cleanup secret\n+    deleteSecret(dsSecret, domainNamespace);\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+  }\n+\n+  /**\n+   * Test patching the domain with values for /spec/configuration/overrideDistributionStrategy field anything other than\n+   * DYNAMIC or ON_RESTART fails.\n+   *\n+   * <p>Test tries to set the above field to RESTART and asserts the patching fails.\n+   */\n+  @Disabled\n+  @Order(4)\n+  @Test\n+  @DisplayName(\"Test invalid overrideDistributionStrategy value RESTART\")\n+  public void testOverrideNegative() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: RESTART\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"RESTART\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertFalse(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Patch domain with invalid overrideDistributionStrategy succeeded.\");\n+\n+    //verify the overrides are not applied and original configuration is still effective\n+    verifyConfigXMLOverride(false);\n+  }\n+\n+  private Callable<Boolean> configUpdated() {\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(domainNamespace, adminServerPodName\n+            + \"-external\",\n+            \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    //verify server attribute MaxMessageSize\n+    String appURI = \"/clusterview/ConfigServlet?\"\n+        + \"attributeTest=true&\"\n+        + \"serverType=adminserver&\"\n+        + \"serverName=\" + adminServerName;\n+    String url = \"http://\" + K8S_NODEPORT_HOST + \":\" + serviceNodePort + appURI;\n+\n+    String maxMessageSize = \"78787878\";\n+    return (()\n+        -> {\n+      HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(url, true));\n+      assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+      return response.body().contains(\"MaxMessageSize=\".concat(maxMessageSize));\n+    });\n+  }\n+\n+  private void verifyConfigXMLOverride(boolean configUpdated) {\n+\n+    int port = getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+    String baseUri = \"http://\" + K8S_NODEPORT_HOST + \":\" + port + \"/clusterview/\";\n+\n+    //verify server attribute MaxMessageSize to be equal to 78787878\n+    String configUri = \"ConfigServlet?\"\n+        + \"attributeTest=true\"\n+        + \"&serverType=adminserver\"\n+        + \"&serverName=\" + adminServerName;\n+    HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(baseUri + configUri, true));\n+\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    if (configUpdated) {\n+      assertTrue(response.body().contains(\"MaxMessageSize=78787878\"), \"Didn't get MaxMessageSize=78787878\");\n+    } else {\n+      assertTrue(response.body().contains(\"MaxMessageSize=10000000\"), \"Didn't get MaxMessageSize=10000000\");\n+    }\n+\n+  }\n+\n+  //use the http client and access the clusterview application to get server configuration\n+  //and JDBC datasource configuration.\n+  private void verifyResourceJDBC0Override(boolean configUpdated) {\n+\n+    // get admin server node port and construct a base url for clusterview app\n+    int port = getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+    String baseUri = \"http://\" + K8S_NODEPORT_HOST + \":\" + port + \"/clusterview/ConfigServlet?\";\n+\n+    //verify datasource attributes of JdbcTestDataSource-0\n+    String appURI = \"resTest=true&resName=\" + dsName0;\n+    String dsOverrideTestUrl = baseUri + appURI;\n+    HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(dsOverrideTestUrl, true));\n+\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    if (configUpdated) {\n+      assertTrue(response.body().contains(\"getMaxCapacity:12\"), \"Did get getMaxCapacity:12\");\n+      assertTrue(response.body().contains(\"getInitialCapacity:2\"), \"Did get getInitialCapacity:2\");\n+    } else {\n+      assertTrue(response.body().contains(\"getMaxCapacity:15\"), \"Did get getMaxCapacity:15\");\n+      assertTrue(response.body().contains(\"getInitialCapacity:1\"), \"Did get getInitialCapacity:1\");\n+    }\n+\n+    //test connection pool in all managed servers of dynamic cluster\n+    for (int i = 1; i <= replicaCount; i++) {\n+      appURI = \"dsTest=true&dsName=\" + dsName0 + \"&\" + \"serverName=\" + managedServerNameBase + i;\n+      String dsConnectionPoolTestUrl = baseUri + appURI;\n+      response = assertDoesNotThrow(() -> OracleHttpClient.get(dsConnectionPoolTestUrl, true));\n+      assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+      assertTrue(response.body().contains(\"Connection successful\"), \"Didn't get Connection successful\");\n+    }\n+  }\n+\n+  //use the http client and access the clusterview application to get server configuration\n+  //and JDBC datasource configuration.\n+  private void verifyResourceJDBC1Override(boolean configUpdated) {\n+\n+    // get admin server node port and construct a base url for clusterview app\n+    int port = getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+    String baseUri = \"http://\" + K8S_NODEPORT_HOST + \":\" + port + \"/clusterview/ConfigServlet?\";\n+\n+    //verify datasource attributes of JdbcTestDataSource-0\n+    String appURI = \"resTest=true&resName=\" + dsName1;\n+    String dsOverrideTestUrl = baseUri + appURI;\n+    HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(dsOverrideTestUrl, true));\n+\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    if (configUpdated) {\n+      assertTrue(response.body().contains(\"getMaxCapacity:10\"), \"Did get getMaxCapacity:10\");\n+      assertTrue(response.body().contains(\"getInitialCapacity:4\"), \"Did get getInitialCapacity:4\");\n+      assertTrue(response.body().contains(\"Url:\" + dsUrl2), \"Didn't get Url:\" + dsUrl2);\n+    } else {\n+      assertTrue(response.body().contains(\"getMaxCapacity:15\"), \"Did get getMaxCapacity:15\");\n+      assertTrue(response.body().contains(\"getInitialCapacity:1\"), \"Did get getInitialCapacity:1\");\n+      assertTrue(response.body().contains(\"Url:\" + dsUrl1), \"Didn't get Url:\" + dsUrl1);\n+    }\n+\n+    //test connection pool in all managed servers of dynamic cluster\n+    for (int i = 1; i <= replicaCount; i++) {\n+      appURI = \"dsTest=true&dsName=\" + dsName1 + \"&\" + \"serverName=\" + managedServerNameBase + i;\n+      String dsConnectionPoolTestUrl = baseUri + appURI;\n+      response = assertDoesNotThrow(() -> OracleHttpClient.get(dsConnectionPoolTestUrl, true));\n+      assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+      assertTrue(response.body().contains(\"Connection successful\"), \"Didn't get Connection successful\");\n+    }\n+  }\n+\n+  //store pod creation timestamps for podstate check\n+  private void storePodCreationTimestamps() {\n+    // get the pod creation time stamps\n+    podTimestamps = new LinkedHashMap<>();\n+    // get the creation time of the admin server pod before patching\n+    DateTime adminPodCreationTime = getPodCreationTime(domainNamespace, adminServerPodName);\n+    podTimestamps.put(adminServerPodName, adminPodCreationTime);\n+    // get the creation time of the managed server pods before patching\n+    for (int i = 1; i <= replicaCount; i++) {\n+      podTimestamps.put(managedServerPodNamePrefix + i,\n+          getPodCreationTime(domainNamespace, managedServerPodNamePrefix + i));\n+    }\n+  }\n+\n+  //check if the pods are restarted by comparing the pod creationtimestamp.\n+  private void verifyPodsStateNotChanged() {\n+    logger.info(\"Verifying the WebLogic server pod states are not changed\");\n+    for (Map.Entry<String, DateTime> entry : podTimestamps.entrySet()) {\n+      String podName = (String) entry.getKey();\n+      DateTime creationTimestamp = (DateTime) entry.getValue();\n+      assertTrue(podStateNotChanged(podName, domainUid, domainNamespace,\n+          creationTimestamp), \"Pod is restarted\");\n+    }\n+  }\n+\n+  //verify the introspector pod is created and run\n+  private void verifyIntrospectorRuns() {\n+    //verify the introspector pod is created and runs\n+    logger.info(\"Verifying introspector pod is created, runs and deleted\");\n+    String introspectPodName = domainUid + \"-\" + \"introspect-domain-job\";\n+    checkPodExists(introspectPodName, domainUid, domainNamespace);\n+    checkPodDoesNotExist(introspectPodName, domainUid, domainNamespace);\n+  }\n+\n+  //create a standard WebLogic domain.\n+  private void createDomain() {\n+\n+    // create WebLogic domain credential secret\n+    createSecretWithUsernamePassword(wlSecretName, domainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, domainNamespace);\n+\n+    t3ChannelPort = getNextFreePort(30000, 32767);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = assertDoesNotThrow(()\n+        -> File.createTempFile(\"domain\", \".properties\"),\n+        \"Failed to create domain properties file\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", Integer.toString(managedServerPort));\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"2\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    assertDoesNotThrow(()\n+        -> p.store(new FileOutputStream(domainPropertiesFile), \"domain properties file\"),\n+        \"Failed to write domain properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, domainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .configuration(new Configuration()\n+                .overrideDistributionStrategy(\"DYNAMIC\"))\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid) // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.debug.DebugSituationalConfig=true\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.debug.DebugSituationalConfigDumpXml=true\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    createDomainAndVerify(domain, domainNamespace);\n+\n+    // verify the admin server service created\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // verify admin server pod is ready\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPodNamePrefix + i, domainNamespace);\n+    }\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  //deploy application clusterview.war to domain\n+  private void deployApplication(String targets) {\n+    logger.info(\"Getting node port for T3 channel\");\n+    int t3channelNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"t3channel\"),\n+        \"Getting admin server t3channel node port failed\");\n+    assertNotEquals(-1, t3ChannelPort, \"admin server t3channelport is not valid\");\n+\n+    //deploy application\n+    logger.info(\"Deploying webapp {0} to domain\", clusterViewAppPath);\n+    deployUsingWlst(K8S_NODEPORT_HOST, Integer.toString(t3channelNodePort),\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, targets, clusterViewAppPath,\n+        domainNamespace);\n+  }\n+\n+  //restart pods by manipulating the serverStartPolicy to NEVER and IF_NEEDED\n+  private void restartDomain() {\n+    logger.info(\"Restarting domain {0}\", domainNamespace);\n+    shutdownDomain(domainUid, domainNamespace);\n+\n+    logger.info(\"Checking for admin server pod shutdown\");\n+    checkPodDoesNotExist(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Checking managed server pods were shutdown\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodDoesNotExist(managedServerPodNamePrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    startDomain(domainUid, domainNamespace);\n+    //make sure that the introspector runs on a cold start\n+    verifyIntrospectorRuns();\n+    logger.info(\"Checking for admin server pod readiness\");\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Checking for managed servers pod readiness\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodReady(managedServerPodNamePrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  //create a JDBC datasource targeted to cluster.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed1e738b6d6e8ede701e73a7f95bcf26e057a4f4"}, "originalPosition": 836}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY2MzQxMw==", "bodyText": "Sure, later.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r448663413", "createdAt": "2020-07-01T23:16:19Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "diffHunk": "@@ -0,0 +1,1148 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownDomain;\n+import static oracle.weblogic.kubernetes.actions.TestActions.startDomain;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.MySQLDBUtils.createMySQLDB;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static oracle.weblogic.kubernetes.utils.WLSTUtils.executeWLSTScript;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests related to overrideDistributionStrategy attribute.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the overrideDistributionStrategy applies the overrides accordingly to the value set\")\n+@IntegrationTest\n+public class ItConfigDistributionStrategy {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path clusterViewAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  static int mysqlDBPort1;\n+  static int mysqlDBPort2;\n+  static String dsUrl1;\n+  static String dsUrl2;\n+\n+  String dsName0 = \"JdbcTestDataSource-0\";\n+  String dsName1 = \"JdbcTestDataSource-1\";\n+  String dsSecret = domainUid.concat(\"-mysql-secret\");\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   * Creates 2 MySQL database instances.\n+   * Creates and starts WebLogic domain containing 2 instances in dynamic cluser.\n+   * Creates 2 JDBC data sources targeted to cluster.\n+   * Deploys clusterview application to cluster and admin targets.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for domain namspace\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+\n+    // build the clusterview application\n+    Path distDir = buildApplication(Paths.get(APP_DIR, \"clusterview\"),\n+        null, null, \"dist\", domainNamespace);\n+    clusterViewAppPath = Paths.get(distDir.toString(), \"clusterview.war\");\n+    assertTrue(clusterViewAppPath.toFile().exists(), \"Application archive is not available\");\n+\n+    //start two MySQL database instances\n+    mysqlDBPort1 = getNextFreePort(30000, 32767);\n+    createMySQLDB(\"mysqldb-1\", \"root\", \"root123\", mysqlDBPort1, domainNamespace, null);\n+    mysqlDBPort2 = getNextFreePort(31000, 32767);\n+    createMySQLDB(\"mysqldb-2\", \"root\", \"root456\", mysqlDBPort2, domainNamespace, null);\n+\n+    dsUrl1 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort1;\n+    dsUrl2 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort2;\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    } else {\n+      // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+\n+    //create and start WebLogic domain\n+    createDomain();\n+    //create a jdbc resource targeted to cluster\n+    createJdbcDataSource(dsName0, \"root\", \"root123\", mysqlDBPort1);\n+    createJdbcDataSource(dsName1, \"root\", \"root123\", mysqlDBPort1);\n+    //deploy application to view server configuration\n+    deployApplication(clusterName + \",\" + adminServerName);\n+\n+  }\n+\n+  /**\n+   * Verify the default config before starting any test.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    //check configuration values before override\n+    verifyConfigXMLOverride(false);\n+    verifyResourceJDBC0Override(false);\n+  }\n+\n+  /**\n+   * Delete the overrides and restart domain to get clean state.\n+   */\n+  @AfterEach\n+  public void afterEach() {\n+    deleteConfigMap(overridecm, domainNamespace);\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\"},\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+    restartDomain();\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden dynamically when\n+   * /spec/configuration/overrideDistributionStrategy: field is not set. By default it should be DYNAMIC.\n+   *\n+   * <p>Test sets the /spec/configuration/overridesConfigMap and with new configuration for config.xml and datasources.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are updated\n+   * as expected.\n+   */\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy set to DEFAULT\")\n+  public void testDefaultOverride() {\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap and introspectVersion\");\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"1\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC0Override(true);\n+  }\n+\n+  /**\n+   * Test server configuration and datasource configurations are dynamically overridden when\n+   * /spec/configuration/overrideDistributionStrategy is set to DYNAMIC.\n+   *\n+   * <p>Test sets the above field to DYNAMIC and overrides the /spec/configuration/overridesConfigMap\n+   * with new configuration.\n+   *\n+   * <p>Verifies after introspector runs and the server configuration and JDBC datasource configurations are\n+   * updated as expected.\n+   */\n+  @Disabled\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value DYNAMIC\")\n+  public void testDynamicOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: DYNAMIC\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"DYNAMIC\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?\n+    restartDomain(); // if above is a bug, remove this after the above bug is fixed\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap, secrets , cluster and introspectVersion\");\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"2\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC0Override(true);\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden on restart of pods when\n+   * /spec/configuration/overrideDistributionStrategy is set to ON_RESTART.\n+   *\n+   * <p>Test sets the above field to ON_RESTART and overrides the /spec/configuration/overridesConfigMap and\n+   * /spec/configuration/secrets with new configuration and new secrets.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are not\n+   * updated. Verifies the overrides are applied only after a domain restart.\n+   */\n+  @Disabled\n+  @Order(3)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value ON_RESTART\")\n+  public void testOnRestartOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: ON_RESTART\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"ON_RESTART\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?\n+    restartDomain(); // if above is a bug, remove this after the above bug is fixed\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    logger.info(\"Creating secrets for JDBC datasource overrides\");\n+    //create new secrets for jdbc datasource\n+    Map<String, String> secretMap = new HashMap<>();\n+    secretMap.put(\"dbusername\", \"root\");\n+    secretMap.put(\"dbpassword\", \"root456\");\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(dsSecret)\n+            .namespace(domainNamespace))\n+        .stringData(secretMap)), \"Creating secret for datasource failed.\");\n+    assertTrue(secretCreated, String.format(\"creating secret failed %s\", dsSecret));\n+\n+    //copy the template datasource file for override after replacing JDBC_URL with new datasource url\n+    Path srcDsOverrideFile = Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-1.xml\");\n+    Path dstDsOverrideFile = Paths.get(WORK_DIR, \"jdbc-JdbcTestDataSource-1.xml\");\n+    String tempString = assertDoesNotThrow(()\n+        -> Files.readString(srcDsOverrideFile).replaceAll(\"JDBC_URL\", dsUrl2));\n+    assertDoesNotThrow(()\n+        -> Files.write(dstDsOverrideFile, tempString.getBytes(StandardCharsets.UTF_8)));\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(dstDsOverrideFile);\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    //patch the domain resource with overridesConfigMap, secrets and introspectVersion\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\", \\\"value\\\": [\\\"\" + dsSecret + \"\\\"]  },\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"3\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    try {\n+      //wait for a minute to see if the overrides are not applied\n+      TimeUnit.MINUTES.sleep(1);\n+    } catch (InterruptedException ex) {\n+      //ignore\n+    }\n+\n+    //verify the overrides are not applied\n+    verifyConfigXMLOverride(false);\n+    verifyResourceJDBC0Override(false);\n+\n+    //restart domain for the distributionstrategy to take effect\n+    restartDomain();\n+\n+    //verify on restart the overrides are applied\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC1Override(true);\n+\n+    //cleanup secret\n+    deleteSecret(dsSecret, domainNamespace);\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+  }\n+\n+  /**\n+   * Test patching the domain with values for /spec/configuration/overrideDistributionStrategy field anything other than\n+   * DYNAMIC or ON_RESTART fails.\n+   *\n+   * <p>Test tries to set the above field to RESTART and asserts the patching fails.\n+   */\n+  @Disabled\n+  @Order(4)\n+  @Test\n+  @DisplayName(\"Test invalid overrideDistributionStrategy value RESTART\")\n+  public void testOverrideNegative() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: RESTART\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"RESTART\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertFalse(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Patch domain with invalid overrideDistributionStrategy succeeded.\");\n+\n+    //verify the overrides are not applied and original configuration is still effective\n+    verifyConfigXMLOverride(false);\n+  }\n+\n+  private Callable<Boolean> configUpdated() {\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(domainNamespace, adminServerPodName\n+            + \"-external\",\n+            \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    //verify server attribute MaxMessageSize\n+    String appURI = \"/clusterview/ConfigServlet?\"\n+        + \"attributeTest=true&\"\n+        + \"serverType=adminserver&\"\n+        + \"serverName=\" + adminServerName;\n+    String url = \"http://\" + K8S_NODEPORT_HOST + \":\" + serviceNodePort + appURI;\n+\n+    String maxMessageSize = \"78787878\";\n+    return (()\n+        -> {\n+      HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(url, true));\n+      assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+      return response.body().contains(\"MaxMessageSize=\".concat(maxMessageSize));\n+    });\n+  }\n+\n+  private void verifyConfigXMLOverride(boolean configUpdated) {\n+\n+    int port = getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+    String baseUri = \"http://\" + K8S_NODEPORT_HOST + \":\" + port + \"/clusterview/\";\n+\n+    //verify server attribute MaxMessageSize to be equal to 78787878\n+    String configUri = \"ConfigServlet?\"\n+        + \"attributeTest=true\"\n+        + \"&serverType=adminserver\"\n+        + \"&serverName=\" + adminServerName;\n+    HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(baseUri + configUri, true));\n+\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    if (configUpdated) {\n+      assertTrue(response.body().contains(\"MaxMessageSize=78787878\"), \"Didn't get MaxMessageSize=78787878\");\n+    } else {\n+      assertTrue(response.body().contains(\"MaxMessageSize=10000000\"), \"Didn't get MaxMessageSize=10000000\");\n+    }\n+\n+  }\n+\n+  //use the http client and access the clusterview application to get server configuration\n+  //and JDBC datasource configuration.\n+  private void verifyResourceJDBC0Override(boolean configUpdated) {\n+\n+    // get admin server node port and construct a base url for clusterview app\n+    int port = getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+    String baseUri = \"http://\" + K8S_NODEPORT_HOST + \":\" + port + \"/clusterview/ConfigServlet?\";\n+\n+    //verify datasource attributes of JdbcTestDataSource-0\n+    String appURI = \"resTest=true&resName=\" + dsName0;\n+    String dsOverrideTestUrl = baseUri + appURI;\n+    HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(dsOverrideTestUrl, true));\n+\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    if (configUpdated) {\n+      assertTrue(response.body().contains(\"getMaxCapacity:12\"), \"Did get getMaxCapacity:12\");\n+      assertTrue(response.body().contains(\"getInitialCapacity:2\"), \"Did get getInitialCapacity:2\");\n+    } else {\n+      assertTrue(response.body().contains(\"getMaxCapacity:15\"), \"Did get getMaxCapacity:15\");\n+      assertTrue(response.body().contains(\"getInitialCapacity:1\"), \"Did get getInitialCapacity:1\");\n+    }\n+\n+    //test connection pool in all managed servers of dynamic cluster\n+    for (int i = 1; i <= replicaCount; i++) {\n+      appURI = \"dsTest=true&dsName=\" + dsName0 + \"&\" + \"serverName=\" + managedServerNameBase + i;\n+      String dsConnectionPoolTestUrl = baseUri + appURI;\n+      response = assertDoesNotThrow(() -> OracleHttpClient.get(dsConnectionPoolTestUrl, true));\n+      assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+      assertTrue(response.body().contains(\"Connection successful\"), \"Didn't get Connection successful\");\n+    }\n+  }\n+\n+  //use the http client and access the clusterview application to get server configuration\n+  //and JDBC datasource configuration.\n+  private void verifyResourceJDBC1Override(boolean configUpdated) {\n+\n+    // get admin server node port and construct a base url for clusterview app\n+    int port = getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+    String baseUri = \"http://\" + K8S_NODEPORT_HOST + \":\" + port + \"/clusterview/ConfigServlet?\";\n+\n+    //verify datasource attributes of JdbcTestDataSource-0\n+    String appURI = \"resTest=true&resName=\" + dsName1;\n+    String dsOverrideTestUrl = baseUri + appURI;\n+    HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(dsOverrideTestUrl, true));\n+\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    if (configUpdated) {\n+      assertTrue(response.body().contains(\"getMaxCapacity:10\"), \"Did get getMaxCapacity:10\");\n+      assertTrue(response.body().contains(\"getInitialCapacity:4\"), \"Did get getInitialCapacity:4\");\n+      assertTrue(response.body().contains(\"Url:\" + dsUrl2), \"Didn't get Url:\" + dsUrl2);\n+    } else {\n+      assertTrue(response.body().contains(\"getMaxCapacity:15\"), \"Did get getMaxCapacity:15\");\n+      assertTrue(response.body().contains(\"getInitialCapacity:1\"), \"Did get getInitialCapacity:1\");\n+      assertTrue(response.body().contains(\"Url:\" + dsUrl1), \"Didn't get Url:\" + dsUrl1);\n+    }\n+\n+    //test connection pool in all managed servers of dynamic cluster\n+    for (int i = 1; i <= replicaCount; i++) {\n+      appURI = \"dsTest=true&dsName=\" + dsName1 + \"&\" + \"serverName=\" + managedServerNameBase + i;\n+      String dsConnectionPoolTestUrl = baseUri + appURI;\n+      response = assertDoesNotThrow(() -> OracleHttpClient.get(dsConnectionPoolTestUrl, true));\n+      assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+      assertTrue(response.body().contains(\"Connection successful\"), \"Didn't get Connection successful\");\n+    }\n+  }\n+\n+  //store pod creation timestamps for podstate check\n+  private void storePodCreationTimestamps() {\n+    // get the pod creation time stamps\n+    podTimestamps = new LinkedHashMap<>();\n+    // get the creation time of the admin server pod before patching\n+    DateTime adminPodCreationTime = getPodCreationTime(domainNamespace, adminServerPodName);\n+    podTimestamps.put(adminServerPodName, adminPodCreationTime);\n+    // get the creation time of the managed server pods before patching\n+    for (int i = 1; i <= replicaCount; i++) {\n+      podTimestamps.put(managedServerPodNamePrefix + i,\n+          getPodCreationTime(domainNamespace, managedServerPodNamePrefix + i));\n+    }\n+  }\n+\n+  //check if the pods are restarted by comparing the pod creationtimestamp.\n+  private void verifyPodsStateNotChanged() {\n+    logger.info(\"Verifying the WebLogic server pod states are not changed\");\n+    for (Map.Entry<String, DateTime> entry : podTimestamps.entrySet()) {\n+      String podName = (String) entry.getKey();\n+      DateTime creationTimestamp = (DateTime) entry.getValue();\n+      assertTrue(podStateNotChanged(podName, domainUid, domainNamespace,\n+          creationTimestamp), \"Pod is restarted\");\n+    }\n+  }\n+\n+  //verify the introspector pod is created and run\n+  private void verifyIntrospectorRuns() {\n+    //verify the introspector pod is created and runs\n+    logger.info(\"Verifying introspector pod is created, runs and deleted\");\n+    String introspectPodName = domainUid + \"-\" + \"introspect-domain-job\";\n+    checkPodExists(introspectPodName, domainUid, domainNamespace);\n+    checkPodDoesNotExist(introspectPodName, domainUid, domainNamespace);\n+  }\n+\n+  //create a standard WebLogic domain.\n+  private void createDomain() {\n+\n+    // create WebLogic domain credential secret\n+    createSecretWithUsernamePassword(wlSecretName, domainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, domainNamespace);\n+\n+    t3ChannelPort = getNextFreePort(30000, 32767);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = assertDoesNotThrow(()\n+        -> File.createTempFile(\"domain\", \".properties\"),\n+        \"Failed to create domain properties file\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", Integer.toString(managedServerPort));\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"2\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    assertDoesNotThrow(()\n+        -> p.store(new FileOutputStream(domainPropertiesFile), \"domain properties file\"),\n+        \"Failed to write domain properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, domainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .configuration(new Configuration()\n+                .overrideDistributionStrategy(\"DYNAMIC\"))\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid) // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.debug.DebugSituationalConfig=true\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.debug.DebugSituationalConfigDumpXml=true\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    createDomainAndVerify(domain, domainNamespace);\n+\n+    // verify the admin server service created\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // verify admin server pod is ready\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPodNamePrefix + i, domainNamespace);\n+    }\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  //deploy application clusterview.war to domain\n+  private void deployApplication(String targets) {\n+    logger.info(\"Getting node port for T3 channel\");\n+    int t3channelNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"t3channel\"),\n+        \"Getting admin server t3channel node port failed\");\n+    assertNotEquals(-1, t3ChannelPort, \"admin server t3channelport is not valid\");\n+\n+    //deploy application\n+    logger.info(\"Deploying webapp {0} to domain\", clusterViewAppPath);\n+    deployUsingWlst(K8S_NODEPORT_HOST, Integer.toString(t3channelNodePort),\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, targets, clusterViewAppPath,\n+        domainNamespace);\n+  }\n+\n+  //restart pods by manipulating the serverStartPolicy to NEVER and IF_NEEDED\n+  private void restartDomain() {\n+    logger.info(\"Restarting domain {0}\", domainNamespace);\n+    shutdownDomain(domainUid, domainNamespace);\n+\n+    logger.info(\"Checking for admin server pod shutdown\");\n+    checkPodDoesNotExist(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Checking managed server pods were shutdown\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodDoesNotExist(managedServerPodNamePrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    startDomain(domainUid, domainNamespace);\n+    //make sure that the introspector runs on a cold start\n+    verifyIntrospectorRuns();\n+    logger.info(\"Checking for admin server pod readiness\");\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Checking for managed servers pod readiness\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodReady(managedServerPodNamePrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  //create a JDBC datasource targeted to cluster.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY1Njg3NA=="}, "originalCommit": {"oid": "ed1e738b6d6e8ede701e73a7f95bcf26e057a4f4"}, "originalPosition": 836}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NjQxMjc2OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMjo1NTozOFrOGr33RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMzoxODowMlrOGr4RPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY1NzIyMA==", "bodyText": "Common Test Utility candidate", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r448657220", "createdAt": "2020-07-01T22:55:38Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "diffHunk": "@@ -0,0 +1,1148 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownDomain;\n+import static oracle.weblogic.kubernetes.actions.TestActions.startDomain;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.MySQLDBUtils.createMySQLDB;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static oracle.weblogic.kubernetes.utils.WLSTUtils.executeWLSTScript;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests related to overrideDistributionStrategy attribute.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the overrideDistributionStrategy applies the overrides accordingly to the value set\")\n+@IntegrationTest\n+public class ItConfigDistributionStrategy {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path clusterViewAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  static int mysqlDBPort1;\n+  static int mysqlDBPort2;\n+  static String dsUrl1;\n+  static String dsUrl2;\n+\n+  String dsName0 = \"JdbcTestDataSource-0\";\n+  String dsName1 = \"JdbcTestDataSource-1\";\n+  String dsSecret = domainUid.concat(\"-mysql-secret\");\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   * Creates 2 MySQL database instances.\n+   * Creates and starts WebLogic domain containing 2 instances in dynamic cluser.\n+   * Creates 2 JDBC data sources targeted to cluster.\n+   * Deploys clusterview application to cluster and admin targets.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for domain namspace\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+\n+    // build the clusterview application\n+    Path distDir = buildApplication(Paths.get(APP_DIR, \"clusterview\"),\n+        null, null, \"dist\", domainNamespace);\n+    clusterViewAppPath = Paths.get(distDir.toString(), \"clusterview.war\");\n+    assertTrue(clusterViewAppPath.toFile().exists(), \"Application archive is not available\");\n+\n+    //start two MySQL database instances\n+    mysqlDBPort1 = getNextFreePort(30000, 32767);\n+    createMySQLDB(\"mysqldb-1\", \"root\", \"root123\", mysqlDBPort1, domainNamespace, null);\n+    mysqlDBPort2 = getNextFreePort(31000, 32767);\n+    createMySQLDB(\"mysqldb-2\", \"root\", \"root456\", mysqlDBPort2, domainNamespace, null);\n+\n+    dsUrl1 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort1;\n+    dsUrl2 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort2;\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    } else {\n+      // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+\n+    //create and start WebLogic domain\n+    createDomain();\n+    //create a jdbc resource targeted to cluster\n+    createJdbcDataSource(dsName0, \"root\", \"root123\", mysqlDBPort1);\n+    createJdbcDataSource(dsName1, \"root\", \"root123\", mysqlDBPort1);\n+    //deploy application to view server configuration\n+    deployApplication(clusterName + \",\" + adminServerName);\n+\n+  }\n+\n+  /**\n+   * Verify the default config before starting any test.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    //check configuration values before override\n+    verifyConfigXMLOverride(false);\n+    verifyResourceJDBC0Override(false);\n+  }\n+\n+  /**\n+   * Delete the overrides and restart domain to get clean state.\n+   */\n+  @AfterEach\n+  public void afterEach() {\n+    deleteConfigMap(overridecm, domainNamespace);\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\"},\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+    restartDomain();\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden dynamically when\n+   * /spec/configuration/overrideDistributionStrategy: field is not set. By default it should be DYNAMIC.\n+   *\n+   * <p>Test sets the /spec/configuration/overridesConfigMap and with new configuration for config.xml and datasources.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are updated\n+   * as expected.\n+   */\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy set to DEFAULT\")\n+  public void testDefaultOverride() {\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap and introspectVersion\");\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"1\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC0Override(true);\n+  }\n+\n+  /**\n+   * Test server configuration and datasource configurations are dynamically overridden when\n+   * /spec/configuration/overrideDistributionStrategy is set to DYNAMIC.\n+   *\n+   * <p>Test sets the above field to DYNAMIC and overrides the /spec/configuration/overridesConfigMap\n+   * with new configuration.\n+   *\n+   * <p>Verifies after introspector runs and the server configuration and JDBC datasource configurations are\n+   * updated as expected.\n+   */\n+  @Disabled\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value DYNAMIC\")\n+  public void testDynamicOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: DYNAMIC\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"DYNAMIC\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?\n+    restartDomain(); // if above is a bug, remove this after the above bug is fixed\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap, secrets , cluster and introspectVersion\");\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"2\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC0Override(true);\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden on restart of pods when\n+   * /spec/configuration/overrideDistributionStrategy is set to ON_RESTART.\n+   *\n+   * <p>Test sets the above field to ON_RESTART and overrides the /spec/configuration/overridesConfigMap and\n+   * /spec/configuration/secrets with new configuration and new secrets.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are not\n+   * updated. Verifies the overrides are applied only after a domain restart.\n+   */\n+  @Disabled\n+  @Order(3)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value ON_RESTART\")\n+  public void testOnRestartOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: ON_RESTART\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"ON_RESTART\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?\n+    restartDomain(); // if above is a bug, remove this after the above bug is fixed\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    logger.info(\"Creating secrets for JDBC datasource overrides\");\n+    //create new secrets for jdbc datasource\n+    Map<String, String> secretMap = new HashMap<>();\n+    secretMap.put(\"dbusername\", \"root\");\n+    secretMap.put(\"dbpassword\", \"root456\");\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(dsSecret)\n+            .namespace(domainNamespace))\n+        .stringData(secretMap)), \"Creating secret for datasource failed.\");\n+    assertTrue(secretCreated, String.format(\"creating secret failed %s\", dsSecret));\n+\n+    //copy the template datasource file for override after replacing JDBC_URL with new datasource url\n+    Path srcDsOverrideFile = Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-1.xml\");\n+    Path dstDsOverrideFile = Paths.get(WORK_DIR, \"jdbc-JdbcTestDataSource-1.xml\");\n+    String tempString = assertDoesNotThrow(()\n+        -> Files.readString(srcDsOverrideFile).replaceAll(\"JDBC_URL\", dsUrl2));\n+    assertDoesNotThrow(()\n+        -> Files.write(dstDsOverrideFile, tempString.getBytes(StandardCharsets.UTF_8)));\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(dstDsOverrideFile);\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    //patch the domain resource with overridesConfigMap, secrets and introspectVersion\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\", \\\"value\\\": [\\\"\" + dsSecret + \"\\\"]  },\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"3\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    try {\n+      //wait for a minute to see if the overrides are not applied\n+      TimeUnit.MINUTES.sleep(1);\n+    } catch (InterruptedException ex) {\n+      //ignore\n+    }\n+\n+    //verify the overrides are not applied\n+    verifyConfigXMLOverride(false);\n+    verifyResourceJDBC0Override(false);\n+\n+    //restart domain for the distributionstrategy to take effect\n+    restartDomain();\n+\n+    //verify on restart the overrides are applied\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC1Override(true);\n+\n+    //cleanup secret\n+    deleteSecret(dsSecret, domainNamespace);\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+  }\n+\n+  /**\n+   * Test patching the domain with values for /spec/configuration/overrideDistributionStrategy field anything other than\n+   * DYNAMIC or ON_RESTART fails.\n+   *\n+   * <p>Test tries to set the above field to RESTART and asserts the patching fails.\n+   */\n+  @Disabled\n+  @Order(4)\n+  @Test\n+  @DisplayName(\"Test invalid overrideDistributionStrategy value RESTART\")\n+  public void testOverrideNegative() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: RESTART\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"RESTART\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertFalse(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Patch domain with invalid overrideDistributionStrategy succeeded.\");\n+\n+    //verify the overrides are not applied and original configuration is still effective\n+    verifyConfigXMLOverride(false);\n+  }\n+\n+  private Callable<Boolean> configUpdated() {\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(domainNamespace, adminServerPodName\n+            + \"-external\",\n+            \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    //verify server attribute MaxMessageSize\n+    String appURI = \"/clusterview/ConfigServlet?\"\n+        + \"attributeTest=true&\"\n+        + \"serverType=adminserver&\"\n+        + \"serverName=\" + adminServerName;\n+    String url = \"http://\" + K8S_NODEPORT_HOST + \":\" + serviceNodePort + appURI;\n+\n+    String maxMessageSize = \"78787878\";\n+    return (()\n+        -> {\n+      HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(url, true));\n+      assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+      return response.body().contains(\"MaxMessageSize=\".concat(maxMessageSize));\n+    });\n+  }\n+\n+  private void verifyConfigXMLOverride(boolean configUpdated) {\n+\n+    int port = getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+    String baseUri = \"http://\" + K8S_NODEPORT_HOST + \":\" + port + \"/clusterview/\";\n+\n+    //verify server attribute MaxMessageSize to be equal to 78787878\n+    String configUri = \"ConfigServlet?\"\n+        + \"attributeTest=true\"\n+        + \"&serverType=adminserver\"\n+        + \"&serverName=\" + adminServerName;\n+    HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(baseUri + configUri, true));\n+\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    if (configUpdated) {\n+      assertTrue(response.body().contains(\"MaxMessageSize=78787878\"), \"Didn't get MaxMessageSize=78787878\");\n+    } else {\n+      assertTrue(response.body().contains(\"MaxMessageSize=10000000\"), \"Didn't get MaxMessageSize=10000000\");\n+    }\n+\n+  }\n+\n+  //use the http client and access the clusterview application to get server configuration\n+  //and JDBC datasource configuration.\n+  private void verifyResourceJDBC0Override(boolean configUpdated) {\n+\n+    // get admin server node port and construct a base url for clusterview app\n+    int port = getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+    String baseUri = \"http://\" + K8S_NODEPORT_HOST + \":\" + port + \"/clusterview/ConfigServlet?\";\n+\n+    //verify datasource attributes of JdbcTestDataSource-0\n+    String appURI = \"resTest=true&resName=\" + dsName0;\n+    String dsOverrideTestUrl = baseUri + appURI;\n+    HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(dsOverrideTestUrl, true));\n+\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    if (configUpdated) {\n+      assertTrue(response.body().contains(\"getMaxCapacity:12\"), \"Did get getMaxCapacity:12\");\n+      assertTrue(response.body().contains(\"getInitialCapacity:2\"), \"Did get getInitialCapacity:2\");\n+    } else {\n+      assertTrue(response.body().contains(\"getMaxCapacity:15\"), \"Did get getMaxCapacity:15\");\n+      assertTrue(response.body().contains(\"getInitialCapacity:1\"), \"Did get getInitialCapacity:1\");\n+    }\n+\n+    //test connection pool in all managed servers of dynamic cluster\n+    for (int i = 1; i <= replicaCount; i++) {\n+      appURI = \"dsTest=true&dsName=\" + dsName0 + \"&\" + \"serverName=\" + managedServerNameBase + i;\n+      String dsConnectionPoolTestUrl = baseUri + appURI;\n+      response = assertDoesNotThrow(() -> OracleHttpClient.get(dsConnectionPoolTestUrl, true));\n+      assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+      assertTrue(response.body().contains(\"Connection successful\"), \"Didn't get Connection successful\");\n+    }\n+  }\n+\n+  //use the http client and access the clusterview application to get server configuration\n+  //and JDBC datasource configuration.\n+  private void verifyResourceJDBC1Override(boolean configUpdated) {\n+\n+    // get admin server node port and construct a base url for clusterview app\n+    int port = getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+    String baseUri = \"http://\" + K8S_NODEPORT_HOST + \":\" + port + \"/clusterview/ConfigServlet?\";\n+\n+    //verify datasource attributes of JdbcTestDataSource-0\n+    String appURI = \"resTest=true&resName=\" + dsName1;\n+    String dsOverrideTestUrl = baseUri + appURI;\n+    HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(dsOverrideTestUrl, true));\n+\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    if (configUpdated) {\n+      assertTrue(response.body().contains(\"getMaxCapacity:10\"), \"Did get getMaxCapacity:10\");\n+      assertTrue(response.body().contains(\"getInitialCapacity:4\"), \"Did get getInitialCapacity:4\");\n+      assertTrue(response.body().contains(\"Url:\" + dsUrl2), \"Didn't get Url:\" + dsUrl2);\n+    } else {\n+      assertTrue(response.body().contains(\"getMaxCapacity:15\"), \"Did get getMaxCapacity:15\");\n+      assertTrue(response.body().contains(\"getInitialCapacity:1\"), \"Did get getInitialCapacity:1\");\n+      assertTrue(response.body().contains(\"Url:\" + dsUrl1), \"Didn't get Url:\" + dsUrl1);\n+    }\n+\n+    //test connection pool in all managed servers of dynamic cluster\n+    for (int i = 1; i <= replicaCount; i++) {\n+      appURI = \"dsTest=true&dsName=\" + dsName1 + \"&\" + \"serverName=\" + managedServerNameBase + i;\n+      String dsConnectionPoolTestUrl = baseUri + appURI;\n+      response = assertDoesNotThrow(() -> OracleHttpClient.get(dsConnectionPoolTestUrl, true));\n+      assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+      assertTrue(response.body().contains(\"Connection successful\"), \"Didn't get Connection successful\");\n+    }\n+  }\n+\n+  //store pod creation timestamps for podstate check\n+  private void storePodCreationTimestamps() {\n+    // get the pod creation time stamps\n+    podTimestamps = new LinkedHashMap<>();\n+    // get the creation time of the admin server pod before patching\n+    DateTime adminPodCreationTime = getPodCreationTime(domainNamespace, adminServerPodName);\n+    podTimestamps.put(adminServerPodName, adminPodCreationTime);\n+    // get the creation time of the managed server pods before patching\n+    for (int i = 1; i <= replicaCount; i++) {\n+      podTimestamps.put(managedServerPodNamePrefix + i,\n+          getPodCreationTime(domainNamespace, managedServerPodNamePrefix + i));\n+    }\n+  }\n+\n+  //check if the pods are restarted by comparing the pod creationtimestamp.\n+  private void verifyPodsStateNotChanged() {\n+    logger.info(\"Verifying the WebLogic server pod states are not changed\");\n+    for (Map.Entry<String, DateTime> entry : podTimestamps.entrySet()) {\n+      String podName = (String) entry.getKey();\n+      DateTime creationTimestamp = (DateTime) entry.getValue();\n+      assertTrue(podStateNotChanged(podName, domainUid, domainNamespace,\n+          creationTimestamp), \"Pod is restarted\");\n+    }\n+  }\n+\n+  //verify the introspector pod is created and run\n+  private void verifyIntrospectorRuns() {\n+    //verify the introspector pod is created and runs\n+    logger.info(\"Verifying introspector pod is created, runs and deleted\");\n+    String introspectPodName = domainUid + \"-\" + \"introspect-domain-job\";\n+    checkPodExists(introspectPodName, domainUid, domainNamespace);\n+    checkPodDoesNotExist(introspectPodName, domainUid, domainNamespace);\n+  }\n+\n+  //create a standard WebLogic domain.\n+  private void createDomain() {\n+\n+    // create WebLogic domain credential secret\n+    createSecretWithUsernamePassword(wlSecretName, domainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, domainNamespace);\n+\n+    t3ChannelPort = getNextFreePort(30000, 32767);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = assertDoesNotThrow(()\n+        -> File.createTempFile(\"domain\", \".properties\"),\n+        \"Failed to create domain properties file\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", Integer.toString(managedServerPort));\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"2\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    assertDoesNotThrow(()\n+        -> p.store(new FileOutputStream(domainPropertiesFile), \"domain properties file\"),\n+        \"Failed to write domain properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, domainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .configuration(new Configuration()\n+                .overrideDistributionStrategy(\"DYNAMIC\"))\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid) // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.debug.DebugSituationalConfig=true\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.debug.DebugSituationalConfigDumpXml=true\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    createDomainAndVerify(domain, domainNamespace);\n+\n+    // verify the admin server service created\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // verify admin server pod is ready\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPodNamePrefix + i, domainNamespace);\n+    }\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  //deploy application clusterview.war to domain\n+  private void deployApplication(String targets) {\n+    logger.info(\"Getting node port for T3 channel\");\n+    int t3channelNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"t3channel\"),\n+        \"Getting admin server t3channel node port failed\");\n+    assertNotEquals(-1, t3ChannelPort, \"admin server t3channelport is not valid\");\n+\n+    //deploy application\n+    logger.info(\"Deploying webapp {0} to domain\", clusterViewAppPath);\n+    deployUsingWlst(K8S_NODEPORT_HOST, Integer.toString(t3channelNodePort),\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, targets, clusterViewAppPath,\n+        domainNamespace);\n+  }\n+\n+  //restart pods by manipulating the serverStartPolicy to NEVER and IF_NEEDED\n+  private void restartDomain() {\n+    logger.info(\"Restarting domain {0}\", domainNamespace);\n+    shutdownDomain(domainUid, domainNamespace);\n+\n+    logger.info(\"Checking for admin server pod shutdown\");\n+    checkPodDoesNotExist(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Checking managed server pods were shutdown\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodDoesNotExist(managedServerPodNamePrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    startDomain(domainUid, domainNamespace);\n+    //make sure that the introspector runs on a cold start\n+    verifyIntrospectorRuns();\n+    logger.info(\"Checking for admin server pod readiness\");\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Checking for managed servers pod readiness\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodReady(managedServerPodNamePrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  //create a JDBC datasource targeted to cluster.\n+  private void createJdbcDataSource(String dsName, String user, String password, int mySQLNodePort) {\n+\n+    try {\n+      String jdbcDsUrl = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mySQLNodePort;\n+\n+      // create a temporary WebLogic domain property file\n+      File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+      Properties p = new Properties();\n+      p.setProperty(\"admin_host\", K8S_NODEPORT_HOST);\n+      p.setProperty(\"admin_port\", Integer.toString(t3ChannelPort));\n+      p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+      p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+      p.setProperty(\"dsName\", dsName);\n+      p.setProperty(\"dsUrl\", jdbcDsUrl);\n+      p.setProperty(\"dsDriver\", \"com.mysql.cj.jdbc.Driver\");\n+      p.setProperty(\"dsUser\", user);\n+      p.setProperty(\"dsPassword\", password);\n+      p.setProperty(\"dsTarget\", clusterName);\n+      p.store(new FileOutputStream(domainPropertiesFile), \"domain properties file\");\n+\n+      // WLST script for creating jdbc datasource\n+      Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"create-jdbc-resource.py\");\n+      executeWLSTScript(wlstScript, domainPropertiesFile.toPath(), domainNamespace);\n+    } catch (IOException ex) {\n+      logger.severe(ex.getMessage());\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain on a persistent volume by doing the following. Create a configmap containing WLST script\n+   * and property file. Create a Kubernetes job to create domain on persistent volume.\n+   *\n+   * @param wlstScriptFile python script to create domain\n+   * @param domainPropertiesFile properties file containing domain configuration\n+   * @param pvName name of the persistent volume to create domain in\n+   * @param pvcName name of the persistent volume claim\n+   * @param namespace name of the domain namespace in which the job is created\n+   */\n+  private void createDomainOnPVUsingWlst(Path wlstScriptFile, Path domainPropertiesFile,\n+      String pvName, String pvcName, String namespace) {\n+    logger.info(\"Preparing to run create domain job using WLST\");\n+\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(wlstScriptFile);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Creating a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles, namespace),\n+        \"Create configmap for domain creation failed\");\n+\n+    // create a V1Container with specific scripts and properties for creating domain\n+    V1Container jobCreationContainer = new V1Container()\n+        .addCommandItem(\"/bin/sh\")\n+        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+        .addArgsItem(\"/u01/weblogic/\" + wlstScriptFile.getFileName()) //wlst.sh\n+        // script\n+        .addArgsItem(\"-skipWLSModuleScanning\")\n+        .addArgsItem(\"-loadProperties\")\n+        .addArgsItem(\"/u01/weblogic/\" + domainPropertiesFile.getFileName());\n+    //domain property file\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    createDomainJob(pvName, pvcName, domainScriptConfigMapName, namespace, jobCreationContainer);\n+\n+  }\n+\n+  /**\n+   * Create configmap containing domain creation scripts.\n+   *\n+   * @param configMapName name of the configmap to create\n+   * @param files files to add in configmap\n+   * @param namespace name of the namespace in which to create configmap\n+   * @throws IOException when reading the domain script files fail\n+   * @throws ApiException if create configmap fails\n+   */\n+  private void createConfigMapForDomainCreation(String configMapName, List<Path> files, String namespace)\n+      throws ApiException, IOException {\n+    logger.info(\"Creating configmap {0}\", configMapName);\n+\n+    Path domainScriptsDir = Files.createDirectories(\n+        Paths.get(TestConstants.LOGS_DIR, this.getClass().getSimpleName(), namespace));\n+\n+    // add domain creation scripts and properties files to the configmap\n+    Map<String, String> data = new HashMap<>();\n+    for (Path file : files) {\n+      logger.info(\"Adding file {0} in configmap\", file);\n+      data.put(file.getFileName().toString(), Files.readString(file));\n+      logger.info(\"Making a copy of file {0} to {1} for diagnostic purposes\", file,\n+          domainScriptsDir.resolve(file.getFileName()));\n+      Files.copy(file, domainScriptsDir.resolve(file.getFileName()));\n+    }\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .name(configMapName)\n+        .namespace(namespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Failed to create configmap %s with files %s\", configMapName, files));\n+    assertTrue(cmCreated, String.format(\"Failed while creating ConfigMap %s\", configMapName));\n+  }\n+\n+  /**\n+   * Create a job to create a domain in persistent volume.\n+   *\n+   * @param pvName name of the persistent volume to create domain in\n+   * @param pvcName name of the persistent volume claim\n+   * @param domainScriptCM configmap holding domain creation script files\n+   * @param namespace name of the domain namespace in which the job is created\n+   * @param jobContainer V1Container with job commands to create domain\n+   */\n+  private void createDomainJob(String pvName,\n+      String pvcName, String domainScriptCM, String namespace, V1Container jobContainer) {\n+    logger.info(\"Running Kubernetes job to create domain\");\n+\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job-\" + pvName) // name of the create domain job\n+                .namespace(namespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\") //\n+                        // change the ownership\n+                        // of the pv to opc:opc\n+                        .image(image)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R \"\n+                            + \"1000\"\n+                            + \":1000 \"\n+                            + \"/shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\n+                                    \"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(jobContainer // container\n+                        // containing WLST or WDT\n+                        // details\n+                        .name(\"create-weblogic-domain\"\n+                            + \"-onpv-container\")\n+                        .image(image)\n+                        .imagePullPolicy(\"Always\")\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) //\n+                                // location to write\n+                                // domain\n+                                .mountPath(\"/shared\"))))) // mounted under /shared inside pod\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptCM)))) //config map containing domain scripts\n+                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))\n+                        : null))));\n+    String jobName = assertDoesNotThrow(()\n+        -> createNamespacedJob(jobBody), \"Failed to create Job\");\n+\n+    logger.info(\"Checking if the domain creation job {0} completed in namespace {1}\",\n+        jobName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for job {0} to be completed in namespace {1} \"\n+                + \"(elapsed time {2} ms, remaining time {3} ms)\",\n+                jobName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(jobCompleted(jobName, null, namespace));\n+\n+    // check job status and fail test if the job failed to create domain\n+    V1Job job = assertDoesNotThrow(() -> getJob(jobName, namespace),\n+        \"Getting the job failed\");\n+    if (job != null) {\n+      V1JobCondition jobCondition = job.getStatus().getConditions().stream().filter(\n+          v1JobCondition -> \"Failed\".equalsIgnoreCase(v1JobCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+      if (jobCondition != null) {\n+        logger.severe(\"Job {0} failed to create domain\", jobName);\n+        List<V1Pod> pods = assertDoesNotThrow(()\n+            -> listPods(namespace, \"job-name=\" + jobName).getItems(),\n+            \"Listing pods failed\");\n+        if (!pods.isEmpty()) {\n+          String podLog = assertDoesNotThrow(() -> getPodLog(pods.get(0).getMetadata().getName(), namespace),\n+              \"Failed to get pod log\");\n+          logger.severe(podLog);\n+          fail(\"Domain create job failed\");\n+        }\n+      }\n+    }\n+\n+  }\n+\n+  /**\n+   * Create a persistent volume.\n+   *\n+   * @param pvName name of the persistent volume to create\n+   * @param domainUid domain UID\n+   * @throws IOException when creating pv path fails\n+   */\n+  private void createPV(String pvName, String domainUid) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed1e738b6d6e8ede701e73a7f95bcf26e057a4f4"}, "originalPosition": 1063}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY2Mzg3MA==", "bodyText": "Like Bhavani's comments I need to refactor some more classes to use methods from CommonTestUtils for the operations. Will do it in separate PR.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1768#discussion_r448663870", "createdAt": "2020-07-01T23:18:02Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItConfigDistributionStrategy.java", "diffHunk": "@@ -0,0 +1,1148 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownDomain;\n+import static oracle.weblogic.kubernetes.actions.TestActions.startDomain;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.MySQLDBUtils.createMySQLDB;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static oracle.weblogic.kubernetes.utils.WLSTUtils.executeWLSTScript;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests related to overrideDistributionStrategy attribute.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the overrideDistributionStrategy applies the overrides accordingly to the value set\")\n+@IntegrationTest\n+public class ItConfigDistributionStrategy {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path clusterViewAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  static int mysqlDBPort1;\n+  static int mysqlDBPort2;\n+  static String dsUrl1;\n+  static String dsUrl2;\n+\n+  String dsName0 = \"JdbcTestDataSource-0\";\n+  String dsName1 = \"JdbcTestDataSource-1\";\n+  String dsSecret = domainUid.concat(\"-mysql-secret\");\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   * Creates 2 MySQL database instances.\n+   * Creates and starts WebLogic domain containing 2 instances in dynamic cluser.\n+   * Creates 2 JDBC data sources targeted to cluster.\n+   * Deploys clusterview application to cluster and admin targets.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for domain namspace\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+\n+    // build the clusterview application\n+    Path distDir = buildApplication(Paths.get(APP_DIR, \"clusterview\"),\n+        null, null, \"dist\", domainNamespace);\n+    clusterViewAppPath = Paths.get(distDir.toString(), \"clusterview.war\");\n+    assertTrue(clusterViewAppPath.toFile().exists(), \"Application archive is not available\");\n+\n+    //start two MySQL database instances\n+    mysqlDBPort1 = getNextFreePort(30000, 32767);\n+    createMySQLDB(\"mysqldb-1\", \"root\", \"root123\", mysqlDBPort1, domainNamespace, null);\n+    mysqlDBPort2 = getNextFreePort(31000, 32767);\n+    createMySQLDB(\"mysqldb-2\", \"root\", \"root456\", mysqlDBPort2, domainNamespace, null);\n+\n+    dsUrl1 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort1;\n+    dsUrl2 = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mysqlDBPort2;\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    } else {\n+      // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+\n+    //create and start WebLogic domain\n+    createDomain();\n+    //create a jdbc resource targeted to cluster\n+    createJdbcDataSource(dsName0, \"root\", \"root123\", mysqlDBPort1);\n+    createJdbcDataSource(dsName1, \"root\", \"root123\", mysqlDBPort1);\n+    //deploy application to view server configuration\n+    deployApplication(clusterName + \",\" + adminServerName);\n+\n+  }\n+\n+  /**\n+   * Verify the default config before starting any test.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    //check configuration values before override\n+    verifyConfigXMLOverride(false);\n+    verifyResourceJDBC0Override(false);\n+  }\n+\n+  /**\n+   * Delete the overrides and restart domain to get clean state.\n+   */\n+  @AfterEach\n+  public void afterEach() {\n+    deleteConfigMap(overridecm, domainNamespace);\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\"},\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+    restartDomain();\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden dynamically when\n+   * /spec/configuration/overrideDistributionStrategy: field is not set. By default it should be DYNAMIC.\n+   *\n+   * <p>Test sets the /spec/configuration/overridesConfigMap and with new configuration for config.xml and datasources.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are updated\n+   * as expected.\n+   */\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy set to DEFAULT\")\n+  public void testDefaultOverride() {\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap and introspectVersion\");\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"1\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC0Override(true);\n+  }\n+\n+  /**\n+   * Test server configuration and datasource configurations are dynamically overridden when\n+   * /spec/configuration/overrideDistributionStrategy is set to DYNAMIC.\n+   *\n+   * <p>Test sets the above field to DYNAMIC and overrides the /spec/configuration/overridesConfigMap\n+   * with new configuration.\n+   *\n+   * <p>Verifies after introspector runs and the server configuration and JDBC datasource configurations are\n+   * updated as expected.\n+   */\n+  @Disabled\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value DYNAMIC\")\n+  public void testDynamicOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: DYNAMIC\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"DYNAMIC\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?\n+    restartDomain(); // if above is a bug, remove this after the above bug is fixed\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap, secrets , cluster and introspectVersion\");\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"2\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC0Override(true);\n+  }\n+\n+  /**\n+   * Test server configuration and JDBC datasource configurations are overridden on restart of pods when\n+   * /spec/configuration/overrideDistributionStrategy is set to ON_RESTART.\n+   *\n+   * <p>Test sets the above field to ON_RESTART and overrides the /spec/configuration/overridesConfigMap and\n+   * /spec/configuration/secrets with new configuration and new secrets.\n+   *\n+   * <p>Verifies after introspector runs the server configuration and JDBC datasource configurations are not\n+   * updated. Verifies the overrides are applied only after a domain restart.\n+   */\n+  @Disabled\n+  @Order(3)\n+  @Test\n+  @DisplayName(\"Test overrideDistributionStrategy value ON_RESTART\")\n+  public void testOnRestartOverride() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: ON_RESTART\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"ON_RESTART\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //does changing overrideDistributionStrategy needs restart of server pods?\n+    restartDomain(); // if above is a bug, remove this after the above bug is fixed\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    logger.info(\"Creating secrets for JDBC datasource overrides\");\n+    //create new secrets for jdbc datasource\n+    Map<String, String> secretMap = new HashMap<>();\n+    secretMap.put(\"dbusername\", \"root\");\n+    secretMap.put(\"dbpassword\", \"root456\");\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(dsSecret)\n+            .namespace(domainNamespace))\n+        .stringData(secretMap)), \"Creating secret for datasource failed.\");\n+    assertTrue(secretCreated, String.format(\"creating secret failed %s\", dsSecret));\n+\n+    //copy the template datasource file for override after replacing JDBC_URL with new datasource url\n+    Path srcDsOverrideFile = Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/jdbc-JdbcTestDataSource-1.xml\");\n+    Path dstDsOverrideFile = Paths.get(WORK_DIR, \"jdbc-JdbcTestDataSource-1.xml\");\n+    String tempString = assertDoesNotThrow(()\n+        -> Files.readString(srcDsOverrideFile).replaceAll(\"JDBC_URL\", dsUrl2));\n+    assertDoesNotThrow(()\n+        -> Files.write(dstDsOverrideFile, tempString.getBytes(StandardCharsets.UTF_8)));\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(dstDsOverrideFile);\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/config.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset1/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    //patch the domain resource with overridesConfigMap, secrets and introspectVersion\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\", \\\"value\\\": [\\\"\" + dsSecret + \"\\\"]  },\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"3\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    try {\n+      //wait for a minute to see if the overrides are not applied\n+      TimeUnit.MINUTES.sleep(1);\n+    } catch (InterruptedException ex) {\n+      //ignore\n+    }\n+\n+    //verify the overrides are not applied\n+    verifyConfigXMLOverride(false);\n+    verifyResourceJDBC0Override(false);\n+\n+    //restart domain for the distributionstrategy to take effect\n+    restartDomain();\n+\n+    //verify on restart the overrides are applied\n+    verifyConfigXMLOverride(true);\n+    verifyResourceJDBC1Override(true);\n+\n+    //cleanup secret\n+    deleteSecret(dsSecret, domainNamespace);\n+    patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/spec/configuration/secrets\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    patch = new V1Patch(patchStr);\n+    patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+  }\n+\n+  /**\n+   * Test patching the domain with values for /spec/configuration/overrideDistributionStrategy field anything other than\n+   * DYNAMIC or ON_RESTART fails.\n+   *\n+   * <p>Test tries to set the above field to RESTART and asserts the patching fails.\n+   */\n+  @Disabled\n+  @Order(4)\n+  @Test\n+  @DisplayName(\"Test invalid overrideDistributionStrategy value RESTART\")\n+  public void testOverrideNegative() {\n+\n+    //patching the domain with /spec/configuration/overrideDistributionStrategy: RESTART\n+    String patchStr = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overrideDistributionStrategy\\\", \"\n+        + \"\\\"value\\\": \\\"RESTART\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertFalse(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Patch domain with invalid overrideDistributionStrategy succeeded.\");\n+\n+    //verify the overrides are not applied and original configuration is still effective\n+    verifyConfigXMLOverride(false);\n+  }\n+\n+  private Callable<Boolean> configUpdated() {\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(domainNamespace, adminServerPodName\n+            + \"-external\",\n+            \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    //verify server attribute MaxMessageSize\n+    String appURI = \"/clusterview/ConfigServlet?\"\n+        + \"attributeTest=true&\"\n+        + \"serverType=adminserver&\"\n+        + \"serverName=\" + adminServerName;\n+    String url = \"http://\" + K8S_NODEPORT_HOST + \":\" + serviceNodePort + appURI;\n+\n+    String maxMessageSize = \"78787878\";\n+    return (()\n+        -> {\n+      HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(url, true));\n+      assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+      return response.body().contains(\"MaxMessageSize=\".concat(maxMessageSize));\n+    });\n+  }\n+\n+  private void verifyConfigXMLOverride(boolean configUpdated) {\n+\n+    int port = getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+    String baseUri = \"http://\" + K8S_NODEPORT_HOST + \":\" + port + \"/clusterview/\";\n+\n+    //verify server attribute MaxMessageSize to be equal to 78787878\n+    String configUri = \"ConfigServlet?\"\n+        + \"attributeTest=true\"\n+        + \"&serverType=adminserver\"\n+        + \"&serverName=\" + adminServerName;\n+    HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(baseUri + configUri, true));\n+\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    if (configUpdated) {\n+      assertTrue(response.body().contains(\"MaxMessageSize=78787878\"), \"Didn't get MaxMessageSize=78787878\");\n+    } else {\n+      assertTrue(response.body().contains(\"MaxMessageSize=10000000\"), \"Didn't get MaxMessageSize=10000000\");\n+    }\n+\n+  }\n+\n+  //use the http client and access the clusterview application to get server configuration\n+  //and JDBC datasource configuration.\n+  private void verifyResourceJDBC0Override(boolean configUpdated) {\n+\n+    // get admin server node port and construct a base url for clusterview app\n+    int port = getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+    String baseUri = \"http://\" + K8S_NODEPORT_HOST + \":\" + port + \"/clusterview/ConfigServlet?\";\n+\n+    //verify datasource attributes of JdbcTestDataSource-0\n+    String appURI = \"resTest=true&resName=\" + dsName0;\n+    String dsOverrideTestUrl = baseUri + appURI;\n+    HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(dsOverrideTestUrl, true));\n+\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    if (configUpdated) {\n+      assertTrue(response.body().contains(\"getMaxCapacity:12\"), \"Did get getMaxCapacity:12\");\n+      assertTrue(response.body().contains(\"getInitialCapacity:2\"), \"Did get getInitialCapacity:2\");\n+    } else {\n+      assertTrue(response.body().contains(\"getMaxCapacity:15\"), \"Did get getMaxCapacity:15\");\n+      assertTrue(response.body().contains(\"getInitialCapacity:1\"), \"Did get getInitialCapacity:1\");\n+    }\n+\n+    //test connection pool in all managed servers of dynamic cluster\n+    for (int i = 1; i <= replicaCount; i++) {\n+      appURI = \"dsTest=true&dsName=\" + dsName0 + \"&\" + \"serverName=\" + managedServerNameBase + i;\n+      String dsConnectionPoolTestUrl = baseUri + appURI;\n+      response = assertDoesNotThrow(() -> OracleHttpClient.get(dsConnectionPoolTestUrl, true));\n+      assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+      assertTrue(response.body().contains(\"Connection successful\"), \"Didn't get Connection successful\");\n+    }\n+  }\n+\n+  //use the http client and access the clusterview application to get server configuration\n+  //and JDBC datasource configuration.\n+  private void verifyResourceJDBC1Override(boolean configUpdated) {\n+\n+    // get admin server node port and construct a base url for clusterview app\n+    int port = getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+    String baseUri = \"http://\" + K8S_NODEPORT_HOST + \":\" + port + \"/clusterview/ConfigServlet?\";\n+\n+    //verify datasource attributes of JdbcTestDataSource-0\n+    String appURI = \"resTest=true&resName=\" + dsName1;\n+    String dsOverrideTestUrl = baseUri + appURI;\n+    HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(dsOverrideTestUrl, true));\n+\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    if (configUpdated) {\n+      assertTrue(response.body().contains(\"getMaxCapacity:10\"), \"Did get getMaxCapacity:10\");\n+      assertTrue(response.body().contains(\"getInitialCapacity:4\"), \"Did get getInitialCapacity:4\");\n+      assertTrue(response.body().contains(\"Url:\" + dsUrl2), \"Didn't get Url:\" + dsUrl2);\n+    } else {\n+      assertTrue(response.body().contains(\"getMaxCapacity:15\"), \"Did get getMaxCapacity:15\");\n+      assertTrue(response.body().contains(\"getInitialCapacity:1\"), \"Did get getInitialCapacity:1\");\n+      assertTrue(response.body().contains(\"Url:\" + dsUrl1), \"Didn't get Url:\" + dsUrl1);\n+    }\n+\n+    //test connection pool in all managed servers of dynamic cluster\n+    for (int i = 1; i <= replicaCount; i++) {\n+      appURI = \"dsTest=true&dsName=\" + dsName1 + \"&\" + \"serverName=\" + managedServerNameBase + i;\n+      String dsConnectionPoolTestUrl = baseUri + appURI;\n+      response = assertDoesNotThrow(() -> OracleHttpClient.get(dsConnectionPoolTestUrl, true));\n+      assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+      assertTrue(response.body().contains(\"Connection successful\"), \"Didn't get Connection successful\");\n+    }\n+  }\n+\n+  //store pod creation timestamps for podstate check\n+  private void storePodCreationTimestamps() {\n+    // get the pod creation time stamps\n+    podTimestamps = new LinkedHashMap<>();\n+    // get the creation time of the admin server pod before patching\n+    DateTime adminPodCreationTime = getPodCreationTime(domainNamespace, adminServerPodName);\n+    podTimestamps.put(adminServerPodName, adminPodCreationTime);\n+    // get the creation time of the managed server pods before patching\n+    for (int i = 1; i <= replicaCount; i++) {\n+      podTimestamps.put(managedServerPodNamePrefix + i,\n+          getPodCreationTime(domainNamespace, managedServerPodNamePrefix + i));\n+    }\n+  }\n+\n+  //check if the pods are restarted by comparing the pod creationtimestamp.\n+  private void verifyPodsStateNotChanged() {\n+    logger.info(\"Verifying the WebLogic server pod states are not changed\");\n+    for (Map.Entry<String, DateTime> entry : podTimestamps.entrySet()) {\n+      String podName = (String) entry.getKey();\n+      DateTime creationTimestamp = (DateTime) entry.getValue();\n+      assertTrue(podStateNotChanged(podName, domainUid, domainNamespace,\n+          creationTimestamp), \"Pod is restarted\");\n+    }\n+  }\n+\n+  //verify the introspector pod is created and run\n+  private void verifyIntrospectorRuns() {\n+    //verify the introspector pod is created and runs\n+    logger.info(\"Verifying introspector pod is created, runs and deleted\");\n+    String introspectPodName = domainUid + \"-\" + \"introspect-domain-job\";\n+    checkPodExists(introspectPodName, domainUid, domainNamespace);\n+    checkPodDoesNotExist(introspectPodName, domainUid, domainNamespace);\n+  }\n+\n+  //create a standard WebLogic domain.\n+  private void createDomain() {\n+\n+    // create WebLogic domain credential secret\n+    createSecretWithUsernamePassword(wlSecretName, domainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, domainNamespace);\n+\n+    t3ChannelPort = getNextFreePort(30000, 32767);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = assertDoesNotThrow(()\n+        -> File.createTempFile(\"domain\", \".properties\"),\n+        \"Failed to create domain properties file\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", Integer.toString(managedServerPort));\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"2\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    assertDoesNotThrow(()\n+        -> p.store(new FileOutputStream(domainPropertiesFile), \"domain properties file\"),\n+        \"Failed to write domain properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, domainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .configuration(new Configuration()\n+                .overrideDistributionStrategy(\"DYNAMIC\"))\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid) // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.debug.DebugSituationalConfig=true\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.debug.DebugSituationalConfigDumpXml=true\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    createDomainAndVerify(domain, domainNamespace);\n+\n+    // verify the admin server service created\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // verify admin server pod is ready\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPodNamePrefix + i, domainNamespace);\n+    }\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  //deploy application clusterview.war to domain\n+  private void deployApplication(String targets) {\n+    logger.info(\"Getting node port for T3 channel\");\n+    int t3channelNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"t3channel\"),\n+        \"Getting admin server t3channel node port failed\");\n+    assertNotEquals(-1, t3ChannelPort, \"admin server t3channelport is not valid\");\n+\n+    //deploy application\n+    logger.info(\"Deploying webapp {0} to domain\", clusterViewAppPath);\n+    deployUsingWlst(K8S_NODEPORT_HOST, Integer.toString(t3channelNodePort),\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, targets, clusterViewAppPath,\n+        domainNamespace);\n+  }\n+\n+  //restart pods by manipulating the serverStartPolicy to NEVER and IF_NEEDED\n+  private void restartDomain() {\n+    logger.info(\"Restarting domain {0}\", domainNamespace);\n+    shutdownDomain(domainUid, domainNamespace);\n+\n+    logger.info(\"Checking for admin server pod shutdown\");\n+    checkPodDoesNotExist(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Checking managed server pods were shutdown\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodDoesNotExist(managedServerPodNamePrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    startDomain(domainUid, domainNamespace);\n+    //make sure that the introspector runs on a cold start\n+    verifyIntrospectorRuns();\n+    logger.info(\"Checking for admin server pod readiness\");\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Checking for managed servers pod readiness\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodReady(managedServerPodNamePrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  //create a JDBC datasource targeted to cluster.\n+  private void createJdbcDataSource(String dsName, String user, String password, int mySQLNodePort) {\n+\n+    try {\n+      String jdbcDsUrl = \"jdbc:mysql://\" + K8S_NODEPORT_HOST + \":\" + mySQLNodePort;\n+\n+      // create a temporary WebLogic domain property file\n+      File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+      Properties p = new Properties();\n+      p.setProperty(\"admin_host\", K8S_NODEPORT_HOST);\n+      p.setProperty(\"admin_port\", Integer.toString(t3ChannelPort));\n+      p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+      p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+      p.setProperty(\"dsName\", dsName);\n+      p.setProperty(\"dsUrl\", jdbcDsUrl);\n+      p.setProperty(\"dsDriver\", \"com.mysql.cj.jdbc.Driver\");\n+      p.setProperty(\"dsUser\", user);\n+      p.setProperty(\"dsPassword\", password);\n+      p.setProperty(\"dsTarget\", clusterName);\n+      p.store(new FileOutputStream(domainPropertiesFile), \"domain properties file\");\n+\n+      // WLST script for creating jdbc datasource\n+      Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"create-jdbc-resource.py\");\n+      executeWLSTScript(wlstScript, domainPropertiesFile.toPath(), domainNamespace);\n+    } catch (IOException ex) {\n+      logger.severe(ex.getMessage());\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain on a persistent volume by doing the following. Create a configmap containing WLST script\n+   * and property file. Create a Kubernetes job to create domain on persistent volume.\n+   *\n+   * @param wlstScriptFile python script to create domain\n+   * @param domainPropertiesFile properties file containing domain configuration\n+   * @param pvName name of the persistent volume to create domain in\n+   * @param pvcName name of the persistent volume claim\n+   * @param namespace name of the domain namespace in which the job is created\n+   */\n+  private void createDomainOnPVUsingWlst(Path wlstScriptFile, Path domainPropertiesFile,\n+      String pvName, String pvcName, String namespace) {\n+    logger.info(\"Preparing to run create domain job using WLST\");\n+\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(wlstScriptFile);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Creating a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles, namespace),\n+        \"Create configmap for domain creation failed\");\n+\n+    // create a V1Container with specific scripts and properties for creating domain\n+    V1Container jobCreationContainer = new V1Container()\n+        .addCommandItem(\"/bin/sh\")\n+        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+        .addArgsItem(\"/u01/weblogic/\" + wlstScriptFile.getFileName()) //wlst.sh\n+        // script\n+        .addArgsItem(\"-skipWLSModuleScanning\")\n+        .addArgsItem(\"-loadProperties\")\n+        .addArgsItem(\"/u01/weblogic/\" + domainPropertiesFile.getFileName());\n+    //domain property file\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    createDomainJob(pvName, pvcName, domainScriptConfigMapName, namespace, jobCreationContainer);\n+\n+  }\n+\n+  /**\n+   * Create configmap containing domain creation scripts.\n+   *\n+   * @param configMapName name of the configmap to create\n+   * @param files files to add in configmap\n+   * @param namespace name of the namespace in which to create configmap\n+   * @throws IOException when reading the domain script files fail\n+   * @throws ApiException if create configmap fails\n+   */\n+  private void createConfigMapForDomainCreation(String configMapName, List<Path> files, String namespace)\n+      throws ApiException, IOException {\n+    logger.info(\"Creating configmap {0}\", configMapName);\n+\n+    Path domainScriptsDir = Files.createDirectories(\n+        Paths.get(TestConstants.LOGS_DIR, this.getClass().getSimpleName(), namespace));\n+\n+    // add domain creation scripts and properties files to the configmap\n+    Map<String, String> data = new HashMap<>();\n+    for (Path file : files) {\n+      logger.info(\"Adding file {0} in configmap\", file);\n+      data.put(file.getFileName().toString(), Files.readString(file));\n+      logger.info(\"Making a copy of file {0} to {1} for diagnostic purposes\", file,\n+          domainScriptsDir.resolve(file.getFileName()));\n+      Files.copy(file, domainScriptsDir.resolve(file.getFileName()));\n+    }\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .name(configMapName)\n+        .namespace(namespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Failed to create configmap %s with files %s\", configMapName, files));\n+    assertTrue(cmCreated, String.format(\"Failed while creating ConfigMap %s\", configMapName));\n+  }\n+\n+  /**\n+   * Create a job to create a domain in persistent volume.\n+   *\n+   * @param pvName name of the persistent volume to create domain in\n+   * @param pvcName name of the persistent volume claim\n+   * @param domainScriptCM configmap holding domain creation script files\n+   * @param namespace name of the domain namespace in which the job is created\n+   * @param jobContainer V1Container with job commands to create domain\n+   */\n+  private void createDomainJob(String pvName,\n+      String pvcName, String domainScriptCM, String namespace, V1Container jobContainer) {\n+    logger.info(\"Running Kubernetes job to create domain\");\n+\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job-\" + pvName) // name of the create domain job\n+                .namespace(namespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\") //\n+                        // change the ownership\n+                        // of the pv to opc:opc\n+                        .image(image)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R \"\n+                            + \"1000\"\n+                            + \":1000 \"\n+                            + \"/shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\n+                                    \"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(jobContainer // container\n+                        // containing WLST or WDT\n+                        // details\n+                        .name(\"create-weblogic-domain\"\n+                            + \"-onpv-container\")\n+                        .image(image)\n+                        .imagePullPolicy(\"Always\")\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) //\n+                                // location to write\n+                                // domain\n+                                .mountPath(\"/shared\"))))) // mounted under /shared inside pod\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptCM)))) //config map containing domain scripts\n+                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))\n+                        : null))));\n+    String jobName = assertDoesNotThrow(()\n+        -> createNamespacedJob(jobBody), \"Failed to create Job\");\n+\n+    logger.info(\"Checking if the domain creation job {0} completed in namespace {1}\",\n+        jobName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for job {0} to be completed in namespace {1} \"\n+                + \"(elapsed time {2} ms, remaining time {3} ms)\",\n+                jobName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(jobCompleted(jobName, null, namespace));\n+\n+    // check job status and fail test if the job failed to create domain\n+    V1Job job = assertDoesNotThrow(() -> getJob(jobName, namespace),\n+        \"Getting the job failed\");\n+    if (job != null) {\n+      V1JobCondition jobCondition = job.getStatus().getConditions().stream().filter(\n+          v1JobCondition -> \"Failed\".equalsIgnoreCase(v1JobCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+      if (jobCondition != null) {\n+        logger.severe(\"Job {0} failed to create domain\", jobName);\n+        List<V1Pod> pods = assertDoesNotThrow(()\n+            -> listPods(namespace, \"job-name=\" + jobName).getItems(),\n+            \"Listing pods failed\");\n+        if (!pods.isEmpty()) {\n+          String podLog = assertDoesNotThrow(() -> getPodLog(pods.get(0).getMetadata().getName(), namespace),\n+              \"Failed to get pod log\");\n+          logger.severe(podLog);\n+          fail(\"Domain create job failed\");\n+        }\n+      }\n+    }\n+\n+  }\n+\n+  /**\n+   * Create a persistent volume.\n+   *\n+   * @param pvName name of the persistent volume to create\n+   * @param domainUid domain UID\n+   * @throws IOException when creating pv path fails\n+   */\n+  private void createPV(String pvName, String domainUid) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY1NzIyMA=="}, "originalCommit": {"oid": "ed1e738b6d6e8ede701e73a7f95bcf26e057a4f4"}, "originalPosition": 1063}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4405, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}