{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQxNDIxOTgz", "number": 2106, "title": "OWLS 86406: WKO - scaling with webhook invoked from Prometheus not working", "bodyText": "This PR contains the following changes:\n\nChanges to scalingAction.sh for creating temporary per request python scripts for processing JSON results from K8s API requests.  These changes were for OFSS scaling.\nSupport in scalingAction.sh to use 'jq' to parse JSON when running on oraclelinux:8-slim, since python is not included.\nChange to initialize-internal-operator-identity.sh to use openssl, instead of keytool, for generating private key and self-signed certificate for the operator's internal REST endpoint.  curl clients running on oraclelinux:8-slim would fail verification of the keytool generated self-signed certificate.", "createdAt": "2020-12-16T20:31:10Z", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106", "merged": true, "mergeCommit": {"oid": "91b6dcbdeacea826181c0f3f9d6199ccf072dcfc"}, "closed": true, "closedAt": "2020-12-17T21:34:00Z", "author": {"login": "lennyphan"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdlPVhZgH2gAyNTQxNDIxOTgzOjgxMmNkMDk1NjJhMDllNDgzM2Y5MzE5ZjNlZjI1ODljOWM4NGYzZmU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdnKeVeAFqTU1NTAwNDQzNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "812cd09562a09e4833f9319f3ef2589c9c84f3fe", "author": {"user": {"login": "lennyphan", "name": "Lenny Phan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/812cd09562a09e4833f9319f3ef2589c9c84f3fe", "committedDate": "2020-12-11T22:04:31Z", "message": "Update scalingAction.sh to use jq command line tool, if present"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76f4993277bf1ee427898baa015f07368e422e9f", "author": {"user": {"login": "lennyphan", "name": "Lenny Phan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/76f4993277bf1ee427898baa015f07368e422e9f", "committedDate": "2020-12-15T20:31:14Z", "message": "update jq usage and use openssl to create certificate for internal REST"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf1cfa1952998fed290570f57a216467012c33ae", "author": {"user": {"login": "lennyphan", "name": "Lenny Phan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/cf1cfa1952998fed290570f57a216467012c33ae", "committedDate": "2020-12-15T21:16:10Z", "message": "Merge remote-tracking branch 'origin/develop' into OWLS-86406\n\nMerge latest from develop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8097361cb8cd6bb14db695cf8899471cc2a21a65", "author": {"user": {"login": "lennyphan", "name": "Lenny Phan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8097361cb8cd6bb14db695cf8899471cc2a21a65", "committedDate": "2020-12-16T05:51:42Z", "message": "refactor scalingAction.sh script"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b575072b0e55d2876ec13c705df8fcad90c025da", "author": {"user": {"login": "lennyphan", "name": "Lenny Phan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b575072b0e55d2876ec13c705df8fcad90c025da", "committedDate": "2020-12-16T17:16:37Z", "message": "Add comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "248e0bdaa28ada8e8ade9b5925ed6afedf77c44f", "author": {"user": {"login": "lennyphan", "name": "Lenny Phan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/248e0bdaa28ada8e8ade9b5925ed6afedf77c44f", "committedDate": "2020-12-16T17:25:21Z", "message": "Add comment about openssl for OL8-slim only"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MDc5NDc5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#pullrequestreview-554079479", "createdAt": "2020-12-16T20:59:45Z", "commit": {"oid": "248e0bdaa28ada8e8ade9b5925ed6afedf77c44f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMDo1OTo0NVrOIHY6vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMDo1OTo0NVrOIHY6vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYxOTE5Nw==", "bodyText": "Should this take into account 'min replicas' when minimum replicas is enabled?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r544619197", "createdAt": "2020-12-16T20:59:45Z", "author": {"login": "tbarnes-us"}, "path": "src/scripts/scaling/scalingAction.sh", "diffHunk": "@@ -2,24 +2,272 @@\n # Copyright (c) 2017, 2020, Oracle Corporation and/or its affiliates.\n # Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n \n-echo \"called scalingAction.sh\" >> scalingAction.log\n+currdate=`date`\n+\n+echo \"### $currdate ###\" >> scalingAction.log\n \n # script parameters\n-scaling_action=\"\"\n-wls_domain_uid=\"\"\n-wls_cluster_name=\"\"\n-wls_domain_namespace=\"default\"\n+scaling_action=\"scaleUp\"\n+wls_domain_uid=\"sample-domain1\"\n+wls_cluster_name=\"cluster-1\"\n+wls_domain_namespace=\"sample-domain1-ns\"\n operator_service_name=\"internal-weblogic-operator-svc\"\n-operator_namespace=\"weblogic-operator\"\n-operator_service_account=\"weblogic-operator\"\n+operator_namespace=\"sample-weblogic-operator-ns\"\n+operator_service_account=\"sample-weblogic-operator-sa\"\n scaling_size=1\n access_token=\"\"\n kubernetes_master=\"https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n \n+function print_usage() {\n+  echo \"Usage: scalingAction.sh --action=[scaleUp | scaleDown] --domain_uid=<domain uid> --cluster_name=<cluster name> [--kubernetes_master=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}] [--access_token=<access_token>] [--wls_domain_namespace=default] [--operator_namespace=weblogic-operator] [--operator_service_name=weblogic-operator] [--scaling_size=1]\"\n+  echo \"  where\"\n+  echo \"    action - scaleUp or scaleDown\"\n+  echo \"    domain_uid - WebLogic Domain Unique Identifier\"\n+  echo \"    cluster_name - WebLogic Cluster Name\"\n+  echo \"    kubernetes_master - Kubernetes master URL, default=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n+  echo \"    access_token - Service Account Bearer token for authentication and authorization for access to REST Resources\"\n+  echo \"    wls_domain_namespace - Kubernetes name space WebLogic Domain is defined in, default=default\"\n+  echo \"    operator_service_name - WebLogic Operator Service name, default=internal-weblogic-operator-svc\"\n+  echo \"    operator_service_account - Kubernetes Service Account for WebLogic Operator, default=weblogic-operator\"\n+  echo \"    operator_namespace - WebLogic Operator Namespace, default=weblogic-operator\"\n+  echo \"    scaling_size - number of WebLogic server instances by which to scale up or down, default=1\"\n+  exit 1\n+}\n+\n+# Retrieve WebLogic Operator Service Account Token for Authorization\n+function initialize_access_token() {\n+  if [ -z \"$access_token\" ]\n+  then\n+    access_token=`cat /var/run/secrets/kubernetes.io/serviceaccount/token`\n+  fi\n+}\n+\n+function logScalingParameters() {\n+  echo \"scaling_action: $scaling_action\" >> scalingAction.log\n+  echo \"wls_domain_uid: $wls_domain_uid\" >> scalingAction.log\n+  echo \"wls_cluster_name: $wls_cluster_name\" >> scalingAction.log\n+  echo \"wls_domain_namespace: $wls_domain_namespace\" >> scalingAction.log\n+  echo \"operator_service_name: $operator_service_name\" >> scalingAction.log\n+  echo \"operator_service_account: $operator_service_account\" >> scalingAction.log\n+  echo \"operator_namespace: $operator_namespace\" >> scalingAction.log\n+  echo \"scaling_size: $scaling_size\" >> scalingAction.log\n+}\n+\n+# Query WebLogic Operator Service Port\n+function get_operator_internal_rest_port() {\n+  local STATUS=$(curl -v --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" -X GET $kubernetes_master/api/v1/namespaces/$operator_namespace/services/$operator_service_name/status)\n+  if [ $? -ne 0 ]\n+  then\n+    echo \"$currdate Failed to retrieve status of $operator_service_name in name space: $operator_namespace\" >> scalingAction.log\n+    echo \"$currdate STATUS: $STATUS\" >> scalingAction.log\n+    exit 1\n+  fi\n+\n+  local port\n+  if [ -x \"$(command -v jq)\" ]; then\n+    local extractPortCmd=\"(.spec.ports[] | select (.name == \\\"rest\\\") | .port)\"\n+    port=$(echo \"${STATUS}\" | jq \"${extractPortCmd}\")\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"spec\"][\"ports\"]:\n+  if i[\"name\"] == \"rest\":\n+    print(i[\"port\"])\n+INPUT\n+port=$(echo \"${STATUS}\" | python cmds-$$.py)\n+  fi\n+  echo \"$port\"\n+}\n+\n+# Retrieve the api version of the deployed Custom Resource Domain\n+function get_domain_api_version() {\n+  # Retrieve Custom Resource Definition for WebLogic domain\n+  local CRD=`curl -v --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" -X GET $kubernetes_master/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/domains.weblogic.oracle`\n+  if [ $? -ne 0 ]\n+    then\n+      echo \"$currdate Failed to retrieve Custom Resource Definition for WebLogic domain\" >> scalingAction.log\n+      echo \"$currdate CRD: $CRD\" >> scalingAction.log\n+      exit 1\n+  fi\n+\n+# Find domain version\n+  local domain_api_version\n+  if [ -x \"$(command -v jq)\" ]; then\n+    domain_api_version=$(echo \"${CRD}\" | jq -r '.spec.version')\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+print(json.load(sys.stdin)[\"spec\"][\"version\"])\n+INPUT\n+domain_api_version=`echo ${CRD} | python cmds-$$.py`\n+  fi\n+  echo \"$domain_api_version\"\n+}\n+\n+# Retrieve Custom Resource Domain\n+function get_custom_resource_domain() {\n+  local DOMAIN=`curl -v --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" $kubernetes_master/apis/weblogic.oracle/$domain_api_version/namespaces/$wls_domain_namespace/domains/$domain_uid`\n+  if [ $? -ne 0 ]; then\n+    echo \"$currdate Failed to retrieve WebLogic Domain Custom Resource Definition\" >> scalingAction.log\n+    exit 1\n+  fi\n+  echo \"$DOMAIN\"\n+}\n+\n+# Verify if cluster is defined in clusters of the Custom Resource Domain\n+# args:\n+# $1 Custom Resource Domain\n+function is_defined_in_clusters() {\n+  local DOMAIN=\"$1\"\n+  local in_cluster_startup=\"False\"\n+  if [ -x \"$(command -v jq)\" ]; then\n+    local inClusterStartupCmd=\"(.items[].spec.clusters[] | select (.clusterName == \\\"${wls_cluster_name}\\\"))\"\n+    local clusterDefinedInCRD=$(echo \"${DOMAIN}\" | jq \"${inClusterStartupCmd}\")\n+    if [ \"${clusterDefinedInCRD}\" != \"\" ]; then\n+      in_cluster_startup=\"True\"\n+    fi\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+outer_loop_must_break = False\n+for i in json.load(sys.stdin)[\"items\"]:\n+  j = i[\"spec\"][\"clusters\"]\n+  for index, cs in enumerate(j):\n+    if j[index][\"clusterName\"] == \"$wls_cluster_name\":\n+      outer_loop_must_break = True\n+      print True\n+      break\n+if outer_loop_must_break == False:\n+  print False\n+INPUT\n+in_cluster_startup=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+  echo \"$in_cluster_startup\"\n+}\n+\n+# Gets the current replica count of the cluster\n+function get_num_ms_in_cluster() {\n+  local num_ms\n+  if [ -x \"$(command -v jq)\" ]; then\n+  local numManagedServersCmd=\"(.items[].spec.clusters[] | select (.clusterName == \\\"${wls_cluster_name}\\\") | .replicas)\"\n+  num_ms=$(echo \"${DOMAIN}\" | jq \"${numManagedServersCmd}\")\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"items\"]:\n+  j = i[\"spec\"][\"clusters\"]\n+  for index, cs in enumerate(j):\n+    if j[index][\"clusterName\"] == \"$wls_cluster_name\":\n+      print j[index][\"replicas\"]\n+INPUT\n+  num_ms=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+\n+  if [ \"${num_ms}\" == \"null\" ]; then\n+    num_ms=0\n+  fi\n+\n+  echo \"$num_ms\"\n+}\n+\n+# Gets the replica count at the Domain level\n+function get_num_ms_domain_scope() {\n+  local num_ms\n+  if [ -x \"$(command -v jq)\" ]; then\n+    num_ms=$(echo \"${DOMAIN}\" | jq -r '.items[].spec.replicas' )\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"items\"]:\n+  print i[\"spec\"][\"replicas\"]\n+INPUT\n+  num_ms=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+\n+  if [ \"${num_ms}\" == \"null\" ]; then\n+    num_ms=0\n+  fi\n+\n+  echo \"$num_ms\"\n+}\n+\n+# Get the current replica count for the WLS cluster if defined in the CRD's Cluster\n+# configuration.  If WLS cluster is not defined in the CRD then return the Domain\n+# scoped replica value, if present.  Returns replica count = 0 if no replica count found.\n+# args:\n+# $1 \"True\" if WLS cluster configuration defined in CRD, \"False\" otherwise\n+# $2 Custom Resource Domain\n+function get_replica_count() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "248e0bdaa28ada8e8ade9b5925ed6afedf77c44f"}, "originalPosition": 206}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MDgxNzU1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#pullrequestreview-554081755", "createdAt": "2020-12-16T21:03:09Z", "commit": {"oid": "248e0bdaa28ada8e8ade9b5925ed6afedf77c44f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMTowMzowOVrOIHZCKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMTowMzowOVrOIHZCKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYyMTA5Ng==", "bodyText": "This is one of a few examples of long curl commands in this pull that is on a single line.  Can this line and the others be broken up into multiple lines in order to aid readability?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r544621096", "createdAt": "2020-12-16T21:03:09Z", "author": {"login": "tbarnes-us"}, "path": "src/scripts/scaling/scalingAction.sh", "diffHunk": "@@ -2,24 +2,272 @@\n # Copyright (c) 2017, 2020, Oracle Corporation and/or its affiliates.\n # Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n \n-echo \"called scalingAction.sh\" >> scalingAction.log\n+currdate=`date`\n+\n+echo \"### $currdate ###\" >> scalingAction.log\n \n # script parameters\n-scaling_action=\"\"\n-wls_domain_uid=\"\"\n-wls_cluster_name=\"\"\n-wls_domain_namespace=\"default\"\n+scaling_action=\"scaleUp\"\n+wls_domain_uid=\"sample-domain1\"\n+wls_cluster_name=\"cluster-1\"\n+wls_domain_namespace=\"sample-domain1-ns\"\n operator_service_name=\"internal-weblogic-operator-svc\"\n-operator_namespace=\"weblogic-operator\"\n-operator_service_account=\"weblogic-operator\"\n+operator_namespace=\"sample-weblogic-operator-ns\"\n+operator_service_account=\"sample-weblogic-operator-sa\"\n scaling_size=1\n access_token=\"\"\n kubernetes_master=\"https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n \n+function print_usage() {\n+  echo \"Usage: scalingAction.sh --action=[scaleUp | scaleDown] --domain_uid=<domain uid> --cluster_name=<cluster name> [--kubernetes_master=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}] [--access_token=<access_token>] [--wls_domain_namespace=default] [--operator_namespace=weblogic-operator] [--operator_service_name=weblogic-operator] [--scaling_size=1]\"\n+  echo \"  where\"\n+  echo \"    action - scaleUp or scaleDown\"\n+  echo \"    domain_uid - WebLogic Domain Unique Identifier\"\n+  echo \"    cluster_name - WebLogic Cluster Name\"\n+  echo \"    kubernetes_master - Kubernetes master URL, default=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n+  echo \"    access_token - Service Account Bearer token for authentication and authorization for access to REST Resources\"\n+  echo \"    wls_domain_namespace - Kubernetes name space WebLogic Domain is defined in, default=default\"\n+  echo \"    operator_service_name - WebLogic Operator Service name, default=internal-weblogic-operator-svc\"\n+  echo \"    operator_service_account - Kubernetes Service Account for WebLogic Operator, default=weblogic-operator\"\n+  echo \"    operator_namespace - WebLogic Operator Namespace, default=weblogic-operator\"\n+  echo \"    scaling_size - number of WebLogic server instances by which to scale up or down, default=1\"\n+  exit 1\n+}\n+\n+# Retrieve WebLogic Operator Service Account Token for Authorization\n+function initialize_access_token() {\n+  if [ -z \"$access_token\" ]\n+  then\n+    access_token=`cat /var/run/secrets/kubernetes.io/serviceaccount/token`\n+  fi\n+}\n+\n+function logScalingParameters() {\n+  echo \"scaling_action: $scaling_action\" >> scalingAction.log\n+  echo \"wls_domain_uid: $wls_domain_uid\" >> scalingAction.log\n+  echo \"wls_cluster_name: $wls_cluster_name\" >> scalingAction.log\n+  echo \"wls_domain_namespace: $wls_domain_namespace\" >> scalingAction.log\n+  echo \"operator_service_name: $operator_service_name\" >> scalingAction.log\n+  echo \"operator_service_account: $operator_service_account\" >> scalingAction.log\n+  echo \"operator_namespace: $operator_namespace\" >> scalingAction.log\n+  echo \"scaling_size: $scaling_size\" >> scalingAction.log\n+}\n+\n+# Query WebLogic Operator Service Port\n+function get_operator_internal_rest_port() {\n+  local STATUS=$(curl -v --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" -X GET $kubernetes_master/api/v1/namespaces/$operator_namespace/services/$operator_service_name/status)\n+  if [ $? -ne 0 ]\n+  then\n+    echo \"$currdate Failed to retrieve status of $operator_service_name in name space: $operator_namespace\" >> scalingAction.log\n+    echo \"$currdate STATUS: $STATUS\" >> scalingAction.log\n+    exit 1\n+  fi\n+\n+  local port\n+  if [ -x \"$(command -v jq)\" ]; then\n+    local extractPortCmd=\"(.spec.ports[] | select (.name == \\\"rest\\\") | .port)\"\n+    port=$(echo \"${STATUS}\" | jq \"${extractPortCmd}\")\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"spec\"][\"ports\"]:\n+  if i[\"name\"] == \"rest\":\n+    print(i[\"port\"])\n+INPUT\n+port=$(echo \"${STATUS}\" | python cmds-$$.py)\n+  fi\n+  echo \"$port\"\n+}\n+\n+# Retrieve the api version of the deployed Custom Resource Domain\n+function get_domain_api_version() {\n+  # Retrieve Custom Resource Definition for WebLogic domain\n+  local CRD=`curl -v --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" -X GET $kubernetes_master/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/domains.weblogic.oracle`\n+  if [ $? -ne 0 ]\n+    then\n+      echo \"$currdate Failed to retrieve Custom Resource Definition for WebLogic domain\" >> scalingAction.log\n+      echo \"$currdate CRD: $CRD\" >> scalingAction.log\n+      exit 1\n+  fi\n+\n+# Find domain version\n+  local domain_api_version\n+  if [ -x \"$(command -v jq)\" ]; then\n+    domain_api_version=$(echo \"${CRD}\" | jq -r '.spec.version')\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+print(json.load(sys.stdin)[\"spec\"][\"version\"])\n+INPUT\n+domain_api_version=`echo ${CRD} | python cmds-$$.py`\n+  fi\n+  echo \"$domain_api_version\"\n+}\n+\n+# Retrieve Custom Resource Domain\n+function get_custom_resource_domain() {\n+  local DOMAIN=`curl -v --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" $kubernetes_master/apis/weblogic.oracle/$domain_api_version/namespaces/$wls_domain_namespace/domains/$domain_uid`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "248e0bdaa28ada8e8ade9b5925ed6afedf77c44f"}, "originalPosition": 115}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MDg2OTk1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#pullrequestreview-554086995", "createdAt": "2020-12-16T21:11:03Z", "commit": {"oid": "248e0bdaa28ada8e8ade9b5925ed6afedf77c44f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMToxMTowM1rOIHZTkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMToxMTowM1rOIHZTkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYyNTU1NQ==", "bodyText": "Nice to have: See resources/scripts/utils.sh for a timestamp bash function that generates a timestamp in a format that exactly matches the operator logs timestamp format and the timestamp format we use in startServer.sh, etc.  (It's nice to have all of our major scripts use the same timestamp format.)\nNice to have: Consider defining a 'trace' function to replace your use of echo throughout. The trace can then automatically inject the timestamp...", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r544625555", "createdAt": "2020-12-16T21:11:03Z", "author": {"login": "tbarnes-us"}, "path": "src/scripts/scaling/scalingAction.sh", "diffHunk": "@@ -2,24 +2,272 @@\n # Copyright (c) 2017, 2020, Oracle Corporation and/or its affiliates.\n # Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n \n-echo \"called scalingAction.sh\" >> scalingAction.log\n+currdate=`date`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "248e0bdaa28ada8e8ade9b5925ed6afedf77c44f"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MTAzOTc3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#pullrequestreview-554103977", "createdAt": "2020-12-16T21:36:27Z", "commit": {"oid": "248e0bdaa28ada8e8ade9b5925ed6afedf77c44f"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MTYyOTkx", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#pullrequestreview-554162991", "createdAt": "2020-12-16T23:17:36Z", "commit": {"oid": "248e0bdaa28ada8e8ade9b5925ed6afedf77c44f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMzoxNzozNlrOIHdbOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMzoxNzozNlrOIHdbOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY5MzA1MQ==", "bodyText": "Ha, ha... Austin, TX. (Don't bother making that change -- I just found it funny that you chose California)", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r544693051", "createdAt": "2020-12-16T23:17:36Z", "author": {"login": "rjeberhard"}, "path": "src/scripts/initialize-internal-operator-identity.sh", "diffHunk": "@@ -34,56 +34,24 @@ function generateInternalIdentity {\n   host=\"internal-weblogic-operator-svc\"\n   SANS=\"DNS:${host},DNS:${host}.${NAMESPACE},DNS:${host}.${NAMESPACE}.svc,DNS:${host}.${NAMESPACE}.svc.cluster.local\"\n   DAYS_VALID=\"3650\"\n-  TEMP_PW=\"temp_password\"\n   OP_PREFIX=\"weblogic-operator\"\n-  OP_ALIAS=\"${OP_PREFIX}-alias\"\n-  OP_JKS=\"${TEMP_DIR}/${OP_PREFIX}.jks\"\n-  OP_PKCS12=\"${TEMP_DIR}/${OP_PREFIX}.p12\"\n-  OP_CSR=\"${TEMP_DIR}/${OP_PREFIX}.csr\"\n   OP_CERT_PEM=\"${TEMP_DIR}/${OP_PREFIX}.cert.pem\"\n   OP_KEY_PEM=\"${TEMP_DIR}/${OP_PREFIX}.key.pem\"\n-  KEYTOOL=${JAVA_HOME}/bin/keytool\n-\n-  # generate a keypair for the operator's internal service, putting it in a keystore\n-  $KEYTOOL \\\n-    -genkey \\\n-    -keystore ${OP_JKS} \\\n-    -alias ${OP_ALIAS} \\\n-    -storepass ${TEMP_PW} \\\n-    -keypass ${TEMP_PW} \\\n-    -keysize 2048 \\\n-    -keyalg RSA \\\n-    -validity ${DAYS_VALID} \\\n-    -dname \"CN=weblogic-operator\" \\\n-    -ext KU=digitalSignature,nonRepudiation,keyEncipherment,dataEncipherment,keyAgreement \\\n-    -ext SAN=\"${SANS}\"\n-\n-  # extract the cert to a pem file\n-  $KEYTOOL \\\n-    -exportcert \\\n-    -keystore ${OP_JKS} \\\n-    -storepass ${TEMP_PW} \\\n-    -alias ${OP_ALIAS} \\\n-    -rfc \\\n-    > ${OP_CERT_PEM}\n-\n-  # convert the keystore to a pkcs12 file\n-  $KEYTOOL \\\n-    -importkeystore \\\n-    -srckeystore ${OP_JKS} \\\n-    -srcstorepass ${TEMP_PW} \\\n-    -destkeystore ${OP_PKCS12} \\\n-    -deststorepass ${TEMP_PW} \\\n-    -deststoretype PKCS12\n-\n-  # extract the private key from the pkcs12 file to a pem file\n+\n+  # generate a keypair for the operator's internal service\n+  # openssl v1.1.1 is the required minimum to use 'addext' option for\n+  # speciifying \"Subject Alternative Names (SANS)\" thus the following\n+  # configuration cannot be used on Oracle Linux 7-slim.\n   openssl \\\n-    pkcs12 \\\n-    -in ${OP_PKCS12} \\\n-    -passin pass:${TEMP_PW} \\\n+    req \\\n+    -newkey rsa:2048 \\\n     -nodes \\\n-    -nocerts \\\n-    -out ${OP_KEY_PEM}\n+    -keyout ${OP_KEY_PEM} \\\n+    -x509 \\\n+    -days ${DAYS_VALID} \\\n+    -out ${OP_CERT_PEM} \\\n+    -subj \"/C=US/ST=CALIFORNIA/L=REDWOOD CITY/O=WebLogic/OU=Development/CN=weblogic-operator\" \\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "248e0bdaa28ada8e8ade9b5925ed6afedf77c44f"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MTY1MDAw", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#pullrequestreview-554165000", "createdAt": "2020-12-16T23:21:49Z", "commit": {"oid": "248e0bdaa28ada8e8ade9b5925ed6afedf77c44f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae8487d98e1886fb1b5c0fc2707a4ca33b6d702f", "author": {"user": {"login": "lennyphan", "name": "Lenny Phan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/ae8487d98e1886fb1b5c0fc2707a4ca33b6d702f", "committedDate": "2020-12-17T00:33:56Z", "message": "Update scalingAction.sh based on code review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4908acb65eea150724e274cfb7dcdcde169f4d4", "author": {"user": {"login": "lennyphan", "name": "Lenny Phan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c4908acb65eea150724e274cfb7dcdcde169f4d4", "committedDate": "2020-12-17T00:38:29Z", "message": "revert default scripts values"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0NzU2MTMw", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#pullrequestreview-554756130", "createdAt": "2020-12-17T16:10:56Z", "commit": {"oid": "c4908acb65eea150724e274cfb7dcdcde169f4d4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNjoxMDo1N1rOIH9Fzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNjoxMDo1N1rOIH9Fzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIxMTg1NQ==", "bodyText": "It looks like every single trace is redirected to 'scalingAction.log', so the redirect can be centralized into this function.\nAlso, can the same log file be shared by multiple different clusters and domains?  If so, then it'd be helpful to decorate each trace with the current namespace, domain-uid, and cluster-name \"[ns=xxx][uid=xxx][cl=xxx]\".", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545211855", "createdAt": "2020-12-17T16:10:57Z", "author": {"login": "tbarnes-us"}, "path": "src/scripts/scaling/scalingAction.sh", "diffHunk": "@@ -16,10 +14,291 @@ scaling_size=1\n access_token=\"\"\n kubernetes_master=\"https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n \n+# timestamp\n+#   purpose:  echo timestamp in the form yyyymmddThh:mm:ss.mmm ZZZ\n+#   example:  20181001T14:00:00.001 UTC\n+function timestamp() {\n+  local timestamp=\"`date --utc '+%Y-%m-%dT%H:%M:%S %N %s %Z' 2>&1`\"\n+  if [ ! \"${timestamp/illegal/xyz}\" = \"${timestamp}\" ]; then\n+    # old shell versions don't support %N or --utc\n+    timestamp=\"`date -u '+%Y-%m-%dT%H:%M:%S 000000 %s %Z' 2>&1`\"\n+  fi\n+  local ymdhms=\"`echo $timestamp | awk '{ print $1 }'`\"\n+  # convert nano to milli\n+  local milli=\"`echo $timestamp | awk '{ print $2 }' | sed 's/\\(^...\\).*/\\1/'`\"\n+  local secs_since_epoch=\"`echo $timestamp | awk '{ print $3 }'`\"\n+  local millis_since_opoch=\"${secs_since_epoch}${milli}\"\n+  local timezone=\"`echo $timestamp | awk '{ print $4 }'`\"\n+  echo \"${ymdhms}.${milli} ${timezone}\"\n+}\n+\n+function trace() {\n+  echo \"@[$(timestamp)][INFO]\" \"$@\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4908acb65eea150724e274cfb7dcdcde169f4d4"}, "originalPosition": 32}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d40004a546499d121a20d8ec63b2e6141e5ccbea", "author": {"user": {"login": "lennyphan", "name": "Lenny Phan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d40004a546499d121a20d8ec63b2e6141e5ccbea", "committedDate": "2020-12-17T19:02:09Z", "message": "Updated logging and verify scaling request against configured minimum replica count"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0OTIwNDQ0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#pullrequestreview-554920444", "createdAt": "2020-12-17T19:28:49Z", "commit": {"oid": "d40004a546499d121a20d8ec63b2e6141e5ccbea"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxOToyODo1MFrOIIFXKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxOToyODo1MFrOIIFXKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0NzM3MA==", "bodyText": "This URL path is wrong for K8s 1.16 and above as CRD's graduated from \"v1beta1\" to \"v1\". You could either determine the version of the k8s master or I have another idea. If you curl the \"$kubernetes_master/apis\" path, you get back a list of all API's supported by the server. This is equivalent to kubectl api-versions. The code could pick out the highest version of \"weblogic.oracle\" returned. For instance, on my system I get back \"weblogic.oracle/v7\" and \"weblogic.oracle/v8\".", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545347370", "createdAt": "2020-12-17T19:28:50Z", "author": {"login": "rjeberhard"}, "path": "src/scripts/scaling/scalingAction.sh", "diffHunk": "@@ -16,10 +14,328 @@ scaling_size=1\n access_token=\"\"\n kubernetes_master=\"https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n \n+# timestamp\n+#   purpose:  echo timestamp in the form yyyymmddThh:mm:ss.mmm ZZZ\n+#   example:  20181001T14:00:00.001 UTC\n+function timestamp() {\n+  local timestamp=\"`date --utc '+%Y-%m-%dT%H:%M:%S %N %s %Z' 2>&1`\"\n+  if [ ! \"${timestamp/illegal/xyz}\" = \"${timestamp}\" ]; then\n+    # old shell versions don't support %N or --utc\n+    timestamp=\"`date -u '+%Y-%m-%dT%H:%M:%S 000000 %s %Z' 2>&1`\"\n+  fi\n+  local ymdhms=\"`echo $timestamp | awk '{ print $1 }'`\"\n+  # convert nano to milli\n+  local milli=\"`echo $timestamp | awk '{ print $2 }' | sed 's/\\(^...\\).*/\\1/'`\"\n+  local secs_since_epoch=\"`echo $timestamp | awk '{ print $3 }'`\"\n+  local millis_since_opoch=\"${secs_since_epoch}${milli}\"\n+  local timezone=\"`echo $timestamp | awk '{ print $4 }'`\"\n+  echo \"${ymdhms}.${milli} ${timezone}\"\n+}\n+\n+function trace() {\n+  echo \"@[$(timestamp)][$wls_domain_namespace][$wls_domain_uid][$wls_cluster_name][INFO]\" \"$@\" >> scalingAction.log\n+}\n+\n+function print_usage() {\n+  echo \"Usage: scalingAction.sh --action=[scaleUp | scaleDown] --domain_uid=<domain uid> --cluster_name=<cluster name> [--kubernetes_master=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}] [--access_token=<access_token>] [--wls_domain_namespace=default] [--operator_namespace=weblogic-operator] [--operator_service_name=weblogic-operator] [--scaling_size=1]\"\n+  echo \"  where\"\n+  echo \"    action - scaleUp or scaleDown\"\n+  echo \"    domain_uid - WebLogic Domain Unique Identifier\"\n+  echo \"    cluster_name - WebLogic Cluster Name\"\n+  echo \"    kubernetes_master - Kubernetes master URL, default=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n+  echo \"    access_token - Service Account Bearer token for authentication and authorization for access to REST Resources\"\n+  echo \"    wls_domain_namespace - Kubernetes name space WebLogic Domain is defined in, default=default\"\n+  echo \"    operator_service_name - WebLogic Operator Service name, default=internal-weblogic-operator-svc\"\n+  echo \"    operator_service_account - Kubernetes Service Account for WebLogic Operator, default=weblogic-operator\"\n+  echo \"    operator_namespace - WebLogic Operator Namespace, default=weblogic-operator\"\n+  echo \"    scaling_size - number of WebLogic server instances by which to scale up or down, default=1\"\n+  exit 1\n+}\n+\n+# Retrieve WebLogic Operator Service Account Token for Authorization\n+function initialize_access_token() {\n+  if [ -z \"$access_token\" ]\n+  then\n+    access_token=`cat /var/run/secrets/kubernetes.io/serviceaccount/token`\n+  fi\n+}\n+\n+function logScalingParameters() {\n+  trace \"scaling_action: $scaling_action\"\n+  trace \"wls_domain_uid: $wls_domain_uid\"\n+  trace \"wls_cluster_name: $wls_cluster_name\"\n+  trace \"wls_domain_namespace: $wls_domain_namespace\"\n+  trace \"operator_service_name: $operator_service_name\"\n+  trace \"operator_service_account: $operator_service_account\"\n+  trace \"operator_namespace: $operator_namespace\"\n+  trace \"scaling_size: $scaling_size\"\n+}\n+\n+# Query WebLogic Operator Service Port\n+function get_operator_internal_rest_port() {\n+  local STATUS=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    -X GET $kubernetes_master/api/v1/namespaces/$operator_namespace/services/$operator_service_name/status)\n+  if [ $? -ne 0 ]\n+  then\n+    trace \"Failed to retrieve status of $operator_service_name in name space: $operator_namespace\"\n+    trace \"STATUS: $STATUS\"\n+    exit 1\n+  fi\n+\n+  local port\n+  if [ -x \"$(command -v jq)\" ]; then\n+    local extractPortCmd=\"(.spec.ports[] | select (.name == \\\"rest\\\") | .port)\"\n+    port=$(echo \"${STATUS}\" | jq \"${extractPortCmd}\")\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"spec\"][\"ports\"]:\n+  if i[\"name\"] == \"rest\":\n+    print(i[\"port\"])\n+INPUT\n+port=$(echo \"${STATUS}\" | python cmds-$$.py)\n+  fi\n+  echo \"$port\"\n+}\n+\n+# Retrieve the api version of the deployed Custom Resource Domain\n+function get_domain_api_version() {\n+  # Retrieve Custom Resource Definition for WebLogic domain\n+  local CRD=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    -X GET \\\n+    $kubernetes_master/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/domains.weblogic.oracle)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d40004a546499d121a20d8ec63b2e6141e5ccbea"}, "originalPosition": 108}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0OTI2ODc3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#pullrequestreview-554926877", "createdAt": "2020-12-17T19:37:34Z", "commit": {"oid": "d40004a546499d121a20d8ec63b2e6141e5ccbea"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxOTozNzozNVrOIIFr4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxOTozNzozNVrOIIFr4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1MjY3NQ==", "bodyText": "I assume this should be \"get_min_replicas\".", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545352675", "createdAt": "2020-12-17T19:37:35Z", "author": {"login": "tbarnes-us"}, "path": "src/scripts/scaling/scalingAction.sh", "diffHunk": "@@ -16,10 +14,328 @@ scaling_size=1\n access_token=\"\"\n kubernetes_master=\"https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n \n+# timestamp\n+#   purpose:  echo timestamp in the form yyyymmddThh:mm:ss.mmm ZZZ\n+#   example:  20181001T14:00:00.001 UTC\n+function timestamp() {\n+  local timestamp=\"`date --utc '+%Y-%m-%dT%H:%M:%S %N %s %Z' 2>&1`\"\n+  if [ ! \"${timestamp/illegal/xyz}\" = \"${timestamp}\" ]; then\n+    # old shell versions don't support %N or --utc\n+    timestamp=\"`date -u '+%Y-%m-%dT%H:%M:%S 000000 %s %Z' 2>&1`\"\n+  fi\n+  local ymdhms=\"`echo $timestamp | awk '{ print $1 }'`\"\n+  # convert nano to milli\n+  local milli=\"`echo $timestamp | awk '{ print $2 }' | sed 's/\\(^...\\).*/\\1/'`\"\n+  local secs_since_epoch=\"`echo $timestamp | awk '{ print $3 }'`\"\n+  local millis_since_opoch=\"${secs_since_epoch}${milli}\"\n+  local timezone=\"`echo $timestamp | awk '{ print $4 }'`\"\n+  echo \"${ymdhms}.${milli} ${timezone}\"\n+}\n+\n+function trace() {\n+  echo \"@[$(timestamp)][$wls_domain_namespace][$wls_domain_uid][$wls_cluster_name][INFO]\" \"$@\" >> scalingAction.log\n+}\n+\n+function print_usage() {\n+  echo \"Usage: scalingAction.sh --action=[scaleUp | scaleDown] --domain_uid=<domain uid> --cluster_name=<cluster name> [--kubernetes_master=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}] [--access_token=<access_token>] [--wls_domain_namespace=default] [--operator_namespace=weblogic-operator] [--operator_service_name=weblogic-operator] [--scaling_size=1]\"\n+  echo \"  where\"\n+  echo \"    action - scaleUp or scaleDown\"\n+  echo \"    domain_uid - WebLogic Domain Unique Identifier\"\n+  echo \"    cluster_name - WebLogic Cluster Name\"\n+  echo \"    kubernetes_master - Kubernetes master URL, default=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n+  echo \"    access_token - Service Account Bearer token for authentication and authorization for access to REST Resources\"\n+  echo \"    wls_domain_namespace - Kubernetes name space WebLogic Domain is defined in, default=default\"\n+  echo \"    operator_service_name - WebLogic Operator Service name, default=internal-weblogic-operator-svc\"\n+  echo \"    operator_service_account - Kubernetes Service Account for WebLogic Operator, default=weblogic-operator\"\n+  echo \"    operator_namespace - WebLogic Operator Namespace, default=weblogic-operator\"\n+  echo \"    scaling_size - number of WebLogic server instances by which to scale up or down, default=1\"\n+  exit 1\n+}\n+\n+# Retrieve WebLogic Operator Service Account Token for Authorization\n+function initialize_access_token() {\n+  if [ -z \"$access_token\" ]\n+  then\n+    access_token=`cat /var/run/secrets/kubernetes.io/serviceaccount/token`\n+  fi\n+}\n+\n+function logScalingParameters() {\n+  trace \"scaling_action: $scaling_action\"\n+  trace \"wls_domain_uid: $wls_domain_uid\"\n+  trace \"wls_cluster_name: $wls_cluster_name\"\n+  trace \"wls_domain_namespace: $wls_domain_namespace\"\n+  trace \"operator_service_name: $operator_service_name\"\n+  trace \"operator_service_account: $operator_service_account\"\n+  trace \"operator_namespace: $operator_namespace\"\n+  trace \"scaling_size: $scaling_size\"\n+}\n+\n+# Query WebLogic Operator Service Port\n+function get_operator_internal_rest_port() {\n+  local STATUS=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    -X GET $kubernetes_master/api/v1/namespaces/$operator_namespace/services/$operator_service_name/status)\n+  if [ $? -ne 0 ]\n+  then\n+    trace \"Failed to retrieve status of $operator_service_name in name space: $operator_namespace\"\n+    trace \"STATUS: $STATUS\"\n+    exit 1\n+  fi\n+\n+  local port\n+  if [ -x \"$(command -v jq)\" ]; then\n+    local extractPortCmd=\"(.spec.ports[] | select (.name == \\\"rest\\\") | .port)\"\n+    port=$(echo \"${STATUS}\" | jq \"${extractPortCmd}\")\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"spec\"][\"ports\"]:\n+  if i[\"name\"] == \"rest\":\n+    print(i[\"port\"])\n+INPUT\n+port=$(echo \"${STATUS}\" | python cmds-$$.py)\n+  fi\n+  echo \"$port\"\n+}\n+\n+# Retrieve the api version of the deployed Custom Resource Domain\n+function get_domain_api_version() {\n+  # Retrieve Custom Resource Definition for WebLogic domain\n+  local CRD=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    -X GET \\\n+    $kubernetes_master/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/domains.weblogic.oracle)\n+  if [ $? -ne 0 ]\n+    then\n+      trace \"Failed to retrieve Custom Resource Definition for WebLogic domain\"\n+      trace \"CRD: $CRD\"\n+      exit 1\n+  fi\n+\n+# Find domain version\n+  local domain_api_version\n+  if [ -x \"$(command -v jq)\" ]; then\n+    domain_api_version=$(echo \"${CRD}\" | jq -r '.spec.version')\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+print(json.load(sys.stdin)[\"spec\"][\"version\"])\n+INPUT\n+domain_api_version=`echo ${CRD} | python cmds-$$.py`\n+  fi\n+  echo \"$domain_api_version\"\n+}\n+\n+# Retrieve Custom Resource Domain\n+function get_custom_resource_domain() {\n+  local DOMAIN=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    $kubernetes_master/apis/weblogic.oracle/$domain_api_version/namespaces/$wls_domain_namespace/domains/$domain_uid)\n+  if [ $? -ne 0 ]; then\n+    trace \"Failed to retrieve WebLogic Domain Custom Resource Definition\"\n+    exit 1\n+  fi\n+  echo \"$DOMAIN\"\n+}\n+\n+# Verify if cluster is defined in clusters of the Custom Resource Domain\n+# args:\n+# $1 Custom Resource Domain\n+function is_defined_in_clusters() {\n+  local DOMAIN=\"$1\"\n+  local in_cluster_startup=\"False\"\n+  if [ -x \"$(command -v jq)\" ]; then\n+    local inClusterStartupCmd=\"(.items[].spec.clusters[] | select (.clusterName == \\\"${wls_cluster_name}\\\"))\"\n+    local clusterDefinedInCRD=$(echo \"${DOMAIN}\" | jq \"${inClusterStartupCmd}\")\n+    if [ \"${clusterDefinedInCRD}\" != \"\" ]; then\n+      in_cluster_startup=\"True\"\n+    fi\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+outer_loop_must_break = False\n+for i in json.load(sys.stdin)[\"items\"]:\n+  j = i[\"spec\"][\"clusters\"]\n+  for index, cs in enumerate(j):\n+    if j[index][\"clusterName\"] == \"$wls_cluster_name\":\n+      outer_loop_must_break = True\n+      print True\n+      break\n+if outer_loop_must_break == False:\n+  print False\n+INPUT\n+in_cluster_startup=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+  echo \"$in_cluster_startup\"\n+}\n+\n+# Gets the current replica count of the cluster\n+function get_num_ms_in_cluster() {\n+  local num_ms\n+  if [ -x \"$(command -v jq)\" ]; then\n+  local numManagedServersCmd=\"(.items[].spec.clusters[] | select (.clusterName == \\\"${wls_cluster_name}\\\") | .replicas)\"\n+  num_ms=$(echo \"${DOMAIN}\" | jq \"${numManagedServersCmd}\")\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"items\"]:\n+  j = i[\"spec\"][\"clusters\"]\n+  for index, cs in enumerate(j):\n+    if j[index][\"clusterName\"] == \"$wls_cluster_name\":\n+      print j[index][\"replicas\"]\n+INPUT\n+  num_ms=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+\n+  if [ \"${num_ms}\" == \"null\" ]; then\n+    num_ms=0\n+  fi\n+\n+  echo \"$num_ms\"\n+}\n+\n+# Gets the replica count at the Domain level\n+function get_num_ms_domain_scope() {\n+  local num_ms\n+  if [ -x \"$(command -v jq)\" ]; then\n+    num_ms=$(echo \"${DOMAIN}\" | jq -r '.items[].spec.replicas' )\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"items\"]:\n+  print i[\"spec\"][\"replicas\"]\n+INPUT\n+  num_ms=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+\n+  if [ \"${num_ms}\" == \"null\" ]; then\n+    num_ms=0\n+  fi\n+\n+  echo \"$num_ms\"\n+}\n+\n+#\n+# Function to get minimum replica count for cluster\n+# $1 - Domain resource in json format\n+# $2 - Name of the cluster\n+# $3 - Return value containing minimum replica count\n+#\n+function get_min_replicas {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __result=$3\n+\n+  eval $__result=0\n+  minReplicaCmd=\"(.status.clusters[] | select (.clusterName == \\\"${clusterName}\\\")) \\\n+    | .minimumReplicas\"\n+  minReplicas=$(echo ${domainJson} | jq \"${minReplicaCmd}\")\n+  eval $__result=${minReplicas}\n+}\n+\n+# Get the current replica count for the WLS cluster if defined in the CRD's Cluster\n+# configuration.  If WLS cluster is not defined in the CRD then return the Domain\n+# scoped replica value, if present.  Returns replica count = 0 if no replica count found.\n+# args:\n+# $1 \"True\" if WLS cluster configuration defined in CRD, \"False\" otherwise\n+# $2 Custom Resource Domain\n+function get_replica_count() {\n+  local in_cluster_startup=\"$1\"\n+  local DOMAIN=\"$2\"\n+  local num_ms\n+  if [ \"$in_cluster_startup\" == \"True\" ]\n+  then\n+    trace \"$wls_cluster_name defined in clusters\"\n+    num_ms=$(get_num_ms_in_cluster \"$DOMAIN\")\n+  else\n+    trace \"$wls_cluster_name NOT defined in clusters\"\n+    num_ms=$(get_num_ms_domain_scope \"$DOMAIN\")\n+  fi\n+  echo \"$num_ms\"\n+}\n+\n+# Determine the nuber of managed servers to scale\n+# args:\n+# $1 scaling action (scaleUp or scaleDown)\n+# $2 current replica count\n+# $3 scaling increment value\n+function calculate_new_ms_count() {\n+  local scaling_action=\"$1\"\n+  local current_replica_count=\"$2\"\n+  local scaling_size=\"$3\"\n+  local new_ms\n+  if [ \"$scaling_action\" == \"scaleUp\" ];\n+  then\n+    # Scale up by specified scaling size\n+    # shellcheck disable=SC2004\n+    new_ms=$(($current_replica_count + $scaling_size))\n+  else\n+    # Scale down by specified scaling size\n+    new_ms=$(($current_replica_count - $scaling_size))\n+  fi\n+  echo \"$new_ms\"\n+}\n+\n+# Verify if requested managed server scaling count is less than the configured\n+# minimum replica count for the cluster.\n+# args:\n+# $1 Managed server count\n+# $2 Custom Resource Domain\n+# $3 Cluster name\n+function verify_minimum_ms_count_for_cluster() {\n+  local new_ms=\"$1\"\n+  local domainJson=\"$2\"\n+  local clusterName=\"$3\"\n+  # check if replica count is less than minimum replicas\n+  getMinReplicas \"${domainJson}\" \"${clusterName}\" minReplicas", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d40004a546499d121a20d8ec63b2e6141e5ccbea"}, "originalPosition": 293}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0OTI4OTg2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#pullrequestreview-554928986", "createdAt": "2020-12-17T19:40:23Z", "commit": {"oid": "d40004a546499d121a20d8ec63b2e6141e5ccbea"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxOTo0MDoyNFrOIIFylw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxOTo0MDoyNFrOIIFylw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1NDM5MQ==", "bodyText": "This should return 'min_replica_count' if min_replica_ count is higher than the discovered value.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545354391", "createdAt": "2020-12-17T19:40:24Z", "author": {"login": "tbarnes-us"}, "path": "src/scripts/scaling/scalingAction.sh", "diffHunk": "@@ -16,10 +14,328 @@ scaling_size=1\n access_token=\"\"\n kubernetes_master=\"https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n \n+# timestamp\n+#   purpose:  echo timestamp in the form yyyymmddThh:mm:ss.mmm ZZZ\n+#   example:  20181001T14:00:00.001 UTC\n+function timestamp() {\n+  local timestamp=\"`date --utc '+%Y-%m-%dT%H:%M:%S %N %s %Z' 2>&1`\"\n+  if [ ! \"${timestamp/illegal/xyz}\" = \"${timestamp}\" ]; then\n+    # old shell versions don't support %N or --utc\n+    timestamp=\"`date -u '+%Y-%m-%dT%H:%M:%S 000000 %s %Z' 2>&1`\"\n+  fi\n+  local ymdhms=\"`echo $timestamp | awk '{ print $1 }'`\"\n+  # convert nano to milli\n+  local milli=\"`echo $timestamp | awk '{ print $2 }' | sed 's/\\(^...\\).*/\\1/'`\"\n+  local secs_since_epoch=\"`echo $timestamp | awk '{ print $3 }'`\"\n+  local millis_since_opoch=\"${secs_since_epoch}${milli}\"\n+  local timezone=\"`echo $timestamp | awk '{ print $4 }'`\"\n+  echo \"${ymdhms}.${milli} ${timezone}\"\n+}\n+\n+function trace() {\n+  echo \"@[$(timestamp)][$wls_domain_namespace][$wls_domain_uid][$wls_cluster_name][INFO]\" \"$@\" >> scalingAction.log\n+}\n+\n+function print_usage() {\n+  echo \"Usage: scalingAction.sh --action=[scaleUp | scaleDown] --domain_uid=<domain uid> --cluster_name=<cluster name> [--kubernetes_master=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}] [--access_token=<access_token>] [--wls_domain_namespace=default] [--operator_namespace=weblogic-operator] [--operator_service_name=weblogic-operator] [--scaling_size=1]\"\n+  echo \"  where\"\n+  echo \"    action - scaleUp or scaleDown\"\n+  echo \"    domain_uid - WebLogic Domain Unique Identifier\"\n+  echo \"    cluster_name - WebLogic Cluster Name\"\n+  echo \"    kubernetes_master - Kubernetes master URL, default=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n+  echo \"    access_token - Service Account Bearer token for authentication and authorization for access to REST Resources\"\n+  echo \"    wls_domain_namespace - Kubernetes name space WebLogic Domain is defined in, default=default\"\n+  echo \"    operator_service_name - WebLogic Operator Service name, default=internal-weblogic-operator-svc\"\n+  echo \"    operator_service_account - Kubernetes Service Account for WebLogic Operator, default=weblogic-operator\"\n+  echo \"    operator_namespace - WebLogic Operator Namespace, default=weblogic-operator\"\n+  echo \"    scaling_size - number of WebLogic server instances by which to scale up or down, default=1\"\n+  exit 1\n+}\n+\n+# Retrieve WebLogic Operator Service Account Token for Authorization\n+function initialize_access_token() {\n+  if [ -z \"$access_token\" ]\n+  then\n+    access_token=`cat /var/run/secrets/kubernetes.io/serviceaccount/token`\n+  fi\n+}\n+\n+function logScalingParameters() {\n+  trace \"scaling_action: $scaling_action\"\n+  trace \"wls_domain_uid: $wls_domain_uid\"\n+  trace \"wls_cluster_name: $wls_cluster_name\"\n+  trace \"wls_domain_namespace: $wls_domain_namespace\"\n+  trace \"operator_service_name: $operator_service_name\"\n+  trace \"operator_service_account: $operator_service_account\"\n+  trace \"operator_namespace: $operator_namespace\"\n+  trace \"scaling_size: $scaling_size\"\n+}\n+\n+# Query WebLogic Operator Service Port\n+function get_operator_internal_rest_port() {\n+  local STATUS=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    -X GET $kubernetes_master/api/v1/namespaces/$operator_namespace/services/$operator_service_name/status)\n+  if [ $? -ne 0 ]\n+  then\n+    trace \"Failed to retrieve status of $operator_service_name in name space: $operator_namespace\"\n+    trace \"STATUS: $STATUS\"\n+    exit 1\n+  fi\n+\n+  local port\n+  if [ -x \"$(command -v jq)\" ]; then\n+    local extractPortCmd=\"(.spec.ports[] | select (.name == \\\"rest\\\") | .port)\"\n+    port=$(echo \"${STATUS}\" | jq \"${extractPortCmd}\")\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"spec\"][\"ports\"]:\n+  if i[\"name\"] == \"rest\":\n+    print(i[\"port\"])\n+INPUT\n+port=$(echo \"${STATUS}\" | python cmds-$$.py)\n+  fi\n+  echo \"$port\"\n+}\n+\n+# Retrieve the api version of the deployed Custom Resource Domain\n+function get_domain_api_version() {\n+  # Retrieve Custom Resource Definition for WebLogic domain\n+  local CRD=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    -X GET \\\n+    $kubernetes_master/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/domains.weblogic.oracle)\n+  if [ $? -ne 0 ]\n+    then\n+      trace \"Failed to retrieve Custom Resource Definition for WebLogic domain\"\n+      trace \"CRD: $CRD\"\n+      exit 1\n+  fi\n+\n+# Find domain version\n+  local domain_api_version\n+  if [ -x \"$(command -v jq)\" ]; then\n+    domain_api_version=$(echo \"${CRD}\" | jq -r '.spec.version')\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+print(json.load(sys.stdin)[\"spec\"][\"version\"])\n+INPUT\n+domain_api_version=`echo ${CRD} | python cmds-$$.py`\n+  fi\n+  echo \"$domain_api_version\"\n+}\n+\n+# Retrieve Custom Resource Domain\n+function get_custom_resource_domain() {\n+  local DOMAIN=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    $kubernetes_master/apis/weblogic.oracle/$domain_api_version/namespaces/$wls_domain_namespace/domains/$domain_uid)\n+  if [ $? -ne 0 ]; then\n+    trace \"Failed to retrieve WebLogic Domain Custom Resource Definition\"\n+    exit 1\n+  fi\n+  echo \"$DOMAIN\"\n+}\n+\n+# Verify if cluster is defined in clusters of the Custom Resource Domain\n+# args:\n+# $1 Custom Resource Domain\n+function is_defined_in_clusters() {\n+  local DOMAIN=\"$1\"\n+  local in_cluster_startup=\"False\"\n+  if [ -x \"$(command -v jq)\" ]; then\n+    local inClusterStartupCmd=\"(.items[].spec.clusters[] | select (.clusterName == \\\"${wls_cluster_name}\\\"))\"\n+    local clusterDefinedInCRD=$(echo \"${DOMAIN}\" | jq \"${inClusterStartupCmd}\")\n+    if [ \"${clusterDefinedInCRD}\" != \"\" ]; then\n+      in_cluster_startup=\"True\"\n+    fi\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+outer_loop_must_break = False\n+for i in json.load(sys.stdin)[\"items\"]:\n+  j = i[\"spec\"][\"clusters\"]\n+  for index, cs in enumerate(j):\n+    if j[index][\"clusterName\"] == \"$wls_cluster_name\":\n+      outer_loop_must_break = True\n+      print True\n+      break\n+if outer_loop_must_break == False:\n+  print False\n+INPUT\n+in_cluster_startup=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+  echo \"$in_cluster_startup\"\n+}\n+\n+# Gets the current replica count of the cluster\n+function get_num_ms_in_cluster() {\n+  local num_ms\n+  if [ -x \"$(command -v jq)\" ]; then\n+  local numManagedServersCmd=\"(.items[].spec.clusters[] | select (.clusterName == \\\"${wls_cluster_name}\\\") | .replicas)\"\n+  num_ms=$(echo \"${DOMAIN}\" | jq \"${numManagedServersCmd}\")\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"items\"]:\n+  j = i[\"spec\"][\"clusters\"]\n+  for index, cs in enumerate(j):\n+    if j[index][\"clusterName\"] == \"$wls_cluster_name\":\n+      print j[index][\"replicas\"]\n+INPUT\n+  num_ms=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+\n+  if [ \"${num_ms}\" == \"null\" ]; then\n+    num_ms=0\n+  fi\n+\n+  echo \"$num_ms\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d40004a546499d121a20d8ec63b2e6141e5ccbea"}, "originalPosition": 197}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0OTI5MzE4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#pullrequestreview-554929318", "createdAt": "2020-12-17T19:40:50Z", "commit": {"oid": "d40004a546499d121a20d8ec63b2e6141e5ccbea"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxOTo0MDo1MVrOIIFzng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxOTo0MDo1MVrOIIFzng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1NDY1NA==", "bodyText": "This should return 'min_replica_count' if min_replica_ count is higher than the discovered value.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545354654", "createdAt": "2020-12-17T19:40:51Z", "author": {"login": "tbarnes-us"}, "path": "src/scripts/scaling/scalingAction.sh", "diffHunk": "@@ -16,10 +14,328 @@ scaling_size=1\n access_token=\"\"\n kubernetes_master=\"https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n \n+# timestamp\n+#   purpose:  echo timestamp in the form yyyymmddThh:mm:ss.mmm ZZZ\n+#   example:  20181001T14:00:00.001 UTC\n+function timestamp() {\n+  local timestamp=\"`date --utc '+%Y-%m-%dT%H:%M:%S %N %s %Z' 2>&1`\"\n+  if [ ! \"${timestamp/illegal/xyz}\" = \"${timestamp}\" ]; then\n+    # old shell versions don't support %N or --utc\n+    timestamp=\"`date -u '+%Y-%m-%dT%H:%M:%S 000000 %s %Z' 2>&1`\"\n+  fi\n+  local ymdhms=\"`echo $timestamp | awk '{ print $1 }'`\"\n+  # convert nano to milli\n+  local milli=\"`echo $timestamp | awk '{ print $2 }' | sed 's/\\(^...\\).*/\\1/'`\"\n+  local secs_since_epoch=\"`echo $timestamp | awk '{ print $3 }'`\"\n+  local millis_since_opoch=\"${secs_since_epoch}${milli}\"\n+  local timezone=\"`echo $timestamp | awk '{ print $4 }'`\"\n+  echo \"${ymdhms}.${milli} ${timezone}\"\n+}\n+\n+function trace() {\n+  echo \"@[$(timestamp)][$wls_domain_namespace][$wls_domain_uid][$wls_cluster_name][INFO]\" \"$@\" >> scalingAction.log\n+}\n+\n+function print_usage() {\n+  echo \"Usage: scalingAction.sh --action=[scaleUp | scaleDown] --domain_uid=<domain uid> --cluster_name=<cluster name> [--kubernetes_master=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}] [--access_token=<access_token>] [--wls_domain_namespace=default] [--operator_namespace=weblogic-operator] [--operator_service_name=weblogic-operator] [--scaling_size=1]\"\n+  echo \"  where\"\n+  echo \"    action - scaleUp or scaleDown\"\n+  echo \"    domain_uid - WebLogic Domain Unique Identifier\"\n+  echo \"    cluster_name - WebLogic Cluster Name\"\n+  echo \"    kubernetes_master - Kubernetes master URL, default=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n+  echo \"    access_token - Service Account Bearer token for authentication and authorization for access to REST Resources\"\n+  echo \"    wls_domain_namespace - Kubernetes name space WebLogic Domain is defined in, default=default\"\n+  echo \"    operator_service_name - WebLogic Operator Service name, default=internal-weblogic-operator-svc\"\n+  echo \"    operator_service_account - Kubernetes Service Account for WebLogic Operator, default=weblogic-operator\"\n+  echo \"    operator_namespace - WebLogic Operator Namespace, default=weblogic-operator\"\n+  echo \"    scaling_size - number of WebLogic server instances by which to scale up or down, default=1\"\n+  exit 1\n+}\n+\n+# Retrieve WebLogic Operator Service Account Token for Authorization\n+function initialize_access_token() {\n+  if [ -z \"$access_token\" ]\n+  then\n+    access_token=`cat /var/run/secrets/kubernetes.io/serviceaccount/token`\n+  fi\n+}\n+\n+function logScalingParameters() {\n+  trace \"scaling_action: $scaling_action\"\n+  trace \"wls_domain_uid: $wls_domain_uid\"\n+  trace \"wls_cluster_name: $wls_cluster_name\"\n+  trace \"wls_domain_namespace: $wls_domain_namespace\"\n+  trace \"operator_service_name: $operator_service_name\"\n+  trace \"operator_service_account: $operator_service_account\"\n+  trace \"operator_namespace: $operator_namespace\"\n+  trace \"scaling_size: $scaling_size\"\n+}\n+\n+# Query WebLogic Operator Service Port\n+function get_operator_internal_rest_port() {\n+  local STATUS=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    -X GET $kubernetes_master/api/v1/namespaces/$operator_namespace/services/$operator_service_name/status)\n+  if [ $? -ne 0 ]\n+  then\n+    trace \"Failed to retrieve status of $operator_service_name in name space: $operator_namespace\"\n+    trace \"STATUS: $STATUS\"\n+    exit 1\n+  fi\n+\n+  local port\n+  if [ -x \"$(command -v jq)\" ]; then\n+    local extractPortCmd=\"(.spec.ports[] | select (.name == \\\"rest\\\") | .port)\"\n+    port=$(echo \"${STATUS}\" | jq \"${extractPortCmd}\")\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"spec\"][\"ports\"]:\n+  if i[\"name\"] == \"rest\":\n+    print(i[\"port\"])\n+INPUT\n+port=$(echo \"${STATUS}\" | python cmds-$$.py)\n+  fi\n+  echo \"$port\"\n+}\n+\n+# Retrieve the api version of the deployed Custom Resource Domain\n+function get_domain_api_version() {\n+  # Retrieve Custom Resource Definition for WebLogic domain\n+  local CRD=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    -X GET \\\n+    $kubernetes_master/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/domains.weblogic.oracle)\n+  if [ $? -ne 0 ]\n+    then\n+      trace \"Failed to retrieve Custom Resource Definition for WebLogic domain\"\n+      trace \"CRD: $CRD\"\n+      exit 1\n+  fi\n+\n+# Find domain version\n+  local domain_api_version\n+  if [ -x \"$(command -v jq)\" ]; then\n+    domain_api_version=$(echo \"${CRD}\" | jq -r '.spec.version')\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+print(json.load(sys.stdin)[\"spec\"][\"version\"])\n+INPUT\n+domain_api_version=`echo ${CRD} | python cmds-$$.py`\n+  fi\n+  echo \"$domain_api_version\"\n+}\n+\n+# Retrieve Custom Resource Domain\n+function get_custom_resource_domain() {\n+  local DOMAIN=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    $kubernetes_master/apis/weblogic.oracle/$domain_api_version/namespaces/$wls_domain_namespace/domains/$domain_uid)\n+  if [ $? -ne 0 ]; then\n+    trace \"Failed to retrieve WebLogic Domain Custom Resource Definition\"\n+    exit 1\n+  fi\n+  echo \"$DOMAIN\"\n+}\n+\n+# Verify if cluster is defined in clusters of the Custom Resource Domain\n+# args:\n+# $1 Custom Resource Domain\n+function is_defined_in_clusters() {\n+  local DOMAIN=\"$1\"\n+  local in_cluster_startup=\"False\"\n+  if [ -x \"$(command -v jq)\" ]; then\n+    local inClusterStartupCmd=\"(.items[].spec.clusters[] | select (.clusterName == \\\"${wls_cluster_name}\\\"))\"\n+    local clusterDefinedInCRD=$(echo \"${DOMAIN}\" | jq \"${inClusterStartupCmd}\")\n+    if [ \"${clusterDefinedInCRD}\" != \"\" ]; then\n+      in_cluster_startup=\"True\"\n+    fi\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+outer_loop_must_break = False\n+for i in json.load(sys.stdin)[\"items\"]:\n+  j = i[\"spec\"][\"clusters\"]\n+  for index, cs in enumerate(j):\n+    if j[index][\"clusterName\"] == \"$wls_cluster_name\":\n+      outer_loop_must_break = True\n+      print True\n+      break\n+if outer_loop_must_break == False:\n+  print False\n+INPUT\n+in_cluster_startup=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+  echo \"$in_cluster_startup\"\n+}\n+\n+# Gets the current replica count of the cluster\n+function get_num_ms_in_cluster() {\n+  local num_ms\n+  if [ -x \"$(command -v jq)\" ]; then\n+  local numManagedServersCmd=\"(.items[].spec.clusters[] | select (.clusterName == \\\"${wls_cluster_name}\\\") | .replicas)\"\n+  num_ms=$(echo \"${DOMAIN}\" | jq \"${numManagedServersCmd}\")\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"items\"]:\n+  j = i[\"spec\"][\"clusters\"]\n+  for index, cs in enumerate(j):\n+    if j[index][\"clusterName\"] == \"$wls_cluster_name\":\n+      print j[index][\"replicas\"]\n+INPUT\n+  num_ms=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+\n+  if [ \"${num_ms}\" == \"null\" ]; then\n+    num_ms=0\n+  fi\n+\n+  echo \"$num_ms\"\n+}\n+\n+# Gets the replica count at the Domain level\n+function get_num_ms_domain_scope() {\n+  local num_ms\n+  if [ -x \"$(command -v jq)\" ]; then\n+    num_ms=$(echo \"${DOMAIN}\" | jq -r '.items[].spec.replicas' )\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"items\"]:\n+  print i[\"spec\"][\"replicas\"]\n+INPUT\n+  num_ms=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+\n+  if [ \"${num_ms}\" == \"null\" ]; then\n+    num_ms=0\n+  fi\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d40004a546499d121a20d8ec63b2e6141e5ccbea"}, "originalPosition": 217}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0OTI5OTg0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#pullrequestreview-554929984", "createdAt": "2020-12-17T19:41:51Z", "commit": {"oid": "d40004a546499d121a20d8ec63b2e6141e5ccbea"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxOTo0MTo1MVrOIIF18A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxOTo0MTo1MVrOIIF18A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1NTI0OA==", "bodyText": "This should return min_replica_count if discovered value is less than the min", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545355248", "createdAt": "2020-12-17T19:41:51Z", "author": {"login": "tbarnes-us"}, "path": "src/scripts/scaling/scalingAction.sh", "diffHunk": "@@ -16,10 +14,328 @@ scaling_size=1\n access_token=\"\"\n kubernetes_master=\"https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n \n+# timestamp\n+#   purpose:  echo timestamp in the form yyyymmddThh:mm:ss.mmm ZZZ\n+#   example:  20181001T14:00:00.001 UTC\n+function timestamp() {\n+  local timestamp=\"`date --utc '+%Y-%m-%dT%H:%M:%S %N %s %Z' 2>&1`\"\n+  if [ ! \"${timestamp/illegal/xyz}\" = \"${timestamp}\" ]; then\n+    # old shell versions don't support %N or --utc\n+    timestamp=\"`date -u '+%Y-%m-%dT%H:%M:%S 000000 %s %Z' 2>&1`\"\n+  fi\n+  local ymdhms=\"`echo $timestamp | awk '{ print $1 }'`\"\n+  # convert nano to milli\n+  local milli=\"`echo $timestamp | awk '{ print $2 }' | sed 's/\\(^...\\).*/\\1/'`\"\n+  local secs_since_epoch=\"`echo $timestamp | awk '{ print $3 }'`\"\n+  local millis_since_opoch=\"${secs_since_epoch}${milli}\"\n+  local timezone=\"`echo $timestamp | awk '{ print $4 }'`\"\n+  echo \"${ymdhms}.${milli} ${timezone}\"\n+}\n+\n+function trace() {\n+  echo \"@[$(timestamp)][$wls_domain_namespace][$wls_domain_uid][$wls_cluster_name][INFO]\" \"$@\" >> scalingAction.log\n+}\n+\n+function print_usage() {\n+  echo \"Usage: scalingAction.sh --action=[scaleUp | scaleDown] --domain_uid=<domain uid> --cluster_name=<cluster name> [--kubernetes_master=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}] [--access_token=<access_token>] [--wls_domain_namespace=default] [--operator_namespace=weblogic-operator] [--operator_service_name=weblogic-operator] [--scaling_size=1]\"\n+  echo \"  where\"\n+  echo \"    action - scaleUp or scaleDown\"\n+  echo \"    domain_uid - WebLogic Domain Unique Identifier\"\n+  echo \"    cluster_name - WebLogic Cluster Name\"\n+  echo \"    kubernetes_master - Kubernetes master URL, default=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n+  echo \"    access_token - Service Account Bearer token for authentication and authorization for access to REST Resources\"\n+  echo \"    wls_domain_namespace - Kubernetes name space WebLogic Domain is defined in, default=default\"\n+  echo \"    operator_service_name - WebLogic Operator Service name, default=internal-weblogic-operator-svc\"\n+  echo \"    operator_service_account - Kubernetes Service Account for WebLogic Operator, default=weblogic-operator\"\n+  echo \"    operator_namespace - WebLogic Operator Namespace, default=weblogic-operator\"\n+  echo \"    scaling_size - number of WebLogic server instances by which to scale up or down, default=1\"\n+  exit 1\n+}\n+\n+# Retrieve WebLogic Operator Service Account Token for Authorization\n+function initialize_access_token() {\n+  if [ -z \"$access_token\" ]\n+  then\n+    access_token=`cat /var/run/secrets/kubernetes.io/serviceaccount/token`\n+  fi\n+}\n+\n+function logScalingParameters() {\n+  trace \"scaling_action: $scaling_action\"\n+  trace \"wls_domain_uid: $wls_domain_uid\"\n+  trace \"wls_cluster_name: $wls_cluster_name\"\n+  trace \"wls_domain_namespace: $wls_domain_namespace\"\n+  trace \"operator_service_name: $operator_service_name\"\n+  trace \"operator_service_account: $operator_service_account\"\n+  trace \"operator_namespace: $operator_namespace\"\n+  trace \"scaling_size: $scaling_size\"\n+}\n+\n+# Query WebLogic Operator Service Port\n+function get_operator_internal_rest_port() {\n+  local STATUS=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    -X GET $kubernetes_master/api/v1/namespaces/$operator_namespace/services/$operator_service_name/status)\n+  if [ $? -ne 0 ]\n+  then\n+    trace \"Failed to retrieve status of $operator_service_name in name space: $operator_namespace\"\n+    trace \"STATUS: $STATUS\"\n+    exit 1\n+  fi\n+\n+  local port\n+  if [ -x \"$(command -v jq)\" ]; then\n+    local extractPortCmd=\"(.spec.ports[] | select (.name == \\\"rest\\\") | .port)\"\n+    port=$(echo \"${STATUS}\" | jq \"${extractPortCmd}\")\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"spec\"][\"ports\"]:\n+  if i[\"name\"] == \"rest\":\n+    print(i[\"port\"])\n+INPUT\n+port=$(echo \"${STATUS}\" | python cmds-$$.py)\n+  fi\n+  echo \"$port\"\n+}\n+\n+# Retrieve the api version of the deployed Custom Resource Domain\n+function get_domain_api_version() {\n+  # Retrieve Custom Resource Definition for WebLogic domain\n+  local CRD=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    -X GET \\\n+    $kubernetes_master/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/domains.weblogic.oracle)\n+  if [ $? -ne 0 ]\n+    then\n+      trace \"Failed to retrieve Custom Resource Definition for WebLogic domain\"\n+      trace \"CRD: $CRD\"\n+      exit 1\n+  fi\n+\n+# Find domain version\n+  local domain_api_version\n+  if [ -x \"$(command -v jq)\" ]; then\n+    domain_api_version=$(echo \"${CRD}\" | jq -r '.spec.version')\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+print(json.load(sys.stdin)[\"spec\"][\"version\"])\n+INPUT\n+domain_api_version=`echo ${CRD} | python cmds-$$.py`\n+  fi\n+  echo \"$domain_api_version\"\n+}\n+\n+# Retrieve Custom Resource Domain\n+function get_custom_resource_domain() {\n+  local DOMAIN=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    $kubernetes_master/apis/weblogic.oracle/$domain_api_version/namespaces/$wls_domain_namespace/domains/$domain_uid)\n+  if [ $? -ne 0 ]; then\n+    trace \"Failed to retrieve WebLogic Domain Custom Resource Definition\"\n+    exit 1\n+  fi\n+  echo \"$DOMAIN\"\n+}\n+\n+# Verify if cluster is defined in clusters of the Custom Resource Domain\n+# args:\n+# $1 Custom Resource Domain\n+function is_defined_in_clusters() {\n+  local DOMAIN=\"$1\"\n+  local in_cluster_startup=\"False\"\n+  if [ -x \"$(command -v jq)\" ]; then\n+    local inClusterStartupCmd=\"(.items[].spec.clusters[] | select (.clusterName == \\\"${wls_cluster_name}\\\"))\"\n+    local clusterDefinedInCRD=$(echo \"${DOMAIN}\" | jq \"${inClusterStartupCmd}\")\n+    if [ \"${clusterDefinedInCRD}\" != \"\" ]; then\n+      in_cluster_startup=\"True\"\n+    fi\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+outer_loop_must_break = False\n+for i in json.load(sys.stdin)[\"items\"]:\n+  j = i[\"spec\"][\"clusters\"]\n+  for index, cs in enumerate(j):\n+    if j[index][\"clusterName\"] == \"$wls_cluster_name\":\n+      outer_loop_must_break = True\n+      print True\n+      break\n+if outer_loop_must_break == False:\n+  print False\n+INPUT\n+in_cluster_startup=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+  echo \"$in_cluster_startup\"\n+}\n+\n+# Gets the current replica count of the cluster\n+function get_num_ms_in_cluster() {\n+  local num_ms\n+  if [ -x \"$(command -v jq)\" ]; then\n+  local numManagedServersCmd=\"(.items[].spec.clusters[] | select (.clusterName == \\\"${wls_cluster_name}\\\") | .replicas)\"\n+  num_ms=$(echo \"${DOMAIN}\" | jq \"${numManagedServersCmd}\")\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"items\"]:\n+  j = i[\"spec\"][\"clusters\"]\n+  for index, cs in enumerate(j):\n+    if j[index][\"clusterName\"] == \"$wls_cluster_name\":\n+      print j[index][\"replicas\"]\n+INPUT\n+  num_ms=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+\n+  if [ \"${num_ms}\" == \"null\" ]; then\n+    num_ms=0\n+  fi\n+\n+  echo \"$num_ms\"\n+}\n+\n+# Gets the replica count at the Domain level\n+function get_num_ms_domain_scope() {\n+  local num_ms\n+  if [ -x \"$(command -v jq)\" ]; then\n+    num_ms=$(echo \"${DOMAIN}\" | jq -r '.items[].spec.replicas' )\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"items\"]:\n+  print i[\"spec\"][\"replicas\"]\n+INPUT\n+  num_ms=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+\n+  if [ \"${num_ms}\" == \"null\" ]; then\n+    num_ms=0\n+  fi\n+\n+  echo \"$num_ms\"\n+}\n+\n+#\n+# Function to get minimum replica count for cluster\n+# $1 - Domain resource in json format\n+# $2 - Name of the cluster\n+# $3 - Return value containing minimum replica count\n+#\n+function get_min_replicas {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __result=$3\n+\n+  eval $__result=0\n+  minReplicaCmd=\"(.status.clusters[] | select (.clusterName == \\\"${clusterName}\\\")) \\\n+    | .minimumReplicas\"\n+  minReplicas=$(echo ${domainJson} | jq \"${minReplicaCmd}\")\n+  eval $__result=${minReplicas}\n+}\n+\n+# Get the current replica count for the WLS cluster if defined in the CRD's Cluster\n+# configuration.  If WLS cluster is not defined in the CRD then return the Domain\n+# scoped replica value, if present.  Returns replica count = 0 if no replica count found.\n+# args:\n+# $1 \"True\" if WLS cluster configuration defined in CRD, \"False\" otherwise\n+# $2 Custom Resource Domain\n+function get_replica_count() {\n+  local in_cluster_startup=\"$1\"\n+  local DOMAIN=\"$2\"\n+  local num_ms\n+  if [ \"$in_cluster_startup\" == \"True\" ]\n+  then\n+    trace \"$wls_cluster_name defined in clusters\"\n+    num_ms=$(get_num_ms_in_cluster \"$DOMAIN\")\n+  else\n+    trace \"$wls_cluster_name NOT defined in clusters\"\n+    num_ms=$(get_num_ms_domain_scope \"$DOMAIN\")\n+  fi\n+  echo \"$num_ms\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d40004a546499d121a20d8ec63b2e6141e5ccbea"}, "originalPosition": 257}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0OTM2MjQ4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#pullrequestreview-554936248", "createdAt": "2020-12-17T19:50:39Z", "commit": {"oid": "d40004a546499d121a20d8ec63b2e6141e5ccbea"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxOTo1MDozOVrOIIGK7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxOTo1MDozOVrOIIGK7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2MDYyMQ==", "bodyText": "Minor:  It looks like secs_since_epoch & millis_since_epoch are unused - leftover from an older iteration of the function.  They can be removed from here and from the same function in 'utils.sh'.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545360621", "createdAt": "2020-12-17T19:50:39Z", "author": {"login": "tbarnes-us"}, "path": "src/scripts/scaling/scalingAction.sh", "diffHunk": "@@ -16,10 +14,328 @@ scaling_size=1\n access_token=\"\"\n kubernetes_master=\"https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n \n+# timestamp\n+#   purpose:  echo timestamp in the form yyyymmddThh:mm:ss.mmm ZZZ\n+#   example:  20181001T14:00:00.001 UTC\n+function timestamp() {\n+  local timestamp=\"`date --utc '+%Y-%m-%dT%H:%M:%S %N %s %Z' 2>&1`\"\n+  if [ ! \"${timestamp/illegal/xyz}\" = \"${timestamp}\" ]; then\n+    # old shell versions don't support %N or --utc\n+    timestamp=\"`date -u '+%Y-%m-%dT%H:%M:%S 000000 %s %Z' 2>&1`\"\n+  fi\n+  local ymdhms=\"`echo $timestamp | awk '{ print $1 }'`\"\n+  # convert nano to milli\n+  local milli=\"`echo $timestamp | awk '{ print $2 }' | sed 's/\\(^...\\).*/\\1/'`\"\n+  local secs_since_epoch=\"`echo $timestamp | awk '{ print $3 }'`\"\n+  local millis_since_opoch=\"${secs_since_epoch}${milli}\"\n+  local timezone=\"`echo $timestamp | awk '{ print $4 }'`\"\n+  echo \"${ymdhms}.${milli} ${timezone}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d40004a546499d121a20d8ec63b2e6141e5ccbea"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2102331990e95f6fa101a7ca30edc6d1e4f18035", "author": {"user": {"login": "lennyphan", "name": "Lenny Phan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/2102331990e95f6fa101a7ca30edc6d1e4f18035", "committedDate": "2020-12-17T20:59:28Z", "message": "return min replica count if greater than discovered value"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1572fe0b73b1be107d53dd44544692c7f492e6e2", "author": {"user": {"login": "lennyphan", "name": "Lenny Phan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/1572fe0b73b1be107d53dd44544692c7f492e6e2", "committedDate": "2020-12-17T21:07:46Z", "message": "remove unused vars from timestamp function"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MDA0NDM2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#pullrequestreview-555004436", "createdAt": "2020-12-17T21:32:28Z", "commit": {"oid": "1572fe0b73b1be107d53dd44544692c7f492e6e2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4000, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}