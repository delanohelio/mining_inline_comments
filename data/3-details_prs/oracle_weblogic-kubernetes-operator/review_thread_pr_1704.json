{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3MzM3ODc2", "number": 1704, "reviewThreads": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxODo0MTo1OVrOECRs2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNjoxMTo0NlrOEDheDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwODIyNjE5OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxODo0MTo1OVrOGeou_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjo1NzoxNVrOGf2JBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc3Nzg1NQ==", "bodyText": "an unnecessary line break", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r434777855", "createdAt": "2020-06-03T18:41:59Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -580,6 +589,48 @@ public static boolean buildAppArchive(AppParams params) {\n             .build();\n   }\n \n+  /**\n+   * Archive an application from provided ear or war file that can be used by WebLogic Image Tool\n+   * to create an image with the application for a model-in-image use case.\n+   *\n+   * @param srcFile full path to ear or war application file to archive\n+   * @return true if the operation succeeds\n+   */\n+  public static boolean archiveApp(\n+      String srcFile) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NjA4Nw==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436046087", "createdAt": "2020-06-05T16:57:15Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -580,6 +589,48 @@ public static boolean buildAppArchive(AppParams params) {\n             .build();\n   }\n \n+  /**\n+   * Archive an application from provided ear or war file that can be used by WebLogic Image Tool\n+   * to create an image with the application for a model-in-image use case.\n+   *\n+   * @param srcFile full path to ear or war application file to archive\n+   * @return true if the operation succeeds\n+   */\n+  public static boolean archiveApp(\n+      String srcFile) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc3Nzg1NQ=="}, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwODIzNDU2OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxODo0NDo0NVrOGeo0zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjo1NzowNVrOGf2IpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc3OTM0Mg==", "bodyText": "add a import for java.nio.file.Files and java.nio.file.Paths", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r434779342", "createdAt": "2020-06-03T18:44:45Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -580,6 +589,48 @@ public static boolean buildAppArchive(AppParams params) {\n             .build();\n   }\n \n+  /**\n+   * Archive an application from provided ear or war file that can be used by WebLogic Image Tool\n+   * to create an image with the application for a model-in-image use case.\n+   *\n+   * @param srcFile full path to ear or war application file to archive\n+   * @return true if the operation succeeds\n+   */\n+  public static boolean archiveApp(\n+      String srcFile) {\n+\n+    String appName = srcFile.substring(srcFile.lastIndexOf(\"/\") + 1, srcFile.lastIndexOf(\".\"));\n+    String fileExtension = srcFile.substring(srcFile.lastIndexOf(\".\") + 1, srcFile.length());\n+    try {\n+      String appDir = ARCHIVE_DIR + \"/wlsdeploy/applications\";\n+      cleanupDirectory(appDir);\n+      checkDirectory(appDir);\n+      logger.info(\"copy {0]} to {1} \", srcFile, appDir);\n+      java.nio.file.Files.copy(java.nio.file.Paths.get(srcFile), java.nio.file.Paths.get(appDir,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NTk4OQ==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436045989", "createdAt": "2020-06-05T16:57:05Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -580,6 +589,48 @@ public static boolean buildAppArchive(AppParams params) {\n             .build();\n   }\n \n+  /**\n+   * Archive an application from provided ear or war file that can be used by WebLogic Image Tool\n+   * to create an image with the application for a model-in-image use case.\n+   *\n+   * @param srcFile full path to ear or war application file to archive\n+   * @return true if the operation succeeds\n+   */\n+  public static boolean archiveApp(\n+      String srcFile) {\n+\n+    String appName = srcFile.substring(srcFile.lastIndexOf(\"/\") + 1, srcFile.lastIndexOf(\".\"));\n+    String fileExtension = srcFile.substring(srcFile.lastIndexOf(\".\") + 1, srcFile.length());\n+    try {\n+      String appDir = ARCHIVE_DIR + \"/wlsdeploy/applications\";\n+      cleanupDirectory(appDir);\n+      checkDirectory(appDir);\n+      logger.info(\"copy {0]} to {1} \", srcFile, appDir);\n+      java.nio.file.Files.copy(java.nio.file.Paths.get(srcFile), java.nio.file.Paths.get(appDir,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc3OTM0Mg=="}, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwODIzOTc2OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxODo0NjoxMlrOGeo4Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjo1Njo1OVrOGf2IbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MDE3MA==", "bodyText": "same as above comment.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r434780170", "createdAt": "2020-06-03T18:46:12Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -580,6 +589,48 @@ public static boolean buildAppArchive(AppParams params) {\n             .build();\n   }\n \n+  /**\n+   * Archive an application from provided ear or war file that can be used by WebLogic Image Tool\n+   * to create an image with the application for a model-in-image use case.\n+   *\n+   * @param srcFile full path to ear or war application file to archive\n+   * @return true if the operation succeeds\n+   */\n+  public static boolean archiveApp(\n+      String srcFile) {\n+\n+    String appName = srcFile.substring(srcFile.lastIndexOf(\"/\") + 1, srcFile.lastIndexOf(\".\"));\n+    String fileExtension = srcFile.substring(srcFile.lastIndexOf(\".\") + 1, srcFile.length());\n+    try {\n+      String appDir = ARCHIVE_DIR + \"/wlsdeploy/applications\";\n+      cleanupDirectory(appDir);\n+      checkDirectory(appDir);\n+      logger.info(\"copy {0]} to {1} \", srcFile, appDir);\n+      java.nio.file.Files.copy(java.nio.file.Paths.get(srcFile), java.nio.file.Paths.get(appDir,\n+          appName + \".\"\n+              + fileExtension),\n+          java.nio.file.StandardCopyOption.REPLACE_EXISTING);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NTkzMg==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436045932", "createdAt": "2020-06-05T16:56:59Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -580,6 +589,48 @@ public static boolean buildAppArchive(AppParams params) {\n             .build();\n   }\n \n+  /**\n+   * Archive an application from provided ear or war file that can be used by WebLogic Image Tool\n+   * to create an image with the application for a model-in-image use case.\n+   *\n+   * @param srcFile full path to ear or war application file to archive\n+   * @return true if the operation succeeds\n+   */\n+  public static boolean archiveApp(\n+      String srcFile) {\n+\n+    String appName = srcFile.substring(srcFile.lastIndexOf(\"/\") + 1, srcFile.lastIndexOf(\".\"));\n+    String fileExtension = srcFile.substring(srcFile.lastIndexOf(\".\") + 1, srcFile.length());\n+    try {\n+      String appDir = ARCHIVE_DIR + \"/wlsdeploy/applications\";\n+      cleanupDirectory(appDir);\n+      checkDirectory(appDir);\n+      logger.info(\"copy {0]} to {1} \", srcFile, appDir);\n+      java.nio.file.Files.copy(java.nio.file.Paths.get(srcFile), java.nio.file.Paths.get(appDir,\n+          appName + \".\"\n+              + fileExtension),\n+          java.nio.file.StandardCopyOption.REPLACE_EXISTING);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MDE3MA=="}, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwODI0NDI1OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxODo0NzozN1rOGeo6-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjo1Njo0NVrOGf2H9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MDkyMA==", "bodyText": "remove unused imports", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r434780920", "createdAt": "2020-06-03T18:47:37Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NTgxMw==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436045813", "createdAt": "2020-06-05T16:56:45Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MDkyMA=="}, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwODI1Mzk2OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxODo1MDozNVrOGepBWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjo1NjozNlrOGf2Hog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MjU1Mg==", "bodyText": "Missing javadoc", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r434782552", "createdAt": "2020-06-03T18:50:35Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify WebLogic Metric is processed as expected by MonitoringExporter via Prometheus and Grafana\")\n+@IntegrationTest\n+class ItMonitoringExporter implements LoggedTest {\n+\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int replicaCount = 2;\n+\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain1Uid = \"monexp-domain1\";\n+  private static String domain2Uid = \"monexp-domain2\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static List<String> ingressHostList = null;\n+\n+  private String curlCmd = null;\n+  private static String monitoringNS = null;\n+  private static String webhookNS = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  HelmParams promHelmParams = null;\n+  HelmParams grafanaHelmParams = null;\n+  private static String monitoringExporterEndToEndDir = null;\n+  private static String monitoringExporterSrcDir = null;\n+  private static String monitoringExporterAppDir = null;\n+  private static V1Service webhookService = null;\n+  private static V1Deployment webhookDepl = null;\n+  private static V1Service coordinatorService = null;\n+  private static V1Deployment coordinatorDepl = null;\n+  // constants for creating domain image using model in image\n+  private static final String MONEXP_MODEL_FILE = \"model.monexp.yaml\";\n+  private static final String MONEXP_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String MONEXP_APP_NAME = \"monexp-app\";\n+  private static final String MONEXP_APP_WAR_NAME = \"monexp-war\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domain1Uid + \"-admin-server\";\n+  private static String managedServerPrefix = domain1Uid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int nodeportserver;\n+\n+  /**\n+   * Install operator and NGINX. Create model in image domain with multiple clusters.\n+   * Create ingress for the domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(6) List<String> namespaces) {\n+\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    final String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Get a unique namespace for WebLogic domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique monitoring namespace\n+    logger.info(\"Get a unique namespace for monitoring\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    monitoringNS = namespaces.get(3);\n+\n+    // get a unique webhook namespace\n+    logger.info(\"Get a unique namespace for webhook\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    webhookNS = namespaces.get(4);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    final String nginxNamespace = namespaces.get(5);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace,domain2Namespace);\n+\n+    //install monitoring exporter\n+    installMonitoringExporter();\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName, domain1Uid);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+    // create ingress for the domain\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domain1Uid, domain1Namespace);\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    ingressHostList =\n+        createIngressForDomainAndVerify(domain1Uid, domain1Namespace, clusterNameMsPortMap);\n+\n+  }\n+\n+  @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NTczMA==", "bodyText": "added", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436045730", "createdAt": "2020-06-05T16:56:36Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify WebLogic Metric is processed as expected by MonitoringExporter via Prometheus and Grafana\")\n+@IntegrationTest\n+class ItMonitoringExporter implements LoggedTest {\n+\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int replicaCount = 2;\n+\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain1Uid = \"monexp-domain1\";\n+  private static String domain2Uid = \"monexp-domain2\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static List<String> ingressHostList = null;\n+\n+  private String curlCmd = null;\n+  private static String monitoringNS = null;\n+  private static String webhookNS = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  HelmParams promHelmParams = null;\n+  HelmParams grafanaHelmParams = null;\n+  private static String monitoringExporterEndToEndDir = null;\n+  private static String monitoringExporterSrcDir = null;\n+  private static String monitoringExporterAppDir = null;\n+  private static V1Service webhookService = null;\n+  private static V1Deployment webhookDepl = null;\n+  private static V1Service coordinatorService = null;\n+  private static V1Deployment coordinatorDepl = null;\n+  // constants for creating domain image using model in image\n+  private static final String MONEXP_MODEL_FILE = \"model.monexp.yaml\";\n+  private static final String MONEXP_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String MONEXP_APP_NAME = \"monexp-app\";\n+  private static final String MONEXP_APP_WAR_NAME = \"monexp-war\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domain1Uid + \"-admin-server\";\n+  private static String managedServerPrefix = domain1Uid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int nodeportserver;\n+\n+  /**\n+   * Install operator and NGINX. Create model in image domain with multiple clusters.\n+   * Create ingress for the domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(6) List<String> namespaces) {\n+\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    final String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Get a unique namespace for WebLogic domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique monitoring namespace\n+    logger.info(\"Get a unique namespace for monitoring\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    monitoringNS = namespaces.get(3);\n+\n+    // get a unique webhook namespace\n+    logger.info(\"Get a unique namespace for webhook\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    webhookNS = namespaces.get(4);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    final String nginxNamespace = namespaces.get(5);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace,domain2Namespace);\n+\n+    //install monitoring exporter\n+    installMonitoringExporter();\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName, domain1Uid);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+    // create ingress for the domain\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domain1Uid, domain1Namespace);\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    ingressHostList =\n+        createIngressForDomainAndVerify(domain1Uid, domain1Namespace, clusterNameMsPortMap);\n+\n+  }\n+\n+  @Test", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MjU1Mg=="}, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 256}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwODI1NTY1OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxODo1MTowM1rOGepCaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjo1NjoyM1rOGf2HQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MjgyNA==", "bodyText": "is this needed?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r434782824", "createdAt": "2020-06-03T18:51:03Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NTYzMg==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436045632", "createdAt": "2020-06-05T16:56:23Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MjgyNA=="}, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwODI1OTA2OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxODo1MjowMlrOGepEhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjo1NjoxOFrOGf2HBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MzM2NA==", "bodyText": "Does this need any update?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r434783364", "createdAt": "2020-06-03T18:52:02Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NTU3Mw==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436045573", "createdAt": "2020-06-05T16:56:18Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MzM2NA=="}, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTY2OTkwOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNTowNToyN1rOGfKe6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjo1NjowOFrOGf2Gtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzMDc5NQ==", "bodyText": "This is stale. The PR has been merged.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r435330795", "createdAt": "2020-06-04T15:05:27Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify WebLogic Metric is processed as expected by MonitoringExporter via Prometheus and Grafana\")\n+@IntegrationTest\n+class ItMonitoringExporter implements LoggedTest {\n+\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int replicaCount = 2;\n+\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain1Uid = \"monexp-domain1\";\n+  private static String domain2Uid = \"monexp-domain2\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static List<String> ingressHostList = null;\n+\n+  private String curlCmd = null;\n+  private static String monitoringNS = null;\n+  private static String webhookNS = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  HelmParams promHelmParams = null;\n+  HelmParams grafanaHelmParams = null;\n+  private static String monitoringExporterEndToEndDir = null;\n+  private static String monitoringExporterSrcDir = null;\n+  private static String monitoringExporterAppDir = null;\n+  private static V1Service webhookService = null;\n+  private static V1Deployment webhookDepl = null;\n+  private static V1Service coordinatorService = null;\n+  private static V1Deployment coordinatorDepl = null;\n+  // constants for creating domain image using model in image\n+  private static final String MONEXP_MODEL_FILE = \"model.monexp.yaml\";\n+  private static final String MONEXP_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String MONEXP_APP_NAME = \"monexp-app\";\n+  private static final String MONEXP_APP_WAR_NAME = \"monexp-war\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domain1Uid + \"-admin-server\";\n+  private static String managedServerPrefix = domain1Uid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int nodeportserver;\n+\n+  /**\n+   * Install operator and NGINX. Create model in image domain with multiple clusters.\n+   * Create ingress for the domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(6) List<String> namespaces) {\n+\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    final String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Get a unique namespace for WebLogic domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique monitoring namespace\n+    logger.info(\"Get a unique namespace for monitoring\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    monitoringNS = namespaces.get(3);\n+\n+    // get a unique webhook namespace\n+    logger.info(\"Get a unique namespace for webhook\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    webhookNS = namespaces.get(4);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    final String nginxNamespace = namespaces.get(5);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace,domain2Namespace);\n+\n+    //install monitoring exporter\n+    installMonitoringExporter();\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName, domain1Uid);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+    // create ingress for the domain\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domain1Uid, domain1Namespace);\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    ingressHostList =\n+        createIngressForDomainAndVerify(domain1Uid, domain1Namespace, clusterNameMsPortMap);\n+\n+  }\n+\n+  @Test\n+  @DisplayName(\"Install Prometheus, Grafana , Webhook, Coordinator and verify WebLogic metrics\")\n+  public void testCheckMetrics() throws Exception {\n+\n+    createPvAndPvc(\"prometheus\");\n+    createPvAndPvc(\"alertmanager\");\n+    createPvAndPvc(\"grafana\");\n+\n+    logger.info(\"create a staging location for monitoring creation scripts\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"ItMonitoringExporter\", \"promCreateTempValueFile\");\n+    FileUtils.deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+\n+    logger.info(\"copy the promvalue.yaml to staging location\");\n+    Path srcPromFile = Paths.get(RESOURCE_DIR, \"exporter\", \"promvalues.yaml\");\n+    Path targetPromFile = Paths.get(fileTemp.toString(), \"promvalues.yaml\");\n+    Files.copy(srcPromFile, targetPromFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain1;cluster-1\",\n+        \"regex: \" + domain1Namespace\n+        + \";\"\n+        + domain1Uid\n+        + \";cluster-1\");\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain2;cluster-1\",\n+        \"regex: \" + domain2Namespace\n+            + \";\"\n+            + domain2Uid\n+            + \";cluster-1\");\n+    int nodeportalertmanserver = getNextFreePort(30400, 30600);\n+    nodeportserver = getNextFreePort(32400, 32600);\n+\n+    promHelmParams = installAndVerifyPrometheus(\"prometheus\",\n+         monitoringNS,\n+        targetPromFile.toString(),\n+         PROMETHEUS_CHART_VERSION,\n+         nodeportserver,\n+         nodeportalertmanserver);\n+    logger.info(\"Prometheus is running\");\n+\n+    int nodeportgrafana = getNextFreePort(31000, 31200);\n+    grafanaHelmParams = installAndVerifyGrafana(\"grafana\",\n+        monitoringNS,\n+        monitoringExporterEndToEndDir + \"/grafana/values.yaml\",\n+        GRAFANA_CHART_VERSION,\n+        nodeportgrafana);\n+    logger.info(\"Grafana is running\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterEndToEndDir + \"/webhook\",\n+        \"webhook\",\n+        webhookNS,\n+        \"app=webhook\", REPO_SECRET_NAME), \"Failed to start webhook\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterSrcDir + \"/config_coordinator\",\n+        \"coordinator\",\n+        domain1Namespace,\n+        \"app=coordinator\", \"coordsecret\"), \"Failed to start coordinator\");\n+\n+    //verify access to Monitoring Exporter\n+    verifyMonExpAppAccessThroughNginx();\n+    //verify metrics via prometheus\n+    String testappPrometheusSearchKey =\n+        \"weblogic_servlet_invocation_total_count%7Bapp%3D%22wlsexporter%22%7D%5B15s%5D\";\n+    checkMetricsViaPrometheus(testappPrometheusSearchKey, \"wlsexporter\");\n+  }\n+\n+\n+  /**\n+   * TODO: remove this after Sankar's PR is merged", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 324}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NTQ5NA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436045494", "createdAt": "2020-06-05T16:56:08Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify WebLogic Metric is processed as expected by MonitoringExporter via Prometheus and Grafana\")\n+@IntegrationTest\n+class ItMonitoringExporter implements LoggedTest {\n+\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int replicaCount = 2;\n+\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain1Uid = \"monexp-domain1\";\n+  private static String domain2Uid = \"monexp-domain2\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static List<String> ingressHostList = null;\n+\n+  private String curlCmd = null;\n+  private static String monitoringNS = null;\n+  private static String webhookNS = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  HelmParams promHelmParams = null;\n+  HelmParams grafanaHelmParams = null;\n+  private static String monitoringExporterEndToEndDir = null;\n+  private static String monitoringExporterSrcDir = null;\n+  private static String monitoringExporterAppDir = null;\n+  private static V1Service webhookService = null;\n+  private static V1Deployment webhookDepl = null;\n+  private static V1Service coordinatorService = null;\n+  private static V1Deployment coordinatorDepl = null;\n+  // constants for creating domain image using model in image\n+  private static final String MONEXP_MODEL_FILE = \"model.monexp.yaml\";\n+  private static final String MONEXP_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String MONEXP_APP_NAME = \"monexp-app\";\n+  private static final String MONEXP_APP_WAR_NAME = \"monexp-war\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domain1Uid + \"-admin-server\";\n+  private static String managedServerPrefix = domain1Uid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int nodeportserver;\n+\n+  /**\n+   * Install operator and NGINX. Create model in image domain with multiple clusters.\n+   * Create ingress for the domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(6) List<String> namespaces) {\n+\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    final String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Get a unique namespace for WebLogic domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique monitoring namespace\n+    logger.info(\"Get a unique namespace for monitoring\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    monitoringNS = namespaces.get(3);\n+\n+    // get a unique webhook namespace\n+    logger.info(\"Get a unique namespace for webhook\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    webhookNS = namespaces.get(4);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    final String nginxNamespace = namespaces.get(5);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace,domain2Namespace);\n+\n+    //install monitoring exporter\n+    installMonitoringExporter();\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName, domain1Uid);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+    // create ingress for the domain\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domain1Uid, domain1Namespace);\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    ingressHostList =\n+        createIngressForDomainAndVerify(domain1Uid, domain1Namespace, clusterNameMsPortMap);\n+\n+  }\n+\n+  @Test\n+  @DisplayName(\"Install Prometheus, Grafana , Webhook, Coordinator and verify WebLogic metrics\")\n+  public void testCheckMetrics() throws Exception {\n+\n+    createPvAndPvc(\"prometheus\");\n+    createPvAndPvc(\"alertmanager\");\n+    createPvAndPvc(\"grafana\");\n+\n+    logger.info(\"create a staging location for monitoring creation scripts\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"ItMonitoringExporter\", \"promCreateTempValueFile\");\n+    FileUtils.deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+\n+    logger.info(\"copy the promvalue.yaml to staging location\");\n+    Path srcPromFile = Paths.get(RESOURCE_DIR, \"exporter\", \"promvalues.yaml\");\n+    Path targetPromFile = Paths.get(fileTemp.toString(), \"promvalues.yaml\");\n+    Files.copy(srcPromFile, targetPromFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain1;cluster-1\",\n+        \"regex: \" + domain1Namespace\n+        + \";\"\n+        + domain1Uid\n+        + \";cluster-1\");\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain2;cluster-1\",\n+        \"regex: \" + domain2Namespace\n+            + \";\"\n+            + domain2Uid\n+            + \";cluster-1\");\n+    int nodeportalertmanserver = getNextFreePort(30400, 30600);\n+    nodeportserver = getNextFreePort(32400, 32600);\n+\n+    promHelmParams = installAndVerifyPrometheus(\"prometheus\",\n+         monitoringNS,\n+        targetPromFile.toString(),\n+         PROMETHEUS_CHART_VERSION,\n+         nodeportserver,\n+         nodeportalertmanserver);\n+    logger.info(\"Prometheus is running\");\n+\n+    int nodeportgrafana = getNextFreePort(31000, 31200);\n+    grafanaHelmParams = installAndVerifyGrafana(\"grafana\",\n+        monitoringNS,\n+        monitoringExporterEndToEndDir + \"/grafana/values.yaml\",\n+        GRAFANA_CHART_VERSION,\n+        nodeportgrafana);\n+    logger.info(\"Grafana is running\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterEndToEndDir + \"/webhook\",\n+        \"webhook\",\n+        webhookNS,\n+        \"app=webhook\", REPO_SECRET_NAME), \"Failed to start webhook\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterSrcDir + \"/config_coordinator\",\n+        \"coordinator\",\n+        domain1Namespace,\n+        \"app=coordinator\", \"coordsecret\"), \"Failed to start coordinator\");\n+\n+    //verify access to Monitoring Exporter\n+    verifyMonExpAppAccessThroughNginx();\n+    //verify metrics via prometheus\n+    String testappPrometheusSearchKey =\n+        \"weblogic_servlet_invocation_total_count%7Bapp%3D%22wlsexporter%22%7D%5B15s%5D\";\n+    checkMetricsViaPrometheus(testappPrometheusSearchKey, \"wlsexporter\");\n+  }\n+\n+\n+  /**\n+   * TODO: remove this after Sankar's PR is merged", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzMDc5NQ=="}, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 324}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTY3MjY1OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNTowNjowOVrOGfKg1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjo1NjowMVrOGf2GZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzMTI4NQ==", "bodyText": "shutdown the domain before deleting CRD", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r435331285", "createdAt": "2020-06-04T15:06:09Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify WebLogic Metric is processed as expected by MonitoringExporter via Prometheus and Grafana\")\n+@IntegrationTest\n+class ItMonitoringExporter implements LoggedTest {\n+\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int replicaCount = 2;\n+\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain1Uid = \"monexp-domain1\";\n+  private static String domain2Uid = \"monexp-domain2\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static List<String> ingressHostList = null;\n+\n+  private String curlCmd = null;\n+  private static String monitoringNS = null;\n+  private static String webhookNS = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  HelmParams promHelmParams = null;\n+  HelmParams grafanaHelmParams = null;\n+  private static String monitoringExporterEndToEndDir = null;\n+  private static String monitoringExporterSrcDir = null;\n+  private static String monitoringExporterAppDir = null;\n+  private static V1Service webhookService = null;\n+  private static V1Deployment webhookDepl = null;\n+  private static V1Service coordinatorService = null;\n+  private static V1Deployment coordinatorDepl = null;\n+  // constants for creating domain image using model in image\n+  private static final String MONEXP_MODEL_FILE = \"model.monexp.yaml\";\n+  private static final String MONEXP_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String MONEXP_APP_NAME = \"monexp-app\";\n+  private static final String MONEXP_APP_WAR_NAME = \"monexp-war\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domain1Uid + \"-admin-server\";\n+  private static String managedServerPrefix = domain1Uid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int nodeportserver;\n+\n+  /**\n+   * Install operator and NGINX. Create model in image domain with multiple clusters.\n+   * Create ingress for the domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(6) List<String> namespaces) {\n+\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    final String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Get a unique namespace for WebLogic domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique monitoring namespace\n+    logger.info(\"Get a unique namespace for monitoring\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    monitoringNS = namespaces.get(3);\n+\n+    // get a unique webhook namespace\n+    logger.info(\"Get a unique namespace for webhook\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    webhookNS = namespaces.get(4);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    final String nginxNamespace = namespaces.get(5);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace,domain2Namespace);\n+\n+    //install monitoring exporter\n+    installMonitoringExporter();\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName, domain1Uid);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+    // create ingress for the domain\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domain1Uid, domain1Namespace);\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    ingressHostList =\n+        createIngressForDomainAndVerify(domain1Uid, domain1Namespace, clusterNameMsPortMap);\n+\n+  }\n+\n+  @Test\n+  @DisplayName(\"Install Prometheus, Grafana , Webhook, Coordinator and verify WebLogic metrics\")\n+  public void testCheckMetrics() throws Exception {\n+\n+    createPvAndPvc(\"prometheus\");\n+    createPvAndPvc(\"alertmanager\");\n+    createPvAndPvc(\"grafana\");\n+\n+    logger.info(\"create a staging location for monitoring creation scripts\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"ItMonitoringExporter\", \"promCreateTempValueFile\");\n+    FileUtils.deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+\n+    logger.info(\"copy the promvalue.yaml to staging location\");\n+    Path srcPromFile = Paths.get(RESOURCE_DIR, \"exporter\", \"promvalues.yaml\");\n+    Path targetPromFile = Paths.get(fileTemp.toString(), \"promvalues.yaml\");\n+    Files.copy(srcPromFile, targetPromFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain1;cluster-1\",\n+        \"regex: \" + domain1Namespace\n+        + \";\"\n+        + domain1Uid\n+        + \";cluster-1\");\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain2;cluster-1\",\n+        \"regex: \" + domain2Namespace\n+            + \";\"\n+            + domain2Uid\n+            + \";cluster-1\");\n+    int nodeportalertmanserver = getNextFreePort(30400, 30600);\n+    nodeportserver = getNextFreePort(32400, 32600);\n+\n+    promHelmParams = installAndVerifyPrometheus(\"prometheus\",\n+         monitoringNS,\n+        targetPromFile.toString(),\n+         PROMETHEUS_CHART_VERSION,\n+         nodeportserver,\n+         nodeportalertmanserver);\n+    logger.info(\"Prometheus is running\");\n+\n+    int nodeportgrafana = getNextFreePort(31000, 31200);\n+    grafanaHelmParams = installAndVerifyGrafana(\"grafana\",\n+        monitoringNS,\n+        monitoringExporterEndToEndDir + \"/grafana/values.yaml\",\n+        GRAFANA_CHART_VERSION,\n+        nodeportgrafana);\n+    logger.info(\"Grafana is running\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterEndToEndDir + \"/webhook\",\n+        \"webhook\",\n+        webhookNS,\n+        \"app=webhook\", REPO_SECRET_NAME), \"Failed to start webhook\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterSrcDir + \"/config_coordinator\",\n+        \"coordinator\",\n+        domain1Namespace,\n+        \"app=coordinator\", \"coordsecret\"), \"Failed to start coordinator\");\n+\n+    //verify access to Monitoring Exporter\n+    verifyMonExpAppAccessThroughNginx();\n+    //verify metrics via prometheus\n+    String testappPrometheusSearchKey =\n+        \"weblogic_servlet_invocation_total_count%7Bapp%3D%22wlsexporter%22%7D%5B15s%5D\";\n+    checkMetricsViaPrometheus(testappPrometheusSearchKey, \"wlsexporter\");\n+  }\n+\n+\n+  /**\n+   * TODO: remove this after Sankar's PR is merged\n+   * The cleanup framework does not uninstall NGINX release. Do it here for now.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domain1Namespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domain1Uid, domain1Namespace),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 332}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NTQxMw==", "bodyText": "done", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436045413", "createdAt": "2020-06-05T16:56:01Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify WebLogic Metric is processed as expected by MonitoringExporter via Prometheus and Grafana\")\n+@IntegrationTest\n+class ItMonitoringExporter implements LoggedTest {\n+\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int replicaCount = 2;\n+\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain1Uid = \"monexp-domain1\";\n+  private static String domain2Uid = \"monexp-domain2\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static List<String> ingressHostList = null;\n+\n+  private String curlCmd = null;\n+  private static String monitoringNS = null;\n+  private static String webhookNS = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  HelmParams promHelmParams = null;\n+  HelmParams grafanaHelmParams = null;\n+  private static String monitoringExporterEndToEndDir = null;\n+  private static String monitoringExporterSrcDir = null;\n+  private static String monitoringExporterAppDir = null;\n+  private static V1Service webhookService = null;\n+  private static V1Deployment webhookDepl = null;\n+  private static V1Service coordinatorService = null;\n+  private static V1Deployment coordinatorDepl = null;\n+  // constants for creating domain image using model in image\n+  private static final String MONEXP_MODEL_FILE = \"model.monexp.yaml\";\n+  private static final String MONEXP_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String MONEXP_APP_NAME = \"monexp-app\";\n+  private static final String MONEXP_APP_WAR_NAME = \"monexp-war\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domain1Uid + \"-admin-server\";\n+  private static String managedServerPrefix = domain1Uid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int nodeportserver;\n+\n+  /**\n+   * Install operator and NGINX. Create model in image domain with multiple clusters.\n+   * Create ingress for the domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(6) List<String> namespaces) {\n+\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    final String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Get a unique namespace for WebLogic domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique monitoring namespace\n+    logger.info(\"Get a unique namespace for monitoring\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    monitoringNS = namespaces.get(3);\n+\n+    // get a unique webhook namespace\n+    logger.info(\"Get a unique namespace for webhook\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    webhookNS = namespaces.get(4);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    final String nginxNamespace = namespaces.get(5);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace,domain2Namespace);\n+\n+    //install monitoring exporter\n+    installMonitoringExporter();\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName, domain1Uid);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+    // create ingress for the domain\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domain1Uid, domain1Namespace);\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    ingressHostList =\n+        createIngressForDomainAndVerify(domain1Uid, domain1Namespace, clusterNameMsPortMap);\n+\n+  }\n+\n+  @Test\n+  @DisplayName(\"Install Prometheus, Grafana , Webhook, Coordinator and verify WebLogic metrics\")\n+  public void testCheckMetrics() throws Exception {\n+\n+    createPvAndPvc(\"prometheus\");\n+    createPvAndPvc(\"alertmanager\");\n+    createPvAndPvc(\"grafana\");\n+\n+    logger.info(\"create a staging location for monitoring creation scripts\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"ItMonitoringExporter\", \"promCreateTempValueFile\");\n+    FileUtils.deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+\n+    logger.info(\"copy the promvalue.yaml to staging location\");\n+    Path srcPromFile = Paths.get(RESOURCE_DIR, \"exporter\", \"promvalues.yaml\");\n+    Path targetPromFile = Paths.get(fileTemp.toString(), \"promvalues.yaml\");\n+    Files.copy(srcPromFile, targetPromFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain1;cluster-1\",\n+        \"regex: \" + domain1Namespace\n+        + \";\"\n+        + domain1Uid\n+        + \";cluster-1\");\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain2;cluster-1\",\n+        \"regex: \" + domain2Namespace\n+            + \";\"\n+            + domain2Uid\n+            + \";cluster-1\");\n+    int nodeportalertmanserver = getNextFreePort(30400, 30600);\n+    nodeportserver = getNextFreePort(32400, 32600);\n+\n+    promHelmParams = installAndVerifyPrometheus(\"prometheus\",\n+         monitoringNS,\n+        targetPromFile.toString(),\n+         PROMETHEUS_CHART_VERSION,\n+         nodeportserver,\n+         nodeportalertmanserver);\n+    logger.info(\"Prometheus is running\");\n+\n+    int nodeportgrafana = getNextFreePort(31000, 31200);\n+    grafanaHelmParams = installAndVerifyGrafana(\"grafana\",\n+        monitoringNS,\n+        monitoringExporterEndToEndDir + \"/grafana/values.yaml\",\n+        GRAFANA_CHART_VERSION,\n+        nodeportgrafana);\n+    logger.info(\"Grafana is running\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterEndToEndDir + \"/webhook\",\n+        \"webhook\",\n+        webhookNS,\n+        \"app=webhook\", REPO_SECRET_NAME), \"Failed to start webhook\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterSrcDir + \"/config_coordinator\",\n+        \"coordinator\",\n+        domain1Namespace,\n+        \"app=coordinator\", \"coordsecret\"), \"Failed to start coordinator\");\n+\n+    //verify access to Monitoring Exporter\n+    verifyMonExpAppAccessThroughNginx();\n+    //verify metrics via prometheus\n+    String testappPrometheusSearchKey =\n+        \"weblogic_servlet_invocation_total_count%7Bapp%3D%22wlsexporter%22%7D%5B15s%5D\";\n+    checkMetricsViaPrometheus(testappPrometheusSearchKey, \"wlsexporter\");\n+  }\n+\n+\n+  /**\n+   * TODO: remove this after Sankar's PR is merged\n+   * The cleanup framework does not uninstall NGINX release. Do it here for now.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domain1Namespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domain1Uid, domain1Namespace),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzMTI4NQ=="}, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 332}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjAyNTM3OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjoyNTozNVrOGfOAag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNTozODozM1rOGgkUvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4ODUyMg==", "bodyText": "This can be moved to a utils class.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r435388522", "createdAt": "2020-06-04T16:25:35Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify WebLogic Metric is processed as expected by MonitoringExporter via Prometheus and Grafana\")\n+@IntegrationTest\n+class ItMonitoringExporter implements LoggedTest {\n+\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int replicaCount = 2;\n+\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain1Uid = \"monexp-domain1\";\n+  private static String domain2Uid = \"monexp-domain2\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static List<String> ingressHostList = null;\n+\n+  private String curlCmd = null;\n+  private static String monitoringNS = null;\n+  private static String webhookNS = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  HelmParams promHelmParams = null;\n+  HelmParams grafanaHelmParams = null;\n+  private static String monitoringExporterEndToEndDir = null;\n+  private static String monitoringExporterSrcDir = null;\n+  private static String monitoringExporterAppDir = null;\n+  private static V1Service webhookService = null;\n+  private static V1Deployment webhookDepl = null;\n+  private static V1Service coordinatorService = null;\n+  private static V1Deployment coordinatorDepl = null;\n+  // constants for creating domain image using model in image\n+  private static final String MONEXP_MODEL_FILE = \"model.monexp.yaml\";\n+  private static final String MONEXP_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String MONEXP_APP_NAME = \"monexp-app\";\n+  private static final String MONEXP_APP_WAR_NAME = \"monexp-war\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domain1Uid + \"-admin-server\";\n+  private static String managedServerPrefix = domain1Uid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int nodeportserver;\n+\n+  /**\n+   * Install operator and NGINX. Create model in image domain with multiple clusters.\n+   * Create ingress for the domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(6) List<String> namespaces) {\n+\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    final String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Get a unique namespace for WebLogic domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique monitoring namespace\n+    logger.info(\"Get a unique namespace for monitoring\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    monitoringNS = namespaces.get(3);\n+\n+    // get a unique webhook namespace\n+    logger.info(\"Get a unique namespace for webhook\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    webhookNS = namespaces.get(4);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    final String nginxNamespace = namespaces.get(5);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace,domain2Namespace);\n+\n+    //install monitoring exporter\n+    installMonitoringExporter();\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName, domain1Uid);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+    // create ingress for the domain\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domain1Uid, domain1Namespace);\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    ingressHostList =\n+        createIngressForDomainAndVerify(domain1Uid, domain1Namespace, clusterNameMsPortMap);\n+\n+  }\n+\n+  @Test\n+  @DisplayName(\"Install Prometheus, Grafana , Webhook, Coordinator and verify WebLogic metrics\")\n+  public void testCheckMetrics() throws Exception {\n+\n+    createPvAndPvc(\"prometheus\");\n+    createPvAndPvc(\"alertmanager\");\n+    createPvAndPvc(\"grafana\");\n+\n+    logger.info(\"create a staging location for monitoring creation scripts\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"ItMonitoringExporter\", \"promCreateTempValueFile\");\n+    FileUtils.deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+\n+    logger.info(\"copy the promvalue.yaml to staging location\");\n+    Path srcPromFile = Paths.get(RESOURCE_DIR, \"exporter\", \"promvalues.yaml\");\n+    Path targetPromFile = Paths.get(fileTemp.toString(), \"promvalues.yaml\");\n+    Files.copy(srcPromFile, targetPromFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain1;cluster-1\",\n+        \"regex: \" + domain1Namespace\n+        + \";\"\n+        + domain1Uid\n+        + \";cluster-1\");\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain2;cluster-1\",\n+        \"regex: \" + domain2Namespace\n+            + \";\"\n+            + domain2Uid\n+            + \";cluster-1\");\n+    int nodeportalertmanserver = getNextFreePort(30400, 30600);\n+    nodeportserver = getNextFreePort(32400, 32600);\n+\n+    promHelmParams = installAndVerifyPrometheus(\"prometheus\",\n+         monitoringNS,\n+        targetPromFile.toString(),\n+         PROMETHEUS_CHART_VERSION,\n+         nodeportserver,\n+         nodeportalertmanserver);\n+    logger.info(\"Prometheus is running\");\n+\n+    int nodeportgrafana = getNextFreePort(31000, 31200);\n+    grafanaHelmParams = installAndVerifyGrafana(\"grafana\",\n+        monitoringNS,\n+        monitoringExporterEndToEndDir + \"/grafana/values.yaml\",\n+        GRAFANA_CHART_VERSION,\n+        nodeportgrafana);\n+    logger.info(\"Grafana is running\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterEndToEndDir + \"/webhook\",\n+        \"webhook\",\n+        webhookNS,\n+        \"app=webhook\", REPO_SECRET_NAME), \"Failed to start webhook\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterSrcDir + \"/config_coordinator\",\n+        \"coordinator\",\n+        domain1Namespace,\n+        \"app=coordinator\", \"coordsecret\"), \"Failed to start coordinator\");\n+\n+    //verify access to Monitoring Exporter\n+    verifyMonExpAppAccessThroughNginx();\n+    //verify metrics via prometheus\n+    String testappPrometheusSearchKey =\n+        \"weblogic_servlet_invocation_total_count%7Bapp%3D%22wlsexporter%22%7D%5B15s%5D\";\n+    checkMetricsViaPrometheus(testappPrometheusSearchKey, \"wlsexporter\");\n+  }\n+\n+\n+  /**\n+   * TODO: remove this after Sankar's PR is merged\n+   * The cleanup framework does not uninstall NGINX release. Do it here for now.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domain1Namespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domain1Uid, domain1Namespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+    Prometheus.uninstall(promHelmParams);\n+    logger.info(\"Prometheus is uninstalled\");\n+\n+    Grafana.uninstall(grafanaHelmParams);\n+    logger.info(\"Grafana is uninstalled\");\n+\n+    deletePersistentVolumeClaim(\"pvc-alertmanager\",monitoringNS);\n+    deletePersistentVolume(\"pv-testalertmanager\");\n+    deletePersistentVolumeClaim(\"pvc-prometheus\",monitoringNS);\n+    deletePersistentVolume(\"pv-testprometheus\");\n+    deletePersistentVolumeClaim(\"pvc-grafana\",monitoringNS);\n+    deletePersistentVolume(\"pv-testgrafana\");\n+    deleteNamespace(monitoringNS);\n+    uninstallDeploymentService(webhookDepl, webhookService);\n+    uninstallDeploymentService(coordinatorDepl, coordinatorService);\n+    uninstallMonitoringExporter();\n+\n+    // uninstall NGINX release\n+    if (nginxHelmParams != null) {\n+      assertThat(uninstallNginx(nginxHelmParams))\n+          .as(\"Test uninstallNginx returns true\")\n+          .withFailMessage(\"uninstallNginx() did not return true\")\n+          .isTrue();\n+    }\n+  }\n+\n+  /**\n+   * Create a persistent volume and persistent volume claim.\n+   * @param nameSuffix unique nameSuffix for pv and pvc to create\n+   * @throws IOException when creating pv path fails\n+   */\n+  private void createPvAndPvc(String nameSuffix) throws IOException {\n+    logger.info(\"creating persistent volume and persistent volume claim\");\n+    // create persistent volume and persistent volume claims\n+    Path pvHostPath = assertDoesNotThrow(\n+        () -> createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), \"monexp\" + \"-persistentVolume\")),\n+            \"createDirectories failed with IOException\");\n+    logger.info(\"Creating PV directory {0}\", pvHostPath);\n+    assertDoesNotThrow(() -> deleteDirectory(pvHostPath.toFile()), \"deleteDirectory failed with IOException\");\n+    assertDoesNotThrow(() -> createDirectories(pvHostPath), \"createDirectories failed with IOException\");\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(nameSuffix)\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"10Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Retain\")\n+            .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(pvHostPath.toString())))\n+        .metadata(new V1ObjectMeta()\n+            .name(\"pv-test\" + nameSuffix)\n+            .namespace(monitoringNS)\n+            .putLabelsItem(\"weblogic.domainUid\", domain1Uid));\n+\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(nameSuffix)\n+            .volumeName(\"pv-test\" + nameSuffix)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"10Gi\"))))\n+        .metadata(new V1ObjectMeta()\n+            .name(\"pvc-\" + nameSuffix)\n+            .namespace(monitoringNS)\n+            .putLabelsItem(\"weblogic.domainUid\", domain1Uid));\n+    createPVPVCAndVerify(v1pv,v1pvc, \"weblogic.domainUid=\" + domain1Uid, monitoringNS);\n+  }\n+\n+  /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 406}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NTMzMw==", "bodyText": "I use util class but generated pv and pvc are custom objects for grafana, prom, they are different from domain pv/pvc, so I create these objects in the test class but use util method createPVPVCAndVerify from commontestutils to generate them, please let me know", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436045333", "createdAt": "2020-06-05T16:55:52Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify WebLogic Metric is processed as expected by MonitoringExporter via Prometheus and Grafana\")\n+@IntegrationTest\n+class ItMonitoringExporter implements LoggedTest {\n+\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int replicaCount = 2;\n+\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain1Uid = \"monexp-domain1\";\n+  private static String domain2Uid = \"monexp-domain2\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static List<String> ingressHostList = null;\n+\n+  private String curlCmd = null;\n+  private static String monitoringNS = null;\n+  private static String webhookNS = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  HelmParams promHelmParams = null;\n+  HelmParams grafanaHelmParams = null;\n+  private static String monitoringExporterEndToEndDir = null;\n+  private static String monitoringExporterSrcDir = null;\n+  private static String monitoringExporterAppDir = null;\n+  private static V1Service webhookService = null;\n+  private static V1Deployment webhookDepl = null;\n+  private static V1Service coordinatorService = null;\n+  private static V1Deployment coordinatorDepl = null;\n+  // constants for creating domain image using model in image\n+  private static final String MONEXP_MODEL_FILE = \"model.monexp.yaml\";\n+  private static final String MONEXP_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String MONEXP_APP_NAME = \"monexp-app\";\n+  private static final String MONEXP_APP_WAR_NAME = \"monexp-war\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domain1Uid + \"-admin-server\";\n+  private static String managedServerPrefix = domain1Uid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int nodeportserver;\n+\n+  /**\n+   * Install operator and NGINX. Create model in image domain with multiple clusters.\n+   * Create ingress for the domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(6) List<String> namespaces) {\n+\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    final String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Get a unique namespace for WebLogic domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique monitoring namespace\n+    logger.info(\"Get a unique namespace for monitoring\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    monitoringNS = namespaces.get(3);\n+\n+    // get a unique webhook namespace\n+    logger.info(\"Get a unique namespace for webhook\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    webhookNS = namespaces.get(4);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    final String nginxNamespace = namespaces.get(5);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace,domain2Namespace);\n+\n+    //install monitoring exporter\n+    installMonitoringExporter();\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName, domain1Uid);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+    // create ingress for the domain\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domain1Uid, domain1Namespace);\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    ingressHostList =\n+        createIngressForDomainAndVerify(domain1Uid, domain1Namespace, clusterNameMsPortMap);\n+\n+  }\n+\n+  @Test\n+  @DisplayName(\"Install Prometheus, Grafana , Webhook, Coordinator and verify WebLogic metrics\")\n+  public void testCheckMetrics() throws Exception {\n+\n+    createPvAndPvc(\"prometheus\");\n+    createPvAndPvc(\"alertmanager\");\n+    createPvAndPvc(\"grafana\");\n+\n+    logger.info(\"create a staging location for monitoring creation scripts\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"ItMonitoringExporter\", \"promCreateTempValueFile\");\n+    FileUtils.deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+\n+    logger.info(\"copy the promvalue.yaml to staging location\");\n+    Path srcPromFile = Paths.get(RESOURCE_DIR, \"exporter\", \"promvalues.yaml\");\n+    Path targetPromFile = Paths.get(fileTemp.toString(), \"promvalues.yaml\");\n+    Files.copy(srcPromFile, targetPromFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain1;cluster-1\",\n+        \"regex: \" + domain1Namespace\n+        + \";\"\n+        + domain1Uid\n+        + \";cluster-1\");\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain2;cluster-1\",\n+        \"regex: \" + domain2Namespace\n+            + \";\"\n+            + domain2Uid\n+            + \";cluster-1\");\n+    int nodeportalertmanserver = getNextFreePort(30400, 30600);\n+    nodeportserver = getNextFreePort(32400, 32600);\n+\n+    promHelmParams = installAndVerifyPrometheus(\"prometheus\",\n+         monitoringNS,\n+        targetPromFile.toString(),\n+         PROMETHEUS_CHART_VERSION,\n+         nodeportserver,\n+         nodeportalertmanserver);\n+    logger.info(\"Prometheus is running\");\n+\n+    int nodeportgrafana = getNextFreePort(31000, 31200);\n+    grafanaHelmParams = installAndVerifyGrafana(\"grafana\",\n+        monitoringNS,\n+        monitoringExporterEndToEndDir + \"/grafana/values.yaml\",\n+        GRAFANA_CHART_VERSION,\n+        nodeportgrafana);\n+    logger.info(\"Grafana is running\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterEndToEndDir + \"/webhook\",\n+        \"webhook\",\n+        webhookNS,\n+        \"app=webhook\", REPO_SECRET_NAME), \"Failed to start webhook\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterSrcDir + \"/config_coordinator\",\n+        \"coordinator\",\n+        domain1Namespace,\n+        \"app=coordinator\", \"coordsecret\"), \"Failed to start coordinator\");\n+\n+    //verify access to Monitoring Exporter\n+    verifyMonExpAppAccessThroughNginx();\n+    //verify metrics via prometheus\n+    String testappPrometheusSearchKey =\n+        \"weblogic_servlet_invocation_total_count%7Bapp%3D%22wlsexporter%22%7D%5B15s%5D\";\n+    checkMetricsViaPrometheus(testappPrometheusSearchKey, \"wlsexporter\");\n+  }\n+\n+\n+  /**\n+   * TODO: remove this after Sankar's PR is merged\n+   * The cleanup framework does not uninstall NGINX release. Do it here for now.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domain1Namespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domain1Uid, domain1Namespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+    Prometheus.uninstall(promHelmParams);\n+    logger.info(\"Prometheus is uninstalled\");\n+\n+    Grafana.uninstall(grafanaHelmParams);\n+    logger.info(\"Grafana is uninstalled\");\n+\n+    deletePersistentVolumeClaim(\"pvc-alertmanager\",monitoringNS);\n+    deletePersistentVolume(\"pv-testalertmanager\");\n+    deletePersistentVolumeClaim(\"pvc-prometheus\",monitoringNS);\n+    deletePersistentVolume(\"pv-testprometheus\");\n+    deletePersistentVolumeClaim(\"pvc-grafana\",monitoringNS);\n+    deletePersistentVolume(\"pv-testgrafana\");\n+    deleteNamespace(monitoringNS);\n+    uninstallDeploymentService(webhookDepl, webhookService);\n+    uninstallDeploymentService(coordinatorDepl, coordinatorService);\n+    uninstallMonitoringExporter();\n+\n+    // uninstall NGINX release\n+    if (nginxHelmParams != null) {\n+      assertThat(uninstallNginx(nginxHelmParams))\n+          .as(\"Test uninstallNginx returns true\")\n+          .withFailMessage(\"uninstallNginx() did not return true\")\n+          .isTrue();\n+    }\n+  }\n+\n+  /**\n+   * Create a persistent volume and persistent volume claim.\n+   * @param nameSuffix unique nameSuffix for pv and pvc to create\n+   * @throws IOException when creating pv path fails\n+   */\n+  private void createPvAndPvc(String nameSuffix) throws IOException {\n+    logger.info(\"creating persistent volume and persistent volume claim\");\n+    // create persistent volume and persistent volume claims\n+    Path pvHostPath = assertDoesNotThrow(\n+        () -> createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), \"monexp\" + \"-persistentVolume\")),\n+            \"createDirectories failed with IOException\");\n+    logger.info(\"Creating PV directory {0}\", pvHostPath);\n+    assertDoesNotThrow(() -> deleteDirectory(pvHostPath.toFile()), \"deleteDirectory failed with IOException\");\n+    assertDoesNotThrow(() -> createDirectories(pvHostPath), \"createDirectories failed with IOException\");\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(nameSuffix)\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"10Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Retain\")\n+            .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(pvHostPath.toString())))\n+        .metadata(new V1ObjectMeta()\n+            .name(\"pv-test\" + nameSuffix)\n+            .namespace(monitoringNS)\n+            .putLabelsItem(\"weblogic.domainUid\", domain1Uid));\n+\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(nameSuffix)\n+            .volumeName(\"pv-test\" + nameSuffix)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"10Gi\"))))\n+        .metadata(new V1ObjectMeta()\n+            .name(\"pvc-\" + nameSuffix)\n+            .namespace(monitoringNS)\n+            .putLabelsItem(\"weblogic.domainUid\", domain1Uid));\n+    createPVPVCAndVerify(v1pv,v1pvc, \"weblogic.domainUid=\" + domain1Uid, monitoringNS);\n+  }\n+\n+  /**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4ODUyMg=="}, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 406}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc5MTg5NQ==", "bodyText": "My comment was for method replaceStringInFile()", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436791895", "createdAt": "2020-06-08T15:23:00Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify WebLogic Metric is processed as expected by MonitoringExporter via Prometheus and Grafana\")\n+@IntegrationTest\n+class ItMonitoringExporter implements LoggedTest {\n+\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int replicaCount = 2;\n+\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain1Uid = \"monexp-domain1\";\n+  private static String domain2Uid = \"monexp-domain2\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static List<String> ingressHostList = null;\n+\n+  private String curlCmd = null;\n+  private static String monitoringNS = null;\n+  private static String webhookNS = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  HelmParams promHelmParams = null;\n+  HelmParams grafanaHelmParams = null;\n+  private static String monitoringExporterEndToEndDir = null;\n+  private static String monitoringExporterSrcDir = null;\n+  private static String monitoringExporterAppDir = null;\n+  private static V1Service webhookService = null;\n+  private static V1Deployment webhookDepl = null;\n+  private static V1Service coordinatorService = null;\n+  private static V1Deployment coordinatorDepl = null;\n+  // constants for creating domain image using model in image\n+  private static final String MONEXP_MODEL_FILE = \"model.monexp.yaml\";\n+  private static final String MONEXP_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String MONEXP_APP_NAME = \"monexp-app\";\n+  private static final String MONEXP_APP_WAR_NAME = \"monexp-war\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domain1Uid + \"-admin-server\";\n+  private static String managedServerPrefix = domain1Uid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int nodeportserver;\n+\n+  /**\n+   * Install operator and NGINX. Create model in image domain with multiple clusters.\n+   * Create ingress for the domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(6) List<String> namespaces) {\n+\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    final String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Get a unique namespace for WebLogic domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique monitoring namespace\n+    logger.info(\"Get a unique namespace for monitoring\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    monitoringNS = namespaces.get(3);\n+\n+    // get a unique webhook namespace\n+    logger.info(\"Get a unique namespace for webhook\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    webhookNS = namespaces.get(4);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    final String nginxNamespace = namespaces.get(5);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace,domain2Namespace);\n+\n+    //install monitoring exporter\n+    installMonitoringExporter();\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName, domain1Uid);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+    // create ingress for the domain\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domain1Uid, domain1Namespace);\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    ingressHostList =\n+        createIngressForDomainAndVerify(domain1Uid, domain1Namespace, clusterNameMsPortMap);\n+\n+  }\n+\n+  @Test\n+  @DisplayName(\"Install Prometheus, Grafana , Webhook, Coordinator and verify WebLogic metrics\")\n+  public void testCheckMetrics() throws Exception {\n+\n+    createPvAndPvc(\"prometheus\");\n+    createPvAndPvc(\"alertmanager\");\n+    createPvAndPvc(\"grafana\");\n+\n+    logger.info(\"create a staging location for monitoring creation scripts\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"ItMonitoringExporter\", \"promCreateTempValueFile\");\n+    FileUtils.deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+\n+    logger.info(\"copy the promvalue.yaml to staging location\");\n+    Path srcPromFile = Paths.get(RESOURCE_DIR, \"exporter\", \"promvalues.yaml\");\n+    Path targetPromFile = Paths.get(fileTemp.toString(), \"promvalues.yaml\");\n+    Files.copy(srcPromFile, targetPromFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain1;cluster-1\",\n+        \"regex: \" + domain1Namespace\n+        + \";\"\n+        + domain1Uid\n+        + \";cluster-1\");\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain2;cluster-1\",\n+        \"regex: \" + domain2Namespace\n+            + \";\"\n+            + domain2Uid\n+            + \";cluster-1\");\n+    int nodeportalertmanserver = getNextFreePort(30400, 30600);\n+    nodeportserver = getNextFreePort(32400, 32600);\n+\n+    promHelmParams = installAndVerifyPrometheus(\"prometheus\",\n+         monitoringNS,\n+        targetPromFile.toString(),\n+         PROMETHEUS_CHART_VERSION,\n+         nodeportserver,\n+         nodeportalertmanserver);\n+    logger.info(\"Prometheus is running\");\n+\n+    int nodeportgrafana = getNextFreePort(31000, 31200);\n+    grafanaHelmParams = installAndVerifyGrafana(\"grafana\",\n+        monitoringNS,\n+        monitoringExporterEndToEndDir + \"/grafana/values.yaml\",\n+        GRAFANA_CHART_VERSION,\n+        nodeportgrafana);\n+    logger.info(\"Grafana is running\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterEndToEndDir + \"/webhook\",\n+        \"webhook\",\n+        webhookNS,\n+        \"app=webhook\", REPO_SECRET_NAME), \"Failed to start webhook\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterSrcDir + \"/config_coordinator\",\n+        \"coordinator\",\n+        domain1Namespace,\n+        \"app=coordinator\", \"coordsecret\"), \"Failed to start coordinator\");\n+\n+    //verify access to Monitoring Exporter\n+    verifyMonExpAppAccessThroughNginx();\n+    //verify metrics via prometheus\n+    String testappPrometheusSearchKey =\n+        \"weblogic_servlet_invocation_total_count%7Bapp%3D%22wlsexporter%22%7D%5B15s%5D\";\n+    checkMetricsViaPrometheus(testappPrometheusSearchKey, \"wlsexporter\");\n+  }\n+\n+\n+  /**\n+   * TODO: remove this after Sankar's PR is merged\n+   * The cleanup framework does not uninstall NGINX release. Do it here for now.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domain1Namespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domain1Uid, domain1Namespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+    Prometheus.uninstall(promHelmParams);\n+    logger.info(\"Prometheus is uninstalled\");\n+\n+    Grafana.uninstall(grafanaHelmParams);\n+    logger.info(\"Grafana is uninstalled\");\n+\n+    deletePersistentVolumeClaim(\"pvc-alertmanager\",monitoringNS);\n+    deletePersistentVolume(\"pv-testalertmanager\");\n+    deletePersistentVolumeClaim(\"pvc-prometheus\",monitoringNS);\n+    deletePersistentVolume(\"pv-testprometheus\");\n+    deletePersistentVolumeClaim(\"pvc-grafana\",monitoringNS);\n+    deletePersistentVolume(\"pv-testgrafana\");\n+    deleteNamespace(monitoringNS);\n+    uninstallDeploymentService(webhookDepl, webhookService);\n+    uninstallDeploymentService(coordinatorDepl, coordinatorService);\n+    uninstallMonitoringExporter();\n+\n+    // uninstall NGINX release\n+    if (nginxHelmParams != null) {\n+      assertThat(uninstallNginx(nginxHelmParams))\n+          .as(\"Test uninstallNginx returns true\")\n+          .withFailMessage(\"uninstallNginx() did not return true\")\n+          .isTrue();\n+    }\n+  }\n+\n+  /**\n+   * Create a persistent volume and persistent volume claim.\n+   * @param nameSuffix unique nameSuffix for pv and pvc to create\n+   * @throws IOException when creating pv path fails\n+   */\n+  private void createPvAndPvc(String nameSuffix) throws IOException {\n+    logger.info(\"creating persistent volume and persistent volume claim\");\n+    // create persistent volume and persistent volume claims\n+    Path pvHostPath = assertDoesNotThrow(\n+        () -> createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), \"monexp\" + \"-persistentVolume\")),\n+            \"createDirectories failed with IOException\");\n+    logger.info(\"Creating PV directory {0}\", pvHostPath);\n+    assertDoesNotThrow(() -> deleteDirectory(pvHostPath.toFile()), \"deleteDirectory failed with IOException\");\n+    assertDoesNotThrow(() -> createDirectories(pvHostPath), \"createDirectories failed with IOException\");\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(nameSuffix)\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"10Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Retain\")\n+            .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(pvHostPath.toString())))\n+        .metadata(new V1ObjectMeta()\n+            .name(\"pv-test\" + nameSuffix)\n+            .namespace(monitoringNS)\n+            .putLabelsItem(\"weblogic.domainUid\", domain1Uid));\n+\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(nameSuffix)\n+            .volumeName(\"pv-test\" + nameSuffix)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"10Gi\"))))\n+        .metadata(new V1ObjectMeta()\n+            .name(\"pvc-\" + nameSuffix)\n+            .namespace(monitoringNS)\n+            .putLabelsItem(\"weblogic.domainUid\", domain1Uid));\n+    createPVPVCAndVerify(v1pv,v1pvc, \"weblogic.domainUid=\" + domain1Uid, monitoringNS);\n+  }\n+\n+  /**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4ODUyMg=="}, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 406}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgwMjc0OA==", "bodyText": "sorry for misunderstanding, moved it to test utils", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436802748", "createdAt": "2020-06-08T15:38:33Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify WebLogic Metric is processed as expected by MonitoringExporter via Prometheus and Grafana\")\n+@IntegrationTest\n+class ItMonitoringExporter implements LoggedTest {\n+\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int replicaCount = 2;\n+\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain1Uid = \"monexp-domain1\";\n+  private static String domain2Uid = \"monexp-domain2\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static List<String> ingressHostList = null;\n+\n+  private String curlCmd = null;\n+  private static String monitoringNS = null;\n+  private static String webhookNS = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  HelmParams promHelmParams = null;\n+  HelmParams grafanaHelmParams = null;\n+  private static String monitoringExporterEndToEndDir = null;\n+  private static String monitoringExporterSrcDir = null;\n+  private static String monitoringExporterAppDir = null;\n+  private static V1Service webhookService = null;\n+  private static V1Deployment webhookDepl = null;\n+  private static V1Service coordinatorService = null;\n+  private static V1Deployment coordinatorDepl = null;\n+  // constants for creating domain image using model in image\n+  private static final String MONEXP_MODEL_FILE = \"model.monexp.yaml\";\n+  private static final String MONEXP_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String MONEXP_APP_NAME = \"monexp-app\";\n+  private static final String MONEXP_APP_WAR_NAME = \"monexp-war\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domain1Uid + \"-admin-server\";\n+  private static String managedServerPrefix = domain1Uid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int nodeportserver;\n+\n+  /**\n+   * Install operator and NGINX. Create model in image domain with multiple clusters.\n+   * Create ingress for the domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(6) List<String> namespaces) {\n+\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    final String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Get a unique namespace for WebLogic domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique monitoring namespace\n+    logger.info(\"Get a unique namespace for monitoring\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    monitoringNS = namespaces.get(3);\n+\n+    // get a unique webhook namespace\n+    logger.info(\"Get a unique namespace for webhook\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    webhookNS = namespaces.get(4);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    final String nginxNamespace = namespaces.get(5);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace,domain2Namespace);\n+\n+    //install monitoring exporter\n+    installMonitoringExporter();\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName, domain1Uid);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+    // create ingress for the domain\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domain1Uid, domain1Namespace);\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    ingressHostList =\n+        createIngressForDomainAndVerify(domain1Uid, domain1Namespace, clusterNameMsPortMap);\n+\n+  }\n+\n+  @Test\n+  @DisplayName(\"Install Prometheus, Grafana , Webhook, Coordinator and verify WebLogic metrics\")\n+  public void testCheckMetrics() throws Exception {\n+\n+    createPvAndPvc(\"prometheus\");\n+    createPvAndPvc(\"alertmanager\");\n+    createPvAndPvc(\"grafana\");\n+\n+    logger.info(\"create a staging location for monitoring creation scripts\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"ItMonitoringExporter\", \"promCreateTempValueFile\");\n+    FileUtils.deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+\n+    logger.info(\"copy the promvalue.yaml to staging location\");\n+    Path srcPromFile = Paths.get(RESOURCE_DIR, \"exporter\", \"promvalues.yaml\");\n+    Path targetPromFile = Paths.get(fileTemp.toString(), \"promvalues.yaml\");\n+    Files.copy(srcPromFile, targetPromFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain1;cluster-1\",\n+        \"regex: \" + domain1Namespace\n+        + \";\"\n+        + domain1Uid\n+        + \";cluster-1\");\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain2;cluster-1\",\n+        \"regex: \" + domain2Namespace\n+            + \";\"\n+            + domain2Uid\n+            + \";cluster-1\");\n+    int nodeportalertmanserver = getNextFreePort(30400, 30600);\n+    nodeportserver = getNextFreePort(32400, 32600);\n+\n+    promHelmParams = installAndVerifyPrometheus(\"prometheus\",\n+         monitoringNS,\n+        targetPromFile.toString(),\n+         PROMETHEUS_CHART_VERSION,\n+         nodeportserver,\n+         nodeportalertmanserver);\n+    logger.info(\"Prometheus is running\");\n+\n+    int nodeportgrafana = getNextFreePort(31000, 31200);\n+    grafanaHelmParams = installAndVerifyGrafana(\"grafana\",\n+        monitoringNS,\n+        monitoringExporterEndToEndDir + \"/grafana/values.yaml\",\n+        GRAFANA_CHART_VERSION,\n+        nodeportgrafana);\n+    logger.info(\"Grafana is running\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterEndToEndDir + \"/webhook\",\n+        \"webhook\",\n+        webhookNS,\n+        \"app=webhook\", REPO_SECRET_NAME), \"Failed to start webhook\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterSrcDir + \"/config_coordinator\",\n+        \"coordinator\",\n+        domain1Namespace,\n+        \"app=coordinator\", \"coordsecret\"), \"Failed to start coordinator\");\n+\n+    //verify access to Monitoring Exporter\n+    verifyMonExpAppAccessThroughNginx();\n+    //verify metrics via prometheus\n+    String testappPrometheusSearchKey =\n+        \"weblogic_servlet_invocation_total_count%7Bapp%3D%22wlsexporter%22%7D%5B15s%5D\";\n+    checkMetricsViaPrometheus(testappPrometheusSearchKey, \"wlsexporter\");\n+  }\n+\n+\n+  /**\n+   * TODO: remove this after Sankar's PR is merged\n+   * The cleanup framework does not uninstall NGINX release. Do it here for now.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domain1Namespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domain1Uid, domain1Namespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+    Prometheus.uninstall(promHelmParams);\n+    logger.info(\"Prometheus is uninstalled\");\n+\n+    Grafana.uninstall(grafanaHelmParams);\n+    logger.info(\"Grafana is uninstalled\");\n+\n+    deletePersistentVolumeClaim(\"pvc-alertmanager\",monitoringNS);\n+    deletePersistentVolume(\"pv-testalertmanager\");\n+    deletePersistentVolumeClaim(\"pvc-prometheus\",monitoringNS);\n+    deletePersistentVolume(\"pv-testprometheus\");\n+    deletePersistentVolumeClaim(\"pvc-grafana\",monitoringNS);\n+    deletePersistentVolume(\"pv-testgrafana\");\n+    deleteNamespace(monitoringNS);\n+    uninstallDeploymentService(webhookDepl, webhookService);\n+    uninstallDeploymentService(coordinatorDepl, coordinatorService);\n+    uninstallMonitoringExporter();\n+\n+    // uninstall NGINX release\n+    if (nginxHelmParams != null) {\n+      assertThat(uninstallNginx(nginxHelmParams))\n+          .as(\"Test uninstallNginx returns true\")\n+          .withFailMessage(\"uninstallNginx() did not return true\")\n+          .isTrue();\n+    }\n+  }\n+\n+  /**\n+   * Create a persistent volume and persistent volume claim.\n+   * @param nameSuffix unique nameSuffix for pv and pvc to create\n+   * @throws IOException when creating pv path fails\n+   */\n+  private void createPvAndPvc(String nameSuffix) throws IOException {\n+    logger.info(\"creating persistent volume and persistent volume claim\");\n+    // create persistent volume and persistent volume claims\n+    Path pvHostPath = assertDoesNotThrow(\n+        () -> createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), \"monexp\" + \"-persistentVolume\")),\n+            \"createDirectories failed with IOException\");\n+    logger.info(\"Creating PV directory {0}\", pvHostPath);\n+    assertDoesNotThrow(() -> deleteDirectory(pvHostPath.toFile()), \"deleteDirectory failed with IOException\");\n+    assertDoesNotThrow(() -> createDirectories(pvHostPath), \"createDirectories failed with IOException\");\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(nameSuffix)\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"10Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Retain\")\n+            .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(pvHostPath.toString())))\n+        .metadata(new V1ObjectMeta()\n+            .name(\"pv-test\" + nameSuffix)\n+            .namespace(monitoringNS)\n+            .putLabelsItem(\"weblogic.domainUid\", domain1Uid));\n+\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(nameSuffix)\n+            .volumeName(\"pv-test\" + nameSuffix)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"10Gi\"))))\n+        .metadata(new V1ObjectMeta()\n+            .name(\"pvc-\" + nameSuffix)\n+            .namespace(monitoringNS)\n+            .putLabelsItem(\"weblogic.domainUid\", domain1Uid));\n+    createPVPVCAndVerify(v1pv,v1pvc, \"weblogic.domainUid=\" + domain1Uid, monitoringNS);\n+  }\n+\n+  /**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4ODUyMg=="}, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 406}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjAzNjQ2OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjoyODoxN1rOGfOHUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjo1Mzo0NVrOGf2B3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5MDI4OA==", "bodyText": "pod name starts with podName", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r435390288", "createdAt": "2020-06-04T16:28:17Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify WebLogic Metric is processed as expected by MonitoringExporter via Prometheus and Grafana\")\n+@IntegrationTest\n+class ItMonitoringExporter implements LoggedTest {\n+\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int replicaCount = 2;\n+\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain1Uid = \"monexp-domain1\";\n+  private static String domain2Uid = \"monexp-domain2\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static List<String> ingressHostList = null;\n+\n+  private String curlCmd = null;\n+  private static String monitoringNS = null;\n+  private static String webhookNS = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  HelmParams promHelmParams = null;\n+  HelmParams grafanaHelmParams = null;\n+  private static String monitoringExporterEndToEndDir = null;\n+  private static String monitoringExporterSrcDir = null;\n+  private static String monitoringExporterAppDir = null;\n+  private static V1Service webhookService = null;\n+  private static V1Deployment webhookDepl = null;\n+  private static V1Service coordinatorService = null;\n+  private static V1Deployment coordinatorDepl = null;\n+  // constants for creating domain image using model in image\n+  private static final String MONEXP_MODEL_FILE = \"model.monexp.yaml\";\n+  private static final String MONEXP_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String MONEXP_APP_NAME = \"monexp-app\";\n+  private static final String MONEXP_APP_WAR_NAME = \"monexp-war\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domain1Uid + \"-admin-server\";\n+  private static String managedServerPrefix = domain1Uid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int nodeportserver;\n+\n+  /**\n+   * Install operator and NGINX. Create model in image domain with multiple clusters.\n+   * Create ingress for the domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(6) List<String> namespaces) {\n+\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    final String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Get a unique namespace for WebLogic domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique monitoring namespace\n+    logger.info(\"Get a unique namespace for monitoring\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    monitoringNS = namespaces.get(3);\n+\n+    // get a unique webhook namespace\n+    logger.info(\"Get a unique namespace for webhook\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    webhookNS = namespaces.get(4);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    final String nginxNamespace = namespaces.get(5);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace,domain2Namespace);\n+\n+    //install monitoring exporter\n+    installMonitoringExporter();\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName, domain1Uid);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+    // create ingress for the domain\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domain1Uid, domain1Namespace);\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    ingressHostList =\n+        createIngressForDomainAndVerify(domain1Uid, domain1Namespace, clusterNameMsPortMap);\n+\n+  }\n+\n+  @Test\n+  @DisplayName(\"Install Prometheus, Grafana , Webhook, Coordinator and verify WebLogic metrics\")\n+  public void testCheckMetrics() throws Exception {\n+\n+    createPvAndPvc(\"prometheus\");\n+    createPvAndPvc(\"alertmanager\");\n+    createPvAndPvc(\"grafana\");\n+\n+    logger.info(\"create a staging location for monitoring creation scripts\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"ItMonitoringExporter\", \"promCreateTempValueFile\");\n+    FileUtils.deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+\n+    logger.info(\"copy the promvalue.yaml to staging location\");\n+    Path srcPromFile = Paths.get(RESOURCE_DIR, \"exporter\", \"promvalues.yaml\");\n+    Path targetPromFile = Paths.get(fileTemp.toString(), \"promvalues.yaml\");\n+    Files.copy(srcPromFile, targetPromFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain1;cluster-1\",\n+        \"regex: \" + domain1Namespace\n+        + \";\"\n+        + domain1Uid\n+        + \";cluster-1\");\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain2;cluster-1\",\n+        \"regex: \" + domain2Namespace\n+            + \";\"\n+            + domain2Uid\n+            + \";cluster-1\");\n+    int nodeportalertmanserver = getNextFreePort(30400, 30600);\n+    nodeportserver = getNextFreePort(32400, 32600);\n+\n+    promHelmParams = installAndVerifyPrometheus(\"prometheus\",\n+         monitoringNS,\n+        targetPromFile.toString(),\n+         PROMETHEUS_CHART_VERSION,\n+         nodeportserver,\n+         nodeportalertmanserver);\n+    logger.info(\"Prometheus is running\");\n+\n+    int nodeportgrafana = getNextFreePort(31000, 31200);\n+    grafanaHelmParams = installAndVerifyGrafana(\"grafana\",\n+        monitoringNS,\n+        monitoringExporterEndToEndDir + \"/grafana/values.yaml\",\n+        GRAFANA_CHART_VERSION,\n+        nodeportgrafana);\n+    logger.info(\"Grafana is running\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterEndToEndDir + \"/webhook\",\n+        \"webhook\",\n+        webhookNS,\n+        \"app=webhook\", REPO_SECRET_NAME), \"Failed to start webhook\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterSrcDir + \"/config_coordinator\",\n+        \"coordinator\",\n+        domain1Namespace,\n+        \"app=coordinator\", \"coordsecret\"), \"Failed to start coordinator\");\n+\n+    //verify access to Monitoring Exporter\n+    verifyMonExpAppAccessThroughNginx();\n+    //verify metrics via prometheus\n+    String testappPrometheusSearchKey =\n+        \"weblogic_servlet_invocation_total_count%7Bapp%3D%22wlsexporter%22%7D%5B15s%5D\";\n+    checkMetricsViaPrometheus(testappPrometheusSearchKey, \"wlsexporter\");\n+  }\n+\n+\n+  /**\n+   * TODO: remove this after Sankar's PR is merged\n+   * The cleanup framework does not uninstall NGINX release. Do it here for now.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domain1Namespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domain1Uid, domain1Namespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+    Prometheus.uninstall(promHelmParams);\n+    logger.info(\"Prometheus is uninstalled\");\n+\n+    Grafana.uninstall(grafanaHelmParams);\n+    logger.info(\"Grafana is uninstalled\");\n+\n+    deletePersistentVolumeClaim(\"pvc-alertmanager\",monitoringNS);\n+    deletePersistentVolume(\"pv-testalertmanager\");\n+    deletePersistentVolumeClaim(\"pvc-prometheus\",monitoringNS);\n+    deletePersistentVolume(\"pv-testprometheus\");\n+    deletePersistentVolumeClaim(\"pvc-grafana\",monitoringNS);\n+    deletePersistentVolume(\"pv-testgrafana\");\n+    deleteNamespace(monitoringNS);\n+    uninstallDeploymentService(webhookDepl, webhookService);\n+    uninstallDeploymentService(coordinatorDepl, coordinatorService);\n+    uninstallMonitoringExporter();\n+\n+    // uninstall NGINX release\n+    if (nginxHelmParams != null) {\n+      assertThat(uninstallNginx(nginxHelmParams))\n+          .as(\"Test uninstallNginx returns true\")\n+          .withFailMessage(\"uninstallNginx() did not return true\")\n+          .isTrue();\n+    }\n+  }\n+\n+  /**\n+   * Create a persistent volume and persistent volume claim.\n+   * @param nameSuffix unique nameSuffix for pv and pvc to create\n+   * @throws IOException when creating pv path fails\n+   */\n+  private void createPvAndPvc(String nameSuffix) throws IOException {\n+    logger.info(\"creating persistent volume and persistent volume claim\");\n+    // create persistent volume and persistent volume claims\n+    Path pvHostPath = assertDoesNotThrow(\n+        () -> createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), \"monexp\" + \"-persistentVolume\")),\n+            \"createDirectories failed with IOException\");\n+    logger.info(\"Creating PV directory {0}\", pvHostPath);\n+    assertDoesNotThrow(() -> deleteDirectory(pvHostPath.toFile()), \"deleteDirectory failed with IOException\");\n+    assertDoesNotThrow(() -> createDirectories(pvHostPath), \"createDirectories failed with IOException\");\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(nameSuffix)\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"10Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Retain\")\n+            .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(pvHostPath.toString())))\n+        .metadata(new V1ObjectMeta()\n+            .name(\"pv-test\" + nameSuffix)\n+            .namespace(monitoringNS)\n+            .putLabelsItem(\"weblogic.domainUid\", domain1Uid));\n+\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(nameSuffix)\n+            .volumeName(\"pv-test\" + nameSuffix)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"10Gi\"))))\n+        .metadata(new V1ObjectMeta()\n+            .name(\"pvc-\" + nameSuffix)\n+            .namespace(monitoringNS)\n+            .putLabelsItem(\"weblogic.domainUid\", domain1Uid));\n+    createPVPVCAndVerify(v1pv,v1pvc, \"weblogic.domainUid=\" + domain1Uid, monitoringNS);\n+  }\n+\n+  /**\n+   * A utility method to sed files.\n+   *\n+   * @throws IOException when copying files from source location to staging area fails\n+   */\n+  private static void replaceStringInFile(String filePath, String oldValue, String newValue)\n+      throws IOException {\n+    Path src = Paths.get(filePath);\n+    logger.info(\"Copying {0}\", src.toString());\n+    Charset charset = StandardCharsets.UTF_8;\n+    String content = new String(Files.readAllBytes(src), charset);\n+    content = content.replaceAll(oldValue, newValue);\n+    logger.info(\"to {0}\", src.toString());\n+    Files.write(src, content.getBytes(charset));\n+  }\n+\n+  /**\n+   * Create, install  Webhook or Coordinator and wait up to five minutes until the pod is ready.\n+   *\n+   * @param dockerFileDir directory where dockerfile is located\n+   * @param baseImageName base image name\n+   * @param namespace namespace\n+   * @return status of installation\n+   */\n+  public static boolean installAndVerifyPodFromCustomImage(String dockerFileDir,\n+                                                String baseImageName,\n+                                                String namespace,\n+                                                String labelSelector,\n+                                                String secretName) throws ApiException {\n+    //build webhook image\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (!REPO_NAME.isEmpty()) {\n+      imagePullPolicy = \"Always\";\n+    }\n+    String image = createPushImage(dockerFileDir,baseImageName, namespace, secretName);\n+    logger.info(\"Installing {0} in namespace {1}\", baseImageName, namespace);\n+    if (baseImageName.equalsIgnoreCase((\"webhook\"))) {\n+      createWebHook(image, imagePullPolicy, namespace, REPO_SECRET_NAME);\n+    } else if (baseImageName.contains(\"coordinator\")) {\n+      createCoordinator(image, imagePullPolicy, namespace, \"coordsecret\");\n+    } else {\n+      throw new ApiException(\"Custom image creation for \" + baseImageName + \"is not supported\");\n+    }\n+    // wait for the pod to be ready\n+    logger.info(\"Wait for the {0} pod is ready in namespace {1}\", baseImageName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for {0} to be running in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                baseImageName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podIsReady(namespace, labelSelector, baseImageName),\n+            baseImageName + \" podIsReady failed with ApiException\"));\n+    return true;\n+  }\n+\n+  /**\n+   * Create Webhook deployment and service.\n+   *\n+   * @param image full image name for deployment\n+   * @param imagePullPolicy policy for image\n+   * @param namespace webhook namespace\n+   * @param secretName webhook image secret name\n+   */\n+  private static void createWebHook(String image,\n+                                    String imagePullPolicy,\n+                                    String namespace,\n+                                    String secretName) throws ApiException {\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"webhook\");\n+\n+    webhookDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"webhook\")\n+            .namespace(namespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .image(image)\n+                            .imagePullPolicy(imagePullPolicy)\n+                            .name(\"webhook\")))\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(secretName))))));\n+\n+    logger.info(\"Create deployment for webhook in namespace {0}\",\n+        namespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(webhookDepl),\n+        String.format(\"Create deployment failed with ApiException for webhook in namespace %s\",\n+            namespace));\n+    assertTrue(deploymentCreated, String.format(\n+        \"Create deployment failed with ApiException for webhook in namespace %s \",\n+        namespace));\n+\n+    webhookService = new V1Service()\n+        .metadata(new V1ObjectMeta()\n+            .name(\"webhook\")\n+            .namespace(namespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .port(8080)\n+                    .protocol(\"TCP\")))\n+            .selector(labels));\n+\n+    logger.info(\"Create service for webhook in namespace {0}\",\n+        namespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(webhookService),\n+        String.format(\"Create service failed with ApiException for webhook in namespace %s\",\n+            namespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for webhook in namespace %s \",\n+        namespace));\n+    // wait for the webhook pod to be ready\n+    logger.info(\"Wait for the webhook pod is ready in namespace {0}\", namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for webhook to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podIsReady(namespace, \"app=webhook\", \"webhook\"),\n+            \"webhook podIsReady failed with ApiException\"));\n+  }\n+\n+  /**\n+   * Uninstall provided deployment and service.\n+   */\n+  private static void uninstallDeploymentService(V1Deployment deployment, V1Service service) {\n+    String namespace = null;\n+    String serviceName = null;\n+    String deploymentName = null;\n+    try {\n+      if (service != null) {\n+        serviceName = service.getMetadata().getName();\n+        namespace = service.getMetadata().getNamespace();\n+        Kubernetes.deleteService(serviceName, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete service {0} in namespace {1} \",\n+          serviceName, namespace);\n+    }\n+    try {\n+      if (deployment != null) {\n+        deploymentName = deployment.getMetadata().getName();\n+        namespace = deployment.getMetadata().getNamespace();\n+        Kubernetes.deleteDeployment(namespace, deploymentName);\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete deployment {0} in namespace {1}\",\n+          deploymentName, namespace);\n+    }\n+    if (namespace != null) {\n+      deleteNamespace(namespace);\n+    }\n+  }\n+\n+  /**\n+   * Create Coordinator deployment and service.\n+   *\n+   * @param image full image name for deployment\n+   * @param imagePullPolicy policy for image\n+   * @param namespace coordinator namespace\n+   * @param secretName coordinator secret name\n+   */\n+  private static void createCoordinator(String image,\n+                                        String imagePullPolicy,\n+                                        String namespace,\n+                                        String secretName) throws ApiException {\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"coordinator\");\n+    coordinatorDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"coordinator\")\n+            .namespace(namespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+            .type(\"Recreate\"))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .image(image)\n+                            .imagePullPolicy(imagePullPolicy)\n+                            .name(\"coordinator\")\n+                    .ports(Arrays.asList(\n+                        new V1ContainerPort()\n+                        .containerPort(8999)))))\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(secretName))))));\n+\n+    logger.info(\"Create deployment for coordinator in namespace {0}\",\n+        namespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(coordinatorDepl),\n+        String.format(\"Create deployment failed with ApiException for coordinator in namespace %s\",\n+            namespace));\n+    assertTrue(deploymentCreated, String.format(\n+        \"Create deployment failed with ApiException for coordinator in namespace %s \",\n+        namespace));\n+\n+    coordinatorService = new V1Service()\n+        .metadata(new V1ObjectMeta()\n+            .name(\"coordinator\")\n+            .namespace(namespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .port(8999)\n+                    .targetPort(new IntOrString(8999))))\n+            .type(\"NodePort\")\n+            .selector(labels));\n+\n+    logger.info(\"Create service for coordinator in namespace {0}\",\n+        namespace);\n+    boolean success = assertDoesNotThrow(() -> Kubernetes.createService(coordinatorService),\n+        String.format(\"Create service failed with ApiException for coordinator in namespace %s\",\n+            namespace));\n+    assertTrue(success, \"Coordinator service creation failed\");\n+  }\n+\n+  /**\n+   * Checks if the pod is running in a given namespace.\n+   * The method assumes the pod name to starts with podName", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 654}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NDI1Mw==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436044253", "createdAt": "2020-06-05T16:53:45Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify WebLogic Metric is processed as expected by MonitoringExporter via Prometheus and Grafana\")\n+@IntegrationTest\n+class ItMonitoringExporter implements LoggedTest {\n+\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int replicaCount = 2;\n+\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain1Uid = \"monexp-domain1\";\n+  private static String domain2Uid = \"monexp-domain2\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static List<String> ingressHostList = null;\n+\n+  private String curlCmd = null;\n+  private static String monitoringNS = null;\n+  private static String webhookNS = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  HelmParams promHelmParams = null;\n+  HelmParams grafanaHelmParams = null;\n+  private static String monitoringExporterEndToEndDir = null;\n+  private static String monitoringExporterSrcDir = null;\n+  private static String monitoringExporterAppDir = null;\n+  private static V1Service webhookService = null;\n+  private static V1Deployment webhookDepl = null;\n+  private static V1Service coordinatorService = null;\n+  private static V1Deployment coordinatorDepl = null;\n+  // constants for creating domain image using model in image\n+  private static final String MONEXP_MODEL_FILE = \"model.monexp.yaml\";\n+  private static final String MONEXP_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String MONEXP_APP_NAME = \"monexp-app\";\n+  private static final String MONEXP_APP_WAR_NAME = \"monexp-war\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domain1Uid + \"-admin-server\";\n+  private static String managedServerPrefix = domain1Uid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int nodeportserver;\n+\n+  /**\n+   * Install operator and NGINX. Create model in image domain with multiple clusters.\n+   * Create ingress for the domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(6) List<String> namespaces) {\n+\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    final String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Get a unique namespace for WebLogic domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique monitoring namespace\n+    logger.info(\"Get a unique namespace for monitoring\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    monitoringNS = namespaces.get(3);\n+\n+    // get a unique webhook namespace\n+    logger.info(\"Get a unique namespace for webhook\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    webhookNS = namespaces.get(4);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    final String nginxNamespace = namespaces.get(5);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace,domain2Namespace);\n+\n+    //install monitoring exporter\n+    installMonitoringExporter();\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName, domain1Uid);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+    // create ingress for the domain\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domain1Uid, domain1Namespace);\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    ingressHostList =\n+        createIngressForDomainAndVerify(domain1Uid, domain1Namespace, clusterNameMsPortMap);\n+\n+  }\n+\n+  @Test\n+  @DisplayName(\"Install Prometheus, Grafana , Webhook, Coordinator and verify WebLogic metrics\")\n+  public void testCheckMetrics() throws Exception {\n+\n+    createPvAndPvc(\"prometheus\");\n+    createPvAndPvc(\"alertmanager\");\n+    createPvAndPvc(\"grafana\");\n+\n+    logger.info(\"create a staging location for monitoring creation scripts\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"ItMonitoringExporter\", \"promCreateTempValueFile\");\n+    FileUtils.deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+\n+    logger.info(\"copy the promvalue.yaml to staging location\");\n+    Path srcPromFile = Paths.get(RESOURCE_DIR, \"exporter\", \"promvalues.yaml\");\n+    Path targetPromFile = Paths.get(fileTemp.toString(), \"promvalues.yaml\");\n+    Files.copy(srcPromFile, targetPromFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain1;cluster-1\",\n+        \"regex: \" + domain1Namespace\n+        + \";\"\n+        + domain1Uid\n+        + \";cluster-1\");\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain2;cluster-1\",\n+        \"regex: \" + domain2Namespace\n+            + \";\"\n+            + domain2Uid\n+            + \";cluster-1\");\n+    int nodeportalertmanserver = getNextFreePort(30400, 30600);\n+    nodeportserver = getNextFreePort(32400, 32600);\n+\n+    promHelmParams = installAndVerifyPrometheus(\"prometheus\",\n+         monitoringNS,\n+        targetPromFile.toString(),\n+         PROMETHEUS_CHART_VERSION,\n+         nodeportserver,\n+         nodeportalertmanserver);\n+    logger.info(\"Prometheus is running\");\n+\n+    int nodeportgrafana = getNextFreePort(31000, 31200);\n+    grafanaHelmParams = installAndVerifyGrafana(\"grafana\",\n+        monitoringNS,\n+        monitoringExporterEndToEndDir + \"/grafana/values.yaml\",\n+        GRAFANA_CHART_VERSION,\n+        nodeportgrafana);\n+    logger.info(\"Grafana is running\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterEndToEndDir + \"/webhook\",\n+        \"webhook\",\n+        webhookNS,\n+        \"app=webhook\", REPO_SECRET_NAME), \"Failed to start webhook\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterSrcDir + \"/config_coordinator\",\n+        \"coordinator\",\n+        domain1Namespace,\n+        \"app=coordinator\", \"coordsecret\"), \"Failed to start coordinator\");\n+\n+    //verify access to Monitoring Exporter\n+    verifyMonExpAppAccessThroughNginx();\n+    //verify metrics via prometheus\n+    String testappPrometheusSearchKey =\n+        \"weblogic_servlet_invocation_total_count%7Bapp%3D%22wlsexporter%22%7D%5B15s%5D\";\n+    checkMetricsViaPrometheus(testappPrometheusSearchKey, \"wlsexporter\");\n+  }\n+\n+\n+  /**\n+   * TODO: remove this after Sankar's PR is merged\n+   * The cleanup framework does not uninstall NGINX release. Do it here for now.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domain1Namespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domain1Uid, domain1Namespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+    Prometheus.uninstall(promHelmParams);\n+    logger.info(\"Prometheus is uninstalled\");\n+\n+    Grafana.uninstall(grafanaHelmParams);\n+    logger.info(\"Grafana is uninstalled\");\n+\n+    deletePersistentVolumeClaim(\"pvc-alertmanager\",monitoringNS);\n+    deletePersistentVolume(\"pv-testalertmanager\");\n+    deletePersistentVolumeClaim(\"pvc-prometheus\",monitoringNS);\n+    deletePersistentVolume(\"pv-testprometheus\");\n+    deletePersistentVolumeClaim(\"pvc-grafana\",monitoringNS);\n+    deletePersistentVolume(\"pv-testgrafana\");\n+    deleteNamespace(monitoringNS);\n+    uninstallDeploymentService(webhookDepl, webhookService);\n+    uninstallDeploymentService(coordinatorDepl, coordinatorService);\n+    uninstallMonitoringExporter();\n+\n+    // uninstall NGINX release\n+    if (nginxHelmParams != null) {\n+      assertThat(uninstallNginx(nginxHelmParams))\n+          .as(\"Test uninstallNginx returns true\")\n+          .withFailMessage(\"uninstallNginx() did not return true\")\n+          .isTrue();\n+    }\n+  }\n+\n+  /**\n+   * Create a persistent volume and persistent volume claim.\n+   * @param nameSuffix unique nameSuffix for pv and pvc to create\n+   * @throws IOException when creating pv path fails\n+   */\n+  private void createPvAndPvc(String nameSuffix) throws IOException {\n+    logger.info(\"creating persistent volume and persistent volume claim\");\n+    // create persistent volume and persistent volume claims\n+    Path pvHostPath = assertDoesNotThrow(\n+        () -> createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), \"monexp\" + \"-persistentVolume\")),\n+            \"createDirectories failed with IOException\");\n+    logger.info(\"Creating PV directory {0}\", pvHostPath);\n+    assertDoesNotThrow(() -> deleteDirectory(pvHostPath.toFile()), \"deleteDirectory failed with IOException\");\n+    assertDoesNotThrow(() -> createDirectories(pvHostPath), \"createDirectories failed with IOException\");\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(nameSuffix)\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"10Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Retain\")\n+            .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(pvHostPath.toString())))\n+        .metadata(new V1ObjectMeta()\n+            .name(\"pv-test\" + nameSuffix)\n+            .namespace(monitoringNS)\n+            .putLabelsItem(\"weblogic.domainUid\", domain1Uid));\n+\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(nameSuffix)\n+            .volumeName(\"pv-test\" + nameSuffix)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"10Gi\"))))\n+        .metadata(new V1ObjectMeta()\n+            .name(\"pvc-\" + nameSuffix)\n+            .namespace(monitoringNS)\n+            .putLabelsItem(\"weblogic.domainUid\", domain1Uid));\n+    createPVPVCAndVerify(v1pv,v1pvc, \"weblogic.domainUid=\" + domain1Uid, monitoringNS);\n+  }\n+\n+  /**\n+   * A utility method to sed files.\n+   *\n+   * @throws IOException when copying files from source location to staging area fails\n+   */\n+  private static void replaceStringInFile(String filePath, String oldValue, String newValue)\n+      throws IOException {\n+    Path src = Paths.get(filePath);\n+    logger.info(\"Copying {0}\", src.toString());\n+    Charset charset = StandardCharsets.UTF_8;\n+    String content = new String(Files.readAllBytes(src), charset);\n+    content = content.replaceAll(oldValue, newValue);\n+    logger.info(\"to {0}\", src.toString());\n+    Files.write(src, content.getBytes(charset));\n+  }\n+\n+  /**\n+   * Create, install  Webhook or Coordinator and wait up to five minutes until the pod is ready.\n+   *\n+   * @param dockerFileDir directory where dockerfile is located\n+   * @param baseImageName base image name\n+   * @param namespace namespace\n+   * @return status of installation\n+   */\n+  public static boolean installAndVerifyPodFromCustomImage(String dockerFileDir,\n+                                                String baseImageName,\n+                                                String namespace,\n+                                                String labelSelector,\n+                                                String secretName) throws ApiException {\n+    //build webhook image\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (!REPO_NAME.isEmpty()) {\n+      imagePullPolicy = \"Always\";\n+    }\n+    String image = createPushImage(dockerFileDir,baseImageName, namespace, secretName);\n+    logger.info(\"Installing {0} in namespace {1}\", baseImageName, namespace);\n+    if (baseImageName.equalsIgnoreCase((\"webhook\"))) {\n+      createWebHook(image, imagePullPolicy, namespace, REPO_SECRET_NAME);\n+    } else if (baseImageName.contains(\"coordinator\")) {\n+      createCoordinator(image, imagePullPolicy, namespace, \"coordsecret\");\n+    } else {\n+      throw new ApiException(\"Custom image creation for \" + baseImageName + \"is not supported\");\n+    }\n+    // wait for the pod to be ready\n+    logger.info(\"Wait for the {0} pod is ready in namespace {1}\", baseImageName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for {0} to be running in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                baseImageName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podIsReady(namespace, labelSelector, baseImageName),\n+            baseImageName + \" podIsReady failed with ApiException\"));\n+    return true;\n+  }\n+\n+  /**\n+   * Create Webhook deployment and service.\n+   *\n+   * @param image full image name for deployment\n+   * @param imagePullPolicy policy for image\n+   * @param namespace webhook namespace\n+   * @param secretName webhook image secret name\n+   */\n+  private static void createWebHook(String image,\n+                                    String imagePullPolicy,\n+                                    String namespace,\n+                                    String secretName) throws ApiException {\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"webhook\");\n+\n+    webhookDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"webhook\")\n+            .namespace(namespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .image(image)\n+                            .imagePullPolicy(imagePullPolicy)\n+                            .name(\"webhook\")))\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(secretName))))));\n+\n+    logger.info(\"Create deployment for webhook in namespace {0}\",\n+        namespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(webhookDepl),\n+        String.format(\"Create deployment failed with ApiException for webhook in namespace %s\",\n+            namespace));\n+    assertTrue(deploymentCreated, String.format(\n+        \"Create deployment failed with ApiException for webhook in namespace %s \",\n+        namespace));\n+\n+    webhookService = new V1Service()\n+        .metadata(new V1ObjectMeta()\n+            .name(\"webhook\")\n+            .namespace(namespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .port(8080)\n+                    .protocol(\"TCP\")))\n+            .selector(labels));\n+\n+    logger.info(\"Create service for webhook in namespace {0}\",\n+        namespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(webhookService),\n+        String.format(\"Create service failed with ApiException for webhook in namespace %s\",\n+            namespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for webhook in namespace %s \",\n+        namespace));\n+    // wait for the webhook pod to be ready\n+    logger.info(\"Wait for the webhook pod is ready in namespace {0}\", namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for webhook to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podIsReady(namespace, \"app=webhook\", \"webhook\"),\n+            \"webhook podIsReady failed with ApiException\"));\n+  }\n+\n+  /**\n+   * Uninstall provided deployment and service.\n+   */\n+  private static void uninstallDeploymentService(V1Deployment deployment, V1Service service) {\n+    String namespace = null;\n+    String serviceName = null;\n+    String deploymentName = null;\n+    try {\n+      if (service != null) {\n+        serviceName = service.getMetadata().getName();\n+        namespace = service.getMetadata().getNamespace();\n+        Kubernetes.deleteService(serviceName, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete service {0} in namespace {1} \",\n+          serviceName, namespace);\n+    }\n+    try {\n+      if (deployment != null) {\n+        deploymentName = deployment.getMetadata().getName();\n+        namespace = deployment.getMetadata().getNamespace();\n+        Kubernetes.deleteDeployment(namespace, deploymentName);\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete deployment {0} in namespace {1}\",\n+          deploymentName, namespace);\n+    }\n+    if (namespace != null) {\n+      deleteNamespace(namespace);\n+    }\n+  }\n+\n+  /**\n+   * Create Coordinator deployment and service.\n+   *\n+   * @param image full image name for deployment\n+   * @param imagePullPolicy policy for image\n+   * @param namespace coordinator namespace\n+   * @param secretName coordinator secret name\n+   */\n+  private static void createCoordinator(String image,\n+                                        String imagePullPolicy,\n+                                        String namespace,\n+                                        String secretName) throws ApiException {\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"coordinator\");\n+    coordinatorDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"coordinator\")\n+            .namespace(namespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+            .type(\"Recreate\"))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .image(image)\n+                            .imagePullPolicy(imagePullPolicy)\n+                            .name(\"coordinator\")\n+                    .ports(Arrays.asList(\n+                        new V1ContainerPort()\n+                        .containerPort(8999)))))\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(secretName))))));\n+\n+    logger.info(\"Create deployment for coordinator in namespace {0}\",\n+        namespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(coordinatorDepl),\n+        String.format(\"Create deployment failed with ApiException for coordinator in namespace %s\",\n+            namespace));\n+    assertTrue(deploymentCreated, String.format(\n+        \"Create deployment failed with ApiException for coordinator in namespace %s \",\n+        namespace));\n+\n+    coordinatorService = new V1Service()\n+        .metadata(new V1ObjectMeta()\n+            .name(\"coordinator\")\n+            .namespace(namespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .port(8999)\n+                    .targetPort(new IntOrString(8999))))\n+            .type(\"NodePort\")\n+            .selector(labels));\n+\n+    logger.info(\"Create service for coordinator in namespace {0}\",\n+        namespace);\n+    boolean success = assertDoesNotThrow(() -> Kubernetes.createService(coordinatorService),\n+        String.format(\"Create service failed with ApiException for coordinator in namespace %s\",\n+            namespace));\n+    assertTrue(success, \"Coordinator service creation failed\");\n+  }\n+\n+  /**\n+   * Checks if the pod is running in a given namespace.\n+   * The method assumes the pod name to starts with podName", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5MDI4OA=="}, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 654}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjA4MDgwOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjozOTo1NlrOGfOj2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjo1MzozNlrOGf2Bnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5NzU5NQ==", "bodyText": "TestActions class should not contain the implementation, it should call impl class.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r435397595", "createdAt": "2020-06-04T16:39:56Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -580,6 +589,48 @@ public static boolean buildAppArchive(AppParams params) {\n             .build();\n   }\n \n+  /**\n+   * Archive an application from provided ear or war file that can be used by WebLogic Image Tool\n+   * to create an image with the application for a model-in-image use case.\n+   *\n+   * @param srcFile full path to ear or war application file to archive\n+   * @return true if the operation succeeds\n+   */\n+  public static boolean archiveApp(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NDE5MQ==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436044191", "createdAt": "2020-06-05T16:53:36Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -580,6 +589,48 @@ public static boolean buildAppArchive(AppParams params) {\n             .build();\n   }\n \n+  /**\n+   * Archive an application from provided ear or war file that can be used by WebLogic Image Tool\n+   * to create an image with the application for a model-in-image use case.\n+   *\n+   * @param srcFile full path to ear or war application file to archive\n+   * @return true if the operation succeeds\n+   */\n+  public static boolean archiveApp(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5NzU5NQ=="}, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjA4ODAyOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjo0MTo0N1rOGfOokQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjo1MzoyOVrOGf2BYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5ODgwMQ==", "bodyText": "isPrometheusReady()", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r435398801", "createdAt": "2020-06-04T16:41:47Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -450,6 +452,27 @@ public static boolean podStateNotChanged(String podName,\n   }\n \n   /**\n+   * Check if Prometheus is running.\n+   *\n+   * @param namespace in which is prometheus is running\n+   * @return true if running false otherwise\n+   */\n+  public static Callable<Boolean> prometheusIsReady(String namespace) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NDEyOA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436044128", "createdAt": "2020-06-05T16:53:29Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -450,6 +452,27 @@ public static boolean podStateNotChanged(String podName,\n   }\n \n   /**\n+   * Check if Prometheus is running.\n+   *\n+   * @param namespace in which is prometheus is running\n+   * @return true if running false otherwise\n+   */\n+  public static Callable<Boolean> prometheusIsReady(String namespace) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5ODgwMQ=="}, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjA4ODU1OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjo0MTo1OFrOGfOo9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjo1MzoyMlrOGf2BIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5ODkwMg==", "bodyText": "isGrafanaReady()", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r435398902", "createdAt": "2020-06-04T16:41:58Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -450,6 +452,27 @@ public static boolean podStateNotChanged(String podName,\n   }\n \n   /**\n+   * Check if Prometheus is running.\n+   *\n+   * @param namespace in which is prometheus is running\n+   * @return true if running false otherwise\n+   */\n+  public static Callable<Boolean> prometheusIsReady(String namespace) {\n+\n+    return Prometheus.isReady(namespace);\n+  }\n+\n+  /**\n+   * Check if Grafana is running.\n+   *\n+   * @param namespace in which is grafana is running\n+   * @return true if running false otherwise\n+   */\n+  public static Callable<Boolean> grafanaIsReady(String namespace) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NDA2NQ==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436044065", "createdAt": "2020-06-05T16:53:22Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -450,6 +452,27 @@ public static boolean podStateNotChanged(String podName,\n   }\n \n   /**\n+   * Check if Prometheus is running.\n+   *\n+   * @param namespace in which is prometheus is running\n+   * @return true if running false otherwise\n+   */\n+  public static Callable<Boolean> prometheusIsReady(String namespace) {\n+\n+    return Prometheus.isReady(namespace);\n+  }\n+\n+  /**\n+   * Check if Grafana is running.\n+   *\n+   * @param namespace in which is grafana is running\n+   * @return true if running false otherwise\n+   */\n+  public static Callable<Boolean> grafanaIsReady(String namespace) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5ODkwMg=="}, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjU0MDM4OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxODo0MTowMFrOGfTJ_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxOTo1MzozNlrOGf7eNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ3Mjg5NA==", "bodyText": "Can we make the method createPvAndPvc() as action method in TestAction class.  I see similar local methods in ItDomainInPV class", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r435472894", "createdAt": "2020-06-04T18:41:00Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify WebLogic Metric is processed as expected by MonitoringExporter via Prometheus and Grafana\")\n+@IntegrationTest\n+class ItMonitoringExporter implements LoggedTest {\n+\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int replicaCount = 2;\n+\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain1Uid = \"monexp-domain1\";\n+  private static String domain2Uid = \"monexp-domain2\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static List<String> ingressHostList = null;\n+\n+  private String curlCmd = null;\n+  private static String monitoringNS = null;\n+  private static String webhookNS = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  HelmParams promHelmParams = null;\n+  HelmParams grafanaHelmParams = null;\n+  private static String monitoringExporterEndToEndDir = null;\n+  private static String monitoringExporterSrcDir = null;\n+  private static String monitoringExporterAppDir = null;\n+  private static V1Service webhookService = null;\n+  private static V1Deployment webhookDepl = null;\n+  private static V1Service coordinatorService = null;\n+  private static V1Deployment coordinatorDepl = null;\n+  // constants for creating domain image using model in image\n+  private static final String MONEXP_MODEL_FILE = \"model.monexp.yaml\";\n+  private static final String MONEXP_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String MONEXP_APP_NAME = \"monexp-app\";\n+  private static final String MONEXP_APP_WAR_NAME = \"monexp-war\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domain1Uid + \"-admin-server\";\n+  private static String managedServerPrefix = domain1Uid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int nodeportserver;\n+\n+  /**\n+   * Install operator and NGINX. Create model in image domain with multiple clusters.\n+   * Create ingress for the domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(6) List<String> namespaces) {\n+\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    final String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Get a unique namespace for WebLogic domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique monitoring namespace\n+    logger.info(\"Get a unique namespace for monitoring\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    monitoringNS = namespaces.get(3);\n+\n+    // get a unique webhook namespace\n+    logger.info(\"Get a unique namespace for webhook\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    webhookNS = namespaces.get(4);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    final String nginxNamespace = namespaces.get(5);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace,domain2Namespace);\n+\n+    //install monitoring exporter\n+    installMonitoringExporter();\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName, domain1Uid);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+    // create ingress for the domain\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domain1Uid, domain1Namespace);\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    ingressHostList =\n+        createIngressForDomainAndVerify(domain1Uid, domain1Namespace, clusterNameMsPortMap);\n+\n+  }\n+\n+  @Test\n+  @DisplayName(\"Install Prometheus, Grafana , Webhook, Coordinator and verify WebLogic metrics\")\n+  public void testCheckMetrics() throws Exception {\n+\n+    createPvAndPvc(\"prometheus\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzMzQyOQ==", "bodyText": "we have test in commontestutils, it takes v1pv and pvc params, the pv and pvc created in this test are specific to prom and grafana, so I think it is ok to keep in test class, please let me know", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436133429", "createdAt": "2020-06-05T19:53:36Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify WebLogic Metric is processed as expected by MonitoringExporter via Prometheus and Grafana\")\n+@IntegrationTest\n+class ItMonitoringExporter implements LoggedTest {\n+\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int replicaCount = 2;\n+\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain1Uid = \"monexp-domain1\";\n+  private static String domain2Uid = \"monexp-domain2\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static List<String> ingressHostList = null;\n+\n+  private String curlCmd = null;\n+  private static String monitoringNS = null;\n+  private static String webhookNS = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  HelmParams promHelmParams = null;\n+  HelmParams grafanaHelmParams = null;\n+  private static String monitoringExporterEndToEndDir = null;\n+  private static String monitoringExporterSrcDir = null;\n+  private static String monitoringExporterAppDir = null;\n+  private static V1Service webhookService = null;\n+  private static V1Deployment webhookDepl = null;\n+  private static V1Service coordinatorService = null;\n+  private static V1Deployment coordinatorDepl = null;\n+  // constants for creating domain image using model in image\n+  private static final String MONEXP_MODEL_FILE = \"model.monexp.yaml\";\n+  private static final String MONEXP_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String MONEXP_APP_NAME = \"monexp-app\";\n+  private static final String MONEXP_APP_WAR_NAME = \"monexp-war\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domain1Uid + \"-admin-server\";\n+  private static String managedServerPrefix = domain1Uid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int nodeportserver;\n+\n+  /**\n+   * Install operator and NGINX. Create model in image domain with multiple clusters.\n+   * Create ingress for the domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(6) List<String> namespaces) {\n+\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    final String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Get a unique namespace for WebLogic domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique monitoring namespace\n+    logger.info(\"Get a unique namespace for monitoring\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    monitoringNS = namespaces.get(3);\n+\n+    // get a unique webhook namespace\n+    logger.info(\"Get a unique namespace for webhook\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    webhookNS = namespaces.get(4);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    final String nginxNamespace = namespaces.get(5);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace,domain2Namespace);\n+\n+    //install monitoring exporter\n+    installMonitoringExporter();\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName, domain1Uid);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+    // create ingress for the domain\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domain1Uid, domain1Namespace);\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    ingressHostList =\n+        createIngressForDomainAndVerify(domain1Uid, domain1Namespace, clusterNameMsPortMap);\n+\n+  }\n+\n+  @Test\n+  @DisplayName(\"Install Prometheus, Grafana , Webhook, Coordinator and verify WebLogic metrics\")\n+  public void testCheckMetrics() throws Exception {\n+\n+    createPvAndPvc(\"prometheus\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ3Mjg5NA=="}, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 260}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjAzOTExOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjozMzoyNFrOGf1Z8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDoxODoyM1rOGf8K0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAzNDAzNA==", "bodyText": "can you replace the above 2 methods with this? You can use this method in Grafana,Prometheus\n/**\n*\n\nChecks if a pod is ready in a given namespace.\n\n@param namespace in which to check if the pod is ready\n@param labels map of labels as key value pairs\n@param podName name of the pod to check for\n@return true if the pod is in the ready condition, false otherwise\n@throws ApiException if Kubernetes client API call fails\n*/\npublic static boolean isPodReady(String namespace, Map<String, String> labels, String podName) throws ApiException {\nboolean status = false;\nString labelSelector = null;\n\nif (labels != null && !labels.isEmpty()) {\n  labelSelector = labels.entrySet()\n      .stream()\n      .map(e -> e.getKey() + \"=\" + e.getValue())\n      .collect(Collectors.joining(\",\"));\n}\n\nV1Pod pod = getPod(namespace, labelSelector, podName);\nif (pod != null) {\n\n  // get the podCondition with the 'Ready' type field\n  V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n      .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n      .findAny()\n      .orElse(null);\n\n  if (v1PodReadyCondition != null) {\n    status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n    if (status) {\n      logger.info(\"Pod {0} is READY in namespace {1}\", podName, namespace);\n    }\n  }\n} else {\n  logger.info(\"Pod {0} does not exist in namespace {1}\", podName, namespace);\n}\nreturn status;\n\n}", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436034034", "createdAt": "2020-06-05T16:33:24Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -595,6 +595,77 @@ public static boolean isPodRestarted(\n     return false;\n   }\n \n+  /**\n+   * Checks if the promethues pods are running in a given namespace.\n+   * The method assumes the prometheus pods name to starts with prometheus-server, alertmanager\n+   * and decorated with label prometheus\n+   * @param namespace in which to check for the pod existence\n+   * @return true if pods are exist and running otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean arePrometheusPodsReady(String namespace) throws ApiException {\n+    boolean status = false;\n+\n+    V1Pod pod = getPod(namespace, \"component=alertmanager\", \"prometheus-alertmanager\");\n+    if (pod != null) {\n+      // get the podCondition with the 'Ready' type field\n+      V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n+          .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+\n+      if (v1PodReadyCondition != null) {\n+        status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n+      }\n+    } else {\n+      logger.info(\"Prometheus-alertmanager pods don't exist\");\n+    }\n+\n+    pod = getPod(namespace, \"component=server\", \"prometheus-server\");\n+    if (pod != null) {\n+      // get the podCondition with the 'Ready' type field\n+      V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n+          .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+\n+      if (v1PodReadyCondition != null) {\n+        status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n+      }\n+    } else {\n+      logger.info(\"Prometheus-server pods don't exist\");\n+    }\n+    return status;\n+  }\n+\n+  /**\n+   * Checks if the grafana pod is running in a given namespace.\n+   * The method assumes the grafana pod name to starts with grafana\n+   * and decorated with label grafana\n+   * @param namespace in which to check for the pod existence\n+   * @return true if pods are exist and running otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isGrafanaPodReady(String namespace) throws ApiException {\n+    boolean status = false;\n+\n+    V1Pod pod = getPod(namespace, \"app.kubernetes.io/name=grafana\", \"grafana\");\n+    if (pod != null) {\n+      // get the podCondition with the 'Ready' type field\n+      V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n+          .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+\n+      if (v1PodReadyCondition != null) {\n+        status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n+      }\n+    } else {\n+      logger.info(\"Grafana pod doesn't exist\");\n+    }\n+    return status;\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5633729bddf3c70f1ed36f67cd176dbbf3a2f82e"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzMjM0NA==", "bodyText": "done", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436132344", "createdAt": "2020-06-05T19:52:10Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -595,6 +595,77 @@ public static boolean isPodRestarted(\n     return false;\n   }\n \n+  /**\n+   * Checks if the promethues pods are running in a given namespace.\n+   * The method assumes the prometheus pods name to starts with prometheus-server, alertmanager\n+   * and decorated with label prometheus\n+   * @param namespace in which to check for the pod existence\n+   * @return true if pods are exist and running otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean arePrometheusPodsReady(String namespace) throws ApiException {\n+    boolean status = false;\n+\n+    V1Pod pod = getPod(namespace, \"component=alertmanager\", \"prometheus-alertmanager\");\n+    if (pod != null) {\n+      // get the podCondition with the 'Ready' type field\n+      V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n+          .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+\n+      if (v1PodReadyCondition != null) {\n+        status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n+      }\n+    } else {\n+      logger.info(\"Prometheus-alertmanager pods don't exist\");\n+    }\n+\n+    pod = getPod(namespace, \"component=server\", \"prometheus-server\");\n+    if (pod != null) {\n+      // get the podCondition with the 'Ready' type field\n+      V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n+          .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+\n+      if (v1PodReadyCondition != null) {\n+        status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n+      }\n+    } else {\n+      logger.info(\"Prometheus-server pods don't exist\");\n+    }\n+    return status;\n+  }\n+\n+  /**\n+   * Checks if the grafana pod is running in a given namespace.\n+   * The method assumes the grafana pod name to starts with grafana\n+   * and decorated with label grafana\n+   * @param namespace in which to check for the pod existence\n+   * @return true if pods are exist and running otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isGrafanaPodReady(String namespace) throws ApiException {\n+    boolean status = false;\n+\n+    V1Pod pod = getPod(namespace, \"app.kubernetes.io/name=grafana\", \"grafana\");\n+    if (pod != null) {\n+      // get the podCondition with the 'Ready' type field\n+      V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n+          .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+\n+      if (v1PodReadyCondition != null) {\n+        status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n+      }\n+    } else {\n+      logger.info(\"Grafana pod doesn't exist\");\n+    }\n+    return status;\n+  }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAzNDAzNA=="}, "originalCommit": {"oid": "5633729bddf3c70f1ed36f67cd176dbbf3a2f82e"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzNzc1Nw==", "bodyText": "it may not work, since the other method can accept a null for domainUid and that can cause ambiguity as to which overridden method should be called.\nWe may have to fix this later. so don't worry about it for now.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436137757", "createdAt": "2020-06-05T20:00:27Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -595,6 +595,77 @@ public static boolean isPodRestarted(\n     return false;\n   }\n \n+  /**\n+   * Checks if the promethues pods are running in a given namespace.\n+   * The method assumes the prometheus pods name to starts with prometheus-server, alertmanager\n+   * and decorated with label prometheus\n+   * @param namespace in which to check for the pod existence\n+   * @return true if pods are exist and running otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean arePrometheusPodsReady(String namespace) throws ApiException {\n+    boolean status = false;\n+\n+    V1Pod pod = getPod(namespace, \"component=alertmanager\", \"prometheus-alertmanager\");\n+    if (pod != null) {\n+      // get the podCondition with the 'Ready' type field\n+      V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n+          .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+\n+      if (v1PodReadyCondition != null) {\n+        status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n+      }\n+    } else {\n+      logger.info(\"Prometheus-alertmanager pods don't exist\");\n+    }\n+\n+    pod = getPod(namespace, \"component=server\", \"prometheus-server\");\n+    if (pod != null) {\n+      // get the podCondition with the 'Ready' type field\n+      V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n+          .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+\n+      if (v1PodReadyCondition != null) {\n+        status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n+      }\n+    } else {\n+      logger.info(\"Prometheus-server pods don't exist\");\n+    }\n+    return status;\n+  }\n+\n+  /**\n+   * Checks if the grafana pod is running in a given namespace.\n+   * The method assumes the grafana pod name to starts with grafana\n+   * and decorated with label grafana\n+   * @param namespace in which to check for the pod existence\n+   * @return true if pods are exist and running otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isGrafanaPodReady(String namespace) throws ApiException {\n+    boolean status = false;\n+\n+    V1Pod pod = getPod(namespace, \"app.kubernetes.io/name=grafana\", \"grafana\");\n+    if (pod != null) {\n+      // get the podCondition with the 'Ready' type field\n+      V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n+          .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+\n+      if (v1PodReadyCondition != null) {\n+        status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n+      }\n+    } else {\n+      logger.info(\"Grafana pod doesn't exist\");\n+    }\n+    return status;\n+  }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAzNDAzNA=="}, "originalCommit": {"oid": "5633729bddf3c70f1ed36f67cd176dbbf3a2f82e"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0NDg0OQ==", "bodyText": "so I added this for isReadyNginx,     String labelSelector = null;\nreturn isPodReady(namespace, labelSelector, \"nginx-ingress-controller\");, so it works. Also both check for null, and execute same code for that", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436144849", "createdAt": "2020-06-05T20:18:23Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -595,6 +595,77 @@ public static boolean isPodRestarted(\n     return false;\n   }\n \n+  /**\n+   * Checks if the promethues pods are running in a given namespace.\n+   * The method assumes the prometheus pods name to starts with prometheus-server, alertmanager\n+   * and decorated with label prometheus\n+   * @param namespace in which to check for the pod existence\n+   * @return true if pods are exist and running otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean arePrometheusPodsReady(String namespace) throws ApiException {\n+    boolean status = false;\n+\n+    V1Pod pod = getPod(namespace, \"component=alertmanager\", \"prometheus-alertmanager\");\n+    if (pod != null) {\n+      // get the podCondition with the 'Ready' type field\n+      V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n+          .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+\n+      if (v1PodReadyCondition != null) {\n+        status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n+      }\n+    } else {\n+      logger.info(\"Prometheus-alertmanager pods don't exist\");\n+    }\n+\n+    pod = getPod(namespace, \"component=server\", \"prometheus-server\");\n+    if (pod != null) {\n+      // get the podCondition with the 'Ready' type field\n+      V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n+          .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+\n+      if (v1PodReadyCondition != null) {\n+        status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n+      }\n+    } else {\n+      logger.info(\"Prometheus-server pods don't exist\");\n+    }\n+    return status;\n+  }\n+\n+  /**\n+   * Checks if the grafana pod is running in a given namespace.\n+   * The method assumes the grafana pod name to starts with grafana\n+   * and decorated with label grafana\n+   * @param namespace in which to check for the pod existence\n+   * @return true if pods are exist and running otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isGrafanaPodReady(String namespace) throws ApiException {\n+    boolean status = false;\n+\n+    V1Pod pod = getPod(namespace, \"app.kubernetes.io/name=grafana\", \"grafana\");\n+    if (pod != null) {\n+      // get the podCondition with the 'Ready' type field\n+      V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n+          .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+\n+      if (v1PodReadyCondition != null) {\n+        status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n+      }\n+    } else {\n+      logger.info(\"Grafana pod doesn't exist\");\n+    }\n+    return status;\n+  }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAzNDAzNA=="}, "originalCommit": {"oid": "5633729bddf3c70f1ed36f67cd176dbbf3a2f82e"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMTI0ODg3OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Prometheus.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNjowMDo1OVrOGglSgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNzozOTo0NFrOGgpGZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgxODU2MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * install helm chart.\n          \n          \n            \n               * Install Prometheus.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436818560", "createdAt": "2020-06-08T16:00:59Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Prometheus.java", "diffHunk": "@@ -0,0 +1,29 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Helm;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+\n+public class Prometheus {\n+  /**\n+   * install helm chart.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f53a37a1d6397f70bfaca98042e1b37b0e8d2c64"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4MDk5Ng==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436880996", "createdAt": "2020-06-08T17:39:44Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Prometheus.java", "diffHunk": "@@ -0,0 +1,29 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Helm;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+\n+public class Prometheus {\n+  /**\n+   * install helm chart.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgxODU2MA=="}, "originalCommit": {"oid": "f53a37a1d6397f70bfaca98042e1b37b0e8d2c64"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMTI1MTA2OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Prometheus.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNjowMTozMFrOGglT2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNzozOTo1M1rOGgpGwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgxODkwNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Uninstall a helm release.\n          \n          \n            \n               * Uninstall a Prometheus release.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436818906", "createdAt": "2020-06-08T16:01:30Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Prometheus.java", "diffHunk": "@@ -0,0 +1,29 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Helm;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+\n+public class Prometheus {\n+  /**\n+   * install helm chart.\n+   * @param params the helm parameters like namespace, release name, repo url or chart dir,\n+   *               chart name and chart values to override\n+   * @return true on success, false otherwise\n+   */\n+  public static boolean install(PrometheusParams params) {\n+    return Helm.install(params.getHelmParams(), params.getValues());\n+  }\n+\n+  /**\n+   * Uninstall a helm release.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f53a37a1d6397f70bfaca98042e1b37b0e8d2c64"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4MTA4OA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436881088", "createdAt": "2020-06-08T17:39:53Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Prometheus.java", "diffHunk": "@@ -0,0 +1,29 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Helm;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+\n+public class Prometheus {\n+  /**\n+   * install helm chart.\n+   * @param params the helm parameters like namespace, release name, repo url or chart dir,\n+   *               chart name and chart values to override\n+   * @return true on success, false otherwise\n+   */\n+  public static boolean install(PrometheusParams params) {\n+    return Helm.install(params.getHelmParams(), params.getValues());\n+  }\n+\n+  /**\n+   * Uninstall a helm release.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgxODkwNg=="}, "originalCommit": {"oid": "f53a37a1d6397f70bfaca98042e1b37b0e8d2c64"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMTI2MDMxOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNjowMzozN1rOGglZow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNzo0MDowMlrOGgpHHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgyMDM4Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @throws ApiException when delete fails\n          \n          \n            \n               * @throws ApiException when create fails", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436820387", "createdAt": "2020-06-08T16:03:37Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -283,9 +283,34 @@ private static void initializeGenericKubernetesApiClients() {\n   }\n \n   // ------------------------  deployments -----------------------------------\n-  public static boolean createDeployment(String deploymentYaml) {\n-    // do something with the command!!!\n-    return true;\n+\n+  /**\n+   * Create a deployment.\n+   *\n+   * @param deployment V1Deployment object containing deployment configuration data\n+   * @return true if creation was successful\n+   * @throws ApiException when delete fails", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f53a37a1d6397f70bfaca98042e1b37b0e8d2c64"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4MTE4Mg==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436881182", "createdAt": "2020-06-08T17:40:02Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -283,9 +283,34 @@ private static void initializeGenericKubernetesApiClients() {\n   }\n \n   // ------------------------  deployments -----------------------------------\n-  public static boolean createDeployment(String deploymentYaml) {\n-    // do something with the command!!!\n-    return true;\n+\n+  /**\n+   * Create a deployment.\n+   *\n+   * @param deployment V1Deployment object containing deployment configuration data\n+   * @return true if creation was successful\n+   * @throws ApiException when delete fails", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgyMDM4Nw=="}, "originalCommit": {"oid": "f53a37a1d6397f70bfaca98042e1b37b0e8d2c64"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMTI2NTAyOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNjowNDo0OVrOGglcuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNzo0MDoxMFrOGgpHXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgyMTE3Nw==", "bodyText": "we don't need this message logged, it will be too much verbose messages when this gets called repeatedly", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436821177", "createdAt": "2020-06-08T16:04:49Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -448,6 +473,7 @@ public static boolean deletePod(String name, String namespace) {\n   public static V1Pod getPod(String namespace, String labelSelector, String podName) throws ApiException {\n     V1PodList pods = listPods(namespace, labelSelector);\n     for (var pod : pods.getItems()) {\n+      logger.info(\"Check for pod {0}\", pod.getMetadata().getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f53a37a1d6397f70bfaca98042e1b37b0e8d2c64"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4MTI0NA==", "bodyText": "removed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436881244", "createdAt": "2020-06-08T17:40:10Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -448,6 +473,7 @@ public static boolean deletePod(String name, String namespace) {\n   public static V1Pod getPod(String namespace, String labelSelector, String podName) throws ApiException {\n     V1PodList pods = listPods(namespace, labelSelector);\n     for (var pod : pods.getItems()) {\n+      logger.info(\"Check for pod {0}\", pod.getMetadata().getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgyMTE3Nw=="}, "originalCommit": {"oid": "f53a37a1d6397f70bfaca98042e1b37b0e8d2c64"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMTI2ODc5OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNjowNTo0MVrOGglfBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNzo0MDoyNFrOGgpH5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgyMTc2Ng==", "bodyText": "remove empty line", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436821766", "createdAt": "2020-06-08T16:05:41Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -450,6 +452,27 @@ public static boolean podStateNotChanged(String podName,\n   }\n \n   /**\n+   * Check if Prometheus is running.\n+   *\n+   * @param namespace in which is prometheus is running\n+   * @return true if running false otherwise\n+   */\n+  public static Callable<Boolean> isPrometheusReady(String namespace) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f53a37a1d6397f70bfaca98042e1b37b0e8d2c64"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4MTM4MQ==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436881381", "createdAt": "2020-06-08T17:40:24Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -450,6 +452,27 @@ public static boolean podStateNotChanged(String podName,\n   }\n \n   /**\n+   * Check if Prometheus is running.\n+   *\n+   * @param namespace in which is prometheus is running\n+   * @return true if running false otherwise\n+   */\n+  public static Callable<Boolean> isPrometheusReady(String namespace) {\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgyMTc2Ng=="}, "originalCommit": {"oid": "f53a37a1d6397f70bfaca98042e1b37b0e8d2c64"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMTI5NTUxOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNjoxMTo0NlrOGglvYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNzo0MDozOFrOGgpIYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgyNTk1Mw==", "bodyText": "Please replace the StringBuilder with this.\nlabelSelector = labels.entrySet() .stream() .map(e -> e.getKey() + \"=\" + e.getValue()) .collect(Collectors.joining(\",\"));", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436825953", "createdAt": "2020-06-08T16:11:46Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -122,29 +123,33 @@ public static boolean isPodRunning(String namespace, String domainUid, String po\n   }\n \n   /**\n-   * Checks if a pod is ready in a given namespace.\n-   *\n-   * @param namespace in which to check if the pod is ready\n-   * @param domainUid the label the pod is decorated with\n-   * @param podName name of the pod to check for\n-   * @return true if the pod is in the ready condition, false otherwise\n-   * @throws ApiException if Kubernetes client API call fails\n+\n+   Checks if a pod is ready in a given namespace.\n+   @param namespace in which to check if the pod is ready\n+   @param labels map of labels as key value pairs\n+   @param podName name of the pod to check for\n+   @return true if the pod is in the ready condition, false otherwise\n+   @throws ApiException if Kubernetes client API call fails\n    */\n-  public static boolean isPodReady(String namespace, String domainUid, String podName) throws ApiException {\n+  public static boolean isPodReady(String namespace, Map<String, String> labels, String podName) throws ApiException {\n     boolean status = false;\n     String labelSelector = null;\n-    if (domainUid != null) {\n-      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    if (labels != null && !labels.isEmpty()) {\n+      StringBuilder str = new StringBuilder();\n+      for (Map.Entry<String, String> entry : labels.entrySet()) {\n+        str.append(entry.getKey()).append(\"=\").append(entry.getValue()).append(\",\");\n+      }\n+      //concat last ','\n+      labelSelector = str.toString().substring(0, str.toString().length() - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f53a37a1d6397f70bfaca98042e1b37b0e8d2c64"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4MTUwNQ==", "bodyText": "replaced", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436881505", "createdAt": "2020-06-08T17:40:38Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -122,29 +123,33 @@ public static boolean isPodRunning(String namespace, String domainUid, String po\n   }\n \n   /**\n-   * Checks if a pod is ready in a given namespace.\n-   *\n-   * @param namespace in which to check if the pod is ready\n-   * @param domainUid the label the pod is decorated with\n-   * @param podName name of the pod to check for\n-   * @return true if the pod is in the ready condition, false otherwise\n-   * @throws ApiException if Kubernetes client API call fails\n+\n+   Checks if a pod is ready in a given namespace.\n+   @param namespace in which to check if the pod is ready\n+   @param labels map of labels as key value pairs\n+   @param podName name of the pod to check for\n+   @return true if the pod is in the ready condition, false otherwise\n+   @throws ApiException if Kubernetes client API call fails\n    */\n-  public static boolean isPodReady(String namespace, String domainUid, String podName) throws ApiException {\n+  public static boolean isPodReady(String namespace, Map<String, String> labels, String podName) throws ApiException {\n     boolean status = false;\n     String labelSelector = null;\n-    if (domainUid != null) {\n-      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    if (labels != null && !labels.isEmpty()) {\n+      StringBuilder str = new StringBuilder();\n+      for (Map.Entry<String, String> entry : labels.entrySet()) {\n+        str.append(entry.getKey()).append(\"=\").append(entry.getValue()).append(\",\");\n+      }\n+      //concat last ','\n+      labelSelector = str.toString().substring(0, str.toString().length() - 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgyNTk1Mw=="}, "originalCommit": {"oid": "f53a37a1d6397f70bfaca98042e1b37b0e8d2c64"}, "originalPosition": 39}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4297, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}