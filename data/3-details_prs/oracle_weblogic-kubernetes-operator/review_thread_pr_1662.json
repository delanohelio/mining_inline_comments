{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5NjE0ODcw", "number": 1662, "reviewThreads": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNjo1NTo0N1rOD9el6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxOToxOTo0NVrOD98FhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzkwOTU0OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNjo1NTo0N1rOGW_zcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjozOToyMFrOGXJvag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc2NzIxOA==", "bodyText": "Ideally, the operator should bring up all servers in the new cluster concurrently - without 'rolling' them.  I don't know how to check this except perhaps to have the new server be a two server cluster and verify that its second server starts before its first server becomes 'ready'.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r426767218", "createdAt": "2020-05-18T16:55:47Z", "author": {"login": "tbarnes-us"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,884 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+\n+    // This test uses the WebLogic domain created BeforeAll method\n+    // BeforeEach method make sure the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    List<String> managedServerPodOriginalTimestampList = new ArrayList<>();\n+    for (int i = 1; i <= replicaCount; i++) {\n+      final String managedServerPodName = managedServerPrefix + i;\n+      managedServerPodOriginalTimestampList.add(\n+          assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", managedServerPodName),\n+              String.format(\"getPodCreationTimestamp failed with ApiException for pod %s in namespace %s\",\n+                  managedServerPodName, domainNamespace)));\n+    }\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+\n+    // Check if the admin server pod has been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    checkPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime);\n+\n+    // Check if the managed server pods have been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodRestarted(managedServerPrefix + 1, domainUid, \n+           domainNamespace, managedServerPodOriginalTimestampList.get(i - 1));\n+    }\n+\n+    // The ServerNamePrefix for the new dynamic cluster is dynamic-server\n+    // Make sure the managed server from the new cluster is running\n+    \n+    String newServerPodName = domainUid + \"-dynamic-server1\";\n+    checkPodCreated(newServerPodName, domainUid, domainNamespace);\n+    checkPodReady(newServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(newServerPodName, domainNamespace);\n+\n+    boolean isServerConfigured = checkManagedServerConfiguration(\"dynamic-server1\");\n+    assertTrue(isServerConfigured, \"Could not find new managed server configuration\");\n+    logger.info(\"Found new managed server configuration\");\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a configured cluster.\n+   * Patch the domain resource with the configmap.\n+   * Update the restart version of the domain resource to 3\n+   * Patch the domain resource with the spec/replicas set to 1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4aba885a2661b12ff2b296f7dbd4df4b7f99d06"}, "originalPosition": 432}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3MjE0Mg==", "bodyText": "The usecase makes sure that a new cluster configuration is added to the domain and all the servers are up and running. Since I patch domain resource with the spec/replicas set to 1, only one server from the new cluster comes up.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r426772142", "createdAt": "2020-05-18T17:04:49Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,884 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+\n+    // This test uses the WebLogic domain created BeforeAll method\n+    // BeforeEach method make sure the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    List<String> managedServerPodOriginalTimestampList = new ArrayList<>();\n+    for (int i = 1; i <= replicaCount; i++) {\n+      final String managedServerPodName = managedServerPrefix + i;\n+      managedServerPodOriginalTimestampList.add(\n+          assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", managedServerPodName),\n+              String.format(\"getPodCreationTimestamp failed with ApiException for pod %s in namespace %s\",\n+                  managedServerPodName, domainNamespace)));\n+    }\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+\n+    // Check if the admin server pod has been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    checkPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime);\n+\n+    // Check if the managed server pods have been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodRestarted(managedServerPrefix + 1, domainUid, \n+           domainNamespace, managedServerPodOriginalTimestampList.get(i - 1));\n+    }\n+\n+    // The ServerNamePrefix for the new dynamic cluster is dynamic-server\n+    // Make sure the managed server from the new cluster is running\n+    \n+    String newServerPodName = domainUid + \"-dynamic-server1\";\n+    checkPodCreated(newServerPodName, domainUid, domainNamespace);\n+    checkPodReady(newServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(newServerPodName, domainNamespace);\n+\n+    boolean isServerConfigured = checkManagedServerConfiguration(\"dynamic-server1\");\n+    assertTrue(isServerConfigured, \"Could not find new managed server configuration\");\n+    logger.info(\"Found new managed server configuration\");\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a configured cluster.\n+   * Patch the domain resource with the configmap.\n+   * Update the restart version of the domain resource to 3\n+   * Patch the domain resource with the spec/replicas set to 1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc2NzIxOA=="}, "originalCommit": {"oid": "b4aba885a2661b12ff2b296f7dbd4df4b7f99d06"}, "originalPosition": 432}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3NzkwMQ==", "bodyText": "That's my point.  If you bring up two servers, you can test if the operator is bringing them up in parallel - as expected.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r426777901", "createdAt": "2020-05-18T17:15:30Z", "author": {"login": "tbarnes-us"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,884 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+\n+    // This test uses the WebLogic domain created BeforeAll method\n+    // BeforeEach method make sure the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    List<String> managedServerPodOriginalTimestampList = new ArrayList<>();\n+    for (int i = 1; i <= replicaCount; i++) {\n+      final String managedServerPodName = managedServerPrefix + i;\n+      managedServerPodOriginalTimestampList.add(\n+          assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", managedServerPodName),\n+              String.format(\"getPodCreationTimestamp failed with ApiException for pod %s in namespace %s\",\n+                  managedServerPodName, domainNamespace)));\n+    }\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+\n+    // Check if the admin server pod has been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    checkPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime);\n+\n+    // Check if the managed server pods have been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodRestarted(managedServerPrefix + 1, domainUid, \n+           domainNamespace, managedServerPodOriginalTimestampList.get(i - 1));\n+    }\n+\n+    // The ServerNamePrefix for the new dynamic cluster is dynamic-server\n+    // Make sure the managed server from the new cluster is running\n+    \n+    String newServerPodName = domainUid + \"-dynamic-server1\";\n+    checkPodCreated(newServerPodName, domainUid, domainNamespace);\n+    checkPodReady(newServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(newServerPodName, domainNamespace);\n+\n+    boolean isServerConfigured = checkManagedServerConfiguration(\"dynamic-server1\");\n+    assertTrue(isServerConfigured, \"Could not find new managed server configuration\");\n+    logger.info(\"Found new managed server configuration\");\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a configured cluster.\n+   * Patch the domain resource with the configmap.\n+   * Update the restart version of the domain resource to 3\n+   * Patch the domain resource with the spec/replicas set to 1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc2NzIxOA=="}, "originalCommit": {"oid": "b4aba885a2661b12ff2b296f7dbd4df4b7f99d06"}, "originalPosition": 432}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzMDAyNg==", "bodyText": "All the managed servers should be stated in parallel when the managed servers are started in any model.  So this is not an MII specific behavior. We can track the verification of this use case as a generic pod lifecycle test.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r426930026", "createdAt": "2020-05-18T22:39:20Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,884 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+\n+    // This test uses the WebLogic domain created BeforeAll method\n+    // BeforeEach method make sure the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    List<String> managedServerPodOriginalTimestampList = new ArrayList<>();\n+    for (int i = 1; i <= replicaCount; i++) {\n+      final String managedServerPodName = managedServerPrefix + i;\n+      managedServerPodOriginalTimestampList.add(\n+          assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", managedServerPodName),\n+              String.format(\"getPodCreationTimestamp failed with ApiException for pod %s in namespace %s\",\n+                  managedServerPodName, domainNamespace)));\n+    }\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+\n+    // Check if the admin server pod has been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    checkPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime);\n+\n+    // Check if the managed server pods have been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodRestarted(managedServerPrefix + 1, domainUid, \n+           domainNamespace, managedServerPodOriginalTimestampList.get(i - 1));\n+    }\n+\n+    // The ServerNamePrefix for the new dynamic cluster is dynamic-server\n+    // Make sure the managed server from the new cluster is running\n+    \n+    String newServerPodName = domainUid + \"-dynamic-server1\";\n+    checkPodCreated(newServerPodName, domainUid, domainNamespace);\n+    checkPodReady(newServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(newServerPodName, domainNamespace);\n+\n+    boolean isServerConfigured = checkManagedServerConfiguration(\"dynamic-server1\");\n+    assertTrue(isServerConfigured, \"Could not find new managed server configuration\");\n+    logger.info(\"Found new managed server configuration\");\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a configured cluster.\n+   * Patch the domain resource with the configmap.\n+   * Update the restart version of the domain resource to 3\n+   * Patch the domain resource with the spec/replicas set to 1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc2NzIxOA=="}, "originalCommit": {"oid": "b4aba885a2661b12ff2b296f7dbd4df4b7f99d06"}, "originalPosition": 432}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODgxMjc3OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMTo1MDozMVrOGXIqEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjozOTo0M1rOGXJv3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkxMjI3Mw==", "bodyText": "imported twice", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r426912273", "createdAt": "2020-05-18T21:50:31Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,884 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Order;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4aba885a2661b12ff2b296f7dbd4df4b7f99d06"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzMDE0Mg==", "bodyText": "Removed the duplicate import", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r426930142", "createdAt": "2020-05-18T22:39:43Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,884 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Order;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkxMjI3Mw=="}, "originalCommit": {"oid": "b4aba885a2661b12ff2b296f7dbd4df4b7f99d06"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODgyMzY5OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMTo1NDo1MVrOGXIw4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMTo1NDo1MVrOGXIw4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkxNDAxOA==", "bodyText": "It is already defined globally, line # 107", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r426914018", "createdAt": "2020-05-18T21:54:51Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,884 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4aba885a2661b12ff2b296f7dbd4df4b7f99d06"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODgyNDgwOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMTo1NToxNFrOGXIxjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjo0MTo1M1rOGXJy4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkxNDE5MA==", "bodyText": "where is this used?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r426914190", "createdAt": "2020-05-18T21:55:14Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,884 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4aba885a2661b12ff2b296f7dbd4df4b7f99d06"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzMDkxNA==", "bodyText": "Removed the method checkServerReadyStatusByExec() that uses the string", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r426930914", "createdAt": "2020-05-18T22:41:53Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,884 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkxNDE5MA=="}, "originalCommit": {"oid": "b4aba885a2661b12ff2b296f7dbd4df4b7f99d06"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODgzMDIwOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMTo1NzozNlrOGXI0_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMzowMTowMlrOGXKM-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkxNTA3MA==", "bodyText": "make the above as final", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r426915070", "createdAt": "2020-05-18T21:57:36Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,884 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4aba885a2661b12ff2b296f7dbd4df4b7f99d06"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzNzU5NA==", "bodyText": "changed to  private static final String domainUid = \"miiaddcluster\";", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r426937594", "createdAt": "2020-05-18T23:01:02Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,884 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkxNTA3MA=="}, "originalCommit": {"oid": "b4aba885a2661b12ff2b296f7dbd4df4b7f99d06"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODg3MDU2OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjoxNDozNFrOGXJNhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMzo0MzozOFrOGXK_sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMTM1MA==", "bodyText": "You don't need any of the above in this method. A simple podReady and serviceCreated check is good enough.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r426921350", "createdAt": "2020-05-18T22:14:34Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,884 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4aba885a2661b12ff2b296f7dbd4df4b7f99d06"}, "originalPosition": 279}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk1MDU3Nw==", "bodyText": "Removed the externeous checking", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r426950577", "createdAt": "2020-05-18T23:43:38Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,884 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMTM1MA=="}, "originalCommit": {"oid": "b4aba885a2661b12ff2b296f7dbd4df4b7f99d06"}, "originalPosition": 279}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODg3MjYxOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjoxNToyMlrOGXJOrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjo1MDo0MlrOGXJ-nA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMTY0Nw==", "bodyText": "can you put 1st test here? just for the sake of readability", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r426921647", "createdAt": "2020-05-18T22:15:22Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,884 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4aba885a2661b12ff2b296f7dbd4df4b7f99d06"}, "originalPosition": 317}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzMzkxNg==", "bodyText": "done", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r426933916", "createdAt": "2020-05-18T22:50:42Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,884 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMTY0Nw=="}, "originalCommit": {"oid": "b4aba885a2661b12ff2b296f7dbd4df4b7f99d06"}, "originalPosition": 317}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODg4MDU4OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjoxODozMVrOGXJTZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjo1MjowNlrOGXKAnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMjg1NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // This test uses the WebLogic domain created BeforeAll method\n          \n          \n            \n                // This test uses the WebLogic domain created in BeforeAll method", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r426922854", "createdAt": "2020-05-18T22:18:31Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,884 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+\n+    // This test uses the WebLogic domain created BeforeAll method", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4aba885a2661b12ff2b296f7dbd4df4b7f99d06"}, "originalPosition": 323}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzNDQyOA==", "bodyText": "done", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r426934428", "createdAt": "2020-05-18T22:52:06Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,884 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+\n+    // This test uses the WebLogic domain created BeforeAll method", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMjg1NA=="}, "originalCommit": {"oid": "b4aba885a2661b12ff2b296f7dbd4df4b7f99d06"}, "originalPosition": 323}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODg4MjQ5OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjoxOToyMVrOGXJUmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjo1MzozNlrOGXKCyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMzE2Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // BeforeEach method make sure the server pods are running\n          \n          \n            \n                // BeforeEach method ensures that the server pods are running", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r426923163", "createdAt": "2020-05-18T22:19:21Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,884 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+\n+    // This test uses the WebLogic domain created BeforeAll method\n+    // BeforeEach method make sure the server pods are running", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4aba885a2661b12ff2b296f7dbd4df4b7f99d06"}, "originalPosition": 324}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzNDk4NQ==", "bodyText": "done", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r426934985", "createdAt": "2020-05-18T22:53:36Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,884 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+\n+    // This test uses the WebLogic domain created BeforeAll method\n+    // BeforeEach method make sure the server pods are running", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMzE2Mw=="}, "originalCommit": {"oid": "b4aba885a2661b12ff2b296f7dbd4df4b7f99d06"}, "originalPosition": 324}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODg4ODAxOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjoyMToyNFrOGXJXmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjo1NTo1MVrOGXKFsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMzkzMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String.format(\"createConfigMap failed for %s\", configMapName));\n          \n          \n            \n                    String.format(\"createConfigMap %s failed\", configMapName));", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r426923931", "createdAt": "2020-05-18T22:21:24Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,884 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+\n+    // This test uses the WebLogic domain created BeforeAll method\n+    // BeforeEach method make sure the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4aba885a2661b12ff2b296f7dbd4df4b7f99d06"}, "originalPosition": 346}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzNTcyOA==", "bodyText": "Modified --> Sring.format(\"Can't create ConfigMap %s\", configMapName));", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r426935728", "createdAt": "2020-05-18T22:55:51Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,884 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+\n+    // This test uses the WebLogic domain created BeforeAll method\n+    // BeforeEach method make sure the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMzkzMQ=="}, "originalCommit": {"oid": "b4aba885a2661b12ff2b296f7dbd4df4b7f99d06"}, "originalPosition": 346}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODg5MTM1OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjoyMjo1MVrOGXJZgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjo1Njo0N1rOGXKG9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyNDQxOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n          \n          \n            \n                assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns null\");", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r426924419", "createdAt": "2020-05-18T22:22:51Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,884 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+\n+    // This test uses the WebLogic domain created BeforeAll method\n+    // BeforeEach method make sure the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4aba885a2661b12ff2b296f7dbd4df4b7f99d06"}, "originalPosition": 352}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzNjA1NQ==", "bodyText": "NULL->null", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r426936055", "createdAt": "2020-05-18T22:56:47Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,884 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+\n+    // This test uses the WebLogic domain created BeforeAll method\n+    // BeforeEach method make sure the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyNDQxOQ=="}, "originalCommit": {"oid": "b4aba885a2661b12ff2b296f7dbd4df4b7f99d06"}, "originalPosition": 352}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODg5MjM3OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjoyMzoxM1rOGXJaEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjo1ODozM1rOGXKJrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyNDU2MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n          \n          \n            \n                        String.format(\"Couldn't get PodCreationTime for pod %s\", adminServerPodName));", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r426924561", "createdAt": "2020-05-18T22:23:13Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,884 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+\n+    // This test uses the WebLogic domain created BeforeAll method\n+    // BeforeEach method make sure the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4aba885a2661b12ff2b296f7dbd4df4b7f99d06"}, "originalPosition": 351}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzNjc0OA==", "bodyText": "Can not find  --> Couldn't get", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r426936748", "createdAt": "2020-05-18T22:58:33Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,884 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+\n+    // This test uses the WebLogic domain created BeforeAll method\n+    // BeforeEach method make sure the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyNDU2MQ=="}, "originalCommit": {"oid": "b4aba885a2661b12ff2b296f7dbd4df4b7f99d06"}, "originalPosition": 351}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjM1OTAxOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzozNjo0M1rOGXrVSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOToxMjozNlrOGYaPYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4MDM5NQ==", "bodyText": "use the methods added in CommonTestUtils.java", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r427480395", "createdAt": "2020-05-19T17:36:43Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,843 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static final String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cc09a2b5ca18cf470227b1e81a436ae136d4594"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI0ODkyOA==", "bodyText": "will do in next round of enhancement.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r428248928", "createdAt": "2020-05-20T19:12:36Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,843 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static final String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4MDM5NQ=="}, "originalCommit": {"oid": "2cc09a2b5ca18cf470227b1e81a436ae136d4594"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjM2NzI5OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzozODo1M1rOGXraWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOToxMjo0MlrOGYaPmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4MTY4OQ==", "bodyText": "call the methods added in CommonTestUtils.java", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r427481689", "createdAt": "2020-05-19T17:38:53Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,843 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static final String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cc09a2b5ca18cf470227b1e81a436ae136d4594"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI0ODk4Ng==", "bodyText": "will do in next round of enhancement.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r428248986", "createdAt": "2020-05-20T19:12:42Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,843 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static final String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4MTY4OQ=="}, "originalCommit": {"oid": "2cc09a2b5ca18cf470227b1e81a436ae136d4594"}, "originalPosition": 226}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjQxNzM2OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzo1MTozM1rOGXr6lA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMToxMzozNlrOGX37sA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4OTk0MA==", "bodyText": "can you create a common method which curl's the given url and returns the response code..there lot of curl statements in the test ...method will take just the url", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r427489940", "createdAt": "2020-05-19T17:51:33Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -321,25 +346,80 @@ public void testCreateMiiConfigMapDomain() {\n     }\n \n     int adminServiceNodePort = getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n-    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    ExecResult result = null;\n+    checkJdbc = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+    checkJdbc.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+         .append(\"/management/weblogic/latest/domainConfig\")\n+         .append(\"/JDBCSystemResources/TestDataSource/\")\n+         .append(\" --silent --show-error \")\n+         .append(\" -o /dev/null \")\n+         .append(\" -w %{http_code});\")\n+         .append(\"echo ${status}\");\n+    logger.info(\"CheckJdbc: curl command {0}\", new String(checkJdbc));\n+    try {\n+      result = exec(new String(checkJdbc), true);\n+    } catch (Exception ex) {\n+      logger.info(\"CheckJdbc: caught unexpected exception {0}\", ex);\n+      fail(\"CheckJdbc:  got unexpected exception\" + ex);\n+    }\n+    logger.info(\"CheckJdbc: curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"DataSource configuration not found\");\n+    logger.info(\"Found the DataSource configuration\");\n+\n+    checkJdbcRuntime = new StringBuffer(\"curl --user weblogic:welcome1 \");\n+    checkJdbcRuntime.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+         .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+         .append(\" --silent --show-error \");\n+    logger.info(\"checkJdbcRuntime: curl command {0}\", new String(checkJdbcRuntime));\n     try {\n-      checkJdbc = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n-      checkJdbc.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n-          .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+      result = exec(new String(checkJdbcRuntime), true);\n+    } catch (Exception ex) {\n+      logger.info(\"checkJdbcRuntime: caught unexpected exception {0}\", ex);\n+      fail(\"checkJdbcRuntime:  got unexpected exception\" + ex);\n+    }\n+    logger.info(\"checkJdbcRuntime: curl command returns {0}\", result.toString());\n+    assertTrue(result.stdout().contains(\"jdbc:oracle:thin:localhost\"),\n+         String.format(\"Overriden Database URL not found on RuntimeMBean\"));\n+    assertTrue(result.stdout().contains(\"scott\"),\n+         String.format(\"Overriden Database user not found on RuntimeMBean\"));\n+\n+    checkJms = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+    checkJms.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/weblogic/latest/domainConfig\")\n+          .append(\"/JMSSystemResources/TestClusterJmsModule/\")\n           .append(\" --silent --show-error \")\n           .append(\" -o /dev/null \")\n           .append(\" -w %{http_code});\")\n           .append(\"echo ${status}\");\n-      logger.info(\"curl command {0}\", new String(checkJdbc));\n-      result = exec(new String(checkJdbc), true);\n+    logger.info(\"CheckJms: curl command {0}\", new String(checkJms));\n+    try {\n+      result = exec(new String(checkJms), true);\n     } catch (Exception ex) {\n-      logger.info(\"Caught unexpected exception {0}\", ex);\n-      fail(\"Got unexpected exception\" + ex);\n+      logger.info(\"CheckJms: caught unexpected exception {0}\", ex);\n+      fail(\"CheckJms:  got unexpected exception\" + ex);\n     }\n-\n-    logger.info(\"curl command returns {0}\", result.toString());\n-    assertEquals(\"200\", result.stdout(), \"DataSource configuration not found\");\n-    logger.info(\"Found the DataSource configuration \");\n+    logger.info(\"CheckJms: curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"JMSSystemResources configuration not found\");\n+    logger.info(\"Found the JMSSystemResources configuration\");\n+\n+    checkWldf = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+    checkWldf.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/weblogic/latest/domainConfig\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cc09a2b5ca18cf470227b1e81a436ae136d4594"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4NjgzMg==", "bodyText": "Added a new private method to verify curl commad\nprivate ExecResult checkSystemResourceConfiguration(String resourcesType, String resourcesName)", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r427686832", "createdAt": "2020-05-20T01:13:36Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -321,25 +346,80 @@ public void testCreateMiiConfigMapDomain() {\n     }\n \n     int adminServiceNodePort = getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n-    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    ExecResult result = null;\n+    checkJdbc = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+    checkJdbc.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+         .append(\"/management/weblogic/latest/domainConfig\")\n+         .append(\"/JDBCSystemResources/TestDataSource/\")\n+         .append(\" --silent --show-error \")\n+         .append(\" -o /dev/null \")\n+         .append(\" -w %{http_code});\")\n+         .append(\"echo ${status}\");\n+    logger.info(\"CheckJdbc: curl command {0}\", new String(checkJdbc));\n+    try {\n+      result = exec(new String(checkJdbc), true);\n+    } catch (Exception ex) {\n+      logger.info(\"CheckJdbc: caught unexpected exception {0}\", ex);\n+      fail(\"CheckJdbc:  got unexpected exception\" + ex);\n+    }\n+    logger.info(\"CheckJdbc: curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"DataSource configuration not found\");\n+    logger.info(\"Found the DataSource configuration\");\n+\n+    checkJdbcRuntime = new StringBuffer(\"curl --user weblogic:welcome1 \");\n+    checkJdbcRuntime.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+         .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+         .append(\" --silent --show-error \");\n+    logger.info(\"checkJdbcRuntime: curl command {0}\", new String(checkJdbcRuntime));\n     try {\n-      checkJdbc = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n-      checkJdbc.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n-          .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+      result = exec(new String(checkJdbcRuntime), true);\n+    } catch (Exception ex) {\n+      logger.info(\"checkJdbcRuntime: caught unexpected exception {0}\", ex);\n+      fail(\"checkJdbcRuntime:  got unexpected exception\" + ex);\n+    }\n+    logger.info(\"checkJdbcRuntime: curl command returns {0}\", result.toString());\n+    assertTrue(result.stdout().contains(\"jdbc:oracle:thin:localhost\"),\n+         String.format(\"Overriden Database URL not found on RuntimeMBean\"));\n+    assertTrue(result.stdout().contains(\"scott\"),\n+         String.format(\"Overriden Database user not found on RuntimeMBean\"));\n+\n+    checkJms = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+    checkJms.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/weblogic/latest/domainConfig\")\n+          .append(\"/JMSSystemResources/TestClusterJmsModule/\")\n           .append(\" --silent --show-error \")\n           .append(\" -o /dev/null \")\n           .append(\" -w %{http_code});\")\n           .append(\"echo ${status}\");\n-      logger.info(\"curl command {0}\", new String(checkJdbc));\n-      result = exec(new String(checkJdbc), true);\n+    logger.info(\"CheckJms: curl command {0}\", new String(checkJms));\n+    try {\n+      result = exec(new String(checkJms), true);\n     } catch (Exception ex) {\n-      logger.info(\"Caught unexpected exception {0}\", ex);\n-      fail(\"Got unexpected exception\" + ex);\n+      logger.info(\"CheckJms: caught unexpected exception {0}\", ex);\n+      fail(\"CheckJms:  got unexpected exception\" + ex);\n     }\n-\n-    logger.info(\"curl command returns {0}\", result.toString());\n-    assertEquals(\"200\", result.stdout(), \"DataSource configuration not found\");\n-    logger.info(\"Found the DataSource configuration \");\n+    logger.info(\"CheckJms: curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"JMSSystemResources configuration not found\");\n+    logger.info(\"Found the JMSSystemResources configuration\");\n+\n+    checkWldf = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+    checkWldf.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/weblogic/latest/domainConfig\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4OTk0MA=="}, "originalCommit": {"oid": "2cc09a2b5ca18cf470227b1e81a436ae136d4594"}, "originalPosition": 186}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjY5Mzk5OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxOTowNjowOFrOGXuplQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxOToyNjo0MlrOGXvXPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzNDc0MQ==", "bodyText": "Fix the restart version, the test # 1 restart version is 4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r427534741", "createdAt": "2020-05-19T19:06:08Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,879 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static final String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+  }\n+\n+  /**\n+   * Patch the domain resource with the configmap to add a cluster.\n+   * Update the restart version of the domain resource to 4\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are not in running state, because the spec level replica count to zero(default)\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Add a cluster to model in image domain with default replica count\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiClusteriWithNoReplica() {\n+\n+    // This test uses the WebLogic domain created in BeforeAll method\n+    // BeforeEach method ensures that the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.config.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"noreplicaconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.config.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Can't create ConfigMap %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // get the creation time of the admin server pod before patching\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodCreationTime);\n+\n+    // get the creation time of the managed server pods before patching\n+    List<String> managedServerPodOriginalTimestampList = new ArrayList<>();\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            managedServerPodOriginalTimestampList.add(creationTime);\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"4\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+\n+    // Check if the admin server pod has been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    checkPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime);\n+\n+    // Check if the managed server pods have been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodRestarted(managedServerPrefix + 1, domainUid, \n+           domainNamespace, managedServerPodOriginalTimestampList.get(i - 1));\n+    }\n+\n+    // The ServerNamePrefix for the new configured cluster is config-server\n+    // Make sure the managed server from new cluster is not running\n+\n+    String newServerPodName = domainUid + \"-config-server1\";\n+    checkPodNotCreated(newServerPodName, domainUid, domainNamespace);\n+\n+    boolean isServerConfigured = checkManagedServerConfiguration(\"config-server1\");\n+    assertTrue(isServerConfigured, \"Could not find new managed server configuration\");\n+    logger.info(\"Found new managed server configuration\");\n+  }\n+\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+\n+    // This test uses the WebLogic domain created in BeforeAll method\n+    // BeforeEach method ensures that the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Can't create ConfigMap %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // get the creation time of the admin server pod before patching\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodCreationTime);\n+\n+    // get the creation time of the managed server pods before patching\n+    List<String> managedServerPodOriginalTimestampList = new ArrayList<>();\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            managedServerPodOriginalTimestampList.add(creationTime);\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47e999c250c8ce606710d6daea9610cb16fd99f6"}, "originalPosition": 499}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU0NjQzMQ==", "bodyText": "Modified the restart version as same as @order value.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r427546431", "createdAt": "2020-05-19T19:26:42Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,879 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static final String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+  }\n+\n+  /**\n+   * Patch the domain resource with the configmap to add a cluster.\n+   * Update the restart version of the domain resource to 4\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are not in running state, because the spec level replica count to zero(default)\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Add a cluster to model in image domain with default replica count\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiClusteriWithNoReplica() {\n+\n+    // This test uses the WebLogic domain created in BeforeAll method\n+    // BeforeEach method ensures that the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.config.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"noreplicaconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.config.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Can't create ConfigMap %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // get the creation time of the admin server pod before patching\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodCreationTime);\n+\n+    // get the creation time of the managed server pods before patching\n+    List<String> managedServerPodOriginalTimestampList = new ArrayList<>();\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            managedServerPodOriginalTimestampList.add(creationTime);\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"4\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+\n+    // Check if the admin server pod has been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    checkPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime);\n+\n+    // Check if the managed server pods have been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodRestarted(managedServerPrefix + 1, domainUid, \n+           domainNamespace, managedServerPodOriginalTimestampList.get(i - 1));\n+    }\n+\n+    // The ServerNamePrefix for the new configured cluster is config-server\n+    // Make sure the managed server from new cluster is not running\n+\n+    String newServerPodName = domainUid + \"-config-server1\";\n+    checkPodNotCreated(newServerPodName, domainUid, domainNamespace);\n+\n+    boolean isServerConfigured = checkManagedServerConfiguration(\"config-server1\");\n+    assertTrue(isServerConfigured, \"Could not find new managed server configuration\");\n+    logger.info(\"Found new managed server configuration\");\n+  }\n+\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+\n+    // This test uses the WebLogic domain created in BeforeAll method\n+    // BeforeEach method ensures that the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Can't create ConfigMap %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // get the creation time of the admin server pod before patching\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodCreationTime);\n+\n+    // get the creation time of the managed server pods before patching\n+    List<String> managedServerPodOriginalTimestampList = new ArrayList<>();\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            managedServerPodOriginalTimestampList.add(creationTime);\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzNDc0MQ=="}, "originalCommit": {"oid": "47e999c250c8ce606710d6daea9610cb16fd99f6"}, "originalPosition": 499}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjcxMzg1OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxOToxMToyN1rOGXu18w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMzoxMDozNlrOGX1vJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzNzkwNw==", "bodyText": "Between line # 562 to here the code seems to be common in all test methods. Can you put this in a private method in this class?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r427537907", "createdAt": "2020-05-19T19:11:27Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,879 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static final String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+  }\n+\n+  /**\n+   * Patch the domain resource with the configmap to add a cluster.\n+   * Update the restart version of the domain resource to 4\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are not in running state, because the spec level replica count to zero(default)\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Add a cluster to model in image domain with default replica count\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiClusteriWithNoReplica() {\n+\n+    // This test uses the WebLogic domain created in BeforeAll method\n+    // BeforeEach method ensures that the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.config.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"noreplicaconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.config.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Can't create ConfigMap %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // get the creation time of the admin server pod before patching\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodCreationTime);\n+\n+    // get the creation time of the managed server pods before patching\n+    List<String> managedServerPodOriginalTimestampList = new ArrayList<>();\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            managedServerPodOriginalTimestampList.add(creationTime);\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"4\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+\n+    // Check if the admin server pod has been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    checkPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime);\n+\n+    // Check if the managed server pods have been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodRestarted(managedServerPrefix + 1, domainUid, \n+           domainNamespace, managedServerPodOriginalTimestampList.get(i - 1));\n+    }\n+\n+    // The ServerNamePrefix for the new configured cluster is config-server\n+    // Make sure the managed server from new cluster is not running\n+\n+    String newServerPodName = domainUid + \"-config-server1\";\n+    checkPodNotCreated(newServerPodName, domainUid, domainNamespace);\n+\n+    boolean isServerConfigured = checkManagedServerConfiguration(\"config-server1\");\n+    assertTrue(isServerConfigured, \"Could not find new managed server configuration\");\n+    logger.info(\"Found new managed server configuration\");\n+  }\n+\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+\n+    // This test uses the WebLogic domain created in BeforeAll method\n+    // BeforeEach method ensures that the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Can't create ConfigMap %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // get the creation time of the admin server pod before patching\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodCreationTime);\n+\n+    // get the creation time of the managed server pods before patching\n+    List<String> managedServerPodOriginalTimestampList = new ArrayList<>();\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            managedServerPodOriginalTimestampList.add(creationTime);\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+\n+    // Check if the admin server pod has been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    checkPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime);\n+\n+    // Check if the managed server pods have been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodRestarted(managedServerPrefix + 1, domainUid, \n+           domainNamespace, managedServerPodOriginalTimestampList.get(i - 1));\n+    }\n+\n+    // The ServerNamePrefix for the new dynamic cluster is dynamic-server\n+    // Make sure the managed server from the new cluster is running\n+    \n+    String newServerPodName = domainUid + \"-dynamic-server1\";\n+    checkPodCreated(newServerPodName, domainUid, domainNamespace);\n+    checkPodReady(newServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(newServerPodName, domainNamespace);\n+\n+    boolean isServerConfigured = checkManagedServerConfiguration(\"dynamic-server1\");\n+    assertTrue(isServerConfigured, \"Could not find new managed server configuration\");\n+    logger.info(\"Found new managed server configuration\");\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a configured cluster.\n+   * Patch the domain resource with the configmap.\n+   * Update the restart version of the domain resource to 3\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"Add a configured cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiConfiguredCluster() {\n+ \n+    // This test uses the WebLogic domain created in BeforeAll method\n+    // BeforeEach method ensures that the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.config.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"configclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.config.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Can't create ConfigMap %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // get the creation time of the admin server pod before patching\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodCreationTime);\n+\n+    // get the creation time of the managed server pods before patching\n+    List<String> managedServerPodOriginalTimestampList = new ArrayList<>();\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            managedServerPodOriginalTimestampList.add(creationTime);\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"3\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47e999c250c8ce606710d6daea9610cb16fd99f6"}, "originalPosition": 640}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY1MDg1Mg==", "bodyText": "created following two methods\nprivate String getadminPodCreationTime()\nprivate List getManagedServerPodTimestampList()", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r427650852", "createdAt": "2020-05-19T23:10:36Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,879 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static final String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+  }\n+\n+  /**\n+   * Patch the domain resource with the configmap to add a cluster.\n+   * Update the restart version of the domain resource to 4\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are not in running state, because the spec level replica count to zero(default)\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Add a cluster to model in image domain with default replica count\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiClusteriWithNoReplica() {\n+\n+    // This test uses the WebLogic domain created in BeforeAll method\n+    // BeforeEach method ensures that the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.config.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"noreplicaconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.config.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Can't create ConfigMap %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // get the creation time of the admin server pod before patching\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodCreationTime);\n+\n+    // get the creation time of the managed server pods before patching\n+    List<String> managedServerPodOriginalTimestampList = new ArrayList<>();\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            managedServerPodOriginalTimestampList.add(creationTime);\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"4\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+\n+    // Check if the admin server pod has been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    checkPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime);\n+\n+    // Check if the managed server pods have been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodRestarted(managedServerPrefix + 1, domainUid, \n+           domainNamespace, managedServerPodOriginalTimestampList.get(i - 1));\n+    }\n+\n+    // The ServerNamePrefix for the new configured cluster is config-server\n+    // Make sure the managed server from new cluster is not running\n+\n+    String newServerPodName = domainUid + \"-config-server1\";\n+    checkPodNotCreated(newServerPodName, domainUid, domainNamespace);\n+\n+    boolean isServerConfigured = checkManagedServerConfiguration(\"config-server1\");\n+    assertTrue(isServerConfigured, \"Could not find new managed server configuration\");\n+    logger.info(\"Found new managed server configuration\");\n+  }\n+\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+\n+    // This test uses the WebLogic domain created in BeforeAll method\n+    // BeforeEach method ensures that the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Can't create ConfigMap %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // get the creation time of the admin server pod before patching\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodCreationTime);\n+\n+    // get the creation time of the managed server pods before patching\n+    List<String> managedServerPodOriginalTimestampList = new ArrayList<>();\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            managedServerPodOriginalTimestampList.add(creationTime);\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+\n+    // Check if the admin server pod has been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    checkPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime);\n+\n+    // Check if the managed server pods have been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodRestarted(managedServerPrefix + 1, domainUid, \n+           domainNamespace, managedServerPodOriginalTimestampList.get(i - 1));\n+    }\n+\n+    // The ServerNamePrefix for the new dynamic cluster is dynamic-server\n+    // Make sure the managed server from the new cluster is running\n+    \n+    String newServerPodName = domainUid + \"-dynamic-server1\";\n+    checkPodCreated(newServerPodName, domainUid, domainNamespace);\n+    checkPodReady(newServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(newServerPodName, domainNamespace);\n+\n+    boolean isServerConfigured = checkManagedServerConfiguration(\"dynamic-server1\");\n+    assertTrue(isServerConfigured, \"Could not find new managed server configuration\");\n+    logger.info(\"Found new managed server configuration\");\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a configured cluster.\n+   * Patch the domain resource with the configmap.\n+   * Update the restart version of the domain resource to 3\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"Add a configured cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiConfiguredCluster() {\n+ \n+    // This test uses the WebLogic domain created in BeforeAll method\n+    // BeforeEach method ensures that the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.config.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"configclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.config.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Can't create ConfigMap %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // get the creation time of the admin server pod before patching\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodCreationTime);\n+\n+    // get the creation time of the managed server pods before patching\n+    List<String> managedServerPodOriginalTimestampList = new ArrayList<>();\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            managedServerPodOriginalTimestampList.add(creationTime);\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"3\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzNzkwNw=="}, "originalCommit": {"oid": "47e999c250c8ce606710d6daea9610cb16fd99f6"}, "originalPosition": 640}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjcxNjQ4OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxOToxMjoxM1rOGXu3qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDo0MjowNVrOGXx12A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzODM0Nw==", "bodyText": "where are you deleting the images that you have created?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r427538347", "createdAt": "2020-05-19T19:12:13Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,879 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static final String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+  }\n+\n+  /**\n+   * Patch the domain resource with the configmap to add a cluster.\n+   * Update the restart version of the domain resource to 4\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are not in running state, because the spec level replica count to zero(default)\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Add a cluster to model in image domain with default replica count\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiClusteriWithNoReplica() {\n+\n+    // This test uses the WebLogic domain created in BeforeAll method\n+    // BeforeEach method ensures that the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.config.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"noreplicaconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.config.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Can't create ConfigMap %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // get the creation time of the admin server pod before patching\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodCreationTime);\n+\n+    // get the creation time of the managed server pods before patching\n+    List<String> managedServerPodOriginalTimestampList = new ArrayList<>();\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            managedServerPodOriginalTimestampList.add(creationTime);\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"4\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+\n+    // Check if the admin server pod has been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    checkPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime);\n+\n+    // Check if the managed server pods have been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodRestarted(managedServerPrefix + 1, domainUid, \n+           domainNamespace, managedServerPodOriginalTimestampList.get(i - 1));\n+    }\n+\n+    // The ServerNamePrefix for the new configured cluster is config-server\n+    // Make sure the managed server from new cluster is not running\n+\n+    String newServerPodName = domainUid + \"-config-server1\";\n+    checkPodNotCreated(newServerPodName, domainUid, domainNamespace);\n+\n+    boolean isServerConfigured = checkManagedServerConfiguration(\"config-server1\");\n+    assertTrue(isServerConfigured, \"Could not find new managed server configuration\");\n+    logger.info(\"Found new managed server configuration\");\n+  }\n+\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+\n+    // This test uses the WebLogic domain created in BeforeAll method\n+    // BeforeEach method ensures that the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Can't create ConfigMap %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // get the creation time of the admin server pod before patching\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodCreationTime);\n+\n+    // get the creation time of the managed server pods before patching\n+    List<String> managedServerPodOriginalTimestampList = new ArrayList<>();\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            managedServerPodOriginalTimestampList.add(creationTime);\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+\n+    // Check if the admin server pod has been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    checkPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime);\n+\n+    // Check if the managed server pods have been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodRestarted(managedServerPrefix + 1, domainUid, \n+           domainNamespace, managedServerPodOriginalTimestampList.get(i - 1));\n+    }\n+\n+    // The ServerNamePrefix for the new dynamic cluster is dynamic-server\n+    // Make sure the managed server from the new cluster is running\n+    \n+    String newServerPodName = domainUid + \"-dynamic-server1\";\n+    checkPodCreated(newServerPodName, domainUid, domainNamespace);\n+    checkPodReady(newServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(newServerPodName, domainNamespace);\n+\n+    boolean isServerConfigured = checkManagedServerConfiguration(\"dynamic-server1\");\n+    assertTrue(isServerConfigured, \"Could not find new managed server configuration\");\n+    logger.info(\"Found new managed server configuration\");\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a configured cluster.\n+   * Patch the domain resource with the configmap.\n+   * Update the restart version of the domain resource to 3\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"Add a configured cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiConfiguredCluster() {\n+ \n+    // This test uses the WebLogic domain created in BeforeAll method\n+    // BeforeEach method ensures that the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.config.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"configclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.config.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Can't create ConfigMap %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // get the creation time of the admin server pod before patching\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodCreationTime);\n+\n+    // get the creation time of the managed server pods before patching\n+    List<String> managedServerPodOriginalTimestampList = new ArrayList<>();\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            managedServerPodOriginalTimestampList.add(creationTime);\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"3\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+\n+    // The ServerNamePrefix for the new configured cluster is config-server\n+    // Make sure the managed server from the new cluster is running\n+    \n+    String newServerPodName = domainUid + \"-config-server1\";\n+    checkPodCreated(newServerPodName, domainUid, domainNamespace);\n+    checkPodReady(newServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(newServerPodName, domainNamespace);\n+\n+    // Check if the admin server pod has been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    checkPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime);\n+\n+    // Check if the managed server pods have been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    \n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodRestarted(managedServerPrefix + 1, domainUid, \n+           domainNamespace, managedServerPodOriginalTimestampList.get(i - 1));\n+    }\n+\n+    boolean isServerConfigured = checkManagedServerConfiguration(\"config-server1\");\n+    assertTrue(isServerConfigured, \"Could not find new managed server configuration\");\n+    logger.info(\"Found new managed server configuration\");\n+\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47e999c250c8ce606710d6daea9610cb16fd99f6"}, "originalPosition": 676}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzODY2OA==", "bodyText": "If you are not deleting the images then you don't need this tearDown", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r427538668", "createdAt": "2020-05-19T19:12:45Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,879 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static final String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+  }\n+\n+  /**\n+   * Patch the domain resource with the configmap to add a cluster.\n+   * Update the restart version of the domain resource to 4\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are not in running state, because the spec level replica count to zero(default)\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Add a cluster to model in image domain with default replica count\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiClusteriWithNoReplica() {\n+\n+    // This test uses the WebLogic domain created in BeforeAll method\n+    // BeforeEach method ensures that the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.config.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"noreplicaconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.config.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Can't create ConfigMap %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // get the creation time of the admin server pod before patching\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodCreationTime);\n+\n+    // get the creation time of the managed server pods before patching\n+    List<String> managedServerPodOriginalTimestampList = new ArrayList<>();\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            managedServerPodOriginalTimestampList.add(creationTime);\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"4\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+\n+    // Check if the admin server pod has been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    checkPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime);\n+\n+    // Check if the managed server pods have been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodRestarted(managedServerPrefix + 1, domainUid, \n+           domainNamespace, managedServerPodOriginalTimestampList.get(i - 1));\n+    }\n+\n+    // The ServerNamePrefix for the new configured cluster is config-server\n+    // Make sure the managed server from new cluster is not running\n+\n+    String newServerPodName = domainUid + \"-config-server1\";\n+    checkPodNotCreated(newServerPodName, domainUid, domainNamespace);\n+\n+    boolean isServerConfigured = checkManagedServerConfiguration(\"config-server1\");\n+    assertTrue(isServerConfigured, \"Could not find new managed server configuration\");\n+    logger.info(\"Found new managed server configuration\");\n+  }\n+\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+\n+    // This test uses the WebLogic domain created in BeforeAll method\n+    // BeforeEach method ensures that the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Can't create ConfigMap %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // get the creation time of the admin server pod before patching\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodCreationTime);\n+\n+    // get the creation time of the managed server pods before patching\n+    List<String> managedServerPodOriginalTimestampList = new ArrayList<>();\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            managedServerPodOriginalTimestampList.add(creationTime);\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+\n+    // Check if the admin server pod has been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    checkPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime);\n+\n+    // Check if the managed server pods have been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodRestarted(managedServerPrefix + 1, domainUid, \n+           domainNamespace, managedServerPodOriginalTimestampList.get(i - 1));\n+    }\n+\n+    // The ServerNamePrefix for the new dynamic cluster is dynamic-server\n+    // Make sure the managed server from the new cluster is running\n+    \n+    String newServerPodName = domainUid + \"-dynamic-server1\";\n+    checkPodCreated(newServerPodName, domainUid, domainNamespace);\n+    checkPodReady(newServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(newServerPodName, domainNamespace);\n+\n+    boolean isServerConfigured = checkManagedServerConfiguration(\"dynamic-server1\");\n+    assertTrue(isServerConfigured, \"Could not find new managed server configuration\");\n+    logger.info(\"Found new managed server configuration\");\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a configured cluster.\n+   * Patch the domain resource with the configmap.\n+   * Update the restart version of the domain resource to 3\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"Add a configured cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiConfiguredCluster() {\n+ \n+    // This test uses the WebLogic domain created in BeforeAll method\n+    // BeforeEach method ensures that the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.config.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"configclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.config.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Can't create ConfigMap %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // get the creation time of the admin server pod before patching\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodCreationTime);\n+\n+    // get the creation time of the managed server pods before patching\n+    List<String> managedServerPodOriginalTimestampList = new ArrayList<>();\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            managedServerPodOriginalTimestampList.add(creationTime);\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"3\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+\n+    // The ServerNamePrefix for the new configured cluster is config-server\n+    // Make sure the managed server from the new cluster is running\n+    \n+    String newServerPodName = domainUid + \"-config-server1\";\n+    checkPodCreated(newServerPodName, domainUid, domainNamespace);\n+    checkPodReady(newServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(newServerPodName, domainNamespace);\n+\n+    // Check if the admin server pod has been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    checkPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime);\n+\n+    // Check if the managed server pods have been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    \n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodRestarted(managedServerPrefix + 1, domainUid, \n+           domainNamespace, managedServerPodOriginalTimestampList.get(i - 1));\n+    }\n+\n+    boolean isServerConfigured = checkManagedServerConfiguration(\"config-server1\");\n+    assertTrue(isServerConfigured, \"Could not find new managed server configuration\");\n+    logger.info(\"Found new managed server configuration\");\n+\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzODM0Nw=="}, "originalCommit": {"oid": "47e999c250c8ce606710d6daea9610cb16fd99f6"}, "originalPosition": 676}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4NzAzMg==", "bodyText": "I do not delete the image. Should I remove the @afterall method entitely or it is not affective even if I keep it.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r427587032", "createdAt": "2020-05-19T20:42:05Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,879 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static final String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+  }\n+\n+  /**\n+   * Patch the domain resource with the configmap to add a cluster.\n+   * Update the restart version of the domain resource to 4\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are not in running state, because the spec level replica count to zero(default)\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Add a cluster to model in image domain with default replica count\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiClusteriWithNoReplica() {\n+\n+    // This test uses the WebLogic domain created in BeforeAll method\n+    // BeforeEach method ensures that the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.config.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"noreplicaconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.config.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Can't create ConfigMap %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // get the creation time of the admin server pod before patching\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodCreationTime);\n+\n+    // get the creation time of the managed server pods before patching\n+    List<String> managedServerPodOriginalTimestampList = new ArrayList<>();\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            managedServerPodOriginalTimestampList.add(creationTime);\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"4\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+\n+    // Check if the admin server pod has been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    checkPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime);\n+\n+    // Check if the managed server pods have been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodRestarted(managedServerPrefix + 1, domainUid, \n+           domainNamespace, managedServerPodOriginalTimestampList.get(i - 1));\n+    }\n+\n+    // The ServerNamePrefix for the new configured cluster is config-server\n+    // Make sure the managed server from new cluster is not running\n+\n+    String newServerPodName = domainUid + \"-config-server1\";\n+    checkPodNotCreated(newServerPodName, domainUid, domainNamespace);\n+\n+    boolean isServerConfigured = checkManagedServerConfiguration(\"config-server1\");\n+    assertTrue(isServerConfigured, \"Could not find new managed server configuration\");\n+    logger.info(\"Found new managed server configuration\");\n+  }\n+\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+\n+    // This test uses the WebLogic domain created in BeforeAll method\n+    // BeforeEach method ensures that the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Can't create ConfigMap %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // get the creation time of the admin server pod before patching\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodCreationTime);\n+\n+    // get the creation time of the managed server pods before patching\n+    List<String> managedServerPodOriginalTimestampList = new ArrayList<>();\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            managedServerPodOriginalTimestampList.add(creationTime);\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+\n+    // Check if the admin server pod has been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    checkPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime);\n+\n+    // Check if the managed server pods have been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodRestarted(managedServerPrefix + 1, domainUid, \n+           domainNamespace, managedServerPodOriginalTimestampList.get(i - 1));\n+    }\n+\n+    // The ServerNamePrefix for the new dynamic cluster is dynamic-server\n+    // Make sure the managed server from the new cluster is running\n+    \n+    String newServerPodName = domainUid + \"-dynamic-server1\";\n+    checkPodCreated(newServerPodName, domainUid, domainNamespace);\n+    checkPodReady(newServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(newServerPodName, domainNamespace);\n+\n+    boolean isServerConfigured = checkManagedServerConfiguration(\"dynamic-server1\");\n+    assertTrue(isServerConfigured, \"Could not find new managed server configuration\");\n+    logger.info(\"Found new managed server configuration\");\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a configured cluster.\n+   * Patch the domain resource with the configmap.\n+   * Update the restart version of the domain resource to 3\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"Add a configured cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiConfiguredCluster() {\n+ \n+    // This test uses the WebLogic domain created in BeforeAll method\n+    // BeforeEach method ensures that the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.config.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"configclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.config.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Can't create ConfigMap %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // get the creation time of the admin server pod before patching\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"Domain {0} in namespace {1}, admin server pod {2} creationTimestamp before patching is {3}\",\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        adminPodCreationTime);\n+\n+    // get the creation time of the managed server pods before patching\n+    List<String> managedServerPodOriginalTimestampList = new ArrayList<>();\n+    assertDoesNotThrow(\n+        () -> { \n+          for (int i = 1; i <= replicaCount; i++) {\n+            String managedServerPodName = managedServerPrefix + i;\n+            String creationTime = getPodCreationTimestamp(domainNamespace,\"\", managedServerPodName);\n+            managedServerPodOriginalTimestampList.add(creationTime);\n+            logger.info(\"Domain {0} in namespace {1}, managed server pod {2} creationTimestamp before patching is {3}\",\n+                domainUid,\n+                domainNamespace,\n+                managedServerPodName,\n+                creationTime);\n+          } \n+        },\n+        String.format(\"Failed to get creationTimestamp for managed server pods\"));\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"3\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+\n+    // The ServerNamePrefix for the new configured cluster is config-server\n+    // Make sure the managed server from the new cluster is running\n+    \n+    String newServerPodName = domainUid + \"-config-server1\";\n+    checkPodCreated(newServerPodName, domainUid, domainNamespace);\n+    checkPodReady(newServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(newServerPodName, domainNamespace);\n+\n+    // Check if the admin server pod has been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    checkPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime);\n+\n+    // Check if the managed server pods have been restarted \n+    // by comparing the PodCreationTime before and after rolling restart\n+    \n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodRestarted(managedServerPrefix + 1, domainUid, \n+           domainNamespace, managedServerPodOriginalTimestampList.get(i - 1));\n+    }\n+\n+    boolean isServerConfigured = checkManagedServerConfiguration(\"config-server1\");\n+    assertTrue(isServerConfigured, \"Could not find new managed server configuration\");\n+    logger.info(\"Found new managed server configuration\");\n+\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzODM0Nw=="}, "originalCommit": {"oid": "47e999c250c8ce606710d6daea9610cb16fd99f6"}, "originalPosition": 676}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Mjc0MTgwOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxOToxOTo0NVrOGXvH4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxOToyNzoyMlrOGXvYtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU0MjQ5OQ==", "bodyText": "If the test data source fails, what http response code do you get?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r427542499", "createdAt": "2020-05-19T19:19:45Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -321,25 +346,80 @@ public void testCreateMiiConfigMapDomain() {\n     }\n \n     int adminServiceNodePort = getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n-    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    ExecResult result = null;\n+    checkJdbc = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+    checkJdbc.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+         .append(\"/management/weblogic/latest/domainConfig\")\n+         .append(\"/JDBCSystemResources/TestDataSource/\")\n+         .append(\" --silent --show-error \")\n+         .append(\" -o /dev/null \")\n+         .append(\" -w %{http_code});\")\n+         .append(\"echo ${status}\");\n+    logger.info(\"CheckJdbc: curl command {0}\", new String(checkJdbc));\n+    try {\n+      result = exec(new String(checkJdbc), true);\n+    } catch (Exception ex) {\n+      logger.info(\"CheckJdbc: caught unexpected exception {0}\", ex);\n+      fail(\"CheckJdbc:  got unexpected exception\" + ex);\n+    }\n+    logger.info(\"CheckJdbc: curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"DataSource configuration not found\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47e999c250c8ce606710d6daea9610cb16fd99f6"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU0NjgwNA==", "bodyText": "It returns 404", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1662#discussion_r427546804", "createdAt": "2020-05-19T19:27:22Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -321,25 +346,80 @@ public void testCreateMiiConfigMapDomain() {\n     }\n \n     int adminServiceNodePort = getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n-    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    ExecResult result = null;\n+    checkJdbc = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+    checkJdbc.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+         .append(\"/management/weblogic/latest/domainConfig\")\n+         .append(\"/JDBCSystemResources/TestDataSource/\")\n+         .append(\" --silent --show-error \")\n+         .append(\" -o /dev/null \")\n+         .append(\" -w %{http_code});\")\n+         .append(\"echo ${status}\");\n+    logger.info(\"CheckJdbc: curl command {0}\", new String(checkJdbc));\n+    try {\n+      result = exec(new String(checkJdbc), true);\n+    } catch (Exception ex) {\n+      logger.info(\"CheckJdbc: caught unexpected exception {0}\", ex);\n+      fail(\"CheckJdbc:  got unexpected exception\" + ex);\n+    }\n+    logger.info(\"CheckJdbc: curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"DataSource configuration not found\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU0MjQ5OQ=="}, "originalCommit": {"oid": "47e999c250c8ce606710d6daea9610cb16fd99f6"}, "originalPosition": 134}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4580, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}